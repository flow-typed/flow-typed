/**
 * Flowtype definitions for angular-protractor
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare
var npm$namespace$protractor: {
    wrapDriver: typeof protractor$wrapDriver,
}
declare class ActionSequence mixins webdriver.ActionSequence {}

declare class Builder mixins webdriver.Builder {}

declare class Capabilities mixins webdriver.Capabilities {}

declare class Command mixins webdriver.Command {}

declare class EventEmitter mixins webdriver.EventEmitter {}

declare class Session mixins webdriver.Session {}

declare class WebDriver mixins webdriver.WebDriver {}

declare class WebElement mixins webdriver.WebElement {}

declare class WebElementPromise mixins webdriver.WebElementPromise {}

declare
var Browser: webdriver.IBrowser;

declare
var Button: webdriver.IButton;

declare
var Capability: webdriver.ICapability;

declare
var CommandName: webdriver.ICommandName;

declare
var Key: webdriver.IKey;

declare class Error mixins undefined.Error {}

declare
var ErrorCode: undefined.IErrorCode;


declare
var npm$namespace$logging: {
    getLevel: typeof logging$getLevel,
}
declare class Preferences mixins undefined.Preferences {}

declare class Entry mixins undefined.Entry {}

declare
var Type: undefined.IType;

declare
var Level: undefined.ILevelValues;

declare
function logging$getLevel(nameOrValue: string): undefined.ILevel


declare
var npm$namespace$promise: {
    all: typeof promise$all,
    asap: typeof promise$asap,
    controlFlow: typeof promise$controlFlow,
    createFlow: typeof promise$createFlow,
    isPromise: typeof promise$isPromise,
    isGenerator: typeof promise$isGenerator,
    delayed: typeof promise$delayed,
    filter: typeof promise$filter,
    defer: typeof promise$defer,
    fulfilled: typeof promise$fulfilled,
    map: typeof promise$map,
    rejected: typeof promise$rejected,
    checkedNodeCall: typeof promise$checkedNodeCall,
    consume: typeof promise$consume,
    when: typeof promise$when,
    fullyResolved: typeof promise$fullyResolved,
    setDefaultFlow: typeof promise$setDefaultFlow,
}
declare class Thenable<T>mixins undefined.Thenable<T>{}

declare class Promise<T>mixins undefined.Promise<T>{}

declare class Deferred<T>mixins undefined.Deferred<T>{}

declare class ControlFlow mixins undefined.ControlFlow {}

declare class CancellationError mixins undefined.CancellationError {}


/**
 * Given an array of promises, will return a promise that will be fulfilled
 * with the fulfillment values of the input array's values. If any of the
input array's promises are rejected, the returned promise will be rejected
with the same reason.
 * @param  An array of
promises to wait on.
 * @return  A promise that is
fulfilled with an array containing the fulfilled values of the
input array, or rejected with the same reason as the first
rejected value.
 * @template  
*/
declare
function promise$all(arr: undefined.Promise<any>[]): undefined.Promise<any[] >


    /**
     * Invokes the appropriate callback function as soon as a promised
     * {
     * @code  value} is resolved. This function is similar to
    {
     * @link  webdriver.promise.when}, except it does not return a new promise.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
    */
    declare
function promise$asap(value: any, callback: Function, opt_errback?: Function): void


/**
 * 
 * @return  The currently active control flow.
 */
declare
function promise$controlFlow(): undefined.ControlFlow


/**
 * Creates a new control flow. The provided callback will be invoked as the
 * first task within the new flow, with the flow as its sole argument. Returns
a promise that resolves to the callback result.
 * @param  The entry point
to the newly created flow.
 * @return  A promise that resolves to the callback
result.
*/
declare
function promise$createFlow<R>(callback: (flow: undefined.ControlFlow) => R): undefined.Promise<R >


    /**
     * Determines whether a {@code value} should be treated as a promise.
     * Any object whose "then" property is a function will be considered a promise.
     * @param  The value to test.
     * @return  Whether the value is a promise.
     */
    declare
function promise$isPromise(value: any): boolean


/**
 * Tests is a function is a generator.
 * @param  The function to test.
 * @return  Whether the function is a generator.
 */
declare
function promise$isGenerator(fn: Function): boolean


/**
 * Creates a promise that will be resolved at a set time in the future.
 * @param  The amount of time, in milliseconds, to wait before
resolving the promise.
 * @return  The promise.
*/
declare
function promise$delayed(ms: number): undefined.Promise<void >


    /**
     * Calls a function for each element in an array, and if the function returns
     * true adds the element to a new array.

    <p>If the return value of the filter function is a promise, this function
    will wait for it to be fulfilled before determining whether to insert the
    element into the new array.

    <p>If the filter function throws or returns a rejected promise, the promise
    returned by this function will be rejected with the same reason. Only the
    first failure will be reported; all subsequent errors will be silently
    ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  |webdriver.promise.Promise.<boolean>)} fn The function
    to call for each element in the array.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare
function promise$filter<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): undefined.Promise<T[] >


    /**
     * Creates a new deferred object.
     * @return  The new deferred object.
     */
    declare
function promise$defer<T>(): undefined.Deferred<T >


    /**
     * Creates a promise that has been resolved with the given value.*=} opt_value The resolved value.
     * @return  The resolved promise.
     */
    declare
function promise$fulfilled<T>(opt_value?: T): undefined.Promise<T >


    /**
     * Calls a function for each element in an array and inserts the result into a
     * new array, which is used as the fulfillment value of the promise returned
    by this function.

    <p>If the return value of the mapping function is a promise, this function
    will wait for it to be fulfilled before inserting it into the new array.

    <p>If the mapping function throws or returns a rejected promise, the
    promise returned by this function will be rejected with the same reason.
    Only the first failure will be reported; all subsequent errors will be
    silently ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  The
    function to call for each element in the array. This function should
    expect three arguments (the element, the index, and the array itself.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare
function promise$map<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): undefined.Promise<T[] >


    /**
     * Creates a promise that has been rejected with the given reason.*=} opt_reason The rejection reason; may be any value, but is
     *     usually an Error or a string.
     * @return  The rejected promise.
     */
    declare
function promise$rejected(opt_reason?: any): undefined.Promise<void >


    /**
     * Wraps a function that is assumed to be a node-style callback as its final
     * argument. This callback takes two arguments: an error value (which will be
    null if the call succeeded), and the success value as the second argument.
    If the call fails, the returned promise will be rejected, otherwise it will
    be resolved with the result.
     * @param  The function to wrap.
     * @return  A promise that will be resolved with the
    result of the provided function's callback.
    */
    declare
function promise$checkedNodeCall<T>(fn: Function, ...var_args: any[]): undefined.Promise<T >


    /**
     * Consumes a {@code GeneratorFunction}. Each time the generator yields a
     * promise, this function will wait for it to be fulfilled before feeding the
    fulfilled value back into {@code next}. Likewise, if a yielded promise is
    rejected, the rejection error will be passed to {@code throw}.

    <p>Example 1: the Fibonacci Sequence.
    <pre><code>
    webdriver.promise.consume(function fibonacci() {
       var n1 = 1, n2 = 1;
       for (var i = 0; i<4; ++i) {
         var tmp = yield n1 + n2;
         n1 = n2;
         n2 = tmp;
       }
       return n1 + n2;
    }).then(function(result) {
       console.log(result);  // 13
    });
    </code></pre>

    <p>Example 2: a generator that throws.
    <pre><code>
    webdriver.promise.consume(function () {
       yield webdriver.promise.delayed(250).then(function() {
         throw Error('boom');
       });
    }).thenCatch(function(e) {
       console.log(e.toString());  // Error: boom
    });
    </code></pre>
     * @param  The generator function to execute.
     * @param  The object to use as "this" when invoking the
    initial generator.
     * @param  Any arguments to pass to the initial generator.
     * @return  A promise that will resolve to the
    generator's final result.
     * @throws  {TypeError} If the given function is not a generator.
    */
    declare
function promise$consume<T>(
        generatorFn: Function,
        opt_self?: any,
        ...var_args: any[]): undefined.Promise<T >


    /**
     * Registers an observer on a promised {@code value}, returning a new promise
     * that will be resolved when the value is. If {@code value} is not a promise,
    then the return promise will be immediately resolved.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
     * @return  A new promise.
    */
    declare
function promise$when<T, R>(
        value: T,
        opt_callback?: (value: T) => any,
        opt_errback?: (error: any) => any): undefined.Promise<R >


    /**
     * Returns a promise that will be resolved with the input value in a
     * fully-resolved state. If the value is an array, each element will be fully
    resolved. Likewise, if the value is an object, all keys will be fully
    resolved. In both cases, all nested arrays and objects will also be
    fully resolved.  All fields are resolved in place; the returned promise will
    resolve on {@code value} and not a copy.

    Warning: This function makes no checks against objects that contain
    cyclical references:

       var value = {};
       value['self'] = value;
       webdriver.promise.fullyResolved(value);  // Stack overflow.
     * @param  The value to fully resolve.
     * @return  A promise for a fully resolved version
    of the input value.
    */
    declare
function promise$fullyResolved<T>(value: any): undefined.Promise<T >


    /**
     * Changes the default flow to use when no others are active.
     * @param  The new default flow.
     * @throws  {Error} If the default flow is not currently active.
     */
    declare
function promise$setDefaultFlow(flow: undefined.ControlFlow): void


declare
var npm$namespace$stacktrace: {
    format: typeof stacktrace$format,
    get: typeof stacktrace$get,
}
declare class Frame mixins undefined.Frame {}

declare class Snapshot mixins undefined.Snapshot {}


/**
 * Formats an error's stack trace.
 * @param  The error to format.
 * @return  The formatted error.
 */
declare
function stacktrace$format(error: any): any


/**
 * Gets the native stack trace if available otherwise follows the call chain.
 * The generated trace will exclude all frames up to and including the call to
this function.
 * @return  The frames of the stack trace.
*/
declare
function stacktrace$get(): undefined.Frame[]

declare
var BROWSER_SUPPORTED: boolean;


declare
var npm$namespace$until: {
    ableToSwitchToFrame: typeof until$ableToSwitchToFrame,
    alertIsPresent: typeof until$alertIsPresent,
    elementIsDisabled: typeof until$elementIsDisabled,
    elementIsEnabled: typeof until$elementIsEnabled,
    elementIsNotSelected: typeof until$elementIsNotSelected,
    elementIsNotVisible: typeof until$elementIsNotVisible,
    elementIsSelected: typeof until$elementIsSelected,
    elementIsVisible: typeof until$elementIsVisible,
    elementLocated: typeof until$elementLocated,
    elementTextContains: typeof until$elementTextContains,
    elementTextIs: typeof until$elementTextIs,
    elementTextMatches: typeof until$elementTextMatches,
    elementsLocated: typeof until$elementsLocated,
    stalenessOf: typeof until$stalenessOf,
    titleContains: typeof until$titleContains,
    titleIs: typeof until$titleIs,
    titleMatches: typeof until$titleMatches,
}
declare class Condition<T>mixins undefined.Condition<T>{}


/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as:
<ol>
   <li>A numeric index into {@code window.frames} for the currently selected
       frame.
   <li>A {@link webdriver.WebElement}, which must reference a FRAME or IFRAME
       element on the current page.
   <li>A locator which may be used to first locate a FRAME or IFRAME on the
       current page before attempting to switch to it.
</ol>

<p>Upon successful resolution of this condition, the driver will be left
focused on the new frame.
 * @param  .Locator|webdriver.By.Hash|
function(!webdriver.WebDriver): !webdriver.WebElement)} frame
The frame identifier.
 * @return  A new condition.
*/
declare
function until$ableToSwitchToFrame(frame: number): undefined.Condition<boolean >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  The new condition.
     */
    declare
function until$alertIsPresent(): undefined.Condition<webdriver.Alert >


    /**
     * Creates a condition that will wait for the given element to be disabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare
function until$elementIsDisabled(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be enabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare
function until$elementIsEnabled(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be deselected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare
function until$elementIsNotSelected(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be in the DOM,
     * yet not visible to the user.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare
function until$elementIsNotVisible(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be selected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare
function until$elementIsSelected(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to become visible.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare
function until$elementIsVisible(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will loop until an element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new condition.
    */
    declare
function until$elementLocated(locator: webdriver.Locator): undefined.Condition<webdriver.IWebElement >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to contain the given
    substring.
     * @param  The element to test.
     * @param  The substring to search for.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare
function until$elementTextContains(element: webdriver.IWebElement, substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match the given
    {
     * @code  text} exactly.
     * @param  The element to test.
     * @param  The expected text.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare
function until$elementTextIs(element: webdriver.IWebElement, text: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match a regular
    expression.
     * @param  The element to test.
     * @param  The regular expression to test against.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare
function until$elementTextMatches(element: webdriver.IWebElement, regex: RegExp): undefined.Condition<boolean >


    /**
     * Creates a condition that will loop until at least one element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new
    condition.
    */
    declare
function until$elementsLocated(locator: webdriver.Locator): undefined.Condition<webdriver.IWebElement[] >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  The new condition.
    */
    declare
function until$stalenessOf(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare
function until$titleContains(substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  The new condition.
     */
    declare
function until$titleIs(title: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given regular expression.
     * @param  The regular expression to test against.
     * @return  The new condition.
     */
    declare
function until$titleMatches(regex: RegExp): undefined.Condition<boolean >


    declare
var npm$namespace$ExpectedConditions: {
        not: typeof ExpectedConditions$not,
        and: typeof ExpectedConditions$and,
        or: typeof ExpectedConditions$or,
        alertIsPresent: typeof ExpectedConditions$alertIsPresent,
        elementToBeClickable: typeof ExpectedConditions$elementToBeClickable,
        textToBePresentInElement: typeof ExpectedConditions$textToBePresentInElement,
        textToBePresentInElementValue: typeof ExpectedConditions$textToBePresentInElementValue,
        titleContains: typeof ExpectedConditions$titleContains,
        titleIs: typeof ExpectedConditions$titleIs,
        presenceOf: typeof ExpectedConditions$presenceOf,
        stalenessOf: typeof ExpectedConditions$stalenessOf,
        visibilityOf: typeof ExpectedConditions$visibilityOf,
        invisibilityOf: typeof ExpectedConditions$invisibilityOf,
        elementToBeSelected: typeof ExpectedConditions$elementToBeSelected,
    }
    /**
     * Negates the result of a promise.<boolean>} expectedCondition
     * @return  <boolean>} An expected condition that returns the negated value.
     */
declare
function ExpectedConditions$not<T>(expectedCondition: undefined.Condition<T>): undefined.Condition<T >


    /**
     * Chain a number of expected conditions using logical_and, short circuiting at the
     * first expected condition that evaluates to false.<boolean>[]} fns An array of expected conditions to 'and' together.
     * @return  <boolean>} An expected condition that returns a promise which evaluates
    to the result of the logical and.
    */
    declare
function ExpectedConditions$and<T>(...fns: undefined.Condition<T>[]): undefined.Condition<T >


    /**
     * Chain a number of expected conditions using logical_or, short circuiting at the
     * first expected condition that evaluates to true.<boolean>[]} fns An array of expected conditions to 'or' together.
     * @return  <boolean>} An expected condition that returns a promise which
    evaluates to the result of the logical or.
    */
    declare
function ExpectedConditions$or<T>(...fns: undefined.Condition<T>[]): undefined.Condition<T >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  The new condition.
     */
    declare
function ExpectedConditions$alertIsPresent(): undefined.Condition<webdriver.Alert >


    /**
     * An Expectation for checking an element is visible and enabled such that you can click it.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is clickable.
    */
    declare
function ExpectedConditions$elementToBeClickable<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking if the given text is present in the element.
     * Returns false if the elementFinder does not find an element.
     * @param  The element to check
     * @param  The text to verify against
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the text is present in the element.
    */
    declare
function ExpectedConditions$textToBePresentInElement<T>(element: protractor$ElementFinder, text: string): undefined.Condition<T >


    /**
     * An expectation for checking if the given text is present in the elementâ€™s value.
     * Returns false if the elementFinder does not find an element.
     * @param  The element to check
     * @param  The text to verify against
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the text is present in the element's value.
    */
    declare
function ExpectedConditions$textToBePresentInElementValue<T>(element: protractor$ElementFinder, text: string): undefined.Condition<T >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare
function ExpectedConditions$titleContains(substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  The new condition.
     */
    declare
function ExpectedConditions$titleIs(title: string): undefined.Condition<boolean >


    /**
     * An expectation for checking that an element is present on the DOM of a page. This does not necessarily
     * mean that the element is visible. This is the opposite of 'stalenessOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise
    representing whether the element is present.
    */
    declare
function ExpectedConditions$presenceOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  The new condition.
    */
    declare
function ExpectedConditions$stalenessOf(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * An expectation for checking that an element is present on the DOM of a page and visible.
     * Visibility means that the element is not only displayed but also has a height and width that is
    greater than 0. This is the opposite of 'invisibilityOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is visible.
    */
    declare
function ExpectedConditions$visibilityOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking that an element is present on the DOM of a page. This does not necessarily
     * mean that the element is visible. This is the opposite of 'stalenessOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is invisible.
    */
    declare
function ExpectedConditions$invisibilityOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking the selection is selected.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is selected.
    */
    declare
function ExpectedConditions$elementToBeSelected<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * Use as: element(locator)
     * 
    The ElementFinder can be treated as a WebElement for most purposes, in
    particular, you may perform actions (i.e. click, getText) on them as you
    would a WebElement. ElementFinders extend Promise, and once an action
    is performed on an ElementFinder, the latest result from the chain can be
    accessed using then. Unlike a WebElement, an ElementFinder will wait for
    angular to settle before performing finds or actions.

    ElementFinder can be used to build a chain of locators that is used to find
    an element. An ElementFinder does not actually attempt to find the element
    until an action is called, which means they can be set up in helper files
    before the page is available.
     * @param  An element locator.
     * @return  
    */
    declare interface protractor$Element {
        (locator: webdriver.Locator): protractor$ElementFinder,

        /**
         * ElementArrayFinder is used for operations on an array of elements (as opposed
         * to a single element).
         * @param  An element locator.
         * @return  
         */
        all(locator: webdriver.Locator): protractor$ElementArrayFinder
    }

declare type protractor$ElementFinder = {

        /**
         * Calls to element may be chained to find elements within a parent.
         * @alias  element(locator).element(locator)
         * @view  * <div class="parent">
        <div class="child">
        Child text
        <div>{{person.phone}}</div>
        </div>
        </div>
         * @example  * // Chain 2 element calls.
        var child = element(by.css('.parent')).
        element(by.css('.child'));
        expect(child.getText()).toBe('Child text\n555-123-4567');

        // Chain 3 element calls.
        var triple = element(by.css('.parent')).
        element(by.css('.child')).
        element(by.binding('person.phone'));
        expect(triple.getText()).toBe('555-123-4567');
         * @param  
         * @return  
        */
        element(subLocator: webdriver.Locator): protractor$ElementFinder,

        /**
         * Calls to element may be chained to find an array of elements within a parent.
         * @alias  element(locator).all(locator)
         * @view  * <div class="parent">
        <ul>
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
        </div>
         * @example  * var items = element(by.css('.parent')).all(by.tagName('li'))
         * @param  
         * @return  
        */
        all(subLocator: webdriver.Locator): protractor$ElementArrayFinder,

        /**
         * Shortcut for querying the document directly with css.
         * @alias  $(cssSelector)
         * @view  * <div class="count">
        <span class="one">First</span>
        <span class="two">Second</span>
        </div>
         * @example  * var item = $('.count .two');
        expect(item.getText()).toBe('Second');
         * @param  A css selector
         * @return  which identifies the located
        {
         * @link  webdriver.WebElement}
        */
        $(selector: string): protractor$ElementFinder,

        /**
         * Shortcut for querying the document directly with css.
         * @alias  $$(cssSelector)
         * @view  * <div class="count">
        <span class="one">First</span>
        <span class="two">Second</span>
        </div>
         * @example  * // The following protractor expressions are equivalent.
        var list = element.all(by.css('.count span'));
        expect(list.count()).toBe(2);

        list = $$('.count span');
        expect(list.count()).toBe(2);
        expect(list.get(0).getText()).toBe('First');
        expect(list.get(1).getText()).toBe('Second');
         * @param  a css selector
         * @return  which identifies the
        array of the located {
         * @link  webdriver.WebElement}s.
        */
        $$(selector: string): protractor$ElementArrayFinder,

        /**
         * Determine whether the element is present on the page.
         * @view  * <span>{{person.name}}</span>
         * @example  * // Element exists.
        expect(element(by.binding('person.name')).isPresent()).toBe(true);

        // Element not present.
        expect(element(by.binding('notPresent')).isPresent()).toBe(false);
         * @return  which resolves to whether
        the element is present on the page.
        */
        isPresent(): undefined.Promise<boolean>,

        /**
         * Override for WebElement.prototype.isElementPresent so that protractor waits
         * for Angular to settle before making the check.
         * @see  ElementFinder.isPresent
         * @param  Locator for element to look for.
         * @return  which resolves to whether
        the element is present on the page.
        */
        isElementPresent(subLocator: webdriver.Locator): undefined.Promise<boolean>,

        /**
         * 
         * @see  ElementArrayFinder.prototype.locator
         * @return  
         */
        locator(): webdriver.Locator,

        /**
         * Returns the WebElement represented by this ElementFinder.
         * Throws the WebDriver error if the element doesn't exist.
         * @example  *  The following three expressions are equivalent.
        element(by.css('.parent')).getWebElement();
        browser.waitForAngular(); browser.driver.findElement(by.css('.parent'));
        browser.findElement(by.css('.parent'));
         * @alias  element(locator).getWebElement()
         * @return  
        */
        getWebElement(): webdriver.WebElement,

        /**
         * Evaluates the input as if it were on the scope of the current element.
         * @see  ElementArrayFinder.evaluate
         * @param  
         * @return  which resolves to the evaluated expression.
         */
        evaluate(expression: string): protractor$ElementFinder,

        /**
         * 
         * @see  ElementArrayFinder.prototype.allowAnimations.
         * @param  
         * @return  which resolves to whether animation is allowed.
         */
        allowAnimations(value: string): protractor$ElementFinder,

        /**
         * Create a shallow copy of ElementFinder.
         * @return  A shallow copy of this.
         */
        clone(): protractor$ElementFinder
    } & &


    declare type protractor$ElementArrayFinder = {

        /**
         * Returns the elements as an array of WebElements.
         */
        getWebElements(): webdriver.WebElement[],

        /**
         * Get an element within the ElementArrayFinder by index. The index starts at 0.
         * Negative indices are wrapped (i.e. -i means ith element from last)
        This does not actually retrieve the underlying element.
         * @alias  element.all(locator).get(index)
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var list = element.all(by.css('.items li'));
        expect(list.get(0).getText()).toBe('First');
        expect(list.get(1).getText()).toBe('Second');
         * @param  Element index.
         * @return  finder representing element at the given index.
        */
        get(index: number): protractor$ElementFinder,

        /**
         * Get the first matching element for the ElementArrayFinder. This does not
         * actually retrieve the underlying element.
         * @alias  element.all(locator).first()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var first = element.all(by.css('.items li')).first();
        expect(first.getText()).toBe('First');
         * @return  finder representing the first matching element
        */
        first(): protractor$ElementFinder,

        /**
         * Get the last matching element for the ElementArrayFinder. This does not
         * actually retrieve the underlying element.
         * @alias  element.all(locator).last()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var last = element.all(by.css('.items li')).last();
        expect(last.getText()).toBe('Third');
         * @return  finder representing the last matching element
        */
        last(): protractor$ElementFinder,

        /**
         * Count the number of elements represented by the ElementArrayFinder.
         * @alias  element.all(locator).count()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var list = element.all(by.css('.items li'));
        expect(list.count()).toBe(3);
         * @return  A promise which resolves to the
        number of elements matching the locator.
        */
        count(): undefined.Promise<number>,

        /**
         * Calls the input function on each ElementFinder represented by the ElementArrayFinder.
         * @alias  element.all(locator).each(eachFunction)
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * element.all(by.css('.items li')).each(function(element) {
        // Will print First, Second, Third.
        element.getText().then(console.log);
        });
         * @param  Input function
        */
        each(fn: (element: protractor$ElementFinder, index: number) => void): void,

        /**
         * Apply a map function to each element within the ElementArrayFinder. The
         * callback receives the ElementFinder as the first argument and the index as
        a second arg.
         * @alias  element.all(locator).map(mapFunction)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * var items = element.all(by.css('.items li')).map(function(elm, index) {
        return {
        index: index,
        text: elm.getText(),
        class: elm.getAttribute('class')
        };
        });
        expect(items).toEqual([
        {index: 0, text: 'First', class: 'one'},
        {index: 1, text: 'Second', class: 'two'},
        {index: 2, text: 'Third', class: 'three'}
        ]);
         * @param  Map function that
        will be applied to each element.
         * @return  A promise that resolves to an array
        of values returned by the map function.
        */
        map<T>(
            mapFn: (element: protractor$ElementFinder, index: number) => T): undefined.Promise<T[]>,
        map<T,
        T2>(
            mapFn: (element: protractor$ElementFinder, index: number) => T2): undefined.Promise<T[]>,

        /**
         * Apply a filter function to each element within the ElementArrayFinder. Returns
         * a new ElementArrayFinder with all elements that pass the filter function. The
        filter function receives the ElementFinder as the first argument
        and the index as a second arg.
        This does not actually retrieve the underlying list of elements, so it can
        be used in page objects.
         * @alias  element.all(locator).filter(filterFn)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * element.all(by.css('.items li')).filter(function(elem, index) {
        return elem.getText().then(function(text) {
        return text === 'Third';
        });
        }).then(function(filteredElements) {
        filteredElements[0].click();
        });
         * @param  Filter function that will test if an element should be returned.
        filterFn can either return a boolean or a promise that resolves to a boolean.
         * @return  A ElementArrayFinder that represents an array
        of element that satisfy the filter function.
        */
        filter(
            filterFn: (element: protractor$ElementFinder, index: number) => any): protractor$ElementArrayFinder,

        /**
         * Apply a reduce function against an accumulator and every element found
         * using the locator (from left-to-right). The reduce function has to reduce
        every element into a single value (the accumulator). Returns promise of
        the accumulator. The reduce function receives the accumulator, current
        ElementFinder, the index, and the entire array of ElementFinders,
        respectively.reduceFn Reduce function that reduces every element into a single value.
         * @alias  element.all(locator).reduce(reduceFn)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * var value = element.all(by.css('.items li')).reduce(function(acc, elem) {
        return elem.getText().then(function(text) {
        return acc + text + ' ';
        });
        });

        expect(value).toEqual('First Second Third ');
         * @param  Initial value of the accumulator.
         * @return  A promise that resolves to the final
        value of the accumulator.
        */
        reduce<T>(
            reduceFn: (
                acc: T,
                element: protractor$ElementFinder,
                index: number,
                arr: protractor$ElementFinder[]) => undefined.Promise<T>,
            initialValue: T): undefined.Promise<T>,
        reduce<T>(
            reduceFn: (
                acc: T,
                element: protractor$ElementFinder,
                index: number,
                arr: protractor$ElementFinder[]) => T,
            initialValue: T): undefined.Promise<T>,

        /**
         * Represents the ElementArrayFinder as an array of ElementFinders.
         * @return  Return a promise, which resolves to a list
        of ElementFinders specified by the locator.
        */
        asElementFinders_(): undefined.Promise<protractor$ElementFinder[]>,

        /**
         * Create a shallow copy of ElementArrayFinder.
         * @return  A shallow copy of this.
         */
        clone(): protractor$ElementArrayFinder,

        /**
         * Calls to ElementArrayFinder may be chained to find an array of elements
         * using the current elements in this ElementArrayFinder as the starting point.
        This function returns a new ElementArrayFinder which would contain the
        children elements found (and could also be empty).
         * @alias  element.all(locator).all(locator)
         * @view  * <div id='id1' class="parent">
        <ul>
        <li class="foo">1a</li>
        <li class="baz">1b</li>
        </ul>
        </div>
        <div id='id2' class="parent">
        <ul>
        <li class="foo">2a</li>
        <li class="bar">2b</li>
        </ul>
        </div>
         * @example  * var foo = element.all(by.css('.parent')).all(by.css('.foo'))
        expect(foo.getText()).toEqual(['1a', '2a'])
        var baz = element.all(by.css('.parent')).all(by.css('.baz'))
        expect(baz.getText()).toEqual(['1b'])
        var nonexistent = element.all(by.css('.parent')).all(by.css('.NONEXISTENT'))
        expect(nonexistent.getText()).toEqual([''])
         * @param  
         * @return  
        */
        all(locator: webdriver.Locator): protractor$ElementArrayFinder,

        /**
         * Shorthand function for finding arrays of elements by css.
         * @type  
         */
        $$(selector: string): protractor$ElementArrayFinder,

        /**
         * Returns an ElementFinder representation of ElementArrayFinder. It ensures
         * that the ElementArrayFinder resolves to one and only one underlying element.
         * @return  An ElementFinder representation
         * @private  
         */
        toElementFinder_(): protractor$ElementFinder,

        /**
         * Returns the most relevant locator.
         * @example  * $('#ID1').locator() // returns by.css('#ID1')
        $('#ID1').$('#ID2').locator() // returns by.css('#ID2')
        $$('#ID1').filter(filterFn).get(0).click().locator() // returns by.css('#ID1')
         * @return  
        */
        locator(): webdriver.Locator,

        /**
         * Evaluates the input as if it were on the scope of the current underlying
         * elements.
         * @view  * <span id="foo">{{variableInScope}}</span>
         * @example  * var value = element(by.id('foo')).evaluate('variableInScope');
         * @param  
         * @return  which resolves to the
        evaluated expression for each underlying element.
        The result will be resolved as in
        {
         * @link  webdriver.WebDriver.executeScript}. In summary - primitives will
        be resolved as is, functions will be converted to string, and elements
        will be returned as a WebElement.
        */
        evaluate(expression: string): protractor$ElementArrayFinder,

        /**
         * Determine if animation is allowed on the current underlying elements.
         * @param  
         * @example  * // Turns off ng-animate animations for all elements in the <body>
        element(by.css('body')).allowAnimations(false);
         * @return  which resolves to whether animation is allowed.
        */
        allowAnimations(value: boolean): protractor$ElementArrayFinder,

        /**
         * Schedules a command to click on this element.
         * @return  A promise that will be resolved when
        the click command has completed.
        */
        click(): undefined.Promise<void>,

        /**
         * Schedules a command to type a sequence on the DOM element represented by this
         * instance.
        <p/>
        Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
        processed in the keysequence, that key state is toggled until one of the
        following occurs:
        <ul>
        <li>The modifier key is encountered again in the sequence. At this point the
        state of the key is toggled (along with the appropriate keyup/down events).
        </li>
        <li>The {@code webdriver.Key.NULL} key is encountered in the sequence. When
        this key is encountered, all modifier keys current in the down state are
        released (with accompanying keyup events). The NULL key can be used to
        simulate common keyboard shortcuts:
        <code>
             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");
        </code></li>
        <li>The end of the keysequence is encountered. When there are no more keys
        to type, all depressed modifier keys are released (with accompanying keyup
        events).
        </li>
        </ul>
        <strong>Note:</strong> On browsers where native keyboard events are not yet
        supported (e.g. Firefox on OS X), key events will be synthesized. Special
        punctionation keys will be synthesized according to a standard QWERTY en-us
        keyboard layout.
         * @param  The sequence of keys to
        type. All arguments will be joined into a single sequence (var_args is
        permitted for convenience).
         * @return  A promise that will be resolved when all
        keys have been typed.
        */
        sendKeys(...var_args: string[]): undefined.Promise<void>,

        /**
         * Schedules a command to query for the tag/node name of this element.
         * @return  A promise that will be resolved with the
        element's tag name.
        */
        getTagName(): undefined.Promise<string[]>,

        /**
         * Schedules a command to query for the computed style of the element
         * represented by this instance. If the element inherits the named style from
        its parent, the parent will be queried for its value.  Where possible, color
        values will be converted to their hex representation (e.g. #00ff00 instead of
        rgb(0, 255, 0)).
        <p/>
        <em>Warning:</em> the value returned will be as the browser interprets it, so
        it may be tricky to form a proper assertion.
         * @param  The name of the CSS style property to look
        up.
         * @return  A promise that will be resolved with the
        requested CSS value.
        */
        getCssValue(cssStyleProperty: string): undefined.Promise<string[]>,

        /**
         * Schedules a command to query for the value of the given attribute of the
         * element. Will return the current value even if it has been modified after the
        page has been loaded. More exactly, this method will return the value of the
        given attribute, unless that attribute is not present, in which case the
        value of the property with the same name is returned. If neither value is
        set, null is returned. The "style" attribute is converted as best can be to a
        text representation with a trailing semi-colon. The following are deemed to
        be "boolean" attributes and will be returned as thus:

        <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,
        defaultchecked, defaultselected, defer, disabled, draggable, ended,
        formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
        loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
        paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
        selected, spellcheck, truespeed, willvalidate

        <p>Finally, the following commonly mis-capitalized attribute/property names
        are evaluated as expected:
        <ul>
           <li>"class"
           <li>"readonly"
        </ul>
         * @param  The name of the attribute to query.
         * @return  A promise that will be resolved with the
        attribute's value.
        */
        getAttribute(attributeName: string): undefined.Promise<string[]>,

        /**
         * Get the visible (i.e. not hidden by CSS) innerText of this element, including
         * sub-elements, without any leading or trailing whitespace.
         * @return  A promise that will be resolved with the
        element's visible text.
        */
        getText(): undefined.Promise<string[]>,

        /**
         * Schedules a command to compute the size of this element's bounding box, in
         * pixels.
         * @return  A promise that will be resolved with the
        element's size as a {
         * @code  {width:number, height:number}} object.
        */
        getSize(): undefined.Promise<webdriver.ISize[]>,

        /**
         * Schedules a command to compute the location of this element in page space.
         * @return  A promise that will be resolved to the
        element's location as a {
         * @code  {x:number, y:number}} object.
        */
        getLocation(): undefined.Promise<webdriver.ILocation[]>,

        /**
         * Schedules a command to query whether the DOM element represented by this
         * instance is enabled, as dicted by the {@code disabled} attribute.
         * @return  A promise that will be resolved with
        whether this element is currently enabled.
        */
        isEnabled(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to query whether this element is selected.
         * @return  A promise that will be resolved with
        whether this element is currently selected.
        */
        isSelected(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to submit the form containing this element (or this
         * element if it is a FORM element). This command is a no-op if the element is
        not contained in a form.
         * @return  A promise that will be resolved when
        the form has been submitted.
        */
        submit(): undefined.Promise<void>,

        /**
         * Schedules a command to clear the {@code value} of this element. This command
         * has no effect if the underlying DOM element is neither a text INPUT element
        nor a TEXTAREA element.
         * @return  A promise that will be resolved when
        the element has been cleared.
        */
        clear(): undefined.Promise<void>,

        /**
         * Schedules a command to test whether this element is currently displayed.
         * @return  A promise that will be resolved with
        whether this element is currently visible on the page.
        */
        isDisplayed(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to retrieve the outer HTML of this element.
         * @return  A promise that will be resolved with
        the element's outer HTML.
        */
        getOuterHtml(): undefined.Promise<string[]>,

        /**
         * 
         * @return  A promise
        that resolves to this element's JSON representation as defined by the
        WebDriver wire protocol.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol
        */
        getId(): undefined.Promise<webdriver.IWebElementId[]>,

        /**
         * Schedules a command to retrieve the inner HTML of this element.
         * @return  A promise that will be resolved with the
        element's inner HTML.
        */
        getInnerHtml(): undefined.Promise<string[] >
    }

declare type protractor$LocatorWithColumn = {
    column(index: number): webdriver.Locator,
    column(name: string): webdriver.Locator
}

declare type protractor$RepeaterLocator = {
    row(index: number): protractor$LocatorWithColumn
} & protractor$LocatorWithColumn


declare interface protractor$IProtractorLocatorStrategy {

    /**
     * webdriver's By is an enum of locator functions, so we must set it to
     * a prototype before inheriting from it.
     */
    className: typeof undefined,
        css: typeof undefined,
        id: typeof undefined,
        linkText: typeof undefined,
        js: typeof undefined,
        name: typeof undefined,
        partialLinkText: typeof undefined,
        tagName: typeof undefined,
        xpath: typeof undefined,

        /**
         * Add a locator to this instance of ProtractorBy. This locator can then be
         * used with element(by.locatorName(args)).
         * @view  * <button ng-click="doAddition()">Go!</button>
         * @example  * // Add the custom locator.
        by.addLocator('buttonTextSimple',
        function(buttonText, opt_parentElement, opt_rootSelector) {
        // This function will be serialized as a string and will execute in the
        // browser. The first argument is the text for the button. The second
        // argument is the parent element, if any.
        var using = opt_parentElement,
        buttons = using.querySelectorAll('button');

        // Return an array of buttons with the text.
        return Array.prototype.filter.call(buttons, function(button) {
        return button.textContent === buttonText;
        });
        });

        // Use the custom locator.
        element(by.buttonTextSimple('Go!')).click();
         * @alias  by.addLocator(locatorName, functionOrScript)
         * @param  The name of the new locator.
         * @param  A script to be run in the context of
        the browser. This script will be passed an array of arguments
        that contains any args passed into the locator followed by the
        element scoping the search and the css selector for the root angular
        element. It should return an array of elements.
        */
        addLocator(name: string, script: string): void,
        addLocator(name: string, script: Function): void,

        /**
         * Find an element by binding.
         * @view  * <span>{{person.name}}</span>
        <span ng-bind="person.email"></span>
         * @example  * var span1 = element(by.binding('person.name'));
        expect(span1.getText()).toBe('Foo');

        var span2 = element(by.binding('person.email'));
        expect(span2.getText()).toBe('foo
         * @bar  .com');
         * @param  
         * @return  
        */
        binding(bindingDescriptor: string): webdriver.Locator,

        /**
         * Find an element by exact binding.
         * @view  * <span>{{ person.name }}</span>
        <span ng-bind="person-email"></span>
        <span>{{person_phone|uppercase}}</span>
         * @example  * expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person-email')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person')).isPresent()).toBe(false);
        expect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);
        expect(element(by.exactBinding('phone')).isPresent()).toBe(false);
         * @param  
         * @return  
        */
        exactBinding(bindingDescriptor: string): webdriver.Locator,

        /**
         * Find an element by ng-model expression.
         * @alias  by.model(modelName)
         * @view  * <input type="text" ng-model="person.name"/>
         * @example  * var input = element(by.model('person.name'));
        input.sendKeys('123');
        expect(input.getAttribute('value')).toBe('Foo123');
         * @param  ng-model expression.
        */
        model(model: string): webdriver.Locator,

        /**
         * Find a button by text.
         * @view  * <button>Save</button>
         * @example  * element(by.buttonText('Save'));
         * @param  
         * @return  
         */
        buttonText(searchText: string): webdriver.Locator,

        /**
         * Find a button by partial text.
         * @view  * <button>Save my file</button>
         * @example  * element(by.partialButtonText('Save'));
         * @param  
         * @return  
         */
        partialButtonText(searchText: string): webdriver.Locator,

        /**
         * Find elements inside an ng-repeat.
         * @view  * <div ng-repeat="cat in pets">
        <span>{{cat.name}}</span>
        <span>{{cat.age}}</span>
        </div>

        <div class="book-img" ng-repeat-start="book in library">
        <span>{{$index}}</span>
        </div>
        <div class="book-info" ng-repeat-end>
        <h4>{{book.name}}</h4>
        <p>{{book.blurb}}</p>
        </div>
         * @example  * // Returns the DIV for the second cat.
        var secondCat = element(by.repeater('cat in pets').row(1));

        // Returns the SPAN for the first cat's name.
        var firstCatName = element(by.repeater('cat in pets').
        row(0).column('{{cat.name}}'));

        // Returns a promise that resolves to an array of WebElements from a column
        var ages = element.all(
        by.repeater('cat in pets').column('{{cat.age}}'));

        // Returns a promise that resolves to an array of WebElements containing
        // all top level elements repeated by the repeater. For 2 pets rows resolves
        // to an array of 2 elements.
        var rows = element.all(by.repeater('cat in pets'));

        // Returns a promise that resolves to an array of WebElements containing all
        // the elements with a binding to the book's name.
        var divs = element.all(by.repeater('book in library').column('book.name'));

        // Returns a promise that resolves to an array of WebElements containing
        // the DIVs for the second book.
        var bookInfo = element.all(by.repeater('book in library').row(1));

        // Returns the H4 for the first book's name.
        var firstBookName = element(by.repeater('book in library').
        row(0).column('{{book.name}}'));

        // Returns a promise that resolves to an array of WebElements containing
        // all top level elements repeated by the repeater. For 2 books divs
        // resolves to an array of 4 elements.
        var divs = element.all(by.repeater('book in library'));
        */
        repeater(repeatDescriptor: string): protractor$RepeaterLocator,

        /**
         * Find elements by CSS which contain a certain string.
         * @view  * <ul>
        <li class="pet">Dog</li>
        <li class="pet">Cat</li>
        </ul>
         * @example  * // Returns the DIV for the dog, but not cat.
        var dog = element(by.cssContainingText('.pet', 'Dog'));
        */
        cssContainingText(cssSelector: string, searchText: string): webdriver.Locator,

        /**
         * Find an element by ng-options expression.
         * @alias  by.options(optionsDescriptor)
         * @view  * <select ng-model="color" ng-options="c for c in colors">
        <option value="0" selected="selected">red</option>
        <option value="1">green</option>
        </select>
         * @example  * var allOptions = element.all(by.options('c for c in colors'));
        expect(allOptions.count()).toEqual(2);
        var firstOption = allOptions.first();
        expect(firstOption.getText()).toEqual('red');
         * @param  ng-options expression.
        */
        options(optionsDescriptor: string): webdriver.Locator
}

declare
var By: protractor$IProtractorLocatorStrategy;

declare type protractor$Protractor = {

    /**
     * The wrapped webdriver instance. Use this to interact with pages that do
     * not contain Angular (such as a log-in screen).
     * @type  
     */
    driver: webdriver.WebDriver,

    /**
     * Helper function for finding elements.
     * @type  
     */
    element(locator: webdriver.Locator): protractor$ElementFinder,

    /**
     * Shorthand function for finding elements by css.
     * @type  
     */
    $(selector: string): protractor$ElementFinder,

    /**
     * Shorthand function for finding arrays of elements by css.
     * @type  
     */
    $$(selector: string): protractor$ElementArrayFinder,

    /**
     * All get methods will be resolved against this base URL. Relative URLs are =
     * resolved the way anchor tags resolve.
     * @type  
     */
    baseUrl: string,

    /**
     * The css selector for an element on which to find Angular. This is usually
     * 'body' but if your ng-app is on a subsection of the page it may be
    a subelement.
     * @type  
    */
    rootEl: string,

    /**
     * If true, Protractor will not attempt to synchronize with the page before
     * performing actions. This can be harmful because Protractor will not wait
    until $timeouts and $http calls have been processed, which can cause
    tests to become flaky. This should be used only when necessary, such as
    when a page continuously polls an API using $timeout.
     * @type  
    */
    ignoreSynchronization: boolean,

    /**
     * Timeout in milliseconds to wait for pages to load when calling `get`.
     * @type  
     */
    getPageTimeout: number,

    /**
     * An object that holds custom test parameters.
     * @type  
     */
    params: any,

    /**
     * The reset URL to use between page loads.
     * @type  
     */
    resetUrl: string,

    /**
     * Instruct webdriver to wait until Angular has finished rendering and has
     * no outstanding $http calls before continuing.
     * @return  A promise that will resolve to the
    scripts return value.
    */
    waitForAngular(): undefined.Promise<any>,

    /**
     * Add a module to load before Angular whenever Protractor.get is called.
     * Modules will be registered after existing modules already on the page,
    so any module registered here will override preexisting modules with the same
    name.
     * @example  * browser.addMockModule('modName', function() {
    angular.module('modName', []).value('foo', 'bar');
    });
     * @param  The name of the module to load or override.
     * @param  The JavaScript to load the module.
     * @param  Any additional arguments will be provided to
    the script and may be referenced using the `arguments` object.
    */
    addMockModule(name: string, script: string, ...varArgs: any[]): void,
    addMockModule(name: string, script: Function, ...varArgs: any[]): void,

    /**
     * Clear the list of registered mock modules.
     */
    clearMockModules(): void,

    /**
     * Remove a registered mock module.
     * @example  * browser.removeMockModule('modName');
     * @param  The name of the module to remove.
     */
    removeMockModule(name: string): void,

    /**
     * 
     * @see  webdriver.WebDriver.get

    Navigate to the given destination and loads mock modules before
    Angular. Assumes that the page being loaded uses Angular.
    If you need to access a page which does not have Angular on load, use
    the wrapped webdriver directly.
     * @param  Destination URL.
     * @param  Number of milliseconds to wait for Angular to
    start.
    */
    get(destination: string, opt_timeout?: number): undefined.Promise<void>,

    /**
     * See webdriver.WebDriver.refresh
     * 
    Makes a full reload of the current page and loads mock modules before
    Angular. Assumes that the page being loaded uses Angular.
    If you need to access a page which does not have Angular on load, use
    the wrapped webdriver directly.
     * @param  Number of seconds to wait for Angular to start.
    */
    refresh(opt_timeout?: number): undefined.Promise<void>,

    /**
     * Browse to another page using in-page navigation.
     * @param  In page URL using the same syntax as $location.url()
     * @returns  A promise that will resolve once
    page has been changed.
    */
    setLocation(url: string): undefined.Promise<void>,

    /**
     * Returns the current absolute url from AngularJS.
     */
    getLocationAbsUrl(): undefined.Promise<string>,

    /**
     * Pauses the test and injects some helper functions into the browser, so that
     * debugging may be done in the browser console.

    This should be used under node in debug mode, i.e. with
    protractor debug <configuration.js>
     * @example  * While in the debugger, commands can be scheduled through webdriver by
    entering the repl:
    debug> repl
    Press Ctrl + C to leave rdebug repl
   >ptor.findElement(protractor.By.input('user').sendKeys('Laura'));
   >ptor.debugger();
    debug> c

    This will run the sendKeys command as the next task, then re-enter the
    debugger.
    */
    debugger(): void,

    /**
     * Beta (unstable) pause function for debugging webdriver tests. Use
     * browser.pause() in your test to enter the protractor debugger from that
    point in the control flow.
    Does not require changes to the command line (no need to add 'debug').
     * @example  * element(by.id('foo')).click();
    browser.pause();
    // Execution will stop before the next click action.
    element(by.id('bar')).click();
     * @param  Optional port to use for the debugging process
    */
    pause(opt_debugPort?: number): void
}

declare type protractor$IBrowser = {

    /**
     * Fork another instance of protractor for use in interactive tests.
     * @param  Whether to navigate to current url on creation
     * @param  Whether to apply same mock modules on creation
     * @return  a protractor instance.
     */
    forkNewDriverInstance(opt_useSameUrl?: boolean, opt_copyMockModules?: boolean): protractor$Protractor,

    /**
     * Get the processed configuration object that is currently being run. This will contain
     * the specs and capabilities properties of the current runner instance.

    Set by the runner.
     * @return  <any>} A promise which resolves to the capabilities object.
    */
    getProcessedConfig(): undefined.Promise<any >
} & protractor$Protractor



/**
 * Create a new instance of Protractor by wrapping a webdriver instance.
 * @param  The configured webdriver instance.
 * @param  A URL to prepend to relative gets.
 * @return  
 */
declare
function protractor$wrapDriver(
    webdriver: webdriver.WebDriver,
    opt_baseUrl?: string,
    opt_rootElement?: string): protractor$Protractordeclare interface selectorHelper {
    (cssLocator: string |
        Function |
        HTMLElement |
        Document |
        Array<any>): protractor$ElementFinder
}
declare interface cssArraySelectorHelper {
    (cssLocator: string): protractor$ElementArrayFinder
}
declare
var browser: protractor$IBrowser;
declare
var by: protractor$IProtractorLocatorStrategy;
declare
var By: protractor$IProtractorLocatorStrategy;
declare
var element: protractor$Element;
declare
var $: selectorHelper;
declare
var $$: cssArraySelectorHelper;
declare module 'protractor' {
    declare module.exports: typeof protractor
}