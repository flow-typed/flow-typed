/**
 * Flowtype definitions for globalize
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface DateFormatterOptions {

    /**
     * String value indicating a skeleton (see description above), eg. { skeleton: "GyMMMd" }.
     * Skeleton provides a more flexible formatting mechanism than the predefined list full, long, medium, or short represented by date, time, or datetime.
    Instead, they are an open-ended list of patterns containing only date field information, and in a canonical order.
    */
    skeleton?: string,

        /**
         * One of the following String values: full, long, medium, or short, eg. { date: "full" }.
         */
        date?: "full" | "long" | "medium" | "short",

        /**
         * One of the following String values: full, long, medium, or short, eg. { time: "full" }.
         */
        time?: "full" | "long" | "medium" | "short",

        /**
         * One of the following String values: full, long, medium, or short, eg. { datetime: "full" }
         */
        datetime?: "full" | "long" | "medium" | "short",

        /**
         * String value indicating a machine raw pattern (anything in the "Sym." column) eg. { raw: "dd/mm" }.
         * Note this is NOT recommended for i18n in general. Use skeleton instead.
         */
        raw?: string
}
declare interface CommonNumberFormatterOptions {

    /**
     * Non-negative integer Number value indicating the minimum integer digits to be used. Numbers will be padded with leading zeroes if necessary.
     */
    minimumIntegerDigits?: number,

        /**
         * Non-negative integer Number values indicating the minimum and maximum fraction digits to be used.
         * Numbers will be rounded or padded with trailing zeroes if necessary.
        Either one or both of these properties must be present.
        If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.
        */
        minimumFractionDigits?: number,

        /**
         * Non-negative integer Number values indicating the minimum and maximum fraction digits to be used.
         * Numbers will be rounded or padded with trailing zeroes if necessary.
        Either one or both of these properties must be present.
        If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.
        */
        maximumFractionDigits?: number,

        /**
         * Positive integer Number values indicating the minimum and maximum fraction digits to be shown.
         * Either none or both of these properties are present
        If they are, they override minimum and maximum integer and fraction digits.
        The formatter uses however many integer and fraction digits are required to display the specified number of significant digits.
        */
        minimumSignificantDigits?: number,

        /**
         * Positive integer Number values indicating the minimum and maximum fraction digits to be shown.
         * Either none or both of these properties are present.
        If they are, they override minimum and maximum integer and fraction digits.
        The formatter uses however many integer and fraction digits are required to display the specified number of significant digits.
        */
        maximumSignificantDigits?: number,

        /**
         * String with rounding method ceil, floor, round (default), or truncate.
         */
        round?: "ceil" | "floor" | "round" | "truncate",

        /**
         * Boolean (default is true) value indicating whether a grouping separator should be used.
         */
        useGrouping?: boolean
}
declare type NumberFormatterOptions = {

    /**
     * decimal (default), or percent
     */
    style?: "decimal" | "percent"
} & CommonNumberFormatterOptions
declare type CurrencyFormatterOptions = {

    /**
     * symbol (default), accounting, code or name.
     */
    style?: "symbol" | "accounting" | "code" | "name"
} & CommonNumberFormatterOptions
declare interface NumberParserOptions {

    /**
     * decimal (default), or percent.
     */
    style?: "decimal" | "percent"
}
declare interface PluralGeneratorOptions {

    /**
     * cardinal (default), or ordinal.
     */
    type?: "cardinal" | "ordinal"
}
declare interface RelativeTimeFormatterOptions {

    /**
     * eg. "short" or "narrow". Or falsy for default long form
     */
    form?: "short" | "narrow"
}
declare interface UnitFormatterOptions {

    /**
     * form: [String] eg. "long", "short" or "narrow".
     */
    form?: "long" | "short" | "narrow",

        /**
         * numberFormatter: [Function] a number formatter function. Defaults to Globalize .numberFormatter() for the current locale using the default options.
         */
        numberFormatter?: NumberFormatterOptions
}
declare interface GlobalizeStatic {
    cldr: cldr.CldrStatic,

        /**
         * Globalize.load( json, ... )
         * @param  * Load resolved or unresolved cldr data.
        Somewhat equivalent to previous Globalize.addCultureInfo(...).
        */
        load(json: Object): void,

        /**
         * Globalize.locale()
         * Return the default Cldr instance.
         */
        locale(): cldr.CldrStatic,

        /**
         * Globalize.locale( [locale] )
         * @param  Set default Cldr instance
        Return the default Cldr instance.
        */
        locale(locale: string): cldr.CldrStatic,

        /**
         * Globalize.locale( cldr )
         * @param  [Cldr instance]
        Set default Cldr instance
        Return the default Cldr instance.
        */
        locale(cldr: cldr.CldrStatic): cldr.CldrStatic,

        /**
         * .dateFormatter( options )
         * @param  see date/expand_pattern for more info.
         * @returns  Return a function that formats a date according to the given `options` and the default/instance locale.
         */
        dateFormatter(options?: DateFormatterOptions): (value: Date) => string,
        dateParser(options?: DateFormatterOptions): (value: string) => Date,
        formatDate(value: Date, options?: DateFormatterOptions): string,

        /**
         * Alias for .dateParser( [options] )( value ).
         * @param  The object whose module id you wish to determine.
         * @param  The object whose module id you wish to determine.
         * @returns  Return the value as a Date.
         */
        parseDate(value: string, options?: DateFormatterOptions): Date,

        /**
         * Load messages data.
         * @param  JSON object of messages data. Keys can use any character, except /, { and }. Values (i.e., the message content itself) can contain any character.
         * @returns  
         */
        loadMessages(json: Object): void,

        /**
         * Return a function that formats a message (using ICU message format pattern) given its path and a set of variables into a user-readable string. It supports pluralization and gender inflections.
         * @param path String or Array containing the path of the message content, eg. "greetings/bye", or [ "greetings", "bye" ].
         * @returns  Return A function that formats a message (using ICU message format pattern) given its path and a set of variables into a user-readable string. It supports pluralization and gender inflections.
         */
        messageFormatter(path: string | string[]): (variables?: string | string[] | Object) => string,

        /**
         * Formats a message (using ICU message format pattern) given its path and a set of variables into a user-readable string
         * @param path String or Array containing the path of the message content, eg. "greetings/bye", or [ "greetings", "bye" ].
         * @param variables Variables can be Objects, where each property can be referenced by name inside a message; or Arrays, where each entry of the Array can be used inside a message, using numeric indices. When passing one or more arguments of other types, they're converted to an Array and used as such.
         * @returns  Return a user-readable string.
         */
        formatMessage(path: string | string[], variables?: string | string[] | Object): string,

        /**
         * Return a function that formats a number according to the given options or locale's defaults.
         * @param  A JSON object including none or any of the following options.
        style Optional String decimal (default), or percent.
        minimumIntegerDigits Optional Non-negative integer Number value indicating the minimum integer digits to be used. Numbers will be padded with leading zeroes if necessary.
        minimumFractionDigits and maximumFractionDigits Optional Non-negative integer Number values indicating the minimum and maximum fraction digits to be used. Numbers will be rounded or padded with trailing zeroes if necessary. Either one or both of these properties must be present. If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.
        minimumSignificantDigits and maximumSignificantDigits Optional Positive integer Number values indicating the minimum and maximum fraction digits to be shown. Either none or both of these properties are present. If they are, they override minimum and maximum integer and fraction digits. The formatter uses however many integer and fraction digits are required to display the specified number of significant digits.
        round Optional String with rounding method ceil, floor, round (default), or truncate.
        useGrouping Optional Boolean (default is true) value indicating whether a grouping separator should be used.
         * @returns  Return a function that formats a number according to the given options.
        */
        numberFormatter(options?: NumberFormatterOptions): (value: number) => string,

        /**
         * Return a function that parses a string representing a number according to the given options or locale's defaults.
         * @param  A JSON object including none or any of the following options.
        style Optional String decimal (default), or percent.
         * @returns  Return a function that parses a String representing a number according to the given options. If value is invalid, NaN is returned.
        */
        numberParser(options?: NumberParserOptions): (value: string) => number,

        /**
         * Return a number formatted according to the given options or locale's defaults.
         * @param  The number to format
         * @param  A JSON object including none or any of the following options.
        style Optional String decimal (default), or percent.
        minimumIntegerDigits Optional Non-negative integer Number value indicating the minimum integer digits to be used. Numbers will be padded with leading zeroes if necessary.
        minimumFractionDigits and maximumFractionDigits Optional Non-negative integer Number values indicating the minimum and maximum fraction digits to be used. Numbers will be rounded or padded with trailing zeroes if necessary. Either one or both of these properties must be present. If they are, they will override minimum and maximum fraction digits derived from the CLDR patterns.
        minimumSignificantDigits and maximumSignificantDigits Optional Positive integer Number values indicating the minimum and maximum fraction digits to be shown. Either none or both of these properties are present. If they are, they override minimum and maximum integer and fraction digits. The formatter uses however many integer and fraction digits are required to display the specified number of significant digits.
        round Optional String with rounding method ceil, floor, round (default), or truncate.
        useGrouping Optional Boolean (default is true) value indicating whether a grouping separator should be used.
         * @returns  Return the number formatted
        */
        formatNumber(value: number, options?: NumberFormatterOptions): string,

        /**
         * A function that parses a string representing a number according to the given options or locale's defaults.
         * @param  The number as string to parse
         * @param  A JSON object including none or any of the following options.
        style Optional String decimal (default), or percent.
         * @returns  Return a number according to the given options. If value is invalid, NaN is returned.
        */
        parseNumber(value: string, options?: NumberParserOptions): number,

        /**
         * Return a function that formats a currency according to the given options or locale's defaults.
         * The returned function is invoked with one argument: the Number value to be formatted.
         * @param  3-letter currency code as defined by ISO 4217, eg. USD.
         * @param  A JSON object including none or any of the following options.
         * @returns  Return a function that formats a currency
         */
        currencyFormatter(
            currency: string,
            options?: CurrencyFormatterOptions): (value: number) => string,

        /**
         * Return a currency formatted according to the given options or locale's defaults.
         * @param  The value to format.
         * @param  3-letter currency code as defined by ISO 4217, eg. USD.
         * @param  A JSON object including none or any of the following options.
         * @returns  Return a string formatted in the currency according to the value and the options
         */
        formatCurrency(value: number, currency: string, options?: CurrencyFormatterOptions): string,

        /**
         * Return a function that returns the value's corresponding plural group: zero, one, two, few, many, or other.
         * The returned function is invoked with one argument: the Number value for which to return the plural group.
         * @param  A JSON object including none or any of the following options.
        type Optional String cardinal (default), or ordinal.
         * @returns  Return a function that returns the value's corresponding plural group: zero, one, two, few, many, or other.
        */
        pluralGenerator(options?: PluralGeneratorOptions): (value: number) => string,

        /**
         * Returns the value's corresponding plural group: zero, one, two, few, many, or other.
         * @param  A Number for which to return the plural group.
         * @param  A JSON object including none or any of the following options.
        type Optional String cardinal (default), or ordinal.
         * @returns  Returns the value's corresponding plural group: zero, one, two, few, many, or other.
        */
        plural(value: number, options?: PluralGeneratorOptions): string,

        /**
         * Returns a function that formats a relative time according to the given unit, options, and the default/instance locale.
         * The returned function is invoked with one argument: the number value to be formatted.
         * @param unit String value indicating the unit to be formatted. eg. "day", "week", "month", etc.
         * @param options form: [String] eg. "short" or "narrow". Or falsy for default long form.
         * @returns  Returns a function that formats a relative time according to the given unit.
         */
        relativeTimeFormatter(
            unit: string,
            options?: RelativeTimeFormatterOptions): (value: number) => string,

        /**
         * Return a relative time according to the given unit
         * @param  The number to be formatted.
         * @param  String value indicating the unit to be formatted. eg. "day", "week", "month", etc.
         * @param options form: [String] eg. "short" or "narrow". Or falsy for default long form.
         * @returns  Return a relative time according to the given unit.
         */
        formatRelativeTime(value: number, unit: string, options?: RelativeTimeFormatterOptions): string,

        /**
         * Returns a function that formats a unit according to the given unit, options, and the default/instance locale.
         * The returned function is invoked with one argument: the number value to be formatted.
         * @param unit String value indicating the unit to be formatted. eg. "day", "week", "month", etc. Could also be a compound unit, eg. "mile-per-hour" or "mile/hour"
         * @param options form: [String] eg. "long", "short" or "narrow".
         * @returns  Returns a function that formats a unit according to the given unit, options, and the default/instance locale.
         */
        unitFormatter(unit: string, options?: UnitFormatterOptions): (value: number) => string,

        /**
         * Alias for .unitFormatter( unit, options )( value ).
         * @param  The number to be formatted.
         * @param  String value indicating the unit to be formatted. eg. "day", "week", "month", etc. Could also be a compound unit, eg. "mile-per-hour" or "mile/hour"
         * @param  form: [String] eg. "long", "short" or "narrow".
         * @returns  Returns the unit formatted.
         */
        formatUnit(value: number, unit: string, options?: UnitFormatterOptions): string,

        /**
         * Create a Globalize instance.
         * @param  string of the instance.
         * @returns  A Globalize instance
         */
        new(locale: string): GlobalizeStatic,

        /**
         * Create a Globalize instance.
         * @param cldr Cldr instance of the instance.
         * @returns  A Globalize instance
         */
        new(cldr: cldr.CldrStatic): GlobalizeStatic
}
declare var Globalize: GlobalizeStatic;