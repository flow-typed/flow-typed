/**
 * Flowtype definitions for webcola
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare class Link3D {
    source: number;
    target: number;
    length: number;
    constructor(source: number, target: number): this;
    actualLength(x: number[][]): number
}

declare class Node3D mixins vpsc.GraphNode {
    x: number;
    y: number;
    z: number;
    fixed: boolean;
    width: number;
    height: number;
    px: number;
    py: number;
    bounds: vpsc.Rectangle;
    variable: vpsc.Variable;
    constructor(x?: number, y?: number, z?: number): this
}

declare class Layout3D {
    nodes: cola$Node3D[];
    links: cola$Link3D[];
    idealLinkLength: number;
    dims: string[];
    k: number;
    result: number[][];
    constraints: any[];
    constructor(nodes: cola$Node3D[], links: cola$Link3D[], idealLinkLength?: number): this;
    linkLength(l: cola$Link3D): number;
    useJaccardLinkLengths: boolean;
    descent: cola$Descent;
    start(iterations?: number): cola$Layout3D;
    tick(): number
}
declare class PairingHeap<T>{
        elem: T;
        constructor(elem: T): this;
        toString(selector: any): string;
        forEach(f: any): void;
        count(): number;
        min(): T;
        empty(): boolean;
        contains(h: PairingHeap<T>): boolean;
        isHeap(lessThan: (a: T, b: T) => boolean): boolean;
        insert(obj: T, lessThan: any): PairingHeap<T>;
        merge(heap2: PairingHeap<T>, lessThan: any): PairingHeap<T>;
        removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T>;
        mergePairs(lessThan: (a: T, b: T) => boolean): PairingHeap<T>;
        decreaseKey(
            subheap: PairingHeap<T>,
            newValue: T,
            setHeapNode: (e: T, h: PairingHeap<T>) => void,
            lessThan: (a: T, b: T) => boolean): PairingHeap<T >
    }
    /**
     * 
     * @class  PriorityQueue a min priority queue backed by a pairing heap
     */
declare class PriorityQueue<T>{
    constructor(lessThan: (a: T, b: T) => boolean): this;

    /**
     * 
     * @method  top
     * @return  the top element (the min element as defined by lessThan)
     */
    top(): T;

    /**
     * 
     * @method  push
    put things on the heap
    */
    push(...args: T[]): PairingHeap<T>;

    /**
     * 
     * @method  empty
     * @return  true if no more elements in queue
     */
    empty(): boolean;

    /**
     * 
     * @method  isHeap check heap condition (for testing)
     * @return  true if queue is in valid state
     */
    isHeap(): boolean;

    /**
     * 
     * @method  forEach apply f to each element of the queue
     * @param f function to apply
     */
    forEach(f: any): void;

    /**
     * 
     * @method  pop remove and return the min element from the queue
     */
    pop(): T;

    /**
     * 
     * @method  reduceKey reduce the key value of the specified heap node
     */
    reduceKey(
        heapNode: PairingHeap<T>,
        newKey: T,
        setHeapNode?: (e: T, h: PairingHeap<T>) => void): void;
    toString(selector: any): string;

    /**
     * 
     * @method  count
     * @return  number of elements in queue
     */
    count(): number
}