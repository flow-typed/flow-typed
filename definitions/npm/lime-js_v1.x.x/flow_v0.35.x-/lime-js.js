/**
 * Flowtype definitions for lime-js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Lime$Envelope {
    id?: string,
        from?: string,
        to?: string,
        pp?: string,
        metadata?: any
}

declare interface Lime$Reason {
    code: number,
        description?: string
}

declare type Lime$Message = {
    type: string,
    content: any
} & Lime$Envelope


declare type Lime$Notification = {
    event: string,
    reason?: Lime$Reason
} & Lime$Envelope


declare class NotificationEvent {
    accepted: string;
    validated: string;
    authorized: string;
    dispatched: string;
    received: string;
    consumed: string
}

declare type Lime$Command = {
    uri?: string,
    type?: string,
    resource?: any,
    method: string,
    status?: string,
    reason?: Lime$Reason
} & Lime$Envelope


declare class CommandMethod {
    get: string;
    set: string;
    delete: string;
    observe: string;
    subscribe: string
}

declare class CommandStatus {
    success: string;
    failure: string
}

declare type Lime$Session = {
    state: string,
    encryptionOptions?: string[],
    encryption?: string,
    compressionOptions?: string[],
    compression?: string,
    scheme?: string,
    authentication?: any,
    reason?: Lime$Reason
} & Lime$Envelope


declare class SessionState {
    new: string;
    negotiating: string;
    authenticating: string;
    established: string;
    finishing: string;
    finished: string;
    failed: string
}

declare class SessionEncryption {
    none: string;
    tls: string
}

declare class SessionCompression {
    none: string;
    gzip: string
}

declare class Authentication {
    scheme: string;
    guest: string;
    plain: string;
    transport: string;
    key: string
}

declare class GuestAuthentication mixins Authentication {
    scheme: string
}

declare class TransportAuthentication mixins Authentication {
    scheme: string
}

declare class PlainAuthentication mixins Authentication {
    scheme: string;
    password: string
}

declare class KeyAuthentication mixins Authentication {
    scheme: string;
    key: string
}

declare class Channel {
    constructor(transport: Lime$Transport, autoReplyPings: boolean, autoNotifyReceipt: boolean): this;
    sendMessage(message: Lime$Message): void;
    onMessage(message: Lime$Message): void;
    sendCommand(command: Lime$Command): void;
    onCommand(command: Lime$Command): void;
    sendNotification(notification: Lime$Notification): void;
    onNotification(notification: Lime$Notification): void;
    sendSession(session: Lime$Session): void;
    onSession(session: Lime$Session): void;
    transport: Lime$Transport;
    remoteNode: string;
    localNode: string;
    sessionId: string;
    state: string
}

declare class ClientChannel mixins Channel {
    constructor(transport: Lime$Transport, autoReplyPings?: boolean, autoNotifyReceipt?: boolean): this;
    startNewSession(): void;
    negotiateSession(sessionCompression: string, sessionEncryption: string): void;
    authenticateSession(identity: string, authentication: Lime$Authentication, instance: string): void;
    sendFinishingSession(): void;
    onSessionNegotiating(session: Lime$Session): void;
    onSessionAuthenticating(session: Lime$Session): void;
    onSessionEstablished(session: Lime$Session): void;
    onSessionFinished(session: Lime$Session): void;
    onSessionFailed(session: Lime$Session): void
}

declare class ClientChannelExtensions {
    establishSession(
        clientChannel: Lime$ClientChannel,
        compression: string,
        encryption: string,
        identity: string,
        authentication: Lime$Authentication,
        instance: string,
        callback: (error: Error, session: Lime$Session) => any): void
}

declare interface Lime$IMessageChannel {
    sendMessage(message: Lime$Message): void,
        onMessage: (message: Lime$Message) => any
}

declare interface Lime$ICommandChannel {
    sendCommand(command: Lime$Command): void,
        onCommand: (command: Lime$Command) => any
}

declare interface Lime$INotificationChannel {
    sendNotification(notification: Lime$Notification): void,
        onNotification: (notification: Lime$Notification) => any
}

declare interface Lime$ISessionChannel {
    sendSession(session: Lime$Session): void,
        onSession: (session: Lime$Session) => any
}

declare interface Lime$ISessionListener {
    (session: Lime$Session): void
}

declare type Lime$Transport = {
    send(envelope: Lime$Envelope): void,
    onEnvelope: (envelope: Lime$Envelope) => any,
    open(uri: string): void,
    close(): void,
    getSupportedCompression(): string[],
    setCompression(compression: string): void,
    compression: string,
    getSupportedEncryption(): string[],
    setEncryption(encryption: string): void,
    encryption: string
} & Lime$ITransportStateListener


declare interface Lime$ITransportEnvelopeListener {
    (envelope: Lime$Envelope): void
}

declare interface Lime$ITransportStateListener {
    onOpen: () => void,
        onClose: () => void,
        onError: (error: string) => void
}

declare class WebSocketTransport mixins Transport {
    webSocket: WebSocket;
    constructor(traceEnabled?: boolean): this;
    send(envelope: Lime$Envelope): void;
    onEnvelope(envelope: Lime$Envelope): void;
    open(uri: string): void;
    close(): void;
    getSupportedCompression(): string[];
    setCompression(compression: string): void;
    compression: string;
    getSupportedEncryption(): string[];
    setEncryption(encryption: string): void;
    encryption: string;
    onOpen(): void;
    onClose(): void;
    onError(error: string): void
}