// @flow
/**
 * Flowtype definitions for fabricjs
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'fabric' {
    declare module.exports: typeof fabric
}

declare var npm$namespace$fabric: {
    createCanvasForNode: typeof fabric$createCanvasForNode,
    createSVGRefElementsMarkup: typeof fabric$createSVGRefElementsMarkup,
    createSVGFontFacesMarkup: typeof fabric$createSVGFontFacesMarkup,
    loadSVGFromString: typeof fabric$loadSVGFromString,
    loadSVGFromURL: typeof fabric$loadSVGFromURL,
    getCSSRules: typeof fabric$getCSSRules,
    parseElements: typeof fabric$parseElements,
    parsePointsAttribute: typeof fabric$parsePointsAttribute,
    parseStyleAttribute: typeof fabric$parseStyleAttribute,
    parseAttributes: typeof fabric$parseAttributes,
    getGradientDefs: typeof fabric$getGradientDefs,
    parseFontDeclaration: typeof fabric$parseFontDeclaration,
    parseSVGDocument: typeof fabric$parseSVGDocument,
    parseTransformAttribute: typeof fabric$parseTransformAttribute,
    log: typeof fabric$log,
    warn: typeof fabric$warn,
}
declare var isLikelyNode: boolean;

declare var isTouchSupported: boolean;

declare function fabric$createCanvasForNode(width: number, height: number): fabric$ICanvas


/**
 * Creates markup containing SVG referenced elements like patterns, gradients etc.
 * @param  instance of fabric.Canvas
 */
declare function fabric$createSVGRefElementsMarkup(canvas: fabric$IStaticCanvas): string


/**
 * Creates markup containing SVG font faces
 * @param  Array of fabric objects
 */
declare function fabric$createSVGFontFacesMarkup(objects: fabric$IObject[]): string


/**
 * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
 * @param  
 * @param  
 * @param  Method for further parsing of SVG elements, called after each fabric object created.
 */
declare function fabric$loadSVGFromString(
    string: string,
    callback: (results: fabric$IObject[], options: any) => void,
    reviver?: Function): void


/**
 * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
 * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
 * @param  
 * @param  
 * @param  Method for further parsing of SVG elements, called after each fabric object created.
 */
declare function fabric$loadSVGFromURL(
    url: string,
    callback: (results: fabric$IObject[], options: any) => void,
    reviver?: Function): void


/**
 * Returns CSS rules for a given SVG document
 * @param  SVG document to parse
 */
declare function fabric$getCSSRules(doc: SVGElement): any

declare function fabric$parseElements(elements: any[], callback: Function, options: any, reviver?: Function): void


/**
 * Parses "points" attribute, returning an array of values
 * @param  points attribute string
 */
declare function fabric$parsePointsAttribute(points: string): any[]


/**
 * Parses "style" attribute, retuning an object with values
 * @param  Element to parse
 */
declare function fabric$parseStyleAttribute(element: SVGElement): any


/**
 * Returns an object of attributes' name/value, given element and an array of attribute names;
 * Parses parent "g" nodes recursively upwards.
 * @param  Element to parse
 * @param  Array of attributes to parse
 */
declare function fabric$parseAttributes(
    elemen: HTMLElement,
    attributes: string[],
    svgUid?: string): {
    [key: string]: string
}


/**
 * Parses an SVG document, returning all of the gradient declarations found in it
 * @param  SVG document to parse
 */
declare function fabric$getGradientDefs(doc: SVGElement): {
    [key: string]: any
}


/**
 * Parses a short font declaration, building adding its properties to a style object
 * @param  font declaration
 * @param  definition
 */
declare function fabric$parseFontDeclaration(value: string, oStyle: any): void


/**
 * Parses an SVG document, converts it to an array of corresponding fabric. instances and passes them to a callback
 * @param  SVG document to parse
 * @param  Callback to call when parsing is finished; It's being passed an array of elements (parsed from a document).
 * @param  Method for further parsing of SVG elements, called after each fabric object created.
 */
declare function fabric$parseSVGDocument(
    doc: SVGElement,
    callback: (results: fabric$IObject[], options: any) => void,
    reviver?: Function): void


/**
 * Parses "transform" attribute, returning an array of values
 * @param  String containing attribute value
 */
declare function fabric$parseTransformAttribute(attributeValue: string): number[]


/**
 * Wrapper around `console.log` (when available)
 */
declare function fabric$log(...values: any[]): void


/**
 * Wrapper around `console.warn` (when available)
 */
declare function fabric$warn(...values: any[]): void

declare var Canvas: fabric$ICanvasStatic;

declare var StaticCanvas: fabric$IStaticCanvasStatic;

declare var Color: fabric$IColorStatic;

declare var Pattern: fabric$IPatternStatic;

declare var Intersection: fabric$IIntersectionStatic;

declare var Point: fabric$IPointStatic;

declare var Circle: fabric$ICircleStatic;

declare var Ellipse: fabric$IEllipseStatic;

declare var Group: fabric$IGroupStatic;

declare var Image: fabric$IImageStatic;

declare var Line: fabric$ILineStatic;

declare var Object: fabric$IObjectStatic;

declare var Path: fabric$IPathStatic;

declare var PathGroup: fabric$IPathGroupStatic;

declare var Polygon: fabric$IPolygonStatic;

declare var Polyline: fabric$IPolylineStatic;

declare var Rect: fabric$IRectStatic;

declare var Shadow: fabric$IShadowStatic;

declare var Text: fabric$ITextStatic;

declare var IText: fabric$IITextStatic;

declare var Triangle: fabric$ITriangleStatic;

declare var util: fabric$IUtil;

declare interface fabric$IDataURLOptions {

    /**
     * The format of the output image. Either "jpeg" or "png"
     */
    format?: string,

        /**
         * Quality level (0..1). Only used for jpeg
         */
        quality?: number,

        /**
         * Multiplier to scale by
         */
        multiplier?: number,

        /**
         * Cropping left offset. Introduced in v1.2.14
         */
        left?: number,

        /**
         * Cropping top offset. Introduced in v1.2.14
         */
        top?: number,

        /**
         * Cropping width. Introduced in v1.2.14
         */
        width?: number,

        /**
         * Cropping height. Introduced in v1.2.14
         */
        height?: number
}

declare interface fabric$IEvent {
    e: Event,
        target?: fabric$IObject
}

declare interface fabric$IFillOptions {

    /**
     * options.source Pattern source
     */
    source: string | HTMLImageElement,

        /**
         * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
         */
        repeat?: string,

        /**
         * Pattern horizontal offset from object's left/top corner
         */
        offsetX?: number,

        /**
         * Pattern vertical offset from object's left/top corner
         */
        offsetY?: number
}

declare interface fabric$IToSVGOptions {

    /**
     * If true xml tag is not included
     */
    suppressPreamble: boolean,

        /**
         * SVG viewbox object
         */
        viewBox: fabric$IViewBox,

        /**
         * Encoding of SVG output
         */
        encoding: string
}

declare interface fabric$IViewBox {

    /**
     * x-cooridnate of viewbox
     */
    x: number,

        /**
         * y-coordinate of viewbox
         */
        y: number,

        /**
         * Width of viewbox
         */
        width: number,

        /**
         * Height of viewbox
         */
        height: number
}

declare interface fabric$ICollection<T>{

    /**
     * Adds objects to collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * Objects should be instances of (or inherit from) fabric.Object
     * @param  Zero or more fabric instances
     */
    add(...object: fabric$IObject[]): T,

    /**
     * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
     * An object should be an instance of (or inherit from) fabric.Object
     * @param  Object to insert
     * @param  Index to insert object at
     * @param  When `true`, no splicing (shifting) of objects occurs
     * @return  thisArg
     * @chainable  
     */
    insertAt(object: fabric$IObject, index: number, nonSplicing: boolean): T,

    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param  Zero or more fabric instances
     * @return  thisArg
     * @chainable  
     */
    remove(...object: fabric$IObject[]): T,

    /**
     * Executes given function for each object in this group
     * @param  
     * @param  Context (aka thisObject)
     * @return  thisArg
     */
    forEachObject(
        callback: (element: fabric$IObject, index: number, array: fabric$IObject[]) => any,
        context?: any): T,

    /**
     * Returns an array of children objects of this instance
     * Type parameter introduced in 1.3.10
     * @param  When specified, only objects of this type are returned
     * @return  
     */
    getObjects(type?: string): fabric$IObject[],

    /**
     * Returns object at specified index
     * @param  
     * @return  thisArg
     */
    item(index: number): T,

    /**
     * Returns true if collection contains no objects
     * @return  true if collection is empty
     */
    isEmpty(): boolean,

    /**
     * Returns a size of a collection (i.e: length of an array containing its objects)
     * @return  Collection size
     */
    size(): number,

    /**
     * Returns true if collection contains an object
     * @param  Object to check against
     * @return  `true` if collection contains an object
     */
    contains(object: fabric$IObject): boolean,

    /**
     * Returns number representation of a collection complexity
     * @return  complexity
     */
    complexity(): number
}

declare interface fabric$IObservable<T>{

    /**
     * Observes specified event
     * @param eventName Event name (eg. 'after:render')
     * @param handler Function that receives a notification when an event of the specified type occurs
     */
    on(eventName: string, handler: (e: fabric$IEvent) => any): T,

    /**
     * Observes specified event
     * @param eventName Object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     */
    on(eventName: {
        [key: string]: Function
    }): T,

    /**
     * Fires event with an optional options object
     * @param  Event name to fire
     * @param  Options object
     */
    trigger(eventName: string, options?: any): T,

    /**
     * Stops event observing for a particular event handler. Calling this method
     * without arguments removes all handlers for all events
     * @param eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
     * @param handler Function to be deleted from EventListeners
     */
    off(eventName?: string | any, handler?: (e: fabric$IEvent) => any): T
}

declare interface fabric$ICanvasAnimation<T>{
    FX_DURATION: number,

    /**
     * Centers object horizontally with animation.
     * @param  Object to center
     * @param  Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param  .onComplete] Invoked on completion
     * @param  .onChange] Invoked on every step of animation
     */
    fxCenterObjectH(
        object: fabric$IObject,
        callbacks?: {
            onComplete: Function,
            onChange: Function
        }): T,

    /**
     * Centers object vertically with animation.
     * @param  Object to center
     * @param  Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param  .onComplete] Invoked on completion
     * @param  .onChange] Invoked on every step of animation
     */
    fxCenterObjectV(
        object: fabric$IObject,
        callbacks?: {
            onComplete: Function,
            onChange: Function
        }): T,

    /**
     * Same as `fabric.Canvas#remove` but animated
     * @param  Object to remove
     * @param  Callbacks object with optional "onComplete" and/or "onChange" properties
     * @param  .onComplete] Invoked on completion
     * @param  .onChange] Invoked on every step of animation
     * @return  thisArg
     * @chainable  
     */
    fxRemove(
        object: fabric$IObject,
        callbacks?: {
            onComplete: Function,
            onChange: Function
        }): T
}

declare interface fabric$IObjectAnimation<T>{

    /**
     * Animates object's properties
     * object.animate('left', ..., {duration: ...});
     * @param property Property to animate
     * @param value Value to animate property
     * @param options The animation options
     */
    animate(
        property: string,
        value: number | string,
        options?: fabric$IAnimationOptions): fabric$IObject,

    /**
     * Animates object's properties
     * object.animate({ left: ..., top: ... }, { duration: ... });
     * @param properties Properties to animate
     * @param value Options object
     */
    animate(properties: any, options?: fabric$IAnimationOptions): fabric$IObject
}

declare interface fabric$IAnimationOptions {

    /**
     * Allows to specify starting value of animatable property (if we don't want current value to be used).
     */
    from?: string | number,

        /**
         * Defaults to 500 (ms). Can be used to change duration of an animation.
         */
        duration?: number,

        /**
         * Callback; invoked on every value change
         */
        onChange?: Function,

        /**
         * Callback; invoked when value change is completed
         */
        onComplete?: Function,

        /**
         * Easing function. Default: fabric.util.ease.easeInSine
         */
        easing?: Function,

        /**
         * Value to modify the property by, default: end - start
         */
        by?: number
}

declare interface fabric$IColor {

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     */
    getSource(): number[],

        /**
         * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
         */
        setSource(source: number[]): void,

        /**
         * Returns color represenation in RGB format ex: rgb(0-255,0-255,0-255)
         */
        toRgb(): string,

        /**
         * Returns color represenation in RGBA format ex: rgba(0-255,0-255,0-255,0-1)
         */
        toRgba(): string,

        /**
         * Returns color represenation in HSL format ex: hsl(0-360,0%-100%,0%-100%)
         */
        toHsl(): string,

        /**
         * Returns color represenation in HSLA format ex: hsla(0-360,0%-100%,0%-100%,0-1)
         */
        toHsla(): string,

        /**
         * Returns color represenation in HEX format ex: FF5555
         */
        toHex(): string,

        /**
         * Gets value of alpha channel for this color
         */
        getAlpha(): number,

        /**
         * Sets value of alpha channel for this color
         * @param  Alpha value 0-1
         */
        setAlpha(alpha: number): void,

        /**
         * Transforms color to its grayscale representation
         */
        toGrayscale(): fabric$IColor,

        /**
         * Transforms color to its black and white representation
         * @param  
         */
        toBlackWhite(threshold: number): fabric$IColor,

        /**
         * Overlays color with another color
         * @param  
         */
        overlayWith(otherColor: string | fabric$IColor): fabric$IColor
}

declare interface fabric$IColorStatic {

    /**
     * Color class
     * The purpose of Color is to abstract and encapsulate common color operations;
     * @param  optional in hex or rgb(a) format
     */
    new(color?: string): fabric$IColor,

    /**
     * Returns new color object, when given a color in RGB format
     * @param  Color value ex: rgb(0-255,0-255,0-255)
     */
    fromRgb(color: string): fabric$IColor,

        /**
         * Returns new color object, when given a color in RGBA format
         * @param  Color value ex: rgb(0-255,0-255,0-255)
         */
        fromRgba(color: string): fabric$IColor,

        /**
         * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
         * @param  Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
         */
        sourceFromRgb(color: string): number[],

        /**
         * Returns new color object, when given a color in HSL format
         * @param  Color value ex: hsl(0-260,0%-100%,0%-100%)
         */
        fromHsl(color: string): fabric$IColor,

        /**
         * Returns new color object, when given a color in HSLA format
         * @param  Color value ex: hsl(0-260,0%-100%,0%-100%)
         */
        fromHsla(color: string): fabric$IColor,

        /**
         * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
         * @param  Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
         */
        sourceFromHsl(color: string): number[],

        /**
         * Returns new color object, when given a color in HEX format
         * @param  Color value ex: FF5555
         */
        fromHex(color: string): fabric$IColor,

        /**
         * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HEX format
         * @param  ex: FF5555
         */
        sourceFromHex(color: string): number[],

        /**
         * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
         * @param  
         */
        fromSource(source: number[]): fabric$IColor,
        prototype: any
}

declare interface fabric$IGradientOptions {

    /**
     * 
     * @param  .type] Type of gradient 'radial' or 'linear'
     */
    type?: string,

        /**
         * x-coordinate of start point
         */
        x1?: number,

        /**
         * y-coordinate of start point
         */
        y1?: number,

        /**
         * x-coordinate of end point
         */
        x2?: number,

        /**
         * y-coordinate of end point
         */
        y2?: number,

        /**
         * Radius of start point (only for radial gradients)
         */
        r1?: number,

        /**
         * Radius of end point (only for radial gradients)
         */
        r2?: number,

        /**
         * Color stops object eg. {0:string; 1:string;
         */
        colorStops?: any
}

declare type fabric$IGradient = {

    /**
     * Adds another colorStop
     * @param  Object with offset and color
     */
    addColorStop(colorStop: any): fabric$IGradient,

    /**
     * Returns object representation of a gradient
     */
    toObject(): any,

    /**
     * Returns SVG representation of an gradient
     * @param  Object to create a gradient for
     * @param  Whether coords should be normalized
     * @return  SVG representation of an gradient (linear/radial)
     */
    toSVG(object: fabric$IObject, normalize?: boolean): string,

    /**
     * Returns an instance of CanvasGradient
     * @param  Context to render on
     */
    toLive(ctx: CanvasRenderingContext2D, object?: fabric$IPathGroup): CanvasGradient
} & fabric$IGradientOptions


declare interface fabric$IGrandientStatic {
    new(options?: fabric$IGradientOptions): fabric$IGradient,

    /**
     * Returns instance from an SVG element
     * @param  SVG gradient element
     * @param  
     */
    fromElement(el: SVGGradientElement, instance: fabric$IObject): fabric$IGradient,

        /**
         * Returns instance from its object representation
         * @param  
         * @param  Options object
         */
        fromObject(obj: any, options: any[]): fabric$IGradient
}

declare interface fabric$IIntersection {

    /**
     * Appends a point to intersection
     */
    appendPoint(point: fabric$IPoint): void,

        /**
         * Appends points to intersection
         */
        appendPoints(points: fabric$IPoint[]): void
}

declare interface fabric$IIntersectionStatic {

    /**
     * Intersection class
     */
    new(status?: string): void,

    /**
     * Checks if polygon intersects another polygon
     */
    intersectPolygonPolygon(points1: fabric$IPoint[], points2: fabric$IPoint[]): fabric$IIntersection,

        /**
         * Checks if line intersects polygon
         */
        intersectLinePolygon(
            a1: fabric$IPoint,
            a2: fabric$IPoint,
            points: fabric$IPoint[]): fabric$IIntersection,

        /**
         * Checks if one line intersects another
         */
        intersectLineLine(
            a1: fabric$IPoint,
            a2: fabric$IPoint,
            b1: fabric$IPoint,
            b2: fabric$IPoint): fabric$IIntersection,

        /**
         * Checks if polygon intersects rectangle
         */
        intersectPolygonRectangle(points: fabric$IPoint[], r1: number, r2: number): fabric$IIntersection
}

declare interface fabric$IPatternOptions {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     */
    repeat: string,

        /**
         * Pattern horizontal offset from object's left/top corner
         */
        offsetX: number,

        /**
         * Pattern vertical offset from object's left/top corner
         */
        offsetY: number,

        /**
         * The source for the pattern
         */
        source: string | HTMLImageElement
}

declare type fabric$IPattern = {
    new(options?: fabric$IPatternOptions): fabric$IPattern,
    initialise(options?: fabric$IPatternOptions): fabric$IPattern,

    /**
     * Returns an instance of CanvasPattern
     */
    toLive(ctx: CanvasRenderingContext2D): fabric$IPattern,

    /**
     * Returns object representation of a pattern
     */
    toObject(): any,

    /**
     * Returns SVG representation of a pattern
     * @param  
     */
    toSVG(object: fabric$IObject): string
} & fabric$IPatternOptions


declare interface fabric$IPatternStatic {
    new(options?: fabric$IPatternOptions): fabric$IPattern,
    prototype: any
}

declare interface fabric$IPoint {
    x: number,
        y: number,

        /**
         * Adds another point to this one and returns another one
         * @param  
         */
        add(that: fabric$IPoint): fabric$IPoint,

        /**
         * Adds another point to this one
         * @param  
         */
        addEquals(that: fabric$IPoint): fabric$IPoint,

        /**
         * Adds value to this point and returns a new one
         * @param  
         */
        scalarAdd(scalar: number): fabric$IPoint,

        /**
         * Adds value to this point
         * @param  
         */
        scalarAddEquals(scalar: number): fabric$IPoint,

        /**
         * Subtracts another point from this point and returns a new one
         * @param  
         */
        subtract(that: fabric$IPoint): fabric$IPoint,

        /**
         * Subtracts another point from this point
         * @param  
         */
        subtractEquals(that: fabric$IPoint): fabric$IPoint,

        /**
         * Subtracts value from this point and returns a new one
         * @param  
         */
        scalarSubtract(scalar: number): fabric$IPoint,

        /**
         * Subtracts value from this point
         * @param  
         */
        scalarSubtractEquals(scalar: number): fabric$IPoint,

        /**
         * Miltiplies this point by a value and returns a new one
         * @param  
         */
        multiply(scalar: number): fabric$IPoint,

        /**
         * Miltiplies this point by a value
         * @param  
         */
        multiplyEquals(scalar: number): fabric$IPoint,

        /**
         * Divides this point by a value and returns a new one
         * @param  
         */
        divide(scalar: number): fabric$IPoint,

        /**
         * Divides this point by a value
         * @param  
         */
        divideEquals(scalar: number): fabric$IPoint,

        /**
         * Returns true if this point is equal to another one
         * @param  
         */
        eq(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns true if this point is less than another one
         * @param  
         */
        lt(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns true if this point is less than or equal to another one
         * @param  
         */
        lte(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns true if this point is greater another one
         * @param  
         */
        gt(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns true if this point is greater than or equal to another one
         * @param  
         */
        gte(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns new point which is the result of linear interpolation with this one and another one
         * @param  
         * @param  
         */
        lerp(that: fabric$IPoint, t: number): fabric$IPoint,

        /**
         * Returns distance from this point and another one
         * @param  
         */
        distanceFrom(that: fabric$IPoint): number,

        /**
         * Returns the point between this point and another one
         * @param  
         */
        midPointFrom(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns a new point which is the min of this and another one
         * @param  
         */
        min(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns a new point which is the max of this and another one
         * @param  
         */
        max(that: fabric$IPoint): fabric$IPoint,

        /**
         * Returns string representation of this point
         */
        toString(): string,

        /**
         * Sets x/y of this point
         * @param  
         * @param  
         */
        setXY(x: number, y: number): fabric$IPoint,

        /**
         * Sets x/y of this point from another point
         * @param  
         */
        setFromPoint(that: fabric$IPoint): fabric$IPoint,

        /**
         * Swaps x/y of this point and another point
         * @param  
         */
        swap(that: fabric$IPoint): fabric$IPoint
}

declare interface fabric$IPointStatic {
    new(x: number, y: number): fabric$IPoint,
    prototype: any
}

declare interface fabric$IShadowOptions {

    /**
     * Whether the shadow should affect stroke operations
     */
    affectStrike: boolean,

        /**
         * Shadow blur
         */
        blur: number,

        /**
         * Shadow color
         */
        color: string,

        /**
         * Indicates whether toObject should include default values
         */
        includeDefaultValues: boolean,

        /**
         * Shadow horizontal offset
         */
        offsetX: number,

        /**
         * Shadow vertical offset
         */
        offsetY: number
}

declare type fabric$IShadow = {
    initialize(options?: fabric$IShadowOptions | string): fabric$IShadow,

    /**
     * Returns object representation of a shadow
     */
    toObject(): fabric$IObject,

    /**
     * Returns a string representation of an instance, CSS3 text-shadow declaration
     */
    toString(): string,

    /**
     * Returns SVG representation of a shadow
     * @param  
     */
    toSVG(object: fabric$IObject): string,

    /**
     * Regex matching shadow offsetX, offsetY and blur, Static
     */
    reOffsetsAndBlur: RegExp
} & fabric$IShadowOptions


declare interface fabric$IShadowStatic {
    new(options?: fabric$IShadowOptions): fabric$IShadow,
    reOffsetsAndBlur: RegExp
}

declare interface fabric$ICanvasDimensions {

    /**
     * Width of canvas element
     */
    width: number,

        /**
         * Height of canvas element
         */
        height: number
}

declare interface fabric$ICanvasDimensionsOptions {

    /**
     * Set the given dimensions only as canvas backstore dimensions
     */
    backstoreOnly?: boolean,

        /**
         * Set the given dimensions only as css dimensions
         */
        cssOnly?: boolean
}

declare interface fabric$IStaticCanvasOptions {

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     */
    allowTouchScrolling?: boolean,

        /**
         * Indicates whether this canvas will use image smoothing, this is on by default in browsers
         */
        imageSmoothingEnabled?: boolean,

        /**
         * Indicates whether objects should remain in current stack position when selected.
         * When false objects are brought to top and rendered as part of the selection group
         */
        preserveObjectStacking?: boolean,

        /**
         * The transformation (in the format of Canvas transform) which focuses the viewport
         */
        viewportTransform?: number[],
        freeDrawingColor?: string,
        freeDrawingLineWidth?: number,

        /**
         * Background color of canvas instance.
         * Should be set via setBackgroundColor
         */
        backgroundColor?: string | fabric$IPattern,

        /**
         * Background image of canvas instance.
         * Should be set via setBackgroundImage
        <b>Backwards incompatibility note:</b> The "backgroundImageOpacity" and "backgroundImageStretch" properties are deprecated since 1.3.9.
        */
        backgroundImage?: fabric$IImage | string,
        backgroundImageOpacity?: number,
        backgroundImageStretch?: number,

        /**
         * Function that determines clipping of entire canvas area
         * Being passed context as first argument. See clipping canvas area
         */
        clipTo?: (context: CanvasRenderingContext2D) => void,

        /**
         * Indicates whether object controls (borders/controls) are rendered above overlay image
         */
        controlsAboveOverlay?: boolean,

        /**
         * Indicates whether toObject/toDatalessObject should include default values
         */
        includeDefaultValues?: boolean,

        /**
         * Overlay color of canvas instance.
         * Should be set via setOverlayColor
         */
        overlayColor?: string | fabric$IPattern,

        /**
         * Overlay image of canvas instance.
         * Should be set via setOverlayImage
        <b>Backwards incompatibility note:</b> The "overlayImageLeft" and "overlayImageTop" properties are deprecated since 1.3.9.
        */
        overlayImage?: fabric$IImage,
        overlayImageLeft?: number,
        overlayImageTop?: number,

        /**
         * Indicates whether add, insertAt and remove should also re-render canvas.
         * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once
        (followed by a manual rendering after addition/deletion)
        */
        renderOnAddRemove?: boolean,

        /**
         * Indicates whether objects' state should be saved
         */
        stateful?: boolean
}

declare type fabric$IStaticCanvas = {

    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     */
    calcOffset(): fabric$IStaticCanvas,

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param  fabric.Image instance or URL of an image to set overlay to
     * @param  callback to invoke when image is loaded and set as an overlay
     * @param  Optional options to set for the {
     * @link  fabric.Image|overlay image}.
     */
    setOverlayImage(
        image: fabric$IImage | string,
        callback: Function,
        options?: fabric$IObjectOptions): fabric$IStaticCanvas,

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param  fabric.Image instance or URL of an image to set background to
     * @param  Callback to invoke when image is loaded and set as background
     * @param  Optional options to set for the {
     * @link  fabric.Image|background image}.
     */
    setBackgroundImage(
        image: fabric$IImage | string,
        callback: Function,
        options?: fabric$IObjectOptions): fabric$IStaticCanvas,

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas
     * @param  Color or pattern to set background color to
     * @param  Callback to invoke when background color is set
     */
    setOverlayColor(
        overlayColor: string | fabric$IPattern,
        callback: Function): fabric$IStaticCanvas,

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param  Color or pattern to set background color to
     * @param  Callback to invoke when background color is set
     */
    setBackgroundColor(
        backgroundColor: string | fabric$IPattern,
        callback: Function): fabric$IStaticCanvas,

    /**
     * Returns canvas width (in px)
     */
    getWidth(): number,

    /**
     * Returns canvas height (in px)
     */
    getHeight(): number,

    /**
     * Sets width of this canvas instance
     * @param  Value to set width to
     * @param  Options object
     */
    setWidth(
        value: number | string,
        options?: fabric$ICanvasDimensionsOptions): fabric$IStaticCanvas,

    /**
     * Sets height of this canvas instance
     * @param  Value to set height to
     * @param  Options object
     */
    setHeight(
        value: number | string,
        options?: fabric$ICanvasDimensionsOptions): fabric$IStaticCanvas,

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param  Object with width/height properties
     * @param  Options object
     */
    setDimensions(
        dimensions: fabric$ICanvasDimensions,
        options?: fabric$ICanvasDimensionsOptions): fabric$IStaticCanvas,

    /**
     * Returns canvas zoom level
     */
    getZoom(): number,

    /**
     * Sets viewport transform of this canvas instance
     * @param  the transform in the form of context.transform
     */
    setViewportTransform(vpt: number[]): fabric$IStaticCanvas,

    /**
     * Sets zoom level of this canvas instance, zoom centered around point
     * @param  to zoom with respect to
     * @param  to set zoom to, less than 1 zooms out
     */
    zoomToPoint(point: fabric$IPoint, value: number): fabric$IStaticCanvas,

    /**
     * Sets zoom level of this canvas instance
     * @param  to set zoom to, less than 1 zooms out
     */
    setZoom(value: number): fabric$IStaticCanvas,

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param  to move to
     */
    absolutePan(point: fabric$IPoint): fabric$IStaticCanvas,

    /**
     * Pans viewpoint relatively
     * @param  (position vector) to move by
     */
    relativePan(point: fabric$IPoint): fabric$IStaticCanvas,

    /**
     * Returns <canvas> element corresponding to this instance
     */
    getElement(): HTMLCanvasElement,

    /**
     * Returns currently selected object, if any
     */
    getActiveObject(): fabric$IObject,

    /**
     * Returns currently selected group of object, if any
     */
    getActiveGroup(): fabric$IGroup,

    /**
     * Clears specified context of canvas element
     * @param  Context to clear
     * @chainable  
     */
    clearContext(ctx: CanvasRenderingContext2D): fabric$IStaticCanvas,

    /**
     * Returns context of canvas where objects are drawn
     */
    getContext(): CanvasRenderingContext2D,

    /**
     * Clears all contexts (background, main, top) of an instance
     */
    clear(): fabric$IStaticCanvas,

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @param  Whether we want to force all images to be rendered on the top canvas
     * @chainable  
     */
    renderAll(allOnTop?: boolean): fabric$IStaticCanvas,

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @chainable  
     */
    renderTop(): fabric$IStaticCanvas,

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     */
    getCenter(): {
        top: number,
        left: number
    },

    /**
     * Centers object horizontally.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param  Object to center horizontally
     */
    centerObjectH(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Centers object vertically.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param  Object to center vertically
     */
    centerObjectV(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Centers object vertically and horizontally.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param  Object to center vertically and horizontally
     */
    centerObject(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Returs dataless JSON representation of canvas
     * @param  Any properties that you might want to additionally include in the output
     */
    toDatalessJSON(propertiesToInclude?: any[]): string,

    /**
     * Returns object representation of canvas
     * @param  Any properties that you might want to additionally include in the output
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns dataless object representation of canvas
     * @param  Any properties that you might want to additionally include in the output
     */
    toDatalessObject(propertiesToInclude?: any[]): any,

    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     */
    svgViewportTransformation: boolean,

    /**
     * Returns SVG representation of canvas
     * @param  Options object for SVG output
     * @param  Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     */
    toSVG(options: fabric$IToSVGOptions, reviver?: Function): string,

    /**
     * Moves an object to the bottom of the stack of drawn objects
     * @param  Object to send to back
     * @chainable  
     */
    sendToBack(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Moves an object to the top of the stack of drawn objects
     * @param  Object to send
     * @chainable  
     */
    bringToFront(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Moves an object down in stack of drawn objects
     * @param  Object to send
     * @param  If `true`, send object behind next lower intersecting object
     * @chainable  
     */
    sendBackwards(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Moves an object up in stack of drawn objects
     * @param  Object to send
     * @param  If `true`, send object in front of next upper intersecting object
     * @chainable  
     */
    bringForward(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param  Object to send
     * @param  Position to move to
     * @chainable  
     */
    moveTo(object: fabric$IObject, index: number): fabric$IStaticCanvas,

    /**
     * Clears a canvas element and removes all event listeners
     */
    dispose(): fabric$IStaticCanvas,

    /**
     * Returns a string representation of an instance
     */
    toString(): string,

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param  Options object
     */
    toDataURL(options?: fabric$IDataURLOptions): string,

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     * @param  Method to check support for; Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
     * @return  `true` if method is supported (or at least exists), null` if canvas element or context can not be initialized
     */
    supports(methodName: string): boolean,

    /**
     * Populates canvas with data from the specified JSON.
     * JSON format must conform to the one of toJSON formats
     * @param  JSON string or object
     * @param  Callback, invoked when json is parsed
    and corresponding objects (e.g: {
     * @link  fabric.Image})
                        are initialized
     * @param  Method for further parsing of JSON elements, called after each fabric object created.
    */
    loadFromJSON(json: string | any, callback: Function, reviver?: Function): fabric$ICanvas,

    /**
     * Clones canvas instance
     * @param  Receives cloned instance as a first argument
     * @param  Array of properties to include in the cloned canvas and children
     */
    clone(callback: (canvas: fabric$IStaticCanvas) => any, properties?: any[]): void,

    /**
     * Clones canvas instance without cloning existing data.
     * This essentially copies canvas dimensions, clipping properties, etc.
    but leaves data empty (so that you can populate it with your own)
     * @param  Receives cloned instance as a first argument
    */
    cloneWithoutData(callback: (canvas: fabric$IStaticCanvas) => any): void,

    /**
     * Callback; invoked right before object is about to be scaled/rotated
     */
    onBeforeScaleRotate(target: fabric$IObject): void,

    /**
     * Straightens object, then rerenders canvas
     * @param  Object to straighten
     */
    straightenObject(object: fabric$IObject): fabric$IStaticCanvas,

    /**
     * Same as straightenObject, but animated
     * @param  Object to straighten
     */
    fxStraightenObject(object: fabric$IObject): fabric$IStaticCanvas
} & fabric$IObservable & fabric$IStaticCanvasOptions & fabric$ICollection & fabric$ICanvasAnimation


declare interface fabric$IStaticCanvasStatic {

    /**
     * Constructor
     * @param  <canvas> element to initialize instance on
     * @param  Options object
     */
    new(
        element: HTMLCanvasElement | string,
        options?: fabric$ICanvasOptions): fabric$IStaticCanvas,
    EMPTY_JSON: string,

        /**
         * Provides a way to check support of some of the canvas methods
         * (either those of HTMLCanvasElement itself, or rendering context)
         * @param  Method to check support for; Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
         */
        supports(methodName: string): boolean,
        prototype: any,

        /**
         * Returns JSON representation of canvas
         * @param  Any properties that you might want to additionally include in the output
         */
        toJSON(propertiesToInclude?: any[]): string
}

declare type fabric$ICanvasOptions = {

    /**
     * When true, objects can be transformed by one side (unproportionally)
     */
    uniScaleTransform?: boolean,

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     */
    centeredScaling?: boolean,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     */
    centeredRotation?: boolean,

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     */
    interactive?: boolean,

    /**
     * Indicates whether group selection should be enabled
     */
    selection?: boolean,

    /**
     * Color of selection
     */
    selectionColor?: string,

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     */
    selectionDashArray?: any[],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     */
    selectionBorderColor?: string,

    /**
     * Width of a line used in object/group selection
     */
    selectionLineWidth?: number,

    /**
     * Default cursor value used when hovering over an object on canvas
     */
    hoverCursor?: string,

    /**
     * Default cursor value used when moving an object on canvas
     */
    moveCursor?: string,

    /**
     * Default cursor value used for the entire canvas
     */
    defaultCursor?: string,

    /**
     * Cursor value used during free drawing
     */
    freeDrawingCursor?: string,

    /**
     * Cursor value used for rotation point
     */
    rotationCursor?: string,

    /**
     * Default element class that's given to wrapper (div) element of canvas
     */
    containerClass?: string,

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     */
    perPixelTargetFind?: boolean,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     */
    targetFindTolerance?: number,

    /**
     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
     */
    skipTargetFind?: boolean,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
    and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
    */
    isDrawingMode?: boolean
} & fabric$IStaticCanvasOptions


declare type fabric$ICanvas = {
    _objects: fabric$IObject[],

    /**
     * Checks if point is contained within an area of given object
     * @param  Event object
     * @param  Object to test against
     */
    containsPoint(e: Event, target: fabric$IObject): boolean,

    /**
     * Deactivates all objects on canvas, removing any active group or object
     * @return  thisArg
     */
    deactivateAll(): fabric$ICanvas,

    /**
     * Deactivates all objects and dispatches appropriate events
     * @param  Event (passed along when firing)
     * @return  thisArg
     */
    deactivateAllWithDispatch(e?: Event): fabric$ICanvas,

    /**
     * Discards currently active group
     * @param  Event (passed along when firing)
     * @return  thisArg
     */
    discardActiveGroup(e?: Event): fabric$ICanvas,

    /**
     * Discards currently active object
     * @param  Event (passed along when firing)
     * @return  thisArg
     * @chainable  
     */
    discardActiveObject(e?: Event): fabric$ICanvas,

    /**
     * Draws objects' controls (borders/controls)
     * @param  Context to render controls on
     */
    drawControls(ctx: CanvasRenderingContext2D): void,

    /**
     * Method that determines what object we are clicking on
     * @param  mouse event
     * @param  when true, group is skipped and only objects are traversed through
     */
    findTarget(e: MouseEvent, skipGroup: boolean): fabric$ICanvas,

    /**
     * Returns currently active group
     * @return  Current group
     */
    getActiveGroup(): fabric$IGroup,

    /**
     * Returns currently active object
     * @return  active object
     */
    getActiveObject(): fabric$IObject,

    /**
     * Returns pointer coordinates relative to canvas.
     * @param  
     * @return  object with "x" and "y" number values
     */
    getPointer(
        e: Event,
        ignoreZoom?: boolean,
        upperCanvasEl?: CanvasRenderingContext2D): {
        x: number,
        y: number
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return  
     */
    getSelectionContext(): CanvasRenderingContext2D,

    /**
     * Returns <canvas> element on which object selection is drawn
     * @return  
     */
    getSelectionElement(): HTMLCanvasElement,

    /**
     * Returns true if object is transparent at a certain location
     * @param  Object to check
     * @param  Left coordinate
     * @param  Top coordinate
     */
    isTargetTransparent(target: fabric$IObject, x: number, y: number): boolean,

    /**
     * Sets active group to a speicified one
     * @param  Group to set as a current one
     * @param  Event (passed along when firing)
     */
    setActiveGroup(group: fabric$IGroup, e?: Event): fabric$ICanvas,

    /**
     * Sets given object as the only active object on canvas
     * @param  Object to set as an active one
     * @param  Event (passed along when firing "object:selected")
     */
    setActiveObject(object: fabric$IObject, e?: Event): fabric$ICanvas,

    /**
     * Set the cursor type of the canvas element
     * @param  Cursor type of the canvas element.
     * @see  http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor(value: string): void,

    /**
     * Removes all event listeners
     */
    removeListeners(): void
} & fabric$IStaticCanvas & fabric$ICanvasOptions


declare interface fabric$ICanvasStatic {

    /**
     * Constructor
     * @param  <canvas> element to initialize instance on
     * @param  Options object
     */
    new(
        element: HTMLCanvasElement | string,
        options?: fabric$ICanvasOptions): fabric$ICanvas,
    EMPTY_JSON: string,

        /**
         * Provides a way to check support of some of the canvas methods
         * (either those of HTMLCanvasElement itself, or rendering context)
         * @param  Method to check support for; Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
         */
        supports(methodName: string): boolean,
        prototype: any,

        /**
         * Returns JSON representation of canvas
         * @param  Any properties that you might want to additionally include in the output
         */
        toJSON(propertiesToInclude?: any[]): string
}

declare type fabric$ICircleOptions = {

    /**
     * Radius of this circle
     */
    radius?: number,

    /**
     * Start angle of the circle, moving clockwise
     */
    startAngle?: number,

    /**
     * End angle of the circle
     */
    endAngle?: number
} & fabric$IObjectOptions


declare type fabric$ICircle = {

    /**
     * Returns complexity of an instance
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return  
     */
    getRadiusX(): number,

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return  
     */
    getRadiusY(): number,

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return  
     */
    setRadius(value: number): number,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$ICircleOptions


declare interface fabric$ICircleStatic {

    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns Circle instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options: fabric$ICircleOptions): fabric$ICircle,

        /**
         * Returns Circle instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$ICircle,

        /**
         * Circle class
         */
        new(options?: fabric$ICircleOptions): fabric$ICircle,
        prototype: any
}

declare type fabric$IEllipseOptions = {

    /**
     * Horizontal radius
     */
    rx?: number,

    /**
     * Vertical radius
     */
    ry?: number
} & fabric$IObjectOptions


declare type fabric$IEllipse = {

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return  
     */
    getRx(): number,

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return  
     */
    getRy(): number,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string,

    /**
     * Returns complexity of an instance
     * @return  complexity
     */
    complexity(): number
} & fabric$IObject & fabric$IEllipseOptions


declare interface fabric$IEllipseStatic {
    new(options?: fabric$IEllipseOptions): fabric$IEllipse,

    /**
     * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns Ellipse instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$IEllipseOptions): fabric$IEllipse,

        /**
         * Returns Ellipse instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$IEllipse
}

declare type fabric$IGroup = {
    activateAllObjects(): fabric$IGroup,

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param  
     * @return  thisArg
     * @chainable  
     */
    addWithUpdate(object: fabric$IObject): fabric$IGroup,
    containsPoint(point: fabric$IPoint): boolean,

    /**
     * Destroys a group (restoring state of its objects)
     * @return  thisArg
     * @chainable  
     */
    destroy(): fabric$IGroup,

    /**
     * Returns requested property
     * @param  Property to get
     * @return  
     */
    get(prop: string): any,

    /**
     * Checks whether this group was moved (since `saveCoords` was called last)
     * @return  true if an object was moved (since fabric.Group#saveCoords was called)
     */
    hasMoved(): boolean,

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param  
     * @return  thisArg
     * @chainable  
     */
    removeWithUpdate(object: fabric$IObject): fabric$IGroup,

    /**
     * Renders instance on a given context
     * @param  context to render instance on
     */
    render(ctx: CanvasRenderingContext2D): void,

    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param  Zero or more fabric instances
     * @return  thisArg
     * @chainable  
     */
    remove(...object: fabric$IObject[]): fabric$IGroup,

    /**
     * Saves coordinates of this instance (to be used together with `hasMoved`)
     * @saveCoords  * 
     * @return  thisArg
     * @chainable  
     */
    saveCoords(): fabric$IGroup,

    /**
     * Sets coordinates of all group objects
     * @return  thisArg
     * @chainable  
     */
    setObjectsCoords(): fabric$IGroup,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns string represenation of a group
     * @return  
     */
    toString(): string,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$ICollection


declare interface fabric$IGroupStatic {

    /**
     * Constructor
     * @param  Group objects
     * @param  Options object
     */
    new(items?: any[], options?: fabric$IObjectOptions): fabric$IGroup,

    /**
     * Returns {@link fabric.Group} instance from an object representation
     * @param  Object to create a group from
     * @param  Callback to invoke when an group instance is created
     */
    fromObject(object: any, callback: (group: fabric$IGroup) => any): void
}

declare type fabric$IImageOptions = {

    /**
     * crossOrigin value (one of "", "anonymous", "allow-credentials")
     */
    crossOrigin: string,

    /**
     * AlignX value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.
     */
    alignX: string,

    /**
     * AlignY value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.
     */
    alignY: string,

    /**
     * meetOrSlice value, part of preserveAspectRatio  (one of "meet", "slice").
     * if meet the image is always fully visibile, if slice the viewport is always filled with image.
     * @see  http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
     */
    meetOrSlice: string,

    /**
     * Image filter array
     */
    filters: fabric$IBaseFilter[]
} & fabric$IObjectOptions


declare type fabric$IImage = {
    initialize(element?: string | HTMLImageElement, options?: fabric$IImageOptions): void,

    /**
     * Applies filters assigned to this image (from "filters" array)
     * @param  Callback is invoked when all filters have been applied and new image is generated
     */
    applyFilters(callback: Function): void,

    /**
     * Returns a clone of an instance
     * @param  Callback is invoked with a clone as a first argument
     * @param  Any properties that you might want to additionally include in the output
     */
    clone(callback?: Function, propertiesToInclude?: any[]): fabric$IObject,

    /**
     * Returns complexity of an instance
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Returns image element which this instance if based on
     * @return  Image element
     */
    getElement(): HTMLImageElement,

    /**
     * Returns original size of an image
     * @return  Object with "width" and "height" properties
     */
    getOriginalSize(): {
        width: number,
        height: number
    },

    /**
     * Returns source of an image
     * @return  Source of an image
     */
    getSrc(): string,
    render(ctx: CanvasRenderingContext2D, noTransform: boolean): void,

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
    You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param  
     * @param  Callback is invoked when all filters have been applied and new image is generated
     * @param  Options object
    */
    setElement(
        element: HTMLImageElement,
        callback: Function,
        options: fabric$IImageOptions): fabric$IImage,

    /**
     * Sets crossOrigin value (on an instance and corresponding image element)
     */
    setCrossOrigin(value: string): fabric$IImage,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  Object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns string representation of an instance
     * @return  String representation of an instance
     */
    toString(): string,

    /**
     * Returns SVG representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string,

    /**
     * Sets source of an image
     * @param  Source string (URL)
     * @param  Callback is invoked when image has been loaded (and all filters have been applied)
     * @param  Options object
     */
    setSrc(src: string, callback: Function, options: fabric$IImageOptions): fabric$IImage
} & fabric$IObject & fabric$IImageOptions


declare interface fabric$IImageStatic {

    /**
     * Constructor
     * @param  Image element
     * @param  Options object
     */
    new(element: HTMLImageElement, objObjects: fabric$IObjectOptions): fabric$IImage,

    /**
     * Creates an instance of fabric.Image from an URL string
     * @param  URL to create an image from
     * @param  Callback to invoke when image is created (newly created image is passed as a first argument)
     * @param  Options object
     */
    fromURL(
            url: string,
            callback?: (image: fabric$IImage) => any,
            objObjects?: fabric$IObjectOptions): fabric$IImage,

        /**
         * Creates an instance of fabric.Image from its object representation
         * @static  * 
         * @param  Object to create an instance from
         * @param  Callback to invoke when an image instance is created
         */
        fromObject(object: any, callback: (image: fabric$IImage) => {}): void,

        /**
         * Returns Image instance from an SVG element
         * @param  Element to parse
         * @param  Callback to execute when fabric.Image object is created
         * @param  Options object
         */
        fromElement(element: SVGElement, callback: Function, options?: fabric$IImageOptions): void,
        prototype: any,

        /**
         * Default CSS class name for canvas
         */
        CSS_CANVAS: string,
        filters: fabric$IAllFilters
}

declare type fabric$ILineOptions = {

    /**
     * x value or first line edge
     */
    x1: number,

    /**
     * x value or second line edge
     */
    x2: number,

    /**
     * y value or first line edge
     */
    y1: number,

    /**
     * y value or second line edge
     */
    y2: number
} & fabric$IObjectOptions


declare type fabric$ILine = {

    /**
     * Returns complexity of an instance
     * @return  complexity
     */
    complexity(): number,
    initialize(points?: number[], options?: fabric$ILineOptions): fabric$ILine,

    /**
     * Returns object representation of an instance
     * @methd  toObject
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude: any[]): any,

    /**
     * Returns SVG representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$ILineOptions


declare interface fabric$ILineStatic {
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns fabric.Line instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$ILineOptions): fabric$ILine,

        /**
         * Returns fabric.Line instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$ILine,
        prototype: any,

        /**
         * Constructor
         * @param  Array of points
         * @param  Options object
         */
        new(points?: number[], objObjects?: fabric$IObjectOptions): fabric$ILine
}

declare interface fabric$IObjectOptions {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
    If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
    */
    type?: string,

        /**
         * Horizontal origin of transformation of an object (one of "left", "right", "center")
         */
        originX?: string,

        /**
         * Vertical origin of transformation of an object (one of "top", "bottom", "center")
         */
        originY?: string,

        /**
         * Top position of an object. Note that by default it's relative to object center. You can change this by setting originY={top/center/bottom}
         */
        top?: number,

        /**
         * Left position of an object. Note that by default it's relative to object center. You can change this by setting originX={left/center/right}
         */
        left?: number,

        /**
         * Object width
         */
        width?: number,

        /**
         * Object height
         */
        height?: number,

        /**
         * Object scale factor (horizontal)
         */
        scaleX?: number,

        /**
         * Object scale factor (vertical)
         */
        scaleY?: number,

        /**
         * When true, an object is rendered as flipped horizontally
         */
        flipX?: boolean,

        /**
         * When true, an object is rendered as flipped vertically
         */
        flipY?: boolean,

        /**
         * Opacity of an object
         */
        opacity?: number,

        /**
         * Angle of rotation of an object (in degrees)
         */
        angle?: number,

        /**
         * Size of object's controlling corners (in pixels)
         */
        cornerSize?: number,

        /**
         * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
         */
        transparentCorners?: boolean,

        /**
         * Default cursor value used when hovering over this object on canvas
         */
        hoverCursor?: string,

        /**
         * Padding between object and its controlling borders (in pixels)
         */
        padding?: number,

        /**
         * Color of controlling borders of an object (when it's active)
         */
        borderColor?: string,

        /**
         * Color of controlling corners of an object (when it's active)
         */
        cornerColor?: string,

        /**
         * When true, this object will use center point as the origin of transformation
         * when being scaled via the controls.
        <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
        */
        centeredScaling?: boolean,

        /**
         * When true, this object will use center point as the origin of transformation
         * when being rotated via the controls.
        <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
        */
        centeredRotation?: boolean,

        /**
         * Color of object's fill
         */
        fill?: string,

        /**
         * Fill rule used to fill an object
         * accepted values are nonzero, evenodd
        Backwards incompatibility note: This property was used for setting globalCompositeOperation until v1.4.12, use `globalCompositeOperation` instead
        */
        fillRule?: string,

        /**
         * Composite rule used for canvas globalCompositeOperation
         */
        globalCompositeOperation?: string,

        /**
         * Background color of an object. Only works with text objects at the moment.
         */
        backgroundColor?: string,

        /**
         * When defined, an object is rendered via stroke and this property specifies its color
         */
        stroke?: string,

        /**
         * Width of a stroke used to render this object
         */
        strokeWidth?: number,

        /**
         * Array specifying dash pattern of an object's stroke (stroke must be defined)
         */
        strokeDashArray?: any[],

        /**
         * Line endings style of an object's stroke (one of "butt", "round", "square")
         */
        strokeLineCap?: string,

        /**
         * Corner style of an object's stroke (one of "bevil", "round", "miter")
         */
        strokeLineJoin?: string,

        /**
         * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
         */
        strokeMiterLimit?: number,

        /**
         * Shadow object representing shadow of this shape
         */
        shadow?: fabric$IShadow | string,

        /**
         * Opacity of object's controlling borders when object is active and moving
         */
        borderOpacityWhenMoving?: number,

        /**
         * Scale factor of object's controlling borders
         */
        borderScaleFactor?: number,

        /**
         * Transform matrix (similar to SVG's transform matrix)
         */
        transformMatrix?: any[],

        /**
         * Minimum allowed scale value of an object
         */
        minScaleLimit?: number,

        /**
         * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
         * But events still fire on it.
         */
        selectable?: boolean,

        /**
         * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
         */
        evented?: boolean,

        /**
         * When set to `false`, an object is not rendered on canvas
         */
        visible?: boolean,

        /**
         * When set to `false`, object's controls are not displayed and can not be used to manipulate object
         */
        hasControls?: boolean,

        /**
         * When set to `false`, object's controlling borders are not rendered
         */
        hasBorders?: boolean,

        /**
         * When set to `false`, object's controlling rotating point will not be visible or selectable
         */
        hasRotatingPoint?: boolean,

        /**
         * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
         */
        rotatingPointOffset?: number,

        /**
         * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
         */
        perPixelTargetFind?: boolean,

        /**
         * When `false`, default object's values are not included in its serialization
         */
        includeDefaultValues?: boolean,

        /**
         * Function that determines clipping of an object (context is passed as a first argument)
         * Note that context origin is at the object's center point (not left/top corner)
         * @type  Function
         */
        clipTo?: Function,

        /**
         * When `true`, object horizontal movement is locked
         */
        lockMovementX?: boolean,

        /**
         * When `true`, object vertical movement is locked
         */
        lockMovementY?: boolean,

        /**
         * When `true`, object rotation is locked
         */
        lockRotation?: boolean,

        /**
         * When `true`, object horizontal scaling is locked
         */
        lockScalingX?: boolean,

        /**
         * When `true`, object vertical scaling is locked
         */
        lockScalingY?: boolean,

        /**
         * When `true`, object non-uniform scaling is locked
         */
        lockUniScaling?: boolean,

        /**
         * When `true`, object cannot be flipped by scaling into negative values
         */
        lockScalingFlip?: boolean,

        /**
         * Not used by fabric, just for convenience
         */
        name?: string,

        /**
         * Not used by fabric, just for convenience
         */
        data?: any
}

declare type fabric$IObject = {
    getCurrentWidth(): number,
    getCurrentHeight(): number,
    getAngle(): number,
    setAngle(value: number): fabric$IObject,
    getBorderColor(): string,
    setBorderColor(value: string): fabric$IObject,
    getBorderScaleFactor(): number,
    getCornersize(): number,
    setCornersize(value: number): fabric$IObject,
    getFill(): string,
    setFill(value: string): fabric$IObject,
    getFillRule(): string,
    setFillRule(value: string): fabric$IObject,
    getFlipX(): boolean,
    setFlipX(value: boolean): fabric$IObject,
    getFlipY(): boolean,
    setFlipY(value: boolean): fabric$IObject,
    getHeight(): number,
    setHeight(value: number): fabric$IObject,
    getLeft(): number,
    setLeft(value: number): fabric$IObject,
    getOpacity(): number,
    setOpacity(value: number): fabric$IObject,
    overlayFill: string,
    getOverlayFill(): string,
    setOverlayFill(value: string): fabric$IObject,
    getScaleX(): number,
    setScaleX(value: number): fabric$IObject,
    getScaleY(): number,
    setScaleY(value: number): fabric$IObject,
    setShadow(options: any): fabric$IObject,
    getShadow(): fabric$IObject,
    stateProperties: any[],
    getTop(): number,
    setTop(value: number): fabric$IObject,
    getWidth(): number,
    setWidth(value: number): fabric$IObject,
    setOptions(options: any): void,

    /**
     * Transforms context when rendering an object
     * @param  Context
     * @param  When true, context is transformed to object's top/left corner. This is used when rendering text on Node
     */
    transform(ctx: CanvasRenderingContext2D, fromLeft: boolean): void,

    /**
     * Returns an object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns (dataless) object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     */
    toDatalessObject(propertiesToInclude?: any[]): any,

    /**
     * Returns a string representation of an instance
     */
    toString(): string,

    /**
     * Basic getter
     * @param  Property name
     */
    get(property: string): any,

    /**
     * Sets property to a given value.
     * When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls.
    If you need to update those, call `setCoords()`.
     * @param  Property name
     * @param  Property value (if function, the value is passed into it and its return value is used as a new one)
    */
    set(key: string, value: any | Function): fabric$IObject,

    /**
     * Sets property to a given value.
     * When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls.
    If you need to update those, call `setCoords()`.
     * @param Object key Property object, iterate over the object properties
    */
    set(key: any): fabric$IObject,

    /**
     * Toggles specified property from `true` to `false` or from `false` to `true`
     * @param  Property to toggle
     */
    toggle(property: string): fabric$IObject,

    /**
     * Sets sourcePath of an object
     * @param  Value to set sourcePath to
     */
    setSourcePath(value: string): fabric$IObject,

    /**
     * Retrieves viewportTransform from Object's canvas if possible
     */
    getViewportTransform(): boolean,

    /**
     * Renders an object on a specified context
     * @param  Context to render on
     * @param  When true, context is not transformed
     */
    render(ctx: CanvasRenderingContext2D, noTransform?: boolean): void,

    /**
     * Clones an instance
     * @param  Callback is invoked with a clone as a first argument
     * @param  Any properties that you might want to additionally include in the output
     */
    clone(callback: Function, propertiesToInclude?: any[]): fabric$IObject,

    /**
     * Creates an instance of fabric.Image out of an object
     * @param  callback, invoked with an instance as a first argument
     */
    cloneAsImage(callback: (image: fabric$IImage) => any): fabric$IObject,

    /**
     * Converts an object into a data-url-like string
     * @param options Options object
     */
    toDataURL(options: fabric$IDataURLOptions): string,

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param  Type to check against
     */
    isType(type: string): boolean,

    /**
     * Returns complexity of an instance
     */
    complexity(): number,

    /**
     * Returns a JSON representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     */
    toJSON(propertiesToInclude?: any[]): any,

    /**
     * Sets gradient (fill or stroke) of an object
     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
     * @param  Property name 'stroke' or 'fill'
     * @param  Options object
     */
    setGradient(property: string, options: fabric$IGradientOptions): fabric$IObject,

    /**
     * Sets pattern fill of an object
     * @param  Options object
     */
    setPatternFill(options: fabric$IFillOptions): fabric$IObject,

    /**
     * Sets shadow of an object
     * @param  Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     */
    setShadow(options?: string): fabric$IObject,

    /**
     * Sets shadow of an object
     * @param options Options object
     */
    setShadow(options: fabric$IShadow): fabric$IObject,

    /**
     * Sets "color" of an instance (alias of `set('fill', …)`)
     * @param  Color value
     */
    setColor(color: string): fabric$IObject,

    /**
     * Sets "angle" of an instance
     * @param  Angle value
     */
    setAngle(angle: number): fabric$IObject,

    /**
     * Sets "angle" of an instance
     * @param  Angle value
     */
    rotate(angle: number): fabric$IObject,

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     */
    centerH(): void,

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     */
    centerV(): void,

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     */
    center(): void,

    /**
     * Removes object from canvas to which it was added last
     */
    remove(): fabric$IObject,

    /**
     * Returns coordinates of a pointer relative to an object
     * @param  Event to operate upon
     * @param  Pointer to operate upon (instead of event)
     */
    getLocalPointer(e: Event, pointer: any): any,

    /**
     * Sets object's properties from options
     * @param  Options object
     */
    setOptions(options: any): void,

    /**
     * Sets sourcePath of an object
     * @param  Value to set sourcePath to
     */
    setSourcePath(value: string): fabric$IObject,

    /**
     * Returns styles-string for svg-export
     */
    getSvgStyles(): string,

    /**
     * Returns transform-string for svg-export
     */
    getSvgTransform(): string,

    /**
     * Returns transform-string for svg-export from the transform matrix of single elements
     */
    getSvgTransformMatrix(): string,

    /**
     * Returns true if object state (one of its state properties) was changed
     */
    hasStateChanged(): boolean,

    /**
     * Saves state of an object
     * @param  Object with additional `stateProperties` array to include when saving state
     * @return  thisArg
     */
    saveState(options?: {
        stateProperties: any[]
    }): fabric$IObject,

    /**
     * Setups state of an object
     */
    setupState(): fabric$IObject,

    /**
     * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
     */
    straighten(): fabric$IObject,

    /**
     * Same as straighten but with animation
     * @param  Object with callback functions
     * @param  .onComplete] Invoked on completion
     * @param  .onChange] Invoked on every step of animation
     */
    fxStraighten(callbacks: {
        onComplete?: Function,
        onChange: Function
    }): fabric$IObject,

    /**
     * Moves an object up in stack of drawn objects
     * @param  If `true`, send object in front of next upper intersecting object
     */
    bringForward(intersecting?: boolean): fabric$IObject,

    /**
     * Moves an object to the top of the stack of drawn objects
     */
    bringToFront(): fabric$IObject,

    /**
     * Moves an object down in stack of drawn objects
     * @param  If `true`, send object behind next lower intersecting object
     */
    sendBackwards(intersecting?: boolean): fabric$IObject,

    /**
     * Moves an object to the bottom of the stack of drawn objects
     */
    sendToBack(): fabric$IObject,

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param  New position of object
     */
    moveTo(index: number): fabric$IObject,

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param  The point which corresponds to the originX and originY params
     * @param  Horizontal origin: 'left', 'center' or 'right'
     * @param  Vertical origin: 'top', 'center' or 'bottom'
     */
    translateToCenterPoint(point: fabric$IPoint, originX: string, originY: string): fabric$IPoint,

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param  The point which corresponds to center of the object
     * @param  Horizontal origin: 'left', 'center' or 'right'
     * @param  Vertical origin: 'top', 'center' or 'bottom'
     */
    translateToOriginPoint(center: fabric$IPoint, originX: string, originY: string): fabric$IPoint,

    /**
     * Returns the real center coordinates of the object
     */
    getCenterPoint(): fabric$IPoint,

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param  Horizontal origin: 'left', 'center' or 'right'
     * @param  Vertical origin: 'top', 'center' or 'bottom'
     */
    getPointByOrigin(): fabric$IPoint,

    /**
     * Returns the point in local coordinates
     * @param  The point relative to the global coordinate system
     * @param  Horizontal origin: 'left', 'center' or 'right'
     * @param  Vertical origin: 'top', 'center' or 'bottom'
     */
    toLocalPoint(point: fabric$IPoint, originX: string, originY: string): fabric$IPoint,

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param  The new position of the object
     * @param  Horizontal origin: 'left', 'center' or 'right'
     * @param  Vertical origin: 'top', 'center' or 'bottom'
     * @return  
     */
    setPositionByOrigin(pos: fabric$IPoint, originX: string, originY: string): void,

    /**
     * 
     * @param  One of 'left', 'center', 'right'
     */
    adjustPosition(to: string): void,

    /**
     * -
     * Draws borders of an object's bounding box.
    Requires public properties: width, height
    Requires public options: padding, borderColor
     * @param  Context to draw on
    */
    drawBorders(context: CanvasRenderingContext2D): fabric$IObject,

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
    Requires public options: cornerSize, padding
     * @param  Context to draw on
    */
    drawCorners(context: CanvasRenderingContext2D): fabric$IObject,

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param  The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     */
    isControlVisible(controlName: string): boolean,

    /**
     * Sets the visibility of the specified control.
     * @param  The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param  true to set the specified control visible, false otherwise
     */
    setControlVisible(controlName: string, visible: boolean): fabric$IObject,

    /**
     * Sets the visibility state of object controls.
     * @param  Options object
     */
    setControlsVisibility(
        options?: {
            bl?: boolean,
            br?: boolean,
            mb?: boolean,
            ml?: boolean,
            mr?: boolean,
            mt?: boolean,
            tl?: boolean,
            tr?: boolean,
            mtr?: boolean
        }): fabric$IObject,

    /**
     * Sets corner position coordinates based on current angle, width and height
     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
     */
    setCoords(): fabric$IObject,

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * @return  Object with left, top, width, height properties
     */
    getBoundingRect(): {
        left: number,
        top: number,
        width: number,
        height: number
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param  Object to test
     */
    isContainedWithinObject(other: fabric$IObject): boolean,

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param  top-left point of area
     * @param  bottom-right point of area
     */
    isContainedWithinRect(pointTL: any, pointBR: any): boolean,

    /**
     * Checks if point is inside the object
     * @param  Point to check against
     */
    containsPoint(point: fabric$IPoint): boolean,

    /**
     * Scales an object (equally by x and y)
     * @param  Scale factor
     * @return  thisArg
     */
    scale(value: number): fabric$IObject,

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param  New height value
     */
    scaleToHeight(value: number): fabric$IObject,

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param  New width value
     */
    scaleToWidth(value: number): fabric$IObject,

    /**
     * Checks if object intersects with another object
     * @param  Object to test
     */
    intersectsWithObject(other: fabric$IObject): boolean,

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param  top-left point of area
     * @param  bottom-right point of area
     */
    intersectsWithRect(pointTL: any, pointBR: any): boolean
} & fabric$IObservable & fabric$IObjectOptions & fabric$IObjectAnimation


declare interface fabric$IObjectStatic {
    prototype: any
}

declare type fabric$IPathOptions = {

    /**
     * Array of path points
     */
    path?: any[],

    /**
     * Minimum X from points values, necessary to offset points
     */
    minX?: number,

    /**
     * Minimum Y from points values, necessary to offset points
     */
    minY?: number
} & fabric$IObjectOptions


declare type fabric$IPath = {
    initialize(path?: any[], options?: fabric$IPathOptions): fabric$IPath,

    /**
     * Returns number representation of an instance complexity
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Renders path on a specified context
     * @param  context to render path on
     * @param  When true, context is not transformed
     */
    render(ctx: CanvasRenderingContext2D, noTransform: boolean): void,

    /**
     * Returns dataless object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toDatalessObject(propertiesToInclude?: any[]): any,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns string representation of an instance
     * @return  string representation of an instance
     */
    toString(): string,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$IPathOptions


declare interface fabric$IPathStatic {

    /**
     * Creates an instance of fabric.Path from an SVG <path> element
     * @param  to parse
     * @param  Callback to invoke when an fabric.Path instance is created
     * @param  Options object
     */
    fromElement(
            element: SVGElement,
            callback: (path: fabric$IPath) => any,
            options?: fabric$IPathOptions): void,

        /**
         * Creates an instance of fabric.Path from an object
         * @param  
         * @param  Callback to invoke when an fabric.Path instance is created
         */
        fromObject(object: any, callback: (path: fabric$IPath) => any): void,

        /**
         * Constructor
         * @param  Path data (sequence of coordinates and corresponding "command" tokens)
         * @param  Options object
         */
        new(path?: string | any[], options?: fabric$IPathOptions): fabric$IPath
}

declare type fabric$IPathGroup = {
    initialize(paths: fabric$IPath[], options?: fabric$IObjectOptions): void,

    /**
     * Returns number representation of object's complexity
     * @return  complexity
     */
    complexity(): number,

    /**
     * Returns true if all paths in this group are of same color
     * @return  true if all paths are of the same color (`fill`)
     */
    isSameColor(): boolean,

    /**
     * Renders this group on a specified context
     * @param  Context to render this instance on
     */
    render(ctx: CanvasRenderingContext2D): void,

    /**
     * Returns dataless object representation of this path group
     * @param  Any properties that you might want to additionally include in the output
     * @return  dataless object representation of an instance
     */
    toDatalessObject(propertiesToInclude?: any[]): any,

    /**
     * Returns object representation of this path group
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns a string representation of this path group
     * @return  string representation of an object
     */
    toString(): string,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string,

    /**
     * Returns all paths in this path group
     * @return  array of path objects included in this path group
     */
    getObjects(): fabric$IPath[]
} & fabric$IObject


declare interface fabric$IPathGroupStatic {
    fromObject(object: any): fabric$IPathGroup,

        /**
         * Constructor
         * @param  
         * @param  Options object
         */
        new(paths: fabric$IPath[], options?: fabric$IObjectOptions): fabric$IPathGroup,

        /**
         * Creates fabric.PathGroup instance from an object representation
         * @static  * 
         * @memberOf  fabric.PathGroup
         * @param  Object to create an instance from
         * @param  Callback to invoke when an fabric.PathGroup instance is created
         */
        fromObject(object: any, callback: (group: fabric$IPathGroup) => any): void,
        prototype: any
}

declare type fabric$IPolygonOptions = {

    /**
     * Points array
     */
    points?: fabric$IPoint[],

    /**
     * Minimum X from points values, necessary to offset points
     */
    minX?: number,

    /**
     * Minimum Y from points values, necessary to offset points
     */
    minY?: number
} & fabric$IObjectOptions


declare type fabric$IPolygon = {

    /**
     * Returns complexity of an instance
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$IPolygonOptions


declare interface fabric$IPolygonStatic {

    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns Polygon instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$IPolygonOptions): fabric$IPolygon,

        /**
         * Returns fabric.Polygon instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$IPolygon,

        /**
         * Constructor
         * @param  Array of points
         * @param  Options object
         */
        new(
            points: {
                x: number,
                y: number
            }[],
            options?: fabric$IObjectOptions,
            skipOffset?: boolean): fabric$IPolygon,
        prototype: any
}

declare type fabric$IPolylineOptions = {

    /**
     * Points array
     */
    points?: fabric$IPoint[],

    /**
     * Minimum X from points values, necessary to offset points
     */
    minX?: number,

    /**
     * Minimum Y from points values, necessary to offset points
     */
    minY?: number
} & fabric$IObjectOptions


declare type fabric$IPolyline = {
    initialize(points: fabric$IPoint[], options?: fabric$IPolylineOptions): void,

    /**
     * Returns complexity of an instance
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  Object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): any,

    /**
     * Returns SVG representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$IPolylineOptions


declare interface fabric$IPolylineStatic {

    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns Polyline  instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$IPolylineOptions): fabric$IPolyline,

        /**
         * Returns fabric.Polyline instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$IPolyline,

        /**
         * Constructor
         * @param  Array of points (where each point is an object with x and y)
         * @param  Options object
         * @param  Whether points offsetting should be skipped
         */
        new(
            points: {
                x: number,
                y: number
            }[],
            options?: fabric$IPolylineOptions): fabric$IPolyline,
        prototype: any
}

declare type fabric$IRectOptions = {
    x?: number,
    y?: number,

    /**
     * Horizontal border radius
     */
    rx?: number,

    /**
     * Vertical border radius
     */
    ry?: number
} & fabric$IObjectOptions


declare type fabric$IRect = {
    initialize(points?: number[], options?: any): fabric$IRect,

    /**
     * Returns complexity of an instance
     * @return  complexity
     */
    complexity(): number,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude: any[]): any,

    /**
     * Returns svg representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject & fabric$IRectOptions


declare interface fabric$IRectStatic {

    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Returns Rect instance from an SVG element
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$IRectOptions): fabric$IRect,

        /**
         * Returns Rect instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$IRect,

        /**
         * Constructor
         * @param  Options object
         */
        new(options?: fabric$IRectOptions): fabric$IRect,
        prototype: any
}

declare type fabric$ITextOptions = {

    /**
     * Font size (in pixels)
     */
    fontSize?: number,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     */
    fontWeight?: number | string,

    /**
     * Font family
     */
    fontFamily?: string,

    /**
     * Text decoration Possible values?: "", "underline", "overline" or "line-through".
     */
    textDecoration?: string,

    /**
     * Text alignment. Possible values?: "left", "center", or "right".
     */
    textAlign?: string,

    /**
     * Font style . Possible values?: "", "normal", "italic" or "oblique".
     */
    fontStyle?: string,

    /**
     * Line height
     */
    lineHeight?: number,

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note?:</b> This property was named "strokeStyle" until v1.1.6
     */
    stroke?: string,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note?:</b> This property was named "textShadow" (String) until v1.2.11
     */
    shadow?: fabric$IShadow | string,

    /**
     * Background color of text lines
     */
    textBackgroundColor?: string,
    path?: string,
    useNative?: Boolean,
    text?: string
} & fabric$IObjectOptions


declare type fabric$IText = {

    /**
     * Returns complexity of an instance
     */
    complexity(): number,

    /**
     * Returns string representation of an instance
     */
    toString(): string,

    /**
     * Renders text instance on a specified context
     * @param  Context to render on
     */
    render(ctx: CanvasRenderingContext2D, noTransform: boolean): void,

    /**
     * Returns object representation of an instance
     * @param  Any properties that you might want to additionally include in the output
     */
    toObject(propertiesToInclude?: any[]): fabric$IObject,

    /**
     * Returns SVG representation of an instance
     * @param  Method for further parsing of svg representation.
     */
    toSVG(reviver?: Function): string,

    /**
     * Retrieves object's fontSize
     */
    getFontSize(): number,

    /**
     * Sets object's fontSize
     * @param  Font size (in pixels)
     */
    setFontSize(fontSize: number): fabric$IText,

    /**
     * Retrieves object's fontWeight
     */
    getFontWeight(): number | string,

    /**
     * Sets object's fontWeight
     * @param  Font weight
     */
    setFontWeight(fontWeight: string | number): fabric$IText,

    /**
     * Retrieves object's fontFamily
     */
    getFontFamily(): string,

    /**
     * Sets object's fontFamily
     * @param  Font family
     */
    setFontFamily(fontFamily: string): fabric$IText,

    /**
     * Retrieves object's text
     */
    getText(): string,

    /**
     * Sets object's text
     * @param  Text
     */
    setText(text: string): fabric$IText,

    /**
     * Retrieves object's textDecoration
     */
    getTextDecoration(): string,

    /**
     * Sets object's textDecoration
     * @param  Text decoration
     */
    setTextDecoration(textDecoration: string): fabric$IText,

    /**
     * Retrieves object's fontStyle
     */
    getFontStyle(): string,

    /**
     * Sets object's fontStyle
     * @param  Font style
     */
    setFontStyle(fontStyle: string): fabric$IText,

    /**
     * Retrieves object's lineHeight
     */
    getLineHeight(): number,

    /**
     * Sets object's lineHeight
     * @param  Line height
     */
    setLineHeight(lineHeight: number): fabric$IText,

    /**
     * Retrieves object's textAlign
     */
    getTextAlign(): string,

    /**
     * Sets object's textAlign
     * @param  Text alignment
     */
    setTextAlign(textAlign: string): fabric$IText,

    /**
     * Retrieves object's textBackgroundColor
     */
    getTextBackgroundColor(): string,

    /**
     * Sets object's textBackgroundColor
     * @param  Text background color
     */
    setTextBackgroundColor(textBackgroundColor: string): fabric$IText
} & fabric$IObject & fabric$ITextOptions


declare interface fabric$ITextStatic {

    /**
     * List of attribute names to account for when parsing SVG element (used by `fabric.Text.fromElement`)
     */
    ATTRIBUTE_NAMES: string[],

        /**
         * Default SVG font size
         */
        DEFAULT_SVG_FONT_SIZE: number,

        /**
         * Constructor
         * @param  Text string
         * @param  Options object
         */
        new(text: string, options?: fabric$ITextOptions): fabric$IText,

        /**
         * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
         * @param  Element to parse
         * @param  Options object
         */
        fromElement(element: SVGElement, options?: fabric$ITextOptions): fabric$IText,

        /**
         * Returns fabric.Text instance from an object representation
         * @param  Object to create an instance from
         */
        fromObject(object: any): fabric$IText
}

declare type fabric$IITextOptions = {

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     */
    selectionStart?: number,

    /**
     * Index where text selection ends
     */
    selectionEnd?: number,

    /**
     * Color of text selection
     */
    selectionColor?: string,

    /**
     * Indicates whether text is in editing mode
     */
    isEditing?: boolean,

    /**
     * Indicates whether a text can be edited
     */
    editable?: boolean,

    /**
     * Border color of text object while it's in editing mode
     */
    editingBorderColor?: string,

    /**
     * Width of cursor (in px)
     */
    cursorWidth?: number,

    /**
     * Color of default cursor (when not overwritten by character style)
     */
    cursorColor?: string,

    /**
     * Delay between cursor blink (in ms)
     */
    cursorDelay?: number,

    /**
     * Duration of cursor fadein (in ms)
     */
    cursorDuration?: number,

    /**
     * Object containing character styles
     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)
     */
    styles?: any,

    /**
     * Indicates whether internal text char widths can be cached
     */
    caching?: boolean
} & fabric$IObjectOptions & fabric$ITextOptions


declare type fabric$IIText = {

    /**
     * Returns true if object has no styling
     */
    isEmptyStyles(): boolean,
    render(ctx: CanvasRenderingContext2D, noTransform: boolean): void,

    /**
     * Returns object representation of an instance
     * @method  toObject
     * @param  Any properties that you might want to additionally include in the output
     * @return  object representation of an instance
     */
    toObject(propertiesToInclude?: any[]): fabric$IObject,
    setText(value: string): fabric$IText,

    /**
     * Sets selection start (left boundary of a selection)
     * @param  Index to set selection start to
     */
    setSelectionStart(index: number): void,

    /**
     * Sets selection end (right boundary of a selection)
     * @param  Index to set selection end to
     */
    setSelectionEnd(index: number): void,

    /**
     * Gets style of a current selection/cursor (at the start position)
     * @param  Start index to get styles at
     * @param  End index to get styles at
     * @return  styles Style object at a specified (or current) index
     */
    getSelectionStyles(startIndex: number, endIndex: number): any,

    /**
     * Sets style of a current selection
     * @param  Styles object
     * @return  thisArg
     * @chainable  
     */
    setSelectionStyles(styles: any): fabric$IText,

    /**
     * Renders cursor or selection (depending on what exists)
     */
    renderCursorOrSelection(): void,

    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param  Optional index. When not given, current selectionStart is used.
     */
    get2DCursorLocation(selectionStart?: number): void,

    /**
     * Returns complete style of char at the current cursor
     * @param  Line index
     * @param  Char index
     * @return  Character style
     */
    getCurrentCharStyle(lineIndex: number, charIndex: number): any,

    /**
     * Returns fontSize of char at the current cursor
     * @param  Line index
     * @param  Char index
     * @return  Character font size
     */
    getCurrentCharFontSize(lineIndex: number, charIndex: number): number,

    /**
     * Returns color (fill) of char at the current cursor
     * @param  Line index
     * @param  Char index
     * @return  Character color (fill)
     */
    getCurrentCharColor(lineIndex: number, charIndex: number): string,

    /**
     * Renders cursor
     * @param  
     */
    renderCursor(boundaries: any): void,

    /**
     * Renders text selection
     * @param  Array of characters
     * @param  Object with left/top/leftOffset/topOffset
     */
    renderSelection(chars: string[], boundaries: any): void,

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior(): void,

    /**
     * Initializes "selected" event handler
     */
    initSelectedHandler(): void,

    /**
     * Initializes "added" event handler
     */
    initAddedHandler(): void,
    initRemovedHandler(): void,

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor(restart: boolean): void,

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation(): void,

    /**
     * Selects entire text
     */
    selectAll(): void,

    /**
     * Returns selected text
     */
    getSelectedText(): string,

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param  Surrent selection index
     * @return  New selection index
     */
    findWordBoundaryLeft(startFrom: number): number,

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param  Current selection index
     * @return  New selection index
     */
    findWordBoundaryRight(startFrom: number): number,

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param  Current selection index
     */
    findLineBoundaryLeft(startFrom: number): number,

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param  Current selection index
     */
    findLineBoundaryRight(startFrom: number): number,

    /**
     * Returns number of newlines in selected text
     */
    getNumNewLinesInSelectedText(): number,

    /**
     * Finds index corresponding to beginning or end of a word
     * @param  Index of a character
     * @param  : 1 or -1
     */
    searchWordBoundary(selectionStart: number, direction: number): number,

    /**
     * Selects a word based on the index
     * @param  Index of a character
     */
    selectWord(selectionStart: number): void,

    /**
     * Selects a line based on the index
     * @param  Index of a character
     */
    selectLine(selectionStart: number): void,

    /**
     * Enters editing state
     */
    enterEditing(): fabric$IIText,

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler(): void,

    /**
     * Exits from editing state
     * @return  thisArg
     * @chainable  
     */
    exitEditing(): fabric$IIText,

    /**
     * Inserts a character where cursor is (replacing selection if one exists)
     * @param  Characters to insert
     */
    insertChars(_chars: string, useCopiedStyle?: boolean): void,

    /**
     * Inserts new style object
     * @param  Index of a line
     * @param  Index of a char
     * @param  True if it's end of line
     */
    insertNewlineStyleObject(lineIndex: number, charIndex: number, isEndOfLine: boolean): void,

    /**
     * Inserts style object for a given line/char index
     * @param  Index of a line
     * @param  Index of a char
     * @param  Style object to insert, if given
     */
    insertCharStyleObject(lineIndex: number, charIndex: number, isEndOfLine: boolean): void,

    /**
     * Inserts style object(s)
     * @param  Characters at the location where style is inserted
     * @param  True if it's end of line
     * @param  Style to insert
     */
    insertStyleObjects(_chars: string, isEndOfLine: boolean, useCopiedStyle?: boolean): void,

    /**
     * Shifts line styles up or down
     * @param  Index of a line
     * @param  Can be -1 or +1
     */
    shiftLineStyles(lineIndex: number, offset: number): void,

    /**
     * Removes style object
     * @param  True if cursor is at the beginning of line
     * @param  Optional index. When not given, current selectionStart is used.
     */
    removeStyleObject(isBeginningOfLine: boolean, index?: number): void,

    /**
     * Inserts new line
     */
    insertNewline(): void
} & fabric$IObject & fabric$IText & fabric$IITextOptions


declare type fabric$IITextStatic = {

    /**
     * Constructor
     * @param  Text string
     * @param  Options object
     */
    new(text: string, options?: fabric$IITextOptions): fabric$IIText,

    /**
     * Returns fabric.IText instance from an object representation
     * @param  Object to create an instance from
     */
    fromObject(object: any): fabric$IIText
} & fabric$ITextStatic


declare type fabric$ITriangleOptions = {} & fabric$IObjectOptions


declare type fabric$ITriangle = {

    /**
     * Returns complexity of an instance
     * @return  complexity of this instance
     */
    complexity(): number,

    /**
     * Returns SVG representation of an instance
     * @param  Method for further parsing of svg representation.
     * @return  svg representation of an instance
     */
    toSVG(reviver?: Function): string
} & fabric$IObject


declare interface fabric$ITriangleStatic {

    /**
     * Constructor
     * @param  Options object
     */
    new(options?: fabric$ITriangleOptions): fabric$ITriangle,

    /**
     * Returns Triangle instance from an object representation
     * @param  Object to create an instance from
     */
    fromObject(object: any): fabric$ITriangle
}

declare interface fabric$IAllFilters {
    BaseFilter: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$IBaseFilter
        },
        Blend: {

            /**
             * Constructor
             * @param  Options object
             */
            new(
                options?: {
                    color?: string,
                    mode?: string,
                    alpha?: number,
                    image?: fabric$IImage
                }): fabric$IBlendFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IBlendFilter
        },
        Brightness: {

            /**
             * Constructor
             * @param  Options object
             * @param  .brightness=0] Value to brighten the image up (0..255)
             */
            new(options?: {
                brightness: number
            }): fabric$IBrightnessFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IBrightnessFilter
        },
        Convolute: {

            /**
             * Constructor
             * @param  Options object
             * @param  .opaque=false] Opaque value (true/false)
             * @param  .matrix] Filter matrix
             */
            new(options?: {
                opaque?: boolean,
                matrix?: number[]
            }): fabric$IConvoluteFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IConvoluteFilter
        },
        GradientTransparency: {

            /**
             * Constructor
             * @param  Options object
             * @param  .threshold=100] Threshold value
             */
            new(options?: {
                threshold?: number
            }): fabric$IGradientTransparencyFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IGradientTransparencyFilter
        },
        Grayscale: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$IGrayscaleFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IGrayscaleFilter
        },
        Invert: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$IInvertFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IInvertFilter
        },
        Mask: {

            /**
             * Constructor
             * @param  Options object
             * @param  .mask] Mask image object
             * @param  .channel=0] Rgb channel (0, 1, 2 or 3)
             */
            new(options?: {
                mask?: fabric$IImage,
                channel: number
            }): fabric$IMaskFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IMaskFilter
        },
        Multiply: {

            /**
             * Constructor
             * @param  Options object
             * @param  .color=#000000] Color to multiply the image pixels with
             */
            new(options?: {
                color: string
            }): fabric$IMultiplyFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IMultiplyFilter
        },
        Noise: {

            /**
             * Constructor
             * @param  Options object
             * @param  .noise=0] Noise value
             */
            new(options?: {
                noise: number
            }): fabric$INoiseFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$INoiseFilter
        },
        Pixelate: {

            /**
             * Constructor
             * @param  Options object
             * @param  .blocksize=4] Blocksize for pixelate
             */
            new(options?: {
                blocksize?: number
            }): fabric$IPixelateFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IPixelateFilter
        },
        RemoveWhite: {

            /**
             * Constructor
             * @param  Options object
             * @param  .threshold=30] Threshold value
             * @param  .distance=20] Distance value
             */
            new(options?: {
                threshold?: number,
                distance?: number
            }): fabric$IRemoveWhiteFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IRemoveWhiteFilter
        },
        Resize: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$IResizeFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$IResizeFilter
        },
        Sepia2: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$ISepia2Filter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$ISepia2Filter
        },
        Sepia: {

            /**
             * Constructor
             * @param  Options object
             */
            new(options?: any): fabric$ISepiaFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$ISepiaFilter
        },
        Tint: {

            /**
             * Constructor
             * @param  Options object
             * @param  .color=#000000] Color to tint the image with
             * @param  .opacity] Opacity value that controls the tint effect's transparency (0..1)
             */
            new(options?: {
                color?: string,
                opacity?: number
            }): fabric$ITintFilter,

            /**
             * Returns filter instance from an object representation
             * @param  Object to create an instance from
             */
            fromObject(object: any): fabric$ITintFilter
        }
}

declare interface fabric$IBaseFilter {

    /**
     * Sets filter's properties from options
     * @param  Options object
     */
    setOptions(options?: any): void,

        /**
         * Returns object representation of an instance
         */
        toObject(): any,

        /**
         * Returns a JSON representation of an instance
         */
        toJSON(): string
}

declare type fabric$IBlendFilter = {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
} & fabric$IBaseFilter


declare type fabric$IBrightnessFilter = {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
} & fabric$IBaseFilter


declare type fabric$IConvoluteFilter = {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
} & fabric$IBaseFilter


declare interface fabric$IGradientTransparencyFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IGrayscaleFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IInvertFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IMaskFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IMultiplyFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$INoiseFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IPixelateFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IRemoveWhiteFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IResizeFilter {

    /**
     * Resize type
     */
    resizeType: string,

        /**
         * Scale factor for resizing, x axis
         */
        scaleX: number,

        /**
         * Scale factor for resizing, y axis
         */
        scaleY: number,

        /**
         * LanczosLobes parameter for lanczos filter
         */
        lanczosLobes: number,

        /**
         * Applies filter to canvas element
         * @param  Canvas element to apply filter to
         */
        applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$ISepiaFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$ISepia2Filter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$ITintFilter {

    /**
     * Applies filter to canvas element
     * @param  Canvas element to apply filter to
     */
    applyTo(canvasEl: HTMLCanvasElement): void
}

declare interface fabric$IBaseBrush {

    /**
     * Color of a brush
     */
    color: string,

        /**
         * Width of a brush
         */
        width: number,

        /**
         * Shadow object representing shadow of this shape.
         * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
        "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
        */
        shadow: fabric$IShadow | string,

        /**
         * Line endings style of a brush (one of "butt", "round", "square")
         */
        strokeLineCap: string,

        /**
         * Corner style of a brush (one of "bevil", "round", "miter")
         */
        strokeLineJoin: string,

        /**
         * Stroke Dash Array.
         */
        strokeDashArray: any[],

        /**
         * Sets shadow of an object
         * @param  Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
         */
        setShadow(options: string | any): fabric$IBaseBrush
}

declare type fabric$ICircleBrush = {

    /**
     * Width of a brush
     */
    width: number,

    /**
     * Invoked inside on mouse down and mouse move
     * @param  
     */
    drawDot(pointer: any): void,

    /**
     * 
     * @param  
     * @return  Just added pointer point
     */
    addPoint(pointer: any): fabric$IPoint
} & fabric$IBaseBrush


declare type fabric$ISprayBrush = {

    /**
     * Width of a brush
     */
    width: number,

    /**
     * Density of a spray (number of dots per chunk)
     */
    density: number,

    /**
     * Width of spray dots
     */
    dotWidth: number,

    /**
     * Width variance of spray dots
     */
    dotWidthVariance: number,

    /**
     * Whether opacity of a dot should be random
     */
    randomOpacity: boolean,

    /**
     * Whether overlapping dots (rectangles) should be removed (for performance reasons)
     */
    optimizeOverlapping: boolean,

    /**
     * 
     * @param  
     */
    addSprayChunk(pointer: any): void
} & fabric$IBaseBrush


declare type fabric$IPatternBrush = {
    getPatternSrc(): HTMLCanvasElement,
    getPatternSrcFunction(): string,

    /**
     * Creates "pattern" instance property
     */
    getPattern(): any,

    /**
     * Creates path
     */
    createPath(pathData: string): fabric$IPath
} & fabric$IPencilBrush


declare type fabric$IPencilBrush = {

    /**
     * Converts points to SVG path
     * @param  Array of points
     * @param  
     * @param  
     */
    convertPointsToSVGPath(points: {
        x: number,
        y: number
    }[], minX?: number, minY?: number): string[],

    /**
     * Creates fabric.Path object to add on canvas
     * @param  Path data
     */
    createPath(pathData: string): fabric$IPath
} & fabric$IBaseBrush


declare var BaseBrush: {
    new(): fabric$IBaseBrush
};

declare var CircleBrush: {
    new(canvas: fabric$ICanvas): fabric$ICircle
};

declare var SprayBrush: {
    new(canvas: fabric$ICanvas): fabric$ISprayBrush
};

declare var PencilBrush: {
    new(canvas: fabric$ICanvas): fabric$IPencilBrush
};

declare var PatternBrush: {
    new(canvas: fabric$ICanvas): fabric$IPatternBrush
};

declare interface fabric$IUtilAnimationOptions {

    /**
     * Starting value
     */
    startValue?: number,

        /**
         * Ending value
         */
        endValue?: number,

        /**
         * Value to modify the property by
         */
        byValue: number,

        /**
         * Duration of change (in ms)
         */
        duration?: number,

        /**
         * Callback; invoked on every value change
         */
        onChange?: Function,

        /**
         * Callback; invoked when value change is completed
         */
        onComplete?: Function,

        /**
         * Easing function
         */
        easing?: Function
}

declare interface fabric$IUtilAnimation {

    /**
     * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
     * @param  Animation options
     */
    animate(options?: fabric$IUtilAnimationOptions): void,

        /**
         * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
         * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
         * @param  Callback to invoke
         */
        requestAnimFrame(callback: Function): void
}

declare interface fabric$IUtilAminEaseFunction {
    (t: number, b: number, c: number, d: number): number
}

declare interface fabric$IUtilAnimEase {
    easeInBack: fabric$IUtilAminEaseFunction,
        easeInBounce: fabric$IUtilAminEaseFunction,
        easeInCirc: fabric$IUtilAminEaseFunction,
        easeInCubic: fabric$IUtilAminEaseFunction,
        easeInElastic: fabric$IUtilAminEaseFunction,
        easeInExpo: fabric$IUtilAminEaseFunction,
        easeInOutBack: fabric$IUtilAminEaseFunction,
        easeInOutBounce: fabric$IUtilAminEaseFunction,
        easeInOutCirc: fabric$IUtilAminEaseFunction,
        easeInOutCubic: fabric$IUtilAminEaseFunction,
        easeInOutElastic: fabric$IUtilAminEaseFunction,
        easeInOutExpo: fabric$IUtilAminEaseFunction,
        easeInOutQuad: fabric$IUtilAminEaseFunction,
        easeInOutQuart: fabric$IUtilAminEaseFunction,
        easeInOutQuint: fabric$IUtilAminEaseFunction,
        easeInOutSine: fabric$IUtilAminEaseFunction,
        easeInQuad: fabric$IUtilAminEaseFunction,
        easeInQuart: fabric$IUtilAminEaseFunction,
        easeInQuint: fabric$IUtilAminEaseFunction,
        easeInSine: fabric$IUtilAminEaseFunction,
        easeOutBack: fabric$IUtilAminEaseFunction,
        easeOutBounce: fabric$IUtilAminEaseFunction,
        easeOutCirc: fabric$IUtilAminEaseFunction,
        easeOutCubic: fabric$IUtilAminEaseFunction,
        easeOutElastic: fabric$IUtilAminEaseFunction,
        easeOutExpo: fabric$IUtilAminEaseFunction,
        easeOutQuad: fabric$IUtilAminEaseFunction,
        easeOutQuart: fabric$IUtilAminEaseFunction,
        easeOutQuint: fabric$IUtilAminEaseFunction,
        easeOutSine: fabric$IUtilAminEaseFunction
}

declare interface fabric$IUtilArc {

    /**
     * Draws arc
     * @param  
     * @param  
     * @param  
     * @param  
     */
    drawArc(ctx: CanvasRenderingContext2D, fx: number, fy: number, coords: number[]): void,

        /**
         * Calculate bounding box of a elliptic-arc
         * @param  start point of arc
         * @param  
         * @param  horizontal radius
         * @param  vertical radius
         * @param  angle of horizontal axe
         * @param  1 or 0, whatever the arc is the big or the small on the 2 points
         * @param  1 or 0, 1 clockwise or counterclockwise direction
         * @param  end point of arc
         * @param  
         */
        getBoundsOfArc(
            fx: number,
            fy: number,
            rx: number,
            ry: number,
            rot: number,
            large: number,
            sweep: number,
            tx: number,
            ty: number): fabric$IPoint[],

        /**
         * Calculate bounding box of a beziercurve
         * @param  starting point
         * @param  
         * @param  first control point
         * @param  
         * @param  secondo control point
         * @param  
         * @param  end of beizer
         * @param  
         */
        getBoundsOfCurve(
            x0: number,
            y0: number,
            x1: number,
            y1: number,
            x2: number,
            y2: number,
            x3: number,
            y3: number): fabric$IPoint[]
}

declare interface fabric$IUtilDomEvent {

    /**
     * Cross-browser wrapper for getting event's coordinates
     * @param  Event object
     * @param  &lt;canvas> element on which object selection is drawn
     */
    getPointer(event: Event, upperCanvasEl: HTMLCanvasElement): fabric$IPoint,

        /**
         * Adds an event listener to an element
         * @param  
         * @param  
         * @param  
         */
        addListener(element: HTMLElement, eventName: string, handler: Function): void,

        /**
         * Removes an event listener from an element
         * @param  
         * @param  
         * @param  
         */
        removeListener(element: HTMLElement, eventName: string, handler: Function): void
}

declare interface fabric$IUtilDomMisc {

    /**
     * Takes id and returns an element with that id (if one exists in a document)
     * @param  
     */
    getById(id: string | HTMLElement): HTMLElement,

        /**
         * Converts an array-like object (e.g. arguments or NodeList) to an array
         * @param  
         */
        toArray(arrayLike: any): any[],

        /**
         * Creates specified element with specified attributes
         * @memberOf  fabric.util
         * @param  Type of an element to create
         * @param  Attributes to set on an element
         * @return  Newly created element
         */
        makeElement(tagName: string, attributes?: any): HTMLElement,

        /**
         * Adds class to an element
         * @param  Element to add class to
         * @param  Class to add to an element
         */
        addClass(element: HTMLElement, classname: string): void,

        /**
         * Wraps element with another element
         * @param  Element to wrap
         * @param  Element to wrap with
         * @param  Attributes to set on a wrapper
         */
        wrapElement(
            element: HTMLElement,
            wrapper: HTMLElement | string,
            attributes?: any): HTMLElement,

        /**
         * Returns element scroll offsets
         * @param  Element to operate on
         * @param  Upper canvas element
         */
        getScrollLeftTop(
            element: HTMLElement,
            upperCanvasEl: HTMLElement): {
            left: number,
            right: number
        },

        /**
         * Returns offset for a given element
         * @param  Element to get offset for
         */
        getElementOffset(element: HTMLElement): {
            left: number,
            right: number
        },

        /**
         * Returns style attribute value of a given element
         * @param  Element to get style attribute for
         * @param  Style attribute to get for element
         */
        getElementStyle(elment: HTMLElement, attr: string): string,

        /**
         * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
         * @memberOf  fabric.util
         * @param  URL of a script to load
         * @param  Callback to execute when script is finished loading
         */
        getScript(url: string, callback: Function): void,

        /**
         * Makes element unselectable
         * @param  Element to make unselectable
         */
        makeElementUnselectable(element: HTMLElement): HTMLElement,

        /**
         * Makes element selectable
         * @param  Element to make selectable
         */
        makeElementSelectable(element: HTMLElement): HTMLElement
}

declare interface fabric$IUtilDomRequest {

    /**
     * Cross-browser abstraction for sending XMLHttpRequest
     * @param  URL to send XMLHttpRequest to
     * @param  Options object
     * @param  .method="GET"]
     * @param  .onComplete Callback to invoke when request is completed
     */
    request(
        url: string,
        options?: {
            method?: string,
            onComplete: Function
        }): XMLHttpRequest
}

declare interface fabric$IUtilDomStyle {

    /**
     * Cross-browser wrapper for setting element's style
     * @param  
     * @param  
     */
    setStyle(element: HTMLElement, styles: any): HTMLElement
}

declare interface fabric$IUtilArray {

    /**
     * Invokes method on all items in a given array
     * @param  Array to iterate over
     * @param  Name of a method to invoke
     */
    invoke(array: any[], method: string): any[],

        /**
         * Finds minimum value in array (not necessarily "first" one)
         * @param  Array to iterate over
         * @param  
         */
        min(array: any[], byProperty: string): any,

        /**
         * Finds maximum value in array (not necessarily "first" one)
         * @param  Array to iterate over
         * @param  
         */
        max(array: any[], byProperty: string): any
}

declare interface fabric$IUtilClass {

    /**
     * Helper for creation of "classes".
     * @param  optional "Class" to inherit from
     * @param  Properties shared by all instances of this class
    (be careful modifying objects defined here as this would affect all instances)
    */
    createClass(parent: Function, properties?: any): void,

        /**
         * Helper for creation of "classes".
         * @param  Properties shared by all instances of this class
        (be careful modifying objects defined here as this would affect all instances)
        */
        createClass(properties?: any): void
}

declare interface fabric$IUtilObject {

    /**
     * Copies all enumerable properties of one object to another
     * @param  Where to copy to
     * @param  Where to copy from
     */
    extend(destination: any, source: any): any,

        /**
         * Creates an empty object and copies all enumerable properties of another object to it
         * @memberOf  fabric.util.object
         * @param  Object to clone
         * @return  
         */
        clone(object: any): any
}

declare interface fabric$IUtilString {

    /**
     * Camelizes a string
     * @param  String to camelize
     */
    camelize(string: string): string,

        /**
         * Capitalizes a string
         * @param  String to capitalize
         * @param  If true only first letter is capitalized
        and other letters stay untouched, if false first letter is capitalized
        and other letters are converted to lowercase.
        */
        capitalize(string: string, firstLetterOnly: boolean): string,

        /**
         * Escapes XML in a string
         * @param  String to escape
         */
        escapeXml(string: string): string
}

declare interface fabric$IUtilMisc {

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @param  
     * @param  
     */
    removeFromArray(array: any[], value: any): any[],

        /**
         * Returns random number between 2 specified ones.
         * @param  lower limit
         * @param  upper limit
         */
        getRandomInt(min: number, max: number): number,

        /**
         * Transforms degrees to radians.
         * @param  value in degrees
         */
        degreesToRadians(degrees: number): number,

        /**
         * Transforms radians to degrees.
         * @memberOf  fabric.util
         * @param  value in radians
         */
        radiansToDegrees(radians: number): number,

        /**
         * Rotates `point` around `origin` with `radians`
         * @param  The point to rotate
         * @param  The origin of the rotation
         * @param  The radians of the angle for the rotation
         */
        rotatePoint(point: fabric$IPoint, origin: fabric$IPoint, radians: number): fabric$IPoint,

        /**
         * Apply transform t to point p
         * @param  The point to transform
         * @param  The transform
         * @param  Indicates that the offset should not be applied
         */
        transformPoint(p: fabric$IPoint, t: any[], ignoreOffset?: boolean): fabric$IPoint,

        /**
         * Invert transformation t
         * @param  The transform
         */
        invertTransform(t: any[]): any[],

        /**
         * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
         * @param  number to operate on
         * @param  number of fraction digits to "leave"
         */
        toFixed(number: number, fractionDigits: number): number,

        /**
         * Converts from attribute value to pixel value if applicable.
         * Returns converted pixels or original value not converted.
         * @param  number to operate on
         */
        parseUnit(value: number | string, fontSize?: number): number | string,

        /**
         * Function which always returns `false`.
         */
        falseFunction(): boolean,

        /**
         * Returns klass "Class" object of given namespace
         * @param  Type of object (eg. 'circle')
         * @param  Namespace to get klass "Class" object from
         */
        getKlass(type: string, namespace: string): any,

        /**
         * Returns object of given namespace
         * @param  Namespace string e.g. 'fabric.Image.filter' or 'fabric'
         */
        resolveNamespace(namespace: string): any,

        /**
         * Loads image element from given url and passes it to a callback
         * @param  URL representing an image
         * @param  Callback; invoked with loaded image
         * @param  Context to invoke callback in
         * @param  crossOrigin value to set image element to
         */
        loadImage(
            url: string,
            callback: (image: HTMLImageElement) => {},
            context?: any,
            crossOrigin?: boolean): void,

        /**
         * Creates corresponding fabric instances from their object representations
         * @param  Objects to enliven
         * @param  Callback to invoke when all objects are created
         * @param  Namespace to get klass "Class" object from
         * @param  Method for further parsing of object elements, called after each fabric object created.
         */
        enlivenObjects(
            objects: any[],
            callback: Function,
            namespace: string,
            reviver?: Function): void,

        /**
         * Groups SVG elements (usually those retrieved from SVG document)
         * @param  SVG elements to group
         * @param  Options object
         */
        groupSVGElements(elements: any[], options?: any, path?: any): fabric$IPathGroup,

        /**
         * Populates an object with properties of another object
         * @param  Source object
         * @param  Destination object
         * @param  Propertie names to include
         */
        populateWithProperties(source: any, destination: any, properties: any): void,

        /**
         * Draws a dashed line between two points
         * This method is used to draw dashed line around selection area.
         * @param  context
         * @param  start x coordinate
         * @param  start y coordinate
         * @param  end x coordinate
         * @param  end y coordinate
         * @param  dash array pattern
         */
        drawDashedLine(
            ctx: CanvasRenderingContext2D,
            x: number,
            y: number,
            x2: number,
            y2: number,
            da: any[]): void,

        /**
         * Creates canvas element and initializes it via excanvas if necessary
         * @param  optional canvas element to initialize;
        when not given, element is created implicitly
        */
        createCanvasElement(canvasEl?: HTMLCanvasElement): HTMLCanvasElement,

        /**
         * Creates image element (works on client and node)
         */
        createImage(): HTMLImageElement,

        /**
         * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
         * @param  "Class" to create accessors for
         */
        createAccessors(klass: any): any,

        /**
         * 
         * @param  Object implementing `clipTo` method
         * @param  Context to clip
         */
        clipContext(receiver: fabric$IObject, ctx: CanvasRenderingContext2D): void,

        /**
         * Multiply matrix A by matrix B to nest transformations
         * @param  First transformMatrix
         * @param  Second transformMatrix
         */
        multiplyTransformMatrices(a: any[], b: any[]): any[],

        /**
         * Returns string representation of function body
         * @param  Function to get body of
         */
        getFunctionBody(fn: Function): string,

        /**
         * Returns true if context has transparent pixel
         * at specified location (taking tolerance into account)
         * @param  context
         * @param  x coordinate
         * @param  y coordinate
         * @param  Tolerance
         */
        isTransparent(
            ctx: CanvasRenderingContext2D,
            x: number,
            y: number,
            tolerance: number): boolean
}

declare type fabric$IUtil = {
    ease: fabric$IUtilAnimEase,
    array: fabric$IUtilArray,
    object: fabric$IUtilObject,
    string: fabric$IUtilString
} & fabric$IUtilAnimation & fabric$IUtilArc & fabric$IObservable & fabric$IUtilDomEvent & fabric$IUtilDomMisc & fabric$IUtilDomRequest & fabric$IUtilDomStyle & fabric$IUtilClass & fabric$IUtilMisc