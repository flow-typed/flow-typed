/**
 * Flowtype definitions for cachefactory
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'CacheFactory' {
    declare export interface IStoreImplementation {
        getItem(key: string): string,
            setItem(key: string, value: string): void,
            removeItem(key: string): void
    }
    declare export interface CacheGetOptions {
        onExpire(key: string, value: any): any
    }
    declare export interface CachePutOptions {
        maxAge?: number,
            storeOnReject?: boolean,
            storeOnResolve?: boolean,
            created?: Date,
            access?: Date,
            expires?: Date
    }
    declare export type CacheTouchOptions = {} & CachePutOptions

    declare export interface CacheOptions {
        cacheFlushInterval?: number,
            capacity?: number,
            deleteOnExpire?: string,
            disabled?: boolean,
            maxAge?: number,
            recycleFreq?: number,
            storeOnReject?: boolean,
            storeOnResolve?: boolean,
            storageImpl?: IStoreImplementation,
            storageMode?: string,
            storagePrefix?: string,
            onExpire(key: string, value: any): any
    }
    declare export interface ICache {
        $$id: string,

            /**
             * Return the item with the given key.options, if provided, must be an object.
             * 
            If the cache is in passive mode, then options.onExpire can be a function that will be called with the key
            and value of the requested item if the requested item is expired, with the get call itself returning undefined.
             * @param key 
             * @returns  
            */
            get<T>(key: string, options?: CacheGetOptions): T,

            /**
             * Insert the item with the given key and value into the cache.options, if provided, must be an object.
             * 
            If inserting a promise, options.storeOnReject determines whether to insert the rejection value if the promise
            rejects (overriding the default storeOnReject setting for the cache). If inserting a promise, options.storeOnResolve
            determines whether to insert the resolved value if the promise resolves (overriding the default storeOnResolve setting for the cache).
             * @param key 
             * @param value 
             * @param options 
            */
            put<T>(key: string, value: T, options?: CachePutOptions): void,

            /**
             * Remove and return the item with the given key, if it is in the cache.
             * @param key 
             * @returns  
             */
            remove<T>(key: string): T,

            /**
             * Remove all items in the cache.
             */
            removeAll(): void,

            /**
             * Remove and return all expired items in the cache.
             * @returns  
             */
            removeExpired(): {
                [key: string]: any
            },

            /**
             * Completely destroy this cache and its data.
             * @returns  
             */
            destroy(): void,

            /**
             * Returns an object containing information about the cache.
             * @param key 
             */
            info(): CacheInfo,

            /**
             * Returns an object containing information about the item with the given key, if the item is in the cache.
             * @param key 
             */
            info(key: string): CacheItemInfo,

            /**
             * Return the keys of all items in the cache as an object.
             * @returns  
             */
            keySet(): any,

            /**
             * Return the keys of all items in the cache as an array.
             * @returns  []
             */
            keys(): Array<string>,

            /**
             * Enable the cache.
             */
            enable(): void,

            /**
             * Disable the cache.
             */
            disable(): void,

            /**
             * cache#touch() will "touch" all items in the cache.
             * cache#touch(key) will "touch" the item with the given key.
             * @param key 
             */
            touch(key?: string, options?: CacheTouchOptions): void,

            /**
             * Set the cacheFlushInterval for the cache.
             * @param cacheFlushInterval 
             */
            setCacheFlushInterval(cacheFlushInterval: number): void,

            /**
             * Set the capacity for the cache.Setting this lower than the current item count will result in those items being removed.
             * @param capacity 
             */
            setCapacity(capacity: number): void,

            /**
             * Set the deleteOnExpire for the cache.
             * @param deleteOnExpire 
             */
            setDeleteOnExpire(deleteOnExpire: string): void,

            /**
             * Set the maxAge for the cache.
             */
            setMaxAge(maxAge: number): void,

            /**
             * Set the onExpire for the cache.
             * @param onExpire 
             */
            setOnExpire(onExpire: Function): void,

            /**
             * Set the recycleFreq for the cache.
             * @param recycleFreq 
             */
            setRecycleFreq(recycleFreq: number): void,

            /**
             * Set the storageMode for the cache.This will move data from the current storage medium to the new one.
             * @param storageMode 
             */
            setStorageMode(storageMode: string): void,

            /**
             * Set multiple options for the cache at a time.Setting strict to true will reset options for the cache
             * that are not specifically set in the options hash to CacheFactoryProvider.defaults.
             * @param options 
             */
            setOptions(options: CacheOptions, strict?: boolean): void,

            /**
             * Return the values of all items in the cache as an array.
             * @returns  Array<any>
             */
            values(): Array<any >
    }
    declare export interface ICacheFactory {
        BinaryHeap: IBinaryHeap,
            utils: IUtils,
            defaults: CacheOptions,

            /**
             * Create a cache. cache must not already exist. cacheId must be a string. options is an optional argument and must be an object.
             * Any options you pass here will override any default options.
             * @param cacheId 
             * @param options 
             * @returns  ICache
             */
            (cacheId: string, options?: CacheOptions): ICache,

            /**
             * Create a cache. cache must not already exist. cacheId must be a string. options is an optional argument and must be an object.
             * Any options you pass here will override any default options.
             * @param cacheId 
             * @param options 
             * @returns  ICache
             */
            createCache(cacheId: string, options?: CacheOptions): ICache,

            /**
             * Return the cache with the given cacheId.
             * @param cacheId The id of the cache storage.
             * @returns  ICache
             */
            get(cacheId: string, options?: CacheOptions): ICache,

            /**
             * Return an object of key- value pairs, the keys being cache ids and the values being the result of .info() being called on each cache.
             * @returns  CacheInfo
             */
            info(): CacheInfo,

            /**
             * Return the ids of all registered caches as an object.
             * @returns  : ICache}
             */
            keySet(): {
                [key: string]: ICache
            },

            /**
             * Return the ids of all registered caches as an array.
             * @returns  Array<string>
             */
            keys(): Array<string>,

            /**
             * Destroy the cache with the given cacheId.
             * @param cacheId 
             */
            destroy(cacheId: string): void,

            /**
             * Destroy all registered caches.
             */
            destroyAll(): void,

            /**
             * Remove all data from all registered caches.
             */
            clearAll(): void,

            /**
             * Enable all registered caches.
             */
            enableAll(): void,

            /**
             * Disable all registered caches.
             */
            disableAll(): void,

            /**
             * Call.touch() on all registered caches.
             */
            touchAll(): void,

            /**
             * Call.removeExpired() on all registered caches.Returns a hash of any expired items, keyed by cache id.
             * @returns  
             */
            removeExpiredFromAll(): Array<{
                [key: string]: Array<{
                    [key: string]: any
                } >
            } >
    }
    declare export interface IUtils {
        isNumber(value: any): boolean,
            isString(value: any): boolean,
            isObject(value: any): boolean,
            isFunction(value: any): boolean,
            equals(a: any, b: any): boolean,
            fromJson(value: any): {},
            Promise: any
    }
    declare export interface HeapItem {
        key: string,
            accessed: Date
    }
    declare export interface IBinaryHeap {
        (w?: IWeightFunc, c?: ICompareFunc): void,
        heap: Array<HeapItem>,
            weightFunc: IWeightFunc,
            compareFunc: ICompareFunc,
            push(node: HeapItem): void,
            pop(): HeapItem,
            peek(): HeapItem,
            remove(node: HeapItem): HeapItem,
            removeAll(): void,
            size(): Number
    }
    declare export interface IWeightFunc {
        (x: T): T
    }
    declare export interface ICompareFunc {
        (x: T, y: T): boolean
    }
    declare export interface CacheInfo {
        size: Number,
            caches: {
                [key: string]: any
            },
            capacity: Number,
            maxAge: Number,
            deleteOnExpire: string,
            onExpire: Function,
            cacheFlushInterval: Number,
            recycleFreq: Number,
            storageMode: string,
            storageImpl: IStoreImplementation,
            disabled: boolean,
            storagePrefix: string,
            storeOnResolve: boolean,
            storeOnReject: boolean
    }
    declare export interface CacheItemInfo {
        created: Date,
            accessed: Date,
            expires: Date,
            isExpired: boolean
    }
}
declare
var CacheFactory: CacheFactory.ICacheFactory;
declare module 'cachefactory' {
    declare module.exports: typeof CacheFactory
}