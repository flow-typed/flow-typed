// @flow
/**
 * Flowtype definitions for _debugger
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module '3d-bin-packing' {
    declare module.exports: typeof bws$packer
}
declare var ReactDataGrid: typeof undefined;
/**
 * <p> Cumulated lengths of current layer. </p>
 * 
<p> {@link Scrapped} represents an edge of the current layer under construction. </p>
 * @author  Bill Knechtel, <br>
Migrated and Refactored by Jeongho Nam <http://samchon.org>
*/
declare class Scrap {

    /**
     * Cumulated length on the X-axis in 3D.
     */
    cumx: number;

    /**
     * Cumulated length on the Z-axis in 3D.
     */
    cumz: number;

    /**
     * Default Constructor.
     */
    constructor(): this;

    /**
     * Initialization Constructor.
     * @param cumx Cumulated length on the x-axis.
     * @param cumz Cumulated length on the z-axis.
     */
    constructor(cumx: number, cumz: number): this
}
declare module 'packer' {

    /**
     * 
     * @brief  Packer, a solver of 3d bin packing with multiple wrappers.
     * @details  * <p> Packer is a facade class supporting packing operations in user side. You can solve a packing problem
    by constructing Packer class with {
     * @link  WrapperArray wrappers} and {
     * @link  InstanceArray instances} to
    pack and executing {
     * @link  optimize Packer.optimize()} method. </p>

    <p> In background side, deducting packing solution, those algorithms are used. </p>
    <ul>
    <li> <a href="http://betterwaysystems.github.io/packer/reference/AirForceBinPacking.pdf" target="_blank">
    Airforce Bin Packing; 3D pallet packing problem: A human intelligence-based heuristic approach </a>
    </li>
    <li> Genetic Algorithm </li>
    <li> Greedy and Back-tracking algorithm </li>
    </ul>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Packer mixins undefined.Entity {

        /**
         * Candidate wrappers who can contain instances.
         */
        wrapperArray: WrapperArray;

        /**
         * Instances trying to pack into the wrapper.
         */
        instanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param wrapperArray Candidate wrappers who can contain instances.
         * @param instanceArray Instances to be packed into some wrappers.
         */
        constructor(wrapperArray: WrapperArray, instanceArray: InstanceArray): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Get wrapperArray.
         */
        getWrapperArray(): WrapperArray;

        /**
         * Get instanceArray.
         */
        getInstanceArray(): InstanceArray;

        /**
         * <p> Deduct
         */
        optimize(): WrapperArray;

        /**
         * 
         * @brief  Initialize sequence list (gene_array).
         * @details  * <p> Deducts initial sequence list by such assumption: </p>

        <ul>
        <li> Cost of larger wrapper is less than smaller one, within framework of price per volume unit. </li>
        <ul>
        <li> Wrapper Larger: (price: $1,000, volume: 100cm^3 -> price per volume unit: $10 / cm^3) </li>
        <li> Wrapper Smaller: (price: $700, volume: 50cm^3 -> price per volume unit: $14 / cm^3) </li>
        <li> Larger's <u>cost</u> is less than Smaller, within framework of price per volume unit </li>
        </ul>
        </ul>

        <p> Method {
         * @link  initGenes initGenes()} constructs {
         * @link  WrapperGroup WrapperGroups} corresponding
        with the {
         * @link  wrapperArray} and allocates {
         * @link  instanceArray instances} to a {
         * @link  WrapperGroup},
        has the smallest <u>cost</u> between containbles. </p>

        <p> After executing packing solution by {
         * @link  WrapperGroup.optimize WrapperGroup.optimize()}, trying to
        {
         * @link  repack re-pack} each {
         * @link  WrapperGroup} to another type of {
         * @link  Wrapper}, deducts the best
        solution between them. It's the initial sequence list of genetic algorithm. </p>
         * @return  Initial sequence list.
        */
        initGenes(): GAWrapperArray;

        /**
         * Try to repack each wrappers to another type.
         * @param $wrappers Wrappers to repack.
         * @return  Re-packed wrappers.
         */
        repack($wrappers: WrapperArray): WrapperArray;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * Bridge of {@link Packer} for {@link InstanceForm repeated instances}.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class PackerForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Initializer Constructor.
         * @param instanceFormArray Form of Instances to pack.
         * @param wrapperArray Type of Wrappers to be used.
         */
        constructor(instanceFormArray: InstanceFormArray, wrapperArray: WrapperArray): this;
        construct(xml: undefined.XML): void;
        optimize(): WrapperArray;
        getInstanceFormArray(): InstanceFormArray;
        getWrapperArray(): WrapperArray;
        TAG(): string;
        toXML(): undefined.XML;
        toPacker(): Packer
    }

    /**
     * An array of {@link InstanceForm} objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceFormArray mixins undefined.EntityArrayCollection<InstanceForm>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createChild(xml: undefined.XML): InstanceForm;
        TAG(): string;
        CHILD_TAG(): string;

        /**
         * Convert {@link InstanceForm} objects to {@link InstanceArray}.
         * @return  An array of instance containing repeated instances in {
         * @link  InstanceForm} objects.
         */
        toInstanceArray(): InstanceArray
    }

    /**
     * <p> A repeated Instance. </p>
     * 
    <p> InstanceForm is an utility class for repeated {@link Instance}. It is designed for shrinking
    volume of network message I/O by storing {@link count repeated count}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class InstanceForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(instance?: boxologic$Instance, count?: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;
        key(): any;
        getInstance(): boxologic$Instance;
        getCount(): number;
        setCount(val: number): void;
        $name: string;
        $width: string;
        $height: string;
        $length: string;
        $count: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Repeated {@link instance} to {@link InstanceArray}.
         * @details  * <p> Contains the {
         * @link  instance repeated instance} to an {
         * @link  InstanceArray} to make
        {
         * @link  instance} to participate in the packing process. The returned {
         * @link  InstanceArray} will be
        registered on {
         * @link  Packer.instanceArray}.
         * @return  An array of instance containing repeated {
         * @link  instance}.
        */
        toInstanceArray(): InstanceArray
    }
    declare class WrapperArray mixins undefined.EntityArrayCollection<Wrapper>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrapper;

        /**
         * Get (calculate) price.
         */
        getPrice(): number;

        /**
         * Get (calculate) utilization rate.
         */
        getUtilization(): number;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }
    declare class GAWrapperArray mixins WrapperArray {
        instanceArray: InstanceArray;
        result: std.HashMap<string,
        WrapperGroup>;

        /**
         * Construct from instances.
         * @param instanceArray Instances to be wrapped.
         */
        constructor(instanceArray: InstanceArray): this;

        /**
         * 
         * @brief  Copy Constructor.
         */
        constructor(genes: GAWrapperArray): this;

        /**
         * 
         * @brief  Get optimization result.
         * @return  result map.
         */
        getResult(): std.HashMap<string,
        WrapperGroup>;
        less(obj: GAWrapperArray): boolean
    }

    /**
     * An interface of physical 3D-instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare type Instance = {

        /**
         * Get name.
         */
        getName(): string,

        /**
         * Get width, length on the X-axis in 3D.
         */
        getWidth(): number,

        /**
         * Get height, length on the Y-axis in 3D.
         */
        getHeight(): number,

        /**
         * Get length, length on the Z-axis in 3D.
         */
        getLength(): number,

        /**
         * Get (calculate) volume.
         * @return  width x height x length
         */
        getVolume(): number,

        /**
         * Set name.
         */
        setName(val: string): void,

        /**
         * Set width, length on the X-axis in 3D.
         */
        setWidth(val: number): void,

        /**
         * Set height, length on the Y-axis in 3D.
         */
        setHeight(val: number): void,

        /**
         * Set length, length on the Z-axis in 3D.
         */
        setLength(val: number): void,

        /**
         * <p> A type, identifier of derived class. </p>
         * 
        <h4> Derived types </h4>
        <ul>
        <li> {@link Product product} </li>
        <li> {@link Wrapper wrapper} </li>
        <ul>
        */
        TYPE(): string
    }

    /**
     * An array of Instance objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceArray mixins undefined.EntityArray<boxologic$Instance>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): boxologic$Instance;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }

    /**
     * A product.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Product mixins undefined.Entity, Instance {

        /**
         * <p> Name, key of the Product. </p>
         * 
        <p> The name must be unique because a name identifies a {@link Product}. </p>
        */
        name: string;

        /**
         * Width of the Product, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Product, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Product, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param name Name, identifier of the Product.
         * @param width Width, length on the X-axis in 3D.
         * @param height Height, length on the Y-axis in 3D.
         * @param length Length, length on the Z-axis in 3D.
         */
        constructor(name: string, width: number, height: number, length: number): this;

        /**
         * Key of a Product is its name.
         */
        key(): any;

        /**
         * 
         * @inheritdoc  
         */
        getName(): string;

        /**
         * 
         * @inheritdoc  
         */
        getWidth(): number;

        /**
         * 
         * @inheritdoc  
         */
        getHeight(): number;

        /**
         * 
         * @inheritdoc  
         */
        getLength(): number;

        /**
         * 
         * @inheritdoc  
         */
        getVolume(): number;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * <p> Wrap represents an act wrap(ping). </p>
     * 
    <p> {@link Wrap} is a class represents an act wrapping an {@link Instance} to an {@link Wrapper}.
    To represent the relationship, Wrap uses Bridge and Capsular patterns to links and intermediates
    relationship between Wrapper and Instance. </p>

    <p> Wrap also helps packing optimization and 3d-visualization with its own members
    {
     * @link  orientation} and position variables {
     * @link  x}, {
     * @link  y} and {
     * @link  z}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Wrap mixins undefined.Entity {

        /**
         * A wrapper wrapping the {@link instance}.
         */
        wrapper: Wrapper;

        /**
         * An instance wrapped into the {@link wrapper}.
         */
        instance: boxologic$Instance;

        /**
         * Coordinate-X of the instance placement in the wrapper.
         */
        x: number;

        /**
         * Coordinate-Y of the instance placement in the wrapper.
         */
        y: number;

        /**
         * Coordinate-Z of the instance placement in the wrapper.
         */
        z: number;

        /**
         * Placement orientation of wrapped {@link instance}.
         */
        orientation: number;

        /**
         * 
         */
        color: number;

        /**
         * Construct from a Wrapper.
         * @param wrapper A wrapper who will contain an instance.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from a Wrapper and Instance with its position and default orientation 1.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number): this;

        /**
         * Construct from a Wrapper and Instance with its position and orientation.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param orientation Placement orientation of wrapped {
         * @link  instance}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number, orientation: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Factory method of wrapped Instance.
         * @param type Type of contained Instance's type.
         */
        createInstance(type: string): boxologic$Instance;

        /**
         * Set orientation.
         * @param orientation Orientation code (1 to 6).
         */
        setOrientation(orientation: number): void;

        /**
         * Set position.
         * @param x Coordinate-X of the instance placement in the wrapper.
         * @param y Coordinate-Y of the instance placement in the wrapper.
         * @param z Coordinate-Z of the instance placement in the wrapper.
         */
        setPosition(x: number, y: number, z: number): void;

        /**
         * 
         * @brief  Estimate orientation by given size.
         * @param width Width by placement.
         * @param height Height by placement.
         * @param length Length by placement.
         */
        estimateOrientation(width: number, height: number, length: number): void;

        /**
         * 
         * @brief  Orientation change is occured in level of the packer.
         * @details  orientation Packer's new orientation.
         */
        changeWrapperOrientation(orientation: number): void;

        /**
         * Get wrapper.
         */
        getWrapper(): Wrapper;

        /**
         * Get instance.
         */
        getInstance(): boxologic$Instance;

        /**
         * Get x.
         */
        getX(): number;

        /**
         * Get y.
         */
        getY(): number;

        /**
         * Get z.
         */
        getZ(): number;

        /**
         * Get orientation.
         */
        getOrientation(): number;

        /**
         * Get width.
         */
        getWidth(): number;

        /**
         * Get height.
         */
        getHeight(): number;

        /**
         * Get length.
         */
        getLength(): number;

        /**
         * Get volume.
         */
        getVolume(): number;
        $instanceName: string;
        $layoutScale: string;
        $position: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * 
         * @param geometry 
         * @return  A shape and its boundary lines as 3D-objects.
         */
        toDisplayObjects(geometry: THREE$Geometry): std.Vector<THREE$Object3D >
    }

    /**
     * A wrapper wrapping instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Wrapper mixins undefined.EntityDeque<Wrap>, Instance {

        /**
         * <p> Name, key of the Wrapper. </p>
         * 
        <p> The name represents a type of Wrapper and identifies the Wrapper. </p>
        */
        name: string;

        /**
         * Price, cost of using an Wrapper.
         */
        price: number;

        /**
         * Width of the Wrapper, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Wrapper, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Wrapper, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * <p> Thickness, margin of a Wrapper causes shrinkness of containable volume. </p>
         * 
        <p> The thickness reduces each dimension's containable size (dimension - 2thickness),
        so finally, it reduces total containable volume (-8  thickness^3). </p>
        */
        thickness: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from members.
         * @param name Name, identifier of a Wrapper.
         * @param price Price, issued cost for a type of the Wrapper.
         * @param width Width, dimensional length on the X-axis in 3D.
         * @param height Height, dimensional length on the Y-axis in 3D.
         * @param length Length, dimensional length on the Z-axis in 3D.
         * @param thickness A thickness causes shrinkness on containable volume.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;
        construct(xml: undefined.XML): void;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrap;

        /**
         * Key of a Wrapper is its name.
         */
        key(): any;

        /**
         * Get name.
         */
        getName(): string;

        /**
         * Get price.
         */
        getPrice(): number;

        /**
         * Get width, length on X-axis in 3D.
         */
        getWidth(): number;

        /**
         * Get height, length on Y-axis in 3D.
         */
        getHeight(): number;

        /**
         * Get length, length on Z-axis in 3D.
         */
        getLength(): number;

        /**
         * Get thickness.
         */
        getThickness(): number;

        /**
         * <p> Get (calculate) containable width, length on the X-axis in 3D. </p>
         * 
        <p> Calculates containable width considering the {@link thickness}. </p>
         * @return  width - (2 x thickness)
        */
        getContainableWidth(): number;

        /**
         * <p> Get (calculate) containable height, length on the Y-axis in 3D. </p>
         * 
        <p> Calculates containable height considering the {@link thickness}. </p>
         * @return  height - (2 x thickness)
        */
        getContainableHeight(): number;

        /**
         * <p> Get (calculate) containable length, length on the Z-axis in 3D. </p>
         * 
        <p> Calculates containable length considering the {@link thickness}. </p>
         * @return  length - (2 x thickness)
        */
        getContainableLength(): number;

        /**
         * <p> Get (calculate) volume. </p>
         * 
        <h4> Notice </h4>
        <p> If {@link thickness} of the Wrapper is not 0, the volume does not mean containable volume.
        In that case, use {@link containableVolume} instead. </p>
         * @return  width x height x length
        */
        getVolume(): number;

        /**
         * <p> Get (calculate) containable volume. </p>
         * 
        <p> Calculates containable volume considering the {@link thickness}. </p>
         * @return  volume - {(2 x thickness) ^ 3}
        */
        getContainableVolume(): number;

        /**
         * Get utilization ratio of containable volume.
         * @return  utilization ratio.
         */
        getUtilization(): number;
        equal_to(obj: Wrapper): boolean;

        /**
         * <p> Wrapper is enough greater? </p>
         * 
        <p> Test whether the Wrapper is enough greater than an Instance to contain. </p>
         * @param instance An Instance to test.
         * @return  Enough greater or not.
        */
        containable(instance: boxologic$Instance): boolean;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * Set price.
         */
        setPrice(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * Set thickness.
         */
        setThickness(val: number): void;
        $name: string;
        $price: string;
        $width: string;
        $height: string;
        $length: string;
        $thickness: string;
        $scale: string;
        $spaceUtilization: string;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Convert to a canvas containing 3D elements. </p>
         * @param endIndex 
         * @return  A 3D-canvans printing the Wrapper and its children {
         * @link  Wrap wrapped}
        {
         * @link  Instance instances} with those boundary lines.
        */
        toCanvas(endIndex?: number): HTMLCanvasElement
    }

    /**
     * A group of {@link Wrapper Wrappers} with same type.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class WrapperGroup mixins WrapperArray {

        /**
         * <p> A sample, standard of the WrapperGroup. </p>
         * 
        <p> The sample represents what type of Wrappers are grouped into the WrapperGroup. </p>
        */
        sample: Wrapper;

        /**
         * Allocated instances.
         */
        allocatedInstanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapperGroup: WrapperGroup): this;

        /**
         * Construct from a sample.
         * @param sample A sample, standard of the WrapperGroup.
         */
        constructor(sample: Wrapper): this;

        /**
         * Construct from members of the {@link sample}.
         * @param name Name, identifier of the sample.
         * @param price Price, issued cost for a type of the sample.
         * @param width Width, dimensional length on the X-axis in 3D, of the sample.
         * @param height Height, dimensional length on the Y-axis in 3D, of the sample.
         * @param length Length, dimensional length on the Z-axis in 3D, of the sample.
         * @param thickness A thickness, causes shrinkness on containable volume, of the sample.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;

        /**
         * Key of a WrapperGroup is dependent on its sample.
         */
        key(): any;

        /**
         * Get sample.
         */
        getSample(): Wrapper;

        /**
         * Get allocated instances.
         */
        getAllocatedInstanceArray(): InstanceArray;

        /**
         * Get (calculate) price.
         * @return  (Price of the sample) x (numbers of children Wrappers)
         */
        getPrice(): number;

        /**
         * 
         * @inheritdoc  
         */
        getUtilization(): number;

        /**
         * <p> Allocate instance(s) to the WrapperGroup. </p>
         * 
        <p> Inspect the instance is enough small to be wrapped into an empty wrapper. If the instance
        is enough small, registers the instance (or repeated instances) to the {@link reserveds} and
        returns <code>true</code>. If the instance is too large to be capsuled, returns <code>false</code>. </p>

        <h4>Note</h4>
        <p> The word <u>the instance is enough small to be wrapped into the empty wrapper</u> means
        the instance can be contained into an empty, a new wrapper contaning nothing literally. </p>

        <p> In the method allocate(), it doesn't consider how many instances are wrapped into ordinary
        wrapper and how much volumes are consumed.  </p>
         * @param instance An Instance to allocate.
         * @param n Repeating number of the <i>instance</i>.
         * @return  Whether the instance is enough small to be wrapped into a (new) wrapper
        of same type with the sample.
        */
        allocate(instance: boxologic$Instance, n?: number): boolean;

        /**
         * <p> Run optimization in level of the group. </p>
         * 
        <p> The optimization routine begins by creating a {@link Wrapper} like the {@link sample}. Then
        try to pack {@link allocatedInstanceArray allocated instances} to the {@link Wrapper} as a lot as
        possible. If there're some {@link Wrappers} can't be packed by overloading, then create a new
        {
         * @link  Wrapper} again and try to pack {
         * @link  allocatedInstanceArray instances} again, too. </p>

        <p> Repeats those steps until all {
         * @link  alloctedInstanceArray instances} are {
         * @link  Wrap packed}
        so that there's not any {
         * @link  Instance instance} left. </p>

        <h4> Warning </h4>
        <p> When call this {
         * @link  optimize optimize()} method, ordinary children {
         * @link  Wrapper} objects
        in the {
         * @link  WrapperGroup} will be substituted with the newly optimized {
         * @link  Wrapper} objects. </p>
        */
        optimize(): void;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string
    }
    declare class Editor<T>mixins React.Component<{
        dataProvider: undefined.EntityArrayCollection<T >
    }, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createColumns(): AdazzleReactDataGrid.Column[];
        render(): JSX.Element
    }
    declare type ItemEditorProps = {
        application: PackerApplication,
        instances: InstanceFormArray,
        wrappers: WrapperArray
    }
    declare class ItemEditor mixins React.Component<ItemEditorProps, {}>{
        render(): JSX.Element
    }
    declare class InstanceEditor mixins Editor<InstanceForm>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class WrapperEditor mixins Editor<Wrapper>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class PackerApplication mixins React.Component<{}, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        pack(): void;
        drawWrapper(wrapper: Wrapper, index?: number): void;
        render(): JSX.Element;
        main(): void
    }
    declare class ResultViewer mixins React.Component<WrapperViewerProps, {}>{
        drawWrapper(wrapper: Wrapper, index?: number): void;
        refresh(): void;
        render(): JSX.Element
    }
    declare type WrapperViewerProps = {
        application: PackerApplication,
        wrappers: WrapperArray
    }
}
declare class TabNavigator mixins React.Component<flex$TabNavigatorProps, flex$TabNavigatorProps>{
    render(): JSX.Element
}

declare class NavigatorContent mixins React.Component<flex$NavigatorContentProps, flex$NavigatorContentProps>{
    render(): JSX.Element
}

declare type flex$TabNavigatorProps = {
    selectedIndex?: number,
    style?: React.CSSProperties
}

declare type flex$NavigatorContentProps = {
    label: string
}
declare module 'MD5' {
    declare     var VERSION: string;
    declare     var BY_ASCII: number;
    declare     var BY_UTF16: number;
    declare     function calc(str: string, option?: number): string
}

/**
 * 
 * @summary  Interface for "saveAs" function.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface FileSaver {
    (data: Blob, filename: string, disableAutoBOM?: boolean): void
}
declare var saveAs: FileSaver;
declare module 'file-saver' {
    declare     var fileSaver: {
        saveAs: typeof saveAs
    };
    declare module.exports: typeof fileSaver
}
declare interface FinchCallback {
    (bindings?: any, childCallback?: () => void): any
}
declare interface ExpandedCallback {
    setup?: FinchCallback,
        load?: FinchCallback,
        unload?: FinchCallback,
        teardown?: FinchCallback
}
declare interface ObserveCallback {
    (...args: any[]): string
}
declare interface FinchOptions {
    CoerceParameterTypes?: boolean
}
declare interface FinchStatic {
    route(route: string, callback: FinchCallback): void,
        route(route: string, callbacks: ExpandedCallback): void,
        call(uri: string): void,
        observe(argN: string[], callback: (params: ObserveCallback) => void): void,
        observe(callback: (params: ObserveCallback) => void): void,
        observe(...args: any[]): void,
        navigate(uri: string, queryParams?: any, doUpdate?: boolean): void,
        navigate(uri: string, doUpdate: boolean): void,
        navigate(queryParams: any, doUpdate?: boolean): void,
        listen(): boolean,
        ignore(): boolean,
        abort(): void,
        options(options: FinchOptions): void
}
declare var Finch: FinchStatic;
declare module 'finch' {
    declare module.exports: typeof Finch
}
declare interface HeadroomOptions {
    offset?: number,
        tolerance?: any,
        classes?: {
            initial?: string,
            notBottom?: string,
            notTop?: string,
            pinned?: string,
            top?: string,
            unpinned?: string
        },
        scroller?: Element,
        onPin?: () => void,
        onUnPin?: () => void,
        onTop?: () => void,
        onNotTop?: () => void
}
declare class Headroom {
    constructor(element: CSG$Node, options?: HeadroomOptions): this;
    constructor(element: Element, options?: HeadroomOptions): this;
    init: () => void
}
declare interface HubSpotPaceInterfaces$PaceOptions {

    /**
     * How long should it take for the bar to animate to a new point after receiving it
     */
    catchupTime?: number,

        /**
         * How quickly should the bar be moving before it has any progress info from a new source in %/ms
         */
        initialRate?: number,

        /**
         * What is the minimum amount of time the bar should be on the screen. Irrespective of this number, the bar will always be on screen for 33  (100 / maxProgressPerFrame) + ghostTime ms.
         */
        minTime?: number,

        /**
         * What is the minimum amount of time the bar should sit after the last update before disappearing
         */
        ghostTime?: number,

        /**
         * Its easy for a bunch of the bar to be eaten in the first few frames before we know how much there is to load. This limits how much of the bar can be used per frame
         */
        maxProgressPerFrame?: number,

        /**
         * This tweaks the animation easing
         */
        easeFactor?: number,

        /**
         * Should pace automatically start when the page is loaded, or should it wait for `start` to be called? Always false if pace is loaded with AMD or CommonJS.
         */
        startOnPageLoad?: boolean,

        /**
         * Should we restart the browser when pushState or replaceState is called?  (Generally means ajax navigation has occured)
         */
        restartOnPushState?: boolean,

        /**
         * Should we show the progress bar for every ajax request (not just regular or ajax-y page navigation)? Set to false to disable. If so, how many ms does the request have to be running for before we show the progress?
         */
        restartOnRequestAfter?: boolean | number,

        /**
         * What element should the pace element be appended to on the page?
         */
        target?: string,
        document?: boolean | string,
        elements?: boolean | HubSpotPaceInterfaces$PaceElementsOptions,
        eventLag?: boolean | HubSpotPaceInterfaces$PaceEventLagOptions,
        ajax?: boolean | HubSpotPaceInterfaces$PaceAjaxOptions
}

declare interface HubSpotPaceInterfaces$PaceElementsOptions {

    /**
     * How frequently in ms should we check for the elements being tested for using the element monitor?
     */
    checkInterval?: number,

        /**
         * What elements should we wait for before deciding the page is fully loaded (not required)
         */
        selectors?: string[]
}

declare interface HubSpotPaceInterfaces$PaceEventLagOptions {

    /**
     * When we first start measuring event lag, not much is going on in the browser yet, so it's not uncommon for the numbers to be abnormally low for the first few samples. This configures how many samples we need before we consider a low number to mean completion.
     */
    minSamples?: number,

        /**
         * How many samples should we average to decide what the current lag is?
         */
        sampleCount?: number,

        /**
         * Above how many ms of lag is the CPU considered busy?
         */
        lagThreshold?: number
}

declare interface HubSpotPaceInterfaces$PaceAjaxOptions {

    /**
     * Which HTTP methods should we track?
     */
    trackMethods?: string[],

        /**
         * Should we track web socket connections?
         */
        trackWebSockets?: boolean,

        /**
         * A list of regular expressions or substrings of URLS we should ignore (for both tracking and restarting)
         */
        ignoreURLs?: (string | RegExp)[]
}

declare interface HubSpotPaceInterfaces$Pace {
    options: HubSpotPaceInterfaces$PaceOptions,
        start(options?: HubSpotPaceInterfaces$PaceOptions): void,
        restart(): void,
        stop(): void,
        track(fn: () => void, ...args: any[]): void,
        ignore(fn: () => void, ...args: any[]): void,
        on(event: string, handler: (...args: any[]) => void, context?: any): void,
        off(event: string, handler?: (...args: any[]) => void): void,
        once(event: string, handler: (...args: any[]) => void, context?: any): void
}
declare var pace: HubSpotPaceInterfaces$Pace;
declare module 'HubSpot-pace' {
    declare module.exports: typeof pace
}
declare module 'JSONStream' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export function parse(pattern: any): NodeJS$ReadWriteStream
    declare     export function stringify(): NodeJS$ReadWriteStream
    declare     export function stringifyObject(): NodeJS$ReadWriteStream
}

declare var npm$namespace$THREE: {
    OrbitControls: typeof THREE$OrbitControls,
    SpriteCanvasMaterial: typeof THREE$SpriteCanvasMaterial,
    RenderableObject: typeof THREE$RenderableObject,
    RenderableFace: typeof THREE$RenderableFace,
    RenderableVertex: typeof THREE$RenderableVertex,
    RenderableLine: typeof THREE$RenderableLine,
    RenderableSprite: typeof THREE$RenderableSprite,
    Projector: typeof THREE$Projector,
}
declare var CSG: {
    fromCSG: (
        csg: CSG,
        defaultColor: any) => {
        colorMesh: Mesh,
        wireframe: Mesh,
        boundLen: number
    },
    getGeometryVertex: (geometry: any, vertex_position: any) => number
};

declare function THREE$OrbitControls(object: any, domElement: any): void

declare function THREE$SpriteCanvasMaterial(parameters?: any): void

declare interface THREE$ICanvasRendererOptions {
    canvas?: HTMLCanvasElement,
        alpha?: boolean
}

declare class CanvasRenderer mixins Renderer {
    domElement: HTMLCanvasElement;
    constructor(parameters: THREE$ICanvasRendererOptions): this;
    supportsVertexTextures(): void;
    setFaceCulling: () => void;
    getPixelRatio(): number;
    setPixelRatio(value: any): void;
    setSize(width: any, height: any, updateStyle: any): void;
    setViewport(x: any, y: any, width: any, height: any): void;
    setScissor(): void;
    enableScissorTest(): void;
    setClearColor(color: any, alpha: any): void;
    setClearColorHex(hex: any, alpha: any): void;
    getClearColor(): Color;
    getClearAlpha(): number;
    getMaxAnisotropy(): number;
    clear(): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    render(
        scene: Scene,
        camera: Camera,
        renderTarget?: RenderTarget,
        forceClear?: boolean): void;
    calculateLights(): void;
    calculateLight(position: any, normal: any, color: any): void;
    renderSprite(v1: any, element: any, material: any): void;
    renderLine(v1: any, v2: any, element: any, material: any): void;
    renderFace3(
        v1: any,
        v2: any,
        v3: any,
        uv1: any,
        uv2: any,
        uv3: any,
        element: any,
        material: any): void;
    drawTriangle(x0: any, y0: any, x1: any, y1: any, x2: any, y2: any): void;
    strokePath(color: any, linewidth: any, linecap: any, linejoin: any): void;
    fillPath(color: any): void;
    onTextureUpdate(event: any): void;
    textureToPattern(texture: any): void;
    patternPath(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        texture: any): void;
    clipImage(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        image: any): void;
    expand(v1: any, v2: any, pixels: any): void;
    setOpacity(value: any): void;
    setBlending(value: any): void;
    setLineWidth(value: any): void;
    setLineCap(value: any): void;
    setLineJoin(value: any): void;
    setStrokeStyle(value: any): void;
    setFillStyle(value: any): void;
    setLineDash(value: any): void
}

declare function THREE$RenderableObject(): void

declare function THREE$RenderableFace(): void

declare function THREE$RenderableVertex(): void

declare function THREE$RenderableLine(): void

declare function THREE$RenderableSprite(): void

declare function THREE$Projector(): void
declare var npm$namespace$OpenJsCad: {
    makeAbsoluteUrl: typeof OpenJsCad$makeAbsoluteUrl,
    isChrome: typeof OpenJsCad$isChrome,
    runMainInWorker: typeof OpenJsCad$runMainInWorker,
    expandResultObjectArray: typeof OpenJsCad$expandResultObjectArray,
    checkResult: typeof OpenJsCad$checkResult,
    resultToCompactBinary: typeof OpenJsCad$resultToCompactBinary,
    resultFromCompactBinary: typeof OpenJsCad$resultFromCompactBinary,
    parseJsCadScriptSync: typeof OpenJsCad$parseJsCadScriptSync,
    parseJsCadScriptASync: typeof OpenJsCad$parseJsCadScriptASync,
    getWindowURL: typeof OpenJsCad$getWindowURL,
    textToBlobUrl: typeof OpenJsCad$textToBlobUrl,
    revokeBlobUrl: typeof OpenJsCad$revokeBlobUrl,
    FileSystemApiErrorHandler: typeof OpenJsCad$FileSystemApiErrorHandler,
    AlertUserOfUncaughtExceptions: typeof OpenJsCad$AlertUserOfUncaughtExceptions,
    getParamDefinitions: typeof OpenJsCad$getParamDefinitions,
}
declare interface OpenJsCad$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare var log: OpenJsCad$ILog;

declare interface OpenJsCad$IViewerOptions {
    drawLines?: boolean,
        drawFaces?: boolean,
        color?: number[],
        bgColor?: number,
        noWebGL?: boolean
}

declare type OpenJsCad$ProcessorOptions = {
    verbose?: boolean,
    viewerwidth?: number,
    viewerheight?: number,
    viewerheightratio?: number
} & OpenJsCad$IViewerOptions


declare class Viewer {
    constructor(containerElm: any, size: any, options: OpenJsCad$IViewerOptions): this;
    createScene(drawAxes: any, axLen: any): void;
    createCamera(): void;
    createControls(canvas: any): void;
    webGLAvailable(): boolean;
    createRenderer(bool_noWebGL: any): void;
    render(): void;
    animate(): void;
    cancelAnimate(): void;
    refreshRenderer(bool_noWebGL: any): void;
    drawAxes(axLen: any): void;
    setCsg(csg: any, resetZoom: any): void;
    applyDrawOptions(): void;
    clear(): void;
    getUserMeshes(str?: any): THREE$Object3D[];
    resetZoom(r: any): void;
    parseSizeParams(): void;
    handleResize(): void
}

declare function OpenJsCad$makeAbsoluteUrl(url: any, baseurl: any): any

declare function OpenJsCad$isChrome(): boolean

declare function OpenJsCad$runMainInWorker(mainParameters: any): void

declare function OpenJsCad$expandResultObjectArray(result: any): any

declare function OpenJsCad$checkResult(result: any): void

declare function OpenJsCad$resultToCompactBinary(resultin: any): any

declare function OpenJsCad$resultFromCompactBinary(resultin: any): any

declare function OpenJsCad$parseJsCadScriptSync(script: any, mainParameters: any, debugging: any): any

declare function OpenJsCad$parseJsCadScriptASync(script: any, mainParameters: any, options: any, callback: any): Worker

declare function OpenJsCad$getWindowURL(): URL

declare function OpenJsCad$textToBlobUrl(txt: any): string

declare function OpenJsCad$revokeBlobUrl(url: any): void

declare function OpenJsCad$FileSystemApiErrorHandler(fileError: any, operation: any): void

declare function OpenJsCad$AlertUserOfUncaughtExceptions(): void

declare function OpenJsCad$getParamDefinitions(script: any): any[]

declare interface OpenJsCad$EventHandler {
    (ev?: Event): any
}


/**
 * options parameter:
 * - drawLines: display wireframe lines
- drawFaces: display surfaces
- bgColor: canvas background color
- color: object color
- viewerwidth, viewerheight: set rendering size. Works with any css unit.
     viewerheight can also be specified as a ratio to width, ie number e (0, 1]
- noWebGL: force render without webGL
- verbose: show additional info (currently only time used for rendering)
*/
declare interface OpenJsCad$ViewerSize {
    widthDefault: string,
        heightDefault: string,
        width: number,
        height: number,
        heightratio: number
}

declare class Processor {
    constructor(containerdiv: HTMLDivElement, options?: OpenJsCad$ProcessorOptions, onchange?: OpenJsCad$EventHandler): this;
    convertToSolid(obj: any): any;
    cleanOption(option: any, deflt: any): any;
    toggleDrawOption(str: any): boolean;
    setDrawOption(str: any, bool: any): void;
    handleResize(): void;
    createElements(): void;
    getFilenameForRenderedObject(): string;
    setRenderedObjects(obj: any): void;
    setSelectedObjectIndex(index: number): void;
    selectedFormat(): any;
    selectedFormatInfo(): any;
    updateDownloadLink(): void;
    clearViewer(): void;
    abort(): void;
    enableItems(): void;
    setOpenJsCadPath(path: string): void;
    addLibrary(lib: any): void;
    setError(txt: string): void;
    setDebugging(debugging: boolean): void;
    setJsCad(script: string, filename?: string): void;
    getParamValues(): {};
    rebuildSolid(): void;
    hasSolid(): boolean;
    isProcessing(): boolean;
    clearOutputFile(): void;
    generateOutputFile(): void;
    currentObjectToBlob(): any;
    supportedFormatsForCurrentObject(): string[];
    formatInfo(format: any): any;
    downloadLinkTextForCurrentObject(): string;
    generateOutputFileBlobUrl(): void;
    generateOutputFileFileSystem(): void;
    createParamControls(): void
}
declare interface Window {
    Worker: Worker,
        webkitURL: URL,
        requestFileSystem: any,
        webkitRequestFileSystem: any
}
declare interface IAMFStringOptions {
    unit: string
}
declare class CxG {
    toStlString(): string;
    toStlBinary(): void;
    toAMFString(AMFStringOptions?: IAMFStringOptions): void;
    getBounds(): CxG[];
    transform(matrix4x4: CSG$Matrix4x4): CxG;
    mirrored(plane: CSG$Plane): CxG;
    mirroredX(): CxG;
    mirroredY(): CxG;
    mirroredZ(): CxG;
    translate(v: number[]): CxG;
    translate(v: CSG$Vector3D): CxG;
    scale(f: CSG$Vector3D): CxG;
    rotateX(deg: number): CxG;
    rotateY(deg: number): CxG;
    rotateZ(deg: number): CxG;
    rotate(rotationCenter: CSG$Vector3D, rotationAxis: CSG$Vector3D, degrees: number): CxG;
    rotateEulerAngles(alpha: number, beta: number, gamma: number, position: number[]): CxG
}
declare interface ICenter {
    center(cAxes: string[]): CxG
}
declare class CSG mixins CxG, ICenter {
    polygons: CSG$Polygon[];
    properties: CSG$Properties;
    isCanonicalized: boolean;
    isRetesselated: boolean;
    cachedBoundingBox: CSG$Vector3D[];
    defaultResolution2D: number;
    defaultResolution3D: number;
    fromPolygons(polygons: CSG$Polygon[]): CSG;
    fromSlices(options: any): CSG;
    fromObject(obj: any): CSG;
    fromCompactBinary(bin: any): CSG;
    toPolygons(): CSG$Polygon[];
    union(csg: CSG[]): CSG;
    union(csg: CSG): CSG;
    unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    unionForNonIntersecting(csg: CSG): CSG;
    subtract(csg: CSG[]): CSG;
    subtract(csg: CSG): CSG;
    subtractSub(csg: CSG, retesselate: boolean, canonicalize: boolean): CSG;
    intersect(csg: CSG[]): CSG;
    intersect(csg: CSG): CSG;
    intersectSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    invert(): CSG;
    transform1(matrix4x4: CSG$Matrix4x4): CSG;
    transform(matrix4x4: CSG$Matrix4x4): CSG;
    toString(): string;
    expand(radius: number, resolution: number): CSG;
    contract(radius: number, resolution: number): CSG;
    stretchAtPlane(normal: number[], point: number[], length: number): CSG;
    expandedShell(radius: number, resolution: number, unionWithThis: boolean): CSG;
    canonicalized(): CSG;
    reTesselated(): CSG;
    getBounds(): CSG$Vector3D[];
    mayOverlap(csg: CSG): boolean;
    cutByPlane(plane: CSG$Plane): CSG;
    connectTo(
        myConnector: CSG$Connector,
        otherConnector: CSG$Connector,
        mirror: boolean,
        normalrotation: number): CSG;
    setShared(shared: undefined.Shared): CSG;
    setColor(args: any): CSG;
    toCompactBinary(): {
        class: string,
        numPolygons: number,
        numVerticesPerPolygon: Uint32Array,
        polygonPlaneIndexes: Uint32Array,
        polygonSharedIndexes: Uint32Array,
        polygonVertices: Uint32Array,
        vertexData: Float64Array,
        planeData: Float64Array,
        shared: undefined.Shared[]
    };
    toPointCloud(cuberadius: any): CSG;
    getTransformationAndInverseTransformationToFlatLying(): any;
    getTransformationToFlatLying(): any;
    lieFlat(): CSG;
    projectToOrthoNormalBasis(orthobasis: CSG$OrthoNormalBasis): CAG;
    sectionCut(orthobasis: CSG$OrthoNormalBasis): CAG;
    fixTJunctions(): CSG;
    toTriangles(): any[];
    getFeatures(features: any): any;
    center(cAxes: string[]): CxG;
    toX3D(): Blob;
    toStlBinary(): Blob;
    toStlString(): string;
    toAMFString(m: IAMFStringOptions): Blob
}
declare class Polygon2D mixins CAG {
    constructor(points: CSG$Vector2D[]): this
}
declare class CAG mixins CxG, ICenter {
    sides: CAG$Side[];
    isCanonicalized: boolean;
    constructor(): this;
    fromSides(sides: CAG$Side[]): CAG;
    fromPoints(points: CSG$Vector2D[]): CAG;
    fromPointsNoCheck(points: CSG$Vector2D[]): CAG;
    fromFakeCSG(csg: CSG): CAG;
    linesIntersect(
        p0start: CSG$Vector2D,
        p0end: CSG$Vector2D,
        p1start: CSG$Vector2D,
        p1end: CSG$Vector2D): boolean;
    circle(options: CSG$ICircleOptions): CAG;
    rectangle(options: CSG$IRectangleOptions): CAG;
    roundedRectangle(options: any): CAG;
    fromCompactBinary(bin: any): CAG;
    toString(): string;
    _toCSGWall(z0: any, z1: any): CSG;
    _toVector3DPairs(m: CSG$Matrix4x4): CSG$Vector3D[][];
    _toPlanePolygons(options: any): CSG$Polygon[];
    _toWallPolygons(options: any): any[];
    union(cag: CAG[]): CAG;
    union(cag: CAG): CAG;
    subtract(cag: CAG[]): CAG;
    subtract(cag: CAG): CAG;
    intersect(cag: CAG[]): CAG;
    intersect(cag: CAG): CAG;
    transform(matrix4x4: CSG$Matrix4x4): CAG;
    area(): number;
    flipped(): CAG;
    getBounds(): CSG$Vector2D[];
    isSelfIntersecting(): boolean;
    expandedShell(radius: number, resolution: number): CAG;
    expand(radius: number, resolution: number): CAG;
    contract(radius: number, resolution: number): CAG;
    extrudeInOrthonormalBasis(orthonormalbasis: CSG$OrthoNormalBasis, depth: number, options?: any): CSG;
    extrudeInPlane(axis1: any, axis2: any, depth: any, options: any): CSG;
    extrude(options: CAG_extrude_options): CSG;
    rotateExtrude(options: any): CSG;
    check(): void;
    canonicalized(): CAG;
    toCompactBinary(): {
        class: string,
        sideVertexIndices: Uint32Array,
        vertexData: Float64Array
    };
    getOutlinePaths(): CSG$Path2D[];
    overCutInsideCorners(cutterradius: any): CAG;
    center(cAxes: string[]): CxG;
    toDxf(): Blob;
    PathsToDxf(paths: CSG$Path2D[]): Blob
}
declare class Vertex {
    pos: CSG$Vector2D;
    tag: number;
    constructor(pos: CSG$Vector2D): this;
    toString(): string;
    getTag(): number
}

declare class Side mixins CxG {
    vertex0: CAG$Vertex;
    vertex1: CAG$Vertex;
    tag: number;
    constructor(vertex0: CAG$Vertex, vertex1: CAG$Vertex): this;
    _fromFakePolygon(polygon: CSG$Polygon): CAG$Side;
    toString(): string;
    toPolygon3D(z0: any, z1: any): CSG$Polygon;
    transform(matrix4x4: CSG$Matrix4x4): CAG$Side;
    flipped(): CAG$Side;
    direction(): CSG$Vector2D;
    getTag(): number;
    lengthSquared(): number;
    length(): number
}

declare class fuzzyCAGFactory {
    vertexfactory: CSG$fuzzyFactory;
    constructor(): this;
    getVertex(sourcevertex: CAG$Vertex): CAG$Vertex;
    getSide(sourceside: CAG$Side): CAG$Side;
    getCAG(sourcecag: CAG): CAG
}
declare interface CAG_extrude_options {
    offset?: number[],
        twistangle?: number,
        twiststeps?: number
}
/**
 * The PayPalItem class defines an optional itemization for a payment.
 * @see  https://developer.paypal.com/docs/api/#item-object for more details.
 */
declare class PayPalItem {

    /**
     * 
     * @param name Name of the item. 127 characters max.
     * @param quantity Number of units. 10 characters max.
     * @param price Unit price for this item 10 characters max.
    May be negative for "coupon" etc.
     * @param currency ISO standard currency code.
     * @param sku The stock keeping unit for this item. 50 characters max (optional).
    */
    constructor(name: string, quantity: number, price: string, currency: string, sku?: string): this;

    /**
     * Name of the item. 127 characters max.
     */
    name: string;

    /**
     * Number of units. 10 characters max.
     */
    quantity: number;

    /**
     * Unit price for this item 10 characters max.
     * May be negative for "coupon" etc.
     */
    price: string;

    /**
     * ISO standard currency code.
     */
    currency: string;

    /**
     * The stock keeping unit for this item. 50 characters max (optional).
     */
    sku: string
}
/**
 * The PayPalPaymentDetails class defines optional amount details.
 * @see  https://developer.paypal.com/webapps/developer/docs/api/#details-object for more details.
 */
declare class PayPalPaymentDetails {

    /**
     * 
     * @param subtotal Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     * @param shipping Amount charged for shipping. 10 characters max with support for 2 decimal places.
     * @param tax Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    constructor(subtotal: string, shipping: string, tax: string): this;

    /**
     * Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     */
    subtotal: string;

    /**
     * Amount charged for shipping. 10 characters max with support for 2 decimal places.
     */
    shipping: string;

    /**
     * Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    tax: string
}
/**
 * Convenience constructor. Returns a PayPalPayment with the specified amount, currency code, and short description.
 */
declare class PayPalPayment {

    /**
     * 
     * @param amount The amount of the payment.
     * @param currencyCode The ISO 4217 currency for the payment.
     * @param shortDescription A short descripton of the payment.
     * @param intent "Sale" for an immediate payment.
    "Auth" for payment authorization only, to be captured separately at a later time.
     "Order" for taking an order, with authorization and capture to be done separately at a later time.
     * @param details PayPalPaymentDetails object (optional).
    */
    constructor(amount: string, currency: string, shortDescription: string, intent: string, details?: PayPalPaymentDetails): this;

    /**
     * The amount of the payment.
     */
    amount: string;

    /**
     * The ISO 4217 currency for the payment.
     */
    currency: string;

    /**
     * A short descripton of the payment.
     */
    shortDescription: string;

    /**
     *  "Sale" for an immediate payment.
     * "Auth" for payment authorization only, to be captured separately at a later time.
    "Order" for taking an order, with authorization and capture to be done separately at a later time.
    */
    intent: string;

    /**
     * PayPalPaymentDetails object (optional).
     */
    details: PayPalPaymentDetails;

    /**
     * Optional invoice number, for your tracking purposes. (up to 256 characters).
     */
    invoiceNumber: string;

    /**
     * Optional text, for your tracking purposes. (up to 256 characters).
     */
    custom: string;

    /**
     * Optional text which will appear on the customer's credit card statement. (up to 22 characters).
     */
    softDescriptor: string;

    /**
     * Optional Build Notation code ("BN code"), obtained from partnerprogram@paypal.com, for your tracking purposes.
     */
    bnCode: string;

    /**
     * Optional array of PayPalItem objects.
     * @see  PayPalItem
     * @note  If you provide one or more items, be sure that the various prices correctly sum to the payment `amount` or to `paymentDetails.subtotal`.
     */
    items: PayPalItem[];

    /**
     * Optional customer shipping address, if your app wishes to provide this to the SDK.
     * @note  make sure to set `payPalShippingAddressOption` in PayPalConfiguration to 1 or 3.
     */
    shippingAddress: PayPalShippingAddress
}
declare class PayPalShippingAddress {

    /**
     * 
     * @param recipientName Name of the recipient at this address. 50 characters max.
     * @param line1 Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     * @param line2 Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     * @param city City name. 50 characters max.
     * @param state 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     * @param postalCode ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     * @param countryCode 2-letter country code. 2 characters max.
     */
    constructor(recipientName: string, line1: string, line2: string, city: string, state: string, postalCode: string, countryCode: string): this;

    /**
     * Name of the recipient at this address. 50 characters max.
     */
    recipientName: string;

    /**
     * Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     */
    line1: string;

    /**
     * Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     */
    line2: string;

    /**
     * City name. 50 characters max.
     */
    city: string;

    /**
     * 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     */
    state: string;

    /**
     * ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     */
    postalCode: string;

    /**
     * 2-letter country code. 2 characters max.
     */
    countryCode: string
}
declare class PayPalConfiguration {

    /**
     * 
     * @param options A set of options to use. Any options not specified will assume default values.
     */
    constructor(options?: PayPalConfigurationOptions): this;

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail: string;

    /**
     * Will be overridden by phone country code used in most recent PayPal login
     */
    defaultUserPhoneCountryCode: string;

    /**
     * Will be overridden by phone number used in most recent PayPal login.
     * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
     */
    defaultUserPhoneNumber: string;

    /**
     * Your company name, as it should be displayed to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantName: string;

    /**
     * URL of your company's privacy policy, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantPrivacyPolicyURL: string;

    /**
     * URL of your company's user agreement, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantUserAgreementURL: string;

    /**
     * If set to false, the SDK will only support paying with PayPal, not with credit cards.
     * This applies only to single payments (via PayPalPaymentViewController).
    Future payments (via PayPalFuturePaymentViewController) always use PayPal.
    Defaults to true.
    */
    acceptCreditCards: boolean;

    /**
     * For single payments, options for the shipping address.
     * 
    - 0 - PayPalShippingAddressOptionNone: no shipping address applies.

    - 1 - PayPalShippingAddressOptionProvided: shipping address will be provided by your app,
       in the shippingAddress property of PayPalPayment.

    - 2 - PayPalShippingAddressOptionPayPal: user will choose from shipping addresses on file
       for their PayPal account.

    - 3 - PayPalShippingAddressOptionBoth: user will choose from the shipping address provided by your app,
       in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

    Defaults to 0 (PayPalShippingAddressOptionNone).
    */
    payPalShippingAddressOption: number;

    /**
     * If set to true, then if the user pays via their PayPal account,
     * the SDK will remember the user's PayPal username or phone number;
    if the user pays via their credit card, then the SDK will remember
    the PayPal Vault token representing the user's credit card.

    If set to false, then any previously-remembered username, phone number, or
    credit card token will be erased, and subsequent payment information will
    not be remembered.

    Defaults to true.
    */
    rememberUser: boolean;

    /**
     * If not set, or if set to nil, defaults to the device's current language setting.
     * 
    Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
    If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
    If the library does not contain localized strings for a specified language, then will fall back to American English.

    If you specify only a language code, and that code matches the device's currently preferred language,
    then the library will attempt to use the device's current region as well.
    E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

    These localizations are currently included:
    da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
    */
    languageOrLocale: string;

    /**
     * Normally, the SDK blurs the screen when the app is backgrounded,
     * to obscure credit card or PayPal account details in the iOS-saved screenshot.
    If your app already does its own blurring upon backgrounding, you might choose to disable this.
    Defaults to false.
    */
    disableBlurWhenBackgrounding: boolean;

    /**
     * If you will present the SDK's view controller within a popover, then set this property to true.
     * Defaults to false. (iOS only)
     */
    presentingInPopover: boolean;

    /**
     * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
     * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

    This setting will have no effect if the operation mode is production.
    Defaults to false.
    */
    forceDefaultsInSandbox: boolean;

    /**
     * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPassword: string;

    /**
     * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPin: string
}
/**
 * Describes the options that can be passed into the PayPalConfiguration class constructor.
 */
declare interface PayPalConfigurationOptions {

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail?: string,

        /**
         * Will be overridden by phone country code used in most recent PayPal login
         */
        defaultUserPhoneCountryCode?: string,

        /**
         * Will be overridden by phone number used in most recent PayPal login.
         * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
         */
        defaultUserPhoneNumber?: string,

        /**
         * Your company name, as it should be displayed to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantName?: string,

        /**
         * URL of your company's privacy policy, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantPrivacyPolicyURL?: string,

        /**
         * URL of your company's user agreement, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantUserAgreementURL?: string,

        /**
         * If set to false, the SDK will only support paying with PayPal, not with credit cards.
         * This applies only to single payments (via PayPalPaymentViewController).
        Future payments (via PayPalFuturePaymentViewController) always use PayPal.
        Defaults to true.
        */
        acceptCreditCards?: boolean,

        /**
         * For single payments, options for the shipping address.
         * 
        - 0 - PayPalShippingAddressOptionNone?: no shipping address applies.

        - 1 - PayPalShippingAddressOptionProvided?: shipping address will be provided by your app,
           in the shippingAddress property of PayPalPayment.

        - 2 - PayPalShippingAddressOptionPayPal?: user will choose from shipping addresses on file
           for their PayPal account.

        - 3 - PayPalShippingAddressOptionBoth?: user will choose from the shipping address provided by your app,
           in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

        Defaults to 0 (PayPalShippingAddressOptionNone).
        */
        payPalShippingAddressOption?: number,

        /**
         * If set to true, then if the user pays via their PayPal account,
         * the SDK will remember the user's PayPal username or phone number;
        if the user pays via their credit card, then the SDK will remember
        the PayPal Vault token representing the user's credit card.

        If set to false, then any previously-remembered username, phone number, or
        credit card token will be erased, and subsequent payment information will
        not be remembered.

        Defaults to true.
        */
        rememberUser?: boolean,

        /**
         * If not set, or if set to nil, defaults to the device's current language setting.
         * 
        Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
        If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
        If the library does not contain localized strings for a specified language, then will fall back to American English.

        If you specify only a language code, and that code matches the device's currently preferred language,
        then the library will attempt to use the device's current region as well.
        E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

        These localizations are currently included:
        da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
        */
        languageOrLocale?: string,

        /**
         * Normally, the SDK blurs the screen when the app is backgrounded,
         * to obscure credit card or PayPal account details in the iOS-saved screenshot.
        If your app already does its own blurring upon backgrounding, you might choose to disable this.
        Defaults to false.
        */
        disableBlurWhenBackgrounding?: boolean,

        /**
         * If you will present the SDK's view controller within a popover, then set this property to true.
         * Defaults to false. (iOS only)
         */
        presentingInPopover?: boolean,

        /**
         * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
         * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

        This setting will have no effect if the operation mode is production.
        Defaults to false.
        */
        forceDefaultsInSandbox?: boolean,

        /**
         * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPassword?: string,

        /**
         * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPin?: string
}
declare export interface PayPalCordovaPlugin$PayPalClientIds {
    PayPalEnvironmentProduction: string,
        PayPalEnvironmentSandbox: string
}


/**
 * Represents the portion of an object that is common to all responses.
 */
declare export interface PayPalCordovaPlugin$BaseResult {
    client: PayPalCordovaPlugin$Client,
        response_type: string
}


/**
 * Represents the client portion of the response.
 */
declare export interface PayPalCordovaPlugin$Client {
    paypal_sdk_version: string,
        environment: string,
        platform: string,
        product_name: string
}


/**
 * Represents the response for a successful callback from renderSinglePaymentUI().
 */
declare export type PayPalCordovaPlugin$SinglePaymentResult = {
    response: {
        intent: string,
        id: string,
        state: string,
        authorization_id: string,
        create_time: string
    }
} & PayPalCordovaPlugin$BaseResult



/**
 * Represents the response for a successful callback from renderFuturePaymentUI().
 */
declare export type PayPalCordovaPlugin$FuturePaymentResult = {
    response: {
        code: string
    }
} & PayPalCordovaPlugin$BaseResult


declare export interface PayPalCordovaPlugin$PayPalMobileStatic {

    /**
     * Retrieve the version of the PayPal iOS SDK library. Useful when contacting support.
     * @param completionCallback a callback function accepting a string
     */
    version(completionCallback: (result: string) => void): void,

        /**
         * You MUST call this method to initialize the PayPal Mobile SDK.
         * 
        The PayPal Mobile SDK can operate in different environments to facilitate development and testing."my-client-id-for-Production",
        PayPalEnvironmentSandbox : @"my-client-id-for-Sandbox"
        }
         * @param clientIdsForEnvironments set of client ids for environments
        Example: var clientIdsForEnvironments = {
        PayPalEnvironmentProduction : 
         * @param completionCallback a callback function on success
        */
        init(
            clientIdsForEnvironments: PayPalCordovaPlugin$PayPalClientIds,
            completionCallback: () => void): void,

        /**
         * You must preconnect to PayPal to prepare the device for processing payments.
         * This improves the user experience, by making the presentation of the
        UI faster. The preconnect is valid for a limited time, so
        the recommended time to preconnect is on page load.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param configuration PayPalConfiguration object, for Future Payments merchantName, merchantPrivacyPolicyURL
        and merchantUserAgreementURL must be set be set
         * @param completionCallback a callback function on success
        */
        prepareToRender(
            environment: string,
            configuration: PayPalConfiguration,
            completionCallback: () => void): void,

        /**
         * Start PayPal UI to collect payment from the user.
         * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/ios-integration-guide/
        for more documentation of the params.
         * @param payment PayPalPayment object
         * @param completionCallback a callback function accepting a js object, called when the user has completed payment
         * @param cancelCallback a callback function accepting a reason string, called when the user cancels the payment
        */
        renderSinglePaymentUI(
            payment: PayPalPayment,
            completionCallback: (result: PayPalCordovaPlugin$SinglePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * 
         * @deprecated  * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
        from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param callback applicationCorrelationID Your server will send this to PayPal in a 'Paypal-Application-Correlation-Id' header.
        */
        applicationCorrelationIDForEnvironment(
            environment: string,
            completionCallback: (applicationCorrelationId: string) => void): void,

        /**
         * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
         * from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param callback clientMetadataID Your server will send this to PayPal in a 'PayPal-Client-Metadata-Id' header.
        */
        clientMetadataID(completionCallback: (clientMetadataId: string) => void): void,

        /**
         * Please Read Docs on Future Payments at https://github.com/paypal/PayPal-iOS-SDK#future-payments
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
         */
        renderFuturePaymentUI(
            completionCallback: (result: PayPalCordovaPlugin$FuturePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * Please Read Docs on Profile Sharing at https://github.com/paypal/PayPal-iOS-SDK#profile-sharing
         * @param scopes scopes Set of requested scope-values. Accepted scopes are: openid, profile, address, email, phone, futurepayments and paypalattributes
        See https://developer.paypal.com/docs/integration/direct/identity/attributes/ for more details
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
        */
        renderProfileSharingUI(
            scopes: string[],
            completionCallback: (result: any) => void,
            cancelCallback: (cancelReason: string) => void): void
}
declare var PayPalMobile: PayPalCordovaPlugin$PayPalMobileStatic;
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}