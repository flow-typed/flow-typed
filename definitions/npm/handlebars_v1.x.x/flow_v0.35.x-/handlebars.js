/**
 * Flowtype definitions for handlebars
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$Handlebars: {
    registerHelper: typeof Handlebars$registerHelper,
    registerPartial: typeof Handlebars$registerPartial,
    unregisterHelper: typeof Handlebars$unregisterHelper,
    unregisterPartial: typeof Handlebars$unregisterPartial,
    K: typeof Handlebars$K,
    createFrame: typeof Handlebars$createFrame,
    Exception: typeof Handlebars$Exception,
    log: typeof Handlebars$log,
    parse: typeof Handlebars$parse,
    compile: typeof Handlebars$compile,
    precompile: typeof Handlebars$precompile,
    template: typeof Handlebars$template,
    create: typeof Handlebars$create,
    registerDecorator: typeof Handlebars$registerDecorator,
    unregisterDecorator: typeof Handlebars$unregisterDecorator,
    noConflict: typeof Handlebars$noConflict,
}
declare export function Handlebars$registerHelper(name: string, fn: Function, inverse?: boolean): void

declare export function Handlebars$registerPartial(name: string, str: any): void

declare export function Handlebars$unregisterHelper(name: string): void

declare export function Handlebars$unregisterPartial(name: string): void

declare export function Handlebars$K(): void

declare export function Handlebars$createFrame(object: any): any

declare export function Handlebars$Exception(message: string): void

declare export function Handlebars$log(level: number, obj: any): void

declare export function Handlebars$parse(input: string): undefined.Program

declare export function Handlebars$compile(input: any, options?: CompileOptions): HandlebarsTemplateDelegate

declare export function Handlebars$precompile(input: any, options?: PrecompileOptions): TemplateSpecification

declare export function Handlebars$template(precompilation: TemplateSpecification): HandlebarsTemplateDelegate

declare export function Handlebars$create(): typeof Handlebars

declare export var SafeString: typeof undefined;

declare export var escapeExpression: typeof undefined;

declare export var Utils: typeof undefined;

declare export var logger: Logger;

declare export var templates: HandlebarsTemplates;

declare export var helpers: any;

declare export function Handlebars$registerDecorator(name: string, fn: Function): void

declare export function Handlebars$unregisterDecorator(name: string): void

declare export function Handlebars$noConflict(): typeof Handlebars

declare module 'AST' {
    declare export var helpers: undefined.helpers;
}


declare interface Handlebars$ICompiler {
    accept(node: undefined.Node): void,
        Program(program: undefined.Program): void,
        BlockStatement(block: undefined.BlockStatement): void,
        PartialStatement(partial: undefined.PartialStatement): void,
        PartialBlockStatement(partial: undefined.PartialBlockStatement): void,
        DecoratorBlock(decorator: undefined.DecoratorBlock): void,
        Decorator(decorator: undefined.Decorator): void,
        MustacheStatement(mustache: undefined.MustacheStatement): void,
        ContentStatement(content: undefined.ContentStatement): void,
        CommentStatement(comment?: undefined.CommentStatement): void,
        SubExpression(sexpr: undefined.SubExpression): void,
        PathExpression(path: undefined.PathExpression): void,
        StringLiteral(str: undefined.StringLiteral): void,
        NumberLiteral(num: undefined.NumberLiteral): void,
        BooleanLiteral(bool: undefined.BooleanLiteral): void,
        UndefinedLiteral(): void,
        NullLiteral(): void,
        Hash(hash: undefined.Hash): void
}

declare export class Visitor mixins ICompiler {
    accept(node: undefined.Node): void;
    acceptKey(node: undefined.Node, name: string): void;
    acceptArray(arr: undefined.Expression[]): void;
    Program(program: undefined.Program): void;
    BlockStatement(block: undefined.BlockStatement): void;
    PartialStatement(partial: undefined.PartialStatement): void;
    PartialBlockStatement(partial: undefined.PartialBlockStatement): void;
    DecoratorBlock(decorator: undefined.DecoratorBlock): void;
    Decorator(decorator: undefined.Decorator): void;
    MustacheStatement(mustache: undefined.MustacheStatement): void;
    ContentStatement(content: undefined.ContentStatement): void;
    CommentStatement(comment?: undefined.CommentStatement): void;
    SubExpression(sexpr: undefined.SubExpression): void;
    PathExpression(path: undefined.PathExpression): void;
    StringLiteral(str: undefined.StringLiteral): void;
    NumberLiteral(num: undefined.NumberLiteral): void;
    BooleanLiteral(bool: undefined.BooleanLiteral): void;
    UndefinedLiteral(): void;
    NullLiteral(): void;
    Hash(hash: undefined.Hash): void
}
/**
 * Implement this interface on your MVW/MVVM/MVC views such as Backbone.View
 */
declare interface HandlebarsTemplatable {
    template: HandlebarsTemplateDelegate
}
declare interface HandlebarsTemplateDelegate {
    (context: any, options?: any): string
}
declare interface HandlebarsTemplates {
    [index: string]: HandlebarsTemplateDelegate
}
declare interface TemplateSpecification {}
declare interface CompileOptions {
    data?: boolean,
        compat?: boolean,
        knownHelpers?: {
            helperMissing?: boolean,
            blockHelperMissing?: boolean,
            each?: boolean,
            if ?: boolean,
            unless?: boolean,
            with?: boolean,
            log?: boolean,
            lookup?: boolean
        },
        knownHelpersOnly?: boolean,
        noEscape?: boolean,
        strict?: boolean,
        assumeObjects?: boolean,
        preventIndent?: boolean,
        ignoreStandalone?: boolean,
        explicitPartialContext?: boolean
}
declare type PrecompileOptions = {
    srcName?: string,
    destName?: string
} & CompileOptions
declare interface AST$Node {
    type: string,
        loc: AST$SourceLocation
}

declare interface AST$SourceLocation {
    source: string,
        start: AST$Position,
        end: AST$Position
}

declare interface AST$Position {
    line: number,
        column: number
}

declare type AST$Program = {
    body: AST$Statement[],
    blockParams: string[]
} & AST$Node


declare type AST$Statement = {} & AST$Node


declare type AST$MustacheStatement = {
    path: AST$PathExpression | AST$Literal,
    params: AST$Expression[],
    hash: AST$Hash,
    escaped: boolean,
    strip: AST$StripFlags
} & AST$Statement


declare type AST$Decorator = {} & AST$MustacheStatement


declare type AST$BlockStatement = {
    path: AST$PathExpression,
    params: AST$Expression[],
    hash: AST$Hash,
    program: AST$Program,
    inverse: AST$Program,
    openStrip: AST$StripFlags,
    inverseStrip: AST$StripFlags,
    closeStrip: AST$StripFlags
} & AST$Statement


declare type AST$DecoratorBlock = {} & AST$BlockStatement


declare type AST$PartialStatement = {
    name: AST$PathExpression | AST$SubExpression,
    params: AST$Expression[],
    hash: AST$Hash,
    indent: string,
    strip: AST$StripFlags
} & AST$Statement


declare type AST$PartialBlockStatement = {
    name: AST$PathExpression | AST$SubExpression,
    params: AST$Expression[],
    hash: AST$Hash,
    program: AST$Program,
    openStrip: AST$StripFlags,
    closeStrip: AST$StripFlags
} & AST$Statement


declare type AST$ContentStatement = {
    value: string,
    original: AST$StripFlags
} & AST$Statement


declare type AST$CommentStatement = {
    value: string,
    strip: AST$StripFlags
} & AST$Statement


declare type AST$Expression = {} & AST$Node


declare type AST$SubExpression = {
    path: AST$PathExpression,
    params: AST$Expression[],
    hash: AST$Hash
} & AST$Expression


declare type AST$PathExpression = {
    data: boolean,
    depth: number,
    parts: string[],
    original: string
} & AST$Expression


declare type AST$Literal = {} & AST$Expression


declare type AST$StringLiteral = {
    value: string,
    original: string
} & AST$Literal


declare type AST$BooleanLiteral = {
    value: boolean,
    original: boolean
} & AST$Literal


declare type AST$NumberLiteral = {
    value: number,
    original: number
} & AST$Literal


declare type AST$UndefinedLiteral = {} & AST$Literal


declare type AST$NullLiteral = {} & AST$Literal


declare type AST$Hash = {
    pairs: AST$HashPair[]
} & AST$Node


declare type AST$HashPair = {
    key: string,
    value: AST$Expression
} & AST$Node


declare interface AST$StripFlags {
    open: boolean,
        close: boolean
}

declare interface AST$helpers {
    helperExpression(node: AST$Node): boolean,
        scopeId(path: AST$PathExpression): boolean,
        simpleId(path: AST$PathExpression): boolean
}
declare interface Logger {
    DEBUG: number,
        INFO: number,
        WARN: number,
        ERROR: number,
        level: number,
        methodMap: {
            [level: number]: string
        },
        log(level: number, obj: string): void
}
declare module 'handlebars' {
    declare module.exports: typeof Handlebars
}