// @flow
/**
 * Flowtype definitions for inquirer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'inquirer' {
    declare type inquirer$Prompts = {
        [name: string]: inquirer$PromptModule
    };

    declare type inquirer$ChoiceType = string | objects$ChoiceOption | objects$Separator;

    declare type inquirer$Questions = inquirer$Question | inquirer$Question[] | Rx.Observable<inquirer$Question>;

    declare interface inquirer$Inquirer {
        restoreDefaultPrompts(): void,

            /**
             * Expose helper functions on the top level for easiest usage by common users
             * @param name 
             * @param prompt 
             */
            registerPrompt(name: string, prompt: inquirer$PromptModule): void,

            /**
             * Create a new self-contained prompt module.
             */
            createPromptModule(): inquirer$PromptModule,

            /**
             * Public CLI helper interface
             * @param questions Questions settings array
             * @param cb Callback being passed the user answers
             * @return  
             */
            prompt(
                questions: inquirer$Questions,
                cb: (answers: inquirer$Answers) => any): ui$Prompt,
            prompt(questions: inquirer$Questions): Promise<inquirer$Answers>,
            prompts: inquirer$Prompts,
            Separator: objects$SeparatorStatic,
            ui: {
                BottomBar: ui$BottomBar,
                Prompt: ui$Prompt
            }
    }

    declare interface inquirer$PromptModule {
        (questions: inquirer$Questions, cb: (answers: inquirer$Answers) => any): ui$Prompt,

        /**
         * Register a prompt type
         * @param name Prompt type name
         * @param prompt Prompt constructor
         */
        registerPrompt(name: string, prompt: inquirer$PromptModule): ui$Prompt,

            /**
             * Register the defaults provider prompts
             */
            restoreDefaultPrompts(): void
    }

    declare interface inquirer$Question {

        /**
         * Type of the prompt.
         * Possible values:
        <ul>
              <li>input</li>
              <li>confirm</li>
              <li>list</li>
              <li>rawlist</li>
              <li>password</li>
        </ul>
         * @defaults  : 'input'
        */
        type?: string,

            /**
             * The name to use when storing the answer in the anwers hash.
             */
            name?: string,

            /**
             * The question to print. If defined as a function,
             * the first parameter will be the current inquirer session answers.
             */
            message?: string | ((answers: inquirer$Answers) => string),

            /**
             * Default value(s) to use if nothing is entered, or a function that returns the default value(s).
             * If defined as a function, the first parameter will be the current inquirer session answers.
             */
            default?: any | ((answers: inquirer$Answers) => any),

            /**
             * Choices array or a function returning a choices array. If defined as a function,
             * the first parameter will be the current inquirer session answers.
            Array values can be simple strings, or objects containing a name (to display) and a value properties
            (to save in the answers hash). Values can also be a Separator.
            */
            choices?: inquirer$ChoiceType[] | ((answers: inquirer$Answers) => inquirer$ChoiceType[]),

            /**
             * Receive the user input and should return true if the value is valid, and an error message (String)
             * otherwise. If false is returned, a default error message is provided.
             */
            validate(input: string): boolean | string,

            /**
             * Receive the user input and return the filtered value to be used inside the program.
             * The value returned will be added to the Answers hash.
             */
            filter(input: string): string,

            /**
             * Receive the current user answers hash and should return true or false depending on whether or
             * not this question should be asked. The value can also be a simple boolean.
             */
            when?: boolean | ((answers: inquirer$Answers) => boolean),
            paginated?: boolean
    }


    /**
     * A key/value hash containing the client answers in each prompt.
     */
    declare interface inquirer$Answers {
        [key: string]: any
    }


    /**
     * Base interface class other can inherits from
     */
    declare type ui$Prompt = {
        new(promptModule: inquirer$Prompts): ui$Prompt,

        /**
         * Once all prompt are over
         */
        onCompletion(): void,
        processQuestion(question: inquirer$Question): any,
        fetchAnswer(question: inquirer$Question): any,
        setDefaultType(question: inquirer$Question): any,
        filterIfRunnable(question: inquirer$Question): any
    } & ui$BaseUI



    /**
     * Sticky bottom bar user interface
     */
    declare type ui$BottomBar = {
        new(opt?: ui$BottomBarOption): ui$BottomBar,

        /**
         * Render the prompt to screen
         * @return  self
         */
        render(): ui$BottomBar,

        /**
         * Update the bottom bar content and rerender
         * @param bottomBar Bottom bar content
         * @return  self
         */
        updateBottomBar(bottomBar: string): ui$BottomBar,

        /**
         * Rerender the prompt
         * @return  self
         */
        writeLog(data: any): ui$BottomBar,

        /**
         * Make sure line end on a line feed
         * @param str Input string
         * @return  The input string with a final line feed
         */
        enforceLF(str: string): string,

        /**
         * Helper for writing message in Prompt
         * @param message The message to be output
         */
        write(message: string): void,
        log: through.ThroughStream
    } & ui$BaseUI


    declare interface ui$BottomBarOption {
        bottomBar?: string
    }


    /**
     * Base interface class other can inherits from
     */
    declare interface ui$BaseUI<TOpt>{
        new(opt: TOpt): void,

        /**
         * Handle the ^C exit
         * @return  
         */
        onForceClose(): void,

        /**
         * Close the interface and cleanup listeners
         */
        close(): void,

        /**
         * Handle and propagate keypress events
         */
        onKeypress(s: string, key: ui$Key): void
    }

    declare interface ui$Key {
        sequence: string,
            name: string,
            meta: boolean,
            shift: boolean,
            ctrl: boolean
    }


    /**
     * Choice object
     * Normalize input as choice object
     * @constructor  * 
     * @param  Choice value. If an object is passed, it should contains
    at least one of `value` or `name` property
    */
    declare interface objects$Choice {
        new(str: string): objects$Choice,
        new(separator: objects$Separator): objects$Choice,
        new(option: objects$ChoiceOption): objects$Choice
    }

    declare interface objects$ChoiceOption {
        name?: string,
            value?: string,
            type?: string,
            extra?: any,
            key?: string,
            checked?: boolean,
            disabled?: string | ((answers: inquirer$Answers) => any)
    }


    /**
     * Choices collection
     * Collection of multiple `choice` object
     * @constructor  * 
     * @param choices All `choice` to keep in the collection
     */
    declare interface objects$Choices {
        new(
            choices: (string | objects$Separator | objects$ChoiceOption)[],
            answers?: inquirer$Answers): objects$Choices,
        choices: objects$Choice[],
            realChoices: objects$Choice[],
            length: number,
            realLength: number,

            /**
             * Get a valid choice from the collection
             * @param selector The selected choice index
             * @return  Return the matched choice or undefined
             */
            getChoice(selector: number): objects$Choice,

            /**
             * Get a raw element from the collection
             * @param selector The selected index value
             * @return  Return the matched choice or undefined
             */
            get(selector: number): objects$Choice,

            /**
             * Match the valid choices against a where clause
             * @param whereClause Lodash `where` clause
             * @return  Matching choices or empty array
             */
            where<U>(whereClause: U): objects$Choice[],

            /**
             * Pluck a particular key from the choices
             * @param propertyName Property name to select
             * @return  Selected properties
             */
            pluck(propertyName: string): any[],
            forEach<T>(application: (choice: objects$Choice) => T): T[]
    }

    declare interface objects$SeparatorStatic {

        /**
         * 
         * @param line Separation line content (facultative)
         */
        new(line?: string): objects$Separator,

        /**
         * Helper function returning false if object is a separator
         * @param obj object to test against
         * @return  `false` if object is a separator
         */
        exclude(obj: any): boolean
    }


    /**
     * Separator object
     * Used to space/separate choices group
     * @constructor  * 
     * @param  Separation line content (facultative)
     */
    declare interface objects$Separator {
        type: string,
            line: string,

            /**
             * Stringify separator
             * @return  the separator display string
             */
            toString(): string
    }
    declare     var inquirer: inquirer$Inquirer;
    declare module.exports: typeof inquirer
}