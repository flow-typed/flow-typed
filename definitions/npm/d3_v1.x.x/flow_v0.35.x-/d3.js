/**
 * Flowtype definitions for d3
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$d3: {
    select: typeof d3$select,
    selectAll: typeof d3$selectAll,
    selection: typeof d3$selection,
    transition: typeof d3$transition,
    ease: typeof d3$ease,
    timer: typeof d3$timer,
    mouse: typeof d3$mouse,
    touch: typeof d3$touch,
    touches: typeof d3$touches,
    ascending: typeof d3$ascending,
    descending: typeof d3$descending,
    min: typeof d3$min,
    max: typeof d3$max,
    extent: typeof d3$extent,
    sum: typeof d3$sum,
    mean: typeof d3$mean,
    median: typeof d3$median,
    quantile: typeof d3$quantile,
    variance: typeof d3$variance,
    deviation: typeof d3$deviation,
    bisectLeft: typeof d3$bisectLeft,
    bisectRight: typeof d3$bisectRight,
    bisector: typeof d3$bisector,
    shuffle: typeof d3$shuffle,
    keys: typeof d3$keys,
    values: typeof d3$values,
    entries: typeof d3$entries,
    map: typeof d3$map,
    set: typeof d3$set,
    merge: typeof d3$merge,
    range: typeof d3$range,
    permute: typeof d3$permute,
    zip: typeof d3$zip,
    transpose: typeof d3$transpose,
    pairs: typeof d3$pairs,
    nest: typeof d3$nest,
    transform: typeof d3$transform,
    format: typeof d3$format,
    formatPrefix: typeof d3$formatPrefix,
    round: typeof d3$round,
    requote: typeof d3$requote,
    functor: typeof d3$functor,
    rebind: typeof d3$rebind,
    dispatch: typeof d3$dispatch,
    interpolate: typeof d3$interpolate,
    interpolateNumber: typeof d3$interpolateNumber,
    interpolateRound: typeof d3$interpolateRound,
    interpolateString: typeof d3$interpolateString,
    interpolateRgb: typeof d3$interpolateRgb,
    interpolateHsl: typeof d3$interpolateHsl,
    interpolateLab: typeof d3$interpolateLab,
    interpolateHcl: typeof d3$interpolateHcl,
    interpolateArray: typeof d3$interpolateArray,
    interpolateObject: typeof d3$interpolateObject,
    interpolateTransform: typeof d3$interpolateTransform,
    interpolateZoom: typeof d3$interpolateZoom,
    xhr: typeof d3$xhr,
    text: typeof d3$text,
    json: typeof d3$json,
    xml: typeof d3$xml,
    html: typeof d3$html,
    dsv: typeof d3$dsv,
    locale: typeof d3$locale,
}
declare export var version: string;


/**
 * Find the first element that matches the given selector string.
 */
declare export function d3$select(selector: string): d3$Selection<any >


    /**
     * Find all elements that match the given selector string.
     */
    declare export function d3$selectAll(selector: string): d3$Selection<any >


    /**
     * Returns the root selection (as if by d3.select(document.documentElement)). This function may be used for 'instanceof' tests, and extending its prototype will add properties to all selections.
     */
    declare export function d3$selection(): d3$Selection<any >

    declare export var prototype: d3$Selection<any>;


/**
 * Selections are grouped into arrays of nodes, with the parent tracked in the 'parentNode' property.
 */
declare type selection$Group = {
    parentNode: EventTarget
} & Array


declare interface selection$Update<Datum>{
    [index: number]: selection$Group,

    /**
     * The number of groups in this selection.
     */
    length: number,

    /**
     * Retrieve the value of the given attribute for the first node in the selection.
     * @param name The attribute name to query. May be prefixed (see d3.ns.prefix).
     */
    attr(name: string): string,

    /**
     * For all nodes, set the attribute to the specified constant value. Use null to remove.
     * @param name The attribute name, optionally prefixed.
     * @param value The attribute value to use. Note that this is coerced to a string automatically.
     */
    attr(name: string, value: d3$Primitive): selection$Update<Datum>,

    /**
     * Derive an attribute value for each node in the selection based on bound data.
     * @param name The attribute name, optionally prefixed.
     * @param value The function of the datum (the bound data item), index (the position in the subgrouping), and outer index (overall position in nested selections) which computes the attribute value. If the function returns null, the attribute is removed.
     */
    attr(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): selection$Update<Datum>,

    /**
     * Set multiple properties at once using an Object. D3 iterates over all enumerable properties and either sets or computes the attribute's value based on the corresponding entry in the Object.
     * @param obj A key-value mapping corresponding to attributes and values. If the value is a simple string or number, it is taken as a constant. Otherwise, it is a function that derives the attribute value.
     */
    attr(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        }): selection$Update<Datum>,

    /**
     * Returns true if the first node in this selection has the given class list. If multiple classes are specified (i.e., "foo bar"), then returns true only if all classes match.
     * @param name The class list to query.
     */
    classed(name: string): boolean,

    /**
     * Adds (or removes) the given class list.
     * @param name The class list to toggle. Spaces separate class names: "foo bar" is a list of two classes.
     * @param value If true, add the classes. If false, remove them.
     */
    classed(name: string, value: boolean): selection$Update<Datum>,

    /**
     * Determine if the given class list should be toggled for each node in the selection.
     * @param name The class list. Spaces separate multiple class names.
     * @param value The function to run for each node. Should return true to add the class to the node, or false to remove it.
     */
    classed(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => boolean): selection$Update<Datum>,

    /**
     * Set or derive classes for multiple class lists at once.
     * @param obj An Object mapping class lists to values that are either plain booleans or functions that return booleans.
     */
    classed(
        obj: {
            [key: string]: boolean | ((datum: Datum, index: number, outerIndex: number) => boolean)
        }): selection$Update<Datum>,

    /**
     * Retrieve the computed style value for the first node in the selection.
     * @param name The CSS property name to query
     */
    style(name: string): string,

    /**
     * Set a style property for all nodes in the selection.
     * @param name the CSS property name
     * @param value the property value
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(name: string, value: d3$Primitive, priority?: string): selection$Update<Datum>,

    /**
     * Derive a property value for each node in the selection.
     * @param name the CSS property name
     * @param value the function to derive the value
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive,
        priority?: string): selection$Update<Datum>,

    /**
     * Set a large number of CSS properties from an object.
     * @param obj an Object whose keys correspond to CSS property names and values are either constants or functions that derive property values
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        },
        priority?: string): selection$Update<Datum>,

    /**
     * Retrieve an arbitrary node property such as the 'checked' property of checkboxes, or the 'value' of text boxes.
     * @param name the node's property to retrieve
     */
    property(name: string): any,

    /**
     * For each node, set the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
     * @param name the property name
     * @param value the property value
     */
    property(name: string, value: any): selection$Update<Datum>,

    /**
     * For each node, derive the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
     * @param name the property name
     * @param value the function used to derive the property's value
     */
    property(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => any): selection$Update<Datum>,

    /**
     * Set multiple node properties. Caveats apply: take care not to mutate special properties like __proto__.
     * @param obj an Object whose keys correspond to node properties and values are either constants or functions that will compute a value.
     */
    property(
        obj: {
            [key: string]: any | ((datum: Datum, index: number, outerIndex: number) => any)
        }): selection$Update<Datum>,

    /**
     * Retrieve the textContent of the first node in the selection.
     */
    text(): string,

    /**
     * Set the textContent of each node in the selection.
     * @param value the text to use for all nodes
     */
    text(value: d3$Primitive): selection$Update<Datum>,

    /**
     * Compute the textContent of each node in the selection.
     * @param value the function which will compute the text
     */
    text(
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): selection$Update<Datum>,

    /**
     * Retrieve the HTML content of the first node in the selection. Uses 'innerHTML' internally and will not work with SVG or other elements without a polyfill.
     */
    html(): string,

    /**
     * Set the HTML content of every node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
     * @param value the HTML content to use.
     */
    html(value: string): d3$Selection<Datum>,

    /**
     * Compute the HTML content for each node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
     * @param value the function to compute HTML content
     */
    html(
        value: (datum: Datum, index: number, outerIndex: number) => string): d3$Selection<Datum>,

    /**
     * Appends a new child to each node in the selection. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     */
    append(name: string): d3$Selection<Datum>,

    /**
     * Appends a new child to each node in the selection by computing a new node. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
     * @param name the function to compute a new element
     */
    append(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget): selection$Update<Datum>,

    /**
     * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     * @param before the selector to determine position (e.g., ":first-child")
     */
    insert(name: string, before: string): selection$Update<Datum>,

    /**
     * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     * @param before a function to determine the node to use as the next sibling
     */
    insert(
        name: string,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): selection$Update<Datum>,

    /**
     * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the function to compute a new child
     * @param before the selector to determine position (e.g., ":first-child")
     */
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before: string): selection$Update<Datum>,

    /**
     * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the function to compute a new child
     * @param before a function to determine the node to use as the next sibling
     */
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): selection$Update<Datum>,

    /**
     * Removes the elements from the DOM. They are in a detached state and may be re-added (though there is currently no dedicated API for doing so).
     */
    remove(): selection$Update<Datum>,

    /**
     * Retrieves the data bound to the first group in this selection.
     */
    data(): Datum[],

    /**
     * Binds data to this selection.
     * @param data the array of data to bind to this selection
     * @param key the optional function to determine the unique key for each piece of data. When unspecified, uses the index of the element.
     */
    data<NewDatum>(
        data: NewDatum[],
        key?: (datum: NewDatum, index: number, outerIndex: number) => string): selection$Update<NewDatum>,

    /**
     * Derives data to bind to this selection.
     * @param data the function to derive data. Must return an array.
     * @param key the optional function to determine the unique key for each data item. When unspecified, uses the index of the element.
     */
    data<NewDatum>(
        data: (datum: Datum, index: number, outerIndex: number) => NewDatum[],
        key?: (datum: NewDatum, index: number, outerIndex: number) => string): selection$Update<NewDatum>,

    /**
     * Filters the selection, returning only those nodes that match the given CSS selector.
     * @param selector the CSS selector
     */
    filter(selector: string): selection$Update<Datum>,

    /**
     * Filters the selection, returning only those nodes for which the given function returned true.
     * @param selector the filter function
     */
    filter(
        selector: (datum: Datum, index: number, outerIndex: number) => boolean): selection$Update<Datum>,

    /**
     * Return the data item bound to the first element in the selection.
     */
    datum(): Datum,

    /**
     * Derive the data item for each node in the selection. Useful for situations such as the HTML5 'dataset' attribute.
     * @param value the function to compute data for each node
     */
    datum<NewDatum>(
        value: (datum: Datum, index: number, outerIndex: number) => NewDatum): selection$Update<NewDatum>,

    /**
     * Set the data item for each node in the selection.
     * @param value the constant element to use for each node
     */
    datum<NewDatum>(value: NewDatum): selection$Update<NewDatum>,

    /**
     * Reorders nodes in the selection based on the given comparator. Nodes are re-inserted into the document once sorted.
     * @param comparator the comparison function, which defaults to d3.ascending
     */
    sort(comparator?: (a: Datum, b: Datum) => number): selection$Update<Datum>,

    /**
     * Reorders nodes in the document to match the selection order. More efficient than calling sort() if the selection is already ordered.
     */
    order(): selection$Update<Datum>,

    /**
     * Returns the listener (if any) for the given event.
     * @param type the type of event to load the listener for. May have a namespace (e.g., ".foo") at the end.
     */
    on(type: string): (datum: Datum, index: number, outerIndex: number) => any,

    /**
     * Adds a listener for the specified event. If one was already registered, it is removed before the new listener is added. The return value of the listener function is ignored.
     * @param type the of event to listen to. May have a namespace (e.g., ".foo") at the end.
     * @param listener an event listener function, or null to unregister
     * @param capture sets the DOM useCapture flag
     */
    on(
        type: string,
        listener: (datum: Datum, index: number, outerIndex: number) => any,
        capture?: boolean): selection$Update<Datum>,

    /**
     * Begins a new transition. Interrupts any active transitions of the same name.
     * @param name the transition name (defaults to "")
     */
    transition(name?: string): d3$Transition<Datum>,

    /**
     * Interrupts the active transition of the provided name. Does not cancel scheduled transitions.
     * @param name the transition name (defaults to "")
     */
    interrupt(name?: string): selection$Update<Datum>,

    /**
     * Creates a subselection by finding the first descendent matching the selector string. Bound data is inherited.
     * @param selector the CSS selector to match against
     */
    select(selector: string): selection$Update<Datum>,

    /**
     * Creates a subselection by using a function to find descendent elements. Bound data is inherited.
     * @param selector the function to find matching descendants
     */
    select(
        selector: (datum: Datum, index: number, outerIndex: number) => EventTarget): selection$Update<Datum>,

    /**
     * Creates a subselection by finding all descendents that match the given selector. Bound data is not inherited.
     * @param selector the CSS selector to match against
     */
    selectAll(selector: string): selection$Update<Datum>,

    /**
     * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
     * @param selector the function to find matching descendents
     */
    selectAll(
        selector: (
            datum: Datum,
            index: number,
            outerIndex: number) => Array<EventTarget>| NodeList): selection$Update<any>,

    /**
     * Invoke the given function for each element in the selection. The return value of the function is ignored.
     * @param func the function to invoke
     */
    each(
        func: (datum: Datum, index: number, outerIndex: number) => any): selection$Update<Datum>,

    /**
     * Call a function on the selection. sel.call(foo) is equivalent to foo(sel).
     * @param func the function to call on the selection
     * @param args any optional args
     */
    call(
        func: (sel: selection$Update<Datum>, ...args: any[]) => any,
        ...args: any[]): selection$Update<Datum>,

    /**
     * Returns true if the current selection is empty.
     */
    empty(): boolean,

    /**
     * Returns the first non-null element in the selection, or null otherwise.
     */
    node(): quadtree$Node,

    /**
     * Returns the total number of elements in the selection.
     */
    size(): number,

    /**
     * Returns the placeholder nodes for each data element for which no corresponding DOM element was found.
     */
    enter(): selection$Enter<Datum>,

    /**
     * Returns a selection for those DOM nodes for which no new data element was found.
     */
    exit(): d3$Selection<Datum >
}

declare interface selection$Enter<Datum>{
    append(name: string): d3$Selection<Datum>,
    append(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,
    insert(name: string, before?: string): d3$Selection<Datum>,
    insert(
        name: string,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before?: string): d3$Selection<Datum>,
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,
    select(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,
    call(
        func: (selection: selection$Enter<Datum>, ...args: any[]) => any,
        ...args: any[]): selection$Enter<Datum>,
    empty(): boolean,
    size(): number
}


/**
 * Administrivia: JavaScript primitive types, or "things that toString() predictably".
 */
declare export type d3$Primitive = number | string | boolean;


/**
 * Administrivia: anything with a valueOf(): number method is comparable, so we allow it in numeric operations
 */
declare interface d3$Numeric {
    valueOf(): number
}


/**
 * A grouped array of nodes.
 * @param Datum the data bound to this selection.
 */
declare interface d3$Selection<Datum>{
    [index: number]: selection$Group,

    /**
     * The number of groups in this selection.
     */
    length: number,

    /**
     * Retrieve the value of the given attribute for the first node in the selection.
     * @param name The attribute name to query. May be prefixed (see d3.ns.prefix).
     */
    attr(name: string): string,

    /**
     * For all nodes, set the attribute to the specified constant value. Use null to remove.
     * @param name The attribute name, optionally prefixed.
     * @param value The attribute value to use. Note that this is coerced to a string automatically.
     */
    attr(name: string, value: d3$Primitive): d3$Selection<Datum>,

    /**
     * Derive an attribute value for each node in the selection based on bound data.
     * @param name The attribute name, optionally prefixed.
     * @param value The function of the datum (the bound data item), index (the position in the subgrouping), and outer index (overall position in nested selections) which computes the attribute value. If the function returns null, the attribute is removed.
     */
    attr(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): d3$Selection<Datum>,

    /**
     * Set multiple properties at once using an Object. D3 iterates over all enumerable properties and either sets or computes the attribute's value based on the corresponding entry in the Object.
     * @param obj A key-value mapping corresponding to attributes and values. If the value is a simple string or number, it is taken as a constant. Otherwise, it is a function that derives the attribute value.
     */
    attr(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        }): d3$Selection<Datum>,

    /**
     * Returns true if the first node in this selection has the given class list. If multiple classes are specified (i.e., "foo bar"), then returns true only if all classes match.
     * @param name The class list to query.
     */
    classed(name: string): boolean,

    /**
     * Adds (or removes) the given class list.
     * @param name The class list to toggle. Spaces separate class names: "foo bar" is a list of two classes.
     * @param value If true, add the classes. If false, remove them.
     */
    classed(name: string, value: boolean): d3$Selection<Datum>,

    /**
     * Determine if the given class list should be toggled for each node in the selection.
     * @param name The class list. Spaces separate multiple class names.
     * @param value The function to run for each node. Should return true to add the class to the node, or false to remove it.
     */
    classed(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => boolean): d3$Selection<Datum>,

    /**
     * Set or derive classes for multiple class lists at once.
     * @param obj An Object mapping class lists to values that are either plain booleans or functions that return booleans.
     */
    classed(
        obj: {
            [key: string]: boolean | ((datum: Datum, index: number, outerIndex: number) => boolean)
        }): d3$Selection<Datum>,

    /**
     * Retrieve the computed style value for the first node in the selection.
     * @param name The CSS property name to query
     */
    style(name: string): string,

    /**
     * Set a style property for all nodes in the selection.
     * @param name the CSS property name
     * @param value the property value
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(name: string, value: d3$Primitive, priority?: string): d3$Selection<Datum>,

    /**
     * Derive a property value for each node in the selection.
     * @param name the CSS property name
     * @param value the function to derive the value
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive,
        priority?: string): d3$Selection<Datum>,

    /**
     * Set a large number of CSS properties from an object.
     * @param obj an Object whose keys correspond to CSS property names and values are either constants or functions that derive property values
     * @param priority if specified, either null or the string "important" (no exclamation mark)
     */
    style(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        },
        priority?: string): d3$Selection<Datum>,

    /**
     * Retrieve an arbitrary node property such as the 'checked' property of checkboxes, or the 'value' of text boxes.
     * @param name the node's property to retrieve
     */
    property(name: string): any,

    /**
     * For each node, set the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
     * @param name the property name
     * @param value the property value
     */
    property(name: string, value: any): d3$Selection<Datum>,

    /**
     * For each node, derive the property value. Internally, this sets the node property directly (e.g., node[name] = value), so take care not to mutate special properties like __proto__.
     * @param name the property name
     * @param value the function used to derive the property's value
     */
    property(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => any): d3$Selection<Datum>,

    /**
     * Set multiple node properties. Caveats apply: take care not to mutate special properties like __proto__.
     * @param obj an Object whose keys correspond to node properties and values are either constants or functions that will compute a value.
     */
    property(
        obj: {
            [key: string]: any | ((datum: Datum, index: number, innerInder: number) => any)
        }): d3$Selection<Datum>,

    /**
     * Retrieve the textContent of the first node in the selection.
     */
    text(): string,

    /**
     * Set the textContent of each node in the selection.
     * @param value the text to use for all nodes
     */
    text(value: d3$Primitive): d3$Selection<Datum>,

    /**
     * Compute the textContent of each node in the selection.
     * @param value the function which will compute the text
     */
    text(
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): d3$Selection<Datum>,

    /**
     * Retrieve the HTML content of the first node in the selection. Uses 'innerHTML' internally and will not work with SVG or other elements without a polyfill.
     */
    html(): string,

    /**
     * Set the HTML content of every node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
     * @param value the HTML content to use.
     */
    html(value: string): d3$Selection<Datum>,

    /**
     * Compute the HTML content for each node in the selection. Uses 'innerHTML' internally and thus will not work with SVG or other elements without a polyfill.
     * @param value the function to compute HTML content
     */
    html(
        value: (datum: Datum, index: number, outerIndex: number) => string): d3$Selection<Datum>,

    /**
     * Appends a new child to each node in the selection. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     */
    append(name: string): d3$Selection<Datum>,

    /**
     * Appends a new child to each node in the selection by computing a new node. This child will inherit the parent's data (if available). Returns a fresh selection consisting of the newly-appended children.
     * @param name the function to compute a new element
     */
    append(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,

    /**
     * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     * @param before the selector to determine position (e.g., ":first-child")
     */
    insert(name: string, before: string): d3$Selection<Datum>,

    /**
     * Inserts a new child to each node in the selection. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the element name to append. May be prefixed (see d3.ns.prefix).
     * @param before a function to determine the node to use as the next sibling
     */
    insert(
        name: string,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,

    /**
     * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the function to compute a new child
     * @param before the selector to determine position (e.g., ":first-child")
     */
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before: string): d3$Selection<Datum>,

    /**
     * Inserts a new child to the end of each node in the selection by computing a new node. This child will inherit its parent's data (if available). Returns a fresh selection consisting of the newly-inserted children.
     * @param name the function to compute a new child
     * @param before a function to determine the node to use as the next sibling
     */
    insert(
        name: (datum: Datum, index: number, outerIndex: number) => EventTarget,
        before: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,

    /**
     * Removes the elements from the DOM. They are in a detached state and may be re-added (though there is currently no dedicated API for doing so).
     */
    remove(): d3$Selection<Datum>,

    /**
     * Retrieves the data bound to the first group in this selection.
     */
    data(): Datum[],

    /**
     * Binds data to this selection.
     * @param data the array of data to bind to this selection
     * @param key the optional function to determine the unique key for each piece of data. When unspecified, uses the index of the element.
     */
    data<NewDatum>(
        data: NewDatum[],
        key?: (datum: NewDatum, index: number, outerIndex: number) => string): selection$Update<NewDatum>,

    /**
     * Derives data to bind to this selection.
     * @param data the function to derive data. Must return an array.
     * @param key the optional function to determine the unique key for each data item. When unspecified, uses the index of the element.
     */
    data<NewDatum>(
        data: (datum: Datum, index: number, outerIndex: number) => NewDatum[],
        key?: (datum: NewDatum, index: number, outerIndex: number) => string): selection$Update<NewDatum>,

    /**
     * Filters the selection, returning only those nodes that match the given CSS selector.
     * @param selector the CSS selector
     */
    filter(selector: string): d3$Selection<Datum>,

    /**
     * Filters the selection, returning only those nodes for which the given function returned true.
     * @param selector the filter function
     */
    filter(
        selector: (datum: Datum, index: number, outerIndex: number) => boolean): d3$Selection<Datum>,

    /**
     * Return the data item bound to the first element in the selection.
     */
    datum(): Datum,

    /**
     * Derive the data item for each node in the selection. Useful for situations such as the HTML5 'dataset' attribute.
     * @param value the function to compute data for each node
     */
    datum<NewDatum>(
        value: (datum: Datum, index: number, outerIndex: number) => NewDatum): d3$Selection<NewDatum>,

    /**
     * Set the data item for each node in the selection.
     * @param value the constant element to use for each node
     */
    datum<NewDatum>(value: NewDatum): d3$Selection<NewDatum>,

    /**
     * Reorders nodes in the selection based on the given comparator. Nodes are re-inserted into the document once sorted.
     * @param comparator the comparison function, which defaults to d3.ascending
     */
    sort(comparator?: (a: Datum, b: Datum) => number): d3$Selection<Datum>,

    /**
     * Reorders nodes in the document to match the selection order. More efficient than calling sort() if the selection is already ordered.
     */
    order(): d3$Selection<Datum>,

    /**
     * Returns the listener (if any) for the given event.
     * @param type the type of event to load the listener for. May have a namespace (e.g., ".foo") at the end.
     */
    on(type: string): (datum: Datum, index: number, outerIndex: number) => any,

    /**
     * Adds a listener for the specified event. If one was already registered, it is removed before the new listener is added. The return value of the listener function is ignored.
     * @param type the of event to listen to. May have a namespace (e.g., ".foo") at the end.
     * @param listener an event listener function, or null to unregister
     * @param capture sets the DOM useCapture flag
     */
    on(
        type: string,
        listener: (datum: Datum, index: number, outerIndex: number) => any,
        capture?: boolean): d3$Selection<Datum>,

    /**
     * Begins a new transition. Interrupts any active transitions of the same name.
     * @param name the transition name (defaults to "")
     */
    transition(name?: string): d3$Transition<Datum>,

    /**
     * Interrupts the active transition of the provided name. Does not cancel scheduled transitions.
     * @param name the transition name (defaults to "")
     */
    interrupt(name?: string): d3$Selection<Datum>,

    /**
     * Creates a subselection by finding the first descendent matching the selector string. Bound data is inherited.
     * @param selector the CSS selector to match against
     */
    select(selector: string): d3$Selection<Datum>,

    /**
     * Creates a subselection by using a function to find descendent elements. Bound data is inherited.
     * @param selector the function to find matching descendants
     */
    select(
        selector: (datum: Datum, index: number, outerIndex: number) => EventTarget): d3$Selection<Datum>,

    /**
     * Creates a subselection by finding all descendents that match the given selector. Bound data is not inherited.
     * @param selector the CSS selector to match against
     */
    selectAll(selector: string): d3$Selection<any>,

    /**
     * Creates a subselection by finding all descendants that match the given selector. Bound data is not inherited.
     * 
    Use this overload when data-binding a subselection (that is, sel.selectAll('.foo').data(d => ...)). The type will carry over.
    */
    selectAll<T>(selector: string): d3$Selection<T>,

    /**
     * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
     * @param selector the function to find matching descendents
     */
    selectAll(
        selector: (
            datum: Datum,
            index: number,
            outerIndex: number) => Array<EventTarget>| NodeList): d3$Selection<any>,

    /**
     * Creates a subselection by using a function to find descendent elements. Bound data is not inherited.
     * 
    Use this overload when data-binding a subselection (that is, sel.selectAll('.foo').data(d => ...)). The type will carry over.
     * @param selector the function to find matching descendents
    */
    selectAll<T>(
        selector: (
            datum: Datum,
            index: number,
            outerIndex: number) => Array<EventTarget>| NodeList): d3$Selection<T>,

    /**
     * Invoke the given function for each element in the selection. The return value of the function is ignored.
     * @param func the function to invoke
     */
    each(
        func: (datum: Datum, index: number, outerIndex: number) => any): d3$Selection<Datum>,

    /**
     * Call a function on the selection. sel.call(foo) is equivalent to foo(sel).
     * @param func the function to call on the selection
     * @param args any optional args
     */
    call(
        func: (sel: d3$Selection<Datum>, ...args: any[]) => any,
        ...args: any[]): d3$Selection<Datum>,

    /**
     * Returns true if the current selection is empty.
     */
    empty(): boolean,

    /**
     * Returns the first non-null element in the selection, or null otherwise.
     */
    node(): quadtree$Node,

    /**
     * Returns the total number of elements in the selection.
     */
    size(): number
}

declare export function d3$transition(): d3$Transition<any >

    declare export var prototype: d3$Transition<any>;

declare interface d3$Transition<Datum>{
    transition(): d3$Transition<Datum>,
    delay(): number,
    delay(delay: number): d3$Transition<Datum>,
    delay(
        delay: (datum: Datum, index: number, outerIndex: number) => number): d3$Transition<Datum>,
    duration(): number,
    duration(duration: number): d3$Transition<Datum>,
    duration(
        duration: (datum: Datum, index: number, outerIndex: number) => number): d3$Transition<Datum>,
    ease(): (t: number) => number,
    ease(value: string, ...args: any[]): d3$Transition<Datum>,
    ease(value: (t: number) => number): d3$Transition<Datum>,
    attr(name: string, value: d3$Primitive): d3$Transition<Datum>,
    attr(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): d3$Transition<Datum>,
    attr(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        }): d3$Transition<Datum>,
    attrTween(
        name: string,
        tween: (datum: Datum, index: number, attr: string) => (t: number) => d3$Primitive): d3$Transition<Datum>,
    style(name: string, value: d3$Primitive, priority?: string): d3$Transition<Datum>,
    style(
        name: string,
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive,
        priority?: string): d3$Transition<Datum>,
    style(
        obj: {
            [key: string]: d3$Primitive | ((datum: Datum, index: number, outerIndex: number) => d3$Primitive)
        },
        priority?: string): d3$Transition<Datum>,
    styleTween(
        name: string,
        tween: (datum: Datum, index: number, attr: string) => (t: number) => d3$Primitive,
        priority?: string): d3$Transition<Datum>,
    text(value: d3$Primitive): d3$Transition<Datum>,
    text(
        value: (datum: Datum, index: number, outerIndex: number) => d3$Primitive): d3$Transition<Datum>,
    tween(name: string, factory: () => (t: number) => any): d3$Transition<Datum>,
    remove(): d3$Transition<Datum>,
    select(selector: string): d3$Transition<Datum>,
    select(selector: (d: Datum, i: number) => EventTarget): d3$Transition<Datum>,
    selectAll(selector: string): d3$Transition<any>,
    selectAll(selector: (d: Datum, i: number) => EventTarget[]): d3$Transition<any>,
    filter(selector: string): d3$Transition<Datum>,
    filter(selector: (d: Datum, i: number) => boolean): d3$Transition<Datum>,
    each(type: string, listener: (d: Datum, i: number) => any): d3$Transition<Datum>,
    each(listener: (d: Datum, i: number) => any): d3$Transition<Datum>,
    call(
        func: (transition: d3$Transition<Datum>, ...args: any[]) => any,
        ...args: any[]): d3$Transition<Datum>,
    empty(): boolean,
    node(): quadtree$Node,
    size(): number
}

declare export function d3$ease(type: "linear"): (t: number) => number

declare export function d3$timer(func: () => any, delay?: number, time?: number): void


declare var npm$namespace$timer: {
    flush: typeof timer$flush,
}
declare export function timer$flush(): void

declare interface d3$BaseEvent {
    type: string,
        sourceEvent?: force$Event
}


/**
 * Define a D3-specific ZoomEvent per https://github.com/mbostock/d3/wiki/Zoom-Behavior#event
 */
declare type d3$ZoomEvent = {
    scale: number,
    translate: [number, number]
} & d3$BaseEvent



/**
 * Define a D3-specific DragEvent per https://github.com/mbostock/d3/wiki/Drag-Behavior#on
 */
declare type d3$DragEvent = {
    x: number,
    y: number,
    dx: number,
    dy: number
} & d3$BaseEvent


declare export var event: force$Event | d3$BaseEvent;


/**
 * Returns the x and y coordinates of the mouse relative to the provided container element, using d3.event for the mouse's position on the page.
 * @param container the container element (e.g. an SVG <g> element)
 */
declare export function d3$mouse(container: EventTarget): [number, number]


/**
 * Given a container element and a touch identifier, determine the x and y coordinates of the touch.
 * @param container the container element (e.g., an SVG <svg> element)
 * @param identifier the given touch identifier
 */
declare export function d3$touch(container: EventTarget, identifer: number): [number, number]


/**
 * Given a container element and an optional list of touches, return the position of every touch relative to the container.
 * @param container the container element
 * @param touches an optional list of touches (defaults to d3.event.touches)
 */
declare export function d3$touches(container: EventTarget, touches?: TouchList): Array<[number, number] >


    /**
     * Compares two primitive values for sorting (in ascending order).
     */
    declare export function d3$ascending(a: d3$Primitive, b: d3$Primitive): number


/**
 * Compares two primitive values for sorting (in ascending order).
 */
declare export function d3$descending(a: d3$Primitive, b: d3$Primitive): number


/**
 * Return the minimum value in the array using natural order.
 */
declare export function d3$min(array: number[]): number


/**
 * Return the maximum value in the array of numbers using natural order.
 */
declare export function d3$max(array: number[]): number


/**
 * Return the min and max simultaneously.
 */
declare export function d3$extent(array: number[]): [number, number]


/**
 * Compute the sum of an array of numbers.
 */
declare export function d3$sum(array: number[]): number

declare export function d3$mean(array: number[]): number


/**
 * Compute the median of an array of numbers (the 0.5-quantile).
 */
declare export function d3$median(array: number[]): number

declare export function d3$quantile(array: number[], p: number): number

declare export function d3$variance(array: number[]): number

declare export function d3$deviation(array: number[]): number

declare export function d3$bisectLeft<T>(array: T[], x: T, lo?: number, hi?: number): number

declare export var bisect: typeof bisectRight;

declare export function d3$bisectRight<T>(array: T[], x: T, lo?: number, hi?: number): number

declare export function d3$bisector<T, U>(
    accessor: (x: T) => U): {
    left: (array: T[], x: U, lo?: number, hi?: number) => number,
    right: (array: T[], x: U, lo?: number, hi?: number) => number
}

declare export function d3$shuffle<T>(array: T[], lo?: number, hi?: number): T[]


/**
 * Returns the enumerable property names of the specified object.
 * @param object a JavaScript object
 */
declare export function d3$keys(object: Object): string[]


/**
 * Returns an array containing the property values of the specified object.
 */
declare export function d3$values<T>(object: {
    [key: string]: T
}): T[]


/**
 * Returns an array of key-value pairs containing the property values of the specified object.
 */
declare export function d3$entries<T>(object: {
    [key: string]: T
}): {
    key: string,
    value: T
}[]


/**
 * A shim for ES6 maps. The implementation uses a JavaScript object internally, and thus keys are limited to strings.
 */
declare interface d3$Map<T>{

    /**
     * Does the map contain the given key?
     */
    has(key: string): boolean,

    /**
     * Retrieve the value for the given key. Returns undefined if there is no value stored.
     */
    get(key: string): T,

    /**
     * Set the value for the given key. Returns the new value.
     */
    set(key: string, value: T): T,

    /**
     * Remove the value for the given key. Returns true if there was a value and false otherwise.
     */
    remove(key: string): boolean,

    /**
     * Returns an array of all keys in arbitrary order.
     */
    keys(): string[],

    /**
     * Returns an array of all values in arbitrary order.
     */
    values(): T[],

    /**
     * Returns an array of key-value objects in arbitrary order.
     */
    entries(): {
        key: string,
        value: T
    }[],

    /**
     * Calls the function for each key and value pair in the map. The 'this' context is the map itself.
     */
    forEach(func: (key: string, value: T) => any): void,

    /**
     * Is this map empty?
     */
    empty(): boolean,

    /**
     * Returns the number of elements stored in the map.
     */
    size(): number
}


/**
 * Constructs an initially empty map.
 */
declare export function d3$map<T>(): d3$Map<T >


    /**
     * A shim for ES6 sets. Is only able to store strings.
     */
    declare interface d3$Set {

        /**
         * Is the given string stored in this set?
         */
        has(value: string): boolean,

            /**
             * Add the string to this set. Returns the value.
             */
            add(value: string): string,

            /**
             * Remove the given value from the set. Returns true if it was stored, and false otherwise.
             */
            remove(value: string): boolean,

            /**
             * Returns an array of the strings stored in this set.
             */
            values(): string[],

            /**
             * Calls a given function for each value in the set. The return value of the function is ignored. The this context of the function is the set itself.
             */
            forEach(func: (value: string) => any): void,

            /**
             * Is this set empty?
             */
            empty(): boolean,

            /**
             * Returns the number of values stored in this set.
             */
            size(): number
    }


/**
 * Creates an initially-empty set.
 */
declare export function d3$set(): d3$Set


/**
 * Merges the specified arrays into a single array.
 */
declare export function d3$merge<T>(arrays: T[][]): T[]


/**
 * Generates a 0-based numeric sequence. The output range does not include 'stop'.
 */
declare export function d3$range(stop: number): number[]


/**
 * Given the specified array, return an array corresponding to the list of indices in 'keys'.
 */
declare export function d3$permute<T>(array: {
    [key: number]: T
}, keys: number[]): T[]

declare export function d3$zip<T>(...arrays: T[][]): T[][]

declare export function d3$transpose<T>(matrix: T[][]): T[][]


/**
 * For each adjacent pair of elements in the specified array, returns a new array of tuples of elements i and i - 1.
 * Returns the empty array if the input array has fewer than two elements.
 */
declare export function d3$pairs<T>(array: T[]): Array<[T, T] >

    declare interface d3$Nest<T>{
        key(func: (datum: T) => string): d3$Nest<T>,
        sortKeys(comparator: (a: string, b: string) => number): d3$Nest<T>,
        sortValues(comparator: (a: T, b: T) => number): d3$Nest<T>,
        rollup<U>(func: (values: T[]) => U): d3$Nest<T>,
        map(array: T[]): {
            [key: string]: any
        },
        map(array: T[], mapType: typeof undefined): d3$Map<any>,
        entries(array: T[]): {
            key: string,
            values: any
        }[]
    }

declare export function d3$nest<T>(): d3$Nest<T >

    declare module 'random' {
        declare     export function normal(mean?: number, deviation?: number): () => number
        declare     export function logNormal(mean?: number, deviation?: number): () => number
        declare     export function bates(count: number): () => number
        declare     export function irwinHall(count: number): () => number
    }


declare interface d3$Transform {
    rotate: number,
        translate: [number, number],
        skew: number,
        scale: [number, number],
        toString(): string
}

declare export function d3$transform(transform: string): d3$Transform

declare export function d3$format(specifier: string): (n: number) => string

declare interface d3$FormatPrefix {
    symbol: string,
        scale(n: number): number
}

declare export function d3$formatPrefix(value: number, precision?: number): d3$FormatPrefix

declare export function d3$round(x: number, n?: number): number

declare export function d3$requote(string: string): string

declare export var rgb: {
    new(r: number, g: number, b: number): d3$Rgb,
    new(color: string): d3$Rgb,
    (r: number, g: number, b: number): d3$Rgb,
    (color: string): d3$Rgb
};

declare type d3$Rgb = {
    r: number,
    g: number,
    b: number,
    brighter(k?: number): d3$Rgb,
    darker(k?: number): d3$Rgb,
    hsl(): d3$Hsl,
    toString(): string
} & d3$Color


declare export var hsl: {
    new(h: number, s: number, l: number): d3$Hsl,
    new(color: string): d3$Hsl,
    (h: number, s: number, l: number): d3$Hsl,
    (color: string): d3$Hsl
};

declare type d3$Hsl = {
    h: number,
    s: number,
    l: number,
    brighter(k?: number): d3$Hsl,
    darker(k?: number): d3$Hsl,
    rgb(): d3$Rgb,
    toString(): string
} & d3$Color


declare export var hcl: {
    new(h: number, c: number, l: number): d3$Hcl,
    new(color: string): d3$Hcl,
    (h: number, c: number, l: number): d3$Hcl,
    (color: string): d3$Hcl
};

declare type d3$Hcl = {
    h: number,
    c: number,
    l: number,
    brighter(k?: number): d3$Hcl,
    darker(k?: number): d3$Hcl
} & d3$Color


declare export var lab: {
    new(l: number, a: number, b: number): d3$Lab,
    new(color: string): d3$Lab,
    (l: number, a: number, b: number): d3$Lab,
    (color: string): d3$Lab
};

declare type d3$Lab = {
    l: number,
    a: number,
    b: number,
    brighter(k?: number): d3$Lab,
    darker(k?: number): d3$Lab,
    rgb(): d3$Rgb,
    toString(): string
} & d3$Color


declare export var color: {
    (): d3$Color,
    new(): d3$Color
};

declare interface d3$Color {
    rgb(): d3$Rgb
}

declare module 'ns' {
    declare interface Qualified {
        space: string,
            local: string
    }
    declare export var prefix: {
        [key: string]: string
    };
    declare export function qualify(name: string): Qualified | string
}


declare export function d3$functor<T>(value: T): T

declare export function d3$rebind(target: {}, source: {}, ...names: string[]): any

declare export function d3$dispatch(...names: string[]): d3$Dispatch

declare interface d3$Dispatch {
    on(type: string): (...args: any[]) => void,
        on(type: string, listener: (...args: any[]) => any): d3$Dispatch, [event: string]: (...args: any[]) => void
}

declare module 'scale' {
    declare export function identity(): Identity
    declare interface Identity {
        (n: number): number,
        invert(n: number): number,
            domain(): number[],
            domain(numbers: number[]): Identity,
            range(): number[],
            range(numbers: number[]): Identity,
            ticks(count?: number): number[],
            tickFormat(count?: number, format?: string): (n: number) => string,
            copy(): Identity
    }
    declare export function linear(): Linear<number, number >
        declare interface Linear<Range, Output>{
            (x: number): Output,
            invert(y: number): number,
            domain(): number[],
            domain(numbers: number[]): Linear<Range,
            Output>,
            range(): Range[],
            range(values: Range[]): Linear<Range,
            Output>,
            rangeRound(values: number[]): Linear<number,
            number>,
            interpolate(): (a: Range, b: Range) => (t: number) => Output,
            interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Linear<Range,
            Output>,
            clamp(): boolean,
            clamp(clamp: boolean): Linear<Range,
            Output>,
            nice(count?: number): Linear<Range,
            Output>,
            ticks(count?: number): number[],
            tickFormat(count?: number, format?: string): (n: number) => string,
            copy(): Linear<Range,
            Output >
        }
    declare export function sqrt(): Pow<number, number >
        declare export function pow(): Pow<number, number >
        declare interface Pow<Range, Output>{
            (x: number): Output,
            invert(y: number): number,
            domain(): number[],
            domain(numbers: number[]): Pow<Range,
            Output>,
            range(): Range[],
            range(values: Range[]): Pow<Range,
            Output>,
            rangeRound(values: number[]): Pow<number,
            number>,
            exponent(): number,
            exponent(k: number): Pow<Range,
            Output>,
            interpolate(): (a: Range, b: Range) => (t: number) => Output,
            interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Pow<Range,
            Output>,
            clamp(): boolean,
            clamp(clamp: boolean): Pow<Range,
            Output>,
            nice(m?: number): Pow<Range,
            Output>,
            ticks(count?: number): number[],
            tickFormat(count?: number, format?: string): (n: number) => string,
            copy(): Pow<Range,
            Output >
        }
    declare export function log(): Log<number, number >
        declare interface Log<Range, Output>{
            (x: number): Output,
            invert(y: number): number,
            domain(): number[],
            domain(numbers: number[]): Log<Range,
            Output>,
            range(): Range[],
            range(values: Range[]): Log<Range,
            Output>,
            rangeRound(values: number[]): Log<number,
            number>,
            base(): number,
            base(base: number): Log<Range,
            Output>,
            interpolate(): (a: Range, b: Range) => (t: number) => Output,
            interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Log<Range,
            Output>,
            clamp(): boolean,
            clamp(clamp: boolean): Log<Range,
            Output>,
            nice(): Log<Range,
            Output>,
            ticks(): number[],
            tickFormat(count?: number, format?: string): (t: number) => string,
            copy(): Log<Range,
            Output >
        }
    declare export function quantize<T>(): Quantize<T >
        declare interface Quantize<T>{
            (x: number): T,
            invertExtent(y: T): [number, number],
            domain(): number[],
            domain(numbers: number[]): Quantize<T>,
            range(): T[],
            range(values: T[]): Quantize<T>,
            copy(): Quantize<T >
        }
    declare export function quantile(array: number[], p: number): number
    declare interface Quantile<T>{
        (x: number): T,
        invertExtent(y: T): [number, number],
        domain(): number[],
        domain(numbers: number[]): Quantile<T>,
        range(): T[],
        range(values: T[]): Quantile<T>,
        quantiles(): number[],
        copy(): Quantile<T >
    }
    declare export function threshold<Range>(): Threshold<number, Range >
        declare interface Threshold<Domain, Range>{
            (x: number): Range,
            invertExtent(y: Range): [Domain, Domain],
            domain(): Domain[],
            domain(domain: Domain[]): Threshold<Domain,
            Range>,
            range(): Range[],
            range(values: Range[]): Threshold<Domain,
            Range>,
            copy(): Threshold<Domain,
            Range >
        }
    declare export function ordinal<Range>(): Ordinal<string, Range >
        declare export function category10(): Ordinal<string, string >
        declare export function category20(): Ordinal<string, string >
        declare export function category20b(): Ordinal<string, string >
        declare export function category20c(): Ordinal<string, string >
        declare interface Ordinal<Domain, Range>{
            (x: Domain): Range,
            domain(): Domain[],
            domain(values: Domain[]): Ordinal<Domain,
            Range>,
            range(): Range[],
            range(values: Range[]): Ordinal<Domain,
            Range>,
            rangePoints(interval: [number, number], padding?: number): Ordinal<Domain,
            number>,
            rangeRoundPoints(interval: [number, number], padding?: number): Ordinal<Domain,
            number>,
            rangeBands(
                interval: [number, number],
                padding?: number,
                outerPadding?: number): Ordinal<Domain,
            number>,
            rangeRoundBands(
                interval: [number, number],
                padding?: number,
                outerPadding?: number): Ordinal<Domain,
            number>,
            rangeBand(): number,
            rangeExtent(): [number, number],
            copy(): Ordinal<Domain,
            Range >
        }
    declare export function utc(specifier: string): Format
}


declare export function d3$interpolate(a: number, b: number): (t: number) => number

declare export function d3$interpolateNumber(a: number, b: number): (t: number) => number

declare export function d3$interpolateRound(a: number, b: number): (t: number) => number

declare export function d3$interpolateString(a: string, b: string): (t: number) => string

declare export function d3$interpolateRgb(a: string | d3$Color, b: string | d3$Color): (t: number) => string

declare export function d3$interpolateHsl(a: string | d3$Color, b: string | d3$Color): (t: number) => string

declare export function d3$interpolateLab(a: string | d3$Color, b: string | d3$Color): (t: number) => string

declare export function d3$interpolateHcl(a: string | d3$Color, b: string | d3$Color): (t: number) => string

declare export function d3$interpolateArray(a: Array<string | d3$Color>, b: d3$Color[]): (t: number) => string[]

declare export function d3$interpolateObject(
    a: {
        [key: string]: string | d3$Color
    },
    b: {
        [key: string]: d3$Color
    }): (t: number) => {
    [key: string]: string
}

declare export function d3$interpolateTransform(a: string | d3$Transform, b: string | d3$Transform): (t: number) => string

declare export function d3$interpolateZoom(
    a: [number, number, number],
    b: [number, number, number]): {
    (t: number): [number, number, number],
    duration: number
}

declare export var interpolators: Array<(a: any, b: any) => (t: number) => any>;

declare module 'time' {
    declare export var second: Interval;
    declare export var minute: Interval;
    declare export var hour: Interval;
    declare export var day: Interval;
    declare export var week: Interval;
    declare export var sunday: Interval;
    declare export var monday: Interval;
    declare export var tuesday: Interval;
    declare export var wednesday: Interval;
    declare export var thursday: Interval;
    declare export var friday: Interval;
    declare export var saturday: Interval;
    declare export var month: Interval;
    declare export var year: Interval;
    declare interface Interval {
        (d: Date): Date,
        floor(d: Date): Date,
            round(d: Date): Date,
            ceil(d: Date): Date,
            range(start: Date, stop: Date, step?: number): Date[],
            offset(date: Date, step: number): Date,
            utc: {
                (d: Date): Date,
                floor(d: Date): Date,
                round(d: Date): Date,
                ceil(d: Date): Date,
                range(start: Date, stop: Date, step?: number): Date[],
                offset(date: Date, step: number): Date
            }
    }
    declare export function seconds(start: Date, stop: Date, step?: number): Date[]
    declare export function minutes(start: Date, stop: Date, step?: number): Date[]
    declare export function hours(start: Date, stop: Date, step?: number): Date[]
    declare export function days(start: Date, stop: Date, step?: number): Date[]
    declare export function weeks(start: Date, stop: Date, step?: number): Date[]
    declare export function sundays(start: Date, stop: Date, step?: number): Date[]
    declare export function mondays(start: Date, stop: Date, step?: number): Date[]
    declare export function tuesdays(start: Date, stop: Date, step?: number): Date[]
    declare export function wednesdays(start: Date, stop: Date, step?: number): Date[]
    declare export function thursdays(start: Date, stop: Date, step?: number): Date[]
    declare export function fridays(start: Date, stop: Date, step?: number): Date[]
    declare export function saturdays(start: Date, stop: Date, step?: number): Date[]
    declare export function months(start: Date, stop: Date, step?: number): Date[]
    declare export function years(start: Date, stop: Date, step?: number): Date[]
    declare export function dayOfYear(d: Date): number
    declare export function weekOfYear(d: Date): number
    declare export function sundayOfYear(d: Date): number
    declare export function mondayOfYear(d: Date): number
    declare export function tuesdayOfYear(d: Date): number
    declare export function wednesdayOfYear(d: Date): number
    declare export function fridayOfYear(d: Date): number
    declare export function saturdayOfYear(d: Date): number
    declare module 'format' {
        declare     export function multi(formats: Array<[string, (d: Date) => boolean | number]>): Format
        declare     export function utc(specifier: string): Format

        declare     var npm$namespace$utc: {
            multi: typeof utc$multi,
        }
        declare     export function utc$multi(formats: Array<[string, (d: Date) => boolean | number]>): Format
        declare     export var iso: Format;
    }

    declare interface Format {
        (d: Date): string,
        parse(input: string): Date
    }
    declare module 'scale' {
        declare     export function identity(): Identity
        declare interface Identity {
            (n: number): number,
            invert(n: number): number,
                domain(): number[],
                domain(numbers: number[]): Identity,
                range(): number[],
                range(numbers: number[]): Identity,
                ticks(count?: number): number[],
                tickFormat(count?: number, format?: string): (n: number) => string,
                copy(): Identity
        }
        declare     export function linear(): Linear<number, number >
            declare interface Linear<Range, Output>{
                (x: number): Output,
                invert(y: number): number,
                domain(): number[],
                domain(numbers: number[]): Linear<Range,
                Output>,
                range(): Range[],
                range(values: Range[]): Linear<Range,
                Output>,
                rangeRound(values: number[]): Linear<number,
                number>,
                interpolate(): (a: Range, b: Range) => (t: number) => Output,
                interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Linear<Range,
                Output>,
                clamp(): boolean,
                clamp(clamp: boolean): Linear<Range,
                Output>,
                nice(count?: number): Linear<Range,
                Output>,
                ticks(count?: number): number[],
                tickFormat(count?: number, format?: string): (n: number) => string,
                copy(): Linear<Range,
                Output >
            }
        declare     export function sqrt(): Pow<number, number >
            declare     export function pow(): Pow<number, number >
            declare interface Pow<Range, Output>{
                (x: number): Output,
                invert(y: number): number,
                domain(): number[],
                domain(numbers: number[]): Pow<Range,
                Output>,
                range(): Range[],
                range(values: Range[]): Pow<Range,
                Output>,
                rangeRound(values: number[]): Pow<number,
                number>,
                exponent(): number,
                exponent(k: number): Pow<Range,
                Output>,
                interpolate(): (a: Range, b: Range) => (t: number) => Output,
                interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Pow<Range,
                Output>,
                clamp(): boolean,
                clamp(clamp: boolean): Pow<Range,
                Output>,
                nice(m?: number): Pow<Range,
                Output>,
                ticks(count?: number): number[],
                tickFormat(count?: number, format?: string): (n: number) => string,
                copy(): Pow<Range,
                Output >
            }
        declare     export function log(): Log<number, number >
            declare interface Log<Range, Output>{
                (x: number): Output,
                invert(y: number): number,
                domain(): number[],
                domain(numbers: number[]): Log<Range,
                Output>,
                range(): Range[],
                range(values: Range[]): Log<Range,
                Output>,
                rangeRound(values: number[]): Log<number,
                number>,
                base(): number,
                base(base: number): Log<Range,
                Output>,
                interpolate(): (a: Range, b: Range) => (t: number) => Output,
                interpolate(factory: (a: Range, b: Range) => (t: number) => Output): Log<Range,
                Output>,
                clamp(): boolean,
                clamp(clamp: boolean): Log<Range,
                Output>,
                nice(): Log<Range,
                Output>,
                ticks(): number[],
                tickFormat(count?: number, format?: string): (t: number) => string,
                copy(): Log<Range,
                Output >
            }
        declare     export function quantize<T>(): Quantize<T >
            declare interface Quantize<T>{
                (x: number): T,
                invertExtent(y: T): [number, number],
                domain(): number[],
                domain(numbers: number[]): Quantize<T>,
                range(): T[],
                range(values: T[]): Quantize<T>,
                copy(): Quantize<T >
            }
        declare     export function quantile(array: number[], p: number): number
        declare interface Quantile<T>{
            (x: number): T,
            invertExtent(y: T): [number, number],
            domain(): number[],
            domain(numbers: number[]): Quantile<T>,
            range(): T[],
            range(values: T[]): Quantile<T>,
            quantiles(): number[],
            copy(): Quantile<T >
        }
        declare     export function threshold<Range>(): Threshold<number, Range >
            declare interface Threshold<Domain, Range>{
                (x: number): Range,
                invertExtent(y: Range): [Domain, Domain],
                domain(): Domain[],
                domain(domain: Domain[]): Threshold<Domain,
                Range>,
                range(): Range[],
                range(values: Range[]): Threshold<Domain,
                Range>,
                copy(): Threshold<Domain,
                Range >
            }
        declare     export function ordinal<Range>(): Ordinal<string, Range >
            declare     export function category10(): Ordinal<string, string >
            declare     export function category20(): Ordinal<string, string >
            declare     export function category20b(): Ordinal<string, string >
            declare     export function category20c(): Ordinal<string, string >
            declare interface Ordinal<Domain, Range>{
                (x: Domain): Range,
                domain(): Domain[],
                domain(values: Domain[]): Ordinal<Domain,
                Range>,
                range(): Range[],
                range(values: Range[]): Ordinal<Domain,
                Range>,
                rangePoints(interval: [number, number], padding?: number): Ordinal<Domain,
                number>,
                rangeRoundPoints(interval: [number, number], padding?: number): Ordinal<Domain,
                number>,
                rangeBands(
                    interval: [number, number],
                    padding?: number,
                    outerPadding?: number): Ordinal<Domain,
                number>,
                rangeRoundBands(
                    interval: [number, number],
                    padding?: number,
                    outerPadding?: number): Ordinal<Domain,
                number>,
                rangeBand(): number,
                rangeExtent(): [number, number],
                copy(): Ordinal<Domain,
                Range >
            }
        declare     export function utc(specifier: string): Format
    }

    declare interface Scale<Range, Output>{
        (x: Date): Output,
        invert(y: number): Date,
        domain(): Date[],
        domain(dates: number[]): brush$Scale<Range,
        Output>,
        domain(dates: Date[]): brush$Scale<Range,
        Output>,
        nice(): brush$Scale<Range,
        Output>,
        nice(interval: Interval, step?: number): brush$Scale<Range,
        Output>,
        range(): Range[],
        range(values: Range[]): brush$Scale<Range,
        Output>,
        rangeRound(values: number[]): brush$Scale<number,
        number>,
        interpolate(): (a: Range, b: Range) => (t: number) => Output,
        interpolate(
            factory: (a: Range, b: Range) => (t: number) => Output): brush$Scale<Range,
        Output>,
        clamp(): boolean,
        clamp(clamp: boolean): brush$Scale<Range,
        Output>,
        ticks(): Date[],
        ticks(interval: Interval, step?: number): Date[],
        ticks(count: number): Date[],
        tickFormat(count: number): (d: Date) => string,
        copy(): brush$Scale<Range,
        Output >
    }
}


declare module 'behavior' {
    declare export function drag<Datum>(): Drag<Datum >
        declare interface Drag<Datum>{
            (selection: d3$Selection<Datum>): void,
            on(type: string): (d: Datum, i: number) => any,
            on(type: string, listener: (d: Datum, i: number) => any): Drag<Datum>,
            origin(): (d: Datum, i: number) => {
                x: number,
                y: number
            },
            origin(accessor: (d: Datum, i: number) => {
                x: number,
                y: number
            }): Drag<Datum >
        }
    declare export function zoom<Datum>(): Zoom<Datum >
        declare interface zoom$Scale<Range, Output>{
            (x: Date): Output,
            invert(y: number): Date,
            domain(): Date[],
            domain(dates: number[]): zoom$Scale<Range,
            Output>,
            domain(dates: Date[]): zoom$Scale<Range,
            Output>,
            nice(): zoom$Scale<Range,
            Output>,
            nice(interval: Interval, step?: number): zoom$Scale<Range,
            Output>,
            range(): Range[],
            range(values: Range[]): zoom$Scale<Range,
            Output>,
            rangeRound(values: number[]): zoom$Scale<number,
            number>,
            interpolate(): (a: Range, b: Range) => (t: number) => Output,
            interpolate(
                factory: (a: Range, b: Range) => (t: number) => Output): zoom$Scale<Range,
            Output>,
            clamp(): boolean,
            clamp(clamp: boolean): zoom$Scale<Range,
            Output>,
            ticks(): Date[],
            ticks(interval: Interval, step?: number): Date[],
            ticks(count: number): Date[],
            tickFormat(count: number): (d: Date) => string,
            copy(): zoom$Scale<Range,
            Output >
        }
    declare interface Zoom<Datum>{
        (selection: d3$Selection<Datum>): void,
        translate(): [number, number],
        translate(translate: [number, number]): Zoom<Datum>,
        scale(): number,
        scale(scale: number): Zoom<Datum>,
        scaleExtent(): [number, number],
        scaleExtent(extent: [number, number]): Zoom<Datum>,
        center(): [number, number],
        center(center: [number, number]): Zoom<Datum>,
        size(): [number, number],
        size(size: [number, number]): Zoom<Datum>,
        x(): zoom$Scale,
        x(x: zoom$Scale): Zoom<Datum>,
        y(): zoom$Scale,
        y(y: zoom$Scale): Zoom<Datum>,
        on(type: string): (d: Datum, i: number) => any,
        on(type: string, listener: (d: Datum, i: number) => any): Zoom<Datum>,
        event(selection: d3$Selection<Datum>): void,
        event(transition: d3$Transition<Datum>): void
    }
}


declare module 'geo' {
    declare export function path(): Path
    declare interface Path {
        (feature: any, index?: number): string,
        area(feature: any): number,
            centroid(feature: any): [number, number],
            bounds(feature: any): [
                [number, number],
                [number, number]
            ],
            projection(): d3$Transform | ((coordinates: [number, number]) => [number, number]),
            projection(stream: d3$Transform): Path,
            projection(projection: (coordinates: [number, number]) => [number, number]): Path,
            pointRadius(): number | ((datum: any, index: number) => number),
            pointRadius(radius: number): Path,
            pointRadius(radius: (datum: any, index: number) => number): Path,
            context(): CanvasRenderingContext2D,
            context(context: CanvasRenderingContext2D): Path
    }
    declare export function graticule(): Graticule
    declare interface Graticule {
        (): any,
        lines(): any[],
            outline(): any,
            extent(): [
                [number, number],
                [number, number]
            ],
            extent(extent: [
                [number, number],
                [number, number]
            ]): Graticule,
            majorExtent(): [
                [number, number],
                [number, number]
            ],
            majorExtent(extent: [
                [number, number],
                [number, number]
            ]): Graticule,
            minorExtent(): [
                [number, number],
                [number, number]
            ],
            minorExtent(extent: [
                [number, number],
                [number, number]
            ]): Graticule,
            step(): [number, number],
            step(step: [number, number]): Graticule,
            majorStep(): [number, number],
            majorStep(step: [number, number]): Graticule,
            minorStep(): [number, number],
            minorStep(step: [number, number]): Graticule,
            precision(): number,
            precision(precision: number): Graticule
    }
    declare export function circle(): Circle
    declare interface Circle {
        (...args: any[]): any,
        origin(): [number, number] | ((...args: any[]) => [number, number]),
            origin(origin: [number, number]): Circle,
            origin(origin: (...args: any[]) => [number, number]): Circle,
            angle(): number,
            angle(angle: number): Circle,
            precision(): number,
            precision(precision: number): Circle
    }
    declare export function area(feature: any): number
    declare export function centroid(feature: any): [number, number]
    declare export function bounds(feature: any): [
        [number, number],
        [number, number]
    ]
    declare export function distance(a: [number, number], b: [number, number]): number
    declare export function length(feature: any): number
    declare export function interpolate(a: number, b: number): (t: number) => number
    declare export function rotation(rotate: [number, number] | [number, number, number]): Rotation
    declare interface Rotation {
        (location: [number, number]): [number, number],
        invert(location: [number, number]): [number, number]
    }
    declare export function stream(object: any, listener: Listener): void
    declare interface Listener {
        point(x: number, y: number, z: number): void,
            lineStart(): void,
            lineEnd(): void,
            polygonStart(): void,
            polygonEnd(): void,
            sphere(): void
    }
    declare export function transform(transform: string): d3$Transform
    declare interface TransformMethods {
        point(x: number, y: number, z: number): void,
            lineStart(): void,
            lineEnd(): void,
            polygonStart(): void,
            polygonEnd(): void,
            sphere(): void
    }
    declare interface Transform {
        rotate: number,
            translate: [number, number],
            skew: number,
            scale: [number, number],
            toString(): string
    }
    declare export function clipExtent(): ClipExtent
    declare type ClipExtent = {
        extent(): [
            [number, number],
            [number, number]
        ],
        extent(extent: [
            [number, number],
            [number, number]
        ]): ClipExtent
    } & d3$Transform

    declare export function projection(raw: RawInvertibleProjection): InvertibleProjection
    declare export function projectionMutator(
        factory: (...args: any[]) => RawInvertibleProjection): (...args: any[]) => InvertibleProjection
    declare export function albers(): ConicProjection
    declare export function albersUsa(): ConicProjection
    declare export function azimuthalEqualArea(): InvertibleProjection

    declare var npm$namespace$azimuthalEqualArea: {
        raw: typeof azimuthalEqualArea$raw,
    }
    declare export function azimuthalEqualArea$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function azimuthalEquidistant(): InvertibleProjection

    declare var npm$namespace$azimuthalEquidistant: {
        raw: typeof azimuthalEquidistant$raw,
    }
    declare export function azimuthalEquidistant$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function conicConformal(): ConicProjection

    declare var npm$namespace$conicConformal: {
        raw: typeof conicConformal$raw,
    }
    declare export function conicConformal$raw(lambda: number, phi: number): [number, number]
    declare export function conicEqualArea(): ConicProjection

    declare var npm$namespace$conicEqualArea: {
        raw: typeof conicEqualArea$raw,
    }
    declare export function conicEqualArea$raw(lambda: number, phi: number): [number, number]
    declare export function conicEquidistant(): ConicProjection

    declare var npm$namespace$conicEquidistant: {
        raw: typeof conicEquidistant$raw,
    }
    declare export function conicEquidistant$raw(lambda: number, phi: number): [number, number]
    declare export function equirectangular(): InvertibleProjection

    declare var npm$namespace$equirectangular: {
        raw: typeof equirectangular$raw,
    }
    declare export function equirectangular$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function gnomonic(): InvertibleProjection

    declare var npm$namespace$gnomonic: {
        raw: typeof gnomonic$raw,
    }
    declare export function gnomonic$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function mercator(): InvertibleProjection

    declare var npm$namespace$mercator: {
        raw: typeof mercator$raw,
    }
    declare export function mercator$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function orthographic(): InvertibleProjection

    declare var npm$namespace$orthographic: {
        raw: typeof orthographic$raw,
    }
    declare export function orthographic$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function stereographic(): InvertibleProjection

    declare var npm$namespace$stereographic: {
        raw: typeof stereographic$raw,
    }
    declare export function stereographic$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare export function transverseMercator(): InvertibleProjection

    declare var npm$namespace$transverseMercator: {
        raw: typeof transverseMercator$raw,
    }
    declare export function transverseMercator$raw(lambda: number, phi: number): [number, number]


    declare var npm$namespace$raw: {
        invert: typeof raw$invert,
    }
    declare export function raw$invert(x: number, y: number): [number, number]
    declare interface Projection {
        (location: [number, number]): [number, number],
        rotate(): [number, number, number],
            rotate(rotation: [number, number, number]): Projection,
            center(): [number, number],
            center(location: [number, number]): Projection,
            translate(): [number, number],
            translate(point: [number, number]): Projection,
            scale(): number,
            scale(scale: number): Projection,
            clipAngle(): number,
            clipAngle(angle: number): Projection,
            clipExtent(): [
                [number, number],
                [number, number]
            ],
            clipExtent(extent: [
                [number, number],
                [number, number]
            ]): Projection,
            precision(): number,
            precision(precision: number): Projection,
            stream(listener: Listener): Listener
    }
    declare type InvertibleProjection = {
        invert(point: [number, number]): [number, number]
    } & Projection

    declare type ConicProjection = {
        parallels(): [number, number],
        parallels(parallels: [number, number]): ConicProjection,
        rotate(): [number, number, number],
        rotate(rotation: [number, number, number]): ConicProjection,
        center(): [number, number],
        center(location: [number, number]): ConicProjection,
        translate(): [number, number],
        translate(point: [number, number]): ConicProjection,
        scale(): number,
        scale(scale: number): ConicProjection,
        clipAngle(): number,
        clipAngle(angle: number): ConicProjection,
        clipExtent(): [
            [number, number],
            [number, number]
        ],
        clipExtent(extent: [
            [number, number],
            [number, number]
        ]): ConicProjection,
        precision(): number,
        precision(precision: number): ConicProjection
    } & InvertibleProjection

    declare interface RawProjection {
        (lambda: number, phi: number): [number, number]
    }
    declare type RawInvertibleProjection = {
        invert(x: number, y: number): [number, number]
    } & RawProjection

}



declare var npm$namespace$svg: {
    line: typeof svg$line,
    area: typeof svg$area,
    arc: typeof svg$arc,
    symbol: typeof svg$symbol,
    chord: typeof svg$chord,
    diagonal: typeof svg$diagonal,
    axis: typeof svg$axis,
    brush: typeof svg$brush,
}
declare export function svg$line(): svg$Line<[number, number] >

    declare interface svg$Line<T>{
        (data: T[]): string,
        x(): number | ((d: T, i: number) => number),
        x(x: number): svg$Line<T>,
        x(x: (d: T, i: number) => number): svg$Line<T>,
        y(): number | ((d: T, i: number) => number),
        y(x: number): svg$Line<T>,
        y(y: (d: T, i: number) => number): svg$Line<T>,
        interpolate(): string | ((points: Array<[number, number]>) => string),
        interpolate(interpolate: "linear"): svg$Line<T>,
        interpolate(interpolate: "linear-closed"): svg$Line<T>,
        interpolate(interpolate: "step"): svg$Line<T>,
        interpolate(interpolate: "step-before"): svg$Line<T>,
        interpolate(interpolate: "step-after"): svg$Line<T>,
        interpolate(interpolate: "basis"): svg$Line<T>,
        interpolate(interpolate: "basis-open"): svg$Line<T>,
        interpolate(interpolate: "basis-closed"): svg$Line<T>,
        interpolate(interpolate: "bundle"): svg$Line<T>,
        interpolate(interpolate: "cardinal"): svg$Line<T>,
        interpolate(interpolate: "cardinal-open"): svg$Line<T>,
        interpolate(interpolate: "cardinal-closed"): svg$Line<T>,
        interpolate(interpolate: "monotone"): svg$Line<T>,
        interpolate(
            interpolate: string | ((points: Array<[number, number]>) => string)): svg$Line<T>,
        tension(): number,
        tension(tension: number): svg$Line<T>,
        defined(): (d: T, i: number) => boolean,
        defined(defined: (d: T, i: number) => boolean): svg$Line<T >
    }


declare var npm$namespace$line: {
    radial: typeof line$radial,
}
declare export function line$radial(): diagonal$Radial<[number, number] >

    declare interface line$Radial<T>{
        (data: T[]): string,
        radius(): number | ((d: T, i: number) => number),
        radius(radius: number): line$Radial<T>,
        radius(radius: (d: T, i: number) => number): line$Radial<T>,
        angle(): number | ((d: T, i: number) => number),
        angle(angle: number): line$Radial<T>,
        angle(angle: (d: T, i: number) => number): line$Radial<T>,
        interpolate(): string | ((points: Array<[number, number]>) => string),
        interpolate(interpolate: "linear"): line$Radial<T>,
        interpolate(interpolate: "linear-closed"): line$Radial<T>,
        interpolate(interpolate: "step"): line$Radial<T>,
        interpolate(interpolate: "step-before"): line$Radial<T>,
        interpolate(interpolate: "step-after"): line$Radial<T>,
        interpolate(interpolate: "basis"): line$Radial<T>,
        interpolate(interpolate: "basis-open"): line$Radial<T>,
        interpolate(interpolate: "basis-closed"): line$Radial<T>,
        interpolate(interpolate: "bundle"): line$Radial<T>,
        interpolate(interpolate: "cardinal"): line$Radial<T>,
        interpolate(interpolate: "cardinal-open"): line$Radial<T>,
        interpolate(interpolate: "cardinal-closed"): line$Radial<T>,
        interpolate(interpolate: "monotone"): line$Radial<T>,
        interpolate(
            interpolate: string | ((points: Array<[number, number]>) => string)): line$Radial<T>,
        tension(): number,
        tension(tension: number): line$Radial<T>,
        defined(): (d: T, i: number) => boolean,
        defined(defined: (d: T, i: number) => boolean): line$Radial<T >
    }

declare export function svg$area(feature: any): number

declare interface svg$Area<T>{
    (data: T[]): string,
    x(): number | ((d: T, i: number) => number),
    x(x: number): svg$Area<T>,
    x(x: (d: T, i: number) => number): svg$Area<T>,
    x0(): number | ((d: T, i: number) => number),
    x0(x0: number): svg$Area<T>,
    x0(x0: (d: T, i: number) => number): svg$Area<T>,
    x1(): number | ((d: T, i: number) => number),
    x1(x1: number): svg$Area<T>,
    x1(x1: (d: T, i: number) => number): svg$Area<T>,
    y(): number | ((d: T, i: number) => number),
    y(y: number): svg$Area<T>,
    y(y: (d: T, i: number) => number): svg$Area<T>,
    y0(): number | ((d: T, i: number) => number),
    y0(y0: number): svg$Area<T>,
    y0(y0: (d: T, i: number) => number): svg$Area<T>,
    y1(): number | ((d: T, i: number) => number),
    y1(y1: number): svg$Area<T>,
    y1(y1: (d: T, i: number) => number): svg$Area<T>,
    interpolate(): string | ((points: Array<[number, number]>) => string),
    interpolate(interpolate: "linear"): svg$Area<T>,
    interpolate(interpolate: "step"): svg$Area<T>,
    interpolate(interpolate: "step-before"): svg$Area<T>,
    interpolate(interpolate: "step-after"): svg$Area<T>,
    interpolate(interpolate: "basis"): svg$Area<T>,
    interpolate(interpolate: "basis-open"): svg$Area<T>,
    interpolate(interpolate: "cardinal"): svg$Area<T>,
    interpolate(interpolate: "cardinal-open"): svg$Area<T>,
    interpolate(interpolate: "monotone"): svg$Area<T>,
    interpolate(
        interpolate: string | ((points: Array<[number, number]>) => string)): svg$Area<T>,
    tension(): number,
    tension(tension: number): svg$Area<T>,
    defined(): (d: T, i: number) => boolean,
    defined(defined: (d: T, i: number) => boolean): svg$Area<T >
}


declare var npm$namespace$area: {
    radial: typeof area$radial,
}
declare export function area$radial(): line$Radial<[number, number] >

    declare interface area$Radial<T>{
        (data: T[]): string,
        radius(): number | ((d: T, i: number) => number),
        radius(radius: number): area$Radial<T>,
        radius(radius: (d: T, i: number) => number): area$Radial<T>,
        angle(): number | ((d: T, i: number) => number),
        angle(angle: number): area$Radial<T>,
        angle(angle: (d: T, i: number) => number): area$Radial<T>,
        interpolate(): string | ((points: Array<[number, number]>) => string),
        interpolate(interpolate: "linear"): area$Radial<T>,
        interpolate(interpolate: "linear-closed"): area$Radial<T>,
        interpolate(interpolate: "step"): area$Radial<T>,
        interpolate(interpolate: "step-before"): area$Radial<T>,
        interpolate(interpolate: "step-after"): area$Radial<T>,
        interpolate(interpolate: "basis"): area$Radial<T>,
        interpolate(interpolate: "basis-open"): area$Radial<T>,
        interpolate(interpolate: "basis-closed"): area$Radial<T>,
        interpolate(interpolate: "bundle"): area$Radial<T>,
        interpolate(interpolate: "cardinal"): area$Radial<T>,
        interpolate(interpolate: "cardinal-open"): area$Radial<T>,
        interpolate(interpolate: "cardinal-closed"): area$Radial<T>,
        interpolate(interpolate: "monotone"): area$Radial<T>,
        interpolate(
            interpolate: string | ((points: Array<[number, number]>) => string)): area$Radial<T>,
        tension(): number,
        tension(tension: number): area$Radial<T>,
        defined(): (d: T, i: number) => boolean,
        defined(defined: (d: T, i: number) => boolean): area$Radial<T >
    }

declare export function svg$arc(): pie$Arc<arc$Arc >

    declare interface arc$Arc {
        innerRadius: number,
            outerRadius: number,
            startAngle: number,
            endAngle: number,
            padAngle: number
    }

declare interface svg$Arc {
    innerRadius: number,
        outerRadius: number,
        startAngle: number,
        endAngle: number,
        padAngle: number
}

declare export function svg$symbol(): svg$Symbol<{} >

    declare interface svg$Symbol<T>{
        (d: T, i?: number): string,
        type(): (d: T, i: number) => string,
        type(type: string): svg$Symbol<T>,
        type(type: (d: T, i: number) => string): svg$Symbol<T>,
        size(): (d: T, i: string) => number,
        size(size: number): svg$Symbol<T>,
        size(size: (d: T, i: number) => number): svg$Symbol<T >
    }

declare export var symbolTypes: string[];

declare export function svg$chord(): layout$Chord<chord$Link<chord$Node>, chord$Node >

    declare interface chord$Link<Node>{
        source: quadtree$Node,
        target: quadtree$Node
    }

declare interface chord$Node {
    radius: number,
        startAngle: number,
        endAngle: number
}

declare interface svg$Chord<Link, Node>{
    (d: chord$Link, i: number): string,
    source(): (d: chord$Link, i: number) => chord$Node,
    source(source: chord$Node): svg$Chord<chord$Link,
    chord$Node>,
    source(
        source: (d: chord$Link, i: number) => chord$Node): svg$Chord<chord$Link,
    chord$Node>,
    target(): (d: chord$Link, i: number) => chord$Node,
    target(target: chord$Node): svg$Chord<chord$Link,
    chord$Node>,
    target(
        target: (d: chord$Link, i: number) => chord$Node): svg$Chord<chord$Link,
    chord$Node>,
    radius(): (d: chord$Node, i: number) => number,
    radius(radius: number): svg$Chord<chord$Link,
    chord$Node>,
    radius(
        radius: (d: chord$Node, i: number) => number): svg$Chord<chord$Link,
    chord$Node>,
    startAngle(): (d: chord$Node, i: number) => number,
    startAngle(angle: number): svg$Chord<chord$Link,
    chord$Node>,
    startAngle(angle: (d: chord$Node, i: number) => number): svg$Chord<chord$Link,
    chord$Node>,
    endAngle(): (d: chord$Node, i: number) => number,
    endAngle(angle: number): svg$Chord<chord$Link,
    chord$Node>,
    endAngle(angle: (d: chord$Node, i: number) => number): svg$Chord<chord$Link,
    chord$Node >
}

declare export function svg$diagonal(): svg$Diagonal<diagonal$Link<diagonal$Node>, diagonal$Node >


    declare var npm$namespace$diagonal: {
    radial: typeof diagonal$radial,
}
declare export function diagonal$radial(): area$Radial<[number, number] >

    declare interface diagonal$Radial<T>{
        (data: T[]): string,
        radius(): number | ((d: T, i: number) => number),
        radius(radius: number): diagonal$Radial<T>,
        radius(radius: (d: T, i: number) => number): diagonal$Radial<T>,
        angle(): number | ((d: T, i: number) => number),
        angle(angle: number): diagonal$Radial<T>,
        angle(angle: (d: T, i: number) => number): diagonal$Radial<T>,
        interpolate(): string | ((points: Array<[number, number]>) => string),
        interpolate(interpolate: "linear"): diagonal$Radial<T>,
        interpolate(interpolate: "linear-closed"): diagonal$Radial<T>,
        interpolate(interpolate: "step"): diagonal$Radial<T>,
        interpolate(interpolate: "step-before"): diagonal$Radial<T>,
        interpolate(interpolate: "step-after"): diagonal$Radial<T>,
        interpolate(interpolate: "basis"): diagonal$Radial<T>,
        interpolate(interpolate: "basis-open"): diagonal$Radial<T>,
        interpolate(interpolate: "basis-closed"): diagonal$Radial<T>,
        interpolate(interpolate: "bundle"): diagonal$Radial<T>,
        interpolate(interpolate: "cardinal"): diagonal$Radial<T>,
        interpolate(interpolate: "cardinal-open"): diagonal$Radial<T>,
        interpolate(interpolate: "cardinal-closed"): diagonal$Radial<T>,
        interpolate(interpolate: "monotone"): diagonal$Radial<T>,
        interpolate(
            interpolate: string | ((points: Array<[number, number]>) => string)): diagonal$Radial<T>,
        tension(): number,
        tension(tension: number): diagonal$Radial<T>,
        defined(): (d: T, i: number) => boolean,
        defined(defined: (d: T, i: number) => boolean): diagonal$Radial<T >
    }

declare interface svg$Diagonal<Link, Node>{
    (d: chord$Link, i?: number): string,
    source(): (d: chord$Link, i: number) => chord$Node,
    source(source: chord$Node): svg$Diagonal<chord$Link,
    chord$Node>,
    source(
        source: (d: chord$Link, i: number) => {
            x: number,
            y: number
        }): svg$Diagonal<chord$Link,
    chord$Node>,
    target(): (d: chord$Link, i: number) => chord$Node,
    target(target: chord$Node): svg$Diagonal<chord$Link,
    chord$Node>,
    target(
        target: (d: chord$Link, i: number) => {
            x: number,
            y: number
        }): svg$Diagonal<chord$Link,
    chord$Node>,
    projection(): (d: chord$Node, i: number) => [number, number],
    projection(
        projection: (d: chord$Node, i: number) => [number, number]): svg$Diagonal<chord$Link,
    chord$Node >
}

declare export function svg$axis(): svg$Axis

declare interface svg$Axis {
    (selection: d3$Selection<any>): void,
    (selection: d3$Transition<any>): void,
    scale(): any,
        scale(scale: any): svg$Axis,
        orient(): string,
        orient(orientation: string): svg$Axis,
        ticks(): any[],
        ticks(...args: any[]): svg$Axis,
        tickValues(): any[],
        tickValues(values: any[]): svg$Axis,
        tickSize(): number,
        tickSize(size: number): svg$Axis,
        tickSize(inner: number, outer: number): svg$Axis,
        innerTickSize(): number,
        innerTickSize(size: number): svg$Axis,
        outerTickSize(): number,
        outerTickSize(size: number): svg$Axis,
        tickPadding(): number,
        tickPadding(padding: number): svg$Axis,
        tickFormat(): (t: any) => string,
        tickFormat(format: (t: any) => string): svg$Axis,
        tickFormat(format: string): svg$Axis
}

declare export function svg$brush(): svg$Brush<any >

    declare interface brush$Scale<Range, Output>{
        (x: Date): Output,
        invert(y: number): Date,
        domain(): Date[],
        domain(dates: number[]): brush$Scale<Range,
        Output>,
        domain(dates: Date[]): brush$Scale<Range,
        Output>,
        nice(): brush$Scale<Range,
        Output>,
        nice(interval: Interval, step?: number): brush$Scale<Range,
        Output>,
        range(): Range[],
        range(values: Range[]): brush$Scale<Range,
        Output>,
        rangeRound(values: number[]): brush$Scale<number,
        number>,
        interpolate(): (a: Range, b: Range) => (t: number) => Output,
        interpolate(
            factory: (a: Range, b: Range) => (t: number) => Output): brush$Scale<Range,
        Output>,
        clamp(): boolean,
        clamp(clamp: boolean): brush$Scale<Range,
        Output>,
        ticks(): Date[],
        ticks(interval: Interval, step?: number): Date[],
        ticks(count: number): Date[],
        tickFormat(count: number): (d: Date) => string,
        copy(): brush$Scale<Range,
        Output >
    }

declare interface svg$Brush<T>{
    (selection: d3$Selection<T>): void,
    (selection: d3$Transition<T>): void,
    event(selection: d3$Selection<T>): void,
    event(selection: d3$Transition<T>): void,
    x(): brush$Scale,
    x(x: brush$Scale): svg$Brush<T>,
    y(): brush$Scale,
    y(y: brush$Scale): svg$Brush<T>,
    extent(): [number, number] | [
        [number, number],
        [number, number]
    ],
    extent(extent: [number, number] | [
        [number, number],
        [number, number]
    ]): svg$Brush<T>,
    clamp(): boolean | [boolean, boolean],
    clamp(clamp: boolean | [boolean, boolean]): svg$Brush<T>,
    clear(): void,
    empty(): boolean,
    on(type: "brushstart"): (datum: T, index: number) => void,
    on(type: "brush"): (datum: T, index: number) => void,
    on(type: "brushend"): (datum: T, index: number) => void,
    on(type: string): (datum: T, index: number) => void,
    on(type: "brushstart", listener: (datum: T, index: number) => void): svg$Brush<T>,
    on(type: "brush", listener: (datum: T, index: number) => void): svg$Brush<T>,
    on(type: "brushend", listener: (datum: T, index: number) => void): svg$Brush<T>,
    on(type: string, listener: (datum: T, index: number) => void): svg$Brush<T >
}

declare export function d3$xhr(
    url: string,
    mimeType?: string,
    callback?: (err: any, data: any) => void): d3$Xhr

declare interface d3$Xhr {
    header(name: string): string,
        header(name: string, value: string): d3$Xhr,
        mimeType(): string,
        mimeType(type: string): d3$Xhr,
        responseType(): string,
        responseType(type: string): d3$Xhr,
        response(): (request: XMLHttpRequest) => any,
        response(value: (request: XMLHttpRequest) => any): d3$Xhr,
        get(callback?: (err: any, data: any) => void): d3$Xhr,
        post(data?: any, callback?: (err: any, data: any) => void): d3$Xhr,
        post(callback: (err: any, data: any) => void): d3$Xhr,
        send(method: string, data?: any, callback?: (err: any, data: any) => void): d3$Xhr,
        send(method: string, callback: (err: any, data: any) => void): d3$Xhr,
        abort(): d3$Xhr,
        on(type: "beforesend"): (request: XMLHttpRequest) => void,
        on(type: "progress"): (request: XMLHttpRequest) => void,
        on(type: "load"): (response: any) => void,
        on(type: "error"): (err: any) => void,
        on(type: string): (...args: any[]) => void,
        on(type: "beforesend", listener: (request: XMLHttpRequest) => void): d3$Xhr,
        on(type: "progress", listener: (request: XMLHttpRequest) => void): d3$Xhr,
        on(type: "load", listener: (response: any) => void): d3$Xhr,
        on(type: "error", listener: (err: any) => void): d3$Xhr,
        on(type: string, listener: (...args: any[]) => void): d3$Xhr
}

declare export function d3$text(
    url: string,
    mimeType?: string,
    callback?: (err: any, data: string) => void): d3$Xhr

declare export function d3$json(url: string, callback?: (err: any, data: any) => void): d3$Xhr

declare export function d3$xml(
    url: string,
    mimeType?: string,
    callback?: (err: any, data: any) => void): d3$Xhr

declare export function d3$html(url: string, callback?: (err: any, data: DocumentFragment) => void): d3$Xhr

declare export var csv: d3$Dsv;

declare export var tsv: d3$Dsv;

declare export function d3$dsv(delimiter: string, mimeType: string): d3$Dsv

declare interface d3$Dsv {
    (url: string, callback: (rows: {
        [key: string]: string
    }[]) => void): d3$DsvXhr<{
            [key: string]: string
        }>,
        (url: string, callback: (error: any, rows: {
            [key: string]: string
        }[]) => void): d3$DsvXhr<{
            [key: string]: string
        }>,
        (url: string): d3$DsvXhr<{
            [key: string]: string
        }>,
        (url: string, accessor: (row: {
            [key: string]: string
        }) => T, callback: (rows: T[]) => void): d3$DsvXhr<T>,
        (url: string, accessor: (row: {
            [key: string]: string
        }) => T, callback: (error: any, rows: T[]) => void): d3$DsvXhr<T>,
        (url: string, accessor: (row: {
            [key: string]: string
        }) => T): d3$DsvXhr<T>,
        parse(string: string): {
            [key: string]: string
        }[],
        parse<T>(
            string: string,
            accessor: (row: {
                [key: string]: string
            }, index: number) => T): T[],
        parseRows(string: string): string[][],
        parseRows<T>(string: string, accessor: (row: string[], index: number) => T): T[],
        format(rows: Object[]): string,
        formatRows(rows: string[][]): string
}

declare type d3$DsvXhr<T>= {
    row(): (row: {
        [key: string]: string
    }) => T,
    row<U>(accessor: (row: {
        [key: string]: string
    }) => U): d3$DsvXhr<U>,
    header(name: string): string,
    header(name: string, value: string): d3$DsvXhr<T>,
    mimeType(): string,
    mimeType(type: string): d3$DsvXhr<T>,
    responseType(): string,
    responseType(type: string): d3$DsvXhr<T>,
    response(): (request: XMLHttpRequest) => any,
    response(value: (request: XMLHttpRequest) => any): d3$DsvXhr<T>,
    get(callback?: (err: XMLHttpRequest, data: T[]) => void): d3$DsvXhr<T>,
    post(data?: any, callback?: (err: XMLHttpRequest, data: T[]) => void): d3$DsvXhr<T>,
    post(callback: (err: XMLHttpRequest, data: T[]) => void): d3$DsvXhr<T>,
    send(
        method: string,
        data?: any,
        callback?: (err: XMLHttpRequest, data: T[]) => void): d3$DsvXhr<T>,
    send(
        method: string,
        callback: (err: XMLHttpRequest, data: T[]) => void): d3$DsvXhr<T>,
    abort(): d3$DsvXhr<T>,
    on(type: "beforesend"): (request: XMLHttpRequest) => void,
    on(type: "progress"): (request: XMLHttpRequest) => void,
    on(type: "load"): (response: T[]) => void,
    on(type: "error"): (err: any) => void,
    on(type: string): (...args: any[]) => void,
    on(type: "beforesend", listener: (request: XMLHttpRequest) => void): d3$DsvXhr<T>,
    on(type: "progress", listener: (request: XMLHttpRequest) => void): d3$DsvXhr<T>,
    on(type: "load", listener: (response: T[]) => void): d3$DsvXhr<T>,
    on(type: "error", listener: (err: any) => void): d3$DsvXhr<T>,
    on(type: string, listener: (...args: any[]) => void): d3$DsvXhr<T >
} & d3$Xhr


declare export function d3$locale(definition: d3$LocaleDefinition): d3$Locale

declare interface d3$LocaleDefinition {
    decimal: string,
        thousands: string,
        grouping: number[],
        currency: [string, string],
        dateTime: string,
        date: string,
        time: string,
        periods: [string, string],
        days: [string, string, string, string, string, string, string],
        shortDays: [string, string, string, string, string, string, string],
        months: [string, string, string, string, string, string, string, string, string, string, string, string],
        shortMonths: [string, string, string, string, string, string, string, string, string, string, string, string]
}

declare interface d3$Locale {
    numberFormat(specifier: string): (n: number) => string,
        timeFormat: {
            (specifier: string): time.Format,
            utc(specifier: string): time.Format,
            multi(formats: Array<[string, (d: Date) => boolean | number]>): time.Format
        }
}


declare var npm$namespace$layout: {
    bundle: typeof layout$bundle,
    chord: typeof layout$chord,
    cluster: typeof layout$cluster,
    force: typeof layout$force,
    hierarchy: typeof layout$hierarchy,
    histogram: typeof layout$histogram,
    pack: typeof layout$pack,
    partition: typeof layout$partition,
    pie: typeof layout$pie,
    stack: typeof layout$stack,
    tree: typeof layout$tree,
    treemap: typeof layout$treemap,
}
declare export function layout$bundle(): layout$Bundle<bundle$Node >

    declare interface bundle$Node {
        radius: number,
            startAngle: number,
            endAngle: number
    }

declare interface bundle$Link<Node>{
    source: bundle$Node,
    target: bundle$Node
}

declare interface layout$Bundle<T>{
    (links: bundle$Link<T>[]): T[][]
}

declare export function layout$chord(): svg$Chord<chord$Link<chord$Node>, chord$Node >

    declare interface chord$Link<Node>{
        source: bundle$Node,
        target: bundle$Node
    }

declare interface chord$Node {
    radius: number,
        startAngle: number,
        endAngle: number
}


/**
 * Selections are grouped into arrays of nodes, with the parent tracked in the 'parentNode' property.
 */
declare type chord$Group = {
    parentNode: EventTarget
} & Array


declare interface layout$Chord<Link, Node>{
    (d: chord$Link, i: number): string,
    source(): (d: chord$Link, i: number) => chord$Node,
    source(source: chord$Node): layout$Chord<chord$Link,
    chord$Node>,
    source(
        source: (d: chord$Link, i: number) => chord$Node): layout$Chord<chord$Link,
    chord$Node>,
    target(): (d: chord$Link, i: number) => chord$Node,
    target(target: chord$Node): layout$Chord<chord$Link,
    chord$Node>,
    target(
        target: (d: chord$Link, i: number) => chord$Node): layout$Chord<chord$Link,
    chord$Node>,
    radius(): (d: chord$Node, i: number) => number,
    radius(radius: number): layout$Chord<chord$Link,
    chord$Node>,
    radius(
        radius: (d: chord$Node, i: number) => number): layout$Chord<chord$Link,
    chord$Node>,
    startAngle(): (d: chord$Node, i: number) => number,
    startAngle(angle: number): layout$Chord<chord$Link,
    chord$Node>,
    startAngle(
        angle: (d: chord$Node, i: number) => number): layout$Chord<chord$Link,
    chord$Node>,
    endAngle(): (d: chord$Node, i: number) => number,
    endAngle(angle: number): layout$Chord<chord$Link,
    chord$Node>,
    endAngle(
        angle: (d: chord$Node, i: number) => number): layout$Chord<chord$Link,
    chord$Node >
}

declare export function layout$cluster(): layout$Cluster<cluster$Result >

    declare interface cluster$Result {
        parent?: cluster$Result,
            children?: cluster$Result[],
            depth?: number,
            x?: number,
            y?: number
    }

declare interface cluster$Link<Node>{
    source: chord$Node,
    target: chord$Node
}

declare interface layout$Cluster<T>{
    (root: T): T[],
    nodes(root: T): T[],
    links(nodes: T[]): cluster$Link<T>[],
    children(): (node: T) => T[],
    children(accessor: (node: T) => T[]): layout$Cluster<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Cluster<T>,
    separation(): (a: T, b: T) => number,
    separation(separation: (a: T, b: T) => number): layout$Cluster<T>,
    size(): [number, number],
    size(size: [number, number]): layout$Cluster<T>,
    nodeSize(): [number, number],
    nodeSize(nodeSize: [number, number]): layout$Cluster<T>,
    value(): (a: T) => number,
    value(value: (a: T) => number): layout$Cluster<T >
}

declare export function layout$force(): layout$Force<force$Link<force$Node>, force$Node >

    declare interface force$Link<Node>{
        source: chord$Node,
        target: chord$Node
    }

declare interface force$Node {
    radius: number,
        startAngle: number,
        endAngle: number
}

declare interface force$Event {
    type: string,
        alpha: number
}

declare interface layout$Force<Link, Node>{
    size(): [number, number],
    size(size: [number, number]): layout$Force<force$Link,
    force$Node>,
    linkDistance(): number | ((link: force$Link, index: number) => number),
    linkDistance(distance: number): layout$Force<force$Link,
    force$Node>,
    linkDistance(
        distance: (link: force$Link, index: number) => number): layout$Force<force$Link,
    force$Node>,
    linkStrength(): number | ((link: force$Link, index: number) => number),
    linkStrength(strength: number): layout$Force<force$Link,
    force$Node>,
    linkStrength(
        strength: (link: force$Link, index: number) => number): layout$Force<force$Link,
    force$Node>,
    friction(): number,
    friction(friction: number): layout$Force<force$Link,
    force$Node>,
    charge(): number | ((node: force$Node, index: number) => number),
    charge(charge: number): layout$Force<force$Link,
    force$Node>,
    charge(
        charge: (node: force$Node, index: number) => number): layout$Force<force$Link,
    force$Node>,
    chargeDistance(): number,
    chargeDistance(distance: number): layout$Force<force$Link,
    force$Node>,
    theta(): number,
    theta(theta: number): layout$Force<force$Link,
    force$Node>,
    gravity(): number,
    gravity(gravity: number): layout$Force<force$Link,
    force$Node>,
    nodes(): force$Node[],
    nodes(nodes: force$Node[]): layout$Force<force$Link,
    force$Node>,
    links(): force$Link[],
    links(
        links: {
            source: number,
            target: number
        }[]): layout$Force<force$Link,
    force$Node>,
    links(links: force$Link[]): layout$Force<force$Link,
    force$Node>,
    start(): layout$Force<force$Link,
    force$Node>,
    tick(): layout$Force<force$Link,
    force$Node>,
    alpha(): number,
    alpha(value: number): layout$Force<force$Link,
    force$Node>,
    resume(): layout$Force<force$Link,
    force$Node>,
    stop(): layout$Force<force$Link,
    force$Node>,
    on(type: string): (event: force$Event) => void,
    on(
        type: string,
        listener: (event: force$Event) => void): layout$Force<force$Link,
    force$Node>,
    drag(): behavior.Drag<force$Node>,
    drag(selection: d3$Selection<force$Node>): void
}

declare export function layout$hierarchy(): layout$Hierarchy<hierarchy$Result >

    declare interface hierarchy$Result {
        parent?: hierarchy$Result,
            children?: hierarchy$Result[],
            depth?: number,
            x?: number,
            y?: number
    }

declare interface layout$Hierarchy<T>{
    (root: T): T[],
    children(): (node: T) => T[],
    children(accessor: (node: T) => T[]): layout$Hierarchy<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Hierarchy<T>,
    value(): (node: T) => number,
    value(accessor: (node: T) => number): layout$Hierarchy<T>,
    revalue(root: T): T[]
}

declare export function layout$histogram(): layout$Histogram<number >

    declare type histogram$Bin<T>= {
        x: number,
        dx: number,
        y: number
    } & Array


declare interface layout$Histogram<T>{
    (values: T[], index?: number): histogram$Bin<T>[],
    value(): (datum: T, index: number) => number,
    value(value: (datum: T, index: number) => number): layout$Histogram<T>,
    range(): (values: T[], index: number) => [number, number],
    range(range: (values: T[], index: number) => [number, number]): layout$Histogram<T>,
    range(range: [number, number]): layout$Histogram<T>,
    bins(): (range: [number, number], values: T[], index: number) => number[],
    bins(count: number): layout$Histogram<T>,
    bins(thresholds: number[]): layout$Histogram<T>,
    bins(
        func: (range: [number, number], values: T[], index: number) => number[]): layout$Histogram<T>,
    frequency(): boolean,
    frequency(frequency: boolean): layout$Histogram<T >
}

declare export function layout$pack(): layout$Pack<pack$Node >

    declare interface pack$Node {
        radius: number,
            startAngle: number,
            endAngle: number
    }

declare interface pack$Link<Node>{
    source: pack$Node,
    target: pack$Node
}

declare interface layout$Pack<T>{
    (root: T): T[],
    nodes(root: T): T[],
    links(nodes: T[]): pack$Link<T>[],
    children(): (node: T, depth: number) => T[],
    children(children: (node: T, depth: number) => T[]): layout$Pack<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Pack<T>,
    value(): (node: T) => number,
    value(value: (node: T) => number): layout$Pack<T>,
    size(): [number, number],
    size(size: [number, number]): layout$Pack<T>,
    radius(): number | ((node: T) => number),
    radius(radius: number): layout$Pack<T>,
    radius(radius: (node: T) => number): layout$Pack<T>,
    padding(): number,
    padding(padding: number): layout$Pack<T >
}

declare export function layout$partition(): layout$Partition<partition$Node >

    declare interface partition$Link<Node>{
        source: pack$Node,
        target: pack$Node
    }

declare interface partition$Node {
    radius: number,
        startAngle: number,
        endAngle: number
}

declare export interface layout$Partition<T>{
    (root: T): T[],
    nodes(root: T): T[],
    links(nodes: T[]): partition$Link<T>[],
    children(): (node: T, depth: number) => T[],
    children(children: (node: T, depth: number) => T[]): layout$Partition<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Partition<T>,
    value(): (node: T) => number,
    value(value: (node: T) => number): layout$Partition<T>,
    size(): [number, number],
    size(size: [number, number]): layout$Partition<T >
}

declare export function layout$pie(): layout$Pie<number >

    declare interface pie$Arc {
        innerRadius: number,
            outerRadius: number,
            startAngle: number,
            endAngle: number,
            padAngle: number
    }

declare interface layout$Pie<T>{
    (data: T[], index?: number): pie$Arc<T>[],
    value(): (datum: T, index: number) => number,
    value(accessor: (datum: T, index: number) => number): layout$Pie<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Pie<T>,
    startAngle(): number | ((data: T[], index: number) => number),
    startAngle(angle: number): layout$Pie<T>,
    startAngle(angle: (data: T[], index: number) => number): layout$Pie<T>,
    endAngle(): number | ((data: T[], index: number) => number),
    endAngle(angle: number): layout$Pie<T>,
    endAngle(angle: (data: T[], index: number) => number): layout$Pie<T>,
    padAngle(): number | ((data: T[], index: number) => number),
    padAngle(angle: number): layout$Pie<T>,
    padAngle(angle: (data: T[], index: number) => number): layout$Pie<T >
}

declare export function layout$stack(): layout$Stack<stack$Value[], stack$Value >

    declare interface stack$Value {
        x: number,
            y: number,
            y0?: number
    }

declare interface layout$Stack<Series, Value>{
    (layers: Series[], index?: number): Series[],
    values(): (layer: Series, index: number) => stack$Value[],
    values(
        accessor: (layer: Series, index: number) => stack$Value[]): layout$Stack<Series,
    stack$Value>,
    offset(): (data: Array<[number, number]>) => number[],
    offset(offset: "silhouette"): layout$Stack<Series,
    stack$Value>,
    offset(offset: "wiggle"): layout$Stack<Series,
    stack$Value>,
    offset(offset: "expand"): layout$Stack<Series,
    stack$Value>,
    offset(offset: "zero"): layout$Stack<Series,
    stack$Value>,
    offset(offset: string): layout$Stack<Series,
    stack$Value>,
    offset(
        offset: (data: Array<[number, number]>) => number[]): layout$Stack<Series,
    stack$Value>,
    order(): (data: Array<[number, number]>) => number[],
    order(order: "inside-out"): layout$Stack<Series,
    stack$Value>,
    order(order: "reverse"): layout$Stack<Series,
    stack$Value>,
    order(order: "default"): layout$Stack<Series,
    stack$Value>,
    order(order: string): layout$Stack<Series,
    stack$Value>,
    order(
        order: (data: Array<[number, number]>) => number[]): layout$Stack<Series,
    stack$Value>,
    x(): (value: stack$Value, index: number) => number,
    x(
        accessor: (value: stack$Value, index: number) => number): layout$Stack<Series,
    stack$Value>,
    y(): (value: stack$Value, index: number) => number,
    y(
        accesor: (value: stack$Value, index: number) => number): layout$Stack<Series,
    stack$Value>,
    out(): (value: stack$Value, y0: number, y: number) => void,
    out(
        setter: (value: stack$Value, y0: number, y: number) => void): layout$Stack<Series,
    stack$Value >
}

declare export function layout$tree(): layout$Tree<tree$Node >

    declare interface tree$Link<Node>{
        source: partition$Node,
        target: partition$Node
    }

declare interface tree$Node {
    radius: number,
        startAngle: number,
        endAngle: number
}

declare interface layout$Tree<T>{
    (root: T, index?: number): T[],
    nodes(root: T, index?: number): T[],
    links(nodes: T[]): tree$Link<T>[],
    children(): (datum: T, index: number) => T[],
    children(children: (datum: T, index: number) => T[]): layout$Tree<T>,
    separation(): (a: T, b: T) => number,
    separation(separation: (a: T, b: T) => number): layout$Tree<T>,
    size(): [number, number],
    size(size: [number, number]): layout$Tree<T>,
    nodeSize(): [number, number],
    nodeSize(size: [number, number]): layout$Tree<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Tree<T>,
    value(): (datum: T, index: number) => number,
    value(value: (datum: T, index: number) => number): layout$Tree<T >
}

declare export function layout$treemap(): layout$Treemap<treemap$Node >

    declare interface treemap$Node {
        radius: number,
            startAngle: number,
            endAngle: number
    }

declare interface treemap$Link<Node>{
    source: treemap$Node,
    target: treemap$Node
}

declare type treemap$Padding = number | [number, number, number, number];

declare interface layout$Treemap<T>{
    (root: T, index?: number): T[],
    nodes(root: T, index?: number): T[],
    links(nodes: T[]): treemap$Link<T>[],
    children(): (node: T, depth: number) => T[],
    children(children: (node: T, depth: number) => T[]): layout$Treemap<T>,
    sort(): (a: T, b: T) => number,
    sort(comparator: (a: T, b: T) => number): layout$Treemap<T>,
    value(): (node: T, index: number) => number,
    value(value: (node: T, index: number) => number): layout$Treemap<T>,
    size(): [number, number],
    size(size: [number, number]): layout$Treemap<T>,
    padding(): (node: T, depth: number) => treemap$Padding,
    padding(padding: treemap$Padding): layout$Treemap<T>,
    padding(padding: (node: T, depth: number) => treemap$Padding): layout$Treemap<T>,
    round(): boolean,
    round(round: boolean): layout$Treemap<T>,
    sticky(): boolean,
    sticky(sticky: boolean): boolean,
    mode(): string,
    mode(mode: "squarify"): layout$Treemap<T>,
    mode(mode: "slice"): layout$Treemap<T>,
    mode(mode: "dice"): layout$Treemap<T>,
    mode(mode: "slice-dice"): layout$Treemap<T>,
    mode(mode: string): layout$Treemap<T>,
    ratio(): number,
    ratio(ratio: number): layout$Treemap<T >
}


declare var npm$namespace$geom: {
    voronoi: typeof geom$voronoi,
    delaunay: typeof geom$delaunay,
    quadtree: typeof geom$quadtree,
    hull: typeof geom$hull,
    polygon: typeof geom$polygon,
}
declare export function geom$voronoi(): geom$Voronoi<[number, number] >

    declare interface voronoi$Link<Node>{
        source: treemap$Node,
        target: treemap$Node
    }

declare interface geom$Voronoi<T>{
    (data: T[]): Array<[number, number]>,
    x(): (vertex: T) => number,
    x(x: (vertex: T) => number): geom$Voronoi<T>,
    y(): (vertex: T) => number,
    y(y: (vertex: T) => number): geom$Voronoi<T>,
    clipExtent(): [
        [number, number],
        [number, number]
    ],
    clipExtent(extent: [
        [number, number],
        [number, number]
    ]): geom$Voronoi<T>,
    links(data: T[]): voronoi$Link<T>[],
    triangles(data: T[]): Array<[T, T, T] >
}


/**
 * 
 * @deprecated  use d3.geom.voronoi().triangles() instead
 */
declare export function geom$delaunay(
    vertices: Array<[number, number]>): Array<[
        [number, number],
        [number, number],
        [number, number]
    ] >

    declare export function geom$quadtree(): geom$Quadtree<[number, number] >

    declare interface quadtree$Node {
        radius: number,
            startAngle: number,
            endAngle: number
    }

declare type quadtree$Quadtree<T>= {
    add(point: T): void,
    visit(
        callback: (
            node: quadtree$Node<T>,
            x1: number,
            y1: number,
            x2: number,
            y2: number) => boolean | void): void,
    find(point: [number, number]): T
} & quadtree$Node


declare type geom$Quadtree<T>= {
    add(point: T): void,
    visit(
        callback: (
            node: quadtree$Node<T>,
            x1: number,
            y1: number,
            x2: number,
            y2: number) => boolean | void): void,
    find(point: [number, number]): T
} & quadtree$Node


declare export function geom$hull(vertices: Array<[number, number]>): Array<[number, number] >

    declare interface geom$Hull<T>{
        (vertices: T[]): Array<[number, number]>,
        x(): (datum: T) => number,
        x(x: (datum: T) => number): geom$Hull<T>,
        y(): (datum: T) => number,
        y(y: (datum: T) => number): geom$Hull<T >
    }

declare export function geom$polygon(vertices: Array<[number, number]>): geom$Polygon

declare interface geom$Polygon {
    area(): number,
        centroid(): [number, number],
        clip(subject: Array<[number, number]>): Array<[number, number] >
}
declare interface TouchList {}
declare module 'd3' {
    declare module.exports: typeof d3
}