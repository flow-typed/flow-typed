/**
 * Flowtype definitions for selenium-webdriver
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$chrome: {
        getDefaultService: typeof chrome$getDefaultService,
        setDefaultService: typeof chrome$setDefaultService,
    }
    /**
     * Creates a new WebDriver client for Chrome.
     * @extends  {webdriver.WebDriver}
     */
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options.
     * @param  The session to use; will use
    the {
     * @link  getDefaultService default service} by default.
     * @param  The control flow to use, or
    {
     * @code  null} to use the currently active flow.
     * @constructor  
    */
    constructor(opt_config?: webdriver$Capabilities, opt_service?: any, opt_flow?: undefined.ControlFlow): this;
    constructor(opt_config?: firefox$Options, opt_service?: any, opt_flow?: undefined.ControlFlow): this
}

declare interface chrome$IOptionsValues {
    args: string[],
        binary?: string,
        detach: boolean,
        extensions: string[],
        localState?: any,
        logFile?: string,
        prefs?: any
}

declare interface chrome$IPerfLoggingPrefs {
    enableNetwork: boolean,
        enablePage: boolean,
        enableTimeline: boolean,
        tracingCategories: string,
        bufferUsageReportingInterval: number
}


/**
 * Class for managing ChromeDriver specific options.
 */
declare class Options {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities
     * object.
     * @param  The capabilities object.
     * @return  The ChromeDriver options.
     */
    fromCapabilities(capabilities: webdriver$Capabilities): chrome$Options;

    /**
     * Add additional command line arguments to use when launching the Chrome
     * browser.  Each argument may be specified with or without the "--" prefix
    (e.g. "--foo" and "foo"). Arguments with an associated value should be
    delimited by an "=": "foo=bar".
     * @param  The arguments to add.
     * @return  A self reference.
    */
    addArguments(...var_args: string[]): chrome$Options;

    /**
     * List of Chrome command line switches to exclude that ChromeDriver by default
     * passes when starting Chrome.  Do not prefix switches with "--".
     * @param  The switches to exclude.
     * @return  A self reference.
     */
    excludeSwitches(...var_args: string[]): chrome$Options;

    /**
     * Add additional extensions to install when launching Chrome. Each extension
     * should be specified as the path to the packed CRX file, or a Buffer for an
    extension.
     * @param  The
    extensions to add.
     * @return  A self reference.
    */
    addExtensions(...var_args: any[]): chrome$Options;

    /**
     * Sets the path to the Chrome binary to use. On Mac OS X, this path should
     * reference the actual Chrome executable, not just the application binary
    (e.g. "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome").

    The binary path be absolute or relative to the chromedriver server
    executable, but it must exist on the machine that will launch Chrome.
     * @param  The path to the Chrome binary to use.
     * @return  A self reference.
    */
    setChromeBinaryPath(path: string): chrome$Options;

    /**
     * Sets whether to leave the started Chrome browser running if the controlling
     * ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is
    called.
     * @param  Whether to leave the browser running if the
    chromedriver service is killed before the session.
     * @return  A self reference.
    */
    detachDriver(detach: boolean): chrome$Options;

    /**
     * Sets the user preferences for Chrome's user profile. See the "Preferences"
     * file in Chrome's user data directory for examples.
     * @param  Dictionary of user preferences to use.
     * @return  A self reference.
     */
    setUserPreferences(prefs: any): chrome$Options;

    /**
     * Sets the logging preferences for the new session.
     * @param  The logging preferences.
     * @return  A self reference.
     */
    setLoggingPrefs(prefs: undefined.Preferences): chrome$Options;

    /**
     * Sets the performance logging preferences. Options include:
     * 
    - `enableNetwork`: Whether or not to collect events from Network domain.
    - `enablePage`: Whether or not to collect events from Page domain.
    - `enableTimeline`: Whether or not to collect events from Timeline domain.
         Note: when tracing is enabled, Timeline domain is implicitly disabled,
         unless `enableTimeline` is explicitly set to true.
    - `tracingCategories`: A comma-separated string of Chrome tracing categories
         for which trace events should be collected. An unspecified or empty
         string disables tracing.
    - `bufferUsageReportingInterval`: The requested number of milliseconds
         between DevTools trace buffer usage events. For example, if 1000, then
         once per second, DevTools will report how full the trace buffer is. If a
         report indicates the buffer usage is 100%, a warning will be issued.enablePage: boolean,
    enableTimeline: boolean,
    tracingCategories: string,
    bufferUsageReportingInterval: number}} prefs The performance
    logging preferences.
     * @return  A self reference.
    */
    setPerfLoggingPrefs(prefs: chrome$IPerfLoggingPrefs): chrome$Options;

    /**
     * Sets preferences for the "Local State" file in Chrome's user data
     * directory.
     * @param  Dictionary of local state preferences.
     * @return  A self reference.
     */
    setLocalState(state: any): chrome$Options;

    /**
     * Sets the name of the activity hosting a Chrome-based Android WebView. This
     * option must be set to connect to an [Android WebView](
    https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)
     * @param  The activity name.
     * @return  A self reference.
    */
    androidActivity(name: string): chrome$Options;

    /**
     * Sets the device serial number to connect to via ADB. If not specified, the
     * ChromeDriver will select an unused device at random. An error will be
    returned if all devices already have active sessions.
     * @param  The device serial number to connect to.
     * @return  A self reference.
    */
    androidDeviceSerial(serial: string): chrome$Options;

    /**
     * Configures the ChromeDriver to launch Chrome on Android via adb. This
     * function is shorthand for
    {
     * @link  #androidPackage options.androidPackage('com.android.chrome')}.
     * @return  A self reference.
    */
    androidChrome(): chrome$Options;

    /**
     * Sets the package name of the Chrome or WebView app.
     * @param  The package to connect to, or `null` to disable Android
    and switch back to using desktop Chrome.
     * @return  A self reference.
    */
    androidPackage(pkg: string): chrome$Options;

    /**
     * Sets the process name of the Activity hosting the WebView (as given by `ps`).
     * If not specified, the process name is assumed to be the same as
    {
     * @link  #androidPackage}.
     * @param  The main activity name.
     * @return  A self reference.
    */
    androidProcess(processName: string): chrome$Options;

    /**
     * Sets whether to connect to an already-running instead of the specified
     * {
     * @linkplain  #androidProcess app} instead of launching the app with a clean
    data directory.
     * @param  Whether to connect to a running instance.
     * @return  A self reference.
    */
    androidUseRunningApp(useRunning: boolean): chrome$Options;

    /**
     * Sets the path to Chrome's log file. This path should exist on the machine
     * that will launch Chrome.
     * @param  Path to the log file to use.
     * @return  A self reference.
     */
    setChromeLogFile(path: string): chrome$Options;

    /**
     * Sets the proxy settings for the new session.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): chrome$Options;

    /**
     * Converts this options instance to a {@link webdriver.Capabilities} object.
     * @param  The capabilities to merge
    these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities?: webdriver$Capabilities): webdriver$Capabilities;

    /**
     * Converts this instance to its JSON wire protocol representation. Note this
     * function is an implementation not intended for general use.
     * @return  Array.<string>,
    binary: (string|undefined),
    detach: boolean,
    extensions: !Array.<string>,
    localState: (Object|undefined),
    logFile: (string|undefined),
    prefs: (Object|undefined)}} The JSON wire protocol representation
    of this instance.
    */
    toJSON(): chrome$IOptionsValues
}


/**
 * Creates {@link remote.DriverService} instances that manage a ChromeDriver
 * server.
 */
declare class ServiceBuilder {

    /**
     * 
     * @param  Path to the server executable to use. If omitted,
    the builder will attempt to locate the chromedriver on the current
    PATH.
     * @throws  {Error} If provided executable does not exist, or the chromedriver
    cannot be found on the PATH.
     * @constructor  
    */
    constructor(opt_exe?: string): this;

    /**
     * Sets the port to start the ChromeDriver on.
     * @param  The port to use, or 0 for any free port.
     * @return  A self reference.
     * @throws  {Error} If the port is invalid.
     */
    usingPort(port: number): chrome$ServiceBuilder;

    /**
     * Sets which port adb is listening to. _The ChromeDriver will connect to adb
     * if an {@linkplain Options#androidPackage Android session} is requested, but
    adb *must* be started beforehand._
     * @param  Which port adb is running on.
     * @return  A self reference.
    */
    setAdbPort(port: number): chrome$ServiceBuilder;

    /**
     * Sets the path of the log file the driver should log to. If a log file is
     * not specified, the driver will log to stderr.
     * @param  Path of the log file to use.
     * @return  A self reference.
     */
    loggingTo(path: string): chrome$ServiceBuilder;

    /**
     * Enables verbose logging.
     * @return  A self reference.
     */
    enableVerboseLogging(): chrome$ServiceBuilder;

    /**
     * Sets the number of threads the driver should use to manage HTTP requests.
     * By default, the driver will use 4 threads.
     * @param  The number of threads to use.
     * @return  A self reference.
     */
    setNumHttpThreads(n: number): chrome$ServiceBuilder;

    /**
     * Sets the base path for WebDriver REST commands (e.g. "/wd/hub").
     * By default, the driver will accept commands relative to "/".
     * @param  The base path to use.
     * @return  A self reference.
     */
    setUrlBasePath(path: string): chrome$ServiceBuilder;

    /**
     * Defines the stdio configuration for the driver service. See
     * {>)} config The
      configuration to use.
     * @code  child_process.spawn} for more information.
     * @return  A self reference.
    */
    setStdio(config: string): chrome$ServiceBuilder;
    setStdio(config: any[]): chrome$ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be
     * inherited by every browser session started by the server.
     * @param  The environment to use.
     * @return  A self reference.
     */
    withEnvironment(env: {
        [key: string]: string
    }): chrome$ServiceBuilder;

    /**
     * Creates a new DriverService using this instance's current configuration.
     * @return  A new driver service using this instance's
    current configuration.
     * @throws  {Error} If the driver exectuable was not specified and a default
    could not be found on the current PATH.
    */
    build(): any
}


/**
 * Returns the default ChromeDriver service. If such a service has not been
 * configured, one will be constructed using the default configuration for
a ChromeDriver executable found on the system PATH.
 * @return  The default ChromeDriver service.
*/
declare function chrome$getDefaultService(): any


/**
 * Sets the default service to use for new ChromeDriver instances.
 * @param  The service to use.
 * @throws  {Error} If the default service is currently running.
 */
declare function chrome$setDefaultService(service: any): void
/**
 * Manages a Firefox subprocess configured for use with WebDriver.
 */
declare class Binary {

    /**
     * 
     * @param  Path to the Firefox binary to use. If not
    specified, will attempt to locate Firefox on the current system.
     * @constructor  
    */
    constructor(opt_exe?: string): this;

    /**
     * Add arguments to the command line used to start Firefox.
     * @param  Either the arguments to add as
    varargs, or the arguments as an array.
    */
    addArguments(...var_args: string[]): void;

    /**
     * Launches Firefox and eturns a promise that will be fulfilled when the process
     * terminates.
     * @param  Path to the profile directory to use.
     * @return  A promise for the process result.
     * @throws  {Error} If this instance has already been started.
     */
    launch(profile: string): undefined.Promise<any>;

    /**
     * Kills the managed Firefox process.
     * @return  A promise for when the process has terminated.
     */
    kill(): undefined.Promise<void >
}


/**
 * A WebDriver client for Firefox.
 * @extends  {webdriver.WebDriver}
 */
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The
    configuration options for this driver, specified as either an
    {
     * @link  Options} or {
     * @link  webdriver.Capabilities}, or as a raw hash
    object.
     * @param  The flow to
    schedule commands through. Defaults to the active flow object.
     * @constructor  
    */
    constructor(opt_config?: webdriver$Capabilities, opt_flow?: undefined.ControlFlow): this;
    constructor(opt_config?: any, opt_flow?: undefined.ControlFlow): this
}


/**
 * Configuration options for the FirefoxDriver.
 */
declare class Options {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Sets the profile to use. The profile may be specified as a
     * {
     * @link  Profile} object or as the path to an existing Firefox profile to use
    as a template.
     * @param  The profile to use.
     * @return  A self reference.
    */
    setProfile(profile: string): firefox$Options;
    setProfile(profile: firefox$Profile): firefox$Options;

    /**
     * Sets the binary to use. The binary may be specified as the path to a Firefox
     * executable, or as a {@link Binary} object.
     * @param  The binary to use.
     * @return  A self reference.
     */
    setBinary(binary: string): firefox$Options;
    setBinary(binary: firefox$Binary): firefox$Options;

    /**
     * Sets the logging preferences for the new session.
     * @param  The logging preferences.
     * @return  A self reference.
     */
    setLoggingPreferences(prefs: undefined.Preferences): firefox$Options;

    /**
     * Sets the proxy to use.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): firefox$Options;

    /**
     * Converts these options to a {@link webdriver.Capabilities} instance.
     * @return  A new capabilities object.
     */
    toCapabilities(opt_remote?: any): webdriver$Capabilities
}


/**
 * Models a Firefox proifle directory for use with the FirefoxDriver. The
 * {
 * @code  Proifle} directory uses an in-memory model until {
 * @link  #writeToDisk}
is called.
*/
declare class Profile {

    /**
     * 
     * @param  Path to an existing Firefox profile directory to
    use a template for this profile. If not specified, a blank profile will
    be used.
     * @constructor  
    */
    constructor(opt_dir?: string): this;

    /**
     * Registers an extension to be included with this profile.
     * @param  Path to the extension to include, as either an
    unpacked extension directory or the path to a xpi file.
    */
    addExtension(extension: string): void;

    /**
     * Sets a desired preference for this profile.
     * @param  The preference key.
     * @param  The preference value.
     * @throws  {Error} If attempting to set a frozen preference.
     */
    setPreference(key: string, value: string): void;
    setPreference(key: string, value: number): void;
    setPreference(key: string, value: boolean): void;

    /**
     * Returns the currently configured value of a profile preference. This does
     * not include any defaults defined in the profile's template directory user.js
    file (if a template were specified on construction).
     * @param  The desired preference.
     * @return  The current value of the
    requested preference.
    */
    getPreference(key: string): any;

    /**
     * 
     * @return  The port this profile is currently configured to use, or
    0 if the port will be selected at random when the profile is written
    to disk.
    */
    getPort(): number;

    /**
     * Sets the port to use for the WebDriver extension loaded by this profile.
     * @param  The desired port, or 0 to use any free port.
     */
    setPort(port: number): void;

    /**
     * 
     * @return  Whether the FirefoxDriver is configured to automatically
    accept untrusted SSL certificates.
    */
    acceptUntrustedCerts(): boolean;

    /**
     * Sets whether the FirefoxDriver should automatically accept untrusted SSL
     * certificates.
     * @param  .
     */
    setAcceptUntrustedCerts(value: boolean): void;

    /**
     * Sets whether to assume untrusted certificates come from untrusted issuers.
     * @param  .
     */
    setAssumeUntrustedCertIssuer(value: boolean): void;

    /**
     * 
     * @return  Whether to assume untrusted certs come from untrusted
    issuers.
    */
    assumeUntrustedCertIssuer(): boolean;

    /**
     * Sets whether to use native events with this profile.
     * @param  .
     */
    setNativeEventsEnabled(enabled: boolean): void;

    /**
     * Returns whether native events are enabled in this profile.
     * @return  .
     */
    nativeEventsEnabled(): boolean;

    /**
     * Writes this profile to disk.
     * @param  Whether to exclude the WebDriver
    extension from the generated profile. Used to reduce the size of an
    {
     * @link  #encode() encoded profile} since the server will always install
    the extension itself.
     * @return  A promise for the path to the new
    profile directory.
    */
    writeToDisk(opt_excludeWebDriverExt?: boolean): undefined.Promise<string>;

    /**
     * Encodes this profile as a zipped, base64 encoded directory.
     * @return  A promise for the encoded profile.
     */
    encode(): undefined.Promise<string >
}
declare var npm$namespace$executors: {
        createExecutor: typeof executors$createExecutor,
    }
    /**
     * Creates a command executor that uses WebDriver's JSON wire protocol.
     * @param url The server's URL, or a promise that will resolve to that URL.
     * @returns  The new command executor.
     */
declare function executors$createExecutor(url: string): webdriver$CommandExecutordeclare interface error$IErrorCode {
    SUCCESS: number,
        NO_SUCH_ELEMENT: number,
        NO_SUCH_FRAME: number,
        UNKNOWN_COMMAND: number,
        UNSUPPORTED_OPERATION: number,
        STALE_ELEMENT_REFERENCE: number,
        ELEMENT_NOT_VISIBLE: number,
        INVALID_ELEMENT_STATE: number,
        UNKNOWN_ERROR: number,
        ELEMENT_NOT_SELECTABLE: number,
        JAVASCRIPT_ERROR: number,
        XPATH_LOOKUP_ERROR: number,
        TIMEOUT: number,
        NO_SUCH_WINDOW: number,
        INVALID_COOKIE_DOMAIN: number,
        UNABLE_TO_SET_COOKIE: number,
        MODAL_DIALOG_OPENED: number,
        UNEXPECTED_ALERT_OPEN: number,
        NO_SUCH_ALERT: number,
        NO_MODAL_DIALOG_OPEN: number,
        SCRIPT_TIMEOUT: number,
        INVALID_ELEMENT_COORDINATES: number,
        IME_NOT_AVAILABLE: number,
        IME_ENGINE_ACTIVATION_FAILED: number,
        INVALID_SELECTOR_ERROR: number,
        SESSION_NOT_CREATED: number,
        MOVE_TARGET_OUT_OF_BOUNDS: number,
        SQL_DATABASE_ERROR: number,
        INVALID_XPATH_SELECTOR: number,
        INVALID_XPATH_SELECTOR_RETURN_TYPE: number,
        METHOD_NOT_ALLOWED: number
}

declare var ErrorCode: error$IErrorCode;


/**
 * Error extension that includes error status codes from the WebDriver wire
 * protocol:
http://code.google.com/p/selenium/wiki/JsonWireProtocol#Response_Status_Codes
 * @extends  {Error}
*/
declare class Error {

    /**
     * 
     * @param  The error's status code.
     * @param  Optional error message.
     * @constructor  
     */
    constructor(code: number, opt_message?: string): this;

    /**
     * Status strings enumerated in the W3C WebDriver working draft.
     * @enum  {string}
     * @see  http://www.w3.org/TR/webdriver/#status-codes
     */
    State: {
        ELEMENT_NOT_SELECTABLE: string,
        ELEMENT_NOT_VISIBLE: string,
        IME_ENGINE_ACTIVATION_FAILED: string,
        IME_NOT_AVAILABLE: string,
        INVALID_COOKIE_DOMAIN: string,
        INVALID_ELEMENT_COORDINATES: string,
        INVALID_ELEMENT_STATE: string,
        INVALID_SELECTOR: string,
        JAVASCRIPT_ERROR: string,
        MOVE_TARGET_OUT_OF_BOUNDS: string,
        NO_SUCH_ALERT: string,
        NO_SUCH_DOM: string,
        NO_SUCH_ELEMENT: string,
        NO_SUCH_FRAME: string,
        NO_SUCH_WINDOW: string,
        SCRIPT_TIMEOUT: string,
        SESSION_NOT_CREATED: string,
        STALE_ELEMENT_REFERENCE: string,
        SUCCESS: string,
        TIMEOUT: string,
        UNABLE_TO_SET_COOKIE: string,
        UNEXPECTED_ALERT_OPEN: string,
        UNKNOWN_COMMAND: string,
        UNKNOWN_ERROR: string,
        UNSUPPORTED_OPERATION: string
    };

    /**
     * This error's status code.
     * @type  
     */
    code: number;

    /**
     * 
     * @type  
     */
    state: string;

    /**
     * 
     * @override  
     */
    message: string;

    /**
     * 
     * @override  
     */
    name: string;

    /**
     * 
     * @override  
     */
    stack: string;

    /**
     * Flag used for duck-typing when this code is embedded in a Firefox extension.
     * This is required since an Error thrown in one component and then reported
    to another will fail instanceof checks in the second component.
     * @type  
    */
    isAutomationError: boolean;

    /**
     * 
     * @return  The string representation of this error. 
     */
    toString(): string
}


declare var npm$namespace$logging: {
        getLevel: typeof logging$getLevel,
    }
    /**
     * A hash describing log preferences.
     * @typedef  
     */
declare class Preferences {
    setLevel(type: string, level: logging$ILevel): void;
    toJSON(): {
        [key: string]: string
    }
}

declare interface logging$IType {

    /**
     * Logs originating from the browser. 
     */
    BROWSER: string,

        /**
         * Logs from a WebDriver client. 
         */
        CLIENT: string,

        /**
         * Logs from a WebDriver implementation. 
         */
        DRIVER: string,

        /**
         * Logs related to performance. 
         */
        PERFORMANCE: string,

        /**
         * Logs from the remote server. 
         */
        SERVER: string
}

declare var Type: logging$IType;


/**
 * Logging levels.
 * @enum  {{value: number, name: webdriver.logging.LevelName}}
 */
declare interface logging$ILevel {
    value: number,
        name: string
}

declare interface logging$ILevelValues {
    ALL: logging$ILevel,
        DEBUG: logging$ILevel,
        INFO: logging$ILevel,
        WARNING: logging$ILevel,
        SEVERE: logging$ILevel,
        OFF: logging$ILevel
}

declare var Level: logging$ILevelValues;


/**
 * Converts a level name or value to a {@link webdriver.logging.Level} value.
 * If the name/value is not recognized, {@link webdriver.logging.Level.ALL}
will be returned.
 * @param  The log level name, or value, to
convert .
 * @return  The converted level.
*/
declare function logging$getLevel(nameOrValue: string): logging$ILevel

declare interface logging$IEntryJSON {
    level: string,
        message: string,
        timestamp: number,
        type: string
}


/**
 * A single log entry.
 */
declare class Entry {

    /**
     * 
     * @param  The entry level.
     * @param  The log message.
     * @param  The time this entry was generated, in
    milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
    current time will be used.
     * @param  The log type, if known.
     * @constructor  
    */
    constructor(level: logging$ILevel, message: string, opt_timestamp?: number, opt_type?: string): this;
    constructor(level: string, message: string, opt_timestamp?: number, opt_type?: string): this;

    /**
     * 
     * @type  
     */
    level: logging$ILevel;

    /**
     * 
     * @type  
     */
    message: string;

    /**
     * 
     * @type  
     */
    timestamp: number;

    /**
     * 
     * @type  
     */
    type: string;

    /**
     * Converts a {@link goog.debug.LogRecord} into a
     * {
     * @link  webdriver.logging.Entry}.
     * @param  The record to convert.
     * @param  The log type.
     * @return  The converted entry.
     */
    fromClosureLogRecord(logRecord: any, opt_type?: string): logging$Entry;

    /**
     * 
     * @return  *           type: string}} The JSON representation of this entry.
     */
    toJSON(): logging$IEntryJSON
}


declare var npm$namespace$promise: {
        all: typeof promise$all,
        asap: typeof promise$asap,
        controlFlow: typeof promise$controlFlow,
        createFlow: typeof promise$createFlow,
        isPromise: typeof promise$isPromise,
        isGenerator: typeof promise$isGenerator,
        delayed: typeof promise$delayed,
        filter: typeof promise$filter,
        defer: typeof promise$defer,
        fulfilled: typeof promise$fulfilled,
        map: typeof promise$map,
        rejected: typeof promise$rejected,
        checkedNodeCall: typeof promise$checkedNodeCall,
        consume: typeof promise$consume,
        when: typeof promise$when,
        fullyResolved: typeof promise$fullyResolved,
        setDefaultFlow: typeof promise$setDefaultFlow,
    }
    /**
     * Given an array of promises, will return a promise that will be fulfilled
     * with the fulfillment values of the input array's values. If any of the
    input array's promises are rejected, the returned promise will be rejected
    with the same reason.
     * @param  An array of
    promises to wait on.
     * @return  A promise that is
    fulfilled with an array containing the fulfilled values of the
    input array, or rejected with the same reason as the first
    rejected value.
     * @template  
    */
declare function promise$all(arr: promise$Promise<any>[]): promise$Promise<any[] >


    /**
     * Invokes the appropriate callback function as soon as a promised
     * {
     * @code  value} is resolved. This function is similar to
    {
     * @link  webdriver.promise.when}, except it does not return a new promise.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
    */
    declare function promise$asap(value: any, callback: Function, opt_errback?: Function): void


/**
 * 
 * @return  The currently active control flow.
 */
declare function promise$controlFlow(): promise$ControlFlow


/**
 * Creates a new control flow. The provided callback will be invoked as the
 * first task within the new flow, with the flow as its sole argument. Returns
a promise that resolves to the callback result.
 * @param  The entry point
to the newly created flow.
 * @return  A promise that resolves to the callback
result.
*/
declare function promise$createFlow<R>(callback: (flow: promise$ControlFlow) => R): promise$Promise<R >


    /**
     * Determines whether a {@code value} should be treated as a promise.
     * Any object whose "then" property is a function will be considered a promise.
     * @param  The value to test.
     * @return  Whether the value is a promise.
     */
    declare function promise$isPromise(value: any): boolean


/**
 * Tests is a function is a generator.
 * @param  The function to test.
 * @return  Whether the function is a generator.
 */
declare function promise$isGenerator(fn: Function): boolean


/**
 * Creates a promise that will be resolved at a set time in the future.
 * @param  The amount of time, in milliseconds, to wait before
resolving the promise.
 * @return  The promise.
*/
declare function promise$delayed(ms: number): promise$Promise<void >


    /**
     * Calls a function for each element in an array, and if the function returns
     * true adds the element to a new array.

    <p>If the return value of the filter function is a promise, this function
    will wait for it to be fulfilled before determining whether to insert the
    element into the new array.

    <p>If the filter function throws or returns a rejected promise, the promise
    returned by this function will be rejected with the same reason. Only the
    first failure will be reported; all subsequent errors will be silently
    ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  |webdriver.promise.Promise.<boolean>)} fn The function
    to call for each element in the array.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$filter<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): promise$Promise<T[] >


    /**
     * Creates a new deferred object.
     * @return  The new deferred object.
     */
    declare function promise$defer<T>(): promise$Deferred<T >


    /**
     * Creates a promise that has been resolved with the given value.*=} opt_value The resolved value.
     * @return  The resolved promise.
     */
    declare function promise$fulfilled<T>(opt_value?: T): promise$Promise<T >


    /**
     * Calls a function for each element in an array and inserts the result into a
     * new array, which is used as the fulfillment value of the promise returned
    by this function.

    <p>If the return value of the mapping function is a promise, this function
    will wait for it to be fulfilled before inserting it into the new array.

    <p>If the mapping function throws or returns a rejected promise, the
    promise returned by this function will be rejected with the same reason.
    Only the first failure will be reported; all subsequent errors will be
    silently ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  The
    function to call for each element in the array. This function should
    expect three arguments (the element, the index, and the array itself.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$map<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): promise$Promise<T[] >


    /**
     * Creates a promise that has been rejected with the given reason.*=} opt_reason The rejection reason; may be any value, but is
     *     usually an Error or a string.
     * @return  The rejected promise.
     */
    declare function promise$rejected(opt_reason?: any): promise$Promise<void >


    /**
     * Wraps a function that is assumed to be a node-style callback as its final
     * argument. This callback takes two arguments: an error value (which will be
    null if the call succeeded), and the success value as the second argument.
    If the call fails, the returned promise will be rejected, otherwise it will
    be resolved with the result.
     * @param  The function to wrap.
     * @return  A promise that will be resolved with the
    result of the provided function's callback.
    */
    declare function promise$checkedNodeCall<T>(fn: Function, ...var_args: any[]): promise$Promise<T >


    /**
     * Consumes a {@code GeneratorFunction}. Each time the generator yields a
     * promise, this function will wait for it to be fulfilled before feeding the
    fulfilled value back into {@code next}. Likewise, if a yielded promise is
    rejected, the rejection error will be passed to {@code throw}.

    <p>Example 1: the Fibonacci Sequence.
    <pre><code>
    webdriver.promise.consume(function fibonacci() {
       var n1 = 1, n2 = 1;
       for (var i = 0; i<4; ++i) {
         var tmp = yield n1 + n2;
         n1 = n2;
         n2 = tmp;
       }
       return n1 + n2;
    }).then(function(result) {
       console.log(result);  // 13
    });
    </code></pre>

    <p>Example 2: a generator that throws.
    <pre><code>
    webdriver.promise.consume(function () {
       yield webdriver.promise.delayed(250).then(function() {
         throw Error('boom');
       });
    }).thenCatch(function(e) {
       console.log(e.toString());  // Error: boom
    });
    </code></pre>
     * @param  The generator function to execute.
     * @param  The object to use as "this" when invoking the
    initial generator.
     * @param  Any arguments to pass to the initial generator.
     * @return  A promise that will resolve to the
    generator's final result.
     * @throws  {TypeError} If the given function is not a generator.
    */
    declare function promise$consume<T>(
        generatorFn: Function,
        opt_self?: any,
        ...var_args: any[]): promise$Promise<T >


    /**
     * Registers an observer on a promised {@code value}, returning a new promise
     * that will be resolved when the value is. If {@code value} is not a promise,
    then the return promise will be immediately resolved.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
     * @return  A new promise.
    */
    declare function promise$when<T, R>(
        value: T,
        opt_callback?: (value: T) => any,
        opt_errback?: (error: any) => any): promise$Promise<R >


    /**
     * Returns a promise that will be resolved with the input value in a
     * fully-resolved state. If the value is an array, each element will be fully
    resolved. Likewise, if the value is an object, all keys will be fully
    resolved. In both cases, all nested arrays and objects will also be
    fully resolved.  All fields are resolved in place; the returned promise will
    resolve on {@code value} and not a copy.

    Warning: This function makes no checks against objects that contain
    cyclical references:

       var value = {};
       value['self'] = value;
       webdriver.promise.fullyResolved(value);  // Stack overflow.
     * @param  The value to fully resolve.
     * @return  A promise for a fully resolved version
    of the input value.
    */
    declare function promise$fullyResolved<T>(value: any): promise$Promise<T >


    /**
     * Changes the default flow to use when no others are active.
     * @param  The new default flow.
     * @throws  {Error} If the default flow is not currently active.
     */
    declare function promise$setDefaultFlow(flow: promise$ControlFlow): void


/**
 * Error used when the computation of a promise is cancelled.
 * @extends  {goog.debug.Error}
 * @final  
 */
declare class CancellationError {

    /**
     * 
     * @param  The cancellation message.
     * @constructor  
     */
    constructor(opt_msg?: string): this;
    name: string;
    message: string
}

declare interface promise$IThenable<T>{

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process. This method is a no-op if the promise has alreayd been resolved.
     * @param  The reason this promise is being cancelled.
     */
    cancel(opt_reason?: string): void,

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean,

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => promise$Promise<R>,
        opt_errback?: (error: any) => any): promise$Promise<R>,

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => R,
        opt_errback?: (error: any) => any): promise$Promise<R>,

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): promise$Promise<R>,

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: () => any): promise$Promise<R >
}


/**
 * Thenable is a promise-like object with a {@code then} method which may be
 * used to schedule callbacks on a promised value.
 * @interface  * 
 * @template  
 */
declare class Thenable<T>mixins IThenable<T>{

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process. This method is a no-op if the promise has alreayd been resolved.
     * @param  The reason this promise is being cancelled.
     */
    cancel(opt_reason?: string): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => promise$Promise<R>,
        opt_errback?: (error: any) => any): promise$Promise<R>;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => R,
        opt_errback?: (error: any) => any): promise$Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): promise$Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: () => any): promise$Promise<R>;

    /**
     * Adds a property to a class prototype to allow runtime checks of whether
     * instances of that class implement the Thenable interface. This function will
    also ensure the prototype's {@code then} function is exported from compiled
    code.
     * @param  The
    constructor whose prototype to modify.
    */
    addImplementation(ctor: Function): void;

    /**
     * Checks if an object has been tagged for implementing the Thenable interface
     * as defined by {@link webdriver.promise.Thenable.addImplementation}.
     * @param  The object to test.
     * @return  Whether the object is an implementation of the Thenable
    interface.
    */
    isImplementation(object: any): boolean
}

declare interface promise$IFulfilledCallback<T>{
    (value: T | promise$IThenable<T>| promise$Thenable<T>| void): void
}

declare interface promise$IRejectedCallback {
    (reason: any): void
}


/**
 * Represents the eventual value of a completed operation. Each promise may be
 * in one of three states: pending, fulfilled, or rejected. Each promise starts
in the pending state and may make a single transition to either a
fulfilled or rejected state, at which point the promise is considered
resolved.
 * @implements  {promise.Thenable<T>}
 * @template  * 
 * @see  http://promises-aplus.github.io/promises-spec/
*/
declare class Promise<T>mixins IThenable<T>{

    /**
     * 
     * @param  Function that is invoked immediately to begin computation of this
    promise's value. The function should accept a pair of callback functions,
    one for fulfilling the promise and another for rejecting it.
     * @param  The control flow
    this instance was created under. Defaults to the currently active flow.
     * @constructor  
    */
    constructor(resolver: (
        onFulfilled: promise$IFulfilledCallback<T>,
        onRejected: promise$IRejectedCallback) => void, opt_flow?: promise$ControlFlow): this;
    constructor(): this;

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process.
     * @param  The reason this promise is being cancelled. If not an
    {
     * @code  Error}, one will be created using the value's string
    representation.
    */
    cancel(reason: any): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved. This function most
     * overridden by subtypes.
     * @param opt_callback The function to call if this promise is
    successfully resolved. The function should expect a single argument: the
    promise's resolved value.
     * @param opt_errback The function to call if this promise is
    rejected. The function should expect a single argument: the rejection
    reason.
     * @return  A new promise which will be resolved
    with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => promise$Promise<R>,
        opt_errback?: (error: any) => any): promise$Promise<R>;

    /**
     * Registers listeners for when this instance is resolved. This function most
     * overridden by subtypes.
     * @param opt_callback The function to call if this promise is
    successfully resolved. The function should expect a single argument: the
    promise's resolved value.
     * @param opt_errback The function to call if this promise is
    rejected. The function should expect a single argument: the rejection
    reason.
     * @return  A new promise which will be resolved
    with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: T) => R,
        opt_errback?: (error: any) => any): promise$Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): promise$Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: () => any): promise$Promise<R >
}


/**
 * Represents a value that will be resolved at some point in the future. This
 * class represents the protected "producer" half of a Promise - each Deferred
has a {@code promise} property that may be returned to consumers for
registering callbacks, reserving the ability to resolve the deferred to the
producer.

<p>If this Deferred is rejected and there are no listeners registered before
the next turn of the event loop, the rejection will be passed to the
{
 * @link  webdriver.promise.ControlFlow} as an unhandled failure.

<p>If this Deferred is cancelled, the cancellation reason will be forward to
the Deferred's canceller function (if provided). The canceller may return a
truth-y value to override the reason provided for rejection.
 * @extends  {webdriver.promise.Promise}
*/
declare class Deferred<T>mixins Promise<T>{

    /**
     * 
     * @param  The control flow
    this instance was created under. This should only be provided during
    unit tests.
     * @constructor  
    */
    constructor(opt_flow?: promise$ControlFlow): this;
    State_: {
        BLOCKED: number,
        PENDING: number,
        REJECTED: number,
        RESOLVED: number
    };

    /**
     * The consumer promise for this instance. Provides protected access to the
     * callback registering functions.
     * @type  
     */
    promise: promise$Promise<T>;

    /**
     * Rejects this promise. If the error is itself a promise, this instance will
     * be chained to it and be rejected with the error's resolved value.*=} opt_error The rejection reason, typically either a
        {
     * @code  Error} or a {
     * @code  string}.
    */
    reject(opt_error?: any): void;
    errback(opt_error?: any): void;

    /**
     * Resolves this promise with the given value. If the value is itself a
     * promise and not a reference to this deferred, this instance will wait for
    it before resolving.*=} opt_value The resolved value.
    */
    fulfill(opt_value?: T): void;

    /**
     * Removes all of the listeners previously registered on this deferred.
     * @throws  {Error} If this deferred has already been resolved.
     */
    removeAll(): void
}

declare interface promise$IControlFlowTimer {
    clearInterval: (ms: number) => void,
        clearTimeout: (ms: number) => void,
        setInterval: (fn: Function, ms: number) => number,
        setTimeout: (fn: Function, ms: number) => number
}


/**
 * Handles the execution of scheduled tasks, each of which may be an
 * asynchronous operation. The control flow will ensure tasks are executed in
the ordered scheduled, starting each task only once those before it have
completed.

Each task scheduled within this flow may return a
{
 * @link  webdriver.promise.Promise} to indicate it is an asynchronous
operation. The ControlFlow will wait for such promises to be resolved before
marking the task as completed.

Tasks and each callback registered on a {
 * @link  webdriver.promise.Promise}
will be run in their own ControlFlow frame.  Any tasks scheduled within a
frame will take priority over previously scheduled tasks. Furthermore, if any
of the tasks in the frame fail, the remainder of the tasks in that frame will
be discarded and the failure will be propagated to the user through the
callback/task's promised result.

Each time a ControlFlow empties its task queue, it will fire an
{
 * @link  webdriver.promise.ControlFlow.EventType.IDLE IDLE} event. Conversely,
whenever the flow terminates due to an unhandled error, it will remove all
remaining tasks in its queue and fire an
{
 * @link  webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION
UNCAUGHT_EXCEPTION} event. If there are no listeners registered with the
flow, the error will be rethrown to the global error handler.
 * @extends  {EventEmitter}
 * @final  
*/
declare class ControlFlow mixins EventEmitter {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Events that may be emitted by an {@link webdriver.promise.ControlFlow}.
     * @enum  {string}
     */
    EventType: {

        /**
         * Emitted when all tasks have been successfully executed. 
         */
        IDLE: string,

        /**
         * Emitted when a ControlFlow has been reset. 
         */
        RESET: string,

        /**
         * Emitted whenever a new task has been scheduled. 
         */
        SCHEDULE_TASK: string,

        /**
         * Emitted whenever a control flow aborts due to an unhandled promise
         * rejection. This event will be emitted along with the offending rejection
        reason. Upon emitting this event, the control flow will empty its task
        queue and revert to its initial state.
        */
        UNCAUGHT_EXCEPTION: string
    };

    /**
     * Returns a string representation of this control flow, which is its current
     * {
     * @link  #getSchedule() schedule}, sans task stack traces.
     * @return  The string representation of this contorl flow.
     * @override  
     */
    toString(): string;

    /**
     * Resets this instance, clearing its queue and removing all event listeners.
     */
    reset(): void;

    /**
     * Generates an annotated string describing the internal state of this control
     * flow, including the currently executing as well as pending tasks. If
    {
     * @code  opt_includeStackTraces === true}, the string will include the
    stack trace from when each task was scheduled.
     * @param  Whether to include the stack traces
    from when each task was scheduled. Defaults to false.
     * @return  String representation of this flow's internal state.
    */
    getSchedule(opt_includeStackTraces?: boolean): string;

    /**
     * Schedules a task for execution. If there is nothing currently in the
     * queue, the task will be executed in the next turn of the event loop. If
    the task function is a generator, the task will be executed using
    {<T>)} fn The function to
      call to start the task. If the function returns a
      {
     * @link  webdriver.promise.consume}.
     * @link  webdriver.promise.Promise}, this instance will wait for it to be
    resolved before starting the next task.
     * @param  A description of the task.
     * @return  <T>} A promise that will be resolved
    with the result of the action.
     * @template  
    */
    execute<T>(
        fn: () => (T | promise$Promise<T>),
        opt_description?: string): promise$Promise<T>;

    /**
     * Inserts a {@code setTimeout} into the command queue. This is equivalent to
     * a thread sleep in a synchronous programming language.
     * @param  The timeout delay, in milliseconds.
     * @param  A description to accompany the timeout.
     * @return  A promise that will be resolved with
    the result of the action.
    */
    timeout(ms: number, opt_description?: string): promise$Promise<void>;

    /**
     * Schedules a task that shall wait for a condition to hold. Each condition
     * function may return any value, but it will always be evaluated as a boolean.

    Condition functions may schedule sub-tasks with this instance, however,
    their execution time will be factored into whether a wait has timed out.

    In the event a condition returns a Promise, the polling loop will wait for
    it to be resolved before evaluating whether the condition has been satisfied.
    The resolution time for a promise is factored into whether a wait has timed
    out.

    If the condition function throws, or returns a rejected promise, the
    wait task will fail.

    If the condition is defined as a promise, the flow will wait for it to
    settle. If the timeout expires before the promise settles, the promise
    returned by this function will be rejected.

    If this function is invoked with `timeout === 0`, or the timeout is omitted,
    the flow will wait indefinitely for the condition to be satisfied.<T>|function())} condition The condition to poll,
        or a promise to wait on.
     * @param  How long to wait, in milliseconds, for the
    condition to hold before timing out. If omitted, the flow will wait
    indefinitely.
     * @param  An optional error message to include if the
    wait times out; defaults to the empty string.
     * @return  <T>} A promise that will be fulfilled
    when the condition has been satisified. The promise shall be rejected if
    the wait times out waiting for the condition.
     * @throws  {TypeError} If condition is not a function or promise or if timeout
    is not a number >= 0.
     * @template  
    */
    wait<T>(
        condition: promise$Promise<T>| Function,
        opt_timeout?: number,
        opt_message?: string): promise$Promise<T >
}


declare var npm$namespace$stacktrace: {
        format: typeof stacktrace$format,
        get: typeof stacktrace$get,
    }
    /**
     * Class representing one stack frame.
     */
declare class Frame {

    /**
     * 
     * @param  Context object, empty in case of global
    functions or if the browser doesn't provide this information.
     * @param  Function name, empty in case of anonymous
    functions.
     * @param  Alias of the function if available. For
    example the function name will be 'c' and the alias will be 'b' if the
    function is defined as <code>a.b = function c() {};</code>.
     * @param  File path or URL including line number and
    optionally column number separated by colons.
     * @constructor  
    */
    constructor(context?: string, name?: string, alias?: string, path?: string): this;

    /**
     * 
     * @return  The function name or empty string if the function is
    anonymous and the object field which it's assigned to is unknown.
    */
    getName(): string;

    /**
     * 
     * @return  The url or empty string if it is unknown.
     */
    getUrl(): string;

    /**
     * 
     * @return  The line number if known or -1 if it is unknown.
     */
    getLine(): number;

    /**
     * 
     * @return  The column number if known and -1 if it is unknown.
     */
    getColumn(): number;

    /**
     * 
     * @return  Whether the stack frame contains an anonymous function.
     */
    isAnonymous(): boolean;

    /**
     * Converts this frame to its string representation using V8's stack trace
     * format: http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
     * @return  The string representation of this frame.
     * @override  
     */
    toString(): string
}


/**
 * Stores a snapshot of the stack trace at the time this instance was created.
 * The stack trace will always be adjusted to exclude this function call.
 */
declare class Snapshot {

    /**
     * 
     * @param  The number of frames to remove from the top of
    the generated stack trace.
     * @constructor  
    */
    constructor(opt_slice?: number): this;

    /**
     * 
     * @return  The parsed stack trace.
     */
    getStacktrace(): stacktrace$Frame[]
}


/**
 * Formats an error's stack trace.
 * @param  The error to format.
 * @return  The formatted error.
 */
declare function stacktrace$format(error: any): any


/**
 * Gets the native stack trace if available otherwise follows the call chain.
 * The generated trace will exclude all frames up to and including the call to
this function.
 * @return  The frames of the stack trace.
*/
declare function stacktrace$get(): stacktrace$Frame[]

declare var BROWSER_SUPPORTED: boolean;


declare var npm$namespace$until: {
        ableToSwitchToFrame: typeof until$ableToSwitchToFrame,
        alertIsPresent: typeof until$alertIsPresent,
        elementIsDisabled: typeof until$elementIsDisabled,
        elementIsEnabled: typeof until$elementIsEnabled,
        elementIsNotSelected: typeof until$elementIsNotSelected,
        elementIsNotVisible: typeof until$elementIsNotVisible,
        elementIsSelected: typeof until$elementIsSelected,
        elementIsVisible: typeof until$elementIsVisible,
        elementLocated: typeof until$elementLocated,
        elementTextContains: typeof until$elementTextContains,
        elementTextIs: typeof until$elementTextIs,
        elementTextMatches: typeof until$elementTextMatches,
        elementsLocated: typeof until$elementsLocated,
        stalenessOf: typeof until$stalenessOf,
        titleContains: typeof until$titleContains,
        titleIs: typeof until$titleIs,
        titleMatches: typeof until$titleMatches,
    }
    /**
     * Defines a condition to
     */
declare class Condition<T>{

    /**
     * 
     * @param  A descriptive error message. Should complete the
    sentence "Waiting [...]"
     * @param  The condition function to
    evaluate on each iteration of the wait loop.
     * @constructor  
    */
    constructor(message: string, fn: (webdriver: webdriver$WebDriver) => any): this;

    /**
     * 
     * @return  A description of this condition. 
     */
    description(): string;

    /**
     * 
     * @type  
     */
    fn(webdriver: webdriver$WebDriver): any
}


/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as:
<ol>
   <li>A numeric index into {@code window.frames} for the currently selected
       frame.
   <li>A {@link webdriver.WebElement}, which must reference a FRAME or IFRAME
       element on the current page.
   <li>A locator which may be used to first locate a FRAME or IFRAME on the
       current page before attempting to switch to it.
</ol>

<p>Upon successful resolution of this condition, the driver will be left
focused on the new frame.
 * @param  .Locator|webdriver.By.Hash|
function(!webdriver.WebDriver): !webdriver.WebElement)} frame
The frame identifier.
 * @return  A new condition.
*/
declare function until$ableToSwitchToFrame(
    frame: number |
    webdriver$WebElement |
    webdriver$Locator |
    By$Hash |
    ((webdriver: webdriver$WebDriver) => webdriver$WebElement)): until$Condition<boolean >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  The new condition.
     */
    declare function until$alertIsPresent(): until$Condition<webdriver$Alert >


    /**
     * Creates a condition that will wait for the given element to be disabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsDisabled(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be enabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsEnabled(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be deselected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsNotSelected(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be in the DOM,
     * yet not visible to the user.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsNotVisible(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be selected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsSelected(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to become visible.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsVisible(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will loop until an element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new condition.
    */
    declare function until$elementLocated(
    locator: webdriver$Locator | By$Hash | Function): until$Condition<webdriver$WebElement >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to contain the given
    substring.
     * @param  The element to test.
     * @param  The substring to search for.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextContains(element: webdriver$WebElement, substr: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match the given
    {
     * @code  text} exactly.
     * @param  The element to test.
     * @param  The expected text.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextIs(element: webdriver$WebElement, text: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match a regular
    expression.
     * @param  The element to test.
     * @param  The regular expression to test against.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextMatches(element: webdriver$WebElement, regex: RegExp): until$Condition<boolean >


    /**
     * Creates a condition that will loop until at least one element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new
    condition.
    */
    declare function until$elementsLocated(
    locator: webdriver$Locator | By$Hash | Function): until$Condition<webdriver$WebElement[] >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  The new condition.
    */
    declare function until$stalenessOf(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare function until$titleContains(substr: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  The new condition.
     */
    declare function until$titleIs(title: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given regular expression.
     * @param  The regular expression to test against.
     * @return  The new condition.
     */
    declare function until$titleMatches(regex: RegExp): until$Condition<boolean >

    declare interface webdriver$ILocation {
        x: number,
            y: number
    }

declare interface webdriver$ISize {
    width: number,
        height: number
}


/**
 * Enumeration of the buttons used in the advanced interactions API.
 * NOTE: A TypeScript enum was not used so that this class could be extended in Protractor.
 * @enum  {number}
 */
declare interface webdriver$IButton {
    LEFT: number,
        MIDDLE: number,
        RIGHT: number
}

declare var Button: webdriver$IButton;


/**
 * Representations of pressable keys that aren't text.  These are stored in
 * the Unicode PUA (Private Use Area) code points, 0xE000-0xF8FF.  Refer to
http://www.google.com.au/search?&q=unicode+pua&btnG=Search
 * @enum  {string}
*/
declare interface webdriver$IKey {
    NULL: string,
        CANCEL: string,
        HELP: string,
        BACK_SPACE: string,
        TAB: string,
        CLEAR: string,
        RETURN: string,
        ENTER: string,
        SHIFT: string,
        CONTROL: string,
        ALT: string,
        PAUSE: string,
        ESCAPE: string,
        SPACE: string,
        PAGE_UP: string,
        PAGE_DOWN: string,
        END: string,
        HOME: string,
        ARROW_LEFT: string,
        LEFT: string,
        ARROW_UP: string,
        UP: string,
        ARROW_RIGHT: string,
        RIGHT: string,
        ARROW_DOWN: string,
        DOWN: string,
        INSERT: string,
        DELETE: string,
        SEMICOLON: string,
        EQUALS: string,
        NUMPAD0: string,
        NUMPAD1: string,
        NUMPAD2: string,
        NUMPAD3: string,
        NUMPAD4: string,
        NUMPAD5: string,
        NUMPAD6: string,
        NUMPAD7: string,
        NUMPAD8: string,
        NUMPAD9: string,
        MULTIPLY: string,
        ADD: string,
        SEPARATOR: string,
        SUBTRACT: string,
        DECIMAL: string,
        DIVIDE: string,
        F1: string,
        F2: string,
        F3: string,
        F4: string,
        F5: string,
        F6: string,
        F7: string,
        F8: string,
        F9: string,
        F10: string,
        F11: string,
        F12: string,
        COMMAND: string,
        META: string,

        /**
         * Simulate pressing many keys at once in a "chord". Takes a sequence of
         * {
         * @link  webdriver.Key}s or strings, appends each of the values to a string,
        and adds the chord termination key ({
         * @link  webdriver.Key.NULL}) and returns
        the resultant string.

        Note: when the low-level webdriver key handlers see Keys.NULL, active
        modifier keys (CTRL/ALT/SHIFT/etc) release via a keyup event.
         * @param  The key sequence to concatenate.
         * @return  The null-terminated key sequence.
         * @see  http://code.google.com/p/webdriver/issues/detail?id=79
        */
        chord: (...var_args: string[]) => string
}

declare var Key: webdriver$IKey;


/**
 * Class for defining sequences of complex user interactions. Each sequence
 * will not be executed until {@link #perform} is called.

<p>Example:<pre><code>
   new webdriver.ActionSequence(driver).
       keyDown(webdriver.Key.SHIFT).
       click(element1).
       click(element2).
       dragAndDrop(element3, element4).
       keyUp(webdriver.Key.SHIFT).
       perform();
</pre></code>
*/
declare class ActionSequence {

    /**
     * 
     * @param  The driver instance to use.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Executes this action sequence.
     * @return  A promise that will be resolved once
    this sequence has completed.
    */
    perform(): undefined.Promise<void>;

    /**
     * Moves the mouse.  The location to move to may be specified in terms of the
     * mouse's current location, an offset relative to the top-left corner of an
    element, or an element (in which case the middle of the element is used).
     * @param  The
    location to drag to, as either another WebElement or an offset in pixels.
     * @param  An optional offset, in pixels.
    Defaults to (0, 0).
     * @return  A self reference.
    */
    mouseMove(
        location: webdriver$WebElement,
        opt_offset?: webdriver$ILocation): webdriver$ActionSequence;
    mouseMove(location: webdriver$ILocation): webdriver$ActionSequence;

    /**
     * Presses a mouse button. The mouse button will not be released until
     * {
     * @link  #mouseUp} is called, regardless of whether that call is made in this
    sequence or another. The behavior for out-of-order events (e.g. mouseDown,
    click) is undefined.

    <p>If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:
    <pre><code>sequence.mouseMove(element).mouseDown()</code></pre>

    <p>Warning: this method currently only supports the left mouse button. See
    http://code.google.com/p/selenium/issues/detail?id=4047
     * @param  Either
    the element to interact with or the button to click with.
    Defaults to {
     * @link  webdriver.Button.LEFT} if neither an element nor
    button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  webdriver.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    mouseDown(
        opt_elementOrButton?: webdriver$WebElement,
        opt_button?: number): webdriver$ActionSequence;
    mouseDown(opt_elementOrButton?: number): webdriver$ActionSequence;

    /**
     * Releases a mouse button. Behavior is undefined for calling this function
     * without a previous call to {@link #mouseDown}.

    <p>If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:
    <pre><code>sequence.mouseMove(element).mouseUp()</code></pre>

    <p>Warning: this method currently only supports the left mouse button. See
    http://code.google.com/p/selenium/issues/detail?id=4047
     * @param  Either
    the element to interact with or the button to click with.
    Defaults to {
     * @link  webdriver.Button.LEFT} if neither an element nor
    button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  webdriver.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    mouseUp(
        opt_elementOrButton?: webdriver$WebElement,
        opt_button?: number): webdriver$ActionSequence;
    mouseUp(opt_elementOrButton?: number): webdriver$ActionSequence;

    /**
     * Convenience function for performing a "drag and drop" manuever. The target
     * element may be moved to the location of another element, or by an offset (in
    pixels).
     * @param  The element to drag.
     * @param  The
    location to drag to, either as another WebElement or an offset in pixels.
     * @return  A self reference.
    */
    dragAndDrop(
        element: webdriver$WebElement,
        location: webdriver$WebElement): webdriver$ActionSequence;
    dragAndDrop(
        element: webdriver$WebElement,
        location: webdriver$ILocation): webdriver$ActionSequence;

    /**
     * Clicks a mouse button.
     * 
    <p>If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:
    <pre><code>sequence.mouseMove(element).click()</code></pre>
     * @param  Either
    the element to interact with or the button to click with.
    Defaults to {
     * @link  webdriver.Button.LEFT} if neither an element nor
    button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  webdriver.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    click(
        opt_elementOrButton?: webdriver$WebElement,
        opt_button?: number): webdriver$ActionSequence;
    click(opt_elementOrButton?: number): webdriver$ActionSequence;

    /**
     * Double-clicks a mouse button.
     * 
    <p>If an element is provided, the mouse will first be moved to the center of
    that element. This is equivalent to:
    <pre><code>sequence.mouseMove(element).doubleClick()</code></pre>

    <p>Warning: this method currently only supports the left mouse button. See
    http://code.google.com/p/selenium/issues/detail?id=4047
     * @param  Either
    the element to interact with or the button to click with.
    Defaults to {
     * @link  webdriver.Button.LEFT} if neither an element nor
    button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  webdriver.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    doubleClick(
        opt_elementOrButton?: webdriver$WebElement,
        opt_button?: number): webdriver$ActionSequence;
    doubleClick(opt_elementOrButton?: number): webdriver$ActionSequence;

    /**
     * Performs a modifier key press. The modifier key is <em>not released</em>
     * until {@link #keyUp} or {@link #sendKeys} is called. The key press will be
    targetted at the currently focused element.
     * @param  The modifier key to push. Must be one of
    {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    keyDown(key: string): webdriver$ActionSequence;

    /**
     * Performs a modifier key release. The release is targetted at the currently
     * focused element.
     * @param  The modifier key to release. Must be one of
    {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    keyUp(key: string): webdriver$ActionSequence;

    /**
     * Simulates typing multiple keys. Each modifier key encountered in the
     * sequence will not be released until it is encountered again. All key events
    will be targetted at the currently focused element.
     * @param  The keys to type.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    sendKeys(...var_args: any[]): webdriver$ActionSequence
}


/**
 * Class for defining sequences of user touch interactions. Each sequence
 * will not be executed until {@link #perform} is called.

Example:

     new webdriver.TouchSequence(driver).
         tapAndHold({x: 0, y: 0}).
         move({x: 3, y: 4}).
         release({x: 10, y: 10}).
         perform();
*/
declare class TouchSequence {
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Executes this action sequence.
     * @return  A promise that will be resolved once
    this sequence has completed.
    */
    perform(): undefined.Promise<void>;

    /**
     * Taps an element.
     * @param  The element to tap.
     * @return  A self reference.
     */
    tap(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Double taps an element.
     * @param  The element to double tap.
     * @return  A self reference.
     */
    doubleTap(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Long press on an element.
     * @param  The element to long press.
     * @return  A self reference.
     */
    longPress(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Touch down at the given location.
     * @param  The location to touch down at.
     * @return  A self reference.
     */
    tapAndHold(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Move a held {@linkplain #tapAndHold touch} to the specified location.
     * @param  The location to move to.
     * @return  A self reference.
     */
    move(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Release a held {@linkplain #tapAndHold touch} at the specified location.
     * @param  The location to release at.
     * @return  A self reference.
     */
    release(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Scrolls the touch screen by the given offset.
     * @param  The offset to scroll to.
     * @return  A self reference.
     */
    scroll(offset: webdriver$IOffset): webdriver$TouchSequence;

    /**
     * Scrolls the touch screen, starting on `elem` and moving by the specified
     * offset.
     * @param  The element where scroll starts.
     * @param  The offset to scroll to.
     * @return  A self reference.
     */
    scrollFromElement(elem: webdriver$WebElement, offset: webdriver$IOffset): webdriver$TouchSequence;

    /**
     * Flick, starting anywhere on the screen, at speed xspeed and yspeed.
     * @param  The speed to flick in each
    direction, in pixels per second.
     * @return  A self reference.
    */
    flick(speed: webdriver$ISpeed): webdriver$TouchSequence;

    /**
     * Flick starting at elem and moving by x and y at specified speed.
     * @param  The element where flick starts.
     * @param  The offset to flick to.
     * @param  The speed to flick at in pixels per second.
     * @return  A self reference.
     */
    flickElement(
        elem: webdriver$WebElement,
        offset: webdriver$IOffset,
        speed: number): webdriver$TouchSequence
}

declare interface webdriver$IOffset {
    x: number,
        y: number
}

declare interface webdriver$ISpeed {
    xspeed: number,
        yspeed: number
}


/**
 * Represents a modal dialog such as {@code alert}, {@code confirm}, or
 * {
 * @code  prompt}. Provides functions to retrieve the message displayed with
the alert, accept or dismiss the alert, and set the response text (in the
case of {
 * @code  prompt}).
*/
declare interface webdriver$Alert {

    /**
     * Retrieves the message text displayed with this alert. For instance, if the
     * alert were opened with alert("hello"), then this would return "hello".
     * @return  A promise that will be resolved to the
    text displayed with this alert.
    */
    getText(): undefined.Promise<string>,

        /**
         * Accepts this alert.
         * @return  A promise that will be resolved when
        this command has completed.
        */
        accept(): undefined.Promise<void>,

        /**
         * Dismisses this alert.
         * @return  A promise that will be resolved when
        this command has completed.
        */
        dismiss(): undefined.Promise<void>,

        /**
         * Sets the response text on this alert. This command will return an error if
         * the underlying alert does not support response text (e.g. window.alert and
        window.confirm).
         * @param  The text to set.
         * @return  A promise that will be resolved when
        this command has completed.
        */
        sendKeys(text: string): undefined.Promise<void >
}


/**
 * AlertPromise is a promise that will be fulfilled with an Alert. This promise
 * serves as a forward proxy on an Alert, allowing calls to be scheduled
directly on this instance before the underlying Alert has been fulfilled. In
other words, the following two statements are equivalent:
<pre><code>
     driver.switchTo().alert().dismiss();
     driver.switchTo().alert().then(function(alert) {
       return alert.dismiss();
     });
</code></pre>
 * @param  The driver controlling the browser this
alert is attached to.
 * @param  A thenable
that will be fulfilled with the promised alert.
 * @constructor  * 
 * @extends  {webdriver.Alert}
 * @implements  {webdriver.promise.Thenable.<!webdriver.Alert>}
 * @final  
*/
declare type webdriver$AlertPromise = {} & webdriver$Alert &



    /**
     * An error returned to indicate that there is an unhandled modal dialog on the
     * current page.
     * @extends  {bot.Error}
     */
    declare type webdriver$UnhandledAlertError = {

        /**
         * 
         * @return  The text displayed with the unhandled alert.
         */
        getAlertText(): string,

        /**
         * 
         * @return  The open alert.
         * @deprecated  Use {
         * @link  #getAlertText}. This method will be removed in
        2.45.0.
        */
        getAlert(): webdriver$Alert
    }


/**
 * Recognized browser names.
 * @enum  {string}
 */
declare interface webdriver$IBrowser {
    ANDROID: string,
        CHROME: string,
        FIREFOX: string,
        INTERNET_EXPLORER: string,
        IPAD: string,
        IPHONE: string,
        OPERA: string,
        PHANTOM_JS: string,
        SAFARI: string,
        HTMLUNIT: string
}

declare var Browser: webdriver$IBrowser;

declare interface webdriver$ProxyConfig {
    proxyType: string,
        proxyAutoconfigUrl?: string,
        ftpProxy?: string,
        httpProxy?: string,
        sslProxy?: string,
        noProxy?: string
}

declare class Builder {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Creates a new WebDriver client based on this builder's current
     * configuration.
     * @return  A new WebDriver instance.
     * @throws  {Error} If the current configuration is invalid.
     */
    build(): webdriver$WebDriver;

    /**
     * Configures the target browser for clients created by this instance.
     * Any calls to {@link #withCapabilities} after this function will
    overwrite these settings.

    <p>You may also define the target browser using the {@code SELENIUM_BROWSER}
    environment variable. If set, this environment variable should be of the
    form {@code browser[:[version][:platform]]}.
     * @param  The name of the target browser;
    common defaults are available on the {
     * @link  webdriver.Browser} enum.
     * @param  A desired version; may be omitted if any
    version should be used.
     * @param  The desired platform; may be omitted if any
    version may be used.
     * @return  A self reference.
    */
    forBrowser(name: string, opt_version?: string, opt_platform?: string): webdriver$Builder;

    /**
     * Returns the base set of capabilities this instance is currently configured
     * to use.
     * @return  The current capabilities for this builder.
     */
    getCapabilities(): webdriver$Capabilities;

    /**
     * 
     * @return  The URL of the WebDriver server this instance is configured
    to use.
    */
    getServerUrl(): string;

    /**
     * Sets the default action to take with an unexpected alert before returning
     * an error.
     * @param  The desired behavior; should be "accept", "dismiss",
    or "ignore". Defaults to "dismiss".
     * @return  A self reference.
    */
    setAlertBehavior(behavior: string): webdriver$Builder;

    /**
     * Sets Chrome-specific options for drivers created by this builder. Any
     * logging or proxy settings defined on the given options will take precedence
    over those set through {@link #setLoggingPrefs} and {@link #setProxy},
    respectively.
     * @param  The ChromeDriver options to use.
     * @return  A self reference.
    */
    setChromeOptions(options: chrome$Options): webdriver$Builder;

    /**
     * Sets the control flow that created drivers should execute actions in. If
     * the flow is never set, or is set to {@code null}, it will use the active
    flow at the time {@link #build()} is called.
     * @param  The control flow to use, or
    {
     * @code  null} to
     * @return  A self reference.
    */
    setControlFlow(flow: undefined.ControlFlow): webdriver$Builder;

    /**
     * Sets whether native events should be used.
     * @param  Whether to enable native events.
     * @return  A self reference.
     */
    setEnableNativeEvents(enabled: boolean): webdriver$Builder;

    /**
     * Sets Firefox-specific options for drivers created by this builder. Any
     * logging or proxy settings defined on the given options will take precedence
    over those set through {@link #setLoggingPrefs} and {@link #setProxy},
    respectively.
     * @param  The FirefoxDriver options to use.
     * @return  A self reference.
    */
    setFirefoxOptions(options: firefox$Options): webdriver$Builder;

    /**
     * Sets the logging preferences for the created session. Preferences may be
     * changed by repeated calls, or by calling {@link #withCapabilities}.
     * @param  The
    desired logging preferences.
     * @return  A self reference.
    */
    setLoggingPrefs(prefs: undefined.Preferences): webdriver$Builder;
    setLoggingPrefs(prefs: {
        [key: string]: string
    }): webdriver$Builder;

    /**
     * Sets the proxy configuration to use for WebDriver clients created by this
     * builder. Any calls to {@link #withCapabilities} after this function will
    overwrite these settings.
     * @param  The configuration to use.
     * @return  A self reference.
    */
    setProxy(config: webdriver$ProxyConfig): webdriver$Builder;

    /**
     * Sets how elements should be scrolled into view for interaction.
     * @param  The desired scroll behavior: either 0 to align with
    the top of the viewport or 1 to align with the bottom.
     * @return  A self reference.
    */
    setScrollBehavior(behavior: number): webdriver$Builder;

    /**
     * Sets the URL of a remote WebDriver server to use. Once a remote URL has been
     * specified, the builder direct all new clients to that server. If this method
    is never called, the Builder will attempt to create all clients locally.

    <p>As an alternative to this method, you may also set the
    {
     * @code  SELENIUM_REMOTE_URL} environment variable.
     * @param  The URL of a remote server to use.
     * @return  A self reference.
    */
    usingServer(url: string): webdriver$Builder;

    /**
     * Sets the desired capabilities when requesting a new session. This will
     * overwrite any previously set capabilities.
     * @param  The desired
    capabilities for a new session.
     * @return  A self reference.
    */
    withCapabilities(capabilities: webdriver$Capabilities): webdriver$Builder;
    withCapabilities(capabilities: any): webdriver$Builder
}


/**
 * Common webdriver capability keys.
 * @enum  {string}
 */
declare interface webdriver$ICapability {

    /**
     * Indicates whether a driver should accept all SSL certs by default. This
     * capability only applies when requesting a new session. To query whether
    a driver can handle insecure SSL certs, see
    {
     * @link  webdriver.Capability.SECURE_SSL}.
    */
    ACCEPT_SSL_CERTS: string,

        /**
         * The browser name. Common browser names are defined in the
         * {
         * @link  webdriver.Browser} enum.
         */
        BROWSER_NAME: string,

        /**
         * Defines how elements should be scrolled into the viewport for interaction.
         * This capability will be set to zero (0) if elements are aligned with the
        top of the viewport, or one (1) if aligned with the bottom. The default
        behavior is to align with the top of the viewport.
        */
        ELEMENT_SCROLL_BEHAVIOR: string,

        /**
         * Whether the driver is capable of handling modal alerts (e.g. alert,
         * confirm, prompt). To define how a driver <i>should</i> handle alerts,
        use {@link webdriver.Capability.UNEXPECTED_ALERT_BEHAVIOR}.
        */
        HANDLES_ALERTS: string,

        /**
         * Key for the logging driver logging preferences.
         */
        LOGGING_PREFS: string,

        /**
         * Whether this session generates native events when simulating user input.
         *   
         */
        NATIVE_EVENTS: string,

        /**
         * Describes the platform the browser is running on. Will be one of
         * ANDROID, IOS, LINUX, MAC, UNIX, or WINDOWS. When <i>requesting</i> a
        session, ANY may be used to indicate no platform preference (this is
        semantically equivalent to omitting the platform capability).
        */
        PLATFORM: string,

        /**
         * Describes the proxy configuration to use for a new WebDriver session.
         */
        PROXY: string,

        /**
         * Whether the driver supports changing the brower's orientation. 
         */
        ROTATABLE: string,

        /**
         * Whether a driver is only capable of handling secure SSL certs. To request
         * that a driver accept insecure SSL certs by default, use
        {
         * @link  webdriver.Capability.ACCEPT_SSL_CERTS}.
        */
        SECURE_SSL: string,

        /**
         * Whether the driver supports manipulating the app cache. 
         */
        SUPPORTS_APPLICATION_CACHE: string,

        /**
         * Whether the driver supports locating elements with CSS selectors. 
         */
        SUPPORTS_CSS_SELECTORS: string,

        /**
         * Whether the browser supports JavaScript. 
         */
        SUPPORTS_JAVASCRIPT: string,

        /**
         * Whether the driver supports controlling the browser's location info. 
         */
        SUPPORTS_LOCATION_CONTEXT: string,

        /**
         * Whether the driver supports taking screenshots. 
         */
        TAKES_SCREENSHOT: string,

        /**
         * Defines how the driver should handle unexpected alerts. The value should
         * be one of "accept", "dismiss", or "ignore.
         */
        UNEXPECTED_ALERT_BEHAVIOR: string,

        /**
         * Defines the browser version. 
         */
        VERSION: string
}

declare var Capability: webdriver$ICapability;

declare class Capabilities {

    /**
     * 
     * @param  Another set of
    capabilities to merge into this instance.
     * @constructor  
    */
    constructor(opt_other?: webdriver$Capabilities): this;
    constructor(opt_other?: any): this;

    /**
     * 
     * @return  The JSON representation of this instance. 
     */
    toJSON(): any;

    /**
     * Merges another set of capabilities into this instance. Any duplicates in
     * the provided set will override those already set on this instance.
     * @param  The capabilities to
    merge into this instance.
     * @return  A self reference.
    */
    merge(other: webdriver$Capabilities): webdriver$Capabilities;
    merge(other: any): webdriver$Capabilities;

    /**
     * 
     * @param  The capability to set.
     * @param  The capability value.  Capability values must be JSON
    serializable. Pass {
     * @code  null} to unset the capability.
     * @return  A self reference.
    */
    set(key: string, value: any): webdriver$Capabilities;

    /**
     * Sets the logging preferences. Preferences may be specified as a
     * {
     * @link  webdriver.logging.Preferences} instance, or a as a map of log-type to
    log-level.
     * @param  The
    logging preferences.
     * @return  A self reference.
    */
    setLoggingPrefs(prefs: undefined.Preferences): webdriver$Capabilities;
    setLoggingPrefs(prefs: {
        [key: string]: string
    }): webdriver$Capabilities;

    /**
     * Sets the proxy configuration for this instance.
     * @param  The desired proxy configuration.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): webdriver$Capabilities;

    /**
     * Sets whether native events should be used.
     * @param  Whether to enable native events.
     * @return  A self reference.
     */
    setEnableNativeEvents(enabled: boolean): webdriver$Capabilities;

    /**
     * Sets how elements should be scrolled into view for interaction.
     * @param  The desired scroll behavior: either 0 to align with
    the top of the viewport or 1 to align with the bottom.
     * @return  A self reference.
    */
    setScrollBehavior(behavior: number): webdriver$Capabilities;

    /**
     * Sets the default action to take with an unexpected alert before returning
     * an error.
     * @param  The desired behavior; should be "accept", "dismiss",
    or "ignore". Defaults to "dismiss".
     * @return  A self reference.
    */
    setAlertBehavior(behavior: string): webdriver$Capabilities;

    /**
     * 
     * @param  The capability to return.
     * @return  The capability with the given key, or {
     * @code  null} if it has
    not been set.
    */
    get(key: string): any;

    /**
     * 
     * @param  The capability to check.
     * @return  Whether the specified capability is set.
     */
    has(key: string): boolean;

    /**
     * 
     * @return  A basic set of capabilities for Android.
     */
    android(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Chrome.
     */
    chrome(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Firefox.
     */
    firefox(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for
    Internet Explorer.
    */
    ie(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for iPad.
     */
    ipad(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for iPhone.
     */
    iphone(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Opera.
     */
    opera(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for
    PhantomJS.
    */
    phantomjs(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Safari.
     */
    safari(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for HTMLUnit.
     */
    htmlunit(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for HTMLUnit
      with enabled Javascript.
    */
    htmlunitwithjs(): webdriver$Capabilities
}


/**
 * An enumeration of valid command string.
 */
declare interface webdriver$ICommandName {
    GET_SERVER_STATUS: string,
        NEW_SESSION: string,
        GET_SESSIONS: string,
        DESCRIBE_SESSION: string,
        CLOSE: string,
        QUIT: string,
        GET_CURRENT_URL: string,
        GET: string,
        GO_BACK: string,
        GO_FORWARD: string,
        REFRESH: string,
        ADD_COOKIE: string,
        GET_COOKIE: string,
        GET_ALL_COOKIES: string,
        DELETE_COOKIE: string,
        DELETE_ALL_COOKIES: string,
        GET_ACTIVE_ELEMENT: string,
        FIND_ELEMENT: string,
        FIND_ELEMENTS: string,
        FIND_CHILD_ELEMENT: string,
        FIND_CHILD_ELEMENTS: string,
        CLEAR_ELEMENT: string,
        CLICK_ELEMENT: string,
        SEND_KEYS_TO_ELEMENT: string,
        SUBMIT_ELEMENT: string,
        GET_CURRENT_WINDOW_HANDLE: string,
        GET_WINDOW_HANDLES: string,
        GET_WINDOW_POSITION: string,
        SET_WINDOW_POSITION: string,
        GET_WINDOW_SIZE: string,
        SET_WINDOW_SIZE: string,
        MAXIMIZE_WINDOW: string,
        SWITCH_TO_WINDOW: string,
        SWITCH_TO_FRAME: string,
        GET_PAGE_SOURCE: string,
        GET_TITLE: string,
        EXECUTE_SCRIPT: string,
        EXECUTE_ASYNC_SCRIPT: string,
        GET_ELEMENT_TEXT: string,
        GET_ELEMENT_TAG_NAME: string,
        IS_ELEMENT_SELECTED: string,
        IS_ELEMENT_ENABLED: string,
        IS_ELEMENT_DISPLAYED: string,
        GET_ELEMENT_LOCATION: string,
        GET_ELEMENT_LOCATION_IN_VIEW: string,
        GET_ELEMENT_SIZE: string,
        GET_ELEMENT_ATTRIBUTE: string,
        GET_ELEMENT_VALUE_OF_CSS_PROPERTY: string,
        ELEMENT_EQUALS: string,
        SCREENSHOT: string,
        IMPLICITLY_WAIT: string,
        SET_SCRIPT_TIMEOUT: string,
        SET_TIMEOUT: string,
        ACCEPT_ALERT: string,
        DISMISS_ALERT: string,
        GET_ALERT_TEXT: string,
        SET_ALERT_TEXT: string,
        EXECUTE_SQL: string,
        GET_LOCATION: string,
        SET_LOCATION: string,
        GET_APP_CACHE: string,
        GET_APP_CACHE_STATUS: string,
        CLEAR_APP_CACHE: string,
        IS_BROWSER_ONLINE: string,
        SET_BROWSER_ONLINE: string,
        GET_LOCAL_STORAGE_ITEM: string,
        GET_LOCAL_STORAGE_KEYS: string,
        SET_LOCAL_STORAGE_ITEM: string,
        REMOVE_LOCAL_STORAGE_ITEM: string,
        CLEAR_LOCAL_STORAGE: string,
        GET_LOCAL_STORAGE_SIZE: string,
        GET_SESSION_STORAGE_ITEM: string,
        GET_SESSION_STORAGE_KEYS: string,
        SET_SESSION_STORAGE_ITEM: string,
        REMOVE_SESSION_STORAGE_ITEM: string,
        CLEAR_SESSION_STORAGE: string,
        GET_SESSION_STORAGE_SIZE: string,
        SET_SCREEN_ORIENTATION: string,
        GET_SCREEN_ORIENTATION: string,
        CLICK: string,
        DOUBLE_CLICK: string,
        MOUSE_DOWN: string,
        MOUSE_UP: string,
        MOVE_TO: string,
        SEND_KEYS_TO_ACTIVE_ELEMENT: string,
        TOUCH_SINGLE_TAP: string,
        TOUCH_DOWN: string,
        TOUCH_UP: string,
        TOUCH_MOVE: string,
        TOUCH_SCROLL: string,
        TOUCH_DOUBLE_TAP: string,
        TOUCH_LONG_PRESS: string,
        TOUCH_FLICK: string,
        GET_AVAILABLE_LOG_TYPES: string,
        GET_LOG: string,
        GET_SESSION_LOGS: string
}

declare var CommandName: webdriver$ICommandName;


/**
 * Describes a command to be executed by the WebDriverJS framework.
 * @param  The name of this command.
 * @constructor  
 */
declare class Command {

    /**
     * 
     * @param  The name of this command.
     * @constructor  
     */
    constructor(name: string): this;

    /**
     * 
     * @return  This command's name.
     */
    getName(): string;

    /**
     * Sets a parameter to send with this command.
     * @param  The parameter name.
     * @param  The parameter value.
     * @return  A self reference.
     */
    setParameter(name: string, value: any): webdriver$Command;

    /**
     * Sets the parameters for this command.
     * @param  The command parameters.
     * @return  A self reference.
     */
    setParameters(parameters: any): webdriver$Command;

    /**
     * Returns a named command parameter.
     * @param  The parameter key to look up.
     * @return  The parameter value, or undefined if it has not been set.
     */
    getParameter(key: string): any;

    /**
     * 
     * @return  The parameters to send with this command.
     */
    getParameters(): any
}


/**
 * Handles the execution of {@code webdriver.Command} objects.
 */
declare interface webdriver$CommandExecutor {

    /**
     * Executes the given {@code command}. If there is an error executing the
     * command, the provided callback will be invoked with the offending error.
    Otherwise, the callback will be invoked with a null Error and non-null
    {
     * @link  bot.response.ResponseObject} object.
     * @param  The command to execute.
     * @param  the function
    to invoke when the command response is ready.
    */
    execute(
        command: webdriver$Command,
        callback: (error: error$Error, responseObject: any) => any): void
}


/**
 * Object that can emit events for others to listen for. This is used instead
 * of Closure's event system because it is much more light weight. The API is
based on Node's EventEmitters.
*/
declare class EventEmitter {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Fires an event and calls all listeners.
     * @param  The type of event to emit.
     * @param  Any arguments to pass to each listener.
     */
    emit(type: string, ...var_args: any[]): void;

    /**
     * Returns a mutable list of listeners for a specific type of event.
     * @param  The type of event to retrieve the listeners for.
     * @return  >} The registered listeners for
    the given event type.
    */
    listeners(type: string): Array<{
        fn: Function,
        oneshot: boolean,
        scope: any
    }>;

    /**
     * Registers a listener.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @return  A self reference.
     */
    addListener(type: string, listenerFn: Function, opt_scope?: any): webdriver$EventEmitter;

    /**
     * Registers a one-time listener which will be called only the first time an
     * event is emitted, after which it will be removed.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @return  A self reference.
     */
    once(type: string, listenerFn: any, opt_scope?: any): webdriver$EventEmitter;

    /**
     * An alias for {@code #addListener()}.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @return  A self reference.
     */
    on(type: string, listenerFn: Function, opt_scope?: any): webdriver$EventEmitter;

    /**
     * Removes a previously registered event listener.
     * @param  The type of event to unregister.
     * @param  The handler function to remove.
     * @return  A self reference.
     */
    removeListener(type: string, listenerFn: Function): webdriver$EventEmitter;

    /**
     * Removes all listeners for a specific type of event. If no event is
     * specified, all listeners across all types will be removed.
     * @param  The type of event to remove listeners from.
     * @return  A self reference.
     */
    removeAllListeners(opt_type?: string): webdriver$EventEmitter
}


/**
 * Interface for navigating back and forth in the browser history.
 */
declare interface webdriver$WebDriverNavigation {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverNavigation,

    /**
     * Schedules a command to navigate to a new URL.
     * @param  The URL to navigate to.
     * @return  A promise that will be resolved
    when the URL has been loaded.
    */
    to(url: string): undefined.Promise<void>,

        /**
         * Schedules a command to move backwards in the browser history.
         * @return  A promise that will be resolved
        when the navigation event has completed.
        */
        back(): undefined.Promise<void>,

        /**
         * Schedules a command to move forwards in the browser history.
         * @return  A promise that will be resolved
        when the navigation event has completed.
        */
        forward(): undefined.Promise<void>,

        /**
         * Schedules a command to refresh the current page.
         * @return  A promise that will be resolved
        when the navigation event has completed.
        */
        refresh(): undefined.Promise<void >
}

declare interface webdriver$IWebDriverOptionsCookie {
    name: string,
        value: string,
        path?: string,
        domain?: string,
        secure?: boolean,
        expiry?: number
}


/**
 * Provides methods for managing browser and driver state.
 */
declare interface webdriver$WebDriverOptions {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverOptions,

    /**
     * Schedules a command to add a cookie.
     * @param  The cookie name.
     * @param  The cookie value.
     * @param  The cookie path.
     * @param  The cookie domain.
     * @param  Whether the cookie is secure.
     * @param  When the cookie expires. If specified as
    a number, should be in milliseconds since midnight, January 1, 1970 UTC.
     * @return  A promise that will be resolved when the
    cookie has been added to the page.
    */
    addCookie(
            name: string,
            value: string,
            opt_path?: string,
            opt_domain?: string,
            opt_isSecure?: boolean,
            opt_expiry?: number): undefined.Promise<void>,
        addCookie(
            name: string,
            value: string,
            opt_path?: string,
            opt_domain?: string,
            opt_isSecure?: boolean,
            opt_expiry?: Date): undefined.Promise<void>,

        /**
         * Schedules a command to delete all cookies visible to the current page.
         * @return  A promise that will be resolved when all
        cookies have been deleted.
        */
        deleteAllCookies(): undefined.Promise<void>,

        /**
         * Schedules a command to delete the cookie with the given name. This command is
         * a no-op if there is no cookie with the given name visible to the current
        page.
         * @param  The name of the cookie to delete.
         * @return  A promise that will be resolved when the
        cookie has been deleted.
        */
        deleteCookie(name: string): undefined.Promise<void>,

        /**
         * Schedules a command to retrieve all cookies visible to the current page.
         * Each cookie will be returned as a JSON object as described by the WebDriver
        wire protocol.
         * @return  A promise that will be resolved with the
        cookies visible to the current page.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
        */
        getCookies(): undefined.Promise<webdriver$IWebDriverOptionsCookie[]>,

        /**
         * Schedules a command to retrieve the cookie with the given name. Returns null
         * if there is no such cookie. The cookie will be returned as a JSON object as
        described by the WebDriver wire protocol.
         * @param  The name of the cookie to retrieve.
         * @return  A promise that will be resolved with the
        named cookie, or {
         * @code  null} if there is no such cookie.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
        */
        getCookie(name: string): undefined.Promise<webdriver$IWebDriverOptionsCookie>,

        /**
         * 
         * @return  The interface for managing driver
        logs.
        */
        logs(): webdriver$WebDriverLogs,

        /**
         * 
         * @return  The interface for managing driver
        timeouts.
        */
        timeouts(): webdriver$WebDriverTimeouts,

        /**
         * 
         * @return  The interface for managing the
        current window.
        */
        window(): webdriver$WebDriverWindow
}


/**
 * An interface for managing timeout behavior for WebDriver instances.
 */
declare interface webdriver$WebDriverTimeouts {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverTimeouts,

    /**
     * Specifies the amount of time the driver should wait when searching for an
     * element if it is not immediately present.
    <p/>
    When searching for a single element, the driver should poll the page
    until the element has been found, or this timeout expires before failing
    with a {@code bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching
    for multiple elements, the driver should poll the page until at least one
    element has been found or this timeout has expired.
    <p/>
    Setting the wait timeout to 0 (its default value), disables implicit
    waiting.
    <p/>
    Increasing the implicit wait timeout should be used judiciously as it
    will have an adverse effect on test run time, especially when used with
    slower location strategies like XPath.
     * @param  The amount of time to wait, in milliseconds.
     * @return  A promise that will be resolved when the
    implicit wait timeout has been set.
    */
    implicitlyWait(ms: number): undefined.Promise<void>,

        /**
         * Sets the amount of time to wait, in milliseconds, for an asynchronous script
         * to finish execution before returning an error. If the timeout is less than or
        equal to 0, the script will be allowed to run indefinitely.
         * @param  The amount of time to wait, in milliseconds.
         * @return  A promise that will be resolved when the
        script timeout has been set.
        */
        setScriptTimeout(ms: number): undefined.Promise<void>,

        /**
         * Sets the amount of time to wait for a page load to complete before returning
         * an error.  If the timeout is negative, page loads may be indefinite.
         * @param  The amount of time to wait, in milliseconds.
         * @return  A promise that will be resolved when
        the timeout has been set.
        */
        pageLoadTimeout(ms: number): undefined.Promise<void >
}


/**
 * An interface for managing the current window.
 */
declare interface webdriver$WebDriverWindow {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverWindow,

    /**
     * Retrieves the window's current position, relative to the top left corner of
     * the screen.
     * @return  A promise that will be resolved with the
    window's position in the form of a {x:number, y:number} object literal.
    */
    getPosition(): undefined.Promise<webdriver$ILocation>,

        /**
         * Repositions the current window.
         * @param  The desired horizontal position, relative to the left side
        of the screen.
         * @param  The desired vertical position, relative to the top of the
        of the screen.
         * @return  A promise that will be resolved when the
        command has completed.
        */
        setPosition(x: number, y: number): undefined.Promise<void>,

        /**
         * Retrieves the window's current size.
         * @return  A promise that will be resolved with the
        window's size in the form of a {width:number, height:number} object
        literal.
        */
        getSize(): undefined.Promise<webdriver$ISize>,

        /**
         * Resizes the current window.
         * @param  The desired window width.
         * @param  The desired window height.
         * @return  A promise that will be resolved when the
        command has completed.
        */
        setSize(width: number, height: number): undefined.Promise<void>,

        /**
         * Maximizes the current window.
         * @return  A promise that will be resolved when the
        command has completed.
        */
        maximize(): undefined.Promise<void >
}


/**
 * Interface for managing WebDriver log records.
 */
declare interface webdriver$WebDriverLogs {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverLogs,

    /**
     * Fetches available log entries for the given type.
     * 
    <p/>Note that log buffers are reset after each call, meaning that
    available log entries correspond to those entries not yet returned for a
    given log type. In practice, this means that this call will return the
    available log entries since the last call, or from the start of the
    session.
     * @param  The desired log type.
     * @return  A
    promise that will resolve to a list of log entries for the specified
    type.
    */
    get(type: string): undefined.Promise<undefined.Entry[]>,

        /**
         * Retrieves the log types available to this driver.
         * @return  A
        promise that will resolve to a list of available log types.
        */
        getAvailableLogTypes(): undefined.Promise<string[] >
}


/**
 * An interface for changing the focus of the driver to another frame or window.
 */
declare interface webdriver$WebDriverTargetLocator {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    new(driver: webdriver$WebDriver): webdriver$WebDriverTargetLocator,

    /**
     * Schedules a command retrieve the {@code document.activeElement} element on
     * the current document, or {@code document.body} if activeElement is not
    available.
     * @return  The active element.
    */
    activeElement(): webdriver$WebElementPromise,

        /**
         * Schedules a command to switch focus of all future commands to the first frame
         * on the page.
         * @return  A promise that will be resolved when the
        driver has changed focus to the default content.
        */
        defaultContent(): undefined.Promise<void>,

        /**
         * Schedules a command to switch the focus of all future commands to another
         * frame on the page.
        <p/>
        If the frame is specified by a number, the command will switch to the frame
        by its (zero-based) index into the {@code window.frames} collection.
        <p/>
        If the frame is specified by a string, the command will select the frame by
        its name or ID. To select sub-frames, simply separate the frame names/IDs by
        dots. As an example, "main.child" will select the frame with the name "main"
        and then its child "child".
        <p/>
        If the specified frame can not be found, the deferred result will errback
        with a {@code bot.ErrorCode.NO_SUCH_FRAME} error.
         * @param  The frame locator.
         * @return  A promise that will be resolved when the
        driver has changed focus to the specified frame.
        */
        frame(nameOrIndex: string): undefined.Promise<void>,
        frame(nameOrIndex: number): undefined.Promise<void>,

        /**
         * Schedules a command to switch the focus of all future commands to another
         * window. Windows may be specified by their {@code window.name} attribute or
        by its handle (as returned by {@code webdriver.WebDriver#getWindowHandles}).
        <p/>
        If the specificed window can not be found, the deferred result will errback
        with a {@code bot.ErrorCode.NO_SUCH_WINDOW} error.
         * @param  The name or window handle of the window to
        switch focus to.
         * @return  A promise that will be resolved when the
        driver has changed focus to the specified window.
        */
        window(nameOrHandle: string): undefined.Promise<void>,

        /**
         * Schedules a command to change focus to the active alert dialog. This command
         * will return a {@link bot.ErrorCode.NO_MODAL_DIALOG_OPEN} error if a modal
        dialog is not currently open.
         * @return  The open alert.
        */
        alert(): webdriver$AlertPromise
}


/**
 * Used with {@link webdriver.WebElement#sendKeys WebElement#sendKeys} on file
 * input elements ({@code <input type="file">}) to detect when the entered key
sequence defines the path to a file.

By default, {@linkplain webdriver.WebElement WebElement's} will enter all
key sequences exactly as entered. You may set a
{
 * @linkplain  webdriver.WebDriver#setFileDetector file detector} on the parent
WebDriver instance to define custom behavior for handling file elements. Of
particular note is the {
 * @link  selenium-webdriver/remote.FileDetector}, which
should be used when running against a remote
[Selenium Server](http://docs.seleniumhq.org/download/).
*/
declare class FileDetector {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Handles the file specified by the given path, preparing it for use with
     * the current browser. If the path does not refer to a valid file, it will
    be returned unchanged, otherwisee a path suitable for use with the current
    browser will be returned.

    This default implementation is a no-op. Subtypes may override this
    function for custom tailored file handling.
     * @param  The driver for the current browser.
     * @param  The path to process.
     * @return  <string>} A promise for the processed
    file path.
     * @package  
    */
    handleFile(driver: webdriver$WebDriver, path: string): undefined.Promise<string >
}


/**
 * Creates a new WebDriver client, which provides control over a browser.
 * 
Every WebDriver command returns a {@code webdriver.promise.Promise} that
represents the result of that command. Callbacks may be registered on this
object to manipulate the command result or catch an expected error. Any
commands scheduled with a callback are considered sub-commands and will
execute before the next command in the current frame. For example:

   var message = [];
   driver.call(message.push, message, 'a').then(function() {
     driver.call(message.push, message, 'b');
   });
   driver.call(message.push, message, 'c');
   driver.call(function() {
     alert('message is abc? ' + (message.join('') == 'abc'));
   });
*/
declare class WebDriver {

    /**
     * 
     * @param  Either a
    known session or a promise that will be resolved to a session.
     * @param  The executor to use when
    sending commands to the browser.
     * @param  The flow to
    schedule commands through. Defaults to the active flow object.
     * @constructor  
    */
    constructor(session: webdriver$Session, executor: webdriver$CommandExecutor, opt_flow?: undefined.ControlFlow): this;
    constructor(session: undefined.Promise<webdriver$Session>, executor: webdriver$CommandExecutor, opt_flow?: undefined.ControlFlow): this;
    Navigation: webdriver$WebDriverNavigation;
    Options: webdriver$WebDriverOptions;
    Timeouts: webdriver$WebDriverTimeouts;
    Window: webdriver$WebDriverWindow;
    Logs: webdriver$WebDriverLogs;
    TargetLocator: webdriver$WebDriverTargetLocator;

    /**
     * Creates a new WebDriver client for an existing session.
     * @param  Command executor to use when
    querying for session details.
     * @param  ID of the session to attach to.
     * @param  The control flow all driver
    commands should execute under. Defaults to the
    {
     * @link  webdriver.promise.controlFlow() currently active}  control flow.
     * @return  A new client for the specified session.
    */
    attachToSession(
        executor: webdriver$CommandExecutor,
        sessionId: string,
        opt_flow?: undefined.ControlFlow): webdriver$WebDriver;

    /**
     * Creates a new WebDriver session.
     * @param  The executor to create the new
    session with.
     * @param  The desired
    capabilities for the new session.
     * @param  The control flow all driver
    commands should execute under, including the initial session creation.
    Defaults to the {
     * @link  webdriver.promise.controlFlow() currently active}
    control flow.
     * @return  The driver for the newly created session.
    */
    createSession(
        executor: webdriver$CommandExecutor,
        desiredCapabilities: webdriver$Capabilities,
        opt_flow?: undefined.ControlFlow): webdriver$WebDriver;

    /**
     * 
     * @return  The control flow used by this
    instance.
    */
    controlFlow(): undefined.ControlFlow;

    /**
     * Schedules a {@code webdriver.Command} to be executed by this driver's
     * {
     * @code  webdriver.CommandExecutor}.
     * @param  The command to schedule.
     * @param  A description of the command for debugging.
     * @return  A promise that will be resolved with
    the command result.
    */
    schedule<T>(command: webdriver$Command, description: string): undefined.Promise<T>;

    /**
     * Sets the {@linkplain webdriver.FileDetector file detector} that should be
     * used with this instance.
     * @param  The detector to use or {
     * @code  null}.
     */
    setFileDetector(detector: webdriver$FileDetector): void;

    /**
     * 
     * @return  A promise for this
    client's session.
    */
    getSession(): undefined.Promise<webdriver$Session>;

    /**
     * 
     * @return  A promise
    that will resolve with the this instance's capabilities.
    */
    getCapabilities(): undefined.Promise<webdriver$Capabilities>;

    /**
     * Schedules a command to quit the current session. After calling quit, this
     * instance will be invalidated and may no longer be used to issue commands
    against the browser.
     * @return  A promise that will be resolved
    when the command has completed.
    */
    quit(): undefined.Promise<void>;

    /**
     * Creates a new action sequence using this driver. The sequence will not be
     * scheduled for execution until {@link webdriver.ActionSequence#perform} is
    called. Example:
    <pre><code>
       driver.actions().
           mouseDown(element1).
           mouseMove(element2).
           mouseUp().
           perform();
    </code></pre>
     * @return  A new action sequence for this instance.
    */
    actions(): webdriver$ActionSequence;

    /**
     * Creates a new touch sequence using this driver. The sequence will not be
     * scheduled for execution until {@link webdriver.TouchSequence#perform} is
    called. Example:

         driver.touchActions().
             tap(element1).
             doubleTap(element2).
             perform();
     * @return  A new touch sequence for this instance.
    */
    touchActions(): webdriver$TouchSequence;

    /**
     * Schedules a command to execute JavaScript in the context of the currently
     * selected frame or window. The script fragment will be executed as the body
    of an anonymous function. If the script is provided as a function object,
    that function will be converted to a string for injection into the target
    window.

    Any arguments provided in addition to the script will be included as script
    arguments and may be referenced using the {@code arguments} object.
    Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
    Arrays and objects may also be used as script arguments as long as each item
    adheres to the types previously mentioned.

    The script may refer to any variables accessible from the current window.
    Furthermore, the script will execute in the window's context, thus
    {
     * @code  document} may be used to refer to the current document. Any local
    variables will not be available once the script has finished executing,
    though global variables will persist.

    If the script has a return value (i.e. if the script contains a return
    statement), then the following steps will be taken for resolving this
    functions return value:

    - For a HTML element, the value will resolve to a
    {
     * @link  webdriver.WebElement}
    - Null and undefined return values will resolve to null</li>
    - Booleans, numbers, and strings will resolve as is</li>
    - Functions will resolve to their string representation</li>
    - For arrays and objects, each member item will be converted according to
    the rules above
     * @param  The script to execute.
     * @param  The arguments to pass to the script.
     * @return  A promise that will resolve to the
    scripts return value.
     * @template  
    */
    executeScript<T>(script: string, ...var_args: any[]): undefined.Promise<T>;
    executeScript<T>(script: Function, ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to execute asynchronous JavaScript in the context of the
     * currently selected frame or window. The script fragment will be executed as
    the body of an anonymous function. If the script is provided as a function
    object, that function will be converted to a string for injection into the
    target window.

    Any arguments provided in addition to the script will be included as script
    arguments and may be referenced using the {@code arguments} object.
    Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
    Arrays and objects may also be used as script arguments as long as each item
    adheres to the types previously mentioned.

    Unlike executing synchronous JavaScript with {@link #executeScript},
    scripts executed with this function must explicitly signal they are finished
    by invoking the provided callback. This callback will always be injected
    into the executed function as the last argument, and thus may be referenced
    with {@code arguments[arguments.length - 1]}. The following steps will be
    taken for resolving this functions return value against the first argument
    to the script's callback function:

    - For a HTML element, the value will resolve to a
         {
     * @link  webdriver.WebElement}
    - Null and undefined return values will resolve to null
    - Booleans, numbers, and strings will resolve as is
    - Functions will resolve to their string representation
    - For arrays and objects, each member item will be converted according to
    the rules above

    __Example #1:__ Performing a sleep that is synchronized with the currently
    selected window:

    var start = new Date().getTime();
    driver.executeAsyncScript(
    'window.setTimeout(arguments[arguments.length - 1], 500);').
    then(function() {
    console.log(
        'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
    });

    __Example #2:__ Synchronizing a test with an AJAX application:

    var button = driver.findElement(By.id('compose-button'));
    button.click();
    driver.executeAsyncScript(
    'var callback = arguments[arguments.length - 1];' +
    'mailClient.getComposeWindowWidget().onload(callback);');
    driver.switchTo().frame('composeWidget');
    driver.findElement(By.id('to')).sendKeys('dog
     * @example  .com');

    __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
    this example, the inject script is specified with a function literal. When
    using this format, the function is converted to a string for injection, so it
    should not reference any symbols not defined in the scope of the page under
    test.

    driver.executeAsyncScript(function() {
    var callback = arguments[arguments.length - 1];
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/resource/data.json", true);
    xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
    callback(xhr.responseText);
    }
    }
    xhr.send('');
    }).then(function(str) {
    console.log(JSON.parse(str)['food']);
    });
     * @param  The script to execute.
     * @param  The arguments to pass to the script.
     * @return  A promise that will resolve to the
    scripts return value.
     * @template  
    */
    executeAsyncScript<T>(script: string | Function, ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to execute a custom function.
     * @param  The function to
    execute.
     * @param  The object in whose scope to execute the function.
     * @param  Any arguments to pass to the function.
     * @return  A promise that will be resolved'
    with the function's result.
     * @template  
    */
    call<T>(
        fn: (...var_args: any[]) => (T | undefined.Promise<T>),
        opt_scope?: any,
        ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to wait for a condition to hold. The condition may be
     * specified by a {@link webdriver.until.Condition}, as a custom function, or
    as a {@link webdriver.promise.Promise}.

    For a {@link webdriver.until.Condition} or function, the wait will repeatedly
    evaluate the condition until it returns a truthy value. If any errors occur
    while evaluating the condition, they will be allowed to propagate. In the
    event a condition returns a {@link webdriver.promise.Promise promise}, the
    polling loop will wait for it to be resolved and use the resolved value for
    whether the condition has been satisified. Note the resolution time for
    a promise is factored into whether a wait has timed out.

    *Example: waiting up to 10 seconds for an element to be present and visible
    on the page.

         var button = driver.wait(until.elementLocated(By.id('foo'), 10000);
         button.click();

    This function may also be used to block the command flow on the resolution
    of a {@link webdriver.promise.Promise promise}. When given a promise, the
    command will simply wait for its resolution before completing. A timeout may
    be provided to fail the command if the promise does not resolve before the
    timeout expires.

    *Example: Suppose you have a function, `startTestServer`, that returns a
    promise for when a server is ready for requests. You can block a `WebDriver`
    client on this promise with:

         var started = startTestServer();
         driver.wait(started, 5  1000, 'Server should start within 5 seconds');
         driver.get(getServerUrl());<T>|
              webdriver.until.Condition<T>|
              function(!webdriver.WebDriver): T)} condition The condition to
        wait on, defined as a promise, condition object, or  a function to
        evaluate as a condition.
     * @param  How long to wait for the condition to be true.
     * @param  An optional message to use if the wait times
    out.
     * @return  <T>} A promise that will be fulfilled
    with the first truthy value returned by the condition function, or
    rejected if the condition times out.
     * @template  
    */
    wait<T>(
        condition: undefined.Promise<T>| undefined.Condition<T>| ((driver: webdriver$WebDriver) => T),
        timeout?: number,
        opt_message?: string): undefined.Promise<T>;

    /**
     * Schedules a command to make the driver sleep for the given amount of time.
     * @param  The amount of time, in milliseconds, to sleep.
     * @return  A promise that will be resolved
    when the sleep has finished.
    */
    sleep(ms: number): undefined.Promise<void>;

    /**
     * Schedules a command to retrieve they current window handle.
     * @return  A promise that will be
    resolved with the current window handle.
    */
    getWindowHandle(): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the current list of available window handles.
     * @return  A promise that will
    be resolved with an array of window handles.
    */
    getAllWindowHandles(): undefined.Promise<string[]>;

    /**
     * Schedules a command to retrieve the current page's source. The page source
     * returned is a representation of the underlying DOM: do not expect it to be
    formatted or escaped in the same way as the response sent from the web
    server.
     * @return  A promise that will be
    resolved with the current page source.
    */
    getPageSource(): undefined.Promise<string>;

    /**
     * Schedules a command to close the current window.
     * @return  A promise that will be resolved
    when this command has completed.
    */
    close(): undefined.Promise<void>;

    /**
     * Schedules a command to navigate to the given URL.
     * @param  The fully qualified URL to open.
     * @return  A promise that will be resolved
    when the document has finished loading.
    */
    get(url: string): undefined.Promise<void>;

    /**
     * Schedules a command to retrieve the URL of the current page.
     * @return  A promise that will be
    resolved with the current URL.
    */
    getCurrentUrl(): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the current page's title.
     * @return  A promise that will be
    resolved with the current page's title.
    */
    getTitle(): undefined.Promise<string>;

    /**
     * Schedule a command to find an element on the page. If the element cannot be
     * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned
    by the driver. Unlike other commands, this error cannot be suppressed. In
    other words, scheduling a command to find an element doubles as an assert
    that the element is present on the page. To test whether an element is
    present on the page, use {@link #isElementPresent} instead.

    The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:

    var e1 = driver.findElement(By.id('foo'));
    var e2 = driver.findElement({id:'foo'});

    You may also provide a custom locator function, which takes as input
    this WebDriver instance and returns a {
     * @link  webdriver.WebElement}, or a
    promise that will resolve to a WebElement. For example, to find the first
    visible link on a page, you could write:

    var link = driver.findElement(firstVisibleLink);

    function firstVisibleLink(driver) {
    var links = driver.findElements(By.tagName('a'));
    return webdriver.promise.filter(links, function(link) {
    return links.isDisplayed();
    }).then(function(visibleLinks) {
    return visibleLinks[0];
    });
    }

    When running in the browser, a WebDriver cannot manipulate DOM elements
    directly; it may do so only through a {
     * @link  webdriver.WebElement} reference.
    This function may be used to generate a WebElement from a DOM element. A
    reference to the DOM element will be stored in a known location and this
    driver will attempt to retrieve it through {
     * @link  #executeScript}. If the
    element cannot be found (eg, it belongs to a different document than the
    one this instance is currently focused on), a
    {
     * @link  bot.ErrorCode.NO_SUCH_ELEMENT} error will be returned.
     * @param  The
    locator to use.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(
        locatorOrElement: webdriver$Locator | By$Hash | webdriver$WebElement | Function): webdriver$WebElementPromise;

    /**
     * Schedules a command to test if an element is present on the page.
     * 
    If given a DOM element, this function will check if it belongs to the
    document the driver is currently focused on. Otherwise, the function will
    test if at least one element can be found with the given search criteria.
     * @param  )} locatorOrElement The locator to use, or the actual
    DOM element to be located by the server.
     * @return  A promise that will resolve
    with whether the element is present on the page.
    */
    isElementPresent(
        locatorOrElement: webdriver$Locator | By$Hash | webdriver$WebElement | Function): undefined.Promise<boolean>;

    /**
     * Schedule a command to search for multiple elements on the page.
     * @param  The locator
    strategy to use when searching for the element.
     * @return  A
    promise that will resolve to an array of WebElements.
    */
    findElements(
        locator: webdriver$Locator | By$Hash | Function): undefined.Promise<webdriver$WebElement[]>;

    /**
     * Schedule a command to take a screenshot. The driver makes a best effort to
     * return a screenshot of the following, in order of preference:
    <ol>
       <li>Entire page
       <li>Current window
       <li>Visible portion of the current frame
       <li>The screenshot of the entire display containing the browser
    </ol>
     * @return  A promise that will be
    resolved to the screenshot as a base-64 encoded PNG.
    */
    takeScreenshot(): undefined.Promise<string>;

    /**
     * 
     * @return  The options interface for this
    instance.
    */
    manage(): webdriver$WebDriverOptions;

    /**
     * 
     * @return  The navigation interface for this
    instance.
    */
    navigate(): webdriver$WebDriverNavigation;

    /**
     * 
     * @return  The target locator interface for
    this instance.
    */
    switchTo(): webdriver$WebDriverTargetLocator
}

declare interface webdriver$IWebElementId {
    ELEMENT: string
}


/**
 * Defines an object that can be asynchronously serialized to its WebDriver
 * wire representation.
 * @constructor  * 
 * @template  
 */
declare interface webdriver$Serializable<T>{

    /**
     * Returns either this instance's serialized represention, if immediately
     * available, or a promise for its serialized representation. This function is
    conceptually equivalent to objects that have a {@code toJSON()} property,
    except the serialize() result may be a promise or an object containing a
    promise (which are not directly JSON friendly).
     * @return  This instance's serialized wire format.
    */
    serialize(): T | undefined.IThenable<T >
}


/**
 * Represents a DOM element. WebElements can be found by searching from the
 * document root using a {@code webdriver.WebDriver} instance, or by searching
under another {@code webdriver.WebElement}:
<pre><code>
   driver.get('http://www.google.com');
   var searchForm = driver.findElement(By.tagName('form'));
   var searchBox = searchForm.findElement(By.name('q'));
   searchBox.sendKeys('webdriver');
</code></pre>

The WebElement is implemented as a promise for compatibility with the promise
API. It will always resolve itself when its internal state has been fully
resolved and commands may be issued against the element. This can be used to
catch errors when an element cannot be located on the page:
<pre><code>
   driver.findElement(By.id('not-there')).then(function(element) {
     alert('Found an element that was not expected to be there!');
   }, function(error) {
     alert('The element was not found, as expected');
   });
</code></pre>
*/
declare interface webdriver$IWebElement {

    /**
     * Schedules a command to click on this element.
     * @return  A promise that will be resolved when
    the click command has completed.
    */
    click(): undefined.Promise<void>,

        /**
         * Schedules a command to type a sequence on the DOM element represented by this
         * instance.
        <p/>
        Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
        processed in the keysequence, that key state is toggled until one of the
        following occurs:
        <ul>
        <li>The modifier key is encountered again in the sequence. At this point the
        state of the key is toggled (along with the appropriate keyup/down events).
        </li>
        <li>The {@code webdriver.Key.NULL} key is encountered in the sequence. When
        this key is encountered, all modifier keys current in the down state are
        released (with accompanying keyup events). The NULL key can be used to
        simulate common keyboard shortcuts:
        <code>
             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");
        </code></li>
        <li>The end of the keysequence is encountered. When there are no more keys
        to type, all depressed modifier keys are released (with accompanying keyup
        events).
        </li>
        </ul>
        <strong>Note:</strong> On browsers where native keyboard events are not yet
        supported (e.g. Firefox on OS X), key events will be synthesized. Special
        punctionation keys will be synthesized according to a standard QWERTY en-us
        keyboard layout.
         * @param  The sequence of keys to
        type. All arguments will be joined into a single sequence (var_args is
        permitted for convenience).
         * @return  A promise that will be resolved when all
        keys have been typed.
        */
        sendKeys(...var_args: string[]): undefined.Promise<void>,

        /**
         * Schedules a command to query for the tag/node name of this element.
         * @return  A promise that will be resolved with the
        element's tag name.
        */
        getTagName(): undefined.Promise<string>,

        /**
         * Schedules a command to query for the computed style of the element
         * represented by this instance. If the element inherits the named style from
        its parent, the parent will be queried for its value.  Where possible, color
        values will be converted to their hex representation (e.g. #00ff00 instead of
        rgb(0, 255, 0)).
        <p/>
        <em>Warning:</em> the value returned will be as the browser interprets it, so
        it may be tricky to form a proper assertion.
         * @param  The name of the CSS style property to look
        up.
         * @return  A promise that will be resolved with the
        requested CSS value.
        */
        getCssValue(cssStyleProperty: string): undefined.Promise<string>,

        /**
         * Schedules a command to query for the value of the given attribute of the
         * element. Will return the current value even if it has been modified after the
        page has been loaded. More exactly, this method will return the value of the
        given attribute, unless that attribute is not present, in which case the
        value of the property with the same name is returned. If neither value is
        set, null is returned. The "style" attribute is converted as best can be to a
        text representation with a trailing semi-colon. The following are deemed to
        be "boolean" attributes and will be returned as thus:

        <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,
        defaultchecked, defaultselected, defer, disabled, draggable, ended,
        formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
        loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
        paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
        selected, spellcheck, truespeed, willvalidate

        <p>Finally, the following commonly mis-capitalized attribute/property names
        are evaluated as expected:
        <ul>
           <li>"class"
           <li>"readonly"
        </ul>
         * @param  The name of the attribute to query.
         * @return  A promise that will be resolved with the
        attribute's value.
        */
        getAttribute(attributeName: string): undefined.Promise<string>,

        /**
         * Get the visible (i.e. not hidden by CSS) innerText of this element, including
         * sub-elements, without any leading or trailing whitespace.
         * @return  A promise that will be resolved with the
        element's visible text.
        */
        getText(): undefined.Promise<string>,

        /**
         * Schedules a command to compute the size of this element's bounding box, in
         * pixels.
         * @return  A promise that will be resolved with the
        element's size as a {
         * @code  {width:number, height:number}} object.
        */
        getSize(): undefined.Promise<webdriver$ISize>,

        /**
         * Schedules a command to compute the location of this element in page space.
         * @return  A promise that will be resolved to the
        element's location as a {
         * @code  {x:number, y:number}} object.
        */
        getLocation(): undefined.Promise<webdriver$ILocation>,

        /**
         * Schedules a command to query whether the DOM element represented by this
         * instance is enabled, as dicted by the {@code disabled} attribute.
         * @return  A promise that will be resolved with
        whether this element is currently enabled.
        */
        isEnabled(): undefined.Promise<boolean>,

        /**
         * Schedules a command to query whether this element is selected.
         * @return  A promise that will be resolved with
        whether this element is currently selected.
        */
        isSelected(): undefined.Promise<boolean>,

        /**
         * Schedules a command to submit the form containing this element (or this
         * element if it is a FORM element). This command is a no-op if the element is
        not contained in a form.
         * @return  A promise that will be resolved when
        the form has been submitted.
        */
        submit(): undefined.Promise<void>,

        /**
         * Schedules a command to clear the {@code value} of this element. This command
         * has no effect if the underlying DOM element is neither a text INPUT element
        nor a TEXTAREA element.
         * @return  A promise that will be resolved when
        the element has been cleared.
        */
        clear(): undefined.Promise<void>,

        /**
         * Schedules a command to test whether this element is currently displayed.
         * @return  A promise that will be resolved with
        whether this element is currently visible on the page.
        */
        isDisplayed(): undefined.Promise<boolean>,

        /**
         * Schedules a command to retrieve the outer HTML of this element.
         * @return  A promise that will be resolved with
        the element's outer HTML.
        */
        getOuterHtml(): undefined.Promise<string>,

        /**
         * 
         * @return  A promise
        that resolves to this element's JSON representation as defined by the
        WebDriver wire protocol.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol
        */
        getId(): undefined.Promise<webdriver$IWebElementId>,

        /**
         * Schedules a command to retrieve the inner HTML of this element.
         * @return  A promise that will be resolved with the
        element's inner HTML.
        */
        getInnerHtml(): undefined.Promise<string >
}

declare interface webdriver$IWebElementFinders {

    /**
     * Schedule a command to find a descendant of this element. If the element
     * cannot be found, a {@code bot.ErrorCode.NO_SUCH_ELEMENT} result will
    be returned by the driver. Unlike other commands, this error cannot be
    suppressed. In other words, scheduling a command to find an element doubles
    as an assert that the element is present on the page. To test whether an
    element is present on the page, use {@code #isElementPresent} instead.

    <p>The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:
    <code><pre>
    var e1 = element.findElement(By.id('foo'));
    var e2 = element.findElement({id:'foo'});
    </pre></code>

    <p>You may also provide a custom locator function, which takes as input
    this WebDriver instance and returns a {
     * @link  webdriver.WebElement}, or a
    promise that will resolve to a WebElement. For example, to find the first
    visible link on a page, you could write:
    <code><pre>
    var link = element.findElement(firstVisibleLink);

    function firstVisibleLink(element) {
    var links = element.findElements(By.tagName('a'));
    return webdriver.promise.filter(links, function(link) {
    return links.isDisplayed();
    }).then(function(visibleLinks) {
    return visibleLinks[0];
    });
    }
    </pre></code>
     * @param  The
    locator strategy to use when searching for the element.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(locator: webdriver$Locator | By$Hash | Function): webdriver$WebElementPromise,

        /**
         * Schedules a command to test if there is at least one descendant of this
         * element that matches the given search criteria.
         * @param  The
        locator strategy to use when searching for the element.
         * @return  A promise that will be
        resolved with whether an element could be located on the page.
        */
        isElementPresent(locator: webdriver$Locator | By$Hash | Function): undefined.Promise<boolean>,

        /**
         * Schedules a command to find all of the descendants of this element that
         * match the given search criteria.
         * @param  The
        locator strategy to use when searching for the elements.
         * @return  A
        promise that will resolve to an array of WebElements.
        */
        findElements(
            locator: webdriver$Locator | By$Hash | Function): undefined.Promise<webdriver$WebElement[] >
}


/**
 * Represents a DOM element. WebElements can be found by searching from the
 * document root using a {@link webdriver.WebDriver} instance, or by searching
under another WebElement:

     driver.get('http://www.google.com');
     var searchForm = driver.findElement(By.tagName('form'));
     var searchBox = searchForm.findElement(By.name('q'));
     searchBox.sendKeys('webdriver');

The WebElement is implemented as a promise for compatibility with the promise
API. It will always resolve itself when its internal state has been fully
resolved and commands may be issued against the element. This can be used to
catch errors when an element cannot be located on the page:

     driver.findElement(By.id('not-there')).then(function(element) {
       alert('Found an element that was not expected to be there!');
     }, function(error) {
       alert('The element was not found, as expected');
     });
 * @extends  {webdriver.Serializable.<webdriver.WebElement.Id>}
*/
declare class WebElement mixins Serializable<webdriver$IWebElementId>{

    /**
     * 
     * @param  The parent WebDriver instance for this
    element.
     * @param  .WebElement.Id)} id The server-assigned opaque ID for the
    underlying DOM element.
     * @constructor  
    */
    constructor(driver: webdriver$WebDriver, id: undefined.Promise<webdriver$IWebElementId>| webdriver$IWebElementId): this;

    /**
     * Wire protocol definition of a WebElement ID.
     * @typedef  * 
     * @see  https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol
     */
    Id: webdriver$IWebElementId;

    /**
     * The property key used in the wire protocol to indicate that a JSON object
     * contains the ID of a WebElement.
     * @type  * 
     * @const  
     */
    ELEMENT_KEY: string;

    /**
     * 
     * @return  The parent driver for this instance.
     */
    getDriver(): webdriver$WebDriver;

    /**
     * Schedule a command to find a descendant of this element. If the element
     * cannot be found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will
    be returned by the driver. Unlike other commands, this error cannot be
    suppressed. In other words, scheduling a command to find an element doubles
    as an assert that the element is present on the page. To test whether an
    element is present on the page, use {@link #isElementPresent} instead.

    The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:

    var e1 = element.findElement(By.id('foo'));
    var e2 = element.findElement({id:'foo'});

    You may also provide a custom locator function, which takes as input
    this WebDriver instance and returns a {
     * @link  webdriver.WebElement}, or a
    promise that will resolve to a WebElement. For example, to find the first
    visible link on a page, you could write:

    var link = element.findElement(firstVisibleLink);

    function firstVisibleLink(element) {
    var links = element.findElements(By.tagName('a'));
    return webdriver.promise.filter(links, function(link) {
    return links.isDisplayed();
    }).then(function(visibleLinks) {
    return visibleLinks[0];
    });
    }
     * @param  The
    locator strategy to use when searching for the element.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(locator: webdriver$Locator | By$Hash | Function): webdriver$WebElementPromise;

    /**
     * Schedules a command to test if there is at least one descendant of this
     * element that matches the given search criteria.
     * @param  The
    locator strategy to use when searching for the element.
     * @return  A promise that will be
    resolved with whether an element could be located on the page.
    */
    isElementPresent(locator: webdriver$Locator | By$Hash | Function): undefined.Promise<boolean>;

    /**
     * Schedules a command to find all of the descendants of this element that
     * match the given search criteria.
     * @param  The
    locator strategy to use when searching for the elements.
     * @return  A
    promise that will resolve to an array of WebElements.
    */
    findElements(
        locator: webdriver$Locator | By$Hash | Function): undefined.Promise<webdriver$WebElement[]>;

    /**
     * Schedules a command to click on this element.
     * @return  A promise that will be resolved
    when the click command has completed.
    */
    click(): undefined.Promise<void>;

    /**
     * Schedules a command to type a sequence on the DOM element represented by this
     * instance.

    Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
    processed in the keysequence, that key state is toggled until one of the
    following occurs:

    - The modifier key is encountered again in the sequence. At this point the
       state of the key is toggled (along with the appropriate keyup/down events).
    - The {@link webdriver.Key.NULL} key is encountered in the sequence. When
       this key is encountered, all modifier keys current in the down state are
       released (with accompanying keyup events). The NULL key can be used to
       simulate common keyboard shortcuts:

             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");

    - The end of the keysequence is encountered. When there are no more keys
       to type, all depressed modifier keys are released (with accompanying keyup
       events).

    If this element is a file input ({@code <input type="file">}), the
    specified key sequence should specify the path to the file to attach to
    the element. This is analgous to the user clicking "Browse..." and entering
    the path into the file select dialog.

         var form = driver.findElement(By.css('form'));
         var element = form.findElement(By.css('input[type=file]'));
         element.sendKeys('/path/to/file.txt');
         form.submit();

    For uploads to function correctly, the entered path must reference a file
    on the _browser's_ machine, not the local machine running this script. When
    running against a remote Selenium server, a {@link webdriver.FileDetector}
    may be used to transparently copy files to the remote machine before
    attempting to upload them in the browser.

    __Note:__ On browsers where native keyboard events are not supported
    (e.g. Firefox on OS X), key events will be synthesized. Special
    punctionation keys will be synthesized according to a standard QWERTY en-us
    keyboard layout.<string>)} var_args The sequence
        of keys to type. All arguments will be joined into a single sequence.
     * @return  A promise that will be resolved
    when all keys have been typed.
    */
    sendKeys(
        ...var_args: Array<string | undefined.Promise<string >> ): undefined.Promise<void>;

    /**
     * Schedules a command to query for the tag/node name of this element.
     * @return  A promise that will be
    resolved with the element's tag name.
    */
    getTagName(): undefined.Promise<string>;

    /**
     * Schedules a command to query for the computed style of the element
     * represented by this instance. If the element inherits the named style from
    its parent, the parent will be queried for its value.  Where possible, color
    values will be converted to their hex representation (e.g. #00ff00 instead of
    rgb(0, 255, 0)).

    _Warning:_ the value returned will be as the browser interprets it, so
    it may be tricky to form a proper assertion.
     * @param  The name of the CSS style property to look
    up.
     * @return  A promise that will be
    resolved with the requested CSS value.
    */
    getCssValue(cssStyleProperty: string): undefined.Promise<string>;

    /**
     * Schedules a command to query for the value of the given attribute of the
     * element. Will return the current value, even if it has been modified after
    the page has been loaded. More exactly, this method will return the value of
    the given attribute, unless that attribute is not present, in which case the
    value of the property with the same name is returned. If neither value is
    set, null is returned (for example, the "value" property of a textarea
    element). The "style" attribute is converted as best can be to a
    text representation with a trailing semi-colon. The following are deemed to
    be "boolean" attributes and will return either "true" or null:

    async, autofocus, autoplay, checked, compact, complete, controls, declare,
    defaultchecked, defaultselected, defer, disabled, draggable, ended,
    formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
    loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
    paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
    selected, spellcheck, truespeed, willvalidate

    Finally, the following commonly mis-capitalized attribute/property names
    are evaluated as expected:

    - "class"
    - "readonly"
     * @param  The name of the attribute to query.
     * @return  A promise that will be
    resolved with the attribute's value. The returned value will always be
    either a string or null.
    */
    getAttribute(attributeName: string): undefined.Promise<string>;

    /**
     * Get the visible (i.e. not hidden by CSS) innerText of this element, including
     * sub-elements, without any leading or trailing whitespace.
     * @return  A promise that will be
    resolved with the element's visible text.
    */
    getText(): undefined.Promise<string>;

    /**
     * Schedules a command to compute the size of this element's bounding box, in
     * pixels.
     * @return  A
    promise that will be resolved with the element's size as a
    {
     * @code  {width:number, height:number}} object.
    */
    getSize(): undefined.Promise<webdriver$ISize>;

    /**
     * Schedules a command to compute the location of this element in page space.
     * @return  A promise that
    will be resolved to the element's location as a
    {
     * @code  {x:number, y:number}} object.
    */
    getLocation(): undefined.Promise<webdriver$ILocation>;

    /**
     * Schedules a command to query whether the DOM element represented by this
     * instance is enabled, as dicted by the {@code disabled} attribute.
     * @return  A promise that will be
    resolved with whether this element is currently enabled.
    */
    isEnabled(): undefined.Promise<boolean>;

    /**
     * Schedules a command to query whether this element is selected.
     * @return  A promise that will be
    resolved with whether this element is currently selected.
    */
    isSelected(): undefined.Promise<boolean>;

    /**
     * Schedules a command to submit the form containing this element (or this
     * element if it is a FORM element). This command is a no-op if the element is
    not contained in a form.
     * @return  A promise that will be resolved
    when the form has been submitted.
    */
    submit(): undefined.Promise<void>;

    /**
     * Schedules a command to clear the {@code value} of this element. This command
     * has no effect if the underlying DOM element is neither a text INPUT element
    nor a TEXTAREA element.
     * @return  A promise that will be resolved
    when the element has been cleared.
    */
    clear(): undefined.Promise<void>;

    /**
     * Schedules a command to test whether this element is currently displayed.
     * @return  A promise that will be
    resolved with whether this element is currently visible on the page.
    */
    isDisplayed(): undefined.Promise<boolean>;

    /**
     * Schedules a command to retrieve the outer HTML of this element.
     * @return  A promise that will be
    resolved with the element's outer HTML.
    */
    getOuterHtml(): undefined.Promise<string>;

    /**
     * 
     * @return  A promise
    that resolves to this element's JSON representation as defined by the
    WebDriver wire protocol.
     * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol
    */
    getId(): undefined.Promise<webdriver$IWebElementId>;

    /**
     * Returns the raw ID string ID for this element.
     * @return  <string>} A promise that resolves to this
    element's raw ID as a string value.
     * @package  
    */
    getRawId(): undefined.Promise<string>;

    /**
     * 
     * @override  
     */
    serialize(): undefined.Promise<webdriver$IWebElementId>;

    /**
     * Schedules a command to retrieve the inner HTML of this element.
     * @return  A promise that will be resolved with the
    element's inner HTML.
    */
    getInnerHtml(): undefined.Promise<string>;

    /**
     * Compares to WebElements for equality.
     * @param  A WebElement.
     * @param  A WebElement.
     * @return  A promise that will be resolved to
    whether the two WebElements are equal.
    */
    equals(a: webdriver$WebElement, b: webdriver$WebElement): undefined.Promise<boolean >
}


/**
 * WebElementPromise is a promise that will be fulfilled with a WebElement.
 * This serves as a forward proxy on WebElement, allowing calls to be
scheduled without directly on this instance before the underlying
WebElement has been fulfilled. In other words, the following two statements
are equivalent:
<pre><code>
     driver.findElement({id: 'my-button'}).click();
     driver.findElement({id: 'my-button'}).then(function(el) {
       return el.click();
     });
</code></pre>
 * @param  The parent WebDriver instance for this
element.
 * @param  A promise
that will resolve to the promised element.
 * @constructor  * 
 * @extends  {webdriver.WebElement}
 * @implements  {webdriver.promise.Thenable.<!webdriver.WebElement>}
 * @final  
*/
declare class WebElementPromise mixins WebElement, undefined.IThenable<webdriver$WebElement>{

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process. This method is a no-op if the promise has alreayd been resolved.
     * @param  The reason this promise is being cancelled.
     */
    cancel(opt_reason?: string): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: webdriver$WebElement) => undefined.Promise<R>,
        opt_errback?: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: webdriver$WebElement) => R,
        opt_errback?: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: () => any): undefined.Promise<R >
}


declare var npm$namespace$By: {
        className: typeof By$className,
        css: typeof By$css,
        id: typeof By$id,
        linkText: typeof By$linkText,
        js: typeof By$js,
        name: typeof By$name,
        partialLinkText: typeof By$partialLinkText,
        tagName: typeof By$tagName,
        xpath: typeof By$xpath,
    }
    /**
     * Locates elements that have a specific class name. The returned locator
     * is equivalent to searching for elements with the CSS selector ".clazz".
     * @param  The class name to search for.
     * @return  The new locator.
     * @see  http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
     * @see  http://www.w3.org/TR/CSS2/selector.html#class-html
     */
declare function By$className(value: string): webdriver$Locator


/**
 * Locates elements using a CSS selector. For browsers that do not support
 * CSS selectors, WebDriver implementations may return an
{
 * @linkplain  bot.Error.State.INVALID_SELECTOR invalid selector} error. An
implementation may, however, emulate the CSS selector API.
 * @param  The CSS selector to use.
 * @return  The new locator.
 * @see  http://www.w3.org/TR/CSS2/selector.html
*/
declare function By$css(value: string): webdriver$Locator


/**
 * Locates an element by its ID.
 * @param  The ID to search for.
 * @return  The new locator.
 */
declare function By$id(value: string): webdriver$Locator


/**
 * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
 * text} matches the given string.
 * @param  The link text to search for.
 * @return  The new locator.
 */
declare function By$linkText(value: string): webdriver$Locator


/**
 * Locates an elements by evaluating a
 * {
 * @linkplain  webdriver.WebDriver#executeScript JavaScript expression}.
The result of this expression must be an element or list of elements.
 * @param  The script to execute.
 * @param  The arguments to pass to the script.
 * @return  A new,
JavaScript-based locator function.
*/
declare function By$js(
    script: any,
    ...var_args: any[]): (WebDriver: webdriver$WebDriver) => undefined.Promise<any >


    /**
     * Locates elements whose {@code name} attribute has the given value.
     * @param  The name attribute to search for.
     * @return  The new locator.
     */
    declare function By$name(value: string): webdriver$Locator


/**
 * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
 * text} contains the given substring.
 * @param  The substring to check for in a link's visible text.
 * @return  The new locator.
 */
declare function By$partialLinkText(value: string): webdriver$Locator


/**
 * Locates elements with a given tag name. The returned locator is
 * equivalent to using the
[getElementsByTagName](https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName)
DOM function.
 * @param  The substring to check for in a link's visible text.
 * @return  The new locator.
 * @see  http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html
*/
declare function By$tagName(value: string): webdriver$Locator


/**
 * Locates elements matching a XPath selector. Care should be taken when
 * using an XPath selector with a {@link webdriver.WebElement} as WebDriver
will respect the context in the specified in the selector. For example,
given the selector {@code "//div"}, WebDriver will search from the
document root regardless of whether the locator was used with a
WebElement.
 * @param  The XPath selector to use.
 * @return  The new locator.
 * @see  http://www.w3.org/TR/xpath/
*/
declare function By$xpath(value: string): webdriver$Locator


/**
 * Short-hand expressions for the primary element locator strategies.
 * For example the following two statements are equivalent:

     var e1 = driver.findElement(webdriver.By.id('foo'));
     var e2 = driver.findElement({id: 'foo'});

Care should be taken when using JavaScript minifiers (such as the
Closure compiler), as locator hashes will always be parsed using
the un-obfuscated properties listed.
 * @typedef  {className: string}|
{css: string}|
{id: string}|
{js: string}|
{linkText: string}|
{name: string}|
{partialLinkText: string}|
{tagName: string}|
{xpath: string})}
*/
declare type By$Hash = {
        className: string
    } |
    {
        css: string
    } |
    {
        id: string
    } |
    {
        js: string
    } |
    {
        linkText: string
    } |
    {
        name: string
    } |
    {
        partialLinkText: string
    } |
    {
        tagName: string
    } |
    {
        xpath: string
    };


/**
 * An element locator.
 */
declare class Locator {

    /**
     * An element locator.
     * @param  The type of strategy to use for this locator.
     * @param  The search target of this locator.
     * @constructor  
     */
    constructor(using: string, value: string): this;

    /**
     * Maps {@link webdriver.By.Hash} keys to the appropriate factory function.
     * @type  * 
     * @const  
     */
    Strategy: {
        className: typeof undefined,
        css: typeof undefined,
        id: typeof undefined,
        js: typeof undefined,
        linkText: typeof undefined,
        name: typeof undefined,
        partialLinkText: typeof undefined,
        tagName: typeof undefined,
        xpath: typeof undefined
    };

    /**
     * Verifies that a {@code value} is a valid locator to use for searching for
     * elements on the page.
     * @param  The value to check is a valid locator.
     * @return  A valid locator object or function.
     * @throws  {TypeError} If the given value is an invalid locator.
     */
    checkLocator(value: any): webdriver$Locator | Function;

    /**
     * The search strategy to use when searching for an element.
     * @type  
     */
    using: string;

    /**
     * The search target for this locator.
     * @type  
     */
    value: string;

    /**
     * 
     * @return  String representation of this locator. 
     */
    toString(): string
}


/**
 * Contains information about a WebDriver session.
 */
declare class Session {

    /**
     * 
     * @param  The session ID.
     * @param  The session
    capabilities.
     * @constructor  
    */
    constructor(id: string, capabilities: webdriver$Capabilities): this;
    constructor(id: string, capabilities: any): this;

    /**
     * 
     * @return  This session's ID.
     */
    getId(): string;

    /**
     * 
     * @return  This session's capabilities.
     */
    getCapabilities(): webdriver$Capabilities;

    /**
     * Retrieves the value of a specific capability.
     * @param  The capability to retrieve.
     * @return  The capability value.
     */
    getCapability(key: string): any;

    /**
     * Returns the JSON representation of this object, which is just the string
     * session ID.
     * @return  The JSON representation of this Session.
     */
    toJSON(): string
}
declare var npm$namespace$testing: {
        describe: typeof testing$describe,
        xdescribe: typeof testing$xdescribe,
        after: typeof testing$after,
        afterEach: typeof testing$afterEach,
        before: typeof testing$before,
        beforeEach: typeof testing$beforeEach,
        it: typeof testing$it,
        iit: typeof testing$iit,
        xit: typeof testing$xit,
    }
    /**
     * Registers a new test suite.
     * @param name The suite name.
     * @param fn The suite function, or {
     * @code  undefined} to define a pending test suite.
     */
declare function testing$describe(name: string, fn: Function): void


/**
 * Defines a suppressed test suite.
 * @param name The suite name.
 * @param fn The suite function, or {
 * @code  undefined} to define a pending test suite.
 */
declare function testing$xdescribe(name: string, fn: Function): void


/**
 * Register a function to call after the current suite finishes.
 * @param fn 
 */
declare function testing$after(fn: Function): void


/**
 * Register a function to call after each test in a suite.
 * @param fn 
 */
declare function testing$afterEach(fn: Function): void


/**
 * Register a function to call before the current suite starts.
 * @param fn 
 */
declare function testing$before(fn: Function): void


/**
 * Register a function to call before each test in a suite.
 * @param fn 
 */
declare function testing$beforeEach(fn: Function): void


/**
 * Add a test to the current suite.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$it(name: string, fn: Function): void


/**
 * An alias for {@link #it()} that flags the test as the only one that should
 * be run within the current suite.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$iit(name: string, fn: Function): void


/**
 * Adds a test to the current suite while suppressing it so it is not run.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$xit(name: string, fn: Function): voiddeclare module 'selenium-webdriver/chrome' {
    declare module.exports: typeof chrome
}
declare module 'selenium-webdriver/firefox' {
    declare module.exports: typeof firefox
}
declare module 'selenium-webdriver/executors' {
    declare module.exports: typeof executors
}
declare module 'selenium-webdriver' {
    declare module.exports: typeof webdriver
}
declare module 'selenium-webdriver/testing' {
    declare module.exports: typeof testing
}