// @flow
/**
 * Flowtype definitions for uglify-js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'uglify-js' {


    declare     var npm$namespace$UglifyJS: {
        minify: typeof UglifyJS$minify,
        parse: typeof UglifyJS$parse,
        Compressor: typeof UglifyJS$Compressor,
    }
    declare interface UglifyJS$Tokenizer {

        /**
         * The type of this token.
         * Can be "num", "string", "regexp", "operator", "punc", "atom", "name", "keyword", "comment1" or "comment2".
        "comment1" and "comment2" are for single-line, respectively multi-line comments.
        */
        type: string,

            /**
             * The name of the file where this token originated from. Useful when compressing multiple files at once to generate the proper source map.
             */
            file: string,

            /**
             * The "value" of the token.
             * That's additional information and depends on the token type: "num", "string" and "regexp" tokens you get their literal value.
            - For "operator" you get the operator.
            - For "punc" it's the punctuation sign (parens, comma, semicolon etc).
            - For "atom", "name" and "keyword" it's the name of the identifier
            - For comments it's the body of the comment (excluding the initial "//" and "/".
            */
            value: string,

            /**
             * The line number of this token in the original code.
             * 1-based index.
             */
            line: number,

            /**
             * The column number of this token in the original code.
             * 0-based index.
             */
            col: number,

            /**
             * Short for "newline before", it's a boolean that tells us whether there was a newline before this node in the original source. It helps for automatic semicolon insertion.
             * For multi-line comments in particular this will be set to true if there either was a newline before this comment, or  * if this comment contains a newline.
             */
            nlb: boolean,

            /**
             * This doesn't apply for comment tokens, but for all other token types it will be an array of comment tokens that were found before.
             */
            comments_before: string[]
    }

    declare interface UglifyJS$AST_Node {
        start: UglifyJS$AST_Node,
            end: UglifyJS$AST_Node,
            transform(tt: UglifyJS$TreeTransformer): UglifyJS$AST_Toplevel
    }

    declare type UglifyJS$AST_Toplevel = {
        figure_out_scope(): void,
        compute_char_frequency(): void,
        mangle_names(): void,
        print(stream: UglifyJS$OutputStream): void,
        print_to_string(options?: UglifyJS$BeautifierOptions): string
    } & UglifyJS$AST_Node


    declare interface UglifyJS$MinifyOptions {
        spidermonkey?: boolean,
            outSourceMap?: string,
            sourceRoot?: string,
            inSourceMap?: string,
            fromString?: boolean,
            warnings?: boolean,
            mangle?: Object,
            output?: UglifyJS$MinifyOutput,
            compress?: Object
    }

    declare interface UglifyJS$MinifyOutput {
        code: string,
            map: string
    }

    declare     function UglifyJS$minify(
        files: string | Array<string>,
        options?: UglifyJS$MinifyOptions): UglifyJS$MinifyOutput

    declare interface UglifyJS$ParseOptions {
        strict?: boolean,
            filename?: string,
            toplevel?: UglifyJS$AST_Toplevel
    }


    /**
     * The parser creates a custom abstract syntax tree given a piece of JavaScript code.
     * Perhaps you should read about the AST first.
     */
    declare     function UglifyJS$parse(code: string, options?: UglifyJS$ParseOptions): UglifyJS$AST_Toplevel

    declare interface UglifyJS$BeautifierOptions {

        /**
         * Start indentation on every line (only when `beautify`)
         */
        indent_start?: number,

            /**
             * Indentation level (only when `beautify`)
             */
            indent_level?: number,

            /**
             * Quote all keys in object literals?
             */
            quote_keys?: boolean,

            /**
             * Add a space after colon signs?
             */
            space_colon?: boolean,

            /**
             * Output ASCII-safe? (encodes Unicode characters as ASCII)
             */
            ascii_only?: boolean,

            /**
             * Escape "</script"?
             */
            inline_script?: boolean,

            /**
             * Informative maximum line width (for beautified output)
             */
            width?: number,

            /**
             * Maximum line length (for non-beautified output)
             */
            max_line_len?: number,

            /**
             * Output IE-safe code?
             */
            ie_proof?: boolean,

            /**
             * Beautify output?
             */
            beautify?: boolean,

            /**
             * Output a source map
             */
            source_map?: UglifyJS$SourceMapOptions,

            /**
             * Use brackets every time?
             */
            bracketize?: boolean,

            /**
             * Output comments?
             */
            comments?: boolean,

            /**
             * Use semicolons to separate statements? (otherwise, newlines)
             */
            semicolons?: boolean
    }

    declare interface UglifyJS$OutputStream {
        get(): string,
            toString(): string,
            indent(half?: boolean): void,
            indentation(): number,
            current_width(): number,
            should_break(): boolean,
            newline(): void,
            print(str: string): void,
            space(): void,
            comma(): void,
            colon(): void,
            last(): string,
            semicolon(): void,
            force_semicolon(): void,
            to_ascii(str: string): void,
            print_name(name: string): void,
            print_string(str: string): void,
            next_indent(): number,
            with_indent(col: number, func: Function): void,
            with_block(func: Function): void,
            with_parens(func: Function): void,
            with_square(func: Function): void,
            add_mapping(token: UglifyJS$AST_Node, name?: string): void,
            option(name: string): any,
            line(): number,
            col(): number,
            push_node(node: UglifyJS$AST_Node): void,
            pop_node(): UglifyJS$AST_Node,
            stack(): any,
            parent(n: number): UglifyJS$AST_Node
    }

    declare interface UglifyJS$SourceMapOptions {

        /**
         * The compressed file name
         */
        file?: string,

            /**
             * The root URL to the original sources
             */
            root?: string,

            /**
             * The input source map.
             * Useful when you compress code that was generated from some other source (possibly other programming language).
            If you have an input source map, pass it in this argument and UglifyJS will generate a mapping that maps back
            to the original source (as opposed to the compiled code that you are compressing).
            */
            orig?: Object | JSON
    }

    declare interface UglifyJS$SourceMap {
        add(
                source: string,
                gen_line: number,
                gen_col: number,
                orig_line: number,
                orig_col: number,
                name?: string): void,
            get(): MOZ_SourceMap.SourceMapGenerator,
            toString(): string
    }

    declare interface UglifyJS$CompressorOptions {
        sequences?: boolean,
            properties?: boolean,
            dead_code?: boolean,
            drop_debugger?: boolean,
            unsafe?: boolean,
            conditionals?: boolean,
            comparisons?: boolean,
            evaluate?: boolean,
            booleans?: boolean,
            loops?: boolean,
            unused?: boolean,
            hoist_funs?: boolean,
            hoist_vars?: boolean,
            if_return?: boolean,
            join_vars?: boolean,
            cascade?: boolean,
            side_effects?: boolean,
            warnings?: boolean,
            global_defs?: Object
    }


    /**
     * The compressor is a tree transformer which reduces the code size by applying various optimizations on the AST
     */
    declare     function UglifyJS$Compressor(options?: UglifyJS$CompressorOptions): UglifyJS$AST_Toplevel

    declare interface UglifyJS$TreeWalker {}

    declare type UglifyJS$visitor = (node: UglifyJS$AST_Node, descend: Function) => boolean;

    declare type UglifyJS$TreeTransformer = {} & UglifyJS$TreeWalker

    declare module.exports: typeof UglifyJS
}