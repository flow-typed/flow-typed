// @flow
/**
 * Flowtype definitions for alexa-sdk
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module '3d-bin-packing' {
    declare module.exports: typeof bws$packer
}
declare var ReactDataGrid: typeof undefined;
/**
 * <p> Cumulated lengths of current layer. </p>
 * 
<p> {@link Scrapped} represents an edge of the current layer under construction. </p>
 * @author  Bill Knechtel, <br>
Migrated and Refactored by Jeongho Nam <http://samchon.org>
*/
declare class Scrap {

    /**
     * Cumulated length on the X-axis in 3D.
     */
    cumx: number;

    /**
     * Cumulated length on the Z-axis in 3D.
     */
    cumz: number;

    /**
     * Default Constructor.
     */
    constructor(): this;

    /**
     * Initialization Constructor.
     * @param cumx Cumulated length on the x-axis.
     * @param cumz Cumulated length on the z-axis.
     */
    constructor(cumx: number, cumz: number): this
}
declare module 'packer' {

    /**
     * 
     * @brief  Packer, a solver of 3d bin packing with multiple wrappers.
     * @details  * <p> Packer is a facade class supporting packing operations in user side. You can solve a packing problem
    by constructing Packer class with {
     * @link  WrapperArray wrappers} and {
     * @link  InstanceArray instances} to
    pack and executing {
     * @link  optimize Packer.optimize()} method. </p>

    <p> In background side, deducting packing solution, those algorithms are used. </p>
    <ul>
    <li> <a href="http://betterwaysystems.github.io/packer/reference/AirForceBinPacking.pdf" target="_blank">
    Airforce Bin Packing; 3D pallet packing problem: A human intelligence-based heuristic approach </a>
    </li>
    <li> Genetic Algorithm </li>
    <li> Greedy and Back-tracking algorithm </li>
    </ul>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Packer mixins undefined.Entity {

        /**
         * Candidate wrappers who can contain instances.
         */
        wrapperArray: WrapperArray;

        /**
         * Instances trying to pack into the wrapper.
         */
        instanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param wrapperArray Candidate wrappers who can contain instances.
         * @param instanceArray Instances to be packed into some wrappers.
         */
        constructor(wrapperArray: WrapperArray, instanceArray: InstanceArray): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Get wrapperArray.
         */
        getWrapperArray(): WrapperArray;

        /**
         * Get instanceArray.
         */
        getInstanceArray(): InstanceArray;

        /**
         * <p> Deduct
         */
        optimize(): WrapperArray;

        /**
         * 
         * @brief  Initialize sequence list (gene_array).
         * @details  * <p> Deducts initial sequence list by such assumption: </p>

        <ul>
        <li> Cost of larger wrapper is less than smaller one, within framework of price per volume unit. </li>
        <ul>
        <li> Wrapper Larger: (price: $1,000, volume: 100cm^3 -> price per volume unit: $10 / cm^3) </li>
        <li> Wrapper Smaller: (price: $700, volume: 50cm^3 -> price per volume unit: $14 / cm^3) </li>
        <li> Larger's <u>cost</u> is less than Smaller, within framework of price per volume unit </li>
        </ul>
        </ul>

        <p> Method {
         * @link  initGenes initGenes()} constructs {
         * @link  WrapperGroup WrapperGroups} corresponding
        with the {
         * @link  wrapperArray} and allocates {
         * @link  instanceArray instances} to a {
         * @link  WrapperGroup},
        has the smallest <u>cost</u> between containbles. </p>

        <p> After executing packing solution by {
         * @link  WrapperGroup.optimize WrapperGroup.optimize()}, trying to
        {
         * @link  repack re-pack} each {
         * @link  WrapperGroup} to another type of {
         * @link  Wrapper}, deducts the best
        solution between them. It's the initial sequence list of genetic algorithm. </p>
         * @return  Initial sequence list.
        */
        initGenes(): GAWrapperArray;

        /**
         * Try to repack each wrappers to another type.
         * @param $wrappers Wrappers to repack.
         * @return  Re-packed wrappers.
         */
        repack($wrappers: WrapperArray): WrapperArray;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * Bridge of {@link Packer} for {@link InstanceForm repeated instances}.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class PackerForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Initializer Constructor.
         * @param instanceFormArray Form of Instances to pack.
         * @param wrapperArray Type of Wrappers to be used.
         */
        constructor(instanceFormArray: InstanceFormArray, wrapperArray: WrapperArray): this;
        construct(xml: undefined.XML): void;
        optimize(): WrapperArray;
        getInstanceFormArray(): InstanceFormArray;
        getWrapperArray(): WrapperArray;
        TAG(): string;
        toXML(): undefined.XML;
        toPacker(): Packer
    }

    /**
     * An array of {@link InstanceForm} objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceFormArray mixins undefined.EntityArrayCollection<InstanceForm>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createChild(xml: undefined.XML): InstanceForm;
        TAG(): string;
        CHILD_TAG(): string;

        /**
         * Convert {@link InstanceForm} objects to {@link InstanceArray}.
         * @return  An array of instance containing repeated instances in {
         * @link  InstanceForm} objects.
         */
        toInstanceArray(): InstanceArray
    }

    /**
     * <p> A repeated Instance. </p>
     * 
    <p> InstanceForm is an utility class for repeated {@link Instance}. It is designed for shrinking
    volume of network message I/O by storing {@link count repeated count}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class InstanceForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(instance?: boxologic$Instance, count?: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;
        key(): any;
        getInstance(): boxologic$Instance;
        getCount(): number;
        setCount(val: number): void;
        $name: string;
        $width: string;
        $height: string;
        $length: string;
        $count: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Repeated {@link instance} to {@link InstanceArray}.
         * @details  * <p> Contains the {
         * @link  instance repeated instance} to an {
         * @link  InstanceArray} to make
        {
         * @link  instance} to participate in the packing process. The returned {
         * @link  InstanceArray} will be
        registered on {
         * @link  Packer.instanceArray}.
         * @return  An array of instance containing repeated {
         * @link  instance}.
        */
        toInstanceArray(): InstanceArray
    }
    declare class WrapperArray mixins undefined.EntityArrayCollection<Wrapper>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrapper;

        /**
         * Get (calculate) price.
         */
        getPrice(): number;

        /**
         * Get (calculate) utilization rate.
         */
        getUtilization(): number;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }
    declare class GAWrapperArray mixins WrapperArray {
        instanceArray: InstanceArray;
        result: std.HashMap<string,
        WrapperGroup>;

        /**
         * Construct from instances.
         * @param instanceArray Instances to be wrapped.
         */
        constructor(instanceArray: InstanceArray): this;

        /**
         * 
         * @brief  Copy Constructor.
         */
        constructor(genes: GAWrapperArray): this;

        /**
         * 
         * @brief  Get optimization result.
         * @return  result map.
         */
        getResult(): std.HashMap<string,
        WrapperGroup>;
        less(obj: GAWrapperArray): boolean
    }

    /**
     * An interface of physical 3D-instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare type Instance = {

        /**
         * Get name.
         */
        getName(): string,

        /**
         * Get width, length on the X-axis in 3D.
         */
        getWidth(): number,

        /**
         * Get height, length on the Y-axis in 3D.
         */
        getHeight(): number,

        /**
         * Get length, length on the Z-axis in 3D.
         */
        getLength(): number,

        /**
         * Get (calculate) volume.
         * @return  width x height x length
         */
        getVolume(): number,

        /**
         * Set name.
         */
        setName(val: string): void,

        /**
         * Set width, length on the X-axis in 3D.
         */
        setWidth(val: number): void,

        /**
         * Set height, length on the Y-axis in 3D.
         */
        setHeight(val: number): void,

        /**
         * Set length, length on the Z-axis in 3D.
         */
        setLength(val: number): void,

        /**
         * <p> A type, identifier of derived class. </p>
         * 
        <h4> Derived types </h4>
        <ul>
        <li> {@link Product product} </li>
        <li> {@link Wrapper wrapper} </li>
        <ul>
        */
        TYPE(): string
    }

    /**
     * An array of Instance objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceArray mixins undefined.EntityArray<boxologic$Instance>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): boxologic$Instance;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }

    /**
     * A product.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Product mixins undefined.Entity, Instance {

        /**
         * <p> Name, key of the Product. </p>
         * 
        <p> The name must be unique because a name identifies a {@link Product}. </p>
        */
        name: string;

        /**
         * Width of the Product, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Product, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Product, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param name Name, identifier of the Product.
         * @param width Width, length on the X-axis in 3D.
         * @param height Height, length on the Y-axis in 3D.
         * @param length Length, length on the Z-axis in 3D.
         */
        constructor(name: string, width: number, height: number, length: number): this;

        /**
         * Key of a Product is its name.
         */
        key(): any;

        /**
         * 
         * @inheritdoc  
         */
        getName(): string;

        /**
         * 
         * @inheritdoc  
         */
        getWidth(): number;

        /**
         * 
         * @inheritdoc  
         */
        getHeight(): number;

        /**
         * 
         * @inheritdoc  
         */
        getLength(): number;

        /**
         * 
         * @inheritdoc  
         */
        getVolume(): number;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * <p> Wrap represents an act wrap(ping). </p>
     * 
    <p> {@link Wrap} is a class represents an act wrapping an {@link Instance} to an {@link Wrapper}.
    To represent the relationship, Wrap uses Bridge and Capsular patterns to links and intermediates
    relationship between Wrapper and Instance. </p>

    <p> Wrap also helps packing optimization and 3d-visualization with its own members
    {
     * @link  orientation} and position variables {
     * @link  x}, {
     * @link  y} and {
     * @link  z}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Wrap mixins undefined.Entity {

        /**
         * A wrapper wrapping the {@link instance}.
         */
        wrapper: Wrapper;

        /**
         * An instance wrapped into the {@link wrapper}.
         */
        instance: boxologic$Instance;

        /**
         * Coordinate-X of the instance placement in the wrapper.
         */
        x: number;

        /**
         * Coordinate-Y of the instance placement in the wrapper.
         */
        y: number;

        /**
         * Coordinate-Z of the instance placement in the wrapper.
         */
        z: number;

        /**
         * Placement orientation of wrapped {@link instance}.
         */
        orientation: number;

        /**
         * 
         */
        color: number;

        /**
         * Construct from a Wrapper.
         * @param wrapper A wrapper who will contain an instance.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from a Wrapper and Instance with its position and default orientation 1.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number): this;

        /**
         * Construct from a Wrapper and Instance with its position and orientation.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param orientation Placement orientation of wrapped {
         * @link  instance}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number, orientation: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Factory method of wrapped Instance.
         * @param type Type of contained Instance's type.
         */
        createInstance(type: string): boxologic$Instance;

        /**
         * Set orientation.
         * @param orientation Orientation code (1 to 6).
         */
        setOrientation(orientation: number): void;

        /**
         * Set position.
         * @param x Coordinate-X of the instance placement in the wrapper.
         * @param y Coordinate-Y of the instance placement in the wrapper.
         * @param z Coordinate-Z of the instance placement in the wrapper.
         */
        setPosition(x: number, y: number, z: number): void;

        /**
         * 
         * @brief  Estimate orientation by given size.
         * @param width Width by placement.
         * @param height Height by placement.
         * @param length Length by placement.
         */
        estimateOrientation(width: number, height: number, length: number): void;

        /**
         * 
         * @brief  Orientation change is occured in level of the packer.
         * @details  orientation Packer's new orientation.
         */
        changeWrapperOrientation(orientation: number): void;

        /**
         * Get wrapper.
         */
        getWrapper(): Wrapper;

        /**
         * Get instance.
         */
        getInstance(): boxologic$Instance;

        /**
         * Get x.
         */
        getX(): number;

        /**
         * Get y.
         */
        getY(): number;

        /**
         * Get z.
         */
        getZ(): number;

        /**
         * Get orientation.
         */
        getOrientation(): number;

        /**
         * Get width.
         */
        getWidth(): number;

        /**
         * Get height.
         */
        getHeight(): number;

        /**
         * Get length.
         */
        getLength(): number;

        /**
         * Get volume.
         */
        getVolume(): number;
        $instanceName: string;
        $layoutScale: string;
        $position: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * 
         * @param geometry 
         * @return  A shape and its boundary lines as 3D-objects.
         */
        toDisplayObjects(geometry: THREE$Geometry): std.Vector<THREE$Object3D >
    }

    /**
     * A wrapper wrapping instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Wrapper mixins undefined.EntityDeque<Wrap>, Instance {

        /**
         * <p> Name, key of the Wrapper. </p>
         * 
        <p> The name represents a type of Wrapper and identifies the Wrapper. </p>
        */
        name: string;

        /**
         * Price, cost of using an Wrapper.
         */
        price: number;

        /**
         * Width of the Wrapper, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Wrapper, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Wrapper, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * <p> Thickness, margin of a Wrapper causes shrinkness of containable volume. </p>
         * 
        <p> The thickness reduces each dimension's containable size (dimension - 2thickness),
        so finally, it reduces total containable volume (-8  thickness^3). </p>
        */
        thickness: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from members.
         * @param name Name, identifier of a Wrapper.
         * @param price Price, issued cost for a type of the Wrapper.
         * @param width Width, dimensional length on the X-axis in 3D.
         * @param height Height, dimensional length on the Y-axis in 3D.
         * @param length Length, dimensional length on the Z-axis in 3D.
         * @param thickness A thickness causes shrinkness on containable volume.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;
        construct(xml: undefined.XML): void;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrap;

        /**
         * Key of a Wrapper is its name.
         */
        key(): any;

        /**
         * Get name.
         */
        getName(): string;

        /**
         * Get price.
         */
        getPrice(): number;

        /**
         * Get width, length on X-axis in 3D.
         */
        getWidth(): number;

        /**
         * Get height, length on Y-axis in 3D.
         */
        getHeight(): number;

        /**
         * Get length, length on Z-axis in 3D.
         */
        getLength(): number;

        /**
         * Get thickness.
         */
        getThickness(): number;

        /**
         * <p> Get (calculate) containable width, length on the X-axis in 3D. </p>
         * 
        <p> Calculates containable width considering the {@link thickness}. </p>
         * @return  width - (2 x thickness)
        */
        getContainableWidth(): number;

        /**
         * <p> Get (calculate) containable height, length on the Y-axis in 3D. </p>
         * 
        <p> Calculates containable height considering the {@link thickness}. </p>
         * @return  height - (2 x thickness)
        */
        getContainableHeight(): number;

        /**
         * <p> Get (calculate) containable length, length on the Z-axis in 3D. </p>
         * 
        <p> Calculates containable length considering the {@link thickness}. </p>
         * @return  length - (2 x thickness)
        */
        getContainableLength(): number;

        /**
         * <p> Get (calculate) volume. </p>
         * 
        <h4> Notice </h4>
        <p> If {@link thickness} of the Wrapper is not 0, the volume does not mean containable volume.
        In that case, use {@link containableVolume} instead. </p>
         * @return  width x height x length
        */
        getVolume(): number;

        /**
         * <p> Get (calculate) containable volume. </p>
         * 
        <p> Calculates containable volume considering the {@link thickness}. </p>
         * @return  volume - {(2 x thickness) ^ 3}
        */
        getContainableVolume(): number;

        /**
         * Get utilization ratio of containable volume.
         * @return  utilization ratio.
         */
        getUtilization(): number;
        equal_to(obj: Wrapper): boolean;

        /**
         * <p> Wrapper is enough greater? </p>
         * 
        <p> Test whether the Wrapper is enough greater than an Instance to contain. </p>
         * @param instance An Instance to test.
         * @return  Enough greater or not.
        */
        containable(instance: boxologic$Instance): boolean;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * Set price.
         */
        setPrice(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * Set thickness.
         */
        setThickness(val: number): void;
        $name: string;
        $price: string;
        $width: string;
        $height: string;
        $length: string;
        $thickness: string;
        $scale: string;
        $spaceUtilization: string;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Convert to a canvas containing 3D elements. </p>
         * @param endIndex 
         * @return  A 3D-canvans printing the Wrapper and its children {
         * @link  Wrap wrapped}
        {
         * @link  Instance instances} with those boundary lines.
        */
        toCanvas(endIndex?: number): HTMLCanvasElement
    }

    /**
     * A group of {@link Wrapper Wrappers} with same type.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class WrapperGroup mixins WrapperArray {

        /**
         * <p> A sample, standard of the WrapperGroup. </p>
         * 
        <p> The sample represents what type of Wrappers are grouped into the WrapperGroup. </p>
        */
        sample: Wrapper;

        /**
         * Allocated instances.
         */
        allocatedInstanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapperGroup: WrapperGroup): this;

        /**
         * Construct from a sample.
         * @param sample A sample, standard of the WrapperGroup.
         */
        constructor(sample: Wrapper): this;

        /**
         * Construct from members of the {@link sample}.
         * @param name Name, identifier of the sample.
         * @param price Price, issued cost for a type of the sample.
         * @param width Width, dimensional length on the X-axis in 3D, of the sample.
         * @param height Height, dimensional length on the Y-axis in 3D, of the sample.
         * @param length Length, dimensional length on the Z-axis in 3D, of the sample.
         * @param thickness A thickness, causes shrinkness on containable volume, of the sample.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;

        /**
         * Key of a WrapperGroup is dependent on its sample.
         */
        key(): any;

        /**
         * Get sample.
         */
        getSample(): Wrapper;

        /**
         * Get allocated instances.
         */
        getAllocatedInstanceArray(): InstanceArray;

        /**
         * Get (calculate) price.
         * @return  (Price of the sample) x (numbers of children Wrappers)
         */
        getPrice(): number;

        /**
         * 
         * @inheritdoc  
         */
        getUtilization(): number;

        /**
         * <p> Allocate instance(s) to the WrapperGroup. </p>
         * 
        <p> Inspect the instance is enough small to be wrapped into an empty wrapper. If the instance
        is enough small, registers the instance (or repeated instances) to the {@link reserveds} and
        returns <code>true</code>. If the instance is too large to be capsuled, returns <code>false</code>. </p>

        <h4>Note</h4>
        <p> The word <u>the instance is enough small to be wrapped into the empty wrapper</u> means
        the instance can be contained into an empty, a new wrapper contaning nothing literally. </p>

        <p> In the method allocate(), it doesn't consider how many instances are wrapped into ordinary
        wrapper and how much volumes are consumed.  </p>
         * @param instance An Instance to allocate.
         * @param n Repeating number of the <i>instance</i>.
         * @return  Whether the instance is enough small to be wrapped into a (new) wrapper
        of same type with the sample.
        */
        allocate(instance: boxologic$Instance, n?: number): boolean;

        /**
         * <p> Run optimization in level of the group. </p>
         * 
        <p> The optimization routine begins by creating a {@link Wrapper} like the {@link sample}. Then
        try to pack {@link allocatedInstanceArray allocated instances} to the {@link Wrapper} as a lot as
        possible. If there're some {@link Wrappers} can't be packed by overloading, then create a new
        {
         * @link  Wrapper} again and try to pack {
         * @link  allocatedInstanceArray instances} again, too. </p>

        <p> Repeats those steps until all {
         * @link  alloctedInstanceArray instances} are {
         * @link  Wrap packed}
        so that there's not any {
         * @link  Instance instance} left. </p>

        <h4> Warning </h4>
        <p> When call this {
         * @link  optimize optimize()} method, ordinary children {
         * @link  Wrapper} objects
        in the {
         * @link  WrapperGroup} will be substituted with the newly optimized {
         * @link  Wrapper} objects. </p>
        */
        optimize(): void;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string
    }
    declare class Editor<T>mixins React.Component<{
        dataProvider: undefined.EntityArrayCollection<T >
    }, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createColumns(): AdazzleReactDataGrid.Column[];
        render(): JSX.Element
    }
    declare type ItemEditorProps = {
        application: PackerApplication,
        instances: InstanceFormArray,
        wrappers: WrapperArray
    }
    declare class ItemEditor mixins React.Component<ItemEditorProps, {}>{
        render(): JSX.Element
    }
    declare class InstanceEditor mixins Editor<InstanceForm>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class WrapperEditor mixins Editor<Wrapper>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class PackerApplication mixins React.Component<{}, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        pack(): void;
        drawWrapper(wrapper: Wrapper, index?: number): void;
        render(): JSX.Element;
        main(): void
    }
    declare class ResultViewer mixins React.Component<WrapperViewerProps, {}>{
        drawWrapper(wrapper: Wrapper, index?: number): void;
        refresh(): void;
        render(): JSX.Element
    }
    declare type WrapperViewerProps = {
        application: PackerApplication,
        wrappers: WrapperArray
    }
}
declare class TabNavigator mixins React.Component<flex$TabNavigatorProps, flex$TabNavigatorProps>{
    render(): JSX.Element
}

declare class NavigatorContent mixins React.Component<flex$NavigatorContentProps, flex$NavigatorContentProps>{
    render(): JSX.Element
}

declare type flex$TabNavigatorProps = {
    selectedIndex?: number,
    style?: React.CSSProperties
}

declare type flex$NavigatorContentProps = {
    label: string
}
declare module 'MD5' {
    declare     var VERSION: string;
    declare     var BY_ASCII: number;
    declare     var BY_UTF16: number;
    declare     function calc(str: string, option?: number): string
}

/**
 * 
 * @summary  Interface for "saveAs" function.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface FileSaver {
    (data: Blob, filename: string, disableAutoBOM?: boolean): void
}
declare var saveAs: FileSaver;
declare module 'file-saver' {
    declare     var fileSaver: {
        saveAs: typeof saveAs
    };
    declare module.exports: typeof fileSaver
}
declare interface FinchCallback {
    (bindings?: any, childCallback?: () => void): any
}
declare interface ExpandedCallback {
    setup?: FinchCallback,
        load?: FinchCallback,
        unload?: FinchCallback,
        teardown?: FinchCallback
}
declare interface ObserveCallback {
    (...args: any[]): string
}
declare interface FinchOptions {
    CoerceParameterTypes?: boolean
}
declare interface FinchStatic {
    route(route: string, callback: FinchCallback): void,
        route(route: string, callbacks: ExpandedCallback): void,
        call(uri: string): void,
        observe(argN: string[], callback: (params: ObserveCallback) => void): void,
        observe(callback: (params: ObserveCallback) => void): void,
        observe(...args: any[]): void,
        navigate(uri: string, queryParams?: any, doUpdate?: boolean): void,
        navigate(uri: string, doUpdate: boolean): void,
        navigate(queryParams: any, doUpdate?: boolean): void,
        listen(): boolean,
        ignore(): boolean,
        abort(): void,
        options(options: FinchOptions): void
}
declare var Finch: FinchStatic;
declare module 'finch' {
    declare module.exports: typeof Finch
}
declare interface HeadroomOptions {
    offset?: number,
        tolerance?: any,
        classes?: {
            initial?: string,
            notBottom?: string,
            notTop?: string,
            pinned?: string,
            top?: string,
            unpinned?: string
        },
        scroller?: Element,
        onPin?: () => void,
        onUnPin?: () => void,
        onTop?: () => void,
        onNotTop?: () => void
}
declare class Headroom {
    constructor(element: CSG$Node, options?: HeadroomOptions): this;
    constructor(element: Element, options?: HeadroomOptions): this;
    init: () => void
}
declare interface HubSpotPaceInterfaces$PaceOptions {

    /**
     * How long should it take for the bar to animate to a new point after receiving it
     */
    catchupTime?: number,

        /**
         * How quickly should the bar be moving before it has any progress info from a new source in %/ms
         */
        initialRate?: number,

        /**
         * What is the minimum amount of time the bar should be on the screen. Irrespective of this number, the bar will always be on screen for 33  (100 / maxProgressPerFrame) + ghostTime ms.
         */
        minTime?: number,

        /**
         * What is the minimum amount of time the bar should sit after the last update before disappearing
         */
        ghostTime?: number,

        /**
         * Its easy for a bunch of the bar to be eaten in the first few frames before we know how much there is to load. This limits how much of the bar can be used per frame
         */
        maxProgressPerFrame?: number,

        /**
         * This tweaks the animation easing
         */
        easeFactor?: number,

        /**
         * Should pace automatically start when the page is loaded, or should it wait for `start` to be called? Always false if pace is loaded with AMD or CommonJS.
         */
        startOnPageLoad?: boolean,

        /**
         * Should we restart the browser when pushState or replaceState is called?  (Generally means ajax navigation has occured)
         */
        restartOnPushState?: boolean,

        /**
         * Should we show the progress bar for every ajax request (not just regular or ajax-y page navigation)? Set to false to disable. If so, how many ms does the request have to be running for before we show the progress?
         */
        restartOnRequestAfter?: boolean | number,

        /**
         * What element should the pace element be appended to on the page?
         */
        target?: string,
        document?: boolean | string,
        elements?: boolean | HubSpotPaceInterfaces$PaceElementsOptions,
        eventLag?: boolean | HubSpotPaceInterfaces$PaceEventLagOptions,
        ajax?: boolean | HubSpotPaceInterfaces$PaceAjaxOptions
}

declare interface HubSpotPaceInterfaces$PaceElementsOptions {

    /**
     * How frequently in ms should we check for the elements being tested for using the element monitor?
     */
    checkInterval?: number,

        /**
         * What elements should we wait for before deciding the page is fully loaded (not required)
         */
        selectors?: string[]
}

declare interface HubSpotPaceInterfaces$PaceEventLagOptions {

    /**
     * When we first start measuring event lag, not much is going on in the browser yet, so it's not uncommon for the numbers to be abnormally low for the first few samples. This configures how many samples we need before we consider a low number to mean completion.
     */
    minSamples?: number,

        /**
         * How many samples should we average to decide what the current lag is?
         */
        sampleCount?: number,

        /**
         * Above how many ms of lag is the CPU considered busy?
         */
        lagThreshold?: number
}

declare interface HubSpotPaceInterfaces$PaceAjaxOptions {

    /**
     * Which HTTP methods should we track?
     */
    trackMethods?: string[],

        /**
         * Should we track web socket connections?
         */
        trackWebSockets?: boolean,

        /**
         * A list of regular expressions or substrings of URLS we should ignore (for both tracking and restarting)
         */
        ignoreURLs?: (string | RegExp)[]
}

declare interface HubSpotPaceInterfaces$Pace {
    options: HubSpotPaceInterfaces$PaceOptions,
        start(options?: HubSpotPaceInterfaces$PaceOptions): void,
        restart(): void,
        stop(): void,
        track(fn: () => void, ...args: any[]): void,
        ignore(fn: () => void, ...args: any[]): void,
        on(event: string, handler: (...args: any[]) => void, context?: any): void,
        off(event: string, handler?: (...args: any[]) => void): void,
        once(event: string, handler: (...args: any[]) => void, context?: any): void
}
declare var pace: HubSpotPaceInterfaces$Pace;
declare module 'HubSpot-pace' {
    declare module.exports: typeof pace
}
declare module 'JSONStream' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export function parse(pattern: any): NodeJS$ReadWriteStream
    declare     export function stringify(): NodeJS$ReadWriteStream
    declare     export function stringifyObject(): NodeJS$ReadWriteStream
}

declare var npm$namespace$THREE: {
    OrbitControls: typeof THREE$OrbitControls,
    SpriteCanvasMaterial: typeof THREE$SpriteCanvasMaterial,
    RenderableObject: typeof THREE$RenderableObject,
    RenderableFace: typeof THREE$RenderableFace,
    RenderableVertex: typeof THREE$RenderableVertex,
    RenderableLine: typeof THREE$RenderableLine,
    RenderableSprite: typeof THREE$RenderableSprite,
    Projector: typeof THREE$Projector,
}
declare var CSG: {
    fromCSG: (
        csg: CSG,
        defaultColor: any) => {
        colorMesh: Mesh,
        wireframe: Mesh,
        boundLen: number
    },
    getGeometryVertex: (geometry: any, vertex_position: any) => number
};

declare function THREE$OrbitControls(object: any, domElement: any): void

declare function THREE$SpriteCanvasMaterial(parameters?: any): void

declare interface THREE$ICanvasRendererOptions {
    canvas?: HTMLCanvasElement,
        alpha?: boolean
}

declare class CanvasRenderer mixins Renderer {
    domElement: HTMLCanvasElement;
    constructor(parameters: THREE$ICanvasRendererOptions): this;
    supportsVertexTextures(): void;
    setFaceCulling: () => void;
    getPixelRatio(): number;
    setPixelRatio(value: any): void;
    setSize(width: any, height: any, updateStyle: any): void;
    setViewport(x: any, y: any, width: any, height: any): void;
    setScissor(): void;
    enableScissorTest(): void;
    setClearColor(color: any, alpha: any): void;
    setClearColorHex(hex: any, alpha: any): void;
    getClearColor(): Color;
    getClearAlpha(): number;
    getMaxAnisotropy(): number;
    clear(): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    render(
        scene: Scene,
        camera: Camera,
        renderTarget?: RenderTarget,
        forceClear?: boolean): void;
    calculateLights(): void;
    calculateLight(position: any, normal: any, color: any): void;
    renderSprite(v1: any, element: any, material: any): void;
    renderLine(v1: any, v2: any, element: any, material: any): void;
    renderFace3(
        v1: any,
        v2: any,
        v3: any,
        uv1: any,
        uv2: any,
        uv3: any,
        element: any,
        material: any): void;
    drawTriangle(x0: any, y0: any, x1: any, y1: any, x2: any, y2: any): void;
    strokePath(color: any, linewidth: any, linecap: any, linejoin: any): void;
    fillPath(color: any): void;
    onTextureUpdate(event: any): void;
    textureToPattern(texture: any): void;
    patternPath(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        texture: any): void;
    clipImage(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        image: any): void;
    expand(v1: any, v2: any, pixels: any): void;
    setOpacity(value: any): void;
    setBlending(value: any): void;
    setLineWidth(value: any): void;
    setLineCap(value: any): void;
    setLineJoin(value: any): void;
    setStrokeStyle(value: any): void;
    setFillStyle(value: any): void;
    setLineDash(value: any): void
}

declare function THREE$RenderableObject(): void

declare function THREE$RenderableFace(): void

declare function THREE$RenderableVertex(): void

declare function THREE$RenderableLine(): void

declare function THREE$RenderableSprite(): void

declare function THREE$Projector(): void
declare var npm$namespace$OpenJsCad: {
    makeAbsoluteUrl: typeof OpenJsCad$makeAbsoluteUrl,
    isChrome: typeof OpenJsCad$isChrome,
    runMainInWorker: typeof OpenJsCad$runMainInWorker,
    expandResultObjectArray: typeof OpenJsCad$expandResultObjectArray,
    checkResult: typeof OpenJsCad$checkResult,
    resultToCompactBinary: typeof OpenJsCad$resultToCompactBinary,
    resultFromCompactBinary: typeof OpenJsCad$resultFromCompactBinary,
    parseJsCadScriptSync: typeof OpenJsCad$parseJsCadScriptSync,
    parseJsCadScriptASync: typeof OpenJsCad$parseJsCadScriptASync,
    getWindowURL: typeof OpenJsCad$getWindowURL,
    textToBlobUrl: typeof OpenJsCad$textToBlobUrl,
    revokeBlobUrl: typeof OpenJsCad$revokeBlobUrl,
    FileSystemApiErrorHandler: typeof OpenJsCad$FileSystemApiErrorHandler,
    AlertUserOfUncaughtExceptions: typeof OpenJsCad$AlertUserOfUncaughtExceptions,
    getParamDefinitions: typeof OpenJsCad$getParamDefinitions,
}
declare interface OpenJsCad$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare var log: OpenJsCad$ILog;

declare interface OpenJsCad$IViewerOptions {
    drawLines?: boolean,
        drawFaces?: boolean,
        color?: number[],
        bgColor?: number,
        noWebGL?: boolean
}

declare type OpenJsCad$ProcessorOptions = {
    verbose?: boolean,
    viewerwidth?: number,
    viewerheight?: number,
    viewerheightratio?: number
} & OpenJsCad$IViewerOptions


declare class Viewer {
    constructor(containerElm: any, size: any, options: OpenJsCad$IViewerOptions): this;
    createScene(drawAxes: any, axLen: any): void;
    createCamera(): void;
    createControls(canvas: any): void;
    webGLAvailable(): boolean;
    createRenderer(bool_noWebGL: any): void;
    render(): void;
    animate(): void;
    cancelAnimate(): void;
    refreshRenderer(bool_noWebGL: any): void;
    drawAxes(axLen: any): void;
    setCsg(csg: any, resetZoom: any): void;
    applyDrawOptions(): void;
    clear(): void;
    getUserMeshes(str?: any): THREE$Object3D[];
    resetZoom(r: any): void;
    parseSizeParams(): void;
    handleResize(): void
}

declare function OpenJsCad$makeAbsoluteUrl(url: any, baseurl: any): any

declare function OpenJsCad$isChrome(): boolean

declare function OpenJsCad$runMainInWorker(mainParameters: any): void

declare function OpenJsCad$expandResultObjectArray(result: any): any

declare function OpenJsCad$checkResult(result: any): void

declare function OpenJsCad$resultToCompactBinary(resultin: any): any

declare function OpenJsCad$resultFromCompactBinary(resultin: any): any

declare function OpenJsCad$parseJsCadScriptSync(script: any, mainParameters: any, debugging: any): any

declare function OpenJsCad$parseJsCadScriptASync(script: any, mainParameters: any, options: any, callback: any): Worker

declare function OpenJsCad$getWindowURL(): URL

declare function OpenJsCad$textToBlobUrl(txt: any): string

declare function OpenJsCad$revokeBlobUrl(url: any): void

declare function OpenJsCad$FileSystemApiErrorHandler(fileError: any, operation: any): void

declare function OpenJsCad$AlertUserOfUncaughtExceptions(): void

declare function OpenJsCad$getParamDefinitions(script: any): any[]

declare interface OpenJsCad$EventHandler {
    (ev?: Event): any
}


/**
 * options parameter:
 * - drawLines: display wireframe lines
- drawFaces: display surfaces
- bgColor: canvas background color
- color: object color
- viewerwidth, viewerheight: set rendering size. Works with any css unit.
     viewerheight can also be specified as a ratio to width, ie number e (0, 1]
- noWebGL: force render without webGL
- verbose: show additional info (currently only time used for rendering)
*/
declare interface OpenJsCad$ViewerSize {
    widthDefault: string,
        heightDefault: string,
        width: number,
        height: number,
        heightratio: number
}

declare class Processor {
    constructor(containerdiv: HTMLDivElement, options?: OpenJsCad$ProcessorOptions, onchange?: OpenJsCad$EventHandler): this;
    convertToSolid(obj: any): any;
    cleanOption(option: any, deflt: any): any;
    toggleDrawOption(str: any): boolean;
    setDrawOption(str: any, bool: any): void;
    handleResize(): void;
    createElements(): void;
    getFilenameForRenderedObject(): string;
    setRenderedObjects(obj: any): void;
    setSelectedObjectIndex(index: number): void;
    selectedFormat(): any;
    selectedFormatInfo(): any;
    updateDownloadLink(): void;
    clearViewer(): void;
    abort(): void;
    enableItems(): void;
    setOpenJsCadPath(path: string): void;
    addLibrary(lib: any): void;
    setError(txt: string): void;
    setDebugging(debugging: boolean): void;
    setJsCad(script: string, filename?: string): void;
    getParamValues(): {};
    rebuildSolid(): void;
    hasSolid(): boolean;
    isProcessing(): boolean;
    clearOutputFile(): void;
    generateOutputFile(): void;
    currentObjectToBlob(): any;
    supportedFormatsForCurrentObject(): string[];
    formatInfo(format: any): any;
    downloadLinkTextForCurrentObject(): string;
    generateOutputFileBlobUrl(): void;
    generateOutputFileFileSystem(): void;
    createParamControls(): void
}
declare interface Window {
    Worker: Worker,
        webkitURL: URL,
        requestFileSystem: any,
        webkitRequestFileSystem: any
}
declare interface IAMFStringOptions {
    unit: string
}
declare class CxG {
    toStlString(): string;
    toStlBinary(): void;
    toAMFString(AMFStringOptions?: IAMFStringOptions): void;
    getBounds(): CxG[];
    transform(matrix4x4: CSG$Matrix4x4): CxG;
    mirrored(plane: CSG$Plane): CxG;
    mirroredX(): CxG;
    mirroredY(): CxG;
    mirroredZ(): CxG;
    translate(v: number[]): CxG;
    translate(v: CSG$Vector3D): CxG;
    scale(f: CSG$Vector3D): CxG;
    rotateX(deg: number): CxG;
    rotateY(deg: number): CxG;
    rotateZ(deg: number): CxG;
    rotate(rotationCenter: CSG$Vector3D, rotationAxis: CSG$Vector3D, degrees: number): CxG;
    rotateEulerAngles(alpha: number, beta: number, gamma: number, position: number[]): CxG
}
declare interface ICenter {
    center(cAxes: string[]): CxG
}
declare class CSG mixins CxG, ICenter {
    polygons: CSG$Polygon[];
    properties: CSG$Properties;
    isCanonicalized: boolean;
    isRetesselated: boolean;
    cachedBoundingBox: CSG$Vector3D[];
    defaultResolution2D: number;
    defaultResolution3D: number;
    fromPolygons(polygons: CSG$Polygon[]): CSG;
    fromSlices(options: any): CSG;
    fromObject(obj: any): CSG;
    fromCompactBinary(bin: any): CSG;
    toPolygons(): CSG$Polygon[];
    union(csg: CSG[]): CSG;
    union(csg: CSG): CSG;
    unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    unionForNonIntersecting(csg: CSG): CSG;
    subtract(csg: CSG[]): CSG;
    subtract(csg: CSG): CSG;
    subtractSub(csg: CSG, retesselate: boolean, canonicalize: boolean): CSG;
    intersect(csg: CSG[]): CSG;
    intersect(csg: CSG): CSG;
    intersectSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    invert(): CSG;
    transform1(matrix4x4: CSG$Matrix4x4): CSG;
    transform(matrix4x4: CSG$Matrix4x4): CSG;
    toString(): string;
    expand(radius: number, resolution: number): CSG;
    contract(radius: number, resolution: number): CSG;
    stretchAtPlane(normal: number[], point: number[], length: number): CSG;
    expandedShell(radius: number, resolution: number, unionWithThis: boolean): CSG;
    canonicalized(): CSG;
    reTesselated(): CSG;
    getBounds(): CSG$Vector3D[];
    mayOverlap(csg: CSG): boolean;
    cutByPlane(plane: CSG$Plane): CSG;
    connectTo(
        myConnector: CSG$Connector,
        otherConnector: CSG$Connector,
        mirror: boolean,
        normalrotation: number): CSG;
    setShared(shared: undefined.Shared): CSG;
    setColor(args: any): CSG;
    toCompactBinary(): {
        class: string,
        numPolygons: number,
        numVerticesPerPolygon: Uint32Array,
        polygonPlaneIndexes: Uint32Array,
        polygonSharedIndexes: Uint32Array,
        polygonVertices: Uint32Array,
        vertexData: Float64Array,
        planeData: Float64Array,
        shared: undefined.Shared[]
    };
    toPointCloud(cuberadius: any): CSG;
    getTransformationAndInverseTransformationToFlatLying(): any;
    getTransformationToFlatLying(): any;
    lieFlat(): CSG;
    projectToOrthoNormalBasis(orthobasis: CSG$OrthoNormalBasis): CAG;
    sectionCut(orthobasis: CSG$OrthoNormalBasis): CAG;
    fixTJunctions(): CSG;
    toTriangles(): any[];
    getFeatures(features: any): any;
    center(cAxes: string[]): CxG;
    toX3D(): Blob;
    toStlBinary(): Blob;
    toStlString(): string;
    toAMFString(m: IAMFStringOptions): Blob
}
declare class Polygon2D mixins CAG {
    constructor(points: CSG$Vector2D[]): this
}
declare class CAG mixins CxG, ICenter {
    sides: CAG$Side[];
    isCanonicalized: boolean;
    constructor(): this;
    fromSides(sides: CAG$Side[]): CAG;
    fromPoints(points: CSG$Vector2D[]): CAG;
    fromPointsNoCheck(points: CSG$Vector2D[]): CAG;
    fromFakeCSG(csg: CSG): CAG;
    linesIntersect(
        p0start: CSG$Vector2D,
        p0end: CSG$Vector2D,
        p1start: CSG$Vector2D,
        p1end: CSG$Vector2D): boolean;
    circle(options: CSG$ICircleOptions): CAG;
    rectangle(options: CSG$IRectangleOptions): CAG;
    roundedRectangle(options: any): CAG;
    fromCompactBinary(bin: any): CAG;
    toString(): string;
    _toCSGWall(z0: any, z1: any): CSG;
    _toVector3DPairs(m: CSG$Matrix4x4): CSG$Vector3D[][];
    _toPlanePolygons(options: any): CSG$Polygon[];
    _toWallPolygons(options: any): any[];
    union(cag: CAG[]): CAG;
    union(cag: CAG): CAG;
    subtract(cag: CAG[]): CAG;
    subtract(cag: CAG): CAG;
    intersect(cag: CAG[]): CAG;
    intersect(cag: CAG): CAG;
    transform(matrix4x4: CSG$Matrix4x4): CAG;
    area(): number;
    flipped(): CAG;
    getBounds(): CSG$Vector2D[];
    isSelfIntersecting(): boolean;
    expandedShell(radius: number, resolution: number): CAG;
    expand(radius: number, resolution: number): CAG;
    contract(radius: number, resolution: number): CAG;
    extrudeInOrthonormalBasis(orthonormalbasis: CSG$OrthoNormalBasis, depth: number, options?: any): CSG;
    extrudeInPlane(axis1: any, axis2: any, depth: any, options: any): CSG;
    extrude(options: CAG_extrude_options): CSG;
    rotateExtrude(options: any): CSG;
    check(): void;
    canonicalized(): CAG;
    toCompactBinary(): {
        class: string,
        sideVertexIndices: Uint32Array,
        vertexData: Float64Array
    };
    getOutlinePaths(): CSG$Path2D[];
    overCutInsideCorners(cutterradius: any): CAG;
    center(cAxes: string[]): CxG;
    toDxf(): Blob;
    PathsToDxf(paths: CSG$Path2D[]): Blob
}
declare class Vertex {
    pos: CSG$Vector2D;
    tag: number;
    constructor(pos: CSG$Vector2D): this;
    toString(): string;
    getTag(): number
}

declare class Side mixins CxG {
    vertex0: CAG$Vertex;
    vertex1: CAG$Vertex;
    tag: number;
    constructor(vertex0: CAG$Vertex, vertex1: CAG$Vertex): this;
    _fromFakePolygon(polygon: CSG$Polygon): CAG$Side;
    toString(): string;
    toPolygon3D(z0: any, z1: any): CSG$Polygon;
    transform(matrix4x4: CSG$Matrix4x4): CAG$Side;
    flipped(): CAG$Side;
    direction(): CSG$Vector2D;
    getTag(): number;
    lengthSquared(): number;
    length(): number
}

declare class fuzzyCAGFactory {
    vertexfactory: CSG$fuzzyFactory;
    constructor(): this;
    getVertex(sourcevertex: CAG$Vertex): CAG$Vertex;
    getSide(sourceside: CAG$Side): CAG$Side;
    getCAG(sourcecag: CAG): CAG
}
declare interface CAG_extrude_options {
    offset?: number[],
        twistangle?: number,
        twiststeps?: number
}
/**
 * The PayPalItem class defines an optional itemization for a payment.
 * @see  https://developer.paypal.com/docs/api/#item-object for more details.
 */
declare class PayPalItem {

    /**
     * 
     * @param name Name of the item. 127 characters max.
     * @param quantity Number of units. 10 characters max.
     * @param price Unit price for this item 10 characters max.
    May be negative for "coupon" etc.
     * @param currency ISO standard currency code.
     * @param sku The stock keeping unit for this item. 50 characters max (optional).
    */
    constructor(name: string, quantity: number, price: string, currency: string, sku?: string): this;

    /**
     * Name of the item. 127 characters max.
     */
    name: string;

    /**
     * Number of units. 10 characters max.
     */
    quantity: number;

    /**
     * Unit price for this item 10 characters max.
     * May be negative for "coupon" etc.
     */
    price: string;

    /**
     * ISO standard currency code.
     */
    currency: string;

    /**
     * The stock keeping unit for this item. 50 characters max (optional).
     */
    sku: string
}
/**
 * The PayPalPaymentDetails class defines optional amount details.
 * @see  https://developer.paypal.com/webapps/developer/docs/api/#details-object for more details.
 */
declare class PayPalPaymentDetails {

    /**
     * 
     * @param subtotal Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     * @param shipping Amount charged for shipping. 10 characters max with support for 2 decimal places.
     * @param tax Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    constructor(subtotal: string, shipping: string, tax: string): this;

    /**
     * Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     */
    subtotal: string;

    /**
     * Amount charged for shipping. 10 characters max with support for 2 decimal places.
     */
    shipping: string;

    /**
     * Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    tax: string
}
/**
 * Convenience constructor. Returns a PayPalPayment with the specified amount, currency code, and short description.
 */
declare class PayPalPayment {

    /**
     * 
     * @param amount The amount of the payment.
     * @param currencyCode The ISO 4217 currency for the payment.
     * @param shortDescription A short descripton of the payment.
     * @param intent "Sale" for an immediate payment.
    "Auth" for payment authorization only, to be captured separately at a later time.
     "Order" for taking an order, with authorization and capture to be done separately at a later time.
     * @param details PayPalPaymentDetails object (optional).
    */
    constructor(amount: string, currency: string, shortDescription: string, intent: string, details?: PayPalPaymentDetails): this;

    /**
     * The amount of the payment.
     */
    amount: string;

    /**
     * The ISO 4217 currency for the payment.
     */
    currency: string;

    /**
     * A short descripton of the payment.
     */
    shortDescription: string;

    /**
     *  "Sale" for an immediate payment.
     * "Auth" for payment authorization only, to be captured separately at a later time.
    "Order" for taking an order, with authorization and capture to be done separately at a later time.
    */
    intent: string;

    /**
     * PayPalPaymentDetails object (optional).
     */
    details: PayPalPaymentDetails;

    /**
     * Optional invoice number, for your tracking purposes. (up to 256 characters).
     */
    invoiceNumber: string;

    /**
     * Optional text, for your tracking purposes. (up to 256 characters).
     */
    custom: string;

    /**
     * Optional text which will appear on the customer's credit card statement. (up to 22 characters).
     */
    softDescriptor: string;

    /**
     * Optional Build Notation code ("BN code"), obtained from partnerprogram@paypal.com, for your tracking purposes.
     */
    bnCode: string;

    /**
     * Optional array of PayPalItem objects.
     * @see  PayPalItem
     * @note  If you provide one or more items, be sure that the various prices correctly sum to the payment `amount` or to `paymentDetails.subtotal`.
     */
    items: PayPalItem[];

    /**
     * Optional customer shipping address, if your app wishes to provide this to the SDK.
     * @note  make sure to set `payPalShippingAddressOption` in PayPalConfiguration to 1 or 3.
     */
    shippingAddress: PayPalShippingAddress
}
declare class PayPalShippingAddress {

    /**
     * 
     * @param recipientName Name of the recipient at this address. 50 characters max.
     * @param line1 Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     * @param line2 Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     * @param city City name. 50 characters max.
     * @param state 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     * @param postalCode ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     * @param countryCode 2-letter country code. 2 characters max.
     */
    constructor(recipientName: string, line1: string, line2: string, city: string, state: string, postalCode: string, countryCode: string): this;

    /**
     * Name of the recipient at this address. 50 characters max.
     */
    recipientName: string;

    /**
     * Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     */
    line1: string;

    /**
     * Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     */
    line2: string;

    /**
     * City name. 50 characters max.
     */
    city: string;

    /**
     * 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     */
    state: string;

    /**
     * ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     */
    postalCode: string;

    /**
     * 2-letter country code. 2 characters max.
     */
    countryCode: string
}
declare class PayPalConfiguration {

    /**
     * 
     * @param options A set of options to use. Any options not specified will assume default values.
     */
    constructor(options?: PayPalConfigurationOptions): this;

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail: string;

    /**
     * Will be overridden by phone country code used in most recent PayPal login
     */
    defaultUserPhoneCountryCode: string;

    /**
     * Will be overridden by phone number used in most recent PayPal login.
     * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
     */
    defaultUserPhoneNumber: string;

    /**
     * Your company name, as it should be displayed to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantName: string;

    /**
     * URL of your company's privacy policy, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantPrivacyPolicyURL: string;

    /**
     * URL of your company's user agreement, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantUserAgreementURL: string;

    /**
     * If set to false, the SDK will only support paying with PayPal, not with credit cards.
     * This applies only to single payments (via PayPalPaymentViewController).
    Future payments (via PayPalFuturePaymentViewController) always use PayPal.
    Defaults to true.
    */
    acceptCreditCards: boolean;

    /**
     * For single payments, options for the shipping address.
     * 
    - 0 - PayPalShippingAddressOptionNone: no shipping address applies.

    - 1 - PayPalShippingAddressOptionProvided: shipping address will be provided by your app,
       in the shippingAddress property of PayPalPayment.

    - 2 - PayPalShippingAddressOptionPayPal: user will choose from shipping addresses on file
       for their PayPal account.

    - 3 - PayPalShippingAddressOptionBoth: user will choose from the shipping address provided by your app,
       in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

    Defaults to 0 (PayPalShippingAddressOptionNone).
    */
    payPalShippingAddressOption: number;

    /**
     * If set to true, then if the user pays via their PayPal account,
     * the SDK will remember the user's PayPal username or phone number;
    if the user pays via their credit card, then the SDK will remember
    the PayPal Vault token representing the user's credit card.

    If set to false, then any previously-remembered username, phone number, or
    credit card token will be erased, and subsequent payment information will
    not be remembered.

    Defaults to true.
    */
    rememberUser: boolean;

    /**
     * If not set, or if set to nil, defaults to the device's current language setting.
     * 
    Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
    If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
    If the library does not contain localized strings for a specified language, then will fall back to American English.

    If you specify only a language code, and that code matches the device's currently preferred language,
    then the library will attempt to use the device's current region as well.
    E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

    These localizations are currently included:
    da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
    */
    languageOrLocale: string;

    /**
     * Normally, the SDK blurs the screen when the app is backgrounded,
     * to obscure credit card or PayPal account details in the iOS-saved screenshot.
    If your app already does its own blurring upon backgrounding, you might choose to disable this.
    Defaults to false.
    */
    disableBlurWhenBackgrounding: boolean;

    /**
     * If you will present the SDK's view controller within a popover, then set this property to true.
     * Defaults to false. (iOS only)
     */
    presentingInPopover: boolean;

    /**
     * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
     * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

    This setting will have no effect if the operation mode is production.
    Defaults to false.
    */
    forceDefaultsInSandbox: boolean;

    /**
     * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPassword: string;

    /**
     * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPin: string
}
/**
 * Describes the options that can be passed into the PayPalConfiguration class constructor.
 */
declare interface PayPalConfigurationOptions {

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail?: string,

        /**
         * Will be overridden by phone country code used in most recent PayPal login
         */
        defaultUserPhoneCountryCode?: string,

        /**
         * Will be overridden by phone number used in most recent PayPal login.
         * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
         */
        defaultUserPhoneNumber?: string,

        /**
         * Your company name, as it should be displayed to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantName?: string,

        /**
         * URL of your company's privacy policy, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantPrivacyPolicyURL?: string,

        /**
         * URL of your company's user agreement, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantUserAgreementURL?: string,

        /**
         * If set to false, the SDK will only support paying with PayPal, not with credit cards.
         * This applies only to single payments (via PayPalPaymentViewController).
        Future payments (via PayPalFuturePaymentViewController) always use PayPal.
        Defaults to true.
        */
        acceptCreditCards?: boolean,

        /**
         * For single payments, options for the shipping address.
         * 
        - 0 - PayPalShippingAddressOptionNone?: no shipping address applies.

        - 1 - PayPalShippingAddressOptionProvided?: shipping address will be provided by your app,
           in the shippingAddress property of PayPalPayment.

        - 2 - PayPalShippingAddressOptionPayPal?: user will choose from shipping addresses on file
           for their PayPal account.

        - 3 - PayPalShippingAddressOptionBoth?: user will choose from the shipping address provided by your app,
           in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

        Defaults to 0 (PayPalShippingAddressOptionNone).
        */
        payPalShippingAddressOption?: number,

        /**
         * If set to true, then if the user pays via their PayPal account,
         * the SDK will remember the user's PayPal username or phone number;
        if the user pays via their credit card, then the SDK will remember
        the PayPal Vault token representing the user's credit card.

        If set to false, then any previously-remembered username, phone number, or
        credit card token will be erased, and subsequent payment information will
        not be remembered.

        Defaults to true.
        */
        rememberUser?: boolean,

        /**
         * If not set, or if set to nil, defaults to the device's current language setting.
         * 
        Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
        If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
        If the library does not contain localized strings for a specified language, then will fall back to American English.

        If you specify only a language code, and that code matches the device's currently preferred language,
        then the library will attempt to use the device's current region as well.
        E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

        These localizations are currently included:
        da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
        */
        languageOrLocale?: string,

        /**
         * Normally, the SDK blurs the screen when the app is backgrounded,
         * to obscure credit card or PayPal account details in the iOS-saved screenshot.
        If your app already does its own blurring upon backgrounding, you might choose to disable this.
        Defaults to false.
        */
        disableBlurWhenBackgrounding?: boolean,

        /**
         * If you will present the SDK's view controller within a popover, then set this property to true.
         * Defaults to false. (iOS only)
         */
        presentingInPopover?: boolean,

        /**
         * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
         * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

        This setting will have no effect if the operation mode is production.
        Defaults to false.
        */
        forceDefaultsInSandbox?: boolean,

        /**
         * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPassword?: string,

        /**
         * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPin?: string
}
declare export interface PayPalCordovaPlugin$PayPalClientIds {
    PayPalEnvironmentProduction: string,
        PayPalEnvironmentSandbox: string
}


/**
 * Represents the portion of an object that is common to all responses.
 */
declare export interface PayPalCordovaPlugin$BaseResult {
    client: PayPalCordovaPlugin$Client,
        response_type: string
}


/**
 * Represents the client portion of the response.
 */
declare export interface PayPalCordovaPlugin$Client {
    paypal_sdk_version: string,
        environment: string,
        platform: string,
        product_name: string
}


/**
 * Represents the response for a successful callback from renderSinglePaymentUI().
 */
declare export type PayPalCordovaPlugin$SinglePaymentResult = {
    response: {
        intent: string,
        id: string,
        state: string,
        authorization_id: string,
        create_time: string
    }
} & PayPalCordovaPlugin$BaseResult



/**
 * Represents the response for a successful callback from renderFuturePaymentUI().
 */
declare export type PayPalCordovaPlugin$FuturePaymentResult = {
    response: {
        code: string
    }
} & PayPalCordovaPlugin$BaseResult


declare export interface PayPalCordovaPlugin$PayPalMobileStatic {

    /**
     * Retrieve the version of the PayPal iOS SDK library. Useful when contacting support.
     * @param completionCallback a callback function accepting a string
     */
    version(completionCallback: (result: string) => void): void,

        /**
         * You MUST call this method to initialize the PayPal Mobile SDK.
         * 
        The PayPal Mobile SDK can operate in different environments to facilitate development and testing."my-client-id-for-Production",
        PayPalEnvironmentSandbox : @"my-client-id-for-Sandbox"
        }
         * @param clientIdsForEnvironments set of client ids for environments
        Example: var clientIdsForEnvironments = {
        PayPalEnvironmentProduction : 
         * @param completionCallback a callback function on success
        */
        init(
            clientIdsForEnvironments: PayPalCordovaPlugin$PayPalClientIds,
            completionCallback: () => void): void,

        /**
         * You must preconnect to PayPal to prepare the device for processing payments.
         * This improves the user experience, by making the presentation of the
        UI faster. The preconnect is valid for a limited time, so
        the recommended time to preconnect is on page load.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param configuration PayPalConfiguration object, for Future Payments merchantName, merchantPrivacyPolicyURL
        and merchantUserAgreementURL must be set be set
         * @param completionCallback a callback function on success
        */
        prepareToRender(
            environment: string,
            configuration: PayPalConfiguration,
            completionCallback: () => void): void,

        /**
         * Start PayPal UI to collect payment from the user.
         * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/ios-integration-guide/
        for more documentation of the params.
         * @param payment PayPalPayment object
         * @param completionCallback a callback function accepting a js object, called when the user has completed payment
         * @param cancelCallback a callback function accepting a reason string, called when the user cancels the payment
        */
        renderSinglePaymentUI(
            payment: PayPalPayment,
            completionCallback: (result: PayPalCordovaPlugin$SinglePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * 
         * @deprecated  * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
        from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param callback applicationCorrelationID Your server will send this to PayPal in a 'Paypal-Application-Correlation-Id' header.
        */
        applicationCorrelationIDForEnvironment(
            environment: string,
            completionCallback: (applicationCorrelationId: string) => void): void,

        /**
         * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
         * from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param callback clientMetadataID Your server will send this to PayPal in a 'PayPal-Client-Metadata-Id' header.
        */
        clientMetadataID(completionCallback: (clientMetadataId: string) => void): void,

        /**
         * Please Read Docs on Future Payments at https://github.com/paypal/PayPal-iOS-SDK#future-payments
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
         */
        renderFuturePaymentUI(
            completionCallback: (result: PayPalCordovaPlugin$FuturePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * Please Read Docs on Profile Sharing at https://github.com/paypal/PayPal-iOS-SDK#profile-sharing
         * @param scopes scopes Set of requested scope-values. Accepted scopes are: openid, profile, address, email, phone, futurepayments and paypalattributes
        See https://developer.paypal.com/docs/integration/direct/identity/attributes/ for more details
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
        */
        renderProfileSharingUI(
            scopes: string[],
            completionCallback: (result: any) => void,
            cancelCallback: (cancelReason: string) => void): void
}
declare var PayPalMobile: PayPalCordovaPlugin$PayPalMobileStatic;
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module 'abs' {
    declare module.exports: typeof Abs
}
declare module 'absolute' {
    declare module.exports: typeof absolute
}
declare interface AccWizardOptions {

    /**
     * 
     * @summary  Add next/prev buttons to panels.
     * @type  
     */
    addButtons: boolean,

        /**
         * 
         * @summary  Selector for task sidebar.
         * @type  
         */
        sidebar: string,

        /**
         * 
         * @summary  Class to indicate the active task in sidebar.
         * @type  
         */
        activeClass: string,

        /**
         * 
         * @summary  Class to indicate task is complete.
         * @type  
         */
        completedClass: string,

        /**
         * 
         * @summary  Class to indicate task is still pending.
         * @type  
         */
        todoClass: string,

        /**
         * 
         * @summary  Class for step buttons within panels.
         * @type  
         */
        stepClass: string,

        /**
         * 
         * @summary  Text for next button.
         * @type  
         */
        nextText: string,

        /**
         * 
         * @summary  Text for back button.
         * @type  
         */
        backText: string,

        /**
         * 
         * @summary  HTML input type for next button. (default: "submit")
         * @type  
         */
        nextType: string,

        /**
         * 
         * @summary  HTML input type for back button. (default: "reset")
         * @type  
         */
        backType: string,

        /**
         * 
         * @summary  Class(es) for next button.
         * @type  
         */
        nextClasses: string,

        /**
         * 
         * @summary  Class(es) for back button.
         * @type  
         */
        backClasses: string,

        /**
         * 
         * @summary  Auto-scrolling.
         * @type  
         */
        autoScrolling: boolean,

        /**
         * 
         * @summary  Function to call on next step.
         */
        onNext: Function,

        /**
         * 
         * @summary  Function to call on back up.
         */
        onBack: Function,

        /**
         * 
         * @summary  A chance to hook initialization.
         */
        onInit: Function,

        /**
         * 
         * @summary  A chance to hook destruction.
         */
        onDestroy: Function
}
/**
 * 
 * @summary  Interface for "acc-wizard" JQuery plugin.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface JQuery {
    accwizard(options?: AccWizardOptions): void
}
declare interface IAccountingCurrencyFormat {
    pos: string,
        neg?: string,
        zero?: string
}
declare interface IAccountingCurrencySettings<TFormat>{
    symbol?: string,
    format?: TFormat,
    decimal?: string,
    thousand?: string,
    precision?: number
}
declare interface IAccountingNumberSettings {
    precision?: number,
        thousand?: string,
        decimal?: string
}
declare interface IAccountingSettings {
    currency: IAccountingCurrencySettings<any>,
        number: IAccountingNumberSettings
}
declare interface IAccountingStatic {
    formatMoney(
            number: number,
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string,
        formatMoney(number: number, options: IAccountingCurrencySettings<string>): string,
        formatMoney(
            number: number,
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string,
        formatMoney(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatMoney(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatMoney(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatMoney(
            numbers: any[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): any[],
        formatMoney(numbers: any[], options: IAccountingCurrencySettings<string>): any[],
        formatMoney(
            numbers: any[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): any[],
        formatColumn(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatColumn(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatColumn(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatColumn(
            numbers: number[][],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[][],
        formatColumn(numbers: number[][], options: IAccountingCurrencySettings<string>): string[][],
        formatColumn(
            numbers: number[][],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[][],
        formatNumber(
            number: number,
            precision?: number,
            thousand?: string,
            decimal?: string): string,
        formatNumber(number: number, options: IAccountingNumberSettings): string,
        formatNumber(
            number: number[],
            precision?: number,
            thousand?: string,
            decimal?: string): string[],
        formatNumber(number: number[], options: IAccountingNumberSettings): string[],
        formatNumber(number: any[], precision?: number, thousand?: string, decimal?: string): any[],
        formatNumber(number: any[], options: IAccountingNumberSettings): any[],
        toFixed(number: number, precision?: number): string,
        unformat(string: string, decimal?: string): number,
        settings: IAccountingSettings
}
declare var accounting: IAccountingStatic;
declare module 'accounting' {
    declare module.exports: typeof accounting
}
declare export interface AceAjax$Delta {
    action: string,
        range: AceAjax$Range,
        text: string,
        lines: string[]
}

declare export interface AceAjax$EditorCommand {
    name: string,
        bindKey: any,
        exec: Function,
        readOnly?: boolean
}

declare export interface AceAjax$CommandManager {
    byName: any,
        commands: any,
        platform: string,
        addCommands(commands: AceAjax$EditorCommand[]): void,
        addCommand(command: AceAjax$EditorCommand): void,
        exec(name: string, editor: AceAjax$Editor, args: any): void
}

declare export interface AceAjax$Annotation {
    row: number,
        column: number,
        text: string,
        type: string
}

declare export interface AceAjax$TokenInfo {
    value: string
}

declare export interface AceAjax$Position {
    row: number,
        column: number
}

declare export interface AceAjax$KeyBinding {
    setDefaultHandler(kb: any): void,
        setKeyboardHandler(kb: any): void,
        addKeyboardHandler(kb: any, pos: any): void,
        removeKeyboardHandler(kb: any): boolean,
        getKeyboardHandler(): any,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        onTextInput(text: any): void
}

declare export interface AceAjax$TextMode {
    getTokenizer(): any,
        toggleCommentLines(state: any, doc: any, startRow: any, endRow: any): void,
        getNextLineIndent(state: any, line: any, tab: any): string,
        checkOutdent(state: any, line: any, input: any): boolean,
        autoOutdent(state: any, doc: any, row: any): void,
        createWorker(session: any): any,
        createModeDelegates(mapping: any): void,
        transformAction(state: any, action: any, editor: any, session: any, param: any): any
}


/**
 * The main class required to set up an Ace instance in the browser.
 */
declare export interface AceAjax$Ace {

    /**
     * Provides access to require in packed noconflict mode
     * @param moduleName 
     */
    require(moduleName: string): any,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: string): AceAjax$Editor,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: HTMLElement): AceAjax$Editor,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: AceAjax$Document, mode: AceAjax$TextMode): AceAjax$IEditSession,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: string, mode: AceAjax$TextMode): AceAjax$IEditSession
}


/**
 * Defines the floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the cursor is updated.
 */
declare export interface AceAjax$Anchor {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Returns an object identifying the `row` and `column` position of the current anchor.
         */
        getPosition(): AceAjax$Position,

        /**
         * Returns the current document.
         */
        getDocument(): AceAjax$Document,

        /**
         * Fires whenever the anchor position changes.
         * Both of these objects have a `row` and `column` property corresponding to the position.
        Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
         * @param e An object containing information about the anchor position. It has two properties:
        - `old`: An object describing the old Anchor position
        - `value`: An object describing the new Anchor position
        */
        onChange(e: any): void,

        /**
         * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
         * @param row The row index to move the anchor to
         * @param column The column index to move the anchor to
         * @param noClip Identifies if you want the position to be clipped
         */
        setPosition(row: number, column: number, noClip: boolean): void,

        /**
         * When called, the `'change'` event listener is removed.
         */
        detach(): void
}

declare var Anchor: {

    /**
     * Creates a new `Anchor` and associates it with a document.
     * @param doc The document to associate with the anchor
     * @param row The starting row position
     * @param column The starting column position
     */
    new(doc: AceAjax$Document, row: number, column: number): AceAjax$Anchor
};


/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use.
 * If a certain row is changed, everything below that row is re-tokenized.
 */
declare export interface AceAjax$BackgroundTokenizer {
    states: any[],

        /**
         * Sets a new tokenizer for this object.
         * @param tokenizer The new tokenizer to use
         */
        setTokenizer(tokenizer: AceAjax$Tokenizer): void,

        /**
         * Sets a new document to associate with this object.
         * @param doc The new document to associate with
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
         * @param firstRow The starting row region
         * @param lastRow The final row region
         */
        fireUpdateEvent(firstRow: number, lastRow: number): void,

        /**
         * Starts tokenizing at the row indicated.
         * @param startRow The row to start at
         */
        start(startRow: number): void,

        /**
         * Stops tokenizing.
         */
        stop(): void,

        /**
         * Gives list of tokens of the row. (tokens are cached)
         * @param row The row to get tokens at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}
         * @param row The row to get state at
         */
        getState(row: number): string
}

declare var BackgroundTokenizer: {

    /**
     * Creates a new `BackgroundTokenizer` object.
     * @param tokenizer The tokenizer to use
     * @param editor The editor to associate with
     */
    new(
        tokenizer: AceAjax$Tokenizer,
        editor: AceAjax$Editor): AceAjax$BackgroundTokenizer
};


/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s.
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 */
declare export interface AceAjax$Document {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Replaces all the lines in the current `Document` with the value of `text`.
         * @param text The text to use
         */
        setValue(text: string): void,

        /**
         * Returns all the lines in the document as a single string, split by the new line character.
         */
        getValue(): string,

        /**
         * Creates a new `Anchor` to define a floating point in the document.
         * @param row The row number to use
         * @param column The column number to use
         */
        createAnchor(row: number, column: number): void,

        /**
         * Returns the newline character that's being used, depending on the value of `newLineMode`.
         */
        getNewLineCharacter(): string,

        /**
         * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
         * @param newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
         */
        getNewLineMode(): string,

        /**
         * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
         * @param text The text to check
         */
        isNewLine(text: string): boolean,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row index to retrieve
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns all lines in the document as string array. Warning: The caller should not modify this array!
         */
        getAllLines(): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * [Given a range within the document, this function returns all the text within that range as a single string.]{: #Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Inserts the elements in `lines` into the document, starting at the row index given by `row`. This method also triggers the `'change'` event.
         * @param row The index of the row to insert at
         * @param lines An array of strings
         */
        insertLines(row: number, lines: string[]): any,

        /**
         * Inserts a new line into the document at the current row's `position`. This method also triggers the `'change'` event.
         * @param position The position to insert at
         */
        insertNewLine(position: AceAjax$Position): any,

        /**
         * Inserts `text` into the `position` at the current row. This method also triggers the `'change'` event.
         * @param position The position to insert at
         * @param text A chunk of text
         */
        insertInLine(position: any, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Removes the specified columns from the `row`. This method also triggers the `'change'` event.
         * @param row The row to remove from
         * @param startColumn The column to start removing at
         * @param endColumn The column to stop removing at
         */
        removeInLine(row: number, startColumn: number, endColumn: number): any,

        /**
         * Removes a range of full lines. This method also triggers the `'change'` event.
         * @param firstRow The first row to be removed
         * @param lastRow The last row to be removed
         */
        removeLines(firstRow: number, lastRow: number): string[],

        /**
         * Removes the new line between `row` and the row immediately following it. This method also triggers the `'change'` event.
         * @param row The row to check
         */
        removeNewLine(row: number): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Applies all the changes previously accumulated. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        applyDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Reverts any changes previously applied. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        revertDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Converts an index position in a document to a `{row, column}` object.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param index An index to convert
         * @param startRow =0 The row from which to start the conversion
        */
        indexToPosition(index: number, startRow: number): AceAjax$Position,

        /**
         * Converts the `{row, column}` position in a document to the character's index.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param pos The `{row, column}` to convert
         * @param startRow =0 The row from which to start the conversion
        */
        positionToIndex(pos: AceAjax$Position, startRow: number): number
}

declare var Document: {

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string): AceAjax$Document,

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string[]): AceAjax$Document
};


/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 */
declare export interface AceAjax$IEditSession {
    selection: AceAjax$Selection,
        bgTokenizer: AceAjax$BackgroundTokenizer,
        doc: AceAjax$Document,
        on(event: string, fn: (e: any) => any): void,
        findMatchingBracket(position: AceAjax$Position): void,
        addFold(text: string, range: AceAjax$Range): void,
        getFoldAt(row: number, column: number): any,
        removeFold(arg: any): void,
        expandFold(arg: any): void,
        unfold(arg1: any, arg2: boolean): void,
        screenToDocumentColumn(row: number, column: number): void,
        getFoldDisplayLine(foldLine: any, docRow: number, docColumn: number): any,
        getFoldsInRange(range: AceAjax$Range): any,
        highlight(text: string): void,

        /**
         * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
         * @param doc The new `Document` to use
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Returns the `Document` associated with this session.
         */
        getDocument(): AceAjax$Document,

        /**
         * undefined
         * @param row The row to work with
         */
        $resetRowCache(row: number): void,

        /**
         * Sets the session text.
         * @param text The new text to place
         */
        setValue(text: string): void,
        setMode(mode: string): void,

        /**
         * Returns the current [[Document `Document`]] as a string.
         */
        getValue(): string,

        /**
         * Returns the string of the current selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:BackgroundTokenizer.getState}
         * @param row The row to start at
         */
        getState(row: number): string,

        /**
         * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
         * @param row The row to start at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
         * @param row The row number to retrieve from
         * @param column The column number to retrieve from
         */
        getTokenAt(row: number, column: number): AceAjax$TokenInfo,

        /**
         * Sets the undo manager.
         * @param undoManager The new undo manager
         */
        setUndoManager(undoManager: AceAjax$UndoManager): void,

        /**
         * Returns the current undo manager.
         */
        getUndoManager(): AceAjax$UndoManager,

        /**
         * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]): void; otherwise it's simply `'\t'`.
         */
        getTabString(): string,

        /**
         * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
         * @param useSoftTabs Value indicating whether or not to use soft tabs
         */
        setUseSoftTabs(useSoftTabs: boolean): void,

        /**
         * Returns `true` if soft tabs are being used, `false` otherwise.
         */
        getUseSoftTabs(): boolean,

        /**
         * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
         * @param tabSize The new tab size
         */
        setTabSize(tabSize: number): void,

        /**
         * Returns the current tab size.
         */
        getTabSize(): number,

        /**
         * Returns `true` if the character at the position is a soft tab.
         * @param position The position to check
         */
        isTabStop(position: any): boolean,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable.
         * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
         * @param row The row number
         * @param className The class to add
         */
        addGutterDecoration(row: number, className: string): void,

        /**
         * Removes `className` from the `row`.
         * @param row The row number
         * @param className The class to add
         */
        removeGutterDecoration(row: number, className: string): void,

        /**
         * Returns an array of numbers, indicating which rows have breakpoints.
         */
        getBreakpoints(): number[],

        /**
         * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param rows An array of row indices
         */
        setBreakpoints(rows: any[]): void,

        /**
         * Removes all breakpoints on the rows. This function also emites the `'changeBreakpoint'` event.
         */
        clearBreakpoints(): void,

        /**
         * Sets a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         * @param className Class of the breakpoint
         */
        setBreakpoint(row: number, className: string): void,

        /**
         * Removes a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         */
        clearBreakpoint(row: number): void,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: Function, inFront: boolean): number,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: string, inFront: boolean): number,

        /**
         * Adds a dynamic marker to the session.
         * @param marker object with update method
         * @param inFront Set to `true` to establish a front marker
         */
        addDynamicMarker(marker: any, inFront: boolean): void,

        /**
         * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
         * @param markerId A number representing a marker
         */
        removeMarker(markerId: number): void,

        /**
         * Returns an array containing the IDs of all the markers, either front or back.
         * @param inFront If `true`, indicates you only want front markers; `false` indicates only back markers
         */
        getMarkers(inFront: boolean): any[],

        /**
         * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
         * @param annotations A list of annotations
         */
        setAnnotations(annotations: AceAjax$Annotation[]): void,

        /**
         * Returns the annotations for the `EditSession`.
         */
        getAnnotations(): any,

        /**
         * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
         */
        clearAnnotations(): void,

        /**
         * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
         * @param text A block of text
         */
        $detectNewLine(text: string): void,

        /**
         * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
         * @param row The row to start at
         * @param column The column to start at
         */
        getWordRange(row: number, column: number): AceAjax$Range,

        /**
         * Gets the range of a word, including its right whitespace.
         * @param row The row number to start from
         * @param column The column number to start from
         */
        getAWordRange(row: number, column: number): any,

        /**
         * {:Document.setNewLineMode.desc}
         * @param newLineMode :Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * Returns the current new line mode.
         */
        getNewLineMode(): string,

        /**
         * Identifies if you want to use a worker for the `EditSession`.
         * @param useWorker Set to `true` to use a worker
         */
        setUseWorker(useWorker: boolean): void,

        /**
         * Returns `true` if workers are being used.
         */
        getUseWorker(): boolean,

        /**
         * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
         */
        onReloadTokenizer(): void,

        /**
         * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
         * @param mode Set a new text mode
         */
        $mode(mode: AceAjax$TextMode): void,

        /**
         * Returns the current text mode.
         */
        getMode(): AceAjax$TextMode,

        /**
         * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
         * @param scrollTop The new scroll top value
         */
        setScrollTop(scrollTop: number): void,

        /**
         * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
         */
        setScrollLeft(): void,

        /**
         * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the width of the screen.
         */
        getScreenWidth(): number,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row to retrieve from
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * {:Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position {row, column} to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Reverts previous changes to your document.
         * @param deltas An array of previous changes
         * @param dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
         */
        undoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Re-implements a previously undone change to your document.
         * @param deltas An array of previous changes
         * @param dontSelect :dontSelect}
         */
        redoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Enables or disables highlighting of the range where an undo occured.
         * @param enable If `true`, selects the range of the reinserted change
         */
        setUndoSelect(enable: boolean): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
         * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
         * @param startRow Starting row
         * @param endRow Ending row
         * @param indentString The indent token
         */
        indentRows(startRow: number, endRow: number, indentString: string): void,

        /**
         * Outdents all the rows defined by the `start` and `end` properties of `range`.
         * @param range A range of rows
         */
        outdentRows(range: AceAjax$Range): void,

        /**
         * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move up
         * @param lastRow The final row to move up
         */
        moveLinesUp(firstRow: number, lastRow: number): number,

        /**
         * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move down
         * @param lastRow The final row to move down
         */
        moveLinesDown(firstRow: number, lastRow: number): number,

        /**
         * Duplicates all the text between `firstRow` and `lastRow`.
         * @param firstRow The starting row to duplicate
         * @param lastRow The final row to duplicate
         */
        duplicateLines(firstRow: number, lastRow: number): number,

        /**
         * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
         * @param useWrapMode Enable (or disable) wrap mode
         */
        setUseWrapMode(useWrapMode: boolean): void,

        /**
         * Returns `true` if wrap mode is being used; `false` otherwise.
         */
        getUseWrapMode(): boolean,

        /**
         * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
         * @param min The minimum wrap value (the left side wrap)
         * @param max The maximum wrap value (the right side wrap)
         */
        setWrapLimitRange(min: number, max: number): void,

        /**
         * This should generally only be called by the renderer when a resize is detected.
         * @param desiredLimit The new wrap limit
         */
        adjustWrapLimit(desiredLimit: number): boolean,

        /**
         * Returns the value of wrap limit.
         */
        getWrapLimit(): number,

        /**
         * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
         * { min: wrapLimitRange_min, max: wrapLimitRange_max }
         */
        getWrapLimitRange(): any,

        /**
         * Given a string, returns an array of the display characters, including tabs and spaces.
         * @param str The string to check
         * @param offset The value to start at
         */
        $getDisplayTokens(str: string, offset: number): void,

        /**
         * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
         * @param str The string to calculate the screen width of
         * @param maxScreenColumn 
         * @param screenColumn 
         */
        $getStringScreenWidth(str: string, maxScreenColumn: number, screenColumn: number): number[],

        /**
         * Returns number of screenrows in a wrapped line.
         * @param row The row number to check
         */
        getRowLength(row: number): number,

        /**
         * Returns the position (on screen) for the last character in the provided screen row.
         * @param screenRow The screen row to check
         */
        getScreenLastRowColumn(screenRow: number): number,

        /**
         * For the given document row and column, this returns the column position of the last screen row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumn(docRow: number, docColumn: number): number,

        /**
         * For the given document row and column, this returns the document position of the last row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumnPosition(docRow: number, docColumn: number): number,

        /**
         * For the given row, this returns the split data.
         */
        getRowSplitData(): string,

        /**
         * The distance to the next tab stop at the specified screen column.
         * @param screenColumn The screen column to check
         */
        getScreenTabSize(screenColumn: number): number,

        /**
         * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
         * @param screenRow The screen row to check
         * @param screenColumn The screen column to check
         */
        screenToDocumentPosition(screenRow: number, screenColumn: number): any,

        /**
         * Converts document coordinates to screen coordinates. {:conversionConsiderations}
         * @param docRow The document row to check
         * @param docColumn The document column to check
         */
        documentToScreenPosition(docRow: number, docColumn: number): any,

        /**
         * For the given document row and column, returns the screen column.
         * @param row 
         * @param docColumn 
         */
        documentToScreenColumn(row: number, docColumn: number): number,

        /**
         * For the given document row and column, returns the screen row.
         * @param docRow 
         * @param docColumn 
         */
        documentToScreenRow(docRow: number, docColumn: number): void,

        /**
         * Returns the length of the screen.
         */
        getScreenLength(): number
}

declare var EditSession: {

    /**
     * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.
     * @param text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
     * @param mode [The inital language mode to use for the document]{: #modeParam}
     */
    new(text: string, mode?: AceAjax$TextMode): AceAjax$IEditSession,
    new(content: string, mode?: string): AceAjax$IEditSession,
    new(text: string[], mode?: string): AceAjax$IEditSession
};


/**
 * The main entry point into the Ace functionality.
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
*/
declare export interface AceAjax$Editor {
    on(ev: string, callback: (e: any) => any): void,
        addEventListener(ev: "change", callback: (ev: AceAjax$EditorChangeEvent) => any): void,
        addEventListener(ev: string, callback: Function): void,
        inMultiSelectMode: boolean,
        selectMoreLines(n: number): void,
        onTextInput(text: string): void,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        commands: AceAjax$CommandManager,
        session: AceAjax$IEditSession,
        selection: AceAjax$Selection,
        renderer: AceAjax$VirtualRenderer,
        keyBinding: AceAjax$KeyBinding,
        container: HTMLElement,
        onSelectionChange(e: any): void,
        onChangeMode(e?: any): void,
        execCommand(command: string, args?: any): void,

        /**
         * Sets a Configuration Option
         */
        setOption(optionName: any, optionValue: any): void,

        /**
         * Sets Configuration Options
         */
        setOptions(keyValueTuples: any): void,

        /**
         * Get a Configuration Option
         */
        getOption(name: any): any,

        /**
         * Get Configuration Options
         */
        getOptions(): any,

        /**
         * Get rid of console warning by setting this to Infinity
         */
        $blockScrolling: number,

        /**
         * Sets a new key handler, such as "vim" or "windows".
         * @param keyboardHandler The new key handler
         */
        setKeyboardHandler(keyboardHandler: string): void,

        /**
         * Returns the keyboard handler, such as "vim" or "windows".
         */
        getKeyboardHandler(): string,

        /**
         * Sets a new editsession to use. This method also emits the `'changeSession'` event.
         * @param session The new session to use
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Returns the current session being used.
         */
        getSession(): AceAjax$IEditSession,

        /**
         * Sets the current document to `val`.
         * @param val The new value to set for the document
         * @param cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
         */
        setValue(val: string, cursorPos?: number): string,

        /**
         * Returns the current session's content.
         */
        getValue(): string,

        /**
         * Returns the currently highlighted selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         */
        resize(force?: boolean): void,

        /**
         * {:VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * {:VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * {:VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * {:VirtualRenderer.unsetStyle}
         */
        unsetStyle(): void,

        /**
         * Set a new font size (in pixels) for the editor text.
         * @param size A font size ( _e.g._ "12px")
         */
        setFontSize(size: string): void,

        /**
         * Brings the current `textInput` into focus.
         */
        focus(): void,

        /**
         * Returns `true` if the current `textInput` is in focus.
         */
        isFocused(): void,

        /**
         * Blurs the current `textInput`.
         */
        blur(): void,

        /**
         * Emitted once the editor comes into focus.
         */
        onFocus(): void,

        /**
         * Emitted once the editor has been blurred.
         */
        onBlur(): void,

        /**
         * Emitted whenever the document is changed.
         * @param e Contains a single property, `data`, which has the delta of changes
         */
        onDocumentChange(e: any): void,

        /**
         * Emitted when the selection changes.
         */
        onCursorChange(): void,

        /**
         * Returns the string of text currently highlighted.
         */
        getCopyText(): string,

        /**
         * Called whenever a text "copy" happens.
         */
        onCopy(): void,

        /**
         * Called whenever a text "cut" happens.
         */
        onCut(): void,

        /**
         * Called whenever a text "paste" happens.
         * @param text The pasted text
         */
        onPaste(text: string): void,

        /**
         * Inserts `text` into wherever the cursor is pointing.
         * @param text The new text to add
         */
        insert(text: string): void,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Sets how fast the mouse scrolling should do.
         * @param speed A value indicating the new speed (in milliseconds)
         */
        setScrollSpeed(speed: number): void,

        /**
         * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
         */
        getScrollSpeed(): number,

        /**
         * Sets the delay (in milliseconds) of the mouse drag.
         * @param dragDelay A value indicating the new delay
         */
        setDragDelay(dragDelay: number): void,

        /**
         * Returns the current mouse drag delay.
         */
        getDragDelay(): number,

        /**
         * Indicates how selections should occur.
         * By default, selections are set to "line". There are no other styles at the moment,
        although this code change in the future.
        This function also emits the `'changeSelectionStyle'` event.
         * @param style The new selection style
        */
        setSelectionStyle(style: string): void,

        /**
         * Returns the current selection style.
         */
        getSelectionStyle(): string,

        /**
         * Determines whether or not the current line should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the current line
         */
        setHighlightActiveLine(shouldHighlight: boolean): void,

        /**
         * Returns `true` if current lines are always highlighted.
         */
        getHighlightActiveLine(): void,

        /**
         * Determines if the currently selected word should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the currently selected word
         */
        setHighlightSelectedWord(shouldHighlight: boolean): void,

        /**
         * Returns `true` if currently highlighted words are to be highlighted.
         */
        getHighlightSelectedWord(): boolean,

        /**
         * If `showInvisibiles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
         * @param showInvisibles Specifies whether or not to show invisible characters
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns `true` if invisible characters are being shown.
         */
        getShowInvisibles(): boolean,

        /**
         * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
         * @param showPrintMargin Specifies whether or not to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns `true` if the print margin is being shown.
         */
        getShowPrintMargin(): boolean,

        /**
         * Sets the column defining where the print margin should be.
         * @param showPrintMargin Specifies the new print margin
         */
        setPrintMarginColumn(showPrintMargin: number): void,

        /**
         * Returns the column number of where the print margin is.
         */
        getPrintMarginColumn(): number,

        /**
         * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
         * @param readOnly Specifies whether the editor can be modified or not
         */
        setReadOnly(readOnly: boolean): void,

        /**
         * Returns `true` if the editor is set to read-only mode.
         */
        getReadOnly(): boolean,

        /**
         * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
         * @param enabled Enables or disables behaviors
         */
        setBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
         */
        getBehavioursEnabled(): boolean,

        /**
         * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
         * when such a character is typed in.
         * @param enabled Enables or disables wrapping behaviors
         */
        setWrapBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the wrapping behaviors are currently enabled.
         */
        getWrapBehavioursEnabled(): void,

        /**
         * Indicates whether the fold widgets are shown or not.
         * @param show Specifies whether the fold widgets are shown
         */
        setShowFoldWidgets(show: boolean): void,

        /**
         * Returns `true` if the fold widgets are shown.
         */
        getShowFoldWidgets(): void,

        /**
         * Removes words of text from the editor. A "word" is defined as a string of characters bookended by whitespace.
         * @param dir The direction of the deletion to occur, either "left" or "right"
         */
        remove(dir: string): void,

        /**
         * Removes the word directly to the right of the current selection.
         */
        removeWordRight(): void,

        /**
         * Removes the word directly to the left of the current selection.
         */
        removeWordLeft(): void,

        /**
         * Removes all the words to the left of the current selection, until the start of the line.
         */
        removeToLineStart(): void,

        /**
         * Removes all the words to the right of the current selection, until the end of the line.
         */
        removeToLineEnd(): void,

        /**
         * Splits the line at the current selection (by inserting an `'\n'`).
         */
        splitLine(): void,

        /**
         * Transposes current line.
         */
        transposeLetters(): void,

        /**
         * Converts the current selection entirely into lowercase.
         */
        toLowerCase(): void,

        /**
         * Converts the current selection entirely into uppercase.
         */
        toUpperCase(): void,

        /**
         * Inserts an indentation into the current cursor position or indents the selected lines.
         */
        indent(): void,

        /**
         * Indents the current line.
         */
        blockIndent(): void,

        /**
         * Outdents the current line.
         */
        blockOutdent(arg?: string): void,

        /**
         * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
         */
        toggleCommentLines(): void,

        /**
         * Works like [[EditSession.getTokenAt]], except it returns a number.
         */
        getNumberAt(): number,

        /**
         * If the character before the cursor is a number, this functions changes its value by `amount`.
         * @param amount The value to change the numeral by (can be negative to decrease value)
         */
        modifyNumber(amount: number): void,

        /**
         * Removes all the lines in the current selection
         */
        removeLines(): void,

        /**
         * Shifts all the selected lines down one row.
         */
        moveLinesDown(): number,

        /**
         * Shifts all the selected lines up one row.
         */
        moveLinesUp(): number,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Copies all the selected lines up one row.
         */
        copyLinesUp(): number,

        /**
         * Copies all the selected lines down one row.
         */
        copyLinesDown(): number,

        /**
         * {:VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * {:VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Indicates if the row is currently visible on the screen.
         * @param row The row to check
         */
        isRowVisible(row: number): boolean,

        /**
         * Indicates if the entire row is currently visible on the screen.
         * @param row The row to check
         */
        isRowFullyVisible(row: number): boolean,

        /**
         * Selects the text from the current position of the document until where a "page down" finishes.
         */
        selectPageDown(): void,

        /**
         * Selects the text from the current position of the document until where a "page up" finishes.
         */
        selectPageUp(): void,

        /**
         * Shifts the document to wherever "page down" is, as well as moving the cursor position.
         */
        gotoPageDown(): void,

        /**
         * Shifts the document to wherever "page up" is, as well as moving the cursor position.
         */
        gotoPageUp(): void,

        /**
         * Scrolls the document to wherever "page down" is, without changing the cursor position.
         */
        scrollPageDown(): void,

        /**
         * Scrolls the document to wherever "page up" is, without changing the cursor position.
         */
        scrollPageUp(): void,

        /**
         * Moves the editor to the specified row.
         */
        scrollToRow(): void,

        /**
         * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
         * @param line The line to scroll to
         * @param center If `true`
         * @param animate If `true` animates scrolling
         * @param callback Function to be called when the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Attempts to center the current selection on the screen.
         */
        centerSelection(): void,

        /**
         * Gets the current position of the cursor.
         */
        getCursorPosition(): AceAjax$Position,

        /**
         * Returns the screen position of the cursor.
         */
        getCursorPositionScreen(): number,

        /**
         * {:Selection.getRange}
         */
        getSelectionRange(): AceAjax$Range,

        /**
         * Selects all the text in editor.
         */
        selectAll(): void,

        /**
         * {:Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        moveCursorTo(row: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
         * @param position An object with two properties, row and column
         */
        moveCursorToPosition(position: AceAjax$Position): void,

        /**
         * Moves the cursor's row and column to the next matching bracket.
         */
        jumpToMatching(): void,

        /**
         * Moves the cursor to the specified line number, and also into the indiciated column.
         * @param lineNumber The line number to go to
         * @param column A column number to go to
         * @param animate If `true` animates scolling
         */
        gotoLine(lineNumber: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        navigateTo(row: number, column: number): void,

        /**
         * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateUp(times?: number): void,

        /**
         * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateDown(times?: number): void,

        /**
         * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateLeft(times?: number): void,

        /**
         * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateRight(times: number): void,

        /**
         * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
         */
        navigateLineStart(): void,

        /**
         * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
         */
        navigateLineEnd(): void,

        /**
         * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
         */
        navigateFileEnd(): void,

        /**
         * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
         */
        navigateFileStart(): void,

        /**
         * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
         */
        navigateWordRight(): void,

        /**
         * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
         */
        navigateWordLeft(): void,

        /**
         * Replaces the first occurance of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replace(replacement: string, options?: any): void,

        /**
         * Replaces all occurances of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replaceAll(replacement: string, options?: any): void,

        /**
         * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
         */
        getLastSearchOptions(): any,

        /**
         * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
         * @param needle The text to search for (optional)
         * @param options An object defining various search properties
         * @param animate If `true` animate scrolling
         */
        find(needle: string, options?: any, animate?: boolean): void,

        /**
         * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findNext(options?: any, animate?: boolean): void,

        /**
         * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findPrevious(options?: any, animate?: boolean): void,

        /**
         * {:UndoManager.undo}
         */
        undo(): void,

        /**
         * {:UndoManager.redo}
         */
        redo(): void,

        /**
         * Cleans up the entire editor.
         */
        destroy(): void
}

declare var Editor: {

    /**
     * Creates a new `Editor` object.
     * @param renderer Associated `VirtualRenderer` that draws everything
     * @param session The `EditSession` to refer to
     */
    new(
        renderer: AceAjax$VirtualRenderer,
        session?: AceAjax$IEditSession): AceAjax$Editor
};

declare interface AceAjax$EditorChangeEvent {
    start: AceAjax$Position,
        end: AceAjax$Position,
        action: string,
        lines: any[]
}

declare export interface AceAjax$PlaceHolder {
    on(event: string, fn: (e: any) => any): void,

        /**
         * PlaceHolder.setup()
         * TODO
         */
        setup(): void,

        /**
         * PlaceHolder.showOtherMarkers()
         * TODO
         */
        showOtherMarkers(): void,

        /**
         * PlaceHolder.hideOtherMarkers()
         * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
         */
        hideOtherMarkers(): void,

        /**
         * PlaceHolder@onUpdate(e)
         * Emitted when the place holder updates.
         */
        onUpdate(): void,

        /**
         * PlaceHolder@onCursorChange(e)
         * Emitted when the cursor changes.
         */
        onCursorChange(): void,

        /**
         * PlaceHolder.detach()
         * TODO
         */
        detach(): void,

        /**
         * PlaceHolder.cancel()
         * TODO
         */
        cancel(): void
}

declare var PlaceHolder: {

    /**
     * - 
     * @param session (Document): The document to associate with the anchor
    - 
     * @param length (Number): The starting row position
    - 
     * @param pos (Number): The starting column position
    - 
     * @param others (String):
    - 
     * @param mainClass (String):
    - 
     * @param othersClass (String):
    */
    new(
        session: AceAjax$Document,
        length: number,
        pos: number,
        others: string,
        mainClass: string,
        othersClass: string): AceAjax$PlaceHolder,
    new(
        session: AceAjax$IEditSession,
        length: number,
        pos: AceAjax$Position,
        positions: AceAjax$Position[]): AceAjax$PlaceHolder
};

declare export interface AceAjax$IRangeList {
    ranges: AceAjax$Range[],
        pointIndex(pos: AceAjax$Position, startIndex?: number): void,
        addList(ranges: AceAjax$Range[]): void,
        add(ranges: AceAjax$Range): void,
        merge(): AceAjax$Range[],
        substractPoint(pos: AceAjax$Position): void
}

declare export var RangeList: {
    new(): AceAjax$IRangeList
};


/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogus to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 */
declare export interface AceAjax$Range {
    startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number,
        start: AceAjax$Position,
        end: AceAjax$Position,
        isEmpty(): boolean,

        /**
         * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
         * @param range A range to check against
         */
        isEqual(range: AceAjax$Range): void,

        /**
         * Returns a string containing the range's row and column information, given like this:
         * ```
        [start.row/start.column] -> [end.row/end.column]
        ```
        */
        toString(): void,

        /**
         * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
         * ```javascript
        this.start.row <= row <= this.end.row &&
        this.start.column <= column <= this.end.column
        ```
         * @param row A row to check for
         * @param column A column to check for
        */
        contains(row: number, column: number): boolean,

        /**
         * Compares `this` range (A) with another range (B).
         * @param range A range to compare with
         */
        compareRange(range: AceAjax$Range): number,

        /**
         * Checks the row and column points of `p` with the row and column points of the calling range.
         * @param p A point to compare with
         */
        comparePoint(p: AceAjax$Range): number,

        /**
         * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
         * @param range A range to compare with
         */
        containsRange(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if passed in `range` intersects with the one calling this method.
         * @param range A range to compare with
         */
        intersects(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isEnd(row: number, column: number): boolean,

        /**
         * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isStart(row: number, column: number): boolean,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setStart(row: number, column: number): void,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setEnd(row: number, column: number): void,

        /**
         * Returns `true` if the `row` and `column` are within the given range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        inside(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's starting points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideStart(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's ending points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideEnd(row: number, column: number): boolean,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compare(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareStart(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareEnd(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareInside(row: number, column: number): number,

        /**
         * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
         * @param firstRow The starting row
         * @param lastRow The ending row
         */
        clipRows(firstRow: number, lastRow: number): AceAjax$Range,

        /**
         * Changes the row and column points for the calling range for both the starting and ending points.
         * @param row A new row to extend to
         * @param column A new column to extend to
         */
        extend(row: number, column: number): AceAjax$Range,

        /**
         * Returns `true` if the range spans across multiple lines.
         */
        isMultiLine(): boolean,

        /**
         * Returns a duplicate of the calling range.
         */
        clone(): AceAjax$Range,

        /**
         * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
         */
        collapseRows(): AceAjax$Range,

        /**
         * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.
         * @param session The `EditSession` to retrieve coordinates from
         */
        toScreenRange(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Creates and returns a new `Range` based on the row and column of the given parameters.
         * @param start A starting point to use
         * @param end An ending point to use
         */
        fromPoints(start: AceAjax$Range, end: AceAjax$Range): AceAjax$Range
}

declare var Range: {
    fromPoints(pos1: AceAjax$Position, pos2: AceAjax$Position): AceAjax$Range,
    new(
        startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number): AceAjax$Range
};

declare export interface AceAjax$RenderLoop {}

declare var RenderLoop: {
    new(): AceAjax$RenderLoop
};


/**
 * A set of methods for setting and retrieving the editor's scrollbar.
 */
declare export interface AceAjax$ScrollBar {

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @param e Contains one property, `"data"`, which indicates the current scroll top position
     */
    onScroll(e: any): void,

        /**
         * Returns the width of the scroll bar.
         */
        getWidth(): number,

        /**
         * Sets the height of the scroll bar, in pixels.
         * @param height The new height
         */
        setHeight(height: number): void,

        /**
         * Sets the inner height of the scroll bar, in pixels.
         * @param height The new inner height
         */
        setInnerHeight(height: number): void,

        /**
         * Sets the scroll top of the scroll bar.
         * @param scrollTop The new scroll top
         */
        setScrollTop(scrollTop: number): void
}

declare var ScrollBar: {

    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param parent A DOM element
     */
    new(parent: HTMLElement): AceAjax$ScrollBar
};


/**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 */
declare export interface AceAjax$Search {

    /**
     * Sets the search options via the `options` parameter.
     * @param options An object containing all the new search properties
     */
    set(options: any): AceAjax$Search,

        /**
         * [Returns an object containing all the search options.]{: #Search.getOptions}
         */
        getOptions(): any,

        /**
         * Sets the search options via the `options` parameter.
         * @param An object containing all the search propertie
         */
        setOptions(An: any): void,

        /**
         * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        find(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Searches for all occurances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        findAll(session: AceAjax$IEditSession): AceAjax$Range[],

        /**
         * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
         * @param input The text to search in
         * @param replacement The replacing text
        + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
        If `options.needle` was not found, this function returns `null`.
        */
        replace(input: string, replacement: string): string
}

declare var Search: {

    /**
     * Creates a new `Search` object. The following search options are avaliable:
     * - `needle`: The string or regular expression you're looking for
    - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.
    - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.
    - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.
    - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.
    - `range`: The [[Range]] to search within. Set this to `null` for the whole document
    - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.
    - `start`: The starting [[Range]] or cursor position to begin the search
    - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.
    */
    new(): AceAjax$Search
};


/**
 * Contains the cursor position and the text selection of an edit session.
 * The row/columns used in the selection are in document coordinates representing ths coordinates as thez appear in the document before applying soft wrap and folding.
 */
declare export interface AceAjax$Selection {
    addEventListener(ev: string, callback: Function): void,
        moveCursorWordLeft(): void,
        moveCursorWordRight(): void,
        fromOrientedRange(range: AceAjax$Range): void,
        setSelectionRange(match: any): void,
        getAllRanges(): AceAjax$Range[],
        on(event: string, fn: (e: any) => any): void,
        addRange(range: AceAjax$Range): void,

        /**
         * Returns `true` if the selection is empty.
         */
        isEmpty(): boolean,

        /**
         * Returns `true` if the selection is a multi-line.
         */
        isMultiLine(): boolean,

        /**
         * Gets the current position of the cursor.
         */
        getCursor(): AceAjax$Position,

        /**
         * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
         * @param row The new row
         * @param column The new column
         */
        setSelectionAnchor(row: number, column: number): void,

        /**
         * Returns an object containing the `row` and `column` of the calling selection anchor.
         */
        getSelectionAnchor(): any,

        /**
         * Returns an object containing the `row` and `column` of the calling selection lead.
         */
        getSelectionLead(): any,

        /**
         * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
         * @param columns The number of columns to shift by
         */
        shiftSelection(columns: number): void,

        /**
         * Returns `true` if the selection is going backwards in the document.
         */
        isBackwards(): boolean,

        /**
         * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
         */
        getRange(): AceAjax$Range,

        /**
         * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Selects all the text in the document.
         */
        selectAll(): void,

        /**
         * Sets the selection to the provided range.
         * @param range The range of text to select
         * @param reverse Indicates if the range should go backwards (`true`) or not
         */
        setRange(range: AceAjax$Range, reverse: boolean): void,

        /**
         * Moves the selection cursor to the indicated row and column.
         * @param row The row to select to
         * @param column The column to select to
         */
        selectTo(row: number, column: number): void,

        /**
         * Moves the selection cursor to the row and column indicated by `pos`.
         * @param pos An object containing the row and column
         */
        selectToPosition(pos: any): void,

        /**
         * Moves the selection up one row.
         */
        selectUp(): void,

        /**
         * Moves the selection down one row.
         */
        selectDown(): void,

        /**
         * Moves the selection right one column.
         */
        selectRight(): void,

        /**
         * Moves the selection left one column.
         */
        selectLeft(): void,

        /**
         * Moves the selection to the beginning of the current line.
         */
        selectLineStart(): void,

        /**
         * Moves the selection to the end of the current line.
         */
        selectLineEnd(): void,

        /**
         * Moves the selection to the end of the file.
         */
        selectFileEnd(): void,

        /**
         * Moves the selection to the start of the file.
         */
        selectFileStart(): void,

        /**
         * Moves the selection to the first word on the right.
         */
        selectWordRight(): void,

        /**
         * Moves the selection to the first word on the left.
         */
        selectWordLeft(): void,

        /**
         * Moves the selection to highlight the entire word.
         */
        getWordRange(): void,

        /**
         * Selects an entire word boundary.
         */
        selectWord(): void,

        /**
         * Selects a word, including its right whitespace.
         */
        selectAWord(): void,

        /**
         * Selects the entire line.
         */
        selectLine(): void,

        /**
         * Moves the cursor up one row.
         */
        moveCursorUp(): void,

        /**
         * Moves the cursor down one row.
         */
        moveCursorDown(): void,

        /**
         * Moves the cursor left one column.
         */
        moveCursorLeft(): void,

        /**
         * Moves the cursor right one column.
         */
        moveCursorRight(): void,

        /**
         * Moves the cursor to the start of the line.
         */
        moveCursorLineStart(): void,

        /**
         * Moves the cursor to the end of the line.
         */
        moveCursorLineEnd(): void,

        /**
         * Moves the cursor to the end of the file.
         */
        moveCursorFileEnd(): void,

        /**
         * Moves the cursor to the start of the file.
         */
        moveCursorFileStart(): void,

        /**
         * Moves the cursor to the word on the right.
         */
        moveCursorLongWordRight(): void,

        /**
         * Moves the cursor to the word on the left.
         */
        moveCursorLongWordLeft(): void,

        /**
         * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
         * @param rows The number of rows to move by
         * @param chars The number of characters to move by
         */
        moveCursorBy(rows: number, chars: number): void,

        /**
         * Moves the selection to the position indicated by its `row` and `column`.
         * @param position The position to move to
         */
        moveCursorToPosition(position: any): void,

        /**
         * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
         */
        moveCursorTo(row: number, column: number, keepDesiredColumn?: boolean): void,

        /**
         * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn :preventUpdateBool}
         */
        moveCursorToScreen(row: number, column: number, keepDesiredColumn: boolean): void
}

declare var Selection: {

    /**
     * Creates a new `Selection` object.
     * @param session The session to use
     */
    new(session: AceAjax$IEditSession): AceAjax$Selection
};

declare export interface AceAjax$Split {

    /**
     * Returns the number of splits.
     */
    getSplits(): number,

        /**
         * Returns the editor identified by the index `idx`.
         * @param idx The index of the editor you want
         */
        getEditor(idx: number): void,

        /**
         * Returns the current editor.
         */
        getCurrentEditor(): AceAjax$Editor,

        /**
         * Focuses the current editor.
         */
        focus(): void,

        /**
         * Blurs the current editor.
         */
        blur(): void,

        /**
         * Sets a theme for each of the available editors.
         * @param theme The name of the theme to set
         */
        setTheme(theme: string): void,

        /**
         * Sets the keyboard handler for the editor.
         * @param keybinding 
         */
        setKeyboardHandler(keybinding: string): void,

        /**
         * Executes `callback` on all of the available editors.
         * @param callback A callback function to execute
         * @param scope The default scope for the callback
         */
        forEach(callback: Function, scope: string): void,

        /**
         * Sets the font size, in pixels, for all the available editors.
         * @param size The new font size
         */
        setFontSize(size: number): void,

        /**
         * Sets a new [[EditSession `EditSession`]] for the indicated editor.
         * @param session The new edit session
         * @param idx The editor's index you're interested in
         */
        setSession(session: AceAjax$IEditSession, idx: number): void,

        /**
         * Returns the orientation.
         */
        getOrientation(): number,

        /**
         * Sets the orientation.
         * @param orientation The new orientation value
         */
        setOrientation(orientation: number): void,

        /**
         * Resizes the editor.
         */
        resize(): void
}

declare var Split: {
    new(): AceAjax$Split
};


/**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 */
declare export interface AceAjax$TokenIterator {

    /**
     * Tokenizes all the items from the current point to the row prior in the document.
     */
    stepBackward(): string[],

        /**
         * Tokenizes all the items from the current point until the next row in the document. If the current point is at the end of the file, this function returns `null`. Otherwise, it returns the tokenized string.
         */
        stepForward(): string,

        /**
         * Returns the current tokenized string.
         */
        getCurrentToken(): AceAjax$TokenInfo,

        /**
         * Returns the current row.
         */
        getCurrentTokenRow(): number,

        /**
         * Returns the current column.
         */
        getCurrentTokenColumn(): number
}

declare var TokenIterator: {

    /**
     * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
     * @param session The session to associate with
     * @param initialRow The row to start the tokenizing at
     * @param initialColumn The column to start the tokenizing at
     */
    new(
        session: AceAjax$IEditSession,
        initialRow: number,
        initialColumn: number): AceAjax$TokenIterator
};


/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 */
declare export interface AceAjax$Tokenizer {

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     */
    getLineTokens(): any
}

declare var Tokenizer: {

    /**
     * Constructs a new tokenizer based on the given rules and flags.
     * @param rules The highlighting rules
     * @param flag Any additional regular expression flags to pass (like "i" for case insensitive)
     */
    new(rules: any, flag: string): AceAjax$Tokenizer
};


/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 */
declare export interface AceAjax$UndoManager {

    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     * - `args[0]` is an array of deltas
    - `args[1]` is the document to associate with
     * @param options Contains additional properties
    */
    execute(options: any): void,

        /**
         * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
         * @param dontSelect :dontSelect}
         */
        undo(dontSelect?: boolean): AceAjax$Range,

        /**
         * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
         * @param dontSelect :dontSelect}
         */
        redo(dontSelect: boolean): void,

        /**
         * Destroys the stack of undo and redo redo operations.
         */
        reset(): void,

        /**
         * Returns `true` if there are undo operations left to perform.
         */
        hasUndo(): boolean,

        /**
         * Returns `true` if there are redo operations left to perform.
         */
        hasRedo(): boolean,

        /**
         * Returns `true` if the dirty counter is 0
         */
        isClean(): boolean,

        /**
         * Sets dirty counter to 0
         */
        markClean(): void
}

declare var UndoManager: {

    /**
     * Resets the current undo state and creates a new `UndoManager`.
     */
    new(): AceAjax$UndoManager
};


/**
 * The class that is responsible for drawing everything you see on the screen!
 */
declare export interface AceAjax$VirtualRenderer {
    scroller: any,
        characterWidth: number,
        lineHeight: number,
        screenToTextCoordinates(left: number, top: number): void,

        /**
         * Associates the renderer with an [[EditSession `EditSession`]].
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Triggers a partial update of the text, from the range given by the two parameters.
         * @param firstRow The first row to update
         * @param lastRow The last row to update
         */
        updateLines(firstRow: number, lastRow: number): void,

        /**
         * Triggers a full update of the text, for all the rows.
         */
        updateText(): void,

        /**
         * Triggers a full update of all the layers, for all the rows.
         * @param force If `true`, forces the changes through
         */
        updateFull(force: boolean): void,

        /**
         * Updates the font size.
         */
        updateFontSize(): void,

        /**
         * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         * @param gutterWidth The width of the gutter in pixels
         * @param width The width of the editor in pixels
         * @param height The hiehgt of the editor, in pixels
         */
        onResize(force: boolean, gutterWidth: number, width: number, height: number): void,

        /**
         * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
         */
        adjustWrapLimit(): void,

        /**
         * Identifies whether you want to have an animated scroll or not.
         * @param shouldAnimate Set to `true` to show animated scrolls
         */
        setAnimatedScroll(shouldAnimate: boolean): void,

        /**
         * Returns whether an animated scroll happens or not.
         */
        getAnimatedScroll(): boolean,

        /**
         * Identifies whether you want to show invisible characters or not.
         * @param showInvisibles Set to `true` to show invisibles
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns whether invisible characters are being shown or not.
         */
        getShowInvisibles(): boolean,

        /**
         * Identifies whether you want to show the print margin or not.
         * @param showPrintMargin Set to `true` to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin is being shown or not.
         */
        getShowPrintMargin(): boolean,

        /**
         * Identifies whether you want to show the print margin column or not.
         * @param showPrintMargin Set to `true` to show the print margin column
         */
        setPrintMarginColumn(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin column is being shown or not.
         */
        getPrintMarginColumn(): boolean,

        /**
         * Returns `true` if the gutter is being shown.
         */
        getShowGutter(): boolean,

        /**
         * Identifies whether you want to show the gutter or not.
         * @param show Set to `true` to show the gutter
         */
        setShowGutter(show: boolean): void,

        /**
         * Returns the root element containing this renderer.
         */
        getContainerElement(): HTMLElement,

        /**
         * Returns the element that the mouse events are attached to
         */
        getMouseEventTarget(): HTMLElement,

        /**
         * Returns the element to which the hidden text area is added.
         */
        getTextAreaContainer(): HTMLElement,

        /**
         * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getFirstFullyVisibleRow(): number,

        /**
         * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getLastFullyVisibleRow(): number,

        /**
         * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Sets the padding for all the layers.
         * @param padding A new padding value (in pixels)
         */
        setPadding(padding: number): void,

        /**
         * Returns whether the horizontal scrollbar is set to be always visible.
         */
        getHScrollBarAlwaysVisible(): boolean,

        /**
         * Identifies whether you want to show the horizontal scrollbar or not.
         * @param alwaysVisible Set to `true` to make the horizontal scroll bar visible
         */
        setHScrollBarAlwaysVisible(alwaysVisible: boolean): void,

        /**
         * Schedules an update to all the front markers in the document.
         */
        updateFrontMarkers(): void,

        /**
         * Schedules an update to all the back markers in the document.
         */
        updateBackMarkers(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        addGutterDecoration(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        removeGutterDecoration(): void,

        /**
         * Redraw breakpoints.
         */
        updateBreakpoints(): void,

        /**
         * Sets annotations for the gutter.
         * @param annotations An array containing annotations
         */
        setAnnotations(annotations: any[]): void,

        /**
         * Updates the cursor icon.
         */
        updateCursor(): void,

        /**
         * Hides the cursor icon.
         */
        hideCursor(): void,

        /**
         * Shows the cursor icon.
         */
        showCursor(): void,

        /**
         * Scrolls the cursor into the first visibile area of the editor
         */
        scrollCursorIntoView(): void,

        /**
         * {:EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * {:EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the first visible row, regardless of whether it's fully visible or not.
         */
        getScrollTopRow(): number,

        /**
         * Returns the last visible row, regardless of whether it's fully visible or not.
         */
        getScrollBottomRow(): number,

        /**
         * Gracefully scrolls from the top of the editor to the row indicated.
         * @param row A row id
         */
        scrollToRow(row: number): void,

        /**
         * Gracefully scrolls the editor to the row indicated.
         * @param line A line number
         * @param center If `true`, centers the editor the to indicated line
         * @param animate If `true` animates scrolling
         * @param callback Function to be called after the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Scrolls the editor to the y pixel indicated.
         * @param scrollTop The position to scroll to
         */
        scrollToY(scrollTop: number): number,

        /**
         * Scrolls the editor across the x-axis to the pixel indicated.
         * @param scrollLeft The position to scroll to
         */
        scrollToX(scrollLeft: number): number,

        /**
         * Scrolls the editor across both x- and y-axes.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        scrollBy(deltaX: number, deltaY: number): void,

        /**
         * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        isScrollableBy(deltaX: number, deltaY: number): boolean,

        /**
         * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
         * @param row The document row position
         * @param column The document column position
         */
        textToScreenCoordinates(row: number, column: number): any,

        /**
         * Focuses the current container.
         */
        visualizeFocus(): void,

        /**
         * Blurs the current container.
         */
        visualizeBlur(): void,

        /**
         * undefined
         * @param position 
         */
        showComposition(position: number): void,

        /**
         * Sets the inner text of the current composition to `text`.
         * @param text A string of text to use
         */
        setCompositionText(text: string): void,

        /**
         * Hides the current composition.
         */
        hideComposition(): void,

        /**
         * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
         * @param style A class name
         */
        unsetStyle(style: string): void,

        /**
         * Destroys the text and cursor layers for this renderer.
         */
        destroy(): void
}

declare var VirtualRenderer: {

    /**
     * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
     * @param container The root element of the editor
     * @param theme The starting theme
     */
    new(container: HTMLElement, theme?: string): AceAjax$VirtualRenderer
};
declare var ace: AceAjax$Ace;
declare module 'acl' {
    declare type strings = string | string[];
    declare type Value = string | number;
    declare type Values = Value | Value[];
    declare type Action = () => any;
    declare type Callback = (err: Error) => any;
    declare type AnyCallback = (err: Error, obj: any) => any;
    declare type AllowedCallback = (err: Error, allowed: boolean) => any;
    declare type GetUserId = (req: http.IncomingMessage, res: http.ServerResponse) => Value;
    declare interface AclStatic {
        new(backend: Backend<any>, logger: Logger, options: Option): Acl,
        new(backend: Backend<any>, logger: Logger): Acl,
        new(backend: Backend<any>): Acl,
        memoryBackend: MemoryBackendStatic
    }
    declare interface Logger {
        debug: (msg: string) => any
    }
    declare interface Acl {
        addUserRoles: (userId: Value, roles: strings, cb?: Callback) => Promise<void>,
            removeUserRoles: (userId: Value, roles: strings, cb?: Callback) => Promise<void>,
            userRoles: (userId: Value, cb?: (err: Error, roles: string[]) => any) => Promise<string[]>,
            roleUsers: (role: Value, cb?: (err: Error, users: Values) => any) => Promise<any>,
            hasRole: (
                userId: Value,
                role: string,
                cb?: (err: Error, isInRole: boolean) => any) => Promise<boolean>,
            addRoleParents: (role: string, parents: Values, cb?: Callback) => Promise<void>,
            removeRole: (role: string, cb?: Callback) => Promise<void>,
            removeResource: (resource: string, cb?: Callback) => Promise<void>,
            allow: {
                (roles: Values, resources: strings, permissions: strings, cb?: Callback): Promise<void>,
                (aclSets: AclSet | AclSet[]): Promise<void >
            },
            removeAllow: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Callback) => Promise<void>,
            removePermissions: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Function) => Promise<void>,
            allowedPermissions: (userId: Value, resources: strings, cb?: AnyCallback) => Promise<void>,
            isAllowed: (
                userId: Value,
                resources: strings,
                permissions: strings,
                cb?: AllowedCallback) => Promise<boolean>,
            areAnyRolesAllowed: (
                roles: strings,
                resource: strings,
                permissions: strings,
                cb?: AllowedCallback) => Promise<any>,
            whatResources: (roles: strings, permissions: strings, cb?: AnyCallback) => Promise<any>,
            permittedResources: (roles: strings, permissions: strings, cb?: Function) => Promise<void>,
            middleware: (
                numPathComponents: number,
                userId: Value | GetUserId,
                actions: strings) => Promise<any >
    }
    declare interface Option {
        buckets?: BucketsOption
    }
    declare interface BucketsOption {
        meta?: string,
            parents?: string,
            permissions?: string,
            resources?: string,
            roles?: string,
            users?: string
    }
    declare interface AclSet {
        roles: strings,
            allows: AclAllow[]
    }
    declare interface AclAllow {
        resources: strings,
            permissions: strings
    }
    declare type MemoryBackend = {} & Backend

    declare interface MemoryBackendStatic {
        new(): MemoryBackend
    }
    declare interface Backend<T>{
        begin: () => T,
        end: (transaction: T, cb?: Action) => void,
        clean: (cb?: Action) => void,
        get: (bucket: string, key: Value, cb?: Action) => void,
        union: (bucket: string, keys: Value[], cb?: Action) => void,
        add: (transaction: T, bucket: string, key: Value, values: Values) => void,
        del: (transaction: T, bucket: string, keys: Value[]) => void,
        remove: (transaction: T, bucket: string, key: Value, values: Values) => void,
        endAsync: Function,
        getAsync: Function,
        cleanAsync: Function,
        unionAsync: Function
    }
    declare interface Contract {
        (args: IArguments): Contract | NoOp,
            debug: boolean,
            fulfilled: boolean,
            args: any[],
            checkedParams: string[],
            params: (...types: string[]) => Contract | NoOp,
            end: () => void
    }
    declare interface NoOp {
        params: (...types: string[]) => NoOp,
            end: () => void
    }
    declare type RedisBackend = {} & Backend

    declare interface RedisBackendStatic {
        new(redis: redis.RedisClient, prefix: string): RedisBackend,
        new(redis: redis.RedisClient): RedisBackend
    }
    declare type MongodbBackend = {} & Backend

    declare interface MongodbBackendStatic {
        new(db: mongo.Db, prefix: string, useSingle: boolean): MongodbBackend,
        new(db: mongo.Db, prefix: string): MongodbBackend,
        new(db: mongo.Db): MongodbBackend
    }
    declare     var _: AclStatic;
    declare module.exports: typeof _
}

declare var npm$namespace$acorn: {
    parse: typeof acorn$parse,
    parseExpressionAt: typeof acorn$parseExpressionAt,
    getLineInfo: typeof acorn$getLineInfo,
}
declare var version: string;

declare export function acorn$parse(pattern: any): NodeJS$ReadWriteStream

declare function acorn$parseExpressionAt(input: string, pos: number, options?: acorn$Options): ESTree.Expression

declare function acorn$getLineInfo(input: string, offset: number): ESTree.Position

declare var defaultOptions: acorn$Options;

declare interface acorn$TokenType {
    label: string,
        keyword: string,
        beforeExpr: boolean,
        startsExpr: boolean,
        isLoop: boolean,
        isAssign: boolean,
        prefix: boolean,
        postfix: boolean,
        binop: number,
        updateContext: (prevType: acorn$TokenType) => any
}

declare interface acorn$AbstractToken {
    start: number,
        end: number,
        loc: ESTree.SourceLocation,
        range: [number, number]
}

declare type acorn$Token = {
    type: acorn$TokenType,
    value: any
} & acorn$AbstractToken


declare type acorn$Comment = {
    type: string,
    value: string
} & acorn$AbstractToken


declare export interface acorn$Options {
    recurse: boolean
}
declare module 'acorn' {
    declare module.exports: typeof acorn
}
declare interface adal$Config {
    tenant?: string,
        clientId: string,
        redirectUri?: string,
        cacheLocation?: string,
        displayCall?: (urlNavigate: string) => any,
        correlationId?: string,
        loginResource?: string,
        resource?: string,
        endpoints?: any,
        extraQueryParameter?: string,
        postLogoutRedirectUri?: string
}

declare interface adal$User {
    userName: string,
        profile: any
}

declare export interface adal$RequestInfo {
    command: string,
        arguments: any
}

declare interface adal$Logging {
    log: (message: string) => void,
        level: LoggingLevel
}

declare interface adal$AuthenticationContextStatic {
    new(config: adal$Config): adal$AuthenticationContext
}

declare interface adal$AuthenticationContext {
    instance: string,
        config: adal$Config,

        /**
         * Gets initial Idtoken for the app backend
         * Saves the resulting Idtoken in localStorage.
         */
        login(): void,

        /**
         * Indicates whether login is in progress now or not.
         */
        loginInProgress(): boolean,

        /**
         * Gets token for the specified resource from local storage cache
         * @param  A URI that identifies the resource for which the token is valid.
         * @returns  token if exists and not expired or null
         */
        getCachedToken(resource: string): string,

        /**
         * Retrieves and parse idToken from localstorage
         * @returns  user object
         */
        getCachedUser(): adal$User,
        registerCallback(
            expectedState: string,
            resource: string,
            callback: (message: string, token: string) => any): void,

        /**
         * Acquire token from cache if not expired and available. Acquires token from iframe if expired.
         * @param  ResourceUri identifying the target resource
         * @param  
         */
        acquireToken(resource: string, callback: (message: string, token: string) => any): void,

        /**
         * Redirect the Browser to Azure AD Authorization endpoint
         * @param  The authorization request url
         */
        promptUser(urlNavigate: string): void,

        /**
         * Clear cache items.
         */
        clearCache(): void,

        /**
         * Clear cache items for a resource.
         */
        clearCacheForResource(resource: string): void,

        /**
         * Logout user will redirect page to logout endpoint.
         * After logout, it will redirect to post_logout page if provided.
         */
        logOut(): void,

        /**
         * Gets a user profile
         * @param  - The callback that handles the response.
         */
        getUser(callback: (message: string, user?: adal$User) => any): void,

        /**
         * Checks if hash contains access token or id token or error_description
         * @param  -  Hash passed from redirect page
         * @returns  
         */
        isCallback(hash: string): boolean,

        /**
         * Gets login error
         * @returns  error message related to login
         */
        getLoginError(): string,

        /**
         * Gets requestInfo from given hash.
         * @returns  for appropriate hash.
         */
        getRequestInfo(hash: string): adal$RequestInfo,

        /**
         * Saves token from hash that is received from redirect.
         */
        saveTokenFromHash(requestInfo: adal$RequestInfo): void,

        /**
         * Gets resource for given endpoint if mapping is provided with config.
         * @param  -  API endpoint
         * @returns  resource for this API endpoint
         */
        getResourceForEndpoint(endpoint: string): string,

        /**
         * Handles redirection after login operation. 
         * Gets access token from url and saves token to the (local/session) storage
        or saves error in case unsuccessful login.
        */
        handleWindowCallback(): void,
        log(level: number, message: string, error: any): void,
        error(message: string, error: any): void,
        warn(message: string): void,
        info(message: string): void,
        verbose(message: string): void
}
declare var AuthenticationContext: adal$AuthenticationContextStatic;
declare var Logging: adal$Logging;
declare module 'adal' {
    declare module.exports: typeof NO PRINT IMPLEMENTED: ObjectLiteralExpression
}
declare var addToHome: {

    /**
     * Shows the popup.
     * @param  Override all the compatibility checks and always show the popup.
     */
    show: (overrideChecks: boolean) => void,

    /**
     * Closes the popup. 
     */
    close: () => void,

    /**
     * Reset the local and session storages so the popup will show again (for automatic mode - has no affect if manually opening the popup). 
     */
    reset: () => void
};
declare module 'adm-zip' {
    declare module.exports: typeof AdmZip

    /**
     * The ZipEntry is more than a structure representing the entry inside the
     * zip file. Beside the normal attributes and headers a entry can have, the
    class contains a reference to the part of the file where the compressed
    data resides and decompresses it when requested. It also compresses the
    data and creates the headers required to write in the zip file.
    */
    declare interface AdmZip$IZipEntry {

        /**
         * Represents the full name and path of the file
         */
        entryName: string,
            rawEntryName: Buffer,

            /**
             * Extra data associated with this entry.
             */
            extra: Buffer,

            /**
             * Entry comment.
             */
            comment: string,
            name: string,

            /**
             * Read-Only property that indicates the type of the entry.
             */
            isDirectory: boolean,

            /**
             * Get the header associated with this ZipEntry.
             */
            header: Buffer,

            /**
             * Retrieve the compressed data for this entry. Note that this may trigger
             * compression if any properties were modified.
             */
            getCompressedData(): Buffer,

            /**
             * Asynchronously retrieve the compressed data for this entry. Note that
             * this may trigger compression if any properties were modified.
             */
            getCompressedDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: string): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: Buffer): void,

            /**
             * Get the decompressed data associated with this entry.
             */
            getData(): Buffer,

            /**
             * Asynchronously get the decompressed data associated with this entry.
             */
            getDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Returns the CEN Entry Header to be written to the output zip file, plus
             * the extra data and the entry comment.
             */
            packHeader(): Buffer,

            /**
             * Returns a nicely formatted string with the most important properties of
             * the ZipEntry.
             */
            toString(): string
    }
}
declare module 'grid' {
    declare class ColumnChangeEvent {
        constructor(type: string): this;
        toString(): string;
        withColumn(column: Column): ColumnChangeEvent;
        withColumnGroup(columnGroup: ColumnGroup): ColumnChangeEvent;
        withFromIndex(fromIndex: number): ColumnChangeEvent;
        withPinnedColumnCount(pinnedColumnCount: number): ColumnChangeEvent;
        withToIndex(toIndex: number): ColumnChangeEvent;
        getFromIndex(): number;
        getToIndex(): number;
        getPinnedColumnCount(): number;
        getType(): string;
        getColumn(): Column;
        getColumnGroup(): ColumnGroup;
        isPivotChanged(): boolean;
        isValueChanged(): boolean;
        isIndividualColumnResized(): boolean
    }
    declare class Utils {
        iterateObject(object: any, callback: (key: string, value: any) => void): void;
        cloneObject(object: any): any;
        map<TItem, TResult>(array: TItem[], callback: (item: TItem) => TResult): TResult[];
        forEach<T>(array: T[], callback: (item: T, index: number) => void): void;
        filter<T>(array: T[], callback: (item: T) => boolean): T[];
        assign(object: any, source: any): void;
        getFunctionParameters(func: any): any;
        find(collection: any, predicate: any, value: any): any;
        toStrings<T>(array: T[]): string[];
        iterateArray<T>(array: T[], callback: (item: T, index: number) => void): void;
        isNode(o: any): boolean;
        isElement(o: any): boolean;
        isNodeOrElement(o: any): boolean;
        addChangeListener(element: HTMLElement, listener: EventListener): void;
        makeNull(value: any): any;
        removeAllChildren(node: HTMLElement): void;
        removeElement(parent: HTMLElement, cssSelector: string): void;
        removeFromParent(node: Element): void;
        isVisible(element: HTMLElement): boolean;

        /**
         * loads the template and returns it as an element. makes up for no simple way in
         * the dom api to load html directly, eg we cannot do this: document.createElement(template)
         */
        loadTemplate(template: string): CSG$Node;
        querySelectorAll_addCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_removeCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_replaceCssClass(
            eParent: any,
            selector: string,
            cssClassToRemove: string,
            cssClassToAdd: string): void;
        addOrRemoveCssClass(element: HTMLElement, className: string, addOrRemove: boolean): void;
        addCssClass(element: HTMLElement, className: string): void;
        offsetHeight(element: HTMLElement): number;
        offsetWidth(element: HTMLElement): number;
        removeCssClass(element: HTMLElement, className: string): void;
        removeFromArray<T>(array: T[], object: T): void;
        defaultComparator(valueA: any, valueB: any): number;
        formatWidth(width: number | string): string;

        /**
         * Tries to use the provided renderer.
         */
        useRenderer<TParams>(
            eParent: Element,
            eRenderer: (params: TParams) => CSG$Node | string,
            params: TParams): void;

        /**
         * If icon provided, use this (either a string, or a function callback).
         * if not, then use the second parameter, which is the svgFactory function
         */
        createIcon(
            iconName: any,
            gridOptionsWrapper: any,
            colDefWrapper: any,
            svgFactoryFunc: () => CSG$Node): HTMLSpanElement;
        addStylesToElement(eElement: any, styles: any): void;
        getScrollbarWidth(): number;
        isKeyPressed(event: KeyboardEvent, keyToCheck: number): boolean;
        setVisible(element: HTMLElement, visible: boolean): void;
        isBrowserIE(): boolean;
        isBrowserSafari(): boolean
    }
    declare class Constants {
        STEP_EVERYTHING: number;
        STEP_FILTER: number;
        STEP_SORT: number;
        STEP_MAP: number;
        ASC: string;
        DESC: string;
        ROW_BUFFER_SIZE: number;
        MIN_COL_WIDTH: number;
        SUM: string;
        MIN: string;
        MAX: string;
        KEY_TAB: number;
        KEY_ENTER: number;
        KEY_BACKSPACE: number;
        KEY_DELETE: number;
        KEY_ESCAPE: number;
        KEY_SPACE: number;
        KEY_DOWN: number;
        KEY_UP: number;
        KEY_LEFT: number;
        KEY_RIGHT: number
    }
    declare class Column {
        colIdSequence: number;
        colDef: ColDef;
        actualWidth: any;
        visible: any;
        colId: any;
        pinned: boolean;
        index: number;
        aggFunc: string;
        pivotIndex: number;
        sort: string;
        sortedAt: number;
        constructor(colDef: ColDef, actualWidth: any): this;
        isGreaterThanMax(width: number): boolean;
        getMinimumWidth(): number;
        setMinimum(): void
    }
    declare class ColumnGroup {
        pinned: any;
        name: any;
        allColumns: Column[];
        displayedColumns: Column[];
        expandable: boolean;
        expanded: boolean;
        actualWidth: number;
        constructor(pinned: any, name: any): this;
        getMinimumWidth(): number;
        addColumn(column: any): void;
        calculateExpandable(): void;
        calculateActualWidth(): void;
        calculateDisplayedColumns(): void;
        addToVisibleColumns(colsToAdd: any): void
    }
    declare class GridOptionsWrapper {
        init(gridOptions: GridOptions, eventService: EventService): void;
        isRowSelection(): boolean;
        isRowDeselection(): boolean;
        isRowSelectionMulti(): boolean;
        getContext(): any;
        isVirtualPaging(): boolean;
        isShowToolPanel(): boolean;
        isToolPanelSuppressPivot(): boolean;
        isToolPanelSuppressValues(): boolean;
        isRowsAlreadyGrouped(): boolean;
        isGroupSelectsChildren(): boolean;
        isGroupHidePivotColumns(): boolean;
        isGroupIncludeFooter(): boolean;
        isGroupSuppressBlankHeader(): boolean;
        isSuppressRowClickSelection(): boolean;
        isSuppressCellSelection(): boolean;
        isSuppressMultiSort(): boolean;
        isGroupSuppressAutoColumn(): boolean;
        isForPrint(): boolean;
        isSuppressHorizontalScroll(): boolean;
        isUnSortIcon(): boolean;
        isSuppressMenuHide(): boolean;
        getRowStyle(): any;
        getRowClass(): any;
        getRowStyleFunc(): any;
        getRowClassFunc(): any;
        getHeaderCellRenderer(): any;
        getApi(): GridApi;
        isEnableColResize(): boolean;
        isSingleClickEdit(): boolean;
        getGroupDefaultExpanded(): any;
        getGroupKeys(): string[];
        getGroupAggFunction(): (nodes: any[]) => any;
        getGroupAggFields(): string[];
        getRowData(): any[];
        isGroupUseEntireRow(): boolean;
        getGroupColumnDef(): any;
        isGroupSuppressRow(): boolean;
        isAngularCompileRows(): boolean;
        isAngularCompileFilters(): boolean;
        isAngularCompileHeaders(): boolean;
        isDebug(): boolean;
        getColumnDefs(): any[];
        getDatasource(): any;
        getRowBuffer(): number;
        isEnableSorting(): boolean;
        isEnableCellExpressions(): boolean;
        isEnableServerSideSorting(): boolean;
        isEnableFilter(): boolean;
        isEnableServerSideFilter(): boolean;
        isSuppressScrollLag(): boolean;
        getIcons(): any;
        getIsScrollLag(): () => boolean;
        getSortingOrder(): string[];
        getSlaveGrids(): GridOptions[];
        getGroupRowRenderer(): Object | Function;
        getRowHeight(): number;
        getHeaderHeight(): number;
        setHeaderHeight(headerHeight: number): void;
        isGroupHeaders(): boolean;
        setGroupHeaders(groupHeaders: boolean): void;
        getFloatingTopRowData(): any[];
        setFloatingTopRowData(rows: any[]): void;
        getFloatingBottomRowData(): any[];
        setFloatingBottomRowData(rows: any[]): void;
        isExternalFilterPresent(): boolean;
        doesExternalFilterPass(node: RowNode): boolean;
        getGroupRowInnerRenderer(): (params: any) => void;
        getColWidth(): number;
        getPinnedColCount(): number;
        getLocaleTextFunc(): Function;
        globalEventHandler(eventName: string, event?: any): void
    }
    declare class LoggerFactory {
        init(gridOptionsWrapper: GridOptionsWrapper): void;
        create(name: string): Logger
    }
    declare class Logger {
        constructor(name: string, logging: boolean): this;
        log(message: string): void
    }
    declare class Events {

        /**
         * A new set of columns has been entered, everything has potentially changed. 
         */
        EVENT_COLUMN_EVERYTHING_CHANGED: string;

        /**
         * A pivot column was added, removed or order changed. 
         */
        EVENT_COLUMN_PIVOT_CHANGE: string;

        /**
         * A value column was added, removed or agg function was changed. 
         */
        EVENT_COLUMN_VALUE_CHANGE: string;

        /**
         * A column was moved 
         */
        EVENT_COLUMN_MOVED: string;

        /**
         * One or more columns was shown / hidden 
         */
        EVENT_COLUMN_VISIBLE: string;

        /**
         * A column group was opened / closed 
         */
        EVENT_COLUMN_GROUP_OPENED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_RESIZED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_PINNED_COUNT_CHANGED: string;
        EVENT_MODEL_UPDATED: string;
        EVENT_CELL_CLICKED: string;
        EVENT_CELL_DOUBLE_CLICKED: string;
        EVENT_CELL_CONTEXT_MENU: string;
        EVENT_CELL_VALUE_CHANGED: string;
        EVENT_CELL_FOCUSED: string;
        EVENT_ROW_SELECTED: string;
        EVENT_SELECTION_CHANGED: string;
        EVENT_BEFORE_FILTER_CHANGED: string;
        EVENT_AFTER_FILTER_CHANGED: string;
        EVENT_FILTER_MODIFIED: string;
        EVENT_BEFORE_SORT_CHANGED: string;
        EVENT_AFTER_SORT_CHANGED: string;
        EVENT_VIRTUAL_ROW_REMOVED: string;
        EVENT_ROW_CLICKED: string;
        EVENT_READY: string
    }
    declare class EventService {
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        dispatchEvent(eventType: string, event?: any): void
    }
    declare class MasterSlaveService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            loggerFactory: LoggerFactory,
            eventService: EventService): void;
        fireHorizontalScrollEvent(horizontalScroll: number): void;
        onScrollEvent(horizontalScroll: number): void;
        onColumnEvent(event: ColumnChangeEvent): void
    }
    declare class ColumnApi {
        constructor(_columnController: ColumnController): this;
        sizeColumnsToFit(gridWidth: any): void;
        hideColumns(colIds: any, hide: any): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        getColumnGroup(name: string): ColumnGroup;
        getDisplayNameForCol(column: any): string;
        getColumn(key: any): Column;
        setState(columnState: any): void;
        getState(): [any];
        isPinning(): boolean;
        getVisibleColAfter(col: Column): Column;
        getVisibleColBefore(col: Column): Column;
        setColumnVisible(column: Column, visible: boolean): void;
        getAllColumns(): Column[];
        getDisplayedColumns(): Column[];
        getPivotedColumns(): Column[];
        getValueColumns(): Column[];
        moveColumn(fromIndex: number, toIndex: number): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        setColumnAggFunction(column: Column, aggFunc: string): void;
        setColumnWidth(column: Column, newWidth: number): void;
        removeValueColumn(column: Column): void;
        addValueColumn(column: Column): void;
        removePivotColumn(column: Column): void;
        setPinnedColumnCount(count: number): void;
        addPivotColumn(column: Column): void;
        getHeaderGroups(): ColumnGroup[];
        hideColumn(colId: any, hide: any): void
    }
    declare class ColumnController {
        constructor(): this;
        init(
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            valueService: ValueService,
            masterSlaveController: MasterSlaveService,
            eventService: EventService): void;
        getColumnApi(): ColumnApi;
        isSetupComplete(): boolean;
        getHeaderGroups(): ColumnGroup[];
        getPinnedContainerWidth(): number;
        addPivotColumn(column: Column): void;
        setPinnedColumnCount(count: number): void;
        removePivotColumn(column: Column): void;
        addValueColumn(column: Column): void;
        removeValueColumn(column: Column): void;
        setColumnWidth(column: Column, newWidth: number): void;
        setColumnAggFunction(column: Column, aggFunc: string): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        moveColumn(fromIndex: number, toIndex: number): void;
        getBodyContainerWidth(): number;
        getValueColumns(): Column[];
        getPivotedColumns(): Column[];
        getDisplayedColumns(): Column[];
        getAllColumns(): Column[];
        setColumnVisible(column: Column, visible: boolean): void;
        getVisibleColBefore(col: any): Column;
        getVisibleColAfter(col: Column): Column;
        isPinning(): boolean;
        getState(): [any];
        setState(columnState: any): void;
        getColumns(keys: any[]): Column[];
        getColumn(key: any): Column;
        getDisplayNameForCol(column: any): string;
        getColumnGroup(name: string): ColumnGroup;
        onColumnsChanged(): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        hideColumns(colIds: any, hide: any): void;
        sizeColumnsToFit(gridWidth: any): void
    }
    declare interface CsvExportParams {
        skipHeader?: boolean,
            skipFooters?: boolean,
            skipGroups?: boolean,
            fileName?: string
    }
    declare class CsvCreator {
        constructor(rowController: InMemoryRowController, columnController: ColumnController, grid: Grid, valueService: ValueService): this;
        exportDataAsCsv(params?: CsvExportParams): void;
        getDataAsCsv(params?: CsvExportParams): string
    }
    declare class ExpressionService {
        init(loggerFactory: LoggerFactory): void;
        evaluate(expression: string, params: any): any
    }
    declare interface TextAndNumberFilterParameters {

        /**
         * What to do when new rows are loaded. The default is to reset the filter, to keep it in line with 'set' filters. If you want to keep the selection, then set this value to 'keep'. 
         */
        newRowsAction?: string
    }
    declare class TextFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare class NumberFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare interface ColDef {

        /**
         * If sorting by default, set it here. Set to 'asc' or 'desc' 
         */
        sort?: string,

            /**
             * If sorting more than one column by default, the milliseconds when this column was sorted, so we know what order to sort the columns in. 
             */
            sortedAt?: number,

            /**
             * The sort order, provide an array with any of the following in any order ['asc','desc',null] 
             */
            sortingOrder?: string[],

            /**
             * The name to render in the column header 
             */
            headerName: string,

            /**
             * The field of the row to get the cells data from 
             */
            field: string,

            /**
             * Expression or function to get the cells value. 
             */
            headerValueGetter?: string | Function,

            /**
             * The unique ID to give the column. This is optional. If missing, the ID will default to the field. If both field and colId are missing, a unique ID will be generated.
             * This ID is used to identify the column in the API for sorting, filtering etc. 
             */
            colId?: string,

            /**
             * Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,
             * however we want all default values to be false and we want columns to be visible by default. 
             */
            hide?: boolean,

            /**
             * Tooltip for the column header 
             */
            headerTooltip?: string,

            /**
             * Expression or function to get the cells value. 
             */
            valueGetter?: string | Function,

            /**
             * To provide custom rendering to the header. 
             */
            headerCellRenderer?: Function | Object,

            /**
             * CSS class for the header 
             */
            headerClass?: string | string[] | ((params: any) => string | string[]),

            /**
             * Initial width, in pixels, of the cell 
             */
            width?: number,

            /**
             * Min width, in pixels, of the cell 
             */
            minWidth?: number,

            /**
             * Max width, in pixels, of the cell 
             */
            maxWidth?: number,

            /**
             * Class to use for the cell. Can be string, array of strings, or function. 
             */
            cellClass?: string | string[] | ((cellClassParams: any) => string | string[]),

            /**
             * An object of css values. Or a function returning an object of css values. 
             */
            cellStyle?: {} | ((params: any) => {}),

            /**
             * A function for rendering a cell. 
             */
            cellRenderer?: Function | {},

            /**
             * A function for rendering a floating cell. 
             */
            floatingCellRenderer?: Function | {},

            /**
             * Name of function to use for aggregation. One of [sum,min,max]. 
             */
            aggFunc?: string,

            /**
             * Comparator function for custom sorting. 
             */
            comparator?: Function,

            /**
             * Set to true to render a selection checkbox in the column. 
             */
            checkboxSelection?: boolean,

            /**
             * Set to true if no menu should be shown for this column header. 
             */
            suppressMenu?: boolean,

            /**
             * Set to true if no sorting should be done for this column. 
             */
            suppressSorting?: boolean,

            /**
             * Set to true if you want the unsorted icon to be shown when no sort is applied to this column. 
             */
            unSortIcon?: boolean,

            /**
             * Set to true if you want this columns width to be fixed during 'size to fit' operation. 
             */
            suppressSizeToFit?: boolean,

            /**
             * Set to true if you do not want this column to be resizable by dragging it's edge. 
             */
            suppressResize?: boolean,

            /**
             * If grouping columns, the group this column belongs to. 
             */
            headerGroup?: string,

            /**
             * Whether to show the column when the group is open / closed. 
             */
            headerGroupShow?: string,

            /**
             * Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable. 
             */
            editable?: boolean | (Function),

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            newValueHandler?: Function,

            /**
             * If true, this cell gets refreshed when api.softRefreshView() gets called. 
             */
            volatile?: boolean,

            /**
             * Cell template to use for cell. Useful for AngularJS cells. 
             */
            template?: string,

            /**
             * Cell template URL to load template from to use for cell. Useful for AngularJS cells. 
             */
            templateUrl?: string,

            /**
             * one of the built in filter names: [set, number, text], or a filter function
             */
            filter?: string | Function,

            /**
             * The filter params are specific to each filter! 
             */
            filterParams?: SetFilterParameters | TextAndNumberFilterParameters,

            /**
             * Rules for applying css classes 
             */
            cellClassRules?: {
                [cssClassName: string]: (Function | string)
            },

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            onCellValueChanged?: Function,

            /**
             * Function callback, gets called when a cell is clicked. 
             */
            onCellClicked?: Function,

            /**
             * Function callback, gets called when a cell is double clicked. 
             */
            onCellDoubleClicked?: Function,

            /**
             * Function callback, gets called when a cell is right clicked. 
             */
            onCellContextMenu?: Function
    }
    declare class SetFilterModel {
        constructor(colDef: ColDef, rowModel: any, valueGetter: any, doesRowPassOtherFilters: any): this;
        refreshAfterNewRowsLoaded(keepSelection: any, isSelectAll: boolean): void;
        refreshAfterAnyFilterChanged(): void;
        setMiniFilter(newMiniFilter: any): boolean;
        getMiniFilter(): any;
        getDisplayedValueCount(): any;
        getDisplayedValue(index: any): any;
        selectEverything(): void;
        isFilterActive(): boolean;
        selectNothing(): void;
        getUniqueValueCount(): any;
        getUniqueValue(index: any): any;
        unselectValue(value: any): void;
        selectValue(value: any): void;
        isValueSelected(value: any): boolean;
        isEverythingSelected(): boolean;
        isNothingSelected(): boolean;
        getModel(): any;
        setModel(model: any, isSelectAll: boolean): void
    }
    declare interface SetFilterParameters {

        /**
         * Same as cell renderer for grid (you can use the same one in both locations). Setting it separatly here allows for the value to be rendered differently in the filter. 
         */
        cellRenderer?: Function,

            /**
             * The height of the cell. 
             */
            cellHeight?: number,

            /**
             * The values to display in the filter. 
             */
            values?: any,

            /**
             * What to do when new rows are loaded. The default is to reset the filter, as the set of values to select from can have changed. If you want to keep the selection, then set this value to 'keep'. 
             */
            newRowsAction?: string,

            /**
             * If true, the filter will not remove items that are no longer availabe due to other filters. 
             */
            suppressRemoveEntries?: boolean
    }
    declare class SetFilter mixins Filter {
        init(params: any): void;
        afterGuiAttached(): void;
        isFilterActive(): boolean;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        onNewRowsLoaded(): void;
        onAnyFilterChanged(): void;
        getApi(): any
    }
    declare class PopupService {
        init(ePopupParent: any): void;
        positionPopup(eventSource: any, ePopup: any, minWidth: any): void;
        addAsModalPopup(eChild: any, closeOnEsc: boolean): (event: any) => void
    }
    declare interface RowNode {

        /**
         * Unique ID for the node. Can be though of as the index of the row in the original list,
         * however exceptions apply so don't depend on uniqueness. 
         */
        id?: number,

            /**
             * The user provided data 
             */
            data?: any,

            /**
             * The parent node to this node, or empty if top level 
             */
            parent?: RowNode,

            /**
             * How many levels this node is from the top 
             */
            level?: number,

            /**
             * True if this node is a group node (ie has children) 
             */
            group?: boolean,

            /**
             * True if this is the first child in this group 
             */
            firstChild?: boolean,

            /**
             * True if this is the last child in this group 
             */
            lastChild?: boolean,

            /**
             * The index of this node in the group 
             */
            childIndex?: number,

            /**
             * True if this row is a floating row 
             */
            floating?: boolean,

            /**
             * True if this row is a floating top row 
             */
            floatingTop?: boolean,

            /**
             * True if this row is a floating bottom row 
             */
            floatingBottom?: boolean,

            /**
             * If using quick filter, stores a string representation of the row for searching against 
             */
            quickFilterAggregateText?: string,

            /**
             * Groups only - True if row is a footer. Footers  have group = true and footer = true 
             */
            footer?: boolean,

            /**
             * Groups only - Children of this group 
             */
            children?: RowNode[],

            /**
             * Groups only - The field we are pivoting on eg Country
             */
            field?: string,

            /**
             * Groups only - The key for the pivot eg Ireland, UK, USA 
             */
            key?: any,

            /**
             * Groups only - Filtered children of this group 
             */
            childrenAfterFilter?: RowNode[],

            /**
             * Groups only - Sorted children of this group 
             */
            childrenAfterSort?: RowNode[],

            /**
             * Groups only - Number of children and grand children 
             */
            allChildrenCount?: number,

            /**
             * Groups only - True if group is expanded, otherwise false 
             */
            expanded?: boolean,

            /**
             * Groups only - If doing footers, reference to the footer node for this group 
             */
            sibling?: RowNode,

            /**
             * Not to be used, internal temporary map used by the grid when creating groups 
             */
            _childrenMap?: {}
    }
    declare class FilterManager {
        init(
            grid: Grid,
            gridOptionsWrapper: GridOptionsWrapper,
            $compile: any,
            $scope: any,
            columnController: ColumnController,
            popupService: PopupService,
            valueService: ValueService): void;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        setRowModel(rowModel: any): void;
        isAdvancedFilterPresent(): boolean;
        isAnyFilterPresent(): boolean;
        isFilterPresentForCol(colId: any): any;
        setQuickFilter(newFilter: any): boolean;
        onFilterChanged(): void;
        isQuickFilterPresent(): boolean;
        doesRowPassOtherFilters(filterToSkip: any, node: any): boolean;
        doesRowPassFilter(node: any, filterToSkip?: any): boolean;
        refreshDisplayedValues(): void;
        onNewRowsLoaded(): void;
        getFilterApi(column: Column): any;
        showFilter(column: Column, eventSource: any): void
    }
    declare class TemplateService {
        templateCache: any;
        waitingCallbacks: any;
        $scope: any;
        init($scope: any): void;
        getTemplate(url: any, callback: any): any;
        handleHttpResult(httpResult: any, url: any): void
    }
    declare class SelectionRendererFactory {
        init(angularGrid: any, selectionController: any): void;
        createSelectionCheckbox(node: any, rowIndex: any): HTMLInputElement
    }
    declare class RenderedCell {
        constructor(isFirstColumn: any, column: any, $compile: any, rowRenderer: RowRenderer, gridOptionsWrapper: GridOptionsWrapper, expressionService: ExpressionService, selectionRendererFactory: SelectionRendererFactory, selectionController: SelectionController, templateService: TemplateService, cellRendererMap: {
            [key: string]: any
        }, node: any, rowIndex: number, scope: any, columnController: ColumnController, valueService: ValueService, eventService: EventService): this;
        getColumn(): Column;
        getVGridCell(): undefined.VHtmlElement;
        startEditing(key?: number): void;
        focusCell(forceBrowserFocus: boolean): void;
        createParams(): any;
        createEvent(event: any, eventSource: any): any;
        isCellEditable(): any;
        createSelectionCheckbox(): void;
        setSelected(state: boolean): void;
        isVolatile(): boolean;
        refreshCell(): void
    }
    declare class RenderedRow {
        vPinnedRow: any;
        vBodyRow: any;
        constructor(gridOptionsWrapper: GridOptionsWrapper, valueService: ValueService, parentScope: any, angularGrid: Grid, columnController: ColumnController, expressionService: ExpressionService, cellRendererMap: {
            [key: string]: any
        }, selectionRendererFactory: SelectionRendererFactory, $compile: any, templateService: TemplateService, selectionController: SelectionController, rowRenderer: RowRenderer, eBodyContainer: HTMLElement, ePinnedContainer: HTMLElement, node: any, rowIndex: number, eventService: EventService): this;
        onRowSelected(selected: boolean): void;
        softRefresh(): void;
        getRenderedCellForColumn(column: Column): RenderedCell;
        getCellForCol(column: Column): any;
        destroy(): void;
        isDataInList(rows: any[]): boolean;
        isNodeInList(nodes: RowNode[]): boolean;
        isGroup(): boolean;
        setMainRowWidth(width: number): void;
        getRowNode(): any;
        getRowIndex(): any;
        refreshCells(colIds: string[]): void
    }
    declare class SvgFactory {
        theInstance: SvgFactory;
        getInstance(): SvgFactory;
        createFilterSvg(): Element;
        createColumnShowingSvg(): Element;
        createColumnHiddenSvg(): Element;
        createMenuSvg(): Element;
        createArrowUpSvg(): Element;
        createArrowLeftSvg(): Element;
        createArrowDownSvg(): Element;
        createArrowRightSvg(): Element;
        createSmallArrowDownSvg(): Element;
        createArrowUpDownSvg(): Element
    }
    declare     function groupCellRendererFactory(
        gridOptionsWrapper: GridOptionsWrapper,
        selectionRendererFactory: SelectionRendererFactory,
        expressionService: ExpressionService): (params: any) => HTMLSpanElement
    declare class RowRenderer {
        init(
            columnModel: any,
            gridOptionsWrapper: GridOptionsWrapper,
            gridPanel: GridPanel,
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            $compile: any,
            $scope: any,
            selectionController: SelectionController,
            expressionService: ExpressionService,
            templateService: TemplateService,
            valueService: ValueService,
            eventService: EventService): void;
        setRowModel(rowModel: any): void;
        onIndividualColumnResized(column: Column): void;
        setMainRowWidths(): void;
        refreshAllFloatingRows(): void;
        refreshView(refreshFromIndex?: any): void;
        softRefreshView(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshGroupRows(): void;
        drawVirtualRows(): void;
        getFirstVirtualRenderedRow(): number;
        getLastVirtualRenderedRow(): number;
        getRenderedNodes(): any[];
        getIndexOfRenderedNode(node: any): number;
        navigateToNextCell(key: any, rowIndex: number, column: Column): void;
        onRowSelected(rowIndex: number, selected: boolean): void;
        focusCell(
            eCell: any,
            rowIndex: number,
            colIndex: number,
            colDef: ColDef,
            forceBrowserFocus: any): void;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        startEditingNextCell(rowIndex: any, column: any, shiftKey: any): void
    }
    declare class SelectionController {
        init(
            angularGrid: Grid,
            gridPanel: GridPanel,
            gridOptionsWrapper: GridOptionsWrapper,
            $scope: any,
            rowRenderer: RowRenderer,
            eventService: EventService): void;
        getSelectedNodesById(): any;
        getSelectedRows(): any;
        getSelectedNodes(): any;
        getBestCostNodeSelection(): any;
        setRowModel(rowModel: any): void;
        deselectAll(): void;
        selectAll(): void;
        selectNode(node: any, tryMulti: any, suppressEvents?: any): void;
        deselectIndex(rowIndex: any): void;
        deselectNode(node: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents?: any): void;
        isNodeSelected(node: any): boolean
    }
    declare class RenderedHeaderElement {
        constructor(eRoot: HTMLElement): this;
        getERoot(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: Column): void;
        addDragHandler(eDraggableElement: any): void;
        stopDragging(listenersToRemove: any): void
    }
    declare class RenderedHeaderCell mixins RenderedHeaderElement {
        constructor(column: Column, parentGroup: RenderedHeaderGroupCell, gridOptionsWrapper: GridOptionsWrapper, parentScope: any, filterManager: FilterManager, columnController: ColumnController, $compile: any, angularGrid: Grid, eRoot: HTMLElement): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: Column): void
    }
    declare class RenderedHeaderGroupCell mixins RenderedHeaderElement {
        constructor(columnGroup: ColumnGroup, gridOptionsWrapper: GridOptionsWrapper, columnController: ColumnController, eRoot: HTMLElement, angularGrid: Grid, parentScope: any, filterManager: FilterManager, $compile: any): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onIndividualColumnResized(column: Column): void;
        onDragStart(): void;
        onDragging(dragChange: any): void
    }
    declare class HeaderRenderer {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            angularGrid: Grid,
            filterManager: FilterManager,
            $scope: any,
            $compile: any): void;
        refreshHeader(): void;
        updateSortIcons(): void;
        updateFilterIcons(): void;
        onIndividualColumnResized(column: Column): void
    }
    declare class GroupCreator {
        init(valueService: ValueService): void;
        group(rowNodes: RowNode[], groupedCols: Column[], expandByDefault: any): RowNode[];
        isExpanded(expandByDefault: any, level: any): boolean
    }
    declare class InMemoryRowController {
        constructor(): this;
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            angularGrid: any,
            filterManager: FilterManager,
            $scope: any,
            groupCreator: GroupCreator,
            valueService: ValueService,
            eventService: EventService): void;
        getModel(): any;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        updateModel(step: any): void;
        doAggregate(): void;
        expandOrCollapseAll(expand: boolean, rowNodes: RowNode[]): void;
        onPivotChanged(): void;
        setAllRows(rows: RowNode[], firstId?: number): void
    }
    declare class VirtualPageRowController {
        rowRenderer: any;
        datasourceVersion: any;
        gridOptionsWrapper: any;
        angularGrid: any;
        datasource: any;
        virtualRowCount: any;
        foundMaxRow: any;
        pageCache: any;
        pageCacheSize: any;
        pageLoadsInProgress: any;
        pageLoadsQueued: any;
        pageAccessTimes: any;
        accessTime: any;
        maxConcurrentDatasourceRequests: any;
        maxPagesInCache: any;
        pageSize: any;
        overflowSize: any;
        init(rowRenderer: any, gridOptionsWrapper: any, angularGrid: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        createNodesFromRows(pageNumber: any, rows: any): any;
        removeFromLoading(pageNumber: any): void;
        pageLoadFailed(pageNumber: any): void;
        pageLoaded(pageNumber: any, rows: any, lastRow: any): void;
        putPageIntoCacheAndPurge(pageNumber: any, rows: any): void;
        checkMaxRowAndInformRowRenderer(pageNumber: any, lastRow: any): void;
        isPageAlreadyLoading(pageNumber: any): boolean;
        doLoadOrQueue(pageNumber: any): void;
        addToQueueAndPurgeQueue(pageNumber: any): void;
        findLeastRecentlyAccessedPage(pageIndexes: any): number;
        checkQueueForNextLoad(): void;
        loadPage(pageNumber: any): void;
        requestIsDaemon(datasourceVersionCopy: any): boolean;
        getVirtualRow(rowIndex: any): any;
        forEachNode(callback: any): void;
        getModel(): {
            getVirtualRow: (index: any) => any,
            getVirtualRowCount: () => any,
            forEachInMemory: (callback: any) => void,
            forEachNode: (callback: any) => void,
            forEachNodeAfterFilter: (callback: any) => void,
            forEachNodeAfterFilterAndSort: (callback: any) => void
        }
    }
    declare class PaginationController {
        eGui: any;
        btNext: any;
        btPrevious: any;
        btFirst: any;
        btLast: any;
        lbCurrent: any;
        lbTotal: any;
        lbRecordCount: any;
        lbFirstRowOnPage: any;
        lbLastRowOnPage: any;
        ePageRowSummaryPanel: any;
        angularGrid: any;
        callVersion: any;
        gridOptionsWrapper: any;
        datasource: any;
        pageSize: any;
        rowCount: any;
        foundMaxRow: any;
        totalPages: any;
        currentPage: any;
        init(angularGrid: any, gridOptionsWrapper: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        setTotalLabels(): void;
        calculateTotalPages(): void;
        pageLoaded(rows: any, lastRowIndex: any): void;
        updateRowLabels(): void;
        loadPage(): void;
        isCallDaemon(versionCopy: any): boolean;
        onBtNext(): void;
        onBtPrevious(): void;
        onBtFirst(): void;
        onBtLast(): void;
        isZeroPagesToDisplay(): boolean;
        enableOrDisableButtons(): void;
        createTemplate(): string;
        getGui(): any;
        setupComponents(): void
    }
    declare class BorderLayout {
        constructor(params: any): this;
        addSizeChangeListener(listener: Function): void;
        fireSizeChanged(): void;
        getGui(): any;
        doLayout(): boolean;
        getCentreHeight(): number;
        setEastVisible(visible: any): void;
        setOverlayVisible(visible: any): void;
        setSouthVisible(visible: any): void
    }
    declare class GridPanel {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnModel: ColumnController,
            rowRenderer: RowRenderer,
            masterSlaveService: MasterSlaveService): void;
        getLayout(): BorderLayout;
        getPinnedFloatingTop(): HTMLElement;
        getFloatingTopContainer(): HTMLElement;
        getPinnedFloatingBottom(): HTMLElement;
        getFloatingBottomContainer(): HTMLElement;
        ensureIndexVisible(index: any): void;
        ensureColIndexVisible(index: any): void;
        showLoading(loading: any): void;
        getWidthForSizeColsToFit(): number;
        setRowModel(rowModel: any): void;
        getBodyContainer(): HTMLElement;
        getBodyViewport(): HTMLElement;
        getPinnedColsContainer(): HTMLElement;
        getHeaderContainer(): HTMLElement;
        getRoot(): HTMLElement;
        getPinnedHeader(): HTMLElement;
        getRowsParent(): HTMLElement[];
        setBodyContainerWidth(): void;
        setPinnedColContainerWidth(): void;
        showPinnedColContainersIfNeeded(): void;
        onBodyHeightChange(): void;
        setHorizontalScrollPosition(hScrollPosition: number): void
    }
    declare class DragAndDropService {
        theInstance: DragAndDropService;
        getInstance(): DragAndDropService;
        dragItem: any;
        constructor(): this;
        stopDragging(): void;
        setDragCssClasses(eListItem: any, dragging: any): void;
        addDragSource(eDragSource: any, dragSourceCallback: any): void;
        onMouseDownDragSource(eDragSource: any, dragSourceCallback: any): void;
        addDropTarget(eDropTarget: any, dropTargetCallback: any): void
    }
    declare class AgList {
        constructor(): this;
        setReadOnly(readOnly: boolean): void;
        setEmptyMessage(emptyMessage: any): void;
        getUniqueId(): any;
        addStyles(styles: any): void;
        addCssClass(cssClass: any): void;
        addDragSource(dragSource: any): void;
        addModelChangedListener(listener: Function): void;
        addItemSelectedListener(listener: any): void;
        addItemMovedListener(listener: any): void;
        addBeforeDropListener(listener: any): void;
        setModel(model: any): void;
        getModel(): any;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        getGui(): any
    }
    declare class ColumnSelectionPanel {
        layout: any;
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        getDragSource(): any;
        getGui(): any
    }
    declare class GroupSelectionPanel {
        gridOptionsWrapper: any;
        columnController: ColumnController;
        inMemoryRowController: any;
        cColumnList: any;
        layout: any;
        constructor(columnController: ColumnController, inMemoryRowController: any, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        addDragSource(dragSource: any): void
    }
    declare class AgDropdownList {
        constructor(popupService: PopupService): this;
        setWidth(width: any): void;
        addItemSelectedListener(listener: any): void;
        fireItemSelected(item: any): void;
        setupComponents(): void;
        itemSelected(item: any): void;
        onClick(): void;
        getGui(): any;
        setSelected(item: any): void;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        setModel(model: any): void
    }
    declare class ValuesSelectionPanel {
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, popupService: PopupService, eventService: EventService): this;
        getLayout(): any;
        addDragSource(dragSource: any): void
    }
    declare class VerticalStack {
        isLayoutPanel: any;
        childPanels: any;
        eGui: any;
        constructor(): this;
        addPanel(panel: any, height: any): void;
        getGui(): any;
        doLayout(): void
    }
    declare class ToolPanel {
        layout: any;
        constructor(): this;
        init(
            columnController: any,
            inMemoryRowController: any,
            gridOptionsWrapper: GridOptionsWrapper,
            popupService: PopupService,
            eventService: EventService): void
    }
    declare interface GridOptions {
        virtualPaging?: boolean,
            toolPanelSuppressPivot?: boolean,
            toolPanelSuppressValues?: boolean,
            rowsAlreadyGrouped?: boolean,
            suppressRowClickSelection?: boolean,
            suppressCellSelection?: boolean,
            sortingOrder?: string[],
            suppressMultiSort?: boolean,
            suppressHorizontalScroll?: boolean,
            unSortIcon?: boolean,
            rowHeight?: number,
            rowBuffer?: number,
            enableColResize?: boolean,
            enableCellExpressions?: boolean,
            enableSorting?: boolean,
            enableServerSideSorting?: boolean,
            enableFilter?: boolean,
            enableServerSideFilter?: boolean,
            colWidth?: number,
            suppressMenuHide?: boolean,
            singleClickEdit?: boolean,
            debug?: boolean,
            icons?: any,
            angularCompileRows?: boolean,
            angularCompileFilters?: boolean,
            angularCompileHeaders?: boolean,
            localeText?: any,
            localeTextFunc?: Function,
            suppressScrollLag?: boolean,
            groupSuppressAutoColumn?: boolean,
            groupSelectsChildren?: boolean,
            groupHidePivotColumns?: boolean,
            groupIncludeFooter?: boolean,
            groupUseEntireRow?: boolean,
            groupSuppressRow?: boolean,
            groupSuppressBlankHeader?: boolean,
            forPrint?: boolean,
            groupColumnDef?: any,
            context?: any,
            rowStyle?: any,
            rowClass?: any,
            groupDefaultExpanded?: any,
            slaveGrids?: GridOptions[],
            rowSelection?: string,
            rowDeselection?: boolean,
            rowData?: any[],
            floatingTopRowData?: any[],
            floatingBottomRowData?: any[],
            showToolPanel?: boolean,
            groupKeys?: string[],
            groupAggFields?: string[],
            columnDefs?: any[],
            datasource?: any,
            pinnedColumnCount?: number,
            groupHeaders?: boolean,
            headerHeight?: number,
            groupRowInnerRenderer(params: any): void,
            groupRowRenderer?: Function | Object,
            isScrollLag(): boolean,
            isExternalFilterPresent(): boolean,
            doesExternalFilterPass(node: RowNode): boolean,
            getRowStyle?: any,
            getRowClass?: any,
            headerCellRenderer?: any,
            groupAggFunction(nodes: any[]): any,
            onReady(api: any): void,
            onModelUpdated(): void,
            onCellClicked(params: any): void,
            onCellDoubleClicked(params: any): void,
            onCellContextMenu(params: any): void,
            onCellValueChanged(params: any): void,
            onCellFocused(params: any): void,
            onRowSelected(params: any): void,
            onSelectionChanged(): void,
            onBeforeFilterChanged(): void,
            onAfterFilterChanged(): void,
            onFilterModified(): void,
            onBeforeSortChanged(): void,
            onAfterSortChanged(): void,
            onVirtualRowRemoved(params: any): void,
            onRowClicked(params: any): void,
            api?: GridApi,
            columnApi?: ColumnApi
    }
    declare class GridApi {
        constructor(grid: Grid, rowRenderer: RowRenderer, headerRenderer: HeaderRenderer, filterManager: FilterManager, columnController: ColumnController, inMemoryRowController: InMemoryRowController, selectionController: SelectionController, gridOptionsWrapper: GridOptionsWrapper, gridPanel: GridPanel, valueService: ValueService, masterSlaveService: MasterSlaveService, eventService: EventService): this;

        /**
         * Used internally by grid. Not intended to be used by the client. Interface may change between releases. 
         */
        ___getMasterSlaveService(): MasterSlaveService;
        getDataAsCsv(params?: CsvExportParams): string;
        exportDataAsCsv(params?: CsvExportParams): void;
        setDatasource(datasource: any): void;
        onNewDatasource(): void;
        setRowData(rowData: any): void;
        setRows(rows: any): void;
        onNewRows(): void;
        setFloatingTopRowData(rows: any[]): void;
        setFloatingBottomRowData(rows: any[]): void;
        onNewCols(): void;
        setColumnDefs(colDefs: ColDef[]): void;
        unselectAll(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshView(): void;
        softRefreshView(): void;
        refreshGroupRows(): void;
        refreshHeader(): void;
        isAnyFilterPresent(): boolean;
        isAdvancedFilterPresent(): boolean;
        isQuickFilterPresent(): boolean;
        getModel(): any;
        onGroupExpandedOrCollapsed(refreshFromIndex: any): void;
        expandAll(): void;
        collapseAll(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        setQuickFilter(newFilter: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents: any): void;
        deselectIndex(index: any): void;
        selectNode(node: any, tryMulti: any, suppressEvents: any): void;
        deselectNode(node: any): void;
        selectAll(): void;
        deselectAll(): void;
        recomputeAggregates(): void;
        sizeColumnsToFit(): void;
        showLoading(show: any): void;
        isNodeSelected(node: any): boolean;
        getSelectedNodesById(): {
            [nodeId: number]: RowNode
        };
        getSelectedNodes(): RowNode[];
        getSelectedRows(): any[];
        getBestCostNodeSelection(): any;
        getRenderedNodes(): any[];
        ensureColIndexVisible(index: any): void;
        ensureIndexVisible(index: any): void;
        ensureNodeVisible(comparator: any): void;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        getFilterApiForColDef(colDef: any): any;
        getFilterApi(key: any): any;
        getColumnDef(key: any): ColDef;
        onFilterChanged(): void;
        setSortModel(sortModel: any): void;
        getSortModel(): any;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        setHeaderHeight(headerHeight: number): void;
        setGroupHeaders(groupHeaders: boolean): void;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        hideColumn(colId: any, hide: any): void;
        hideColumns(colIds: any, hide: any): void;
        getColumnState(): [any];
        setColumnState(state: any): void;
        doLayout(): void;
        getValue(colDef: ColDef, data: any, node: any): any;
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        refreshPivot(): void
    }
    declare class ValueService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            columnController: ColumnController): void;
        getValue(colDef: ColDef, data: any, node: any): any
    }
    declare class Grid {
        constructor(eGridDiv: any, gridOptions: any, globalEventListener?: Function, $scope?: any, $compile?: any, quickFilterOnScope?: any): this;
        getRowModel(): any;
        refreshPivot(): void;
        getEventService(): EventService;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        isUsingInMemoryModel(): boolean;
        setDatasource(datasource?: any): void;
        setFinished(): void;
        onQuickFilterChanged(newFilter: any): void;
        onFilterModified(): void;
        onFilterChanged(): void;
        onRowClicked(event: any, rowIndex: any, node: any): void;
        showLoadingPanel(show: any): void;
        updateModelAndRefresh(step: any, refreshFromIndex?: any): void;
        setRows(rows?: any, firstId?: any): void;
        ensureNodeVisible(comparator: any): void;
        getFilterModel(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        getSortModel(): any;
        setSortModel(sortModel: any): void;
        onSortingChanged(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        onVirtualRowSelected(rowIndex: any, selected: any): void;
        onVirtualRowRemoved(rowIndex: any): void;
        setColumnDefs(colDefs?: ColDef[]): void;
        updateBodyContainerWidthAfterColResize(): void;
        updatePinnedColContainerWidthAfterColResize(): void;
        doLayout(): void
    }
    declare class ComponentUtil {
        SIMPLE_PROPERTIES: string[];
        SIMPLE_NUMBER_PROPERTIES: string[];
        SIMPLE_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_NUMBER_PROPERTIES: string[];
        WITH_IMPACT_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_OTHER_PROPERTIES: string[];
        CALLBACKS: string[];
        ALL_PROPERTIES: string[];
        copyAttributesToGridOptions(gridOptions: GridOptions, component: any): GridOptions;
        processOnChange(changes: any, gridOptions: GridOptions, component: any): void;
        toBoolean(value: any): boolean;
        toNumber(value: any): number
    }
    declare class AgGridNg2 {
        modelUpdated: any;
        cellClicked: any;
        cellDoubleClicked: any;
        cellContextMenu: any;
        cellValueChanged: any;
        cellFocused: any;
        rowSelected: any;
        selectionChanged: any;
        beforeFilterChanged: any;
        afterFilterChanged: any;
        filterModified: any;
        beforeSortChanged: any;
        afterSortChanged: any;
        virtualRowRemoved: any;
        rowClicked: any;
        ready: any;
        columnEverythingChanged: any;
        columnPivotChanged: any;
        columnValueChanged: any;
        columnMoved: any;
        columnVisible: any;
        columnGroupOpened: any;
        columnResized: any;
        columnPinnedCountChanged: any;
        virtualPaging: boolean;
        toolPanelSuppressPivot: boolean;
        toolPanelSuppressValues: boolean;
        rowsAlreadyGrouped: boolean;
        suppressRowClickSelection: boolean;
        suppressCellSelection: boolean;
        sortingOrder: string[];
        suppressMultiSort: boolean;
        suppressHorizontalScroll: boolean;
        unSortIcon: boolean;
        rowHeight: number;
        rowBuffer: number;
        enableColResize: boolean;
        enableCellExpressions: boolean;
        enableSorting: boolean;
        enableServerSideSorting: boolean;
        enableFilter: boolean;
        enableServerSideFilter: boolean;
        colWidth: number;
        suppressMenuHide: boolean;
        debug: boolean;
        icons: any;
        angularCompileRows: boolean;
        angularCompileFilters: boolean;
        angularCompileHeaders: boolean;
        localeText: any;
        localeTextFunc: Function;
        groupSuppressAutoColumn: boolean;
        groupSelectsChildren: boolean;
        groupHidePivotColumns: boolean;
        groupIncludeFooter: boolean;
        groupUseEntireRow: boolean;
        groupSuppressRow: boolean;
        groupSuppressBlankHeader: boolean;
        groupColumnDef: any;
        forPrint: boolean;
        context: any;
        rowStyle: any;
        rowClass: any;
        headerCellRenderer: any;
        groupDefaultExpanded: any;
        slaveGrids: GridOptions[];
        rowSelection: string;
        rowDeselection: boolean;
        rowData: any[];
        floatingTopRowData: any[];
        floatingBottomRowData: any[];
        showToolPanel: boolean;
        groupKeys: string[];
        groupAggFunction: (nodes: any[]) => void;
        groupAggFields: string[];
        columnDefs: any[];
        datasource: any;
        pinnedColumnCount: number;
        quickFilterText: string;
        groupHeaders: boolean;
        headerHeight: number;
        constructor(elementDef: any): this;
        onInit(): void;
        onChange(changes: any): void
    }
    declare interface Filter {
        getGui(): any,
            isFilterActive(): boolean,
            doesFilterPass(params: any): boolean,
            afterGuiAttached(params?: {
                hidePopup?: Function
            }): void,
            onNewRowsLoaded(): void
    }
}
declare var exports: any;
declare var module: any;
declare module 'agenda' {


    declare type Callback = (err: Error) => any;
    declare interface ResultCallback<T>{
        (err?: Error, result?: T): void
    }
    declare module.exports: typeof Agenda

    /**
     * Agenda Configuration.
     */
    declare interface Agenda$AgendaConfiguration {

        /**
         * Sets the interval with which the queue is checked. A number in milliseconds or a frequency string.
         */
        processEvery?: string | number,

            /**
             * Takes a number which specifies the default number of a specific job that can be running at any given moment.
             * By default it is 5.
             */
            defaultConcurrency?: number,

            /**
             * Takes a number which specifies the max number of jobs that can be running at any given moment. By default it
             * is 20.
             */
            maxConcurrency?: number,

            /**
             * Takes a number which specifies the default number of a specific job that can be locked at any given moment.
             * By default it is 0 for no max.
             */
            defaultLockLimit?: number,

            /**
             * Takes a number shich specifies the max number jobs that can be locked at any given moment. By default it is
             * 0 for no max.
             */
            lockLimit?: number,

            /**
             * Takes a number which specifies the default lock lifetime in milliseconds. By default it is 10 minutes. This
             * can be overridden by specifying the lockLifetime option to a defined job.
             */
            defaultLockLifetime?: number,

            /**
             * Specifies that Agenda should be initialized using and existing MongoDB connection.
             */
            mongo?: {

                /**
                 * The MongoDB database connection to use.
                 */
                db: Db,

                /**
                 * The name of the collection to use.
                 */
                collection?: string
            },

            /**
             * Specifies that Agenda should connect to MongoDB.
             */
            db?: {

                /**
                 * The connection URL.
                 */
                address: string,

                /**
                 * The name of the collection to use.
                 */
                collection?: string,

                /**
                 * Connection options to pass to MongoDB.
                 */
                options?: any
            }
    }


    /**
     * The database record associated with a job.
     */
    declare interface Agenda$JobAttributes {

        /**
         * The record identity.
         */
        _id: ObjectID,

            /**
             * The name of the job.
             */
            name: string,

            /**
             * The type of the job (single|normal).
             */
            type: string,

            /**
             * The job details.
             */
            data: {
                [name: string]: any
            },

            /**
             * The priority of the job.
             */
            priority: number,

            /**
             * How often the job is repeated using a human-readable or cron format.
             */
            repeatInterval: string | number,

            /**
             * The timezone that conforms to [moment-timezone](http://momentjs.com/timezone/).
             */
            repeatTimezone: string,

            /**
             * Date/time the job was las modified.
             */
            lastModifiedBy: string,

            /**
             * Date/time the job will run next.
             */
            nextRunAt: Date,

            /**
             * Date/time the job was locked.
             */
            lockedAt: Date,

            /**
             * Date/time the job was last run.
             */
            lastRunAt: Date,

            /**
             * Date/time the job last finished running.
             */
            lastFinishedAt: Date,

            /**
             * The reason the job failed.
             */
            failReason: string,

            /**
             * The number of times the job has failed.
             */
            failCount: number,

            /**
             * The date/time the job last failed.
             */
            failedAt: Date,

            /**
             * Job's state
             */
            disabled: boolean
    }


    /**
     * A scheduled job.
     */
    declare interface Agenda$Job {

        /**
         * The database record associated with the job.
         */
        attrs: Agenda$JobAttributes,

            /**
             * Specifies an interval on which the job should repeat.
             * @param interval A human-readable format String, a cron format String, or a Number.
             * @param options An optional argument that can include a timezone field. The timezone should be a string as
            accepted by moment-timezone and is considered when using an interval in the cron string format.
            */
            repeatEvery(interval: string | number, options?: {
                timezone?: string
            }): Agenda$Job,

            /**
             * Specifies a time when the job should repeat. [Possible values](https://github.com/matthewmueller/date#examples).
             * @param time 
             */
            repeatAt(time: string): Agenda$Job,

            /**
             * Disables the job.
             */
            disable(): Agenda$Job,

            /**
             * Enables the job.
             */
            enable(): Agenda$Job,

            /**
             * Ensure that only one instance of this job exists with the specified properties
             * @param value The properties associated with the job that must be unqiue.
             * @param opts 
             */
            unique(value: any, opts?: {
                insertOnly?: boolean
            }): Agenda$Job,

            /**
             * Specifies the next time at which the job should run.
             * @param time The next time at which the job should run.
             */
            schedule(time: string | Date): Agenda$Job,

            /**
             * Specifies the priority weighting of the job.
             * @param value The priority of the job (lowest|low|normal|high|highest|number).
             */
            priority(value: string | number): Agenda$Job,

            /**
             * Sets job.attrs.failedAt to now, and sets job.attrs.failReason to reason.
             * @param reason A message or Error object that indicates why the job failed.
             */
            fail(reason: string | Error): Agenda$Job,

            /**
             * Runs the given job and calls callback(err, job) upon completion. Normally you never need to call this manually
             * @param cb Called when the job is completed.
             */
            run(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Returns true if the job is running; otherwise, returns false.
             */
            isRunning(): boolean,

            /**
             * Saves the job into the database.
             * @param cb Called when the job is saved.
             */
            save(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Removes the job from the database and cancels the job.
             * @param cb Called after the job has beeb removed from the database.
             */
            remove(cb?: Callback): void,

            /**
             * Resets the lock on the job. Useful to indicate that the job hasn't timed out when you have very long running
             * jobs.
             * @param cb Called after the job has been saved to the database.
             */
            touch(cb?: Callback): void,

            /**
             * Calculates next time the job should run
             */
            computeNextRunAt(): Agenda$Job
    }

    declare interface Agenda$JobOptions {

        /**
         * Maximum number of that job that can be running at once (per instance of agenda)
         */
        concurrency?: number,

            /**
             * Maximum number of that job that can be locked at once (per instance of agenda)
             */
            lockLimit?: number,

            /**
             * Interval in ms of how long the job stays locked for (see multiple job processors for more info). A job will
             * automatically unlock if done() is called.
             */
            lockLifetime?: number,

            /**
             * (lowest|low|normal|high|highest|number) specifies the priority of the job. Higher priority jobs will run
             * first.
             */
            priority?: string | number
    }
}
declare module 'ajv' {
    declare module.exports: typeof Ajv
    declare type Ajv$AjvOptions = {
        v5?: boolean,
        allErrors?: boolean,
        verbose?: boolean,
        jsonPointers?: boolean,
        uniqueItems?: boolean,
        unicode?: boolean,
        format?: string,
        formats?: any,
        schemas?: any,
        missingRefs?: boolean,
        loadSchema(uri: string, callback: (error: Error, body: any) => void): void,
        removeAdditional?: boolean,
        useDefaults?: boolean,
        coerceTypes?: boolean,
        async?: any,
        transpile?: string,
        meta?: boolean,
        validateSchema?: boolean,
        addUsedSchema?: boolean,
        inlineRefs?: boolean,
        passContext?: boolean,
        loopRequired?: number,
        ownProperties?: boolean,
        multipleOfPrecision?: boolean | number,
        errorDataPath?: string,
        messages?: boolean,
        beautify?: boolean,
        cache?: any
    };

    declare type Ajv$AjvValidate = ((data: any) => boolean | PromiseLike<boolean>) & {
        errors: Ajv$ValidationError[]
    };

    declare type Ajv$AjxKeywordDefinition = {
        async?: boolean,
        type: string,
        compile?: (
            schema: any,
            parentsSchema: any) => ((data: any) => boolean | PromiseLike<boolean>),
        validate?: (schema: any, data: any) => boolean
    };

    declare type Ajv$ValidationError = {
        keyword: string,
        dataPath: string,
        schemaPath: string,
        params: any,
        message: string,
        schema: any,
        parentSchema: any,
        data: any
    };
}
declare var alertify: alertify$IAlertifyStatic;
declare interface alertify$IAlertifyStatic {

    /**
     * Create an alert dialog box
     * @param message The message passed from the callee
     * @param fn Callback function
     * @param cssClass Class(es) to append to dialog box
     * @return  alertify (ie this)
     * @since  0.0.1
     */
    alert(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Create a confirm dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param cssClass Class(es) to append to dialog box
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        confirm(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Extend the log method to create custom methods
         * @param type Custom method name
         * @return  function for logging
         * @since  0.0.1
         */
        extend(type: string): (message: string, wait?: number) => alertify$IAlertifyStatic,

        /**
         * Initialize Alertify and create the 2 main elements.
         * Initialization will happen automatically on the first
        use of alert, confirm, prompt or log.
         * @since  0.0.1
        */
        init(): void,

        /**
         * Show a new log message box
         * @param message The message passed from the callee
         * @param type Optional type of log message
         * @param wait Optional time (in ms) to wait before auto-hiding
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        log(message: string, type?: string, wait?: number): alertify$IAlertifyStatic,

        /**
         * Create a prompt dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param placeholder Default value for prompt input
         * @param cssClass Class(es) to append to dialog
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        prompt(
            message: string,
            fn?: Function,
            placeholder?: string,
            cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        success(message: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        error(message: string): alertify$IAlertifyStatic,

        /**
         * Used to set alertify properties
         * @param Properties 
         * @since  0.2.11
         */
        set(args: alertify$IProperties): void,

        /**
         * The labels used for dialog buttons
         */
        labels: alertify$ILabels,

        /**
         * Attaches alertify.error to window.onerror method
         * @since  0.3.8
         */
        debug(): void
}


/**
 * Properties for alertify.set function
 */
declare interface alertify$IProperties {

    /**
     * Default value for milliseconds display of log messages 
     */
    delay?: number,

        /**
         * Default values for display of labels 
         */
        labels?: alertify$ILabels,

        /**
         * Default button for focus 
         */
        buttonFocus?: string,

        /**
         * Should buttons be displayed in reverse order 
         */
        buttonReverse?: boolean
}


/**
 * Labels for altertify.set function 
 */
declare interface alertify$ILabels {
    ok?: string,
        cancel?: string
}
declare module 'alexa-sdk' {
    declare     export function handler(event: RequestBody, context: Context, callback?: Function): AlexaObject
    declare     export function CreateStateHandler(state: string, obj: any): any
    declare     export var StateString: string;
    declare interface AlexaObject {
        _event: any,
            _context: any,
            _callback: any,
            state: any,
            appId: any,
            response: any,
            dynamoDBTableName: any,
            saveBeforeResponse: boolean,
            registerHandlers: (...handlers: Handlers[]) => any,
            execute: () => void
    }
    declare interface Handlers {
        [intent: string]: () => void
    }
    declare interface Handler {
        on: any,
            emit(event: string, ...args: any[]): boolean,
            emitWithState: any,
            state: any,
            handler: any,
            event: RequestBody,
            attributes: any,
            context: any,
            name: any,
            isOverriden: any
    }
    declare interface Context {
        callbackWaitsForEmptyEventLoop: boolean,
            logGroupName: string,
            logStreamName: string,
            functionName: string,
            memoryLimitInMB: string,
            functionVersion: string,
            invokeid: string,
            awsRequestId: string
    }
    declare interface RequestBody {
        version: string,
            session: Session,
            request: LaunchRequest | IntentRequest | SessionEndedRequest
    }
    declare interface Session {
        new: boolean,
        sessionId: string,
            attributes: any,
            application: SessionApplication,
            user: SessionUser
    }
    declare interface SessionApplication {
        applicationId: string
    }
    declare interface SessionUser {
        userId: string,
            accessToken: string
    }
    declare type LaunchRequest = {} & IRequest

    declare type IntentRequest = {
        intent: Intent
    } & IRequest

    declare interface Intent {
        name: string,
            slots: any
    }
    declare type SessionEndedRequest = {
        reason: string
    } & IRequest

    declare interface IRequest {
        type: "LaunchRequest" | "IntentRequest" | "SessionEndedRequest",
            requestId: string,
            timeStamp: string
    }
    declare interface ResponseBody {
        version: string,
            sessionAttributes?: any,
            response: Response
    }
    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare interface OutputSpeech {
        type: "PlainText" | "SSML",
            text?: string,
            ssml?: string
    }
    declare interface Card {
        type: "Simple" | "Standard" | "LinkAccount",
            title?: string,
            content?: string,
            text?: string,
            image?: Image
    }
    declare interface Image {
        smallImageUrl: string,
            largeImageUrl: string
    }
    declare interface Reprompt {
        outputSpeech: OutputSpeech
    }
}