// @flow
/**
 * Flowtype definitions for node-schedule
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'node-schedule' {


    /**
     * The callback executed by a Job
     */
    declare     export interface JobCallback {
        (): void
    }

    /**
     * Scheduler jobs.
     * @class  
     */
    declare     export class Job mixins EventEmitter {

        /**
         * This Job's name. read-only.
         */
        name: string;

        /**
         * Use the function scheduleJob() to create new Job objects.
         * @constructor  * 
         * @internal  * 
         * @param  either an optional name for this Job or this Job's callback
         * @param  either this Job's callback or an optional callback function
         * @param  optional callback that is executed right before the JobCallback
         */
        constructor(name: string | JobCallback, job?: JobCallback | Function, callback?: Function): this;

        /**
         * Adds an Invocation to this job. For internal use.
         * @internal  * 
         * @param  
         * @return  whether the invocation could be added
         */
        trackInvocation(invokation: Invocation): boolean;

        /**
         * removes an Invocation from this Job's tracking list. For internal use.
         * @internal  * 
         * @param invocation * 
         * @return  boolean whether the invocation was successful. Removing an Invocation that doesn't exist, returns false.
         */
        stopTrackingInvocation(invocation: Invocation): boolean;

        /**
         * 
         * @internal  * 
         * @return  the number of currently running instances of this Job.
         */
        triggeredJobs(): number;

        /**
         * set the number of currently running Jobs.
         * @internal  * 
         * @param triggeredJobs 
         */
        setTriggeredJobs(triggeredJobs: number): void;

        /**
         * cancel all pending Invocations of this Job.
         * @param reschedule whether to reschedule the canceled Invocations.
         */
        cancel(reschedule?: boolean): boolean;

        /**
         * cancel the next Invocation of this Job.
         * @param reschedule whether to reschedule the canceled Invocation.
         * @return  whether cancelation was successful
         */
        cancelNext(reschedule?: boolean): boolean;

        /**
         * Changes the scheduling information for this Job.
         * @param spec the
         * @return  whether the reschedule was successful
         */
        reschedule(spec: RecurrenceRule | string | number): boolean;

        /**
         * Returns the Date on which this Job will be run next.
         * @return  
         */
        nextInvocation(): Date;

        /**
         * 
         * @return  Invocation[] a list of all pending Invocations
         */
        pendingInvocations(): Invocation[];

        /**
         * run this Job immediately.
         */
        invoke(): void;

        /**
         * schedule this Job to be run on the specified date.
         * @param date 
         */
        runOnDate(date: Date): void;

        /**
         * set scheduling information
         * @param  
         * @public  
         */
        schedule(date: Date | string | number): boolean
    }

    /**
     * Range.
     * @class  
     */
    declare     export class Range {

        /**
         * Constructor.
         * @constructor  * 
         * @param  The start.
         * @param  The end.
         * @param  The step.
         */
        constructor(start?: number, end?: number, step?: number): this;

        /**
         * Return a {boolean} if the class contains the specified value.
         * @param  The value.
         * @returns  {true} if the class contains the specified value, otherwise, {false}.
         */
        contains(value: number): boolean
    }
    declare type Recurrence = number | Range | string;
    declare type RecurrenceSegment = Recurrence | Recurrence[];

    /**
     * Recurrence rules.
     */
    declare     export class RecurrenceRule {

        /**
         * Day of the month.
         * @public  * 
         * @type  
         */
        date: RecurrenceSegment;

        /**
         * Day of the week.
         * @public  * 
         * @type  
         */
        dayOfWeek: RecurrenceSegment;

        /**
         * Hour.
         * @public  * 
         * @type  
         */
        hour: RecurrenceSegment;

        /**
         * Minute.
         * @public  * 
         * @type  
         */
        minute: RecurrenceSegment;

        /**
         * Month.
         * @public  * 
         * @type  
         */
        month: RecurrenceSegment;

        /**
         * Second.
         * @public  * 
         * @type  
         */
        second: RecurrenceSegment;

        /**
         * Year.
         * @public  * 
         * @type  
         */
        year: RecurrenceSegment;
        constructor(year?: RecurrenceSegment, month?: RecurrenceSegment, date?: RecurrenceSegment, dayOfWeek?: RecurrenceSegment, hour?: RecurrenceSegment, minute?: RecurrenceSegment, second?: RecurrenceSegment): this;
        nextInvocationDate(base: Date): Date
    }

    /**
     * Recurrence rule specification.
     */
    declare     export interface RecurrenceSpec {

        /**
         * Day of the month.
         * @public  * 
         * @type  
         */
        date?: RecurrenceSegment,

            /**
             * Day of the week.
             * @public  * 
             * @type  
             */
            dayOfWeek?: RecurrenceSegment,

            /**
             * Hour.
             * @public  * 
             * @type  
             */
            hour?: RecurrenceSegment,

            /**
             * Minute.
             * @public  * 
             * @type  
             */
            minute?: RecurrenceSegment,

            /**
             * Month.
             * @public  * 
             * @type  
             */
            month?: RecurrenceSegment,

            /**
             * Second.
             * @public  * 
             * @type  
             */
            second?: RecurrenceSegment,

            /**
             * Year.
             * @public  * 
             * @type  
             */
            year?: RecurrenceSegment
    }

    /**
     * Invocation.
     * @class  
     */
    declare     export class Invocation {

        /**
         * Fire date.
         * @public  * 
         * @type  
         */
        fireDate: Date;

        /**
         * Job.
         * @public  * 
         * @type  
         */
        job: Job;

        /**
         * Recurrence rule.
         * @public  * 
         * @type  
         */
        recurrenceRule: RecurrenceRule;

        /**
         * Timer identifier.
         * @public  * 
         * @type  
         */
        timerID: number;

        /**
         * Constructor.
         * @constructor  * 
         * @param  The job.
         * @param  The fire date.
         * @param  The recurrence rule.
         */
        constructor(job: Job, fireDate: Date, recurrenceRule: RecurrenceRule): this
    }

    /**
     * Create a schedule job.
     * @param  name for the new Job
     * @param  scheduling info
     * @param  callback to be executed on each invocation
     */
    declare     export function scheduleJob(
        name: string,
        rule: RecurrenceRule | RecurrenceSpec | Date | string,
        callback: JobCallback): Job

    /**
     * Changes the timing of a Job, canceling all pending invocations.
     * @param job * 
     * @param spec the new timing for this Job
     * @return  if the job could be rescheduled, {null} otherwise.
     */
    declare     export function rescheduleJob(job: Job | string, spec: RecurrenceRule | RecurrenceSpec | Date | string): Job
    declare     export var scheduledJobs: {
        [jobName: string]: Job
    };

    /**
     * Cancels the job.
     * @param  The job.
     * @returns  {true} if the job has been cancelled with success, otherwise, {false}.
     */
    declare     export function cancelJob(job: Job | string): boolean
}