// @flow
/**
 * Flowtype definitions for arcgis-js-api
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'esri' {
    declare     export type AGSMouseEvent = {
        graphic?: Graphic,
        mapPoint: Point,
        screenPoint: ScreenPoint
    } & MouseEvent

    declare     export interface AddOptions {

        /**
         * The features that were added to the feature layer. 
         */
        addedGraphics?: Graphic[],

            /**
             * The feature layer where the new feature(s) are added. 
             */
            featureLayer?: FeatureLayer
    }
    declare     export interface AggregatePointsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * A field name from pointLayer based on which the points will be grouped. 
             */
            groupByField?: string,

            /**
             * When true, the polygons that have no points within them will be returned in the output. 
             */
            keepBoundariesWithNoPoints?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The point feature layer that will be aggregated into the polygons in the polygon feature layer. 
             */
            pointLayer: FeatureLayer,

            /**
             * The polygon layer to be shown selected in in the Choose area menu. 
             */
            polygonLayer: FeatureLayer,

            /**
             * An array of feature layer candidates to be selected as the input polygon layer. 
             */
            polygonLayers: FeatureLayer[],

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of attribute field names and statistic types that you would like to aggregate for all points within each polygon. 
             */
            summaryFields?: string[]
    }
    declare     export interface ArcGISDynamicMapServiceLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string,

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * Represents the image parameter options. 
             */
            imageParameters?: ImageParameters,

            /**
             * infoTemplates object. 
             */
            infoTemplates?: any,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * By default, images are exported in MIME format, and the image is streamed to the client. 
             */
            useMapImage?: boolean,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface ArcGISImageServiceLayerOptions {

        /**
         * Id to assign to the layer. 
         */
        id?: string,

            /**
             * The image service parameter options used when exporting an Image Service layer. 
             */
            imageServiceParameters?: ImageServiceParameters,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a raster. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * By default, images are exported in MIME format, and the image is streamed to the client. 
             */
            useMapImage?: boolean,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface ArcGISImageServiceVectorLayerOptions {

        /**
         * Apply a function for visualization or post-processing purposes. 
         */
        pixelFilter?: any,

            /**
             * Set the default renderer from a list of predefined options. 
             */
            rendererStyle?: string,

            /**
             * A value used to aggregate pixels into tiles for visualization purposes. 
             */
            symbolTileSize?: number
    }
    declare     export interface ArcGISTiledMapServiceLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Lists which levels to draw. 
             */
            displayLevels?: number[],

            /**
             * An array of objects that define areas where a tiled map service should not display tiles. 
             */
            exclusionAreas?: any[],

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * infoTemplates object. 
             */
            infoTemplates?: any,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * The purpose of resampling is to enlarge the image and fill in at the levels where there are no tiles available. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * Array of REST endpoints that can be used to retrieve tile images. 
             */
            tileServers?: string[],

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface AttributeInspectorOptions {

        /**
         * See the object specifications table below for the structure of the layerInfos  object. 
         */
        layerInfos: any[]
    }
    declare     export interface AttributionOptions {

        /**
         * String used as the delimiter between attribution items. 
         */
        itemDelimiter?: string,

            /**
             * Reference to the map object. 
             */
            map: Map
    }
    declare     export interface BasemapGalleryOptions {

        /**
         * List of basemap layer ids in the current map. 
         */
        basemapIds?: string[],

            /**
             * An array of user-defined basemaps to display in the BasemapGallery. 
             */
            basemaps?: Basemap[],

            /**
             * Specify an ArcGIS.com group that contains web maps that will be used as basemaps in the gallery. 
             */
            basemapsGroup?: any,

            /**
             * Specify your Bing Maps key if the basemap group you want to display in the gallery contains bing basemaps. 
             */
            bingMapsKey?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Specify the portal url, including the instance name, used to access the group that contains the basemap gallery items. 
             */
            portalUrl?: string,

            /**
             * List of reference layer ids in the current map. 
             */
            referenceIds?: string[],

            /**
             * When true, queries ArcGIS.com to retrieve available basemaps. 
             */
            showArcGISBasemaps?: boolean
    }
    declare     export interface BasemapLayerOptions {

        /**
         * If the url points to an image service, you can specify which band ids will display. 
         */
        bandIds?: number[],

            /**
             * The attribution information for the layer. 
             */
            copyright?: string,

            /**
             * If the url points to a cached map service you can specify the levels to draw. 
             */
            displayLevels?: number[],

            /**
             * Specify the full extent of the layer. 
             */
            fullExtent?: Extent,

            /**
             * Specify the initial extent of the layer. 
             */
            initialExtent?: Extent,

            /**
             * Set to true if the layer is a reference layer and should be drawn on top of all other layers in the map. 
             */
            isReference?: boolean,

            /**
             * Initial opacity or transparency of the basemap layer. 
             */
            opacity?: number,

            /**
             * Specify subDomains where tiles are served to speed up tile retrieval (using subDomains gets around the browser limit of the max number of concurrent requests to a domain). 
             */
            subDomains?: string[],

            /**
             * The URL template used to retrieve the tiles. 
             */
            templateUrl?: string,

            /**
             * Define the tile info for the layer including lods, rows, cols, origin and spatial reference. 
             */
            tileInfo?: TileInfo,

            /**
             * Define additional tile server domains for the layer. 
             */
            tileServer?: string[],

            /**
             * The type of layer, valid values are "BingMapsAerial", "BingMapsHybrid", "BingMapsRoad", "OpenStreetMap", or "WebTiledLayer". 
             */
            type?: string,

            /**
             * URL to the ArcGIS Server REST resource that represents a map or image service. 
             */
            url?: string,

            /**
             * If the url points to a dynamic map service you can specify a subset of layers to display. 
             */
            visibleLayers?: number[]
    }
    declare     export interface BasemapOptions {

        /**
         * The id of the basemap. 
         */
        id?: string,

            /**
             * An array of layers to add to the basemap. 
             */
            layers: BasemapLayer[],

            /**
             * A URL to a thumbnail image for the basemap that will be displayed in the BasemapGallery. 
             */
            thumbnailUrl?: string,

            /**
             * Title for the basemap. 
             */
            title?: string
    }
    declare     export interface BasemapToggleOptions {

        /**
         * The secondary basemap to toggle to. 
         */
        basemap?: string,

            /**
             * Object containing the labels and URLs for the image of each basemap. 
             */
            basemaps?: any,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface BlendRendererOptions {

        /**
         * This determines how colors are blended together. 
         */
        blendMode?: string,

            /**
             * An array of objects to blend containing the field name and color to use. 
             */
            fields: any[],

            /**
             * The field to normalize. 
             */
            normalizationField?: string,

            /**
             * An array of objects which determines opacity. 
             */
            opacityStops: any[],

            /**
             * The symbol in which the BlendRenderer is applied. 
             */
            symbol: Symbol
    }
    declare     export interface BookmarksOptions {

        /**
         * An array of BookmarkItem objects or a json object with the BookmarkItem format to initially display in the bookmark widget. 
         */
        bookmarks?: BookmarkItem[],

            /**
             * When true, users can add, remove and edit bookmark items. 
             */
            editable?: boolean,

            /**
             * Reference to the map. 
             */
            map: Map
    }
    declare     export interface CSVLayerOptions {

        /**
         * The column delimiter. 
         */
        columnDelimiter?: string,

            /**
             * Copyright information for the layer. 
             */
            copyright?: string,

            /**
             * The fields property contains objects with "name", "alias" and "type" String properties. 
             */
            fields?: any[],

            /**
             * The latitude field name. 
             */
            latitudeFieldName?: string,

            /**
             * The longitude field name. 
             */
            longitudeFieldName?: string,

            /**
             * An array of strings which correspond to fields to include in the CSVLayer. 
             */
            outFields?: string[]
    }
    declare     export interface ChooseBestFacilitiesOptions {

        /**
         * The URL to the analysis service, for example "http://analysis.arcgis.com/arcgis/rest/services/tasks/GPServer". 
         */
        analysisGpServer?: string,

            /**
             * The number of facilities to choose when allocating demand locations. 
             */
            candidateCount?: number,

            /**
             * Specify how much demand every facility in the candidateFacilitiesLayer is capable of supplying. 
             */
            candidateFacilitiesCapacity?: string,

            /**
             * String value indicating the field name on the candidateFacilitiesLayer  representing how much demand each facility in the candidatesFacilitiesLayer is capable of supplying. 
             */
            candidateFacilitiesCapacityField?: string,

            /**
             * A point layer specifying one or more locations that act as facilities by providing some kind of service. 
             */
            candidateFacilitiesLayer?: FeatureLayer,

            /**
             * The amount of demand available at every demand locations. 
             */
            demand?: number,

            /**
             * String value indicating the field name on the demandLocationLayer  representing the amount of demand available at each demand location. 
             */
            demandField?: string,

            /**
             * A point layer specifying the locations that have demand for facilities. 
             */
            demandLocationLayer?: FeatureLayer,

            /**
             * Array of point layers to be used for choosing the demandLocationLayer. 
             */
            demandLocationLayers: FeatureLayer[],

            /**
             * When true, Travel Modes (Driving Time) is enabled for the inputLayer with the point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * Array of point layers used for setting the required facilities layer and candidate facilities layer. 
             */
            featureLayers: FeatureLayer[],

            /**
             * Sets the selected folder of the select folder dropdown. 
             */
            folderId?: string,

            /**
             * Sets the selected folder of the select folder dropdown. 
             */
            folderName?: string,

            /**
             * Reference to the map. 
             */
            map?: Map,

            /**
             * The maximum travel time or distance allowed between a demand location and its allocated facility. 
             */
            maxTravelRange?: number,

            /**
             * String value indicating the field name on the demandLocationLayer specifying the maximum travel time or distance allowed between a demand location and its allocated facility. 
             */
            maxTravelRangeField?: string,

            /**
             * The name of the output layer to be displayed in the result layer  nameinputbox. 
             */
            outputLayerName?: string,

            /**
             * The percentage of the total demand that you want the chosen and required facilities to capture. 
             */
            percentDemandCoverage?: number,

            /**
             * The URL to the ArcGIS organization or Portal site where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Specify how much demand every facility in the requiredFacilitiesLayer is capable of supplying. 
             */
            requiredFacilitiesCapacity?: number,

            /**
             * A field on the requiredFacilitiesLayer representing how much demand each facility in this layer is capable of supplying. 
             */
            requiredFacilitiesCapacityField?: string,

            /**
             * A point layer specifying one or more locations that act as facilities by providing some kind of service. 
             */
            requiredFacilitiesLayer?: FeatureLayer,

            /**
             * Indicates whether to return the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * Indicates whether the "choose extent checkbox" is displayed. 
             */
            showChooseExtent?: boolean,

            /**
             * Indicates whether to show the credit options. 
             */
            showCredits?: boolean,

            /**
             * Indicates whether the help links are displayed. 
             */
            showHelp?: boolean,

            /**
             * Indicates whether to add an option to the UI that allows users to choose ready-to-use analysis layers from the Living Atlas Analysis Layers. 
             */
            showReadyToUseLayers?: boolean,

            /**
             * Indicates whether to display a dropdown menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean,

            /**
             * Indicates whether the select folder dropdown will be displayed. 
             */
            showSelectFolder?: boolean,

            /**
             * The default widget title with a custom title. 
             */
            title?: string
    }
    declare     export interface CircleOptions1 {

        /**
         * Applicable when the spatial reference of the center point is either set to Web Mercator or geographic/geodesic as true would apply. 
         */
        geodesic?: boolean,

            /**
             * A circle can be thought of similar to a polygon. 
             */
            numberOfPoints?: number,

            /**
             * Radius of the circle. 
             */
            radius?: number,

            /**
             * Unit of the radius. 
             */
            radiusUnit?: string
    }
    declare     export interface CircleOptions2 {

        /**
         * The center point of the circle. 
         */
        center: Point | number[],

            /**
             * Applicable when the spatial reference of the center point is either set to Web Mercator or geographic/geodesic as true would apply. 
             */
            geodesic?: boolean,

            /**
             * A circle can be thought of similar to a polygon. 
             */
            numberOfPoints?: number,

            /**
             * The radius of the circle. 
             */
            radius?: number,

            /**
             * Unit of the radius. 
             */
            radiusUnit?: string
    }
    declare     export interface ClassedColorSliderOptions {

        /**
         * Data map containing renderer information. 
         */
        breakInfos: any,

            /**
             * Indicates the classification method used to divide the range of values into bins. 
             */
            classificationMethod?: string,

            /**
             * Required: Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of the histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * Indicates how data values are normalized. 
             */
            normalizationType?: string,

            /**
             * Handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of the widget ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays ticks on slider when true. 
             */
            showTicks?: boolean,

            /**
             * Represents the statistics data object. 
             */
            statistics?: any
    }
    declare     export interface ClassedSizeSliderOptions {

        /**
         * The data map containing renderer information. 
         */
        breakInfos: any,

            /**
             * Optional: Indicates the classification method used to divide the range of values into bins. 
             */
            classificationMethod?: string,

            /**
             * Required: Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * Indicates how data values are normalized. 
             */
            normalizationType?: string,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of slider ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Indicates whether to display the histogram. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Optional: Represents the statistics data object. 
             */
            statistics?: any
    }
    declare     export interface ColorInfoSliderOptions {

        /**
         * The data map containing renderer information. 
         */
        colorInfo: any,

            /**
             * Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Optional: Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of widget ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays handles when set to true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when set to true. 
             */
            showLabels?: boolean,

            /**
             * Indicates whether to display percentage labels. 
             */
            showRatioLabels?: boolean | string,

            /**
             * Displays tick marks when set to true. 
             */
            showTicks?: boolean,

            /**
             * Displays transparent background when set to true. 
             */
            showTransparentBackground?: boolean,

            /**
             * Represents a statistics data object. 
             */
            statistics?: any,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface ColorPickerOptions {

        /**
         * The selected color. 
         */
        color: Color,

            /**
             * The row size of the palette. 
             */
            colorsPerRow: number,

            /**
             * The set of available color options. 
             */
            palette: Color[],

            /**
             * Array of recent colors to show in the recent colors row. 
             */
            recentColors: Color[],

            /**
             * Toggles color selection being required. 
             */
            required: boolean,

            /**
             * Toggles the recent color row. 
             */
            showRecentColors: boolean,

            /**
             * Toggles the transparency slider. 
             */
            showTransparencySlider: boolean
    }
    declare     export interface ConnectOriginsToDestinationsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The linear unit used with the distance value(s). 
             */
            distanceDefaultUnits?: string,

            /**
             * An array of feature layers containing destination points. 
             */
            featureLayers: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The point feature layers containing the origin points. 
             */
            originsLayers: FeatureLayer[],

            /**
             * The name of the output layer to be shown in the Result layer name input box. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean
    }
    declare     export interface CoordinatesLocationProviderOptions {

        /**
         * The attribute field in the graphic object that contains the longitude (X) values. 
         */
        xField: string,

            /**
             * The attribute field in the graphic object that has the latitude (Y) values. 
             */
            yField: string
    }
    declare     export interface CreateBuffersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of buffer distances to buffer the input feature layer. 
             */
            bufferDistance?: number[],

            /**
             * The input point, line, or polygon feature layer to be buffered. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: string,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface CreateDriveTimeAreasOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The units of the breakValues parameter. 
             */
            breakUnits?: string,

            /**
             * An array of driving time break values. 
             */
            breakValues?: number[],

            /**
             * The point feature layer around which drive-time areas will be drawn. 
             */
            inputLayer: FeatureLayer,

            /**
             * The geometry type of the input layer. 
             */
            inputType?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The rule of overlap. 
             */
            overlapPolicy?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface CreateViewshedOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * Feature layer containing observation points to be used as input. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string
    }
    declare     export interface CreateWatershedsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layers containing input points used for calculating watersheds. 
             */
            inputLayers: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean
    }
    declare     export interface CutOptions {

        /**
         * The feature(s) added to the feature layer by the cut operation. 
         */
        addedGraphics?: Graphic[],

            /**
             * The feature layer that contains the cut feature(s). 
             */
            featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) before the cut operation is performed. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface DataAdapterFeatureLayerOptions {

        /**
         * The query parameters to use in retrieving the data through the DataAdapter. 
         */
        dataAdapterQuery: any,

            /**
             * An instance of the LocationProvider class. 
             */
            locationProvider: LocationProviderBase
    }
    declare     export interface DataBrowserOptions {

        /**
         * Whether or not to display the hierarchy dropdown for countries with multiple hierarchies (e.g. 
         */
        allowHierarchies?: boolean,

            /**
             * Show/hide country drop down. 
             */
            countryBox?: boolean,

            /**
             * Two-digit country code selected in the country drop down. 
             */
            countryID?: string,

            /**
             * The hierarchy to load for a country (e.g. 
             */
            hierarchyID?: string,

            /**
             * Text string to display on the back button on the second and third pages of the Data Browser. 
             */
            pageBackButton?: string,

            /**
             * Selected variables array. 
             */
            selection?: string[],

            /**
             * Whether to display the "Shopping Cart" of selected variables. 
             */
            shoppingCart?: boolean,

            /**
             * Title to show in the top left hand corner. 
             */
            title?: string
    }
    declare     export interface DeleteOptions {

        /**
         * The features that were removed from the feature layer. 
         */
        deletedGraphics?: Graphic[],

            /**
             * The feature layer from which the feature(s) are removed. 
             */
            featureLayer?: FeatureLayer
    }
    declare     export interface DirectionsOptions {

        /**
         * Defines the values that label each stop. 
         */
        alphabet?: string | string[] | boolean,

            /**
             * When true, solve will start when the last destination is complete and enter key is hit. 
             */
            autoSolve?: boolean,

            /**
             * Display the 'Add Destination' button. 
             */
            canModifyStops?: boolean,

            /**
             * Center the map at the start of the selected route segment. 
             */
            centerAtSegmentStart?: boolean,

            /**
             * The returned directions object from the routing solve result. 
             */
            directions?: any,

            /**
             * Length units. 
             */
            directionsLengthUnits?: string,

            /**
             * Enable the dragging of stop locations on the map. 
             */
            dragging?: boolean,

            /**
             * Focus the cursor in the stop input when a new stop is added. 
             */
            focusOnNewStop?: boolean,

            /**
             * The symbol that is used to denote the start location on the map. 
             */
            fromSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when the from location is dragged to a new location. 
             */
            fromSymbolDrag?: PictureMarkerSymbol,

            /**
             * If available, this geometry service is used to provide latitude/longitude values for stops whose reverse geocoding did not return an address (Added at v3.11). 
             */
            geometryTaskUrl?: string,

            /**
             * Reference to the map object. 
             */
            map: Map,

            /**
             * Activates the map-click-active toggle button when true. 
             */
            mapClickActive?: boolean,

            /**
             * Maximum number of stops. 
             */
            maxStops?: number,

            /**
             * Minimum number of stops. 
             */
            minStops?: number,

            /**
             * When true, stops on the route are re-ordered to provide an optimal route. 
             */
            optimalRoute?: boolean,

            /**
             * If specified, this specifies the portal where the produced route layers are going to be stored and accessed. 
             */
            portalUrl?: string,

            /**
             * URL link to a custom print page. 
             */
            printPage?: string,

            /**
             * If available, this print task is used to display an overview map of the route on the directions print page (Added at v3.11). 
             */
            printTaskUrl?: string,

            /**
             * HTML string for providing a custom printing page 
             */
            printTemplate?: string,

            /**
             * When true, the route will return to start point. 
             */
            returnToStart?: boolean,

            /**
             * Specify the input parameters for the route task. 
             */
            routeParams?: RouteParameters,

            /**
             * Define the symbol used to draw the route on the map. 
             */
            routeSymbol?: SimpleLineSymbol,

            /**
             * Specify the service that will be used to calculate directions. 
             */
            routeTaskUrl?: string,

            /**
             * Used to define optional search options. 
             */
            searchOptions?: any,

            /**
             * Define the info template for the popup that appears when the popup for a route segment is displayed. 
             */
            segmentInfoTemplate?: InfoTemplate,

            /**
             * Specify the symbol used to render the individual route segments that display on the map when a direction step is clicked. 
             */
            segmentSymbol?: SimpleLineSymbol,

            /**
             * Defines whether the Directions widget will show the map-click-active toggle button. 
             */
            showActivateButton?: boolean,

            /**
             * If true, the Clear button is shown. 
             */
            showClearButton?: boolean,

            /**
             * If true, the toggle button group allowing user to choose between Miles and Kilometers is shown. 
             */
            showMilesKilometersOption?: boolean,

            /**
             * When true, the Optimize order option is shown. 
             */
            showOptimalRouteOption?: boolean,

            /**
             * When true the 'Print' button is displayed that allows users to display driving directions in a print page. 
             */
            showPrintPage?: boolean,

            /**
             * When true, the Return to start option is shown. 
             */
            showReturnToStartOption?: boolean,

            /**
             * Display the 'Show Reverse Stops' button. 
             */
            showReverseStopsButton?: boolean,

            /**
             * Applicable if the widget works with a Network Analyst Server federated with ArcGIS Online or Portal. 
             */
            showSaveButton?: boolean,

            /**
             * Highlight the route segment when a directions step is clicked. 
             */
            showSegmentHighlight?: boolean,

            /**
             * Display a popup with segment details when a direction step is clicked. 
             */
            showSegmentPopup?: boolean,

            /**
             * When true, the Use traffic option is shown. 
             */
            showTrafficOption?: boolean,

            /**
             * If true, and six Standard Travel Modes are supported by the service and accessible using current credentials, then two toggle button groups are shown: one to allow user to choose between Driving a Car, a Truck, and Walking, and one more group to choose between Fastest and Shortest routes. 
             */
            showTravelModesOption?: boolean,

            /**
             * True if currently calculating the route from the routing service. 
             */
            solving?: boolean,

            /**
             * List of graphics used to display the point marker. 
             */
            stopGraphics?: Graphic[],

            /**
             * An array of points that define the stop locations. 
             */
            stops?: Point[] | number[][] | string[] | any[],

            /**
             * Define the info template for the popup that appears when a stop is clicked. 
             */
            stopsInfoTemplate?: InfoTemplate,

            /**
             * The symbol that displays on the map for the locations between the origin and final destination locations. 
             */
            stopSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when an intermediate location is dragged to a new location. 
             */
            stopSymbolDrag?: PictureMarkerSymbol,

            /**
             * List of graphics used to display the text over the point marker. 
             */
            textGraphics?: Graphic[],

            /**
             * The text color for the text that appears for each destination. 
             */
            textSymbolColor?: Color,

            /**
             * The font used for the text that displays on the map for each stop location. 
             */
            textSymbolFont?: Font,

            /**
             * Define an x and/or y offset for the text symbols that are used for the stop locations on the map. 
             */
            textSymbolOffset?: any,

            /**
             * Specify a theme for the widget. 
             */
            theme?: string,

            /**
             * The symbol that is used to denote the final destination location on the map. 
             */
            toSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when an final destination location is dragged to a new location. 
             */
            toSymbolDrag?: PictureMarkerSymbol,

            /**
             * When true, real-time traffic is used to plan the route. 
             */
            traffic?: boolean,

            /**
             * The traffic layer used for real-time traffic. 
             */
            trafficLayer?: ArcGISDynamicMapServiceLayer
    }
    declare     export interface DissolveBoundariesOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of field names based on which polygons are merged. 
             */
            dissolveFields?: string[],

            /**
             * The layer containing polygon features that will be dissolved. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of field names and statistical summary types that you wish to calculate from the polygons that are dissolved together. 
             */
            summaryFields?: string[]
    }
    declare     export interface DotDensityRendererOptions {

        /**
         * The color to be used for the background of the symbol. 
         */
        backgroundColor?: Color,

            /**
             * The shape to be used for the dot. 
             */
            dotShape?: string,

            /**
             * The size of the dot in pixels. 
             */
            dotSize?: number,

            /**
             * The value that a dot represents. 
             */
            dotValue: number,

            /**
             * An array of objects, where each object defines a field to be mapped and its color. 
             */
            fields: any[],

            /**
             * The line symbol to use on the outline of the feature. 
             */
            outline?: LineSymbol
    }
    declare     export interface DrawOptions {

        /**
         * Determines how much time to wait before adding a new point when using a freehand tool. 
         */
        drawTime?: number,

            /**
             * If true, tooltips are displayed when creating new graphics with the draw toolbar. 
             */
            showTooltips?: boolean,

            /**
             * Determines how far the mouse moves before adding a new point when using one of the freehand tools. 
             */
            tolerance?: number,

            /**
             * Determines how far to offset the tool tip from the mouse pointer. 
             */
            tooltipOffset?: number
    }
    declare     export interface DriveBufferOptions {

        /**
         * The radii to use to create ring buffers 
         */
        radius: number[],

            /**
             * The units of the radii. 
             */
            units: string
    }
    declare     export interface EditOptions {

        /**
         * Specifies whether users can add new vertices. 
         */
        allowAddVertices?: boolean,

            /**
             * Specifies whether users can delete vertices. 
             */
            allowDeleteVertices?: boolean,

            /**
             * Line symbol used to draw the guild lines, displayed when moving vertices. 
             */
            ghostLineSymbol?: LineSymbol,

            /**
             * Marker symbol used to display the insertable vertices. 
             */
            ghostVertexSymbol?: MarkerSymbol,

            /**
             * If users want to place the text symbol editor to a user defined HTML element. 
             */
            textSymbolEditorHolder?: Node | string,

            /**
             * When true, if the geometry is re-sized the aspect ration will be preserved. 
             */
            uniformScaling?: boolean,

            /**
             * Marker symbol used to draw the vertices. 
             */
            vertexSymbol?: MarkerSymbol
    }
    declare     export interface EditorOptions {

        /**
         * Create a new settings object that defines the capabilities of the widget. 
         */
        settings?: any
    }
    declare     export interface ElevationProfileOptions {

        /**
         * This object contains properties used to render the chart. 
         */
        chartOptions?: any,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * The URL to the elevation profile service. 
             */
            profileTaskUrl: string,

            /**
             * The measurement unit of the scalebar units. 
             */
            scalebarUnits?: string
    }
    declare     export interface EnrichLayerOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An buffer distance or driving time value to buffer the input feature layer. 
             */
            distance?: number,

            /**
             * When true, Travel Modes (Driving Time) is enabled for inputLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * The input feature layer to enrich with new data. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * When true, you can specify a time for traffic condition under Define areas to enrich - Driving Time. 
             */
            showTrafficWidget?: boolean
    }
    declare     export interface ExtractDataOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * If true, the Clip features option in Study area will be ckecked. 
             */
            clip?: boolean,

            /**
             * The format of output data shown as the default selection in the Output data format menu. 
             */
            dataFormat?: string,

            /**
             * An array for feature layers to be extracted. 
             */
            featureLayers: FeatureLayer[],

            /**
             * An array for feature layers to be extracted. 
             */
            inputLayers?: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FeatureLayerOptions {

        /**
         * Enable or disable the auto generalization of features from a non-editable layer in on-demand mode. 
         */
        autoGeneralize?: boolean,

            /**
             * Class attribute to set for the layer's node. 
             */
            className?: string,

            /**
             * Where clause to use as definition expression for layer. 
             */
            definitionExpression?: string,

            /**
             * When true, graphics are displayed during panning. 
             */
            displayOnPan?: boolean,

            /**
             * Set a callback function that will be invoked by  FeatureLayer.getEditSummary. 
             */
            editSummaryCallback?: Function,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string,

            /**
             * Unique ID to assign to the layer. 
             */
            id?: string,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * The maximum allowable offset, only applicable for layers that are not editable. 
             */
            maxAllowableOffset?: number,

            /**
             * The query mode for the feature layer. 
             */
            mode?: number,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * One or more fields used to order features by - for queries as well as for rendering. 
             */
            orderByFields?: string[],

            /**
             * An array of strings which correspond to fields to include in the FeatureLayer. 
             */
            outFields?: string[],

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * Indicates whether to show labels on the layer. 
             */
            showLabels?: boolean,

            /**
             * The dynamic layer or table source. 
             */
            source?: LayerSource,

            /**
             * Specify the size of the virtual tiles, used in on-demand mode. 
             */
            tileHeight?: number,

            /**
             * Specify the size of the virtual tiles, used in on-demand mode. 
             */
            tileWidth?: number,

            /**
             * The name of the trackIdField. 
             */
            trackIdField?: string,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface FeatureLayerStatisticsOptions {

        /**
         * The feature layer that will be the source for calculating statistics. 
         */
        layer: FeatureLayer
    }
    declare     export interface FeatureTableOptions {

        /**
         * The number of features a service will try to fetch. 
         */
        batchCount?: number,

            /**
             * Object defining the date options specifically for formatting date and time editors. 
             */
            dateOptions?: any,

            /**
             * Sets the editing state for the FeatureTable. 
             */
            editable?: boolean,

            /**
             * The featureLayer that the table is associated with. 
             */
            featureLayer: FeatureLayer,

            /**
             * An array of objects representing field information. 
             */
            fieldInfos?: any[],

            /**
             * Reference to the 'Options' drop-down menu. 
             */
            gridMenu?: any,

            /**
             * Object that can be used to set properties used by the underlying dgrid. 
             */
            gridOptions?: any,

            /**
             * Columns to hide by default using the dGrid ColumnHider extension. 
             */
            hiddenFields?: string[],

            /**
             * A reference to the Map. 
             */
            map?: Map,

            /**
             * Adds additional functional menu items for the 'Options' drop-down menu. 
             */
            menuFunctions?: any[],

            /**
             * Attribute fields to include in the FeatureTable. 
             */
            outFields?: string[],

            /**
             * Displays or hides the attachment column. 
             */
            showAttachments?: boolean,

            /**
             * Displays or hides tooltips for column headers. 
             */
            showColumnHeaderTooltips?: boolean,

            /**
             * Shows or hides cyclical relationship. 
             */
            showCyclicalRelationships?: boolean,

            /**
             * Displays the data type of the field right under the field label. 
             */
            showDataTypes?: boolean,

            /**
             * Displays or hides total number of features and selected number of features in the grid header. 
             */
            showFeatureCount?: boolean,

            /**
             * Displays or hides the FeatureTable header. 
             */
            showGridHeader?: boolean,

            /**
             * Displays or hides 'Options' drop-down menu of the FeatureTable. 
             */
            showGridMenu?: boolean,

            /**
             * Displays or hides the option to show related records in a table if the layer has pre-established relationship. 
             */
            showRelatedRecords?: boolean,

            /**
             * Displays or hides the 'Statistics' option in column menus for numeric fields. 
             */
            showStatistics?: boolean,

            /**
             * Enables an interaction between the map and the feature table. 
             */
            syncSelection?: boolean,

            /**
             * Enables pan/zoom to selected features on the map when the table in 'sync selection' mode. 
             */
            zoomToSelection?: boolean
    }
    declare     export interface FindHotSpotsOptions {

        /**
         * An array of feature layer candidates to be selected as the aggregation polygon layer. 
         */
        aggregationPolygonLayers: FeatureLayer[],

            /**
             * The numeric field in the AnalysisLayer that will be analyzed. 
             */
            analysisField?: string,

            /**
             * The URL to the GPServer used to execute an analysis job. 
             */
            analysisGpServer?: string,

            /**
             * The feature layer for which hot spots will be calculated. 
             */
            analysisLayer: FeatureLayer,

            /**
             * An array of feature layer candidates to be selected as the bounding polygon layer. 
             */
            boundingPolygonLayers: FeatureLayer[],

            /**
             * When true, make process info to get analysis report. 
             */
            isProcessInfo?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FindNearestOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer from which the nearest features are found. 
             */
            analysisLayer: FeatureLayer,

            /**
             * When true, Travel Modes ( Driving Distance, Driving Time) are enabled for analysisLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The maximum number of nearest locations to find for each feature in analysisLayer. 
             */
            maxCount?: number,

            /**
             * The feature layer to be shown selected in the "1. 
             */
            nearLayer: FeatureLayer,

            /**
             * An array of near layer candidates. 
             */
            nearLayers: FeatureLayer[],

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * The maximum range to search for nearest locations from each feature in the analysisLayer. 
             */
            searchCutoff?: number,

            /**
             * The units of the searchCutoff parameter. 
             */
            searchCutoffUnits?: string,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FindTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface GalleryOptions {

        /**
         * An array of items, see example below. 
         */
        items: any[],

            /**
             * Display the title for each item in the gallery. 
             */
            showTitle?: boolean,

            /**
             * Specify the size of the gallery's thumbnail image. 
             */
            thumbnailStyle?: string
    }
    declare     export interface GaugeOptions {

        /**
         * Text to display at the bottom of the gauge. 
         */
        caption?: string,

            /**
             * Color used for the arc indicator on the gauge. 
             */
            color?: string,

            /**
             * Name of the attribute field used to drive the gauge. 
             */
            dataField?: string,

            /**
             * Either "value" or "percentage". 
             */
            dataFormat?: string,

            /**
             * Name of the attribute field used to display a feature name on the gauge. 
             */
            dataLabelField?: string,

            /**
             * When true, the gauge is created with JSON from an ArcGIS Online webmap. 
             */
            fromWebmap?: boolean,

            /**
             * A esri.layers.GraphicsLayer or esri.layers.FeatureLayer used to drive the gauge. 
             */
            layer?: GraphicsLayer,

            /**
             * Maximum value that will be displayed on the gauge. 
             */
            maxDataValue?: number,

            /**
             * The text to display when a feature does not not a value for the dataLabelField. 
             */
            noDataLabel?: string,

            /**
             * Object passed to dojo.number.format to specify how data values are formatted. 
             */
            numberFormat?: any,

            /**
             * Text displayed above the gauge. 
             */
            title?: string,

            /**
             * What to dsiplay after the value of the currently selected feature. 
             */
            unitLabel?: string
    }
    declare     export interface GenerateRendererTaskOptions {

        /**
         * Prior to ArcGIS Server 10.2, map server/feature service only sample 1000 features to generate the renderer when using GenerateRenderer operation, which mean if there are more than 1000 features, it may run into the case that some feature will not be categorized into any breaks/unique values. 
         */
        checkValueRange?: boolean,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string
    }
    declare     export interface GeoRSSLayerOptions {

        /**
         * The template used to display popup window for identify operation. 
         */
        infoTemplate?: InfoTemplate,

            /**
             * The output spatial reference for the GeoRSSLayer. 
             */
            outSpatialReference?: SpatialReference,

            /**
             * The default symbol use to display point features. 
             */
            pointSymbol?: Symbol,

            /**
             * The default symbol used to display polygon features. 
             */
            polygonSymbol?: Symbol,

            /**
             * The default symbol used to display polyline features. 
             */
            polylineSymbol?: Symbol
    }
    declare     export interface GeocoderOptions {

        /**
         * By default, the Geocoder widget uses the Esri World Locator to find search locations. 
         */
        arcgisGeocoder?: boolean | any,

            /**
             * When false, the geocoder will not display the auto-complete results menu. 
             */
            autoComplete?: boolean,

            /**
             * When false, the geolocator will not navigate to the result after selection or search. 
             */
            autoNavigate?: boolean,

            /**
             * When false, the geocoder menu will not be displayed when more than one geocoder is set. 
             */
            geocoderMenu?: boolean,

            /**
             * Defines the geocoders that will be used by the Geocoder widget. 
             */
            geocoders?: any[],

            /**
             * Specify a graphicsLayer to use when  highlightSymbol is true. 
             */
            graphicsLayer?: GraphicsLayer,

            /**
             * Indicates whether to show a graphic at a selected location. 
             */
            highlightLocation?: boolean,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Maximum number of results to return. 
             */
            maxLocations?: number,

            /**
             * Minimum number of characters entered into the search field before querying for results. 
             */
            minCharacters?: number,

            /**
             * Number of milliseconds before querying for results will begin. 
             */
            searchDelay?: number,

            /**
             * When false, the geocoder will not show search suggestions while typing. 
             */
            showResults?: boolean,

            /**
             * Symbol to use when highlightLocation is true. 
             */
            symbol?: Symbol,

            /**
             * Specify a theme for the geocoder. 
             */
            theme?: string,

            /**
             * Start the geocoder with a default value. 
             */
            value?: string,

            /**
             * Scale to zoom to when geocoder does not return an extent. 
             */
            zoomScale?: number
    }
    declare     export interface GeometryLocationProviderOptions {

        /**
         * The attribute field in the graphic object that contains the JSON string representing the geometry. 
         */
        geometryField: string,

            /**
             * The geometry type of the returned features. 
             */
            geometryType: string
    }
    declare     export interface GraphicsLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * List of attribute fields to be added as custom data attributes to graphics node. 
             */
            dataAttributes?: string | string[],

            /**
             * When true, graphics are displayed during panning. 
             */
            displayOnPan?: boolean,

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * The info template for the layer. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Indicates whether the layer is responsible for styling graphics. 
             */
            styling?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface Handle {

        /**
         * Remove the listener 
         */
        remove(): void
    }
    declare     export interface HeatmapRendererOptions {

        /**
         * The radius (in pixels) of the circle over which the majority of each points value is spread out over. 
         */
        blurRadius?: number,

            /**
             * An array of CSS color strings (#RGB, #RRGGBB, rgb(r,g,b), rgba(r,g,b,a)). 
             */
            colors: string[],

            /**
             * The name of the attribute field used to weight the heatmap points. 
             */
            field?: string,

            /**
             * The pixel intensity value which is assigned the final color in the color ramp. 
             */
            maxPixelIntensity?: number,

            /**
             * The pixel intensity value which is assigned the initial color in the color ramp. 
             */
            minPixelIntensity?: number
    }
    declare     export interface HeatmapSliderOptions {

        /**
         * An array of colorStop objects describing the renderer's color ramp with more specificity than just colors. 
         */
        colorStops: any[],

            /**
             * Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * Absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * Width of slider ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean
    }
    declare     export interface HistogramTimeSliderOptions {

        /**
         * Change color of histogram bars, default is "rgb(5, 112, 176)".color: "#555555" 
         */
        color?: string,

            /**
             * Formats dates displayed by histogram slider.dateFormat: "DateFormat(selector: 'date', fullYear: true)" 
             */
            dateFormat?: string,

            /**
             * Array of feature layers to be used by slider. 
             */
            layers?: Layer[],

            /**
             * With a stream layer, when the number of points on the map exceeds the maximum number allowed, this histogram will start removing bins at the beginning of the array if in the "show_partial" mode. 
             */
            mode?: string,

            /**
             * Sets resolution for histogram slider (seconds/minutes/hours/etc) using Esri date formats. 
             */
            timeInterval?: string
    }
    declare     export interface HomeButtonOptions {

        /**
         * The extent used to zoom to when clicked. 
         */
        extent?: Extent,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface HorizontalSliderOptions {

        /**
         * Array of text labels to render - evenly spaced from left-to-right. 
         */
        labels: string[]
    }
    declare     export interface IdentifyTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface ImageServiceMeasureOptions {

        /**
         * The angular unit in which directions of line segments will be calculated. 
         */
        angularUnit?: string,

            /**
             * The area unit in which areas of polygons will be calculated. 
             */
            areaUnit?: string,

            /**
             * Defines whether to show the widget result in a popup or in the widget's result area when the widget has 'toolbar' layout. 
             */
            displayMeasureResultInPopup?: boolean,

            /**
             * Symbol to be used when drawing a polygon or extent. 
             */
            fillSymbol?: SimpleFillSymbol,

            /**
             * Image service layer with which the toolbar is associated. 
             */
            layer: ArcGISImageServiceLayer,

            /**
             * Defines the layout of the widget. 
             */
            layout?: string,

            /**
             * The linear unit in which height, length, or perimeters will be calculated. 
             */
            linearUnit?: string,

            /**
             * Symbol to be used when drawing a line. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Map instance with which the toolbar is associate. 
             */
            map: Map,

            /**
             * Symbol to be used when drawing a point. 
             */
            markerSymbol?: SimpleMarkerSymbol
    }
    declare     export interface ImageServiceMeasureToolOptions {

        /**
         * The angular unit in which directions of line segments will be calculated. 
         */
        angularUnit?: string,

            /**
             * The area unit in which areas of polygons will be calculated. 
             */
            areaUnit?: string,

            /**
             * Symbol to be used when drawing a polygon or extent. 
             */
            fillSymbol?: SimpleFillSymbol,

            /**
             * Image service layer the toolbar is associated with. 
             */
            layer: ArcGISImageServiceLayer,

            /**
             * The linear unit in which height, length, or perimeters will be calculated. 
             */
            linearUnit?: string,

            /**
             * Symbol to be used when drawing a line. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Map instance the toolbar is associated with. 
             */
            map: Map,

            /**
             * Symbol to be used when drawing a point. 
             */
            markerSymbol?: SimpleMarkerSymbol
    }
    declare     export interface ImageSpatialReferenceOptions {

        /**
         * The full Image Coordinate System object, which includes transformations and map spatial reference information specific to each image. 
         */
        ics?: any,

            /**
             * The OBJECTID of the image in a mosaic dataset. 
             */
            icsid?: number,

            /**
             * The url of the image service. 
             */
            url: string
    }
    declare     export interface KMLLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * The output spatial reference for the KMLLayer. 
             */
            outSR?: SpatialReference,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number
    }
    declare     export interface LabelLayerOptions {

        /**
         * ID assigned to the layer. 
         */
        id?: string,

            /**
             * Display mode for the label layer. 
             */
            mode?: string
    }
    declare     export interface LayerListOptions {

        /**
         * An array of operational layers. 
         */
        layers: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Indicates whether to remove underscores from the layer title. 
             */
            removeUnderscores?: boolean,

            /**
             * Indicates whether to display a legend for the layer items. 
             */
            showLegend?: boolean,

            /**
             * Indicates whether to display the opacity slider. 
             */
            showOpacitySlider?: boolean,

            /**
             * Indicates whether to show sublayers in the list of layers. 
             */
            showSubLayers?: boolean,

            /**
             * The CSS class selector used to uniquely style the widget. 
             */
            theme?: string,

            /**
             * Indicates whether to show the LayerList widget. 
             */
            visible?: boolean
    }
    declare     export interface LayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean
    }
    declare     export interface LayerSwipeOptions {

        /**
         * The number of pixels to clip the swipe tool. 
         */
        clip?: number,

            /**
             * If the widget is enabled and layers can be swiped. 
             */
            enabled?: boolean,

            /**
             * The layers to be swiped. 
             */
            layers: Layer[],

            /**
             * The number of pixels to place the tool from the left of the map. 
             */
            left?: number,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * The number of pixels to place the tool from the top of the map. 
             */
            top?: number,

            /**
             * Type of swipe tool to use. 
             */
            type?: string
    }
    declare     export interface LegendOptions {

        /**
         * Specify the alignment of the legend within the HTML element where the legend is rendered. 
         */
        arrangement?: number,

            /**
             * When false, the legend will not automatically update if the map changes scale or when layers are added are removed from the map. 
             */
            autoUpdate?: boolean,

            /**
             * Specify a subset of the layers in the map to display in the legend. 
             */
            layerInfos?: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * When true the legend will update with every scale change and displays only the layers and sub layers that are visible in the current map scale. 
             */
            respectCurrentMapScale?: boolean
    }
    declare     export interface LocateButtonOptions {

        /**
         * Centers the map to the location when a new position is returned. 
         */
        centerAt?: boolean,

            /**
             * The HTML5 Geolocation Position options for locating. 
             */
            geolocationOptions?: any,

            /**
             * If highlightLocation is on and this property is set then a graphic will be added to this layer instead of map.graphics. 
             */
            graphicsLayer?: GraphicsLayer,

            /**
             * If true, the users location will be highlighted with a point. 
             */
            highlightLocation?: boolean,

            /**
             * The infoTemplate used for the highlight graphic. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * The scale to zoom to when a users location has been found. 
             */
            scale?: number,

            /**
             * Sets the maps scale when a new position is returned. 
             */
            setScale?: boolean,

            /**
             * The symbol used on the highlight graphic to highlight the users location on the map. 
             */
            symbol?: Symbol,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * When enabled, the button becomes a toggle that creates an event to watch for location changes. 
             */
            useTracking?: boolean,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface LocatorLocationProviderOptions {

        /**
         * Object that matches the Locator address fields to corresponding attribute names in the Graphic object. 
         */
        addressFields: any,

            /**
             * An instance of a Locator object. 
             */
            locator: Locator
    }
    declare     export interface MapImageOptions {

        /**
         * Specfiy an extent for the image. 
         */
        extent?: Extent,

            /**
             * Specify the url of the image. 
             */
            href?: string
    }
    declare     export interface MapOptions {

        /**
         * Width of the attribution node relative to the map width. 
         */
        attributionWidth?: number,

            /**
             * When true the map will automatically resize when the browser window is resized or when the ContentPane widget enclosing the map is resized. 
             */
            autoResize?: boolean,

            /**
             * Specify a basemap for the map. 
             */
            basemap?: string,

            /**
             * The location where the map should be centered. 
             */
            center?: number[] | Point,

            /**
             * When true, graphics are displayed during panning. 
             */
            displayGraphicsOnPan?: boolean,

            /**
             * If provided, the extent and projection of the map is set to the properties of Extent. 
             */
            extent?: Extent,

            /**
             * When true a fade effect is enabled for supported layers. 
             */
            fadeOnZoom?: boolean,

            /**
             * When true, for maps that contain tiled map service layers, you are guaranteed to have the initial extent defined using the extent constructor option shown completely on the map. 
             */
            fitExtent?: boolean,

            /**
             * When the mapNavigation mode is set to 'css-transforms', CSS3 transforms will be used for map navigation when supported by the browser. 
             */
            force3DTransforms?: boolean,

            /**
             * By default the map creates and uses an out-of-the-box esri/dijit/Popup. 
             */
            infoWindow?: InfoWindowBase,

            /**
             * If provided, the map is initialized with the specified levels of detail. 
             */
            lods?: LOD[],

            /**
             * Display the esri logo on the map. 
             */
            logo?: boolean,

            /**
             * Maximum visible scale of the map. 
             */
            maxScale?: number,

            /**
             * Maximum map zoom level. 
             */
            maxZoom?: number,

            /**
             * Minimum visible scale of the map. 
             */
            minScale?: number,

            /**
             * Minimum map zoom level. 
             */
            minZoom?: number,

            /**
             * Displays pan buttons on map. 
             */
            nav?: boolean,

            /**
             * Specify whether or not to use CSS3 transformations when panning and zooming. 
             */
            navigationMode?: string,

            /**
             * Default value is true, indicating that the map will skip panning animation when calling map.centerAt() or map.setExtent() (for map.setExtent(), the animation is only skipped if the map's zoom level is not changing) if the panning distance is twice the distance of the current extent. 
             */
            optimizePanAnimation?: boolean,

            /**
             * Specify a time period in milliseconds to ignore repeated calls to the resize method. 
             */
            resizeDelay?: number,

            /**
             * Initial map scale. 
             */
            scale?: number,

            /**
             * Enable or disable map attribution display. 
             */
            showAttribution?: boolean,

            /**
             * If true and a map click event occurs, it may show the map's infoWindow. 
             */
            showInfoWindowOnClick?: boolean,

            /**
             * Indicate whether to display labels. 
             */
            showLabels?: boolean,

            /**
             * Displays a slider on the map. 
             */
            slider?: boolean,

            /**
             * Define labels for the slider. 
             */
            sliderLabels?: string[],

            /**
             * Orientation of the zoom slider. 
             */
            sliderOrientation?: string,

            /**
             * Position of the zoom slider within the map control. 
             */
            sliderPosition?: string,

            /**
             * Defines the slider style. 
             */
            sliderStyle?: string,

            /**
             * When true, for Apple computers with a trackpad or magic mouse use, swipe pans instead of zooming. 
             */
            smartNavigation?: boolean,

            /**
             * When true, supports continuous pan across the dateline. 
             */
            wrapAround180?: boolean,

            /**
             * Initial zoom level of the map. 
             */
            zoom?: number
    }
    declare     export interface MeasurementOptions {

        /**
         * Flag for showing full list of units in the Location tool. 
         */
        advancedLocationUnits?: boolean,

            /**
             * The default area unit for the measure area tool. 
             */
            defaultAreaUnit?: string,

            /**
             * The default length unit for the measure distance tool. 
             */
            defaultLengthUnit?: string,

            /**
             * Allows the user to immediately measure previously-created geometry on dijit creation. 
             */
            geometry?: Point | Polyline | Polygon,

            /**
             * Line symbol used to draw the lines for the measure line and measure distance tools. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Marker symbol used to draw the points for the measure line tool. 
             */
            pointSymbol?: MarkerSymbol
    }
    declare     export interface MergeLayersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer to be merged with the mergeLayer. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * An array of feature layer candidates to be selected as the merge layer. 
             */
            mergeLayers: FeatureLayer[],

            /**
             * An array of values that describe how fields from the mergeLayer are to be modified. 
             */
            mergingAttributes?: string[],

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }

    /**
     * Constants representing how the geometry is returned. 
     */
    declare     export interface NAOutputLine {

        /**
         * Do not return geometries. 
         */
        NONE: any,

            /**
             * Return polylines containing striaght lines between input locations. 
             */
            STRAIGHT: any,

            /**
             * Return polylines based on the underlying street geometries. 
             */
            TRUE_SHAPE: any,

            /**
             * Return polylines based on the underlying street geometries with the M values set based on the accumulated impedance at each vertex. 
             */
            TRUE_SHAPE_WITH_MEASURE: any
    }

    /**
     * Constants representing how the geometry is returned. 
     */
    declare     export interface NAOutputPolygon {

        /**
         * Detailed output polygons 
         */
        DETAILED: any,

            /**
             * No output polygons 
             */
            NONE: any,

            /**
             * Simplified output polygons. 
             */
            SIMPLIFIED: any
    }

    /**
     * Constants representing directionality in network analysis. 
     */
    declare     export interface NATravelDirection {

        /**
         * Travel direction from the facility 
         */
        FROM_FACILITY: any,

            /**
             * Travel direction to the facility 
             */
            TO_FACILITY: any
    }

    /**
     * Constants representing how U-Turns are handled. 
     */
    declare     export interface NAUTurn {

        /**
         * Allow u-turns at the end of any street. 
         */
        ALLOW_BACKTRACK: any,

            /**
             * Allow u-turns at dead ends and intersections. 
             */
            AT_DEAD_ENDS_AND_INTERSECTIONS: any,

            /**
             * Only allow u-turns at dead ends where a street is not connected to another street. 
             */
            AT_DEAD_ENDS_ONLY: any,

            /**
             * Do not allow u-turns at the end of any streets. 
             */
            NO_BACKTRACK: any
    }
    declare     export interface OAuthInfoOptions {

        /**
         * The registered application Id. 
         */
        appId: string,

            /**
             * Applications with the same value will share the stored token on the same host. 
             */
            authNamespace?: string,

            /**
             * The number of minutes the token will be valid for. 
             */
            expiration?: number,

            /**
             * The locale for the OAuth sign in page. 
             */
            locale?: string,

            /**
             * The minimum time in minutes before a saved token is due to expire that it should still be considered valid for use. 
             */
            minTimeUntilExpiration?: number,

            /**
             * Set to true to show the OAuth sign in page in a popup window. 
             */
            popup?: boolean,

            /**
             * The relative page URL for the user to be sent to from the OAuth sign in page. 
             */
            popupCallbackUrl?: string,

            /**
             * The window features passed to window.open(). 
             */
            popupWindowFeatures?: string,

            /**
             * The ArcGIS for Portal URL. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display social logins such as Google/Facebook. 
             */
            showSocialLogins?: boolean
    }
    declare     export interface ObliqueViewerOptions {

        /**
         * Azimuth angle value for which to display oblique images. 
         */
        azimuthAngle?: number,

            /**
             * Image service field that denotes the sensor azimuth value for a record. 
             */
            azimuthField?: string,

            /**
             * Tolerance value applied when filtering azimuth images. 
             */
            azimuthTolerance?: number,

            /**
             * Image service field that denotes the sensor elevation value for a record. 
             */
            elevationField?: string,

            /**
             * Elevation value between 0 and 90 that differentiates an image as oblique or nadir. 
             */
            elevationThreshold?: number,

            /**
             * Image service layer to be used as source for oblique images. 
             */
            imageServiceLayer: ArcGISImageServiceLayer,

            /**
             * Map object associated with the widget. 
             */
            map: Map,

            /**
             * When true, the widget doesn't refresh itself with new oblique records when the map's extent changes. 
             */
            noQueryOnExtentChange?: boolean,

            /**
             * Raster info fields to be queried and displayed in the raster list. 
             */
            rasterInfoFields?: any[],

            /**
             * DOM Node or id, where the list element is to be placed. 
             */
            rasterListDiv?: string | Node,

            /**
             * When true, list is populated on data refresh. 
             */
            rasterListRefresh?: boolean,

            /**
             * DOM Node or id, where the oblique rotation gauge element is to be placed. 
             */
            rotationDiv?: string | Node,

            /**
             * When true, thumbnail images for records are displayed in the list. 
             */
            showThumbnail?: boolean,

            /**
             * Sorting function that takes query results and sorts them. 
             */
            sorter?: Function
    }
    declare     export interface OpacitySliderOptions {

        /**
         * Handles identified by their index values within the stops array. 
         */
        handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The data map containing renderer information. 
             */
            opacityInfo: any,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Represents the width of the SVG ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Displays the transparent background when true. 
             */
            showTransparentBackground?: boolean,

            /**
             * Represents a statistics data object. 
             */
            statistics?: any,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface OpenStreetMapLayerOptions {

        /**
         * An array of levels at which to draw. 
         */
        displayLevels?: number[],

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * An array of tile servers 
             */
            tileServers?: string[],

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface OperationBaseOptions {

        /**
         * Provide information about the operation. 
         */
        label?: string,

            /**
             * Specify the type of operation, for example: "edit" or "navigation". 
             */
            type?: string
    }
    declare     export interface OverlayLayersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer that will be overlayed with the overlayLayer. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * An array of feature layers to be overlaid with inputLayer. 
             */
            overlayLayer: FeatureLayer[],

            /**
             * Defines how two input layers are combined. 
             */
            overlayType?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * When the distance between features is less than the tolerance, the features in the overlay layer will snap to the features in the input layer. 
             */
            snapToInput?: boolean,

            /**
             * The minimum distance separating all feature coordinates (nodes and vertices) as well as the distance a coordinate can move in X or Y (or both). 
             */
            tolerance?: number
    }
    declare     export interface OverviewMapOptions {

        /**
         * Specifies which corner of the map to attach the OverviewMap dijit. 
         */
        attachTo?: string,

            /**
             * Specify the base layer for the overview map. 
             */
            baseLayer?: Layer,

            /**
             * Fill color for the extent rectangle. 
             */
            color?: string,

            /**
             * The ratio between the size of the overview map and the extent rectangle displayed on the overview map. 
             */
            expandFactor?: number,

            /**
             * Height of the overview map dijit in screen pixels. 
             */
            height?: number,

            /**
             * Unique identifier for the dijit. 
             */
            id?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Defines the visibility of the maximize/restore button. 
             */
            maximizeButton?: boolean,

            /**
             * Opacity of the extent rectangle, defined as a number between 0 (invisible) and 1 (opaque). 
             */
            opacity?: number,

            /**
             * Specifies the initial visibility of the overview map. 
             */
            visible?: boolean,

            /**
             * Width of the overview map dijit in screen pixels. 
             */
            width?: number
    }
    declare     export interface PixelBlockOptions {

        /**
         * Number of rows. 
         */
        height: number,

            /**
             * An array of nodata mask. 
             */
            mask?: any[],

            /**
             * A two dimensional array. 
             */
            pixels: number[][],

            /**
             * Pixel type. 
             */
            pixelType?: string,

            /**
             * Array of objects containing numeric statistical properties (e.g. 
             */
            statistics?: any[],

            /**
             * Number of columns. 
             */
            width: number
    }
    declare     export interface PopupMobileOptions {

        /**
         * Define the symbol used to highlight polygon features. 
         */
        fillSymbol?: FillSymbol,

            /**
             * When true, the feature is highlighted, set to false to disable highlighting. 
             */
            highlight?: boolean,

            /**
             * Define the symbol used to highlight line features. 
             */
            lineSymbol?: LineSymbol,

            /**
             * Specify the margin (in pixels) to leave to the left of the popup window when it is maximized. 
             */
            marginLeft?: number,

            /**
             * Specify the margin (in pixels) to leave at the top of the popup window when it is maximized. 
             */
            marginTop?: number,

            /**
             * Define the marker symbol used to highlight point features. 
             */
            markerSymbol?: MarkerSymbol,

            /**
             * Specify the x-offset (in pixels) used when positioning the popup. 
             */
            offsetX?: number,

            /**
             * Specify the y-offset (in pixels) used when positioning the popup. 
             */
            offsetY?: number,

            /**
             * Define the number of levels to zoom in, default value is 4. 
             */
            zoomFactor?: number
    }
    declare     export interface PopupOptions {

        /**
         * Controls the placement of the popup window with respect to the geographic location. 
         */
        anchor?: string,

            /**
             * Define the symbol used to highlight polygon features. 
             */
            fillSymbol?: FillSymbol,

            /**
             * Number of milliseconds after which the popup window will be hidden when visibleWhenEmpty is false and there are no features to be displayed. 
             */
            hideDelay?: boolean,

            /**
             * Indicates whether popup should highlight features. 
             */
            highlight?: boolean,

            /**
             * Indicates whether a feature should remain highlighted after the user closes the popup window. 
             */
            keepHighlightOnHide?: boolean,

            /**
             * Define the symbol used to highlight line features. 
             */
            lineSymbol?: LineSymbol,

            /**
             * Specify the margin (in pixels) to leave to the left of the popup window when it is maximized. 
             */
            marginLeft?: number,

            /**
             * Specify the margin (in pixels) to leave at the top of the popup window when it is maximized. 
             */
            marginTop?: number,

            /**
             * Define the marker symbol used to highlight point features. 
             */
            markerSymbol?: MarkerSymbol,

            /**
             * Specify the x-offset (in pixels) used when positioning the popup. 
             */
            offsetX?: number,

            /**
             * Specify the y-offset (in pixels) used when positioning the popup. 
             */
            offsetY?: number,

            /**
             * Indicates whether popup should display previous and next buttons in the title bar. 
             */
            pagingControls?: boolean,

            /**
             * Indicates whether popup should display the title bar text that contains the page number and total number of available features. 
             */
            pagingInfo?: boolean,

            /**
             * Indicates whether the popup window should be displayed. 
             */
            popupWindow?: boolean,

            /**
             * Indicates whether the feature's title should display within the body of the popup window as opposed to in the titlebar. 
             */
            titleInBody?: boolean,

            /**
             * Indicates whether the popup window remains visible when there are no features to be displayed. 
             */
            visibleWhenEmpty?: boolean,

            /**
             * Define the number of levels to zoom in when the 'Zoom to' link is clicked. 
             */
            zoomFactor?: number
    }
    declare     export interface PopupTemplateOptions {

        /**
         * Positive or negative offset (in minutes) from UTC. 
         */
        utcOffset?: number
    }
    declare     export interface PrintOptions {

        /**
         * Set to true if the print service is an asynchronous geoprocessing service. 
         */
        async?: boolean,

        /**
         * The map to  print. 
         */
        map?: Map,

            /**
             * An optional array of user-defined templates. 
             */
            templates?: PrintTemplate[],

            /**
             * The url to an export web map task. 
             */
            url?: string
    }
    declare     export interface PrintTaskOptions {

        /**
         * Set to true if the print service is an asynchronous geoprocessing service. 
         */
        async?: boolean
    }
    declare     export interface ProcessorOptions {

        /**
         * Start processing features immediately. 
         */
        autostart?: boolean,

            /**
             * Whether the processor allow the feature layer to draw its features. 
             */
            drawFeatures?: boolean,

            /**
             * Whether the processor do the layer's I/O via a worker. 
             */
            fetchWithWorker?: boolean,

            /**
             * A FeatureLayer or array of FeatureLayers to attach the processor to. 
             */
            layers?: FeatureLayer[],

            /**
             * Uses all FeatureLayers associated with the map in the processor. 
             */
            map?: Map,

            /**
             * Whether the processor pass the features through without modification or delay to the FeatureLayer. 
             */
            passFeatures?: boolean,

            /**
             * Whether the processor require Workers to function properly. 
             */
            requireWorkerSupport?: boolean
    }
    declare     export interface QueryTaskLocationProviderOptions {

        /**
         * Object containing properties that will be used to query the ArcGIS layer. 
         */
        queryParameters: any,

            /**
             * An instance of a QueryTask. 
             */
            queryTask: QueryTask,

            /**
             * Set to true when querying a field that contains unicode characters. 
             */
            unicode: boolean,

            /**
             * A mapping of the fields in the data and the ArcGIS layer to use to perform a join. 
             */
            whereFields: any
    }
    declare     export interface QueryTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface RasterLayerOptions {

        /**
         * Sets the layer's draw mode. 
         */
        drawMode?: boolean,

            /**
             * Sets the context of the Canvas. 
             */
            drawType?: string,

            /**
             * Additional parameters defined in an  ImageServiceParameters object. 
             */
            imageServiceParameters?: ImageServiceParameters,

            /**
             * Applies a function for visualization or post-processing purposes. 
             */
            pixelFilter?: any
    }
    declare     export interface RendererSliderOptions {

        /**
         * Collection of indexes that indicates which children from the infos array to use as handles. 
         */
        handles?: number[],

            /**
             * Absolute maximum value allowed by the slider. 
             */
            maximum: number,

            /**
             * Top label for the slider. 
             */
            maxLabel?: string,

            /**
             * Absolute minimum value allowed by the slider. 
             */
            minimum: number,

            /**
             * Bottom label for the slider. 
             */
            minLabel?: string,

            /**
             * Accuracy of the data (related to rounding). 
             */
            precision?: number,

            /**
             * Primary handle identified by its index value within the related infos array (color, size, break). 
             */
            primaryHandle?: number,

            /**
             * Toggle for showing the black handle bars. 
             */
            showHandles?: boolean,

            /**
             * Flexible toggle for showing labels (e.g. 
             */
            showLabels?: boolean | string[],

            /**
             * Toggle for showing the horizontal line indicators from the center of the handle. 
             */
            showTicks?: boolean,

            /**
             * Stores positions represented as numbers that fall between minimum and maximum. 
             */
            values: number[]
    }
    declare     export interface RingBufferOptions {

        /**
         * The radii to use to create ring buffers 
         */
        radii: number[],

            /**
             * The units of the radii. 
             */
            units: string
    }
    declare     export interface ScaleDependentRendererOptions {

        /**
         * An array of objects where each object defines a renderer and  the zoom or scale range to which it applies. 
         */
        rendererInfos?: any[]
    }
    declare     export interface ScalebarOptions {

        /**
         * Specify the scalebar position on the map. 
         */
        attachTo?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Specify the style for the scalebar. 
             */
            scalebarStyle?: string,

            /**
             * Specify the scalebar units. 
             */
            scalebarUnit?: string
    }
    declare     export interface SearchOptions {

        /**
         * The currently selected source. 
         */
        activeSourceIndex?: number | string,

            /**
             * Indicates whether to automatically add all the feature layers from the map. 
             */
            addLayersFromMap?: boolean,

            /**
             * This is the default value used as a hint for input text when searching on multiple sources. 
             */
            allPlaceholder?: string,

            /**
             * Indicates whether to automatically navigate to the selected result. 
             */
            autoNavigate?: boolean,

            /**
             * Indicates whether to automatically select the first geocoded result (not the first suggestion). 
             */
            autoSelect?: boolean,

            /**
             * Indicates whether to enable an option to collapse/expand the search into a button. 
             */
            enableButtonMode?: boolean,

            /**
             * Indicates whether to show the selected feature on the map using the highlight symbol property. 
             */
            enableHighlight?: boolean,

            /**
             * Indicates whether to display the infoWindow on feature click. 
             */
            enableInfoWindow?: boolean,

            /**
             * Indicates whether to enable showing a label for the geometry.The default value is false. 
             */
            enableLabel?: boolean,

            /**
             * Indicates whether to display the option to search "All" sources. 
             */
            enableSearchingAll?: boolean,

            /**
             * Indicates whether to enable the menu for selecting different sources. 
             */
            enableSourcesMenu?: boolean,

            /**
             * Indicates whether or not to enable suggest on the widget. 
             */
            enableSuggestions?: boolean,

            /**
             * Indicates whether to display suggest results. 
             */
            enableSuggestionsMenu?: boolean,

            /**
             * Indicates whether to set the state of the enableButtonMode to expanded (true) or collapsed (false). 
             */
            expanded?: boolean,

            /**
             * This the specified graphicsLayer to use for the highlightGraphic and labelGraphic instead of map.graphics. 
             */
            graphicsLayer?: Layer,

            /**
             * The symbol used for highlightGraphic. 
             */
            highlightSymbol?: Symbol,

            /**
             * A customized infoTemplate for the selected feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * The text symbol for the label graphic. 
             */
            labelSymbol?: TextSymbol,

            /**
             * The default distance specified in meters used to reverse geocode, (if not specified by source). 
             */
            locationToAddressDistance?: number,

            /**
             * Reference to the map. 
             */
            map?: Map,

            /**
             * The default maximum number of results returned by the widget if not specified by source. 
             */
            maxResults?: number,

            /**
             * The default maximum number of suggestions returned by the widget if not specified by source. 
             */
            maxSuggestions?: number,

            /**
             * The default minimum amount of characters needed for the search if not specified by source. 
             */
            minCharacters?: number,

            /**
             * Indicates whether to show the infoWindow when a result is selected. 
             */
            showInfoWindowOnSelect?: boolean,

            /**
             * An array of source objects used to find search results. 
             */
            sources?: any[],

            /**
             * The millisecond delay after keyup and before making a suggest network request. 
             */
            suggestionDelay?: number,

            /**
             * The CSS class selector used to uniquely style the widget. 
             */
            theme?: string,

            /**
             * Current value of the search box input text string. 
             */
            value?: string,

            /**
             * Indicates whether to show the Search widget. 
             */
            visible?: boolean,

            /**
             * If the result does not have an associated extent, specify this number to use as the zoom scale for the result. 
             */
            zoomScale?: number
    }
    declare     export interface SizeInfoSliderOptions {

        /**
         * Handles identified by their index values within the stops array. 
         */
        handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of the histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Represents the width of the SVG ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Defines the size of the symbol where feature size is proportional to data value. 
             */
            sizeInfo: any,

            /**
             * Represents the statistics data object. 
             */
            statistics?: any,

            /**
             * The SimpleLineSymbol or SimpleMarkerSymbol used with the widget. 
             */
            symbol: Symbol,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface SnappingManagerOptions {

        /**
         * When true, snapping is always enabled. 
         */
        alwaysSnap?: boolean,

            /**
             * See the object specifications table below for the structure of the  layerInfos  object. 
             */
            layerInfos?: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * When alwaysSnap is set to false use this option to define the key users press to enable snapping. 
             */
            snapKey?: any,

            /**
             * Define a symbol for the snapping location. 
             */
            snapPointSymbol?: SimpleMarkerSymbol,

            /**
             * Specify the radius of the snapping circle in pixels. 
             */
            tolerance?: number
    }
    declare     export interface SpatialIndexOptions {

        /**
         * Start processing features immediately. 
         */
        autostart?: boolean,

            /**
             * Whether the processor allow the feature layer to draw its features. 
             */
            drawFeatures?: boolean,

            /**
             * Whether the processor do the layer's I/O via a worker. 
             */
            fetchWithWorkers?: boolean,

            /**
             * Index system specific options. 
             */
            indexOptions?: any,

            /**
             * The indexing system to use. 
             */
            indexType?: string,

            /**
             * A FeatureLayer or array of FeatureLayers to attach the processor to. 
             */
            layers?: FeatureLayer[],

            /**
             * Uses all FeatureLayers associated with the map in the processor. 
             */
            map?: Map,

            /**
             * Whether the processor pass the features through without modification or delay to the FeatureLayer. 
             */
            passFeatures?: boolean,

            /**
             * Whether the processor require Workers to function properly. 
             */
            requireWorkerSupport?: boolean
    }
    declare     export interface StandardGeographyQueryLocationProviderOptions {

        /**
         * A template to be used to build the query for Standard Geography query. 
         */
        geographyQueryTemplate: string,

            /**
             * An object that specifies the parameters to use in the Standard Geography query. 
             */
            queryParameters?: any,

            /**
             * An instance of the StandardGeographyQuery class. 
             */
            standardGeographyQueryTask: StandardGeographyQueryTask
    }
    declare     export interface StreamLayerOptions1 {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Where clause to use as definition expression for layer. 
             */
            definitionExpression?: string,

            /**
             * The extent to use as the spatial filter for the layer. 
             */
            geometryDefinition?: Extent,

            /**
             * Maximum number of observations to show for each unique track. 
             */
            maximumTrackPoints?: number,

            /**
             * An array of strings corresponding with fields to include in the StreamLayer. 
             */
            outFields?: string[],

            /**
             * Rules for purging data from the layer to avoid overloading the browser with too many features. 
             */
            purgeOptions?: any
    }
    declare     export interface StreamLayerOptions2 {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * The extent to use as the spatial filter for the layer. 
             */
            geometryDefinition?: Extent,

            /**
             * Maximum number of observations to show for each unique track. 
             */
            maximumTrackPoints?: number,

            /**
             * An array of strings corresponding with fields to include in the StreamLayer. 
             */
            outFields?: string[],

            /**
             * Rules for purging data from the layer to avoid overloading the browser with too many features. 
             */
            purgeOptions?: any,

            /**
             * The URL to use for connecting to a socket. 
             */
            socketUrl?: string
    }
    declare     export interface StretchFilterOptions {

        /**
         * Indicates whether to perform dynamic range adjustment using the current pixel data. 
         */
        dra?: boolean,

            /**
             * An array of gamma values, for example [0.8, 0.8, 0.8]. 
             */
            gamma?: number[],

            /**
             * The maximum value of stretched pixels. 
             */
            max?: number,

            /**
             * Percent of pixels clipped on the right histogram tail, for example 0.25. 
             */
            maxPercent?: number,

            /**
             * The minimum value of stretched pixels. 
             */
            min?: number,

            /**
             * Percent of pixels clipped on the left histogram tail, for example 1.5. 
             */
            minPercent?: number,

            /**
             * The number of standard deviations for StandardDeviation stretch, for example 2.5. 
             */
            numberOfStandardDeviations?: number,

            /**
             * The output pixel type. 
             */
            outputPixelType?: string,

            /**
             * An array of arrays containing custom statistics objects. 
             */
            statistics?: any[][],

            /**
             * See the constants table for a list of possible stretchType values. 
             */
            stretchType?: number,

            /**
             * Indicates whether to perform non-linear gamma stretch. 
             */
            useGamma?: boolean
    }
    declare     export interface SummarizeNearbyOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of numbers that defines the search distance (for StraightLine or DrivingDistance) or time (for DrivingTime) shown in the distance input in the Find nearest features using a option. 
             */
            distance?: number[],

            /**
             * When true, Travel Modes (Driving Distance, Driving Time) are enabled for sumNearbyLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * A field of the summarizeLayer features that you can use to calculate statistics separately for each unique attribute value. 
             */
            groupByField?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * Type of distance measurement shown as the defeault value in the Find nearest features using a option. 
             */
            nearType?: string,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * Type of units shown under the Total Area checkbox in the Add statistics from option. 
             */
            shapeUnits?: string,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of possible statistics attribute field names and summary types that you wish to calculate for all nearby features. 
             */
            summaryFields?: string[],

            /**
             * The feature layer to be shown selected in the Choose layer to summarize dropdown. 
             */
            summaryLayer?: FeatureLayer,

            /**
             * An array of possible feature layers summarizing toward. 
             */
            summaryLayers: FeatureLayer[],

            /**
             * The point, line, or polygon feature layers from which distances will be measured to features in summarizeLayer. 
             */
            sumNearbyLayers: FeatureLayer[],

            /**
             * If true. 
             */
            sumShape?: boolean,

            /**
             * Type of units shown as the defeault value in the Find nearest features using a option. 
             */
            units?: string
    }
    declare     export interface SummarizeWithinOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * A field name from summaryLayer that you can use to calculate statistics separately for each unique attribute value. 
             */
            groupByField?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * A list of field names and statistical summary type that you wish to calculate for all features in SummaryLayer that are within each polygon in sumWithinLayer. 
             */
            summaryFields?: string,

            /**
             * The summary layer to be shown selected in in the Choose layer to summarize menu. 
             */
            summaryLayer?: FeatureLayer,

            /**
             * An array of summarize layer candidates. 
             */
            summaryLayers: FeatureLayer[],

            /**
             * The polygon feature layer to be summarized toward. 
             */
            sumWithinLayer: FeatureLayer
    }
    declare     export interface SymbolStylerOptions {

        /**
         * Added at v. 
         */
        portal?: string | any,

            /**
             * Self response of Portal used as symbol provider. 
             */
            portalSelf?: any,

            /**
             * URL to Portal used as symbol provider. 
             */
            portalUrl?: string
    }
    declare     export interface TemplatePickerOptions {

        /**
         * Number of visible columns. 
         */
        columns?: number,

            /**
             * Defines the text to be displayed when the template picker does not have any templates to display. 
             */
            emptyMessage?: string,

            /**
             * Array of input feature layers. 
             */
            featureLayers?: FeatureLayer[],

            /**
             * Templates are grouped based on the containing feature layer. 
             */
            grouping?: boolean,

            /**
             * An array of items described using the syntax below. 
             */
            items?: any[],

            /**
             * Length of label description. 
             */
            maxLabelLength?: number,

            /**
             * Number of visible rows. 
             */
            rows?: number,

            /**
             * Tooltip content contains the template name and description. 
             */
            showTooltip?: boolean,

            /**
             * HTML style attributes for the widget. 
             */
            style?: string,

            /**
             * When true, the template picker displays map service legend swatches for feature layers created in selection mode that have an associated map service added to the map as a dynamic map service layer. 
             */
            useLegend?: boolean
    }
    declare     export interface TimeClassBreaksAgerOptions {

        /**
         * The alpha opacity for the break. 
         */
        alpha: number,

            /**
             * The color for the break. 
             */
            color: Color,

            /**
             * The maximum age for the break info. 
             */
            maxAge: number,

            /**
             * The minimum age for the break info. 
             */
            minAge: number,

            /**
             * The size for the break. 
             */
            size: number
    }
    declare     export interface TimeSliderOptions {

        /**
         * When true, subtracts one second to the time extent's end time to exclude data at the exact end time instant. 
         */
        excludeDataAtLeadingThumb?: boolean,

            /**
             * When true, adds one second to the time extent's start time to exclude data at the exact start time instant. 
             */
            excludeDataAtTrailingThumb?: boolean
    }
    declare     export interface UndoManagerOptions {

        /**
         * The maximum number of operations the UndoManager can perform. 
         */
        maxOperations?: number
    }
    declare     export interface UnionOptions {

        /**
         * The feature(s) removed from the feature layer by the union operation. 
         */
        deletedGraphics?: Graphic[],

            /**
             * The feature layer that contains the unioned feature(s). 
             */
            featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) before the union operation is performed. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface UpdateOptions {

        /**
         * The feature layer that contains the updated feature(s). 
         */
        featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) prior to the update. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface VEGeocoderOptions {

        /**
         * Key used to access Bing Maps maps. 
         */
        bingMapsKey?: string,

            /**
             * Specifies the culture in which to return results. 
             */
            culture?: string
    }
    declare     export interface VETiledLayerOptions {

        /**
         * Key used to access Bing Maps maps. 
         */
        bingMapsKey?: string,

            /**
             * Class attribute to set for the layer's node. 
             */
            className?: string,

            /**
             * Specifies the culture in which to return results. 
             */
            culture?: string,

            /**
             * Bing Maps style. 
             */
            mapStyle?: string,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number
    }
    declare     export interface VectorFieldRendererOptions {

        /**
         * Sets the flow direction of the data. 
         */
        flowRepresentation?: string,

            /**
             * A symbol that can be defined if the style is set to STYLE_SINGLE_ARROW. 
             */
            singleArrowSymbol?: Symbol,

            /**
             * A predefined style. 
             */
            style?: string
    }
    declare     export interface VectorTileLayerOptions {

        /**
         * Lists which levels of the layer to draw. 
         */
        displayLevels?: number[],

            /**
             * Maximum visible scale for the layer. 
             */
            maxScale?: number,

            /**
             * Minimum visible scale for the layer. 
             */
            minScale?: number,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface VisibleScaleRangeSliderOptions {

        /**
         * Layer used to determine the suggested scale range and set the minScale, maxScale values. 
         */
        layer?: Layer,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Region of preview scale thumbnails. 
             */
            region?: string
    }
    declare     export interface WCSConnectionOptions {

        /**
         * The coverage identifier, defaults to the first coverage. 
         */
        coverageId?: string,

            /**
             * The version of WCSLayer, can be: 1.0.01.1.01.1.11.1.22.0.1 
             */
            version?: string
    }
    declare     export interface WCSLayerOptions {

        /**
         * The coverage identifier, defaults to the first coverage. 
         */
        coverageId?: string,

            /**
             * Sets the layer's draw mode. 
             */
            drawMode?: boolean,

            /**
             * Sets the context of the Canvas. 
             */
            drawType?: string,

            /**
             * A function that takes a pixelData object as input and processes it. 
             */
            pixelFilter?: Function,

            /**
             * The version of WCSLayer, can be: 1.0.01.1.01.1.11.1.22.0.1 
             */
            version?: string,

            /**
             * A WCS Connection object. 
             */
            wcsConnection?: WCSConnection
    }
    declare     export interface WFSLayerOptions {

        /**
         * Use this to append custom parameters to WFS requests. 
         */
        customParameters?: any,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Specifies the maximum number of features to return in one response. 
             */
            maxFeatures?: number,

            /**
             * The query mode for the WFS layer. 
             */
            mode?: string,

            /**
             * The simple layer name (excluding the namespace). 
             */
            name?: string,

            /**
             * URL to the WFS server. 
             */
            url: string,

            /**
             * OGC WFS version number. 
             */
            version?: string,

            /**
             * The well-known ID of the spatial reference used by the WFSLayer. 
             */
            wkid?: string
    }
    declare     export interface WMSLayerInfoOptions {

        /**
         * All the bounding extents defined for this layer. 
         */
        allExtents?: Extent[],

            /**
             * A description of the WMS layer. 
             */
            description?: string,

            /**
             * The extent of the WMS Layer. 
             */
            extent?: Extent,

            /**
             * The URL to the legend image. 
             */
            legendURL?: string,

            /**
             * The name of the WMS layer. 
             */
            name: string,

            /**
             * Returns true if the layer can be queried and the service supports GetFeatureInfo with either text/html or text/plain formats. 
             */
            queryable?: boolean,

            /**
             * Indicates if this layer should be included in the popup. 
             */
            showPopup?: boolean,

            /**
             * All the spatial references defined for this layer. 
             */
            spatialReferences?: SpatialReference[],

            /**
             * WMSLayerInfos of the layer's sub layers. 
             */
            subLayers?: WMSLayerInfo[],

            /**
             * The title of the WMS layer. 
             */
            title?: string
    }
    declare     export interface WMSLayerOptions {

        /**
         * The customLayerParameters object used for the WMS Layer. 
         */
        customLayerParameters?: any,

            /**
             * The customParameters object used for the WMS Layer. 
             */
            customParameters?: any,

            /**
             * Specify the map image format, valid options are png,jpg,bmp,gif,svg. 
             */
            format?: string,

            /**
             * An optional resourceInfo object. 
             */
            resourceInfo?: any,

            /**
             * If the WMS service supports transparency, specify whether the image background is transparent. 
             */
            transparent?: boolean,

            /**
             * A version number. 
             */
            version?: string,

            /**
             * A list of layer names that represent the layers to include in the exported map. 
             */
            visibleLayers?: string[]
    }
    declare     export interface WMTSLayerInfoOptions {

        /**
         * The description of the layer defined by the abstract property of the capabilities file or resource info. 
         */
        description?: string,

            /**
             * Specify a format supported by the service. 
             */
            format?: string,

            /**
             * The full extent of the WMTS layer. 
             */
            fullExtent?: Extent,

            /**
             * The layer id. 
             */
            identifier?: string,

            /**
             * The initial extent of the WMTS layer. 
             */
            initialExtent?: Extent,

            /**
             * Specify the layer style. 
             */
            style?: string,

            /**
             * A tile info object. 
             */
            tileInfo?: TileInfo,

            /**
             * Define the tileMatrixSet for the layer. 
             */
            tileMatrixSet?: string,

            /**
             * The layer title. 
             */
            title?: string
    }
    declare     export interface WMTSLayerOptions {

        /**
         * The customLayerParameters object used for the WMTS Layer. 
         */
        customLayerParameters?: any,

            /**
             * The customParameters object used for the WMTS Layer. 
             */
            customParameters?: any,

            /**
             * A WMTSLayerInfo object that when ResourceInfo options are not specified the map will display the first layer in the WMTS capabilities that matches the properties specified by WMTSLayerInfo. 
             */
            layerInfo?: WMTSLayerInfo,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * An optional resource info object. 
             */
            resourceInfo?: any,

            /**
             * Specify the service type. 
             */
            serviceMode?: string
    }
    declare     export interface WebTiledLayerOptions {

        /**
         * Define attribution information for the layer to be used by the Attribution widget. 
         */
        copyright?: string,

            /**
             * Specify the full extent of the layer. 
             */
            fullExtent?: Extent,

            /**
             * Specify the initial extent of the layer. 
             */
            initialExtent?: Extent,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * Specify subDomains where tiles are served to speed up tile retrieval (using subDomains gets around the browser limit of the max number of concurrent requests to a domain). 
             */
            subDomains?: string[],

            /**
             * Define the tile info for the layer including lods, rows, cols, origin and spatial reference. 
             */
            tileInfo?: TileInfo,

            /**
             * Define additional tile server domains for the layer. 
             */
            tileServers?: string[]
    }
}
declare module 'esri/Color' {
    declare module.exports: typeof Color
}
declare module 'esri/Credential' {
    declare module.exports: typeof Credential
}
declare module 'esri/IdentityManager' {
    declare module.exports: typeof IdentityManager
}
declare module 'esri/IdentityManagerBase' {
    declare module.exports: typeof IdentityManagerBase
}
declare module 'esri/ImageSpatialReference' {
    declare module.exports: typeof ImageSpatialReference
}
declare module 'esri/InfoTemplate' {
    declare module.exports: typeof InfoTemplate
}
declare module 'esri/InfoWindowBase' {
    declare module.exports: typeof InfoWindowBase
}
declare module 'esri/OperationBase' {
    declare module.exports: typeof OperationBase
}
declare module 'esri/ServerInfo' {
    declare module.exports: typeof ServerInfo
}
declare module 'esri/SnappingManager' {
    declare module.exports: typeof SnappingManager
}
declare module 'esri/SpatialReference' {
    declare module.exports: typeof SpatialReference
}
declare module 'esri/TimeExtent' {
    declare module.exports: typeof TimeExtent
}
declare module 'esri/arcgis/OAuthInfo' {
    declare module.exports: typeof OAuthInfo
}
declare module 'esri/arcgis/Portal' {

    /**
     * The Portal class is part of the ArcGIS Portal API which provides a way to build applications that work with content from ArcGIS Online or an ArcGIS Portal. 
     */
    declare     export class Portal {

        /**
         * The access level of the organization. 
         */
        access: string;

        /**
         * When true, access to the organization's Portal resources must occur over SSL. 
         */
        allSSL: boolean;

        /**
         * The query that defines the basemaps that are displayed in the Basemap Gallery. 
         */
        basemapGalleryGroupQuery: string;

        /**
         * The Bing key to use for web maps using Bing Maps. 
         */
        bingKey: string;

        /**
         * Whether an organization can list applications in the marketplace . 
         */
        canListApps: boolean;

        /**
         * Whether an organization can list data services in the marketplace. 
         */
        canListData: boolean;

        /**
         * Whether an organization can list pre-provisioned items in the marketplace. 
         */
        canListPreProvisionedItems: boolean;

        /**
         * Whether an organization can provision direct purchases in the marketplace without customer request. 
         */
        canProvisionDirectPurchase: boolean;

        /**
         * When true, the organization's public items, groups and users are included in search queries. 
         */
        canSearchPublic: boolean;

        /**
         * The Bing key can be shared to the public and is returned as part of a portal's description call (/sharing/rest/portals/). 
         */
        canShareBingPublic: boolean;

        /**
         * When true, members of the organization can share resources outside the organization. 
         */
        canSharePublic: boolean;

        /**
         * Whether to allow an organization with an enterprise IDP configured to be able to turn on or off the ArcGIS sign in. 
         */
        canSignInArcGIS: boolean;

        /**
         * Whether to allow an organization with an enterprise IDP configured to be able to turn on or off the enterprise sign in. 
         */
        canSignInIDP: boolean;

        /**
         * The query that identifies the group containing the color sets used for rendering in the map viewer. 
         */
        colorSetsGroupQuery: string;

        /**
         * Whether to allow the organization to disable commenting. 
         */
        commentsEnabled: boolean;

        /**
         * Date the organization was created. 
         */
        created: Date;

        /**
         * The default locale (language and country) information. 
         */
        culture: string;

        /**
         * The custom base URL for the portal. 
         */
        customBaseUrl: string;

        /**
         * The default basemap the portal displays in the map viewer. 
         */
        defaultBasemap: any;

        /**
         * The default extent for the map the portal displays in the map viewer. 
         */
        defaultExtent: any;

        /**
         * A description of the organization / portal. 
         */
        description: string;

        /**
         * The featured groups for the portal. 
         */
        featuredGroups: any[];

        /**
         * The featured groups for the organization. 
         */
        featuredGroupsId: string;

        /**
         * The query that defines the featured group. 
         */
        featuredItemsGroupQuery: string;

        /**
         * The query that identifies the group containing features items for the gallery. 
         */
        galleryTemplatesGroupQuery: string;

        /**
         * The group that contains featured content to be displayed on the home page. 
         */
        homePageFeaturedContent: string;

        /**
         * The number of featured items that can be displayed on the home page. 
         */
        homePageFeaturedContentCount: number;

        /**
         * The port used by the portal for HTTP communication. 
         */
        httpPort: number;

        /**
         * The port used by the portal for HTTPS communication. 
         */
        httpsPort: number;

        /**
         * The id of the organization that owns this portal. 
         */
        id: string;

        /**
         * The country code of the calling IP (ArcGIS Online only). 
         */
        ipCntryCode: string;

        /**
         * Indicates if the portal is an organization. 
         */
        isOrganization: boolean;

        /**
         * Indicates if the portal is on premises. 
         */
        isPortal: boolean;

        /**
         * The query that defines the collection of editable layer templates. 
         */
        layerTemplatesGroupQuery: string;

        /**
         * The maximum validity in minutes of tokens issued for users of the organization. 
         */
        maxTokenExpirationMinutes: number;

        /**
         * Date the organization was last modified. 
         */
        modified: Date;

        /**
         * The Name of the organization / portal. 
         */
        name: string;

        /**
         * The portal host's URL. 
         */
        portalHostname: string;

        /**
         * Denotes multitenant or singletenant. 
         */
        portalMode: string;

        /**
         * The name of the portal, i.e., ArcGIS Online. 
         */
        portalName: string;

        /**
         * Stores properties specific to the organization, for example the "contact us" link. 
         */
        portalProperties: any;

        /**
         * The URL to the thumbnail of the portal. 
         */
        portalThumbnail: string;

        /**
         * URL to the portal. 
         */
        portalUrl: string;

        /**
         * The region for the organization. 
         */
        region: string;

        /**
         * Custom HTML for the home page. 
         */
        rotatorPanels: string[];

        /**
         * Whether the description of your organization displays on the home page. 
         */
        showHomePageDescription: boolean;

        /**
         * Whether hosted services are supported. 
         */
        supportsHostedServices: boolean;

        /**
         * Whether OAuth is supported. 
         */
        supportsOAuth: boolean;

        /**
         * The query that defines the symbols sets used by the map viewer. 
         */
        symbolSetsGroupQuery: string;

        /**
         * The query that defines the collection of templates that will appear in the template gallery. 
         */
        templatesGroupQuery: string;

        /**
         * The URL to the thumbnail of the organization. 
         */
        thumbnail: string;

        /**
         * The url to the thumbnail of the organization (full path). 
         */
        thumbnailUrl: string;

        /**
         * Sets the units of measure for the organization's users. 
         */
        units: string;

        /**
         * The portal url. 
         */
        url: string;

        /**
         * The prefix selected by the organization's administrator to be used with the customBaseURL. 
         */
        urlKey: string;

        /**
         * User information for the accessing user is returned only when a token is passed in. 
         */
        user: PortalUser;

        /**
         * If true, only simple where clauses that are complaint with SQL92 can be used when querying layers and tables. 
         */
        useStandardizedQuery: boolean;

        /**
         * Creates a new Portal object.
         * @param url URL to the ArcGIS.com site or in-house portal.
         */
        constructor(url: string): this;

        /**
         * Returns a PortalUser object that describes the user currently signed in to the portal. 
         */
        getPortalUser(): PortalUser;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalGroup objects for all the groups that match the input query.
         * @param queryParams The input query parameters.
         */
        queryGroups(queryParams?: any): any;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalItem objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryItems(queryParams?: any): any;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalUser objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryUsers(queryParams?: any): any;

        /**
         * Prompts the user using the IdentityManager and returns a deferred that, when resolved, returns the PortalUser for the input credentials. 
         */
        signIn(): any;

        /**
         * Sign out of the Portal which resets the Portal and disables identity checking. 
         */
        signOut(): Portal;

        /**
         * Fires when the signIn() call fails or if the Portal is not able to load. 
         */
        on(
            type: "error",
            listener: (event: {
                error: Error,
                target: Portal
            }) => void): esri.Handle;

        /**
         * Fired when the portal has loaded. 
         */
        on(type: "load", listener: (event: {
            target: Portal
        }) => void): esri.Handle;
        on(type: string, listener: (event: any) => void): esri.Handle
    }

    /**
     * Details about a comment on a Portal item.View the ArcGIS Portal API REST documentation for the item comment for more details. 
     */
    declare     export class PortalComment {

        /**
         * The comment text. 
         */
        comment: string;

        /**
         * The date and time the comment was created. 
         */
        created: string;

        /**
         * The comment id. 
         */
        id: string;

        /**
         * The user name of the user who created the comment. 
         */
        owner: string
    }

    /**
     * The PortalFolder class provides information about folders used to organize content in a portal. 
     */
    declare     export class PortalFolder {

        /**
         * The date the folder was created. 
         */
        created: Date;

        /**
         * The id of the folder. 
         */
        id: string;

        /**
         * The portal for the folder. 
         */
        portal: Portal;

        /**
         * The title of the folder. 
         */
        title: string;

        /**
         * The url to to the folder. 
         */
        url: string;

        /**
         * Find all the items in the folder. 
         */
        getItems(): any
    }

    /**
     * The group resource represents a group within the Portal. 
     */
    declare     export class PortalGroup {

        /**
         * The access privileges on the group which determines who can see and access the group. 
         */
        access: string;

        /**
         * The date the group was created. 
         */
        created: Date;

        /**
         * A detailed description of the group. 
         */
        description: string;

        /**
         * The id for the group. 
         */
        id: string;

        /**
         * If this is set to true, then users will not be able to apply to join the group. 
         */
        isInvitationOnly: boolean;

        /**
         * Denotes a view only group where members are not able to share items. 
         */
        isViewOnly: boolean;

        /**
         * The date the group was last modified. 
         */
        modified: Date;

        /**
         * The username of the group's owner. 
         */
        owner: string;

        /**
         * The portal for the group. 
         */
        portal: Portal;

        /**
         * A short summary that describes the group. 
         */
        snippet: string;

        /**
         * User defined tags that describe the group. 
         */
        tags: string[];

        /**
         * The url to the thumbnail used for the group. 
         */
        thumbnailUrl: string;

        /**
         * The title for the group. 
         */
        title: string;

        /**
         * The url to the group. 
         */
        url: string;

        /**
         * Get the current members for the group. 
         */
        getMembers(): any;

        /**
         * Execute a query against the group to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalItem objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryItems(queryParams?: any): any
    }

    /**
     * An item (a unit of content) in the Portal. 
     */
    declare     export class PortalItem {

        /**
         * Indicates the level of access: private, shared, org, or public. 
         */
        access: string;

        /**
         * Information on the source of the item. 
         */
        accessInformation: string;

        /**
         * Average rating. 
         */
        avgRating: number;

        /**
         * The date the item was created. 
         */
        created: Date;

        /**
         * The item locale information (language and country). 
         */
        culture: string;

        /**
         * The detailed description of the item. 
         */
        description: string;

        /**
         * The bounding rectangle of the item. 
         */
        extent: any;

        /**
         * The unique id for this item. 
         */
        id: string;

        /**
         * The url to the data resource associated with the item. 
         */
        itemDataUrl: string;

        /**
         * The url to the item. 
         */
        itemUrl: string;

        /**
         * Any license information or restrictions. 
         */
        licenseInfo: string;

        /**
         * Date the item was last modified. 
         */
        modified: Date;

        /**
         * The name of the item. 
         */
        name: string;

        /**
         * Number of comments on the item. 
         */
        numComments: number;

        /**
         * Number of ratings on the item. 
         */
        numRatings: number;

        /**
         * Number of views on the item. 
         */
        numViews: number;

        /**
         * The username of the user who owns this item. 
         */
        owner: string;

        /**
         * The portal that contains the item. 
         */
        portal: Portal;

        /**
         * The size of the item. 
         */
        size: number;

        /**
         * A summary description of the item. 
         */
        snippet: string;

        /**
         * The item's coordinate system. 
         */
        spatialReference: string;

        /**
         * User defined tags that describe the item. 
         */
        tags: string[];

        /**
         * The url to the thumbnail used for the item. 
         */
        thumbnailUrl: string;

        /**
         * The title for the item. 
         */
        title: string;

        /**
         * The gis content type of this item. 
         */
        type: string;

        /**
         * A set of keywords that further describes the type of this item. 
         */
        typeKeywords: string[];

        /**
         * The url for the resource represented by the item. 
         */
        url: string;

        /**
         * The url to the user item. 
         */
        userItemUrl: string;

        /**
         * Add a comment to the item.
         * @param comment The text for the comment.
         */
        addComment(comment: string): any;

        /**
         * Add a rating to an item that you have access to.
         * @param rating Rating to set for the item.
         */
        addRating(rating: number): any;

        /**
         * Deletes an item comment.
         * @param comment The PortalComment to delete.
         */
        deleteComment(comment: PortalComment): any;

        /**
         * Delete a rating that you created for the specified item.
         * @param rating Rating to delete.
         */
        deleteRating(rating: PortalRating): any;

        /**
         * Get the comments associated with the item. 
         */
        getComments(): any;

        /**
         * Returns the rating (if any) given to the item. 
         */
        getRating(): any;

        /**
         * Updates an item comment.
         * @param comment A PortalComment that contains the comment updates.
         */
        updateComment(comment: PortalComment): any
    }

    /**
     * Details about the result of a query. 
     */
    declare     export class PortalQueryResult {

        /**
         * The query parameters for the next set of results. 
         */
        nextQueryParams: any;

        /**
         * The query parameters for the first set of results. 
         */
        queryParams: any;

        /**
         * An array of  result item objects. 
         */
        results: any[];

        /**
         * The total number of results. 
         */
        total: number
    }

    /**
     * Details about the rating associated with a Portal item. 
     */
    declare     export class PortalRating {

        /**
         * Date the rating was added to the item. 
         */
        created: Date;

        /**
         * A rating between 1.0 and 5.0 for the item. 
         */
        rating: number
    }

    /**
     * Represents a registered user of the Portal. 
     */
    declare     export class PortalUser {

        /**
         * The access level for the user: private, org or public. 
         */
        access: string;

        /**
         * The date the user was created. 
         */
        created: Date;

        /**
         * The default culture for the user. 
         */
        culture: string;

        /**
         * Description of the user. 
         */
        description: string;

        /**
         * The user's email address. 
         */
        email: string;

        /**
         * The user's full name. 
         */
        fullName: string;

        /**
         * The date the user was modified. 
         */
        modified: Date;

        /**
         * The id of the organization the user belongs to. 
         */
        orgId: string;

        /**
         * The portal. 
         */
        portal: Portal;

        /**
         * The user's preferred view for content, either Web or GIS. 
         */
        preferredView: string;

        /**
         * The user's preferred region, used to set the featured maps on the portal home page, content in the gallery and the default extent for new maps in the Viewer. 
         */
        region: string;

        /**
         * The user's role in the organization: administrator (org_admin), publisher (org_publisher), or user (org_user). 
         */
        role: string;

        /**
         * User-defined tags that describe the user. 
         */
        tags: string[];

        /**
         * The url to the thumbnail image for the user. 
         */
        thumbnailUrl: string;

        /**
         * The url for the user content. 
         */
        userContentUrl: string;

        /**
         * The username for the user. 
         */
        username: string;

        /**
         * Find folders for the portal user. 
         */
        getFolders(): any;

        /**
         * Provides access to the group invitations for the portal user. 
         */
        getGroupInvitations(): any;

        /**
         * Find all the groups that the portal user has permissions to access. 
         */
        getGroups(): any;

        /**
         * Get the portal item along with folder info for the input item id.
         * @param itemId The id of the item.
         */
        getItem(itemId: string): any;

        /**
         * Retrieve all the items in the specified folder.
         * @param folderId The id of the folder that contains the items to retrieve.
         */
        getItems(folderId?: string): any;

        /**
         * Get information about any notifications for the portal user. 
         */
        getNotifications(): any;

        /**
         * Access the tag objects that have been created by the portal user. 
         */
        getTags(): any
    }
}
declare module 'esri/arcgis/utils' {
    declare     var utils: {

        /**
         * Specify the domain where the map associated with the webmap id is located. 
         */
        arcgisUrl: string,

        /**
         * Create a map using information from an ArcGIS.com item.
         * @param itemIdOrItemInfo An itemId for an ArcGIS.com item or the response object obtained from calling the arcgisUtils.getItem method.
         * @param mapDiv Container ID for referencing map.
         * @param options Optional parameters that define the map functionality.
         */
        createMap(itemIdOrItemInfo: string | any, mapDiv: string, options?: any): any,

        /**
         * Get details about the input ArcGIS.com item.
         * @param itemId The itemId for a publicly shared ArcGIS.com item.
         */
        getItem(itemId: string): any,

        /**
         * Can be used with LayerList widget to get the layers list to be passed into the constructor.
         * @param createMapResponse The object created from the resolved promise returned by createMap().
         */
        getLayerList(createMapResponse: any): any[],

        /**
         * Can be used with esri.dijit.Legend to get the layerInfos list to be passed into the Legend constructor.
         * @param createMapResponse Object returned by .createMap() in the .then() callback.
         */
        getLegendLayers(createMapResponse: any): any[]
    };
    declare module.exports: typeof utils
}
declare module 'esri/basemaps' {
    declare     var basemaps: {

        /**
         * The Light Gray Canvas basemap is designed to be used as a neutral background map for overlaying and emphasizing other map layers. 
         */
        gray: any,

        /**
         * The World Imagery map is a detailed imagery map layer and labels that is designed to be used as a basemap for various maps and applications. 
         */
        hybrid: any,

        /**
         * The Ocean Basemap is designed to be used as a basemap by marine GIS professionals and as a reference map by anyone interested in ocean data. 
         */
        oceans: any,

        /**
         * The OpenStreetMap is a community map layer that is designed to be used as a basemap for various maps and applications. 
         */
        osm: any,

        /**
         * The World Imagery map is a detailed imagery map layer that is designed to be used as a basemap for various maps and applications. 
         */
        satellite: any,

        /**
         * The Streets basemap presents a multiscale street map for the world. 
         */
        streets: any,

        /**
         * The Terrain with Labels basemap is designed to be used to overlay and emphasize other thematic map layers. 
         */
        terrain: any,

        /**
         * The Topographic map includes boundaries, cities, water features, physiographic features, parks, landmarks, transportation, and buildings. 
         */
        topo: any
    };
    declare module.exports: typeof basemaps
}
declare module 'esri/config' {
    declare     var config: {

        /**
         * ArcGIS JavaScript API default configurations that can be overridden programmatically. 
         */
        defaults: any
    };
    declare module.exports: typeof config
}
declare module 'esri/dijit/AttributeInspector' {
    declare module.exports: typeof AttributeInspector
}
declare module 'esri/dijit/Attribution' {
    declare module.exports: typeof Attribution
}
declare module 'esri/dijit/Basemap' {
    declare module.exports: typeof Basemap
}
declare module 'esri/dijit/BasemapGallery' {
    declare module.exports: typeof BasemapGallery
}
declare module 'esri/dijit/BasemapLayer' {
    declare module.exports: typeof BasemapLayer
}
declare module 'esri/dijit/BasemapToggle' {
    declare module.exports: typeof BasemapToggle
}
declare module 'esri/dijit/BookmarkItem' {
    declare module.exports: typeof BookmarkItem
}
declare module 'esri/dijit/Bookmarks' {
    declare module.exports: typeof Bookmarks
}
declare module 'esri/dijit/ClassedColorSlider' {
    declare module.exports: typeof ClassedColorSlider
}
declare module 'esri/dijit/ClassedSizeSlider' {
    declare module.exports: typeof ClassedSizeSlider
}
declare module 'esri/dijit/ColorInfoSlider' {
    declare module.exports: typeof ColorInfoSlider
}
declare module 'esri/dijit/ColorPicker' {
    declare module.exports: typeof ColorPicker
}
declare module 'esri/dijit/Directions' {
    declare module.exports: typeof Directions
}
declare module 'esri/dijit/ElevationProfile' {
    declare module.exports: typeof ElevationProfile
}
declare module 'esri/dijit/FeatureTable' {
    declare module.exports: typeof FeatureTable
}
declare module 'esri/dijit/Gallery' {
    declare module.exports: typeof Gallery
}
declare module 'esri/dijit/Gauge' {
    declare module.exports: typeof Gauge
}
declare module 'esri/dijit/Geocoder' {
    declare module.exports: typeof Geocoder
}
declare module 'esri/dijit/HeatmapSlider' {
    declare module.exports: typeof HeatmapSlider
}
declare module 'esri/dijit/HistogramTimeSlider' {
    declare module.exports: typeof HistogramTimeSlider
}
declare module 'esri/dijit/HomeButton' {
    declare module.exports: typeof HomeButton
}
declare module 'esri/dijit/HorizontalSlider' {
    declare module.exports: typeof HorizontalSlider
}
declare module 'esri/dijit/ImageServiceMeasure' {
    declare module.exports: typeof ImageServiceMeasure
}
declare module 'esri/dijit/InfoWindow' {
    declare module.exports: typeof InfoWindow
}
declare module 'esri/dijit/InfoWindowLite' {
    declare module.exports: typeof InfoWindowLite
}
declare module 'esri/dijit/LayerList' {
    declare module.exports: typeof LayerList
}
declare module 'esri/dijit/LayerSwipe' {
    declare module.exports: typeof LayerSwipe
}
declare module 'esri/dijit/Legend' {
    declare module.exports: typeof Legend
}
declare module 'esri/dijit/LocateButton' {
    declare module.exports: typeof LocateButton
}
declare module 'esri/dijit/Measurement' {
    declare module.exports: typeof Measurement
}
declare module 'esri/dijit/ObliqueViewer' {
    declare module.exports: typeof ObliqueViewer
}
declare module 'esri/dijit/OpacitySlider' {
    declare module.exports: typeof OpacitySlider
}
declare module 'esri/dijit/OverviewMap' {
    declare module.exports: typeof OverviewMap
}
declare module 'esri/dijit/Popup' {
    declare module.exports: typeof Popup
}
declare module 'esri/dijit/PopupMobile' {
    declare module.exports: typeof PopupMobile
}
declare module 'esri/dijit/PopupTemplate' {
    declare module.exports: typeof PopupTemplate
}
declare module 'esri/dijit/Print' {
    declare module.exports: typeof Print
}
declare module 'esri/dijit/RendererSlider' {
    declare module.exports: typeof RendererSlider
}
declare module 'esri/dijit/Scalebar' {
    declare module.exports: typeof Scalebar
}
declare module 'esri/dijit/Search' {
    declare module.exports: typeof Search
}
declare module 'esri/dijit/SizeInfoSlider' {
    declare module.exports: typeof SizeInfoSlider
}
declare module 'esri/dijit/SymbolStyler' {
    declare module.exports: typeof SymbolStyler
}
declare module 'esri/dijit/TimeSlider' {
    declare module.exports: typeof TimeSlider
}
declare module 'esri/dijit/VisibleScaleRangeSlider' {
    declare module.exports: typeof VisibleScaleRangeSlider
}
declare module 'esri/dijit/analysis/AggregatePoints' {
    declare module.exports: typeof AggregatePoints
}
declare module 'esri/dijit/analysis/AnalysisBase' {
    declare module.exports: typeof AnalysisBase
}
declare module 'esri/dijit/analysis/CalculateDensity' {
    declare module.exports: typeof CalculateDensity
}
declare module 'esri/dijit/analysis/ChooseBestFacilities' {
    declare module.exports: typeof ChooseBestFacilities
}
declare module 'esri/dijit/analysis/ConnectOriginsToDestinations' {
    declare module.exports: typeof ConnectOriginsToDestinations
}
declare module 'esri/dijit/analysis/CreateBuffers' {
    declare module.exports: typeof CreateBuffers
}
declare module 'esri/dijit/analysis/CreateDriveTimeAreas' {
    declare module.exports: typeof CreateDriveTimeAreas
}
declare module 'esri/dijit/analysis/CreateViewshed' {
    declare module.exports: typeof CreateViewshed
}
declare module 'esri/dijit/analysis/CreateWatersheds' {
    declare module.exports: typeof CreateWatersheds
}
declare module 'esri/dijit/analysis/DeriveNewLocations' {
    declare module.exports: typeof DeriveNewLocations
}
declare module 'esri/dijit/analysis/DissolveBoundaries' {
    declare module.exports: typeof DissolveBoundaries
}
declare module 'esri/dijit/analysis/EnrichLayer' {
    declare module.exports: typeof EnrichLayer
}
declare module 'esri/dijit/analysis/ExtractData' {
    declare module.exports: typeof ExtractData
}
declare module 'esri/dijit/analysis/FindExistingLocations' {
    declare module.exports: typeof FindExistingLocations
}
declare module 'esri/dijit/analysis/FindHotSpots' {
    declare module.exports: typeof FindHotSpots
}
declare module 'esri/dijit/analysis/FindNearest' {
    declare module.exports: typeof FindNearest
}
declare module 'esri/dijit/analysis/FindSimilarLocations' {
    declare module.exports: typeof FindSimilarLocations
}
declare module 'esri/dijit/analysis/InterpolatePoints' {
    declare module.exports: typeof InterpolatePoints
}
declare module 'esri/dijit/analysis/MergeLayers' {
    declare module.exports: typeof MergeLayers
}
declare module 'esri/dijit/analysis/OverlayLayers' {
    declare module.exports: typeof OverlayLayers
}
declare module 'esri/dijit/analysis/PlanRoutes' {
    declare module.exports: typeof PlanRoutes
}
declare module 'esri/dijit/analysis/SummarizeNearby' {
    declare module.exports: typeof SummarizeNearby
}
declare module 'esri/dijit/analysis/SummarizeWithin' {
    declare module.exports: typeof SummarizeWithin
}
declare module 'esri/dijit/analysis/TraceDownstream' {
    declare module.exports: typeof TraceDownstream
}
declare module 'esri/dijit/editing/Add' {
    declare module.exports: typeof Add
}
declare module 'esri/dijit/editing/AttachmentEditor' {
    declare module.exports: typeof AttachmentEditor
}
declare module 'esri/dijit/editing/Cut' {
    declare module.exports: typeof Cut
}
declare module 'esri/dijit/editing/Delete' {
    declare module.exports: typeof Delete
}
declare module 'esri/dijit/editing/Editor' {
    declare module.exports: typeof Editor
}
declare module 'esri/dijit/editing/TemplatePicker' {
    declare module.exports: typeof TemplatePicker
}
declare module 'esri/dijit/editing/Union' {
    declare module.exports: typeof Union
}
declare module 'esri/dijit/editing/Update' {
    declare module.exports: typeof Update
}
declare module 'esri/dijit/geoenrichment/DataBrowser' {
    declare module.exports: typeof DataBrowser
}
declare module 'esri/dijit/geoenrichment/Infographic' {
    declare module.exports: typeof Infographic
}
declare module 'esri/dijit/geoenrichment/InfographicsCarousel' {
    declare module.exports: typeof InfographicsCarousel
}
declare module 'esri/dijit/geoenrichment/InfographicsOptions' {
    declare module.exports: typeof InfographicsOptions
}
declare module 'esri/dijit/geoenrichment/InfographicsOptionsItem' {
    declare module.exports: typeof InfographicsOptionsItem
}
declare module 'esri/dijit/util/busyIndicator' {
    declare     var busyIndicator: {

        /**
         * Creates a busy indicator on a target.
         * @param target The String (Node id, dijit/_WidgetBase id), HTMLElement reference (Node), or dijit/_WidgetBase.
         * @param params (Optional) The params options can be used when needing more fine-grained control.
         */
        create(target: string | HTMLElement | any, params?: any): any
    };
    declare module.exports: typeof busyIndicator
}
declare module 'esri/domUtils' {
    declare     var domUtils: {

        /**
         * Represents the size of the client side window or document at first load. 
         */
        documentBox: any,

        /**
         * Returns the DOM node from HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase to retrieve.
         */
        getNode(target: HTMLElement | any): Node,

        /**
         * Hides the HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        hide(target: HTMLElement | any): void,

        /**
         * Shows the HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        show(target: HTMLElement | any): void,

        /**
         * If the target (HTMLElement or dijit/_WidgetBase) is currently visible, the target is hidden.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        toggle(target: HTMLElement | any): void
    };
    declare module.exports: typeof domUtils
}
declare module 'esri/geometry/Circle' {
    declare module.exports: typeof Circle
}
declare module 'esri/geometry/Extent' {
    declare module.exports: typeof Extent
}
declare module 'esri/geometry/Geometry' {
    declare module.exports: typeof Geometry
}
declare module 'esri/geometry/Multipoint' {
    declare module.exports: typeof Multipoint
}
declare module 'esri/geometry/Point' {
    declare module.exports: typeof Point
}
declare module 'esri/geometry/Polygon' {
    declare module.exports: typeof Polygon
}
declare module 'esri/geometry/Polyline' {
    declare module.exports: typeof Polyline
}
declare module 'esri/geometry/ScreenPoint' {
    declare module.exports: typeof ScreenPoint
}
declare module 'esri/geometry/geodesicUtils' {
    declare     var geodesicUtils: {

        /**
         * Determine the area for the input polygons.
         * @param polygons An array of polygons.
         * @param areaUnit The area unit.
         */
        geodesicAreas(polygons: Polygon[], areaUnit: string): number[],

        /**
         * Returns a densified geometry.
         * @param geometry A polyline or polygon to densify.
         * @param maxSegmentLength The maximum segment length in meters.
         */
        geodesicDensify(geometry: Geometry, maxSegmentLength: number): Geometry,

        /**
         * Determine the length for the input polylines using the specified length unit.
         * @param polylines An array of polylines.
         * @param lengthUnit The length unit.
         */
        geodesicLengths(polylines: Polyline[], lengthUnit: string): number[]
    };
    declare module.exports: typeof geodesicUtils
}
declare module 'esri/geometry/geometryEngine' {
    declare     var geometryEngine: {

        /**
         * Creates planar (or Euclidean) buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        buffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): Polygon | Polygon[],

        /**
         * Calculates the clipped geometry from a target geometry by an envelope.
         * @param geometry The geometry to be clipped.
         * @param envelope The envelope used to clip.
         */
        clip(geometry: Geometry, envelope: Extent): Geometry,

        /**
         * Indicates if one geometry contains another geometry.
         * @param geometry1 The geometry that is tested for the contains relationship to the other geometry.
         * @param geometry2 The geometry that is tested for within relationship to the other geometry.
         */
        contains(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the convex hull of the input geometry.
         * @param geometry The input geometry.
         * @param merge Whether to merge output geometries.
         */
        convexHull(geometry: Geometry | Geometry[], merge?: boolean): Geometry | Geometry[],

        /**
         * Indicates if one geometry crosses another geometry.
         * @param geometry1 The geometry to cross.
         * @param geometry2 The geometry being crossed.
         */
        crosses(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Split the input Polyline or Polygon where it crosses a cutting Polyline.
         * @param geometry The geometry to be cut.
         * @param cutter The polyline to cut the geometry.
         */
        cut(geometry: Geometry, cutter: Polyline): Geometry[],

        /**
         * Densify geometries by plotting points between existing vertices.
         * @param geometry The geometry to be densified.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        densify(
            geometry: Geometry,
            maxSegmentLength: number,
            maxSegmentLengthUnit: string | number): Geometry,

        /**
         * Creates the difference of two geometries.
         * @param inputGeometry The input geometry to subtract from.
         * @param subtractor The geometry being subtracted from inputGeometry.
         */
        difference(
            inputGeometry: Geometry | Geometry[],
            subtractor: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry is disjoint (doesn't intersect in any way) with another geometry.
         * @param geometry1 The base geometry that is tested for the "disjoint" relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the disjoint relationship to the other geometry.
         */
        disjoint(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the shortest planar distance between two geometries.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         * @param distanceUnit Measurement unit of the return value.
         */
        distance(
            geometry1: Geometry,
            geometry2: Geometry,
            distanceUnit: string | number): number,

        /**
         * Indicates if two geometries are equal.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         */
        equals(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Returns an object containing additional information about the input spatial reference.
         * @param spatialReference The spatial Reference.
         */
        extendedSpatialReferenceInfo(spatialReference: SpatialReference): any,

        /**
         * Flips a geometry on the horizontal axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipHorizontal(geometry: Geometry, flipOrigin?: Point): Geometry,

        /**
         * Flips a geometry on the vertical axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipVertical(geometry: Geometry, flipOrigin?: Point): Geometry,

        /**
         * Performs the generalize operation on the geometries in the cursor.
         * @param geometry The geometry to be generalized.
         * @param maxDeviation The maximum allowed deviation from the generalized geometry to the original geometry.
         * @param removeDegenerateParts When true, the degenerate parts of the geometry will be removed from the output (may be undesired for drawing).
         * @param maxDeviationUnit Measurement unit for maxDeviation.
         */
        generalize(
            geometry: Geometry,
            maxDeviation: number,
            removeDegenerateParts?: boolean,
            maxDeviationUnit?: string | number): Geometry,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicArea(geometry: Geometry, unit: string | number): number,

        /**
         * Creates geodesic buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        geodesicBuffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): Polygon | Polygon[],

        /**
         * Returns a geodesically densified version of the input geometry.
         * @param geometry A polyline or polygon geometry to densify.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        geodesicDensify(
            geometry: Polyline | Polygon,
            maxSegmentLength: number,
            maxSegmentLengthUnit?: number): Geometry,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicLength(geometry: Geometry, unit: string | number): number,

        /**
         * Creates a new geometry through intersection between two geometries.
         * @param geometry The input geometry.
         * @param intersector The geometry being intersected.
         */
        intersect(geometry: Geometry | Geometry[], intersector: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry intersects another geometry.
         * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
         * @param geometry2 The geometry being intersected.
         */
        intersects(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Indicates if the given geometry is topologically simple.
         * @param geometry Geometry
         */
        isSimple(geometry: Geometry): boolean,

        /**
         * Finds the coordinate of the geometry which is closest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest coordinate in the geometry.
         */
        nearestCoordinate(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds vertex on the geometry nearest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest vertex in the geometry.
         */
        nearestVertex(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds all vertices in the given distance from the specified point, sorted from the closest to the furthest and returns them as an array of objects.
         * @param geometry The geometry to consider.
         * @param inputPoint The point from which to measure.
         * @param searchRadius The search radius.
         * @param maxVertexCountToReturn The maximum number number of vertices to return.
         */
        nearestVertices(
            geometry: Geometry,
            inputPoint: Point,
            searchRadius: number,
            maxVertexCountToReturn: number): any[],

        /**
         * Creates offset version of the input geometry.
         * @param geometry The geometries to offset.
         * @param offsetDistance The offset distance for the Geometries.
         * @param offsetUnit Measurement unit for the offset.
         * @param joinType The join type.
         * @param bevelRatio Applicable to MITER, bevelRatio is multiplied by the offset distance and the result determines how far a mitered offset intersection can be located before it is beveled.
         * @param flattenError Applicable to ROUND, flattenError determines the maximum distance of the resulting segments compared to the true circular arc.
         */
        offset(
            geometry: Geometry | Geometry[],
            offsetDistance: number,
            offsetUnit: string | number,
            joinType: string,
            bevelRatio?: number,
            flattenError?: number): Geometry | Geometry[],

        /**
         * Indicates if one geometry  overlaps another geometry.
         * @param geometry1 The base geometry that is tested for overlaps relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the overlaps relationship to the other geometry.
         */
        overlaps(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarArea(geometry: Geometry, unit: string | number): number,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarLength(geometry: Geometry, unit: string | number): number,

        /**
         * Indicates if the given DE-9IM relation holds for the two geometries.
         * @param geometry1 The first geometry for the relation.
         * @param geometry2 The second geometry for the relation.
         * @param relation The Dimensionally Extended 9 Intersection Model (DE-9IM) matrix relation (encoded as a string) to test against the relationship of the two geometries.
         */
        relate(geometry1: Geometry, geometry2: Geometry, relation: string): boolean,

        /**
         * Rotates a geometry by a specified angle.
         * @param geometry The input geometry.
         * @param angle The rotation angle
         * @param rotationOrigin Point to rotate the geometry around.
         */
        rotate(geometry: Geometry, angle: number, rotationOrigin?: Point): Geometry,

        /**
         * Performs the simplify operation on the geometry which alters the given geometries to make their definitions topologically legal with respect to their geometry type.
         * @param geometry The geometry to be simplified.
         */
        simplify(geometry: Geometry): Geometry,

        /**
         * Creates the symmetric difference of two geometries.
         * @param leftGeometry One of the Geometry instances in the XOR operation.
         * @param rightGeometry One of the Geometry instances in the XOR operation.
         */
        symmetricDifference(
            leftGeometry: Geometry | Geometry[],
            rightGeometry: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry touches another geometry.
         * @param geometry1 The geometry which may be touching another geometry.
         * @param geometry2 The geometry to be touched.
         */
        touches(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * All inputs must be of the same type of geometries and share one spatial reference.
         * @param geometries The geometries to union.
         */
        union(geometries: Geometry[]): Geometry,

        /**
         * Indicates if one geometry is within another geometry.
         * @param geometry1 The base geometry that is tested for within relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the contains relationship to the other geometry.
         */
        within(geometry1: Geometry, geometry2: Geometry): boolean
    };
    declare module.exports: typeof geometryEngine
}
declare module 'esri/geometry/geometryEngineAsync' {
    declare     var geometryEngineAsync: {

        /**
         * Creates planar (or Euclidean) buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        buffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): any,

        /**
         * Calculates the clipped geometry from a target geometry by an envelope.
         * @param geometry The geometry to be clipped.
         * @param envelope The envelope used to clip.
         */
        clip(geometry: Geometry, envelope: Extent): any,

        /**
         * Indicates if one geometry contains another geometry.
         * @param geometry1 The geometry that is tested for the contains relationship to the other geometry.
         * @param geometry2 The geometry that is tested for within relationship to the other geometry.
         */
        contains(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the convex hull of the input geometry.
         * @param geometry The input geometry.
         * @param merge Whether to merge output geometries.
         */
        convexHull(geometry: Geometry | Geometry[], merge?: boolean): any,

        /**
         * Indicates if one geometry crosses another geometry.
         * @param geometry1 The geometry to cross.
         * @param geometry2 The geometry being crossed.
         */
        crosses(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Split the input polyline or polygon where it crosses a cutting polyline.
         * @param geometry The geometry to be cut.
         * @param cutter The polyline to cut the geometry.
         */
        cut(geometry: Geometry, cutter: Polyline): any,

        /**
         * Densify geometries by plotting points between existing vertices.
         * @param geometry The geometry to be densified.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        densify(
            geometry: Geometry,
            maxSegmentLength: number,
            maxSegmentLengthUnit: string | number): any,

        /**
         * Creates the difference of two geometries.
         * @param inputGeometry The input geometry to subtract from.
         * @param subtractor The geometry being subtracted.
         */
        difference(inputGeometry: Geometry | Geometry[], subtractor: Geometry): any,

        /**
         * Indicates if one geometry is disjoint (doesn't intersect in any way) with another geometry.
         * @param geometry1 The base geometry that is tested for the "disjoint" relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the disjoint relationship to the other geometry.
         */
        disjoint(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the shortest planar distance between two geometries.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         * @param distanceUnit Measurement unit of the return value.
         */
        distance(geometry1: Geometry, geometry2: Geometry, distanceUnit: string | number): any,

        /**
         * Indicates if two geometries are equal.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         */
        equals(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Returns an object containing additional information about the input spatial reference.
         * @param spatialReference The input spatial reference.
         */
        extendedSpatialReferenceInfo(spatialReference: SpatialReference): any,

        /**
         * Flips a geometry on the horizontal axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipHorizontal(geometry: Geometry, flipOrigin?: Point): any,

        /**
         * Flips a geometry on the vertical axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipVertical(geometry: Geometry, flipOrigin?: Point): any,

        /**
         * Performs the generalize operation on the geometries in the cursor.
         * @param geometry The geometry to be generalized.
         * @param maxDeviation The maximum allowed deviation from the generalized geometry to the original geometry.
         * @param removeDegenerateParts When true, the degenerate parts of the geometry will be removed from the output (may be undesired for drawing).
         * @param maxDeviationUnit Measurement unit for maxDeviation.
         */
        generalize(
            geometry: Geometry,
            maxDeviation: number,
            removeDegenerateParts?: boolean,
            maxDeviationUnit?: string | number): any,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicArea(geometry: Geometry, unit: string | number): any,

        /**
         * Creates geodesic buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        geodesicBuffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): any,

        /**
         * Resolves to a geodesically densified version of the input geometry.
         * @param geometry A polyline or polygon geometry to densify.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        geodesicDensify(
            geometry: Polyline | Polygon,
            maxSegmentLength: number,
            maxSegmentLengthUnit?: number): any,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicLength(geometry: Geometry, unit: string | number): any,

        /**
         * Creates a new geometry through intersection between two geometries.
         * @param geometry The input geometry.
         * @param intersector The geometry being intersected.
         */
        intersect(geometry: Geometry | Geometry[], intersector: Geometry): any,

        /**
         * Indicates if one geometry intersects another geometry.
         * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
         * @param geometry2 The geometry being intersected.
         */
        intersects(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Indicates if the given geometry is topologically simple.
         * @param geometry Geometry
         */
        isSimple(geometry: Geometry): any,

        /**
         * Finds the coordinate of the geometry which is closest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest coordinate in the geometry.
         */
        nearestCoordinate(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds vertex on the geometry nearest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest vertex in the geometry.
         */
        nearestVertex(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds all vertices in the given distance from the specified point, sorted from the closest to the furthest and returns them as an array of objects once resolved.
         * @param geometry The geometry to consider.
         * @param inputPoint The point from which to measure.
         * @param searchRadius The search radius.
         * @param maxVertexCountToReturn The maximum number number of vertices to return.
         */
        nearestVertices(
            geometry: Geometry,
            inputPoint: Point,
            searchRadius: number,
            maxVertexCountToReturn: number): any,

        /**
         * Creates offset version of the input geometry.
         * @param geometry The geometries to offset.
         * @param offsetDistance The offset distance for the Geometries.
         * @param offsetUnit Measurement unit for the offset.
         * @param joinType The join type.
         * @param bevelRatio Applicable to MITER, bevelRatio is multiplied by the offset distance and the result determines how far a mitered offset intersection can be located before it is beveled.
         * @param flattenError Applicable to ROUND, flattenError determines the maximum distance of the resulting segments compared to the true circular arc.
         */
        offset(
            geometry: Geometry | Geometry[],
            offsetDistance: number,
            offsetUnit: string | number,
            joinType: string,
            bevelRatio?: number,
            flattenError?: number): any,

        /**
         * Indicates if one geometry  overlaps another geometry.
         * @param geometry1 The base geometry that is tested for overlaps relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the overlaps relationship to the other geometry.
         */
        overlaps(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarArea(geometry: Geometry, unit: string | number): any,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarLength(geometry: Geometry, unit: string | number): any,

        /**
         * Indicates if the given DE-9IM relation holds for the two geometries.
         * @param geometry1 The first geometry for the relation.
         * @param geometry2 The second geometry for the relation.
         * @param relation The Dimensionally Extended 9 Intersection Model (DE-9IM) matrix relation (encoded as a string) to test against the relationship of the two geometries.
         */
        relate(geometry1: Geometry, geometry2: Geometry, relation: string): any,

        /**
         * Rotates a geometry by a specified angle.
         * @param geometry The input geometry.
         * @param angle The rotation angle
         * @param rotationOrigin Point to rotate the geometry around.
         */
        rotate(geometry: Geometry, angle: number, rotationOrigin?: Point): any,

        /**
         * Performs the simplify operation on the geometry which alters the given geometries to make their definitions topologically legal with respect to their geometry type.
         * @param geometry The geometry to be simplified.
         */
        simplify(geometry: Geometry): any,

        /**
         * Creates the symmetric difference of two geometries.
         * @param leftGeometry One of the Geometry instances in the XOR operation.
         * @param rightGeometry One of the Geometry instances in the XOR operation.
         */
        symmetricDifference(leftGeometry: Geometry | Geometry[], rightGeometry: Geometry): any,

        /**
         * Indicates if one geometry touches another geometry.
         * @param geometry1 The geometry which may be touching another geometry.
         * @param geometry2 The geometry to be touched.
         */
        touches(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * All inputs must be of the same type of geometries and share one spatial reference.
         * @param geometries The geometries to union.
         */
        union(geometries: Geometry[]): any,

        /**
         * Indicates if one geometry is within another geometry.
         * @param geometry1 The base geometry that is tested for within relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the contains relationship to the other geometry.
         */
        within(geometry1: Geometry, geometry2: Geometry): any
    };
    declare module.exports: typeof geometryEngineAsync
}
declare module 'esri/geometry/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts the input JSON object to the appropriate esri.geometry. object.
         * @param json The JSON object.
         */
        fromJson(json: Object): Geometry,

        /**
         * Requests the geometry type name as represented in the ArcGIS REST.
         * @param geometry The ArcGIS JavaScript API geometry type to be converted.
         */
        getJsonType(geometry: Geometry): string
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/geometry/mathUtils' {
    declare     var mathUtils: {

        /**
         * Calculates the length of a line based on the input of two points.
         * @param point1 The beginning point.
         * @param point2 The ending point.
         */
        getLength(point1: Point, point2: Point): number,

        /**
         * Calculates the intersecting point of two lines.
         * @param line1start The beginning point of the first line.
         * @param line1end The ending point of the first line.
         * @param line2start The beginning point of the second line.
         * @param line2end The ending point of the second line.
         */
        getLineIntersection(line1start: Point, line1end: Point, line2start: Point, line2end: Point): Point
    };
    declare module.exports: typeof mathUtils
}
declare module 'esri/geometry/normalizeUtils' {
    declare     var normalizeUtils: {

        /**
         * Normalizes  geometries that intersect the central meridian or fall outside the world extent so they stay within the current coordinate system.
         * @param geometries An array of geometries to normalize.
         * @param geometryService Specify a valid geometry service.
         * @param callback The function to call when the method has completed.
         * @param errback An error object is returned, if an error occurs on the Server during task execution.
         */
        normalizeCentralMeridian(
            geometries: Geometry[],
            geometryService?: GeometryService,
            callback?: Function,
            errback?: Function): any
    };
    declare module.exports: typeof normalizeUtils
}
declare module 'esri/geometry/scaleUtils' {
    declare     var scaleUtils: {

        /**
         * Get the extent for the specified scale.
         * @param map The input map.
         * @param scale The input scale.
         */
        getExtentForScale(map: Map, scale: number): Extent,

        /**
         * Gets the current scale of the map.
         * @param map The map whose scale should be calculated.
         */
        getScale(map: Map): number,

        /**
         * Returns the value of one map unit for the given spatial reference (in meters).
         * @param sr The spatial reference represented as a SpatialReference class, Number, or String.
         */
        getUnitValueForSR(sr: SpatialReference | number | string): number
    };
    declare module.exports: typeof scaleUtils
}
declare module 'esri/geometry/screenUtils' {
    declare     var screenUtils: {

        /**
         * Converts the geometry argument to map coordinates based on the extent, width, and height of the Map.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param screenGeometry The geometry to convert from screen to map units.
         */
        toMapGeometry(
            extent: Extent,
            width: number,
            height: number,
            screenGeometry: Geometry): Geometry,

        /**
         * Converts and returns the argument screen point in map coordinates.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param screenPoint The screenPoint to convert from screen to map units.
         */
        toMapPoint(extent: Extent, width: number, height: number, screenPoint: ScreenPoint): Point,

        /**
         * Converts the geometry argument to screen coordinates based on the extent, width, and height of the Map.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param mapGeometry The geometry to convert from map to screen units.
         */
        toScreenGeometry(extent: Extent, width: number, height: number, mapGeometry: Geometry): Geometry,

        /**
         * Converts and returns the argument map point in screen coordinates.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param mapPoint The point to convert from map to screen units.
         */
        toScreenPoint(extent: Extent, width: number, height: number, mapPoint: Point): ScreenPoint
    };
    declare module.exports: typeof screenUtils
}
declare module 'esri/geometry/webMercatorUtils' {
    declare     var webMercatorUtils: {

        /**
         * Returns true if the 'source' can be projected to 'target' by the project() function, or if the 'source' and 'target' is the same spatialReference.
         * @param source An input of type SpatialReference or an object with spatialReference property such as Geometry or Map.
         * @param target The target spatial reference, of type SpatialReference or an object with spatialReference property such as Map.
         */
        canProject(source: SpatialReference | any, target: SpatialReference | any): boolean,

        /**
         * Converts geometry from geographic units to Web Mercator units.
         * @param geometry The geometry to convert.
         */
        geographicToWebMercator(geometry: Geometry): Geometry,

        /**
         * Translates the given latitude and longitude values to Web Mercator.
         * @param long The longitude value to convert.
         * @param lat The latitude value to convert.
         */
        lngLatToXY(long: number, lat: number): number[],

        /**
         * Project the geometry clientside (if possible).
         * @param geometry An input geometry.
         * @param target The target spatial reference, of type SpatialReference or an object with spatialReference property such as Map.
         */
        project(geometry: Geometry, target: SpatialReference | any): any,

        /**
         * Converts geometry from Web Mercator units to geographic units.
         * @param geometry The geometry to convert.
         * @param isLinear Indicates whether to work with linear values, i.e., do not normalize.
         */
        webMercatorToGeographic(geometry: Geometry, isLinear?: boolean): Geometry,

        /**
         * Translates the given Web Mercator coordinates to Longitude and Latitude.
         * @param x The x coordinate value to convert.
         * @param y The y coordinate value to convert.
         */
        xyToLngLat(x: number, y: number): number[]
    };
    declare module.exports: typeof webMercatorUtils
}
declare module 'esri/graphic' {
    declare module.exports: typeof Graphic
}
declare module 'esri/graphicsUtils' {
    declare     var graphicsUtils: {

        /**
         * Converts an array of graphics to an array of geometries.
         * @param graphics Array of graphics to convert to geometries
         */
        getGeometries(graphics: Graphic[]): Geometry[],

        /**
         * Utility function that returns the extent of an array of graphics.
         * @param graphics The input graphics array.
         */
        graphicsExtent(graphics: Graphic[]): Extent
    };
    declare module.exports: typeof graphicsUtils
}
declare module 'esri/kernel' {
    declare     var kernel: {

        /**
         * Current version of the JavaScript API. 
         */
        version: string
    };
    declare module.exports: typeof kernel
}
declare module 'esri/lang' {
    declare     var lang: {

        /**
         * Creates a new object with all properties that pass the test implemented by the filter provided in the function.
         * @param object Object  to filter.
         * @param callback Function or string implementing the filtering.
         * @param thisObject Optional object used to scope the call to the callback.
         */
        filter(object: any, callback: Function, thisObject: any): any,

        /**
         * Returns true when the value is neither null or undefined.
         * @param value The value to test.
         */
        isDefined(value: any): boolean,

        /**
         * Strips HTML tags from a String or Object.
         * @param value Object or String to be stripped of HTML tags.
         */
        stripTags(value: any | string): any | string,

        /**
         * A wrapper around dojo.string.substitute that can also handle wildcard substitution.
         * @param data The data object used in the substitution.
         * @param template The template used for the substitution.
         * @param first When true, returns only the first property found in the data object.
         */
        substitute(data: any, template?: string, first?: boolean): string,

        /**
         * Iterates through the argument array and searches for the identifier to which the argument value matches.
         * @param array The argument array for testing.
         * @param value The value used in the search.
         */
        valueOf(array: any[], value: any): any
    };
    declare module.exports: typeof lang
}
declare module 'esri/layers/ArcGISDynamicMapServiceLayer' {
    declare module.exports: typeof ArcGISDynamicMapServiceLayer
}
declare module 'esri/layers/ArcGISImageServiceLayer' {
    declare module.exports: typeof ArcGISImageServiceLayer
}
declare module 'esri/layers/ArcGISImageServiceVectorLayer' {
    declare module.exports: typeof ArcGISImageServiceVectorLayer
}
declare module 'esri/layers/ArcGISTiledMapServiceLayer' {
    declare module.exports: typeof ArcGISTiledMapServiceLayer
}
declare module 'esri/layers/CSVLayer' {
    declare module.exports: typeof CSVLayer
}
declare module 'esri/layers/CodedValueDomain' {
    declare module.exports: typeof CodedValueDomain
}
declare module 'esri/layers/DataAdapterFeatureLayer' {
    declare module.exports: typeof DataAdapterFeatureLayer
}
declare module 'esri/layers/DataSource' {
    declare module.exports: typeof DataSource
}
declare module 'esri/layers/DimensionalDefinition' {
    declare module.exports: typeof DimensionalDefinition
}
declare module 'esri/layers/Domain' {
    declare module.exports: typeof Domain
}
declare module 'esri/layers/DynamicLayerInfo' {
    declare module.exports: typeof DynamicLayerInfo
}
declare module 'esri/layers/DynamicMapServiceLayer' {
    declare module.exports: typeof DynamicMapServiceLayer
}
declare module 'esri/layers/FeatureEditResult' {
    declare module.exports: typeof FeatureEditResult
}
declare module 'esri/layers/FeatureLayer' {
    declare module.exports: typeof FeatureLayer
}
declare module 'esri/layers/FeatureTemplate' {
    declare module.exports: typeof FeatureTemplate
}
declare module 'esri/layers/FeatureType' {
    declare module.exports: typeof FeatureType
}
declare module 'esri/layers/Field' {
    declare module.exports: typeof Field
}
declare module 'esri/layers/GeoRSSLayer' {
    declare module.exports: typeof GeoRSSLayer
}
declare module 'esri/layers/GraphicsLayer' {
    declare module.exports: typeof GraphicsLayer
}
declare module 'esri/layers/ImageParameters' {
    declare module.exports: typeof ImageParameters
}
declare module 'esri/layers/ImageServiceParameters' {
    declare module.exports: typeof ImageServiceParameters
}
declare module 'esri/layers/InheritedDomain' {
    declare module.exports: typeof InheritedDomain
}
declare module 'esri/layers/JoinDataSource' {
    declare module.exports: typeof JoinDataSource
}
declare module 'esri/layers/KMLFolder' {
    declare module.exports: typeof KMLFolder
}
declare module 'esri/layers/KMLGroundOverlay' {
    declare module.exports: typeof KMLGroundOverlay
}
declare module 'esri/layers/KMLLayer' {
    declare module.exports: typeof KMLLayer
}
declare module 'esri/layers/LOD' {
    declare module.exports: typeof LOD
}
declare module 'esri/layers/LabelClass' {
    declare module.exports: typeof LabelClass
}
declare module 'esri/layers/LabelLayer' {
    declare module.exports: typeof LabelLayer
}
declare module 'esri/layers/LayerDataSource' {
    declare module.exports: typeof LayerDataSource
}
declare module 'esri/layers/LayerDrawingOptions' {
    declare module.exports: typeof LayerDrawingOptions
}
declare module 'esri/layers/LayerInfo' {
    declare module.exports: typeof LayerInfo
}
declare module 'esri/layers/LayerMapSource' {
    declare module.exports: typeof LayerMapSource
}
declare module 'esri/layers/LayerSource' {
    declare module.exports: typeof LayerSource
}
declare module 'esri/layers/LayerTimeOptions' {
    declare module.exports: typeof LayerTimeOptions
}
declare module 'esri/layers/MapImage' {
    declare module.exports: typeof MapImage
}
declare module 'esri/layers/MapImageLayer' {
    declare module.exports: typeof MapImageLayer
}
declare module 'esri/layers/MosaicRule' {
    declare module.exports: typeof MosaicRule
}
declare module 'esri/layers/OpenStreetMapLayer' {
    declare module.exports: typeof OpenStreetMapLayer
}
declare module 'esri/layers/PixelBlock' {
    declare module.exports: typeof PixelBlock
}
declare module 'esri/layers/QueryDataSource' {
    declare module.exports: typeof QueryDataSource
}
declare module 'esri/layers/RangeDomain' {
    declare module.exports: typeof RangeDomain
}
declare module 'esri/layers/RasterDataSource' {
    declare module.exports: typeof RasterDataSource
}
declare module 'esri/layers/RasterFunction' {
    declare module.exports: typeof RasterFunction
}
declare module 'esri/layers/RasterLayer' {
    declare module.exports: typeof RasterLayer
}
declare module 'esri/layers/StreamLayer' {
    declare module.exports: typeof StreamLayer
}
declare module 'esri/layers/TableDataSource' {
    declare module.exports: typeof TableDataSource
}
declare module 'esri/layers/TileInfo' {
    declare module.exports: typeof TileInfo
}
declare module 'esri/layers/TiledMapServiceLayer' {
    declare module.exports: typeof TiledMapServiceLayer
}
declare module 'esri/layers/TimeInfo' {
    declare module.exports: typeof TimeInfo
}
declare module 'esri/layers/TimeReference' {
    declare module.exports: typeof TimeReference
}
declare module 'esri/layers/VectorTileLayer' {
    declare module.exports: typeof VectorTileLayer
}
declare module 'esri/layers/WCSConnection' {
    declare module.exports: typeof WCSConnection
}
declare module 'esri/layers/WCSCoverageDescription' {
    declare module.exports: typeof WCSCoverageDescription
}
declare module 'esri/layers/WCSLayer' {
    declare module.exports: typeof WCSLayer
}
declare module 'esri/layers/WFSLayer' {
    declare module.exports: typeof WFSLayer
}
declare module 'esri/layers/WMSLayer' {
    declare module.exports: typeof WMSLayer
}
declare module 'esri/layers/WMSLayerInfo' {
    declare module.exports: typeof WMSLayerInfo
}
declare module 'esri/layers/WMTSLayer' {
    declare module.exports: typeof WMTSLayer
}
declare module 'esri/layers/WMTSLayerInfo' {
    declare module.exports: typeof WMTSLayerInfo
}
declare module 'esri/layers/WebTiledLayer' {
    declare module.exports: typeof WebTiledLayer
}
declare module 'esri/layers/layer' {
    declare module.exports: typeof Layer
}
declare module 'esri/layers/pixelfilters/StretchFilter' {
    declare module.exports: typeof StretchFilter
}
declare module 'esri/map' {
    declare module.exports: typeof Map
}
declare module 'esri/opsdashboard/DataSourceProxy' {
    declare module.exports: typeof DataSourceProxy
}
declare module 'esri/opsdashboard/ExtensionBase' {
    declare module.exports: typeof ExtensionBase
}
declare module 'esri/opsdashboard/ExtensionConfigurationBase' {
    declare module.exports: typeof ExtensionConfigurationBase
}
declare module 'esri/opsdashboard/FeatureActionConfigurationProxy' {
    declare module.exports: typeof FeatureActionConfigurationProxy
}
declare module 'esri/opsdashboard/FeatureActionFeatures' {
    declare module.exports: typeof FeatureActionFeatures
}
declare module 'esri/opsdashboard/GraphicsLayerProxy' {
    declare module.exports: typeof GraphicsLayerProxy
}
declare module 'esri/opsdashboard/MapToolConfigurationProxy' {
    declare module.exports: typeof MapToolConfigurationProxy
}
declare module 'esri/opsdashboard/MapToolProxy' {
    declare module.exports: typeof MapToolProxy
}
declare module 'esri/opsdashboard/MapWidgetProxy' {
    declare module.exports: typeof MapWidgetProxy
}
declare module 'esri/opsdashboard/WidgetConfigurationProxy' {
    declare module.exports: typeof WidgetConfigurationProxy
}
declare module 'esri/opsdashboard/WidgetProxy' {
    declare module.exports: typeof WidgetProxy
}
declare module 'esri/opsdashboard/featureActionProxy' {
    declare module.exports: typeof featureActionProxy
}
declare module 'esri/plugins/FeatureLayerStatistics' {
    declare module.exports: typeof FeatureLayerStatistics
}
declare module 'esri/plugins/spatialIndex' {
    declare     var spatialIndex: {

        /**
         * Adds an index property to the target instance.
         * @param target The map or feature layer to which the index is connected.
         * @param options See the object specifications table below for the structure of the index  options  object.
         */
        add(target: Map | FeatureLayer, options?: any): void,

        /**
         * Removes the index plugin. 
         */
        remove(): void
    };
    declare module.exports: typeof spatialIndex
}
declare module 'esri/process/Processor' {
    declare module.exports: typeof Processor
}
declare module 'esri/process/SpatialIndex' {
    declare module.exports: typeof SpatialIndex
}
declare module 'esri/renderers/BlendRenderer' {
    declare module.exports: typeof BlendRenderer
}
declare module 'esri/renderers/ClassBreaksRenderer' {
    declare module.exports: typeof ClassBreaksRenderer
}
declare module 'esri/renderers/DotDensityRenderer' {
    declare module.exports: typeof DotDensityRenderer
}
declare module 'esri/renderers/HeatmapRenderer' {
    declare module.exports: typeof HeatmapRenderer
}
declare module 'esri/renderers/Renderer' {
    declare module.exports: typeof Renderer
}
declare module 'esri/renderers/ScaleDependentRenderer' {
    declare module.exports: typeof ScaleDependentRenderer
}
declare module 'esri/renderers/SimpleRenderer' {
    declare module.exports: typeof SimpleRenderer
}
declare module 'esri/renderers/SymbolAger' {
    declare module.exports: typeof SymbolAger
}
declare module 'esri/renderers/TemporalRenderer' {
    declare module.exports: typeof TemporalRenderer
}
declare module 'esri/renderers/TimeClassBreaksAger' {
    declare module.exports: typeof TimeClassBreaksAger
}
declare module 'esri/renderers/TimeRampAger' {
    declare module.exports: typeof TimeRampAger
}
declare module 'esri/renderers/UniqueValueRenderer' {
    declare module.exports: typeof UniqueValueRenderer
}
declare module 'esri/renderers/VectorFieldRenderer' {
    declare module.exports: typeof VectorFieldRenderer
}
declare module 'esri/renderers/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts the input JSON object to the appropriate esri.renderer. object.
         * @param json The JSON object.
         */
        fromJson(json: Object): Renderer
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/renderers/smartMapping' {
    declare     var smartMapping: {

        /**
         * Creates a renderer for visualizing features using colors.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createClassedColorRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features by varying their size.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createClassedSizeRenderer(params: any): any,

        /**
         * Creates an object defining a color ramp used to render a layer.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createColorInfo(params: any): any,

        /**
         * Creates a renderer for visualizing features using colors.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createColorRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features using heatmap.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createHeatmapRenderer(params: any): any,

        /**
         * Creates an object that describes how opacity of features is calculated.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createOpacityInfo(params: any): any,

        /**
         * Creates a renderer for identifying features by their color.
         * @param params See the Object Specifications table below for the structure of the params object.
         */
        createPredominanceRenderer(params: any): any,

        /**
         * Defines the size of the symbol where feature size is proportional to data value.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createSizeInfo(params: any): any,

        /**
         * Creates a renderer for visualizing features by varying their size based on data.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createSizeRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features by their type.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createTypeRenderer(params: any): any,

        /**
         * Searches the fields of an input layer or array of field objects for field names commonly used in rendering based on usage (e.g.
         * @param params See the object specifications table below for details about the params object.
         */
        getSuggestedField(params: any): any
    };
    declare module.exports: typeof smartMapping
}
declare module 'esri/request' {
    declare     var request: {

        /**
         * Retrieve data from a remote server or upload a file from a user's computer.
         * @param request The request parameter is an object with the following properties that describe the request.
         * @param options See the object specifications table below for the structure of the  options  object.
         */
        (request: any, options?: any): any,

        /**
         * Define a callback function that will be called just before esri.request calls into dojo IO functions such as dojo.rawXhrPost and dojo.io.script.get.
         * @param callbackFunction The callback function that will be executed prior to esri.request calls into dojo IO functions.
         */
        setRequestPreCallback(callbackFunction: Function): void
    };
    declare module.exports: typeof request
}
declare module 'esri/symbols/CartographicLineSymbol' {
    declare module.exports: typeof CartographicLineSymbol
}
declare module 'esri/symbols/FillSymbol' {
    declare module.exports: typeof FillSymbol
}
declare module 'esri/symbols/Font' {
    declare module.exports: typeof Font
}
declare module 'esri/symbols/LineSymbol' {
    declare module.exports: typeof LineSymbol
}
declare module 'esri/symbols/MarkerSymbol' {
    declare module.exports: typeof MarkerSymbol
}
declare module 'esri/symbols/PictureFillSymbol' {
    declare module.exports: typeof PictureFillSymbol
}
declare module 'esri/symbols/PictureMarkerSymbol' {
    declare module.exports: typeof PictureMarkerSymbol
}
declare module 'esri/symbols/SimpleFillSymbol' {
    declare module.exports: typeof SimpleFillSymbol
}
declare module 'esri/symbols/SimpleLineSymbol' {
    declare module.exports: typeof SimpleLineSymbol
}
declare module 'esri/symbols/SimpleMarkerSymbol' {
    declare module.exports: typeof SimpleMarkerSymbol
}
declare module 'esri/symbols/Symbol' {
    declare module.exports: typeof Symbol
}
declare module 'esri/symbols/TextSymbol' {
    declare module.exports: typeof TextSymbol
}
declare module 'esri/symbols/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts input json into a symbol, returns null if the input json represents an unknown or unsupported symbol type.
         * @param json The input JSON.
         */
        fromJson(json: Object): Symbol,

        /**
         * Returns the shape description properties for the given symbol as defined by the Dojo GFX API.
         * @param symbol The input symbol.
         */
        getShapeDescriptors(symbol: Symbol): any
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/tasks/AddressCandidate' {
    declare module.exports: typeof AddressCandidate
}
declare module 'esri/tasks/AlgorithmicColorRamp' {
    declare module.exports: typeof AlgorithmicColorRamp
}
declare module 'esri/tasks/AreasAndLengthsParameters' {
    declare module.exports: typeof AreasAndLengthsParameters
}
declare module 'esri/tasks/BufferParameters' {
    declare module.exports: typeof BufferParameters
}
declare module 'esri/tasks/ClassBreaksDefinition' {
    declare module.exports: typeof ClassBreaksDefinition
}
declare module 'esri/tasks/ClassificationDefinition' {
    declare module.exports: typeof ClassificationDefinition
}
declare module 'esri/tasks/ClosestFacilityParameters' {
    declare module.exports: typeof ClosestFacilityParameters
}
declare module 'esri/tasks/ClosestFacilitySolveResult' {
    declare module.exports: typeof ClosestFacilitySolveResult
}
declare module 'esri/tasks/ClosestFacilityTask' {
    declare module.exports: typeof ClosestFacilityTask
}
declare module 'esri/tasks/ColorRamp' {
    declare module.exports: typeof ColorRamp
}
declare module 'esri/tasks/DataFile' {
    declare module.exports: typeof DataFile
}
declare module 'esri/tasks/DataLayer' {
    declare module.exports: typeof DataLayer
}
declare module 'esri/tasks/Date' {
    declare module.exports: typeof AGSDate
}
declare module 'esri/tasks/DensifyParameters' {
    declare module.exports: typeof DensifyParameters
}
declare module 'esri/tasks/DirectionsFeatureSet' {
    declare module.exports: typeof DirectionsFeatureSet
}
declare module 'esri/tasks/DistanceParameters' {
    declare module.exports: typeof DistanceParameters
}
declare module 'esri/tasks/FeatureSet' {
    declare module.exports: typeof FeatureSet
}
declare module 'esri/tasks/FindParameters' {
    declare module.exports: typeof FindParameters
}
declare module 'esri/tasks/FindResult' {
    declare module.exports: typeof FindResult
}
declare module 'esri/tasks/FindTask' {
    declare module.exports: typeof FindTask
}
declare module 'esri/tasks/GPMessage' {
    declare module.exports: typeof GPMessage
}
declare module 'esri/tasks/GeneralizeParameters' {
    declare module.exports: typeof GeneralizeParameters
}
declare module 'esri/tasks/GenerateRendererParameters' {
    declare module.exports: typeof GenerateRendererParameters
}
declare module 'esri/tasks/GenerateRendererTask' {
    declare module.exports: typeof GenerateRendererTask
}
declare module 'esri/tasks/GeometryService' {
    declare module.exports: typeof GeometryService
}
declare module 'esri/tasks/Geoprocessor' {
    declare module.exports: typeof Geoprocessor
}
declare module 'esri/tasks/IdentifyParameters' {
    declare module.exports: typeof IdentifyParameters
}
declare module 'esri/tasks/IdentifyResult' {
    declare module.exports: typeof IdentifyResult
}
declare module 'esri/tasks/IdentifyTask' {
    declare module.exports: typeof IdentifyTask
}
declare module 'esri/tasks/ImageServiceIdentifyParameters' {
    declare module.exports: typeof ImageServiceIdentifyParameters
}
declare module 'esri/tasks/ImageServiceIdentifyResult' {
    declare module.exports: typeof ImageServiceIdentifyResult
}
declare module 'esri/tasks/ImageServiceIdentifyTask' {
    declare module.exports: typeof ImageServiceIdentifyTask
}
declare module 'esri/tasks/ImageServiceMeasureParameters' {
    declare module.exports: typeof ImageServiceMeasureParameters
}
declare module 'esri/tasks/ImageServiceMeasureTask' {
    declare module.exports: typeof ImageServiceMeasureTask
}
declare module 'esri/tasks/JobInfo' {
    declare module.exports: typeof JobInfo
}
declare module 'esri/tasks/LegendLayer' {
    declare module.exports: typeof LegendLayer
}
declare module 'esri/tasks/LengthsParameters' {
    declare module.exports: typeof LengthsParameters
}
declare module 'esri/tasks/LinearUnit' {
    declare module.exports: typeof LinearUnit
}
declare module 'esri/tasks/MultipartColorRamp' {
    declare module.exports: typeof MultipartColorRamp
}
declare module 'esri/tasks/NAMessage' {
    declare module.exports: typeof NAMessage
}
declare module 'esri/tasks/NATypes' {
    declare     var NATypes: {
        OutputLine: esri.NAOutputLine,
        OutputPolygon: esri.NAOutputPolygon,
        TravelDirection: esri.NATravelDirection,
        UTurn: esri.NAUTurn
    };
    declare module.exports: typeof NATypes
}
declare module 'esri/tasks/OffsetParameters' {
    declare module.exports: typeof OffsetParameters
}
declare module 'esri/tasks/ParameterValue' {
    declare module.exports: typeof ParameterValue
}
declare module 'esri/tasks/PrintParameters' {
    declare module.exports: typeof PrintParameters
}
declare module 'esri/tasks/PrintTask' {
    declare module.exports: typeof PrintTask
}
declare module 'esri/tasks/PrintTemplate' {
    declare module.exports: typeof PrintTemplate
}
declare module 'esri/tasks/ProjectParameters' {
    declare module.exports: typeof ProjectParameters
}
declare module 'esri/tasks/QueryTask' {
    declare module.exports: typeof QueryTask
}
declare module 'esri/tasks/RasterData' {
    declare module.exports: typeof RasterData
}
declare module 'esri/tasks/RelationParameters' {
    declare module.exports: typeof RelationParameters
}
declare module 'esri/tasks/RelationshipQuery' {
    declare module.exports: typeof RelationshipQuery
}
declare module 'esri/tasks/RouteParameters' {
    declare module.exports: typeof RouteParameters
}
declare module 'esri/tasks/RouteResult' {
    declare module.exports: typeof RouteResult
}
declare module 'esri/tasks/RouteTask' {
    declare module.exports: typeof RouteTask
}
declare module 'esri/tasks/ServiceAreaParameters' {
    declare module.exports: typeof ServiceAreaParameters
}
declare module 'esri/tasks/ServiceAreaSolveResult' {
    declare module.exports: typeof ServiceAreaSolveResult
}
declare module 'esri/tasks/ServiceAreaTask' {
    declare module.exports: typeof ServiceAreaTask
}
declare module 'esri/tasks/StatisticDefinition' {
    declare module.exports: typeof StatisticDefinition
}
declare module 'esri/tasks/TrimExtendParameters' {
    declare module.exports: typeof TrimExtendParameters
}
declare module 'esri/tasks/UniqueValueDefinition' {
    declare module.exports: typeof UniqueValueDefinition
}
declare module 'esri/tasks/datareviewer/BatchValidationJob' {
    declare module.exports: typeof BatchValidationJob
}
declare module 'esri/tasks/datareviewer/BatchValidationJobInfo' {
    declare module.exports: typeof BatchValidationJobInfo
}
declare module 'esri/tasks/datareviewer/BatchValidationParameters' {
    declare module.exports: typeof BatchValidationParameters
}
declare module 'esri/tasks/datareviewer/BatchValidationTask' {
    declare module.exports: typeof BatchValidationTask
}
declare module 'esri/tasks/datareviewer/DashboardResult' {
    declare module.exports: typeof DashboardResult
}
declare module 'esri/tasks/datareviewer/DashboardTask' {
    declare module.exports: typeof DashboardTask
}
declare module 'esri/tasks/datareviewer/GetResultsQueryParameters' {
    declare module.exports: typeof GetResultsQueryParameters
}
declare module 'esri/tasks/datareviewer/ReviewerAttributes' {
    declare module.exports: typeof ReviewerAttributes
}
declare module 'esri/tasks/datareviewer/ReviewerFilters' {
    declare module.exports: typeof ReviewerFilters
}
declare module 'esri/tasks/datareviewer/ReviewerLifecycle' {
    declare     var ReviewerLifecycle: {

        /**
         * Acceptable lifecycleStatus code = 4 belongs to Verification Phase. 
         */
        ACCEPTABLE: number,

        /**
         * Code for Correction Phase. 
         */
        CORRECTION: number,

        /**
         * Exception lifecycleStatus code = 9 belongs to Verification Phase. 
         */
        EXCEPTION: number,

        /**
         * Failed lifecycleStatus code = 12 belongs to Verification Phase. 
         */
        FAILED: number,

        /**
         * Object containing lifecycle phase codes and their associated descriptions. 
         */
        LIFECYCLEPHASE_DESCRIPTIONS: any,

        /**
         * Object containing lifecycle status codes and their associated descriptions. 
         */
        LIFECYCLESTATUS_DESCRIPTIONS: any,

        /**
         * Mark As Exception lifecycleStatus code = 3 belongs to Correction Phase. 
         */
        MARK_AS_EXCEPTION: number,

        /**
         * New lifecycleStatus code = 10 belongs to Review Phase. 
         */
        NEW: number,

        /**
         * Passed lifecycleStatus code = 11 belongs to Verification Phase. 
         */
        PASSED: number,

        /**
         * Resolved lifecycleStatus code = 2 belongs to Correction Phase. 
         */
        RESOLVED: number,

        /**
         * Code for Review Phase. 
         */
        REVIEW: number,

        /**
         * Reviewed lifecycleStatus code = 1 belongs to Review Phase. 
         */
        REVIEWED: number,

        /**
         * Unacceptable lifecycleStatus code = 6 belongs to Review Phase. 
         */
        UNACCEPTABLE: number,

        /**
         * Unknown lifecycleStatus code = 0 belongs to Review Phase. 
         */
        UNKNOWN: number,

        /**
         * Unresolved Acceptable lifecycleStatus code = 8 belongs to Verification Phase. 
         */
        UNRESOLVED_ACCEPTABLE: number,

        /**
         * Unresolved Exception lifecycleStatus code = 5 belongs to Verification Phase. 
         */
        UNRESOLVED_EXCEPTION: number,

        /**
         * Unresolved Unacceptable lifecycleStatus code = 7 belongs to Review Phase. 
         */
        UNRESOLVED_UNACCEPTABLE: number,

        /**
         * Code for Verififcation Phase. 
         */
        VERIFICATION: number,

        /**
         * This function returns the the associated lifecycle phase of the input lifecycle status.
         * @param lifecycleStatus The lifecycle status code.
         */
        getCurrentLifecyclePhase(lifecycleStatus: number): string,

        /**
         * This function accepts an array of lifecycle statuses and returns an object containing the next appropriate lifecycle status and phase that the record will advance to.
         * @param lifecycleStatus An Array of lifecycle statuses.
         */
        getLifecycleInfo(lifecycleStatus: any[]): any,

        /**
         * This function returns lifecycle phase string associated with the input lifecycle phase code.
         * @param lifecyclePhase The lifecycle phase code.
         */
        toLifecyclePhaseString(lifecyclePhase: number): string,

        /**
         * This function returns lifecycle status string associated with the input lifecycle status code.
         * @param lifecycleStatus The lifecycle status code.
         */
        toLifecycleStatusString(lifecycleStatus: number): string
    };
    declare module.exports: typeof ReviewerLifecycle
}
declare module 'esri/tasks/datareviewer/ReviewerResultsTask' {
    declare module.exports: typeof ReviewerResultsTask
}
declare module 'esri/tasks/datareviewer/ReviewerSession' {
    declare module.exports: typeof ReviewerSession
}
declare module 'esri/tasks/datareviewer/SessionOptions' {
    declare module.exports: typeof SessionOptions
}
declare module 'esri/tasks/geoenrichment/AddressStudyArea' {
    declare module.exports: typeof AddressStudyArea
}
declare module 'esri/tasks/geoenrichment/DriveBuffer' {
    declare module.exports: typeof DriveBuffer
}
declare module 'esri/tasks/geoenrichment/DriveUnits' {
    declare module.exports: typeof DriveUnits
}
declare module 'esri/tasks/geoenrichment/GeographyLevel' {
    declare module.exports: typeof GeographyLevel
}
declare module 'esri/tasks/geoenrichment/GeographyQuery' {
    declare module.exports: typeof GeographyQuery
}
declare module 'esri/tasks/geoenrichment/GeographyQueryBase' {
    declare module.exports: typeof GeographyQueryBase
}
declare module 'esri/tasks/geoenrichment/GeometryStudyArea' {
    declare module.exports: typeof GeometryStudyArea
}
declare module 'esri/tasks/geoenrichment/IntersectingGeographies' {
    declare module.exports: typeof IntersectingGeographies
}
declare module 'esri/tasks/geoenrichment/RingBuffer' {
    declare module.exports: typeof RingBuffer
}
declare module 'esri/tasks/geoenrichment/StandardGeographyQueryTask' {
    declare module.exports: typeof StandardGeographyQueryTask
}
declare module 'esri/tasks/geoenrichment/StandardGeographyStudyArea' {
    declare module.exports: typeof StandardGeographyStudyArea
}
declare module 'esri/tasks/geoenrichment/StudyArea' {
    declare module.exports: typeof StudyArea
}
declare module 'esri/tasks/geoenrichment/SubGeographyQuery' {
    declare module.exports: typeof SubGeographyQuery
}
declare module 'esri/tasks/locationproviders/CoordinatesLocationProvider' {
    declare module.exports: typeof CoordinatesLocationProvider
}
declare module 'esri/tasks/locationproviders/GeometryLocationProvider' {
    declare module.exports: typeof GeometryLocationProvider
}
declare module 'esri/tasks/locationproviders/LocationProviderBase' {
    declare module.exports: typeof LocationProviderBase
}
declare module 'esri/tasks/locationproviders/LocationProviderClientBase' {
    declare module.exports: typeof LocationProviderClientBase
}
declare module 'esri/tasks/locationproviders/LocationProviderRemoteBase' {
    declare module.exports: typeof LocationProviderRemoteBase
}
declare module 'esri/tasks/locationproviders/LocatorLocationProvider' {
    declare module.exports: typeof LocatorLocationProvider
}
declare module 'esri/tasks/locationproviders/QueryTaskLocationProvider' {
    declare module.exports: typeof QueryTaskLocationProvider
}
declare module 'esri/tasks/locationproviders/StandardGeographyQueryLocationProvider' {
    declare module.exports: typeof StandardGeographyQueryLocationProvider
}
declare module 'esri/tasks/locator' {
    declare module.exports: typeof Locator
}
declare module 'esri/tasks/query' {
    declare module.exports: typeof Query
}
declare module 'esri/toolbars/ImageServiceMeasureTool' {
    declare module.exports: typeof ImageServiceMeasureTool
}
declare module 'esri/toolbars/draw' {
    declare module.exports: typeof Draw
}
declare module 'esri/toolbars/edit' {
    declare module.exports: typeof Edit
}
declare module 'esri/toolbars/navigation' {
    declare module.exports: typeof Navigation
}
declare module 'esri/undoManager' {
    declare module.exports: typeof UndoManager
}
declare module 'esri/units' {
    declare module.exports: typeof Units
}
declare module 'esri/urlUtils' {
    declare     var urlUtils: {

        /**
         * Adds the given proxy rule to the proxy rules list: esri.config.defaults.io.proxyRules
         * @param rule The rule argument should have the following properties.
         */
        addProxyRule(rule: any): number,

        /**
         * Returns the proxy rule that matches the given url. 
         */
        getProxyRule(): any,

        /**
         * Converts the URL arguments to an object representation.
         * @param url The input URL.
         */
        urlToObject(url: string): any
    };
    declare module.exports: typeof urlUtils
}
declare module 'esri/virtualearth/VEAddress' {
    declare module.exports: typeof VEAddress
}
declare module 'esri/virtualearth/VEGeocodeResult' {
    declare module.exports: typeof VEGeocodeResult
}
declare module 'esri/virtualearth/VEGeocoder' {
    declare module.exports: typeof VEGeocoder
}
declare module 'esri/virtualearth/VETiledLayer' {
    declare module.exports: typeof VETiledLayer
}
declare module 'esri/workers/WorkerClient' {
    declare module.exports: typeof WorkerClient
}