// @flow
/**
 * Flowtype definitions for oracledb-1.5.0
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'oracledb' {

    declare     export interface ILob {
        chunkSize: number,
            length: number,
            pieceSize: number,
            offset?: number,
            type: string,

            /**
             * Release method on ILob class.
             * @remarks  The cleanup() called by Release() only frees OCI error handle and Lob
            locator.  These calls acquire mutex on OCI environment handle very briefly.
            */
            release(): void,

            /**
             * Read method on ILob class.: any, chunk: string | Buffer) => void} callback Callback to recive the data from lob.
             * @remarks  CLobs send strings while BLobs send Buffer object.
             */
            read(callback: (err: any, chunk: string | Buffer) => void): void,

            /**
             * Read method on ILob class.: any) => void} callback Callback executed when writ is finished or when some error occured.
             * @param  Data write into Lob.
             * @remarks  CLobs send strings while BLobs send Buffer object.
             */
            write(data: Buffer, callback: (err: any) => void): void
    }
    declare     export type Lob = {
        iLob: ILob,
        chunkSize: number,
        length: number,
        pieceSize: number,
        type: string,

        /**
         * Do not call this... used internally by node-oracledb
         */
        constructor(iLob: ILob, opts: stream.DuplexOptions): Lob,
        constructor(iLob: ILob): Lob,

        /**
         * Closes the current LOB.: any) => void} callback? When passed, is called after the release.
         * @returns  void
         */
        close(callback: (err: any) => void): void,
        close(): void
    }
    declare     export interface IConnectionAttributes {
        user?: string,
            password?: string,
            connectString: string,
            stmtCacheSize?: number,
            externalAuth?: boolean
    }
    declare     export type IPoolAttributes = {
        poolMax?: number,
        poolMin?: number,
        poolIncrement?: number,
        poolTimeout?: number
    } & IConnectionAttributes

    declare     export interface IExecuteOptions {

        /**
         * Maximum number of rows that will be retrieved. Used when resultSet is false. 
         */
        maxRows?: number,

            /**
             * Number of rows to be fetched in advance. 
             */
            prefetchRows?: number,

            /**
             * Result format - ARRAY o OBJECT 
             */
            outFormat?: number,

            /**
             * Should use ResultSet or not. 
             */
            resultSet?: boolean,

            /**
             * Transaction should auto commit after each statement? 
             */
            autoCommit?: boolean
    }
    declare     export interface IExecuteReturn {

        /**
         * Number o rows affected by the statement (used for inserts / updates)
         */
        rowsAffected?: number,

            /**
             * When the statement has out parameters, it comes here. 
             */
            outBinds?: Array<any>| Object,

            /**
             * Metadata information - just columns names for now. 
             */
            metaData?: Array<IMetaData>,

            /**
             * When not using ResultSet, query results comes here. 
             */
            rows?: Array<Array<any >> | Array<any>,

            /**
             * When using ResultSet, query results comes here. 
             */
            resultSet?: IResultSet
    }
    declare     export interface IMetaData {

        /**
         * Column name 
         */
        name: string
    }
    declare     export interface IResultSet {

        /**
         * Metadata information - just columns names for now. 
         */
        metaData?: Array<IMetaData>,

            /**
             * Closes the ResultSet.:any)=>void} callback Callback called on finish or when some error occurs
             * @returns  void
             * @remarks  After using a resultSet, it must be closed to free the resources used by the driver.
             */
            close(callback: (err: any) => void): void,

            /**
             * Fetch one row from ResultSet.:any,row:Array<any>|Object)=>void} callback Callback called when the row is available or when some error occurs.
             * @returns  void
             */
            getRow(callback: (err: any, row: Array<any>| Object) => void): void,

            /**
             * Fetch some rows from ResultSet.:any,rows:Array<Array<any>>|Array<Object>)=>void} callback Callback called when the rows are available, or when some error occurs.
             * @param  Number of rows to be fetched.
             * @returns  void
             * @remarks  When the number of rows passed to the callback is less than the rowCount, no more rows are available to be fetched.
             */
            getRows(
                rowCount: number,
                callback: (err: any, rows: Array<Array<any >> | Array<Object>) => void): void
    }
    declare     export interface IConnection {

        /**
         * Statement cache size in bytes (read-only)
         */
        stmtCacheSize: number,

            /**
             * Client id (to be sent to database) (write-only)
             */
            clientId: string,

            /**
             * Module (write-only) 
             */
            module: string,

            /**
             * Action 
             */
            action: string,

            /**
             * Oracle server version 
             */
            oracleServerVersion: number,

            /**
             * Execute method on Connection class.: any, value: IExecuteReturn) => void} callback Callback function to receive the result.
             * @param  SQL Statement.
             * @param  Binds Object/Array
             * @param  Options object
             */
            execute(
                sql: string,
                binds: Object | Array<any>,
                options: IExecuteOptions,
                callback: (err: any, value: IExecuteReturn) => void): void,

            /**
             * Execute method on Connection class.: any, value: IExecuteReturn) => void} callback Callback function to receive the result.
             * @param  SQL Statement.
             * @param  Binds Object/Array
             */
            execute(
                sql: string,
                binds: Object | Array<any>,
                callback: (err: any, value: IExecuteReturn) => void): void,

            /**
             * Execute method on Connection class.: any, value: IExecuteReturn) => void} callback Callback function to receive the result.
             * @param  SQL Statement.
             * @param  Options object
             */
            execute(
                sql: string,
                options: IExecuteOptions,
                callback: (err: any, value: IExecuteReturn) => void): void,

            /**
             * Execute method on Connection class.: any, value: IExecuteReturn) => void} callback Callback function to receive the result.
             * @param  SQL Statement.
             */
            execute(sql: string, callback: (err: any, value: IExecuteReturn) => void): void,

            /**
             * Release method on Connection class.: any) => void} callback Callback function to be called when the connection has been released.
             */
            release(callback: (err: any) => void): void,

            /**
             * Send a commit requisition to the database.: any) => void} callback Callback on commit done.
             */
            commit(callback: (err: any) => void): void,

            /**
             * Send a rollback requisition to database.: any) => void} callback Callback on rollback done.
             */
            rollback(callback: (err: any) => void): void,

            /**
             * Send a break to the database.: any) => void} callback Callback on break done.
             */
            break (callback: (err: any) => void): void
    }
    declare     export interface IConnectionPool {
        poolMax: number,
            poolMin: number,
            poolIncrement: number,
            poolTimeout: number,
            connectionsOpen: number,
            connectionsInUse: number,
            stmtCacheSize: number,

            /**
             * Finalizes the connection pool.:any)=>void} callback Callback called when the pool is terminated or when some error occurs
             * @returns  void
             */
            terminate(callback: (err: any) => void): void,

            /**
             * Retrieve a connection from the pool.:any,connection:IConnection)=>void} callback Callback called when the connection is available or when some error occurs.
             * @returns  void
             * @see  {
             * @link  https://jsao.io/2015/03/making-a-wrapper-module-for-the-node-js-driver-for-oracle-database/}
             * @see  {
             * @link  https://github.com/OraOpenSource/orawrap}
             */
            getConnection(callback: (err: any, connection: IConnection) => void): void
    }
    declare     export var DEFAULT: number;
    declare     export var STRING: number;
    declare     export var NUMBER: number;
    declare     export var DATE: number;
    declare     export var CURSOR: number;
    declare     export var BUFFER: number;
    declare     export var CLOB: number;
    declare     export var BLOB: number;
    declare     export var BIND_IN: number;
    declare     export var BIND_INOUT: number;
    declare     export var BIND_OUT: number;
    declare     export var ARRAY: number;
    declare     export var OBJECT: number;

    /**
     * Do not use this method - used internally by node-oracledb.
     */
    declare     export function newLob(iLob: ILob): Lob

    /**
     * Creates a connection with the database.:any,connection:IConnection)=>void} callback Callback to run when the connection gets stablished or when some error occurs.
     * @param  Parameters to stablish the connection.
     * @returns  void
     */
    declare     export function getConnection(
        connectionAttributes: IConnectionAttributes,
        callback: (err: any, connection: IConnection) => void): void

    /**
     * Creates a database managed connection pool.:any,connection:IConnectionPool)=>void} callback Callback to run when the connection pool gets created or when some error occurs.
     * @param  Parameters to stablish the connection pool.
     * @returns  void
     */
    declare     export function createPool(
        poolAttributes: IPoolAttributes,
        callback: (err: any, connection: IConnectionPool) => void): void
    declare     export var poolMax: number;
    declare     export var poolMin: number;
    declare     export var poolIncrement: number;
    declare     export var poolTimeout: number;
    declare     export var stmtCacheSize: number;
    declare     export var prefetchRows: number;
    declare     export var autoCommit: boolean;
    declare     export var maxRows: number;
    declare     export var outFormat: number;
    declare     export var version: number;
    declare     export var connectionClass: string;
    declare     export var externalAuth: boolean;
    declare     export var fetchAsString: any;
    declare     export var lobPrefetchSize: number;
    declare     export var oracleClientVersion: number;
}