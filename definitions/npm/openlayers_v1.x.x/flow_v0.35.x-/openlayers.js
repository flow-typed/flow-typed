/**
 * Flowtype definitions for openlayers
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare type GlobalObject = Object;
declare module 'ol' {
    declare module 'animation' {

        /**
         * Generate an animated transition that will "bounce" the resolution as it
         * approaches the final value.
         * @param  Bounce options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function bounce(options: undefined.BounceOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view center.
         * @param  Pan options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function pan(options: undefined.PanOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view rotation.
         * @param  Rotate options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function rotate(options: undefined.RotateOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view resolution.
         * @param  Zoom options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function zoom(options: undefined.ZoomOptions): ol.PreRenderFunction

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface BounceOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface PanOptions {
            source: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     anchor: (ol.Coordinate|undefined),
        start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface RotateOptions {
            rotation?: number,
                anchor?: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface ZoomOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }
    }


    /**
     * Error object thrown when an assertion failed. This is an ECMA-262 Error,
     * extended with a `code` property.
     * @see  {
     * @link  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
     * @constructor  * 
     * @extends  {Error}
     * @implements  {oli.AssertionError}
     * @param  Error code.
     */
    declare class AssertionError mixins Error {

        /**
         * Error object thrown when an assertion failed. This is an ECMA-262 Error,
         * extended with a `code` property.
         * @see  {
         * @link  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
         * @constructor  * 
         * @extends  {Error}
         * @implements  {oli.AssertionError}
         * @param  Error code.
         */
        constructor(code: number): this;

        /**
         * Error code. The meaning of the code can be found on
         * {
         * @link  http://openlayers.org/en/latest/errors.html} (replace `latest` with
        the version found in the OpenLayers script's header comment if a version
        other than the latest is used).
         * @type  * 
         * @api  
        */
        code: number
    }

    /**
     * 
     * @classdesc  * An attribution for a layer source.

    Example:

    source: new ol.source.OSM({
    attributions: [
    new ol.Attribution({
    html: 'All maps &copy; ' +
    '<a href="http://www.opencyclemap.org/">OpenCycleMap</a>'
    }),
    ol.source.OSM.ATTRIBUTION
    ],
    ..
     * @constructor  * 
     * @param  Attribution options.
     * @struct  * 
     * @api  stable
    */
    declare class Attribution {

        /**
         * 
         * @classdesc  * An attribution for a layer source.

        Example:

        source: new ol.source.OSM({
        attributions: [
        new ol.Attribution({
        html: 'All maps &copy; ' +
        '<a href="http://www.opencyclemap.org/">OpenCycleMap</a>'
        }),
        ol.source.OSM.ATTRIBUTION
        ],
        ..
         * @constructor  * 
         * @param  Attribution options.
         * @struct  * 
         * @api  stable
        */
        constructor(options: olx.AttributionOptions): this;

        /**
         * Get the attribution markup.
         * @return  The attribution HTML.
         * @api  stable
         */
        getHTML(): string
    }
    declare module 'Collection' {
        declare type EventType = string;

        /**
         * *=} opt_element Element.
         * @classdesc  * Events emitted by {
         * @link  ol.Collection} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.Collection.Event}
         * @param  Type.
        */
        declare class Event mixins undefined.Event {

            /**
             * *=} opt_element Element.
             * @classdesc  * Events emitted by {
             * @link  ol.Collection} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.Collection.Event}
             * @param  Type.
            */
            constructor(type: undefined.EventType, opt_element?: any): this;

            /**
             * The element that is added to or removed from the collection.
             * @type  * 
             * @api  stable
             */
            element: any
        }
    }

    declare module 'color' {

        /**
         * Return the color as an array. This function maintains a cache of calculated
         * arrays which means the result should not be modified.
         * @param  Color.
         * @return  Color.
         * @api  
         */
        declare     function asArray(color: (ol.Color | string)): ol.Color

        /**
         * Return the color as an rgba string.
         * @param  Color.
         * @return  Rgba string.
         * @api  
         */
        declare     function asString(color: (ol.Color | string)): string
    }

    declare module 'colorlike' {

        /**
         * 
         * @param  Color.
         * @return  The color as an ol.ColorLike
         * @api  
         */
        declare     function asColorLike(color: (ol.Color | ol.ColorLike)): ol.ColorLike
    }

    declare module 'control' {

        /**
         * 
         * @classdesc  * Control to show all the attributions associated with the layer sources
        in the map. This control is one of the default controls included in maps.
        By default it will show in the bottom right portion of the map, but this can
        be changed by using a css selector for `.ol-attribution`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Attribution options.
         * @api  stable
        */
        declare class Attribution mixins undefined.Control {

            /**
             * 
             * @classdesc  * Control to show all the attributions associated with the layer sources
            in the map. This control is one of the default controls included in maps.
            By default it will show in the bottom right portion of the map, but this can
            be changed by using a css selector for `.ol-attribution`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Attribution options.
             * @api  stable
            */
            constructor(opt_options?: undefined.AttributionOptions): this;

            /**
             * Update the attribution element.
             * @param  Map event.
             * @this  {ol.control.Attribution}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void;

            /**
             * Return `true` if the attribution is collapsible, `false` otherwise.
             * @return  True if the widget is collapsible.
             * @api  stable
             */
            getCollapsible(): boolean;

            /**
             * Set whether the attribution should be collapsible.
             * @param  True if the widget is collapsible.
             * @api  stable
             */
            setCollapsible(collapsible: boolean): void;

            /**
             * Collapse or expand the attribution according to the passed parameter. Will
             * not do anything if the attribution isn't collapsible or if the current
            collapsed state is already the one requested.
             * @param  True if the widget is collapsed.
             * @api  stable
            */
            setCollapsed(collapsed: boolean): void;

            /**
             * Return `true` when the attribution is currently collapsed or `false`
             * otherwise.
             * @return  True if the widget is collapsed.
             * @api  stable
             */
            getCollapsed(): boolean
        }

        /**
         * 
         * @classdesc  * A control is a visible widget with a DOM element in a fixed position on the
        screen. They can involve user input (buttons), or be informational only;
        the position is determined using CSS. By default these are placed in the
        container with CSS class name `ol-overlaycontainer-stopevent`, but can use
        any outside DOM element.

        This is the base class for controls. You can use it for simple custom
        controls by creating the element with listeners, creating an instance:
        ```js
        var myControl = new ol.control.Control({element: myElement});
        ```
        and then adding this to the map.

        The main advantage of having this as a control rather than a simple separate
        DOM element is that preventing propagation is handled for you. Controls
        will also be `ol.Object`s in a `ol.Collection`, so you can use their
        methods.

        You can also extend this base for your own control class. See
        examples/custom-controls for an example of how to do this.
         * @constructor  * 
         * @extends  {ol.Object}
         * @implements  {oli.control.Control}
         * @param  Control options.
         * @api  stable
        */
        declare class Control mixins ol.Object {

            /**
             * 
             * @classdesc  * A control is a visible widget with a DOM element in a fixed position on the
            screen. They can involve user input (buttons), or be informational only;
            the position is determined using CSS. By default these are placed in the
            container with CSS class name `ol-overlaycontainer-stopevent`, but can use
            any outside DOM element.

            This is the base class for controls. You can use it for simple custom
            controls by creating the element with listeners, creating an instance:
            ```js
            var myControl = new ol.control.Control({element: myElement});
            ```
            and then adding this to the map.

            The main advantage of having this as a control rather than a simple separate
            DOM element is that preventing propagation is handled for you. Controls
            will also be `ol.Object`s in a `ol.Collection`, so you can use their
            methods.

            You can also extend this base for your own control class. See
            examples/custom-controls for an example of how to do this.
             * @constructor  * 
             * @extends  {ol.Object}
             * @implements  {oli.control.Control}
             * @param  Control options.
             * @api  stable
            */
            constructor(options: undefined.ControlOptions): this;

            /**
             * Get the map associated with this control.
             * @return  Map.
             * @api  stable
             */
            getMap(): ol.Map;

            /**
             * Remove the control from its current map and attach it to the new map.
             * Subclasses may set up event handlers to get notified about changes to
            the map here.
             * @param  Map.
             * @api  stable
            */
            setMap(map: ol.Map): void;

            /**
             * This function is used to set a target element for the control. It has no
             * effect if it is called after the control has been added to the map (i.e.
            after `setMap` is called on the control). If no `target` is set in the
            options passed to the control constructor and if `setTarget` is not called
            then the control is added to the map's overlay container.
             * @param  Target.
             * @api  
            */
            setTarget(target: (Element | string)): void
        }

        /**
         * 
         * @classdesc  * Provides a button that when clicked fills up the full screen with the map.
        The full screen source element is by default the element containing the map viewport unless
        overriden by providing the `source` option. In which case, the dom
        element introduced using this parameter will be displayed in full screen.

        When in full screen mode, a close button is shown to exit full screen mode.
        The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
        toggle the map in full screen mode.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Options.
         * @api  stable
        */
        declare class FullScreen mixins undefined.Control {

            /**
             * 
             * @classdesc  * Provides a button that when clicked fills up the full screen with the map.
            The full screen source element is by default the element containing the map viewport unless
            overriden by providing the `source` option. In which case, the dom
            element introduced using this parameter will be displayed in full screen.

            When in full screen mode, a close button is shown to exit full screen mode.
            The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
            toggle the map in full screen mode.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.FullScreenOptions): this
        }

        /**
         * Set of controls included in maps by default. Unless configured otherwise,
         * this returns a collection containing an instance of each of the following
        controls:
        * {@link ol.control.Zoom}
        * {@link ol.control.Rotate}
        * {@link ol.control.Attribution}
         * @param  Defaults options.
         * @return  Controls.
         * @api  stable
        */
        declare     function defaults(opt_options?: undefined.DefaultsOptions): ol.Collection<undefined.Control >

            /**
             * 
             * @classdesc  * A control to show the 2D coordinates of the mouse cursor. By default, these
            are in the view projection, but can be in any supported projection.
            By default the control is shown in the top right corner of the map, but this
            can be changed by using the css selector `.ol-mouse-position`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Mouse position
            options.
             * @api  stable
            */
            declare class MousePosition mixins undefined.Control {

                /**
                 * 
                 * @classdesc  * A control to show the 2D coordinates of the mouse cursor. By default, these
                are in the view projection, but can be in any supported projection.
                By default the control is shown in the top right corner of the map, but this
                can be changed by using the css selector `.ol-mouse-position`.
                 * @constructor  * 
                 * @extends  {ol.control.Control}
                 * @param  Mouse position
                options.
                 * @api  stable
                */
                constructor(opt_options?: undefined.MousePositionOptions): this;

                /**
                 * Update the mouseposition element.
                 * @param  Map event.
                 * @this  {ol.control.MousePosition}
                 * @api  
                 */
                render(mapEvent: ol.MapEvent): void;

                /**
                 * Return the coordinate format type used to render the current position or
                 * undefined.
                 * @return  The format to render the current
                position in.
                 * @observable  * 
                 * @api  stable
                */
                getCoordinateFormat(): (ol.CoordinateFormatType);

                /**
                 * Return the projection that is used to report the mouse position.
                 * @return  The projection to report mouse
                position in.
                 * @observable  * 
                 * @api  stable
                */
                getProjection(): (undefined.Projection);

                /**
                 * Set the coordinate format type used to render the current position.
                 * @param  The format to render the current
                position in.
                 * @observable  * 
                 * @api  stable
                */
                setCoordinateFormat(format: ol.CoordinateFormatType): void;

                /**
                 * Set the projection that is used to report the mouse position.
                 * @param  The projection to report mouse
                position in.
                 * @observable  * 
                 * @api  stable
                */
                setProjection(projection: undefined.Projection): void
            }

        /**
         * Create a new control with a map acting as an overview map for an other
         * defined map.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  OverviewMap options.
         * @api  
         */
        declare class OverviewMap mixins undefined.Control {

            /**
             * Create a new control with a map acting as an overview map for an other
             * defined map.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  OverviewMap options.
             * @api  
             */
            constructor(opt_options?: undefined.OverviewMapOptions): this;

            /**
             * Update the overview map element.
             * @param  Map event.
             * @this  {ol.control.OverviewMap}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void;

            /**
             * Return `true` if the overview map is collapsible, `false` otherwise.
             * @return  True if the widget is collapsible.
             * @api  stable
             */
            getCollapsible(): boolean;

            /**
             * Set whether the overview map should be collapsible.
             * @param  True if the widget is collapsible.
             * @api  stable
             */
            setCollapsible(collapsible: boolean): void;

            /**
             * Collapse or expand the overview map according to the passed parameter. Will
             * not do anything if the overview map isn't collapsible or if the current
            collapsed state is already the one requested.
             * @param  True if the widget is collapsed.
             * @api  stable
            */
            setCollapsed(collapsed: boolean): void;

            /**
             * Determine if the overview map is collapsed.
             * @return  The overview map is collapsed.
             * @api  stable
             */
            getCollapsed(): boolean;

            /**
             * Return the overview map.
             * @return  Overview map.
             * @api  
             */
            getOverviewMap(): ol.Map
        }

        /**
         * 
         * @classdesc  * A button control to reset rotation to 0.
        To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
        selector is added to the button when the rotation is 0.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Rotate options.
         * @api  stable
        */
        declare class Rotate mixins undefined.Control {

            /**
             * 
             * @classdesc  * A button control to reset rotation to 0.
            To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
            selector is added to the button when the rotation is 0.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Rotate options.
             * @api  stable
            */
            constructor(opt_options?: undefined.RotateOptions): this;

            /**
             * Update the rotate control element.
             * @param  Map event.
             * @this  {ol.control.Rotate}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void
        }
        declare module 'ScaleLine' {

            /**
             * 
             * @enum  {string}
             * @api  
             */
            declare type Property = string;

            /**
             * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
             * `'nautical'`, `'metric'`, `'us'`.
             * @enum  {string}
             */
            declare type Units = string;
        }


        /**
         * 
         * @classdesc  * A control with 2 buttons, one for zoom in and one for zoom out.
        This control is one of the default controls of a map. To style this control
        use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Zoom options.
         * @api  stable
        */
        declare class Zoom mixins undefined.Control {

            /**
             * 
             * @classdesc  * A control with 2 buttons, one for zoom in and one for zoom out.
            This control is one of the default controls of a map. To style this control
            use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Zoom options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomOptions): this
        }

        /**
         * 
         * @classdesc  * A slider type of control for zooming.

        Example:

        map.addControl(new ol.control.ZoomSlider());
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Zoom slider options.
         * @api  stable
        */
        declare class ZoomSlider mixins undefined.Control {

            /**
             * 
             * @classdesc  * A slider type of control for zooming.

            Example:

            map.addControl(new ol.control.ZoomSlider());
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Zoom slider options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomSliderOptions): this;

            /**
             * Update the zoomslider element.
             * @param  Map event.
             * @this  {ol.control.ZoomSlider}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void
        }

        /**
         * 
         * @classdesc  * A button control which, when pressed, changes the map view to a specific
        extent. To style this control use the css selector `.ol-zoom-extent`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Options.
         * @api  stable
        */
        declare class ZoomToExtent mixins undefined.Control {

            /**
             * 
             * @classdesc  * A button control which, when pressed, changes the map view to a specific
            extent. To style this control use the css selector `.ol-zoom-extent`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomToExtentOptions): this
        }

        /**
         * 
         * @typedef  *     collapsible: (boolean|undefined),
        collapsed: (boolean|undefined),
        tipLabel: (string|undefined),
        label: (string|Node|undefined),
        collapseLabel: (string|Node|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined)}}
        */
        declare interface AttributionOptions {
            className?: string,
                target?: Element,
                collapsible?: boolean,
                collapsed?: boolean,
                tipLabel?: string,
                label?: (string | Node),
                collapseLabel?: (string | Node),
                render?: ((event: ol.MapEvent) => any)
        }

        /**
         * 
         * @typedef  *     render: (function(ol.MapEvent)|undefined),
        target: (Element|string|undefined)}}
        */
        declare interface ControlOptions {
            element?: Element,
                render?: ((event: ol.MapEvent) => any),
                target?: (Element | string)
        }

        /**
         * 
         * @typedef  *     attributionOptions: (olx.control.AttributionOptions|undefined),
        rotate: (boolean|undefined),
        rotateOptions: (olx.control.RotateOptions|undefined),
        zoom: (boolean|undefined),
        zoomOptions: (olx.control.ZoomOptions|undefined)}}
        */
        declare interface DefaultsOptions {
            attribution?: boolean,
                attributionOptions?: undefined.AttributionOptions,
                rotate?: boolean,
                rotateOptions?: undefined.RotateOptions,
                zoom?: boolean,
                zoomOptions?: undefined.ZoomOptions
        }

        /**
         * 
         * @typedef  *     label: (string|Node|undefined),
        labelActive: (string|Node|undefined),
        tipLabel: (string|undefined),
        keys: (boolean|undefined),
        target: (Element|undefined),
        source: (Element|string|undefined)}}
        */
        declare interface FullScreenOptions {
            className?: string,
                label?: (string | Node),
                labelActive?: (string | Node),
                tipLabel?: string,
                keys?: boolean,
                target?: Element,
                source?: (Element | string)
        }

        /**
         * 
         * @typedef  *     coordinateFormat: (ol.CoordinateFormatType|undefined),
        projection: ol.ProjectionLike,
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        undefinedHTML: (string|undefined)}}
        */
        declare interface MousePositionOptions {
            className?: string,
                coordinateFormat?: ol.CoordinateFormatType,
                projection: ol.ProjectionLike,
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                undefinedHTML?: string
        }

        /**
         * 
         * @typedef  *     collapseLabel: (string|Node|undefined),
        collapsible: (boolean|undefined),
        label: (string|Node|undefined),
        layers: (Array.<ol.layer.Layer>|ol.Collection.<ol.layer.Layer>|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        tipLabel: (string|undefined),
        view: (ol.View|undefined)}}
        */
        declare interface OverviewMapOptions {
            collapsed?: boolean,
                collapseLabel?: (string | Node),
                collapsible?: boolean,
                label?: (string | Node),
                layers?: (undefined.Layer[] | ol.Collection<undefined.Layer>),
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                tipLabel?: string,
                view?: ol.View
        }

        /**
         * 
         * @typedef  *     minWidth: (number|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        units: (ol.control.ScaleLine.Units|string|undefined)}}
        */
        declare interface ScaleLineOptions {
            className?: string,
                minWidth?: number,
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                units?: (undefined.Units | string)
        }

        /**
         * 
         * @typedef  *     anchor: (ol.Coordinate|undefined),
        start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface RotateOptions {
            rotation?: number,
                anchor?: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface ZoomOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined),
        maxResolution: (number|undefined),
        minResolution: (number|undefined),
        render: (function(ol.MapEvent)|undefined)}}
        */
        declare interface ZoomSliderOptions {
            className?: string,
                duration?: number,
                maxResolution?: number,
                minResolution?: number,
                render?: ((event: ol.MapEvent) => any)
        }

        /**
         * 
         * @typedef  *     target: (Element|undefined),
        label: (string|Node|undefined),
        tipLabel: (string|undefined),
        extent: (ol.Extent|undefined)}}
        */
        declare interface ZoomToExtentOptions {
            className?: string,
                target?: Element,
                label?: (string | Node),
                tipLabel?: string,
                extent?: ol.Extent
        }
    }

    declare module 'coordinate' {

        /**
         * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
         * by the function.

        Example:

             var coord = [7.85, 47.983333];
             ol.coordinate.add(coord, [-2, 4]);
             // coord is now [5.85, 51.983333]
         * @param  Coordinate.
         * @param  Delta.
         * @return  The input coordinate adjusted by the given delta.
         * @api  stable
        */
        declare     function add(coordinate: ol.Coordinate, delta: ol.Coordinate): ol.Coordinate

        /**
         * Returns a {@link ol.CoordinateFormatType} function that can be used to format
         * a {ol.Coordinate} to a string.

        Example without specifying the fractional digits:

             var coord = [7.85, 47.983333];
             var stringifyFunc = ol.coordinate.createStringXY();
             var out = stringifyFunc(coord);
             // out is now '8, 48'

        Example with explicitly specifying 2 fractional digits:

             var coord = [7.85, 47.983333];
             var stringifyFunc = ol.coordinate.createStringXY(2);
             var out = stringifyFunc(coord);
             // out is now '7.85, 47.98'
         * @param  The number of digits to include
        after the decimal point. Default is `0`.
         * @return  Coordinate format.
         * @api  stable
        */
        declare     function createStringXY(opt_fractionDigits?: number): ol.CoordinateFormatType

        /**
         * Transforms the given {@link ol.Coordinate} to a string using the given string
         * template. The strings `{x}` and `{y}` in the template will be replaced with
        the first and second coordinate values respectively.

        Example without specifying the fractional digits:

             var coord = [7.85, 47.983333];
             var template = 'Coordinate is ({x}|{y}).';
             var out = ol.coordinate.format(coord, template);
             // out is now 'Coordinate is (8|48).'

        Example explicitly specifying the fractional digits:

             var coord = [7.85, 47.983333];
             var template = 'Coordinate is ({x}|{y}).';
             var out = ol.coordinate.format(coord, template, 2);
             // out is now 'Coordinate is (7.85|47.98).'
         * @param  Coordinate.
         * @param  A template string with `{x}` and `{y}` placeholders
        that will be replaced by first and second coordinate values.
         * @param  The number of digits to include
        after the decimal point. Default is `0`.
         * @return  Formatted coordinate.
         * @api  stable
        */
        declare     function format(
            coordinate: (ol.Coordinate),
            template: string,
            opt_fractionDigits?: number): string

        /**
         * Generate an animated transition while updating the view rotation.
         * @param  Rotate options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function rotate(options: undefined.RotateOptions): ol.PreRenderFunction

        /**
         * Format a geographic coordinate with the hemisphere, degrees, minutes, and
         * seconds.

        Example without specifying fractional digits:

             var coord = [7.85, 47.983333];
             var out = ol.coordinate.toStringHDMS(coord);
             // out is now '47° 58′ 60″ N 7° 50′ 60″ E'

        Example explicitly specifying 1 fractional digit:

             var coord = [7.85, 47.983333];
             var out = ol.coordinate.toStringHDMS(coord, 1);
             // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
         * @param  Coordinate.
         * @param  The number of digits to include
        after the decimal point. Default is `0`.
         * @return  Hemisphere, degrees, minutes and seconds.
         * @api  stable
        */
        declare     function toStringHDMS(coordinate?: ol.Coordinate, opt_fractionDigits?: number): string

        /**
         * Format a coordinate as a comma delimited string.
         * 
        Example without specifying fractional digits:

             var coord = [7.85, 47.983333];
             var out = ol.coordinate.toStringXY(coord);
             // out is now '8, 48'

        Example explicitly specifying 1 fractional digit:

             var coord = [7.85, 47.983333];
             var out = ol.coordinate.toStringXY(coord, 1);
             // out is now '7.8, 48.0'
         * @param  Coordinate.
         * @param  The number of digits to include
        after the decimal point. Default is `0`.
         * @return  XY.
         * @api  stable
        */
        declare     function toStringXY(coordinate?: ol.Coordinate, opt_fractionDigits?: number): string
    }


    /**
     * 
     * @classdesc  * The ol.DeviceOrientation class provides access to information from
    DeviceOrientation events.  See the [HTML 5 DeviceOrientation Specification](
    http://www.w3.org/TR/orientation-event/) for more details.

    Many new computers, and especially mobile phones
    and tablets, provide hardware support for device orientation. Web
    developers targeting mobile devices will be especially interested in this
    class.

    Device orientation data are relative to a common starting point. For mobile
    devices, the starting point is to lay your phone face up on a table with the
    top of the phone pointing north. This represents the zero state. All
    angles are then relative to this state. For computers, it is the same except
    the screen is open at 90 degrees.

    Device orientation is reported as three angles - `alpha`, `beta`, and
    `gamma` - relative to the starting position along the three planar axes X, Y
    and Z. The X axis runs from the left edge to the right edge through the
    middle of the device. Similarly, the Y axis runs from the bottom to the top
    of the device through the middle. The Z axis runs from the back to the front
    through the middle. In the starting position, the X axis points to the
    right, the Y axis points away from you and the Z axis points straight up
    from the device lying flat.

    The three angles representing the device orientation are relative to the
    three axes. `alpha` indicates how much the device has been rotated around the
    Z axis, which is commonly interpreted as the compass heading (see note
    below). `beta` indicates how much the device has been rotated around the X
    axis, or how much it is tilted from front to back.  `gamma` indicates how
    much the device has been rotated around the Y axis, or how much it is tilted
    from left to right.

    For most browsers, the `alpha` value returns the compass heading so if the
    device points north, it will be 0.  With Safari on iOS, the 0 value of
    `alpha` is calculated from when device orientation was first requested.
    ol.DeviceOrientation provides the `heading` property which normalizes this
    behavior across all browsers for you.

    It is important to note that the HTML 5 DeviceOrientation specification
    indicates that `alpha`, `beta` and `gamma` are in degrees while the
    equivalent properties in ol.DeviceOrientation are in radians for consistency
    with all other uses of angles throughout OpenLayers.

    To get notified of device orientation changes, register a listener for the
    generic `change` event on your `ol.DeviceOrientation` instance.
     * @see  {
     * @link  http://www.w3.org/TR/orientation-event/}
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  Options.
     * @api  
    */
    declare class DeviceOrientation mixins ol.Object {

        /**
         * 
         * @classdesc  * The ol.DeviceOrientation class provides access to information from
        DeviceOrientation events.  See the [HTML 5 DeviceOrientation Specification](
        http://www.w3.org/TR/orientation-event/) for more details.

        Many new computers, and especially mobile phones
        and tablets, provide hardware support for device orientation. Web
        developers targeting mobile devices will be especially interested in this
        class.

        Device orientation data are relative to a common starting point. For mobile
        devices, the starting point is to lay your phone face up on a table with the
        top of the phone pointing north. This represents the zero state. All
        angles are then relative to this state. For computers, it is the same except
        the screen is open at 90 degrees.

        Device orientation is reported as three angles - `alpha`, `beta`, and
        `gamma` - relative to the starting position along the three planar axes X, Y
        and Z. The X axis runs from the left edge to the right edge through the
        middle of the device. Similarly, the Y axis runs from the bottom to the top
        of the device through the middle. The Z axis runs from the back to the front
        through the middle. In the starting position, the X axis points to the
        right, the Y axis points away from you and the Z axis points straight up
        from the device lying flat.

        The three angles representing the device orientation are relative to the
        three axes. `alpha` indicates how much the device has been rotated around the
        Z axis, which is commonly interpreted as the compass heading (see note
        below). `beta` indicates how much the device has been rotated around the X
        axis, or how much it is tilted from front to back.  `gamma` indicates how
        much the device has been rotated around the Y axis, or how much it is tilted
        from left to right.

        For most browsers, the `alpha` value returns the compass heading so if the
        device points north, it will be 0.  With Safari on iOS, the 0 value of
        `alpha` is calculated from when device orientation was first requested.
        ol.DeviceOrientation provides the `heading` property which normalizes this
        behavior across all browsers for you.

        It is important to note that the HTML 5 DeviceOrientation specification
        indicates that `alpha`, `beta` and `gamma` are in degrees while the
        equivalent properties in ol.DeviceOrientation are in radians for consistency
        with all other uses of angles throughout OpenLayers.

        To get notified of device orientation changes, register a listener for the
        generic `change` event on your `ol.DeviceOrientation` instance.
         * @see  {
         * @link  http://www.w3.org/TR/orientation-event/}
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Options.
         * @api  
        */
        constructor(opt_options?: olx.DeviceOrientationOptions): this;

        /**
         * Rotation around the device z-axis (in radians).
         * @return  The euler angle in radians of the device from the
        standard Z axis.
         * @observable  * 
         * @api  
        */
        getAlpha(): (number);

        /**
         * Rotation around the device x-axis (in radians).
         * @return  The euler angle in radians of the device from the
        planar X axis.
         * @observable  * 
         * @api  
        */
        getBeta(): (number);

        /**
         * Rotation around the device y-axis (in radians).
         * @return  The euler angle in radians of the device from the
        planar Y axis.
         * @observable  * 
         * @api  
        */
        getGamma(): (number);

        /**
         * The heading of the device relative to north (in radians).
         * @return  The heading of the device relative to north, in
        radians, normalizing for different browser behavior.
         * @observable  * 
         * @api  
        */
        getHeading(): (number);

        /**
         * Determine if orientation is being tracked.
         * @return  Changes in device orientation are being tracked.
         * @observable  * 
         * @api  
         */
        getTracking(): boolean;

        /**
         * Enable or disable tracking of device orientation events.
         * @param  The status of tracking changes to alpha, beta and
        gamma. If true, changes are tracked and reported immediately.
         * @observable  * 
         * @api  
        */
        setTracking(tracking: boolean): void
    }

    /**
     * Objects that need to clean up after themselves.
     * @constructor  
     */
    declare class Disposable {

        /**
         * Objects that need to clean up after themselves.
         * @constructor  
         */
        constructor(): this
    }
    declare module 'easing' {

        /**
         * Start slow and speed up.
         * @param  Input between 0 and 1.
         * @return  Output between 0 and 1.
         * @api  
         */
        declare     function easeIn(t: number): number

        /**
         * Start fast and slow down.
         * @param  Input between 0 and 1.
         * @return  Output between 0 and 1.
         * @api  
         */
        declare     function easeOut(t: number): number

        /**
         * Start slow, speed up, and then slow down again.
         * @param  Input between 0 and 1.
         * @return  Output between 0 and 1.
         * @api  
         */
        declare     function inAndOut(t: number): number

        /**
         * Maintain a constant speed over time.
         * @param  Input between 0 and 1.
         * @return  Output between 0 and 1.
         * @api  
         */
        declare     function linear(t: number): number

        /**
         * Start slow, speed up, and at the very end slow down again.  This has the
         * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
        is delayed.
         * @param  Input between 0 and 1.
         * @return  Output between 0 and 1.
         * @api  
        */
        declare     function upAndDown(t: number): number
    }

    declare module 'events' {
        declare module 'condition' {

            /**
             * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
             * additionally the shift-key is pressed).
             * @param  Map browser event.
             * @return  True if only the alt key is pressed.
             * @api  stable
             */
            declare         function altKeyOnly(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
             * (e.g. when additionally the platform-modifier-key is pressed).
             * @param  Map browser event.
             * @return  True if only the alt and shift keys are pressed.
             * @api  stable
             */
            declare         function altShiftKeysOnly(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return always true.
             * @param  Map browser event.
             * @return  True.
             * @function  * 
             * @api  stable
             */
            declare         function always(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the event is a `click` event, `false` otherwise.
             * @param  Map browser event.
             * @return  True if the event is a map `click` event.
             * @api  stable
             */
            declare         function click(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return always false.
             * @param  Map browser event.
             * @return  False.
             * @function  * 
             * @api  stable
             */
            declare         function never(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the browser event is a `pointermove` event, `false`
             * otherwise.
             * @param  Map browser event.
             * @return  True if the browser event is a `pointermove` event.
             * @api  
             */
            declare         function pointerMove(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the event is a map `singleclick` event, `false` otherwise.
             * @param  Map browser event.
             * @return  True if the event is a map `singleclick` event.
             * @api  stable
             */
            declare         function singleClick(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the event is a map `dblclick` event, `false` otherwise.
             * @param  Map browser event.
             * @return  True if the event is a map `dblclick` event.
             * @api  stable
             */
            declare         function doubleClick(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
             * pressed.
             * @param  Map browser event.
             * @return  True only if there no modifier keys are pressed.
             * @api  stable
             */
            declare         function noModifierKeys(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if only the platform-modifier-key (the meta-key on Mac,
             * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
            the shift-key is pressed).
             * @param  Map browser event.
             * @return  True if only the platform modifier key is pressed.
             * @api  stable
            */
            declare         function platformModifierKeyOnly(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
             * additionally the alt-key is pressed).
             * @param  Map browser event.
             * @return  True if only the shift key is pressed.
             * @api  stable
             */
            declare         function shiftKeyOnly(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the target element is not editable, i.e. not a `<input>`-,
             * `<select>`- or `<textarea>`-element, `false` otherwise.
             * @param  Map browser event.
             * @return  True only if the target element is not editable.
             * @api  
             */
            declare         function targetNotEditable(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the event originates from a mouse device.
             * @param  Map browser event.
             * @return  True if the event originates from a mouse device.
             * @api  stable
             */
            declare         function mouseOnly(mapBrowserEvent: ol.MapBrowserEvent): boolean

            /**
             * Return `true` if the event originates from a primary pointer in
             * contact with the surface or if the left mouse button is pressed.
             * @see  http://www.w3.org/TR/pointerevents/#button-states
             * @param  Map browser event.
             * @return  True if the event originates from a primary pointer.
             * @api  
             */
            declare         function primaryAction(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }


        /**
         * 
         * @classdesc  * Stripped down implementation of the W3C DOM Level 2 Event interface.
         * @see  {
         * @link  https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}

        This implementation only provides `type` and `target` properties, and
        `stopPropagation` and `preventDefault` methods. It is meant as base class
        for higher level events defined in the library, and works with
        {
         * @link  ol.events.EventTarget}.
         * @constructor  * 
         * @implements  {oli.events.Event}
         * @param  Type.
        */
        declare class Event {

            /**
             * 
             * @classdesc  * Stripped down implementation of the W3C DOM Level 2 Event interface.
             * @see  {
             * @link  https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}

            This implementation only provides `type` and `target` properties, and
            `stopPropagation` and `preventDefault` methods. It is meant as base class
            for higher level events defined in the library, and works with
            {
             * @link  ol.events.EventTarget}.
             * @constructor  * 
             * @implements  {oli.events.Event}
             * @param  Type.
            */
            constructor(type: string): this;

            /**
             * The event type.
             * @type  * 
             * @api  stable
             */
            type: string;

            /**
             * The event target.
             * @type  * 
             * @api  stable
             */
            target: GlobalObject;

            /**
             * Stop event propagation.
             * @function  * 
             * @api  stable
             */
            preventDefault(): void;

            /**
             * Stop event propagation.
             * @function  * 
             * @api  stable
             */
            stopPropagation(): void
        }

        /**
         * 
         * @classdesc  * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
         * @see  {
         * @link  https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}

        There are two important simplifications compared to the specification:

        1. The handling of `useCapture` in `addEventListener` and
        `removeEventListener`. There is no real capture model.
        2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
        There is no event target hierarchy. When a listener calls
        `stopPropagation` or `preventDefault` on an event object, it means that no
        more listeners after this one will be called. Same as when the listener
        returns false.
         * @constructor  * 
         * @extends  {ol.Disposable}
        */
        declare class EventTarget mixins ol.Disposable {

            /**
             * 
             * @classdesc  * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
             * @see  {
             * @link  https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}

            There are two important simplifications compared to the specification:

            1. The handling of `useCapture` in `addEventListener` and
            `removeEventListener`. There is no real capture model.
            2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
            There is no event target hierarchy. When a listener calls
            `stopPropagation` or `preventDefault` on an event object, it means that no
            more listeners after this one will be called. Same as when the listener
            returns false.
             * @constructor  * 
             * @extends  {ol.Disposable}
            */
            constructor(): this
        }
    }

    declare module 'extent' {

        /**
         * Build an extent that includes all given coordinates.
         * @param  Coordinates.
         * @return  Bounding extent.
         * @api  stable
         */
        declare     function boundingExtent(coordinates: ol.Coordinate[]): ol.Extent

        /**
         * Return extent increased by the provided value.
         * @param  Extent.
         * @param  The amount by which the extent should be buffered.
         * @param  Extent.
         * @return  Extent.
         * @api  stable
         */
        declare     function buffer(extent: ol.Extent, value: number, opt_extent?: ol.Extent): ol.Extent

        /**
         * Check if the passed coordinate is contained or on the edge of the extent.
         * @param  Extent.
         * @param  Coordinate.
         * @return  The coordinate is contained in the extent.
         * @api  stable
         */
        declare     function containsCoordinate(extent: ol.Extent, coordinate: ol.Coordinate): boolean

        /**
         * Check if one extent contains another.
         * 
        An extent is deemed contained if it lies completely within the other extent,
        including if they share one or more edges.
         * @param  Extent 1.
         * @param  Extent 2.
         * @return  The second extent is contained by or on the edge of the
        first.
         * @api  stable
        */
        declare     function containsExtent(extent1: ol.Extent, extent2: ol.Extent): boolean

        /**
         * Check if the passed coordinate is contained or on the edge of the extent.
         * @param  Extent.
         * @param  X coordinate.
         * @param  Y coordinate.
         * @return  The x, y values are contained in the extent.
         * @api  stable
         */
        declare     function containsXY(extent: ol.Extent, x: number, y: number): boolean

        /**
         * Create an empty extent.
         * @return  Empty extent.
         * @api  stable
         */
        declare     function createEmpty(): ol.Extent

        /**
         * Determine if two extents are equivalent.
         * @param  Extent 1.
         * @param  Extent 2.
         * @return  The two extents are equivalent.
         * @api  stable
         */
        declare     function equals(extent1: ol.Extent, extent2: ol.Extent): boolean

        /**
         * Modify an extent to include another extent.
         * @param  The extent to be modified.
         * @param  The extent that will be included in the first.
         * @return  A reference to the first (extended) extent.
         * @api  stable
         */
        declare     function extend(extent1: ol.Extent, extent2: ol.Extent): ol.Extent

        /**
         * Get the bottom left coordinate of an extent.
         * @param  Extent.
         * @return  Bottom left coordinate.
         * @api  stable
         */
        declare     function getBottomLeft(extent: ol.Extent): ol.Coordinate

        /**
         * Get the bottom right coordinate of an extent.
         * @param  Extent.
         * @return  Bottom right coordinate.
         * @api  stable
         */
        declare     function getBottomRight(extent: ol.Extent): ol.Coordinate

        /**
         * Get the center coordinate of an extent.
         * @param  Extent.
         * @return  Center.
         * @api  stable
         */
        declare     function getCenter(extent: ol.Extent): ol.Coordinate

        /**
         * Get the height of an extent.
         * @param  Extent.
         * @return  Height.
         * @api  stable
         */
        declare     function getHeight(extent: ol.Extent): number

        /**
         * Get the intersection of two extents.
         * @param  Extent 1.
         * @param  Extent 2.
         * @param  Optional extent to populate with intersection.
         * @return  Intersecting extent.
         * @api  stable
         */
        declare     function getIntersection(extent1: ol.Extent, extent2: ol.Extent, opt_extent?: ol.Extent): ol.Extent

        /**
         * Get the size (width, height) of an extent.
         * @param  The extent.
         * @return  The extent size.
         * @api  stable
         */
        declare     function getSize(extent: ol.Extent): ol.Size

        /**
         * Get the top left coordinate of an extent.
         * @param  Extent.
         * @return  Top left coordinate.
         * @api  stable
         */
        declare     function getTopLeft(extent: ol.Extent): ol.Coordinate

        /**
         * Get the top right coordinate of an extent.
         * @param  Extent.
         * @return  Top right coordinate.
         * @api  stable
         */
        declare     function getTopRight(extent: ol.Extent): ol.Coordinate

        /**
         * Get the width of an extent.
         * @param  Extent.
         * @return  Width.
         * @api  stable
         */
        declare     function getWidth(extent: ol.Extent): number

        /**
         * Determine if one extent intersects another.
         * @param  Extent 1.
         * @param  Extent.
         * @return  The two extents intersect.
         * @api  stable
         */
        declare     function intersects(extent1: ol.Extent, extent2: ol.Extent): boolean

        /**
         * Determine if an extent is empty.
         * @param  Extent.
         * @return  Is empty.
         * @api  stable
         */
        declare     function isEmpty(extent: ol.Extent): boolean

        /**
         * Apply a transform function to the extent.
         * @param  Extent.
         * @param  Transform function.  Called with
        [minX, minY, maxX, maxY] extent coordinates.
         * @param  Destination extent.
         * @return  Extent.
         * @api  stable
        */
        declare     function applyTransform(
            extent: ol.Extent,
            transformFn: ol.TransformFunction,
            opt_extent?: ol.Extent): ol.Extent
    }


    /**
     * 
     * @classdesc  * A vector object for geographic features with a geometry and other
    attribute properties, similar to the features in vector file formats like
    GeoJSON.

    Features can be styled individually with `setStyle`; otherwise they use the
    style of their vector layer.

    Note that attribute properties are set as {
     * @link  ol.Object} properties on
    the feature object, so they are observable, and have get/set accessors.

    Typically, a feature has a single geometry property. You can set the
    geometry using the `setGeometry` method and get it with `getGeometry`.
    It is possible to store more than one geometry on a feature using attribute
    properties. By default, the geometry used for rendering is identified by
    the property name `geometry`. If you want to use another geometry property
    for rendering, use the `setGeometryName` method to change the attribute
    property associated with the geometry for the feature.  For example:

    ```js
    var feature = new ol.Feature({
    geometry: new ol.geom.Polygon(polyCoords),
    labelPoint: new ol.geom.Point(labelCoords),
    name: 'My Polygon'
    });

    // get the polygon geometry
    var poly = feature.getGeometry();

    // Render the feature as a point using the coordinates from labelPoint
    feature.setGeometryName('labelPoint');

    // get the point geometry
    var point = feature.getGeometry();
    ```
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  You may pass a Geometry object directly, or an object literal
    containing properties.  If you pass an object literal, you may
    include a Geometry associated with a `geometry` key.
     * @api  stable
    */
    declare class Feature mixins ol.Object {

        /**
         * 
         * @classdesc  * A vector object for geographic features with a geometry and other
        attribute properties, similar to the features in vector file formats like
        GeoJSON.

        Features can be styled individually with `setStyle`; otherwise they use the
        style of their vector layer.

        Note that attribute properties are set as {
         * @link  ol.Object} properties on
        the feature object, so they are observable, and have get/set accessors.

        Typically, a feature has a single geometry property. You can set the
        geometry using the `setGeometry` method and get it with `getGeometry`.
        It is possible to store more than one geometry on a feature using attribute
        properties. By default, the geometry used for rendering is identified by
        the property name `geometry`. If you want to use another geometry property
        for rendering, use the `setGeometryName` method to change the attribute
        property associated with the geometry for the feature.  For example:

        ```js
        var feature = new ol.Feature({
        geometry: new ol.geom.Polygon(polyCoords),
        labelPoint: new ol.geom.Point(labelCoords),
        name: 'My Polygon'
        });

        // get the polygon geometry
        var poly = feature.getGeometry();

        // Render the feature as a point using the coordinates from labelPoint
        feature.setGeometryName('labelPoint');

        // get the point geometry
        var point = feature.getGeometry();
        ```
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  You may pass a Geometry object directly, or an object literal
        containing properties.  If you pass an object literal, you may
        include a Geometry associated with a `geometry` key.
         * @api  stable
        */
        constructor(opt_geometryOrProperties?: (undefined.Geometry | {
            [k: string]: any
        })): this;

        /**
         * Clone this feature. If the original feature has a geometry it
         * is also cloned. The feature id is not set in the clone.
         * @return  The clone.
         * @api  stable
         */
        clone(): ol.Feature;

        /**
         * Get the feature's default geometry.  A feature may have any number of named
         * geometries.  The "default" geometry (the one that is rendered by default) is
        set when calling {@link ol.Feature#setGeometry}.
         * @return  The default geometry for the feature.
         * @api  stable
         * @observable  
        */
        getGeometry(): (undefined.Geometry);

        /**
         * Get the feature identifier.  This is a stable identifier for the feature and
         * is either set when reading data from a remote source or set explicitly by
        calling {@link ol.Feature#setId}.
         * @return  Id.
         * @api  stable
         * @observable  
        */
        getId(): (number | string);

        /**
         * Get the name of the feature's default geometry.  By default, the default
         * geometry is named `geometry`.
         * @return  Get the property name associated with the default geometry
        for this feature.
         * @api  stable
        */
        getGeometryName(): string;

        /**
         * Get the feature's style.  This return for this method depends on what was
         * provided to the {@link ol.Feature#setStyle} method.
         * @return  ol.FeatureStyleFunction} The feature style.
         * @api  stable
         * @observable  
         */
        getStyle(): (undefined.Style | undefined.Style[] | ol.FeatureStyleFunction);

        /**
         * Get the feature's style function.
         * @return  Return a function
        representing the current style of this feature.
         * @api  stable
        */
        getStyleFunction(): (ol.FeatureStyleFunction);

        /**
         * Set the default geometry for the feature.  This will update the property
         * with the name returned by {@link ol.Feature#getGeometryName}.
         * @param  The new geometry.
         * @api  stable
         * @observable  
         */
        setGeometry(geometry: (undefined.Geometry)): void;

        /**
         * Set the style for the feature.  This can be a single style object, an array
         * of styles, or a function that takes a resolution and returns an array of
        styles. If it is `null` the feature has no style (a `null` style).
         * @param  .FeatureStyleFunction} style Style for this feature.
         * @api  stable
         * @observable  
        */
        setStyle(style: (undefined.Style | undefined.Style[] | ol.FeatureStyleFunction)): void;

        /**
         * Set the feature id.  The feature id is considered stable and may be used when
         * requesting features or comparing identifiers returned from a remote source.
        The feature id can be used with the {@link ol.source.Vector#getFeatureById}
        method.
         * @param  The feature id.
         * @api  stable
         * @observable  
        */
        setId(id: (number | string)): void;

        /**
         * Set the property name to be used when getting the feature's default geometry.
         * When calling {@link ol.Feature#getGeometry}, the value of the property with
        this name will be returned.
         * @param  The property name of the default geometry.
         * @api  stable
        */
        setGeometryName(name: string): void
    }
    declare module 'featureloader' {

        /**
         * Create an XHR feature loader for a `url` and `format`. The feature loader
         * loads features (with XHR), parses the features, and adds them to the
        vector tile.
         * @param  Feature URL service.
         * @param  Feature format.
         * @return  The feature loader.
         * @api  
        */
        declare     function tile(
            url: (string | ol.FeatureUrlFunction),
            format: undefined.Feature): ol.FeatureLoader

        /**
         * Create an XHR feature loader for a `url` and `format`. The feature loader
         * loads features (with XHR), parses the features, and adds them to the
        vector source.
         * @param  Feature URL service.
         * @param  Feature format.
         * @return  The feature loader.
         * @api  
        */
        declare     function xhr(
            url: (string | ol.FeatureUrlFunction),
            format: undefined.Feature): ol.FeatureLoader
    }

    declare module 'format' {

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the EsriJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  
         */
        declare class EsriJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the EsriJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.EsriJSONOptions): this;

            /**
             * Read a feature from a EsriJSON Feature source.  Only works for Feature,
             * use `readFeatures` to read FeatureCollection source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  
             */
            readFeature(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a EsriJSON source.  Works with both Feature and
             * FeatureCollection sources.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  
             */
            readFeatures(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a geometry from a EsriJSON source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  
             */
            readGeometry(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a EsriJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  
             */
            readProjection(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string)): undefined.Projection;

            /**
             * Encode a geometry as a EsriJSON string.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a geometry as a EsriJSON object.
             * @param  Geometry.
             * @param  Write options.
             * @return  Object.
             * @api  
             */
            writeGeometryObject(
                geometry: undefined.Geometry,
                opt_options?: undefined.WriteOptions): EsriJSONGeometry;

            /**
             * Encode a feature as a EsriJSON Feature string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a feature as a esriJSON Feature object.
             * @param  Feature.
             * @param  Write options.
             * @return  Object.
             * @api  
             */
            writeFeatureObject(feature: ol.Feature, opt_options?: undefined.WriteOptions): GlobalObject;

            /**
             * Encode an array of features as EsriJSON.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a EsriJSON object.
             * @param  Features.
             * @param  Write options.
             * @return  EsriJSON Object.
             * @api  
             */
            writeFeaturesObject(features: ol.Feature[], opt_options?: undefined.WriteOptions): GlobalObject
        }
        declare type EsriJSONGeometry = JSON;

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for feature formats.
        {ol.format.Feature} subclasses provide the ability to decode and encode
        {
         * @link  ol.Feature} objects from a variety of commonly used geospatial
        file formats.  See the documentation for each format for more details.
         * @constructor  * 
         * @api  stable
        */
        declare class Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for feature formats.
            {ol.format.Feature} subclasses provide the ability to decode and encode
            {
             * @link  ol.Feature} objects from a variety of commonly used geospatial
            file formats.  See the documentation for each format for more details.
             * @constructor  * 
             * @api  stable
            */
            constructor(): this
        }
        declare type GeoJSONFeature = JSON;
        declare type GeoJSONFeatureCollection = JSON;
        declare type GeoJSONGeometry = JSON;
        declare type GeoJSONGeometryCollection = JSON;

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GeoJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  stable
         */
        declare class GeoJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GeoJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.GeoJSONOptions): this;

            /**
             * Read a feature from a GeoJSON Feature source.  Only works for Feature,
             * use `readFeatures` to read FeatureCollection source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a GeoJSON source.  Works with both Feature and
             * FeatureCollection sources.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a geometry from a GeoJSON source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a GeoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode a feature as a GeoJSON Feature string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a feature as a GeoJSON Feature object.
             * @param  Feature.
             * @param  Write options.
             * @return  Object.
             * @api  stable
             */
            writeFeatureObject(feature: ol.Feature, opt_options?: undefined.WriteOptions): GeoJSONFeature;

            /**
             * Encode an array of features as GeoJSON.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a GeoJSON object.
             * @param  Features.
             * @param  Write options.
             * @return  GeoJSON Object.
             * @api  stable
             */
            writeFeaturesObject(
                features: ol.Feature[],
                opt_options?: undefined.WriteOptions): GeoJSONFeatureCollection;

            /**
             * Encode a geometry as a GeoJSON string.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a geometry as a GeoJSON object.
             * @param  Geometry.
             * @param  Write options.
             * @return  Object.
             * @api  stable
             */
            writeGeometryObject(
                geometry: undefined.Geometry,
                opt_options?: undefined.WriteOptions): (GeoJSONGeometry | GeoJSONGeometryCollection)
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format
        version 3.1.1.
        Currently only supports GML 3.1.1 Simple Features profile.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  stable
        */
        declare class GML mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format
            version 3.1.1.
            Currently only supports GML 3.1.1 Simple Features profile.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  stable
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Encode an array of features in GML 3.1.1 Simple Features.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GML 3.1.1 format as an XML node.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format,
        version 2.1.2.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  
        */
        declare class GML2 mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format,
            version 2.1.2.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  
            */
            constructor(opt_options?: undefined.GMLOptions): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format
        version 3.1.1.
        Currently only supports GML 3.1.1 Simple Features profile.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  
        */
        declare class GML3 mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format
            version 3.1.1.
            Currently only supports GML 3.1.1 Simple Features profile.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Encode a geometry in GML 3.1.1 Simple Features.
             * @param  Geometry.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeGeometryNode(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): Node;

            /**
             * Encode an array of features in GML 3.1.1 Simple Features.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GML 3.1.1 format as an XML node.
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Feature base format for reading and writing data in the GML format.
        This class cannot be instantiated, it contains only base content that
        is shared with versioned format classes ol.format.GML2 and
        ol.format.GML3.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.XMLFeature}
        */
        declare class GMLBase mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Feature base format for reading and writing data in the GML format.
            This class cannot be instantiated, it contains only base content that
            is shared with versioned format classes ol.format.GML2 and
            ol.format.GML3.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.XMLFeature}
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Read all features from a GML FeatureCollection.
             * @function  * 
             * @param  Source.
             * @param  Options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[]
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GPX format.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  stable
         */
        declare class GPX mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GPX format.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.GPXOptions): this;

            /**
             * Read the first feature from a GPX source.
             * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
            into MultiLineString. Any properties on route and track waypoints are ignored.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
            */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a GPX source.
             * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
            into MultiLineString. Any properties on route and track waypoints are ignored.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
            */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from a GPX source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode an array of features in the GPX format.
             * LineString geometries are output as routes (`<rte>`), and MultiLineString
            as tracks (`<trk>`).
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  Result.
             * @api  stable
            */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GPX format as an XML node.
             * LineString geometries are output as routes (`<rte>`), and MultiLineString
            as tracks (`<trk>`).
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
            */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * IGC altitude/z. One of 'barometric', 'gps', 'none'.
         * @enum  {string}
         */
        declare type IGCZ = string;

        /**
         * 
         * @classdesc  * Feature format for `*.igc` flight recording files.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Options.
         * @api  
         */
        declare class IGC mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Feature format for `*.igc` flight recording files.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.IGCOptions): this;

            /**
             * Read the feature from the IGC source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read the feature from the source. As IGC sources contain a single
             * feature, this will return the feature in an array.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from the IGC source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for JSON feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class JSONFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for JSON feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the KML format.

        Note that the KML format uses the URL() constructor. Older browsers such as IE
        which do not support this will need a URL polyfill to be loaded before use.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  stable
        */
        declare class KML mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the KML format.

            Note that the KML format uses the URL() constructor. Older browsers such as IE
            which do not support this will need a URL polyfill to be loaded before use.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.KMLOptions): this;

            /**
             * Read the first feature from a KML source. MultiGeometries are converted into
             * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
            MultiLineString/MultiPolygon if they are all of the same type.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
            */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a KML source. MultiGeometries are converted into
             * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
            MultiLineString/MultiPolygon if they are all of the same type.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
            */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the name of the KML.
             * @param  Souce.
             * @return  Name.
             * @api  stable
             */
            readName(source: (Document | Node | string)): (string);

            /**
             * Read the network links of the KML.
             * @param  Source.
             * @return  Network links.
             * @api  
             */
            readNetworkLinks(source: (Document | Node | string)): GlobalObject[];

            /**
             * Read the projection from a KML source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode an array of features in the KML format. GeometryCollections, MultiPoints,
             * MultiLineStrings, and MultiPolygons are output as MultiGeometries.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the KML format as an XML node. GeometryCollections,
             * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Feature format for reading data in the Mapbox MVT format.
         * @constructor  * 
         * @extends  {ol.format.Feature}
         * @param  Options.
         * @api  
         */
        declare class MVT mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the Mapbox MVT format.
             * @constructor  * 
             * @extends  {ol.format.Feature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.MVTOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            readFeatures(
                source: (Document |
                    Node |
                    ArrayBuffer |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Sets the layers that features will be read from.
             * @param  Layers.
             * @api  
             */
            setLayers(layers: string[]): void
        }
        declare module 'ogc' {
            declare module 'filter' {
                declare interface Filter {}
            }

        }


        /**
         * 
         * @classdesc  * Feature format for reading data in the
        [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @api  stable
        */
        declare class OSMXML mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the
            [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @api  stable
            */
            constructor(): this;

            /**
             * Read all features from an OSM source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from an OSM source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the Encoded
        Polyline Algorithm Format.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Optional configuration object.
         * @api  stable
        */
        declare class Polyline mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the Encoded
            Polyline Algorithm Format.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Optional configuration object.
             * @api  stable
            */
            constructor(opt_options?: undefined.PolylineOptions): this;

            /**
             * Encode a list of n-dimensional points and return an encoded string
             * 
            Attention: This function will modify the passed array!
             * @param  A list of n-dimensional points.
             * @param  The number of dimension of the points in the list.
             * @param  The factor by which the numbers will be
            multiplied. The remaining decimal places will get rounded away.
            Default is `1e5`.
             * @return  The encoded string.
             * @api  
            */
            encodeDeltas(numbers: number[], stride: number, opt_factor?: number): string;

            /**
             * Decode a list of n-dimensional points from an encoded string
             * @param  An encoded string.
             * @param  The number of dimension of the points in the
            encoded string.
             * @param  The factor by which the resulting numbers will
            be divided. Default is `1e5`.
             * @return  A list of n-dimensional points.
             * @api  
            */
            decodeDeltas(encoded: string, stride: number, opt_factor?: number): number[];

            /**
             * Encode a list of floating point numbers and return an encoded string
             * 
            Attention: This function will modify the passed array!
             * @param  A list of floating point numbers.
             * @param  The factor by which the numbers will be
            multiplied. The remaining decimal places will get rounded away.
            Default is `1e5`.
             * @return  The encoded string.
             * @api  
            */
            encodeFloats(numbers: number[], opt_factor?: number): string;

            /**
             * Decode a list of floating point numbers from an encoded string
             * @param  An encoded string.
             * @param  The factor by which the result will be divided.
            Default is `1e5`.
             * @return  A list of floating point numbers.
             * @api  
            */
            decodeFloats(encoded: string, opt_factor?: number): number[];

            /**
             * Read the feature from the Polyline source. The coordinates are assumed to be
             * in two dimensions and in latitude, longitude order.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read the feature from the source. As Polyline sources contain a single
             * feature, this will return the feature in an array.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the geometry from the source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a Polyline source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Write a single geometry in Polyline format.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  Geometry.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for text feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class TextFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for text feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading data in the TopoJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  stable
         */
        declare class TopoJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the TopoJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.TopoJSONOptions): this;

            /**
             * Read all features from a TopoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Features.
             * @api  stable
             */
            readFeatures(source: (Document | Node | GlobalObject | string)): ol.Feature[];

            /**
             * Read the projection from a TopoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(object: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the WFS format.
        By default, supports WFS version 1.1.0. You can pass a GML format
        as option if you want to read a WFS that contains GML2 (WFS 1.0.0).
        Also see {
         * @link  ol.format.GMLBase} which is used by this format.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.XMLFeature}
         * @api  stable
        */
        declare class WFS mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the WFS format.
            By default, supports WFS version 1.1.0. You can pass a GML format
            as option if you want to read a WFS that contains GML2 (WFS 1.0.0).
            Also see {
             * @link  ol.format.GMLBase} which is used by this format.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.XMLFeature}
             * @api  stable
            */
            constructor(opt_options?: undefined.WFSOptions): this;

            /**
             * Read all features from a WFS FeatureCollection.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read transaction response of the source.
             * @param  Source.
             * @return  Transaction response.
             * @api  stable
             */
            readTransactionResponse(source: (Document | Node | GlobalObject | string)): (ol.WFSTransactionResponse);

            /**
             * Read feature collection metadata of the source.
             * @param  Source.
             * @return  *     FeatureCollection metadata.
             * @api  stable
             */
            readFeatureCollectionMetadata(
                source: (Document | Node | GlobalObject | string)): (ol.WFSFeatureCollectionMetadata);

            /**
             * Encode format as WFS `GetFeature` and return the Node.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeGetFeature(options: undefined.WFSWriteGetFeatureOptions): Node;

            /**
             * Encode format as WFS `Transaction` and return the Node.
             * @param  The features to insert.
             * @param  The features to update.
             * @param  The features to delete.
             * @param  Write options.
             * @return  Result.
             * @api  stable
             */
            writeTransaction(
                inserts: ol.Feature[],
                updates: ol.Feature[],
                deletes: ol.Feature[],
                options: undefined.WFSWriteTransactionOptions): Node;

            /**
             * Read the projection from a WFS source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Geometry format for reading and writing data in the `WellKnownText` (WKT)
        format.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Options.
         * @api  stable
        */
        declare class WKT mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Geometry format for reading and writing data in the `WellKnownText` (WKT)
            format.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.WKTOptions): this;

            /**
             * Read a feature from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a single geometry from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Encode a feature as a WKT string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  WKT string.
             * @api  stable
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a WKT string.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  WKT string.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Write a single geometry as a WKT string.
             * @function  * 
             * @param  Geometry.
             * @return  WKT string.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry): string
        }

        /**
         * 
         * @classdesc  * Format for reading WMS capabilities data
         * @constructor  * 
         * @extends  {ol.format.XML}
         * @api  
         */
        declare class WMSCapabilities mixins undefined.XML {

            /**
             * 
             * @classdesc  * Format for reading WMS capabilities data
             * @constructor  * 
             * @extends  {ol.format.XML}
             * @api  
             */
            constructor(): this;

            /**
             * Read a WMS capabilities document.
             * @function  * 
             * @param  The XML source.
             * @return  An object representing the WMS capabilities.
             * @api  
             */
            read(source: (Document | Node | string)): GlobalObject
        }

        /**
         * 
         * @classdesc  * Format for reading WMSGetFeatureInfo format. It uses
        {
         * @link  ol.format.GML2} to read features.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  
        */
        declare class WMSGetFeatureInfo mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Format for reading WMSGetFeatureInfo format. It uses
            {
             * @link  ol.format.GML2} to read features.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.WMSGetFeatureInfoOptions): this;

            /**
             * Read all features from a WMSGetFeatureInfo response.
             * @function  * 
             * @param  Source.
             * @param  Options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[]
        }

        /**
         * 
         * @classdesc  * Format for reading WMTS capabilities data.
         * @constructor  * 
         * @extends  {ol.format.XML}
         * @api  
         */
        declare class WMTSCapabilities mixins undefined.XML {

            /**
             * 
             * @classdesc  * Format for reading WMTS capabilities data.
             * @constructor  * 
             * @extends  {ol.format.XML}
             * @api  
             */
            constructor(): this;

            /**
             * Read a WMTS capabilities document.
             * @function  * 
             * @param  The XML source.
             * @return  An object representing the WMTS capabilities.
             * @api  
             */
            read(source: (Document | Node | string)): GlobalObject
        }

        /**
         * 
         * @classdesc  * Generic format for reading non-feature XML data
         * @constructor  * 
         * @struct  
         */
        declare class XML {

            /**
             * 
             * @classdesc  * Generic format for reading non-feature XML data
             * @constructor  * 
             * @struct  
             */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for XML feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class XMLFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for XML feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @typedef  *     featureProjection: ol.ProjectionLike,
        rightHanded: (boolean|undefined)}}
        */
        declare interface ReadOptions {
            dataProjection: ol.ProjectionLike,
                featureProjection: ol.ProjectionLike
        }

        /**
         * 
         * @typedef  *     featureProjection: ol.ProjectionLike,
        rightHanded: (boolean|undefined),
        decimals: (number|undefined)}}
        */
        declare interface WriteOptions {
            dataProjection: ol.ProjectionLike,
                featureProjection: ol.ProjectionLike,
                rightHanded?: boolean,
                decimals?: number
        }

        /**
         * 
         * @typedef  *     geometryName: (string|undefined)}}
         */
        declare interface GeoJSONOptions {
            defaultDataProjection: ol.ProjectionLike,
                geometryName?: string
        }

        /**
         * 
         * @typedef  
         */
        declare interface EsriJSONOptions {
            geometryName?: string
        }

        /**
         * 
         * @typedef  *>)=)|
        function(ol.geom.GeometryType,Array.<number>,
        (Array.<number>|Array.<Array.<number>>),Object.<string, *>)|
        undefined),
        geometryName: (string|undefined),
        layers: (Array.<string>|undefined),
        layerName: (string|undefined)}}
        */
        declare interface MVTOptions {
            featureClass?: (((geom: (undefined.Geometry | {
                    [k: string]: any
                })) => any) | ((
                    geom: undefined.GeometryType,
                    arg2: number[],
                    arg3: (number[] | number[][]),
                    arg4: {
                        [k: string]: any
                    }) => any)),
                geometryName?: string,
                layerName?: string,
                layers?: string[]
        }

        /**
         * 
         * @typedef  *     geometryLayout: (ol.geom.GeometryLayout|undefined)}}
         */
        declare interface PolylineOptions {
            factor?: number,
                geometryLayout?: undefined.GeometryLayout
        }

        /**
         * 
         * @typedef  
         */
        declare interface TopoJSONOptions {
            defaultDataProjection: ol.ProjectionLike
        }

        /**
         * 
         * @typedef  
         */
        declare interface IGCOptions {
            altitudeMode?: undefined.IGCZ
        }

        /**
         * 
         * @typedef  *     defaultStyle: (Array.<ol.style.Style>|undefined),
        showPointNames: (boolean|undefined),
        writeStyles: (boolean|undefined)}}
        */
        declare interface KMLOptions {
            extractStyles?: boolean,
                showPointNames?: boolean,
                defaultStyle?: undefined.Style[],
                writeStyles?: boolean
        }

        /**
         * 
         * @typedef  *     featureType: (Array.<string>|string|undefined),
        srsName: string,
        surface: (boolean|undefined),
        curve: (boolean|undefined),
        multiCurve: (boolean|undefined),
        multiSurface: (boolean|undefined),
        schemaLocation: (string|undefined)}}
        */
        declare interface GMLOptions {
            featureNS?: ({
                    [k: string]: string
                } | string),
                featureType?: (string[] | string),
                srsName: string,
                surface?: boolean,
                curve?: boolean,
                multiCurve?: boolean,
                multiSurface?: boolean,
                schemaLocation?: string
        }

        /**
         * 
         * @typedef  )}}
         */
        declare interface GPXOptions {
            readExtensions?: ((feature: ol.Feature, node: Node) => any)
        }

        /**
         * 
         * @typedef  *     featureType: (Array.<string>|string|undefined),
        gmlFormat: (ol.format.GMLBase|undefined),
        schemaLocation: (string|undefined)}}
        */
        declare interface WFSOptions {
            featureNS?: ({
                    [k: string]: string
                } | string),
                featureType?: (string[] | string),
                gmlFormat?: undefined.GMLBase,
                schemaLocation?: string
        }

        /**
         * 
         * @typedef  *     featurePrefix: string,
        featureTypes: Array.<string>,
        srsName: (string|undefined),
        handle: (string|undefined),
        outputFormat: (string|undefined),
        maxFeatures: (number|undefined),
        geometryName: (string|undefined),
        propertyNames: (Array.<string>|undefined),
        startIndex: (number|undefined),
        count: (number|undefined),
        bbox: (ol.Extent|undefined),
        filter: (ol.format.ogc.filter.Filter|undefined),
        resultType: (string|undefined)}}
        */
        declare interface WFSWriteGetFeatureOptions {
            featureNS: string,
                featurePrefix: string,
                featureTypes: string[],
                srsName?: string,
                handle?: string,
                outputFormat?: string,
                maxFeatures?: number,
                geometryName?: string,
                propertyNames?: string[],
                startIndex?: number,
                count?: number,
                bbox?: ol.Extent,
                filter?: undefined.Filter,
                resultType?: string
        }

        /**
         * 
         * @typedef  *     featurePrefix: string,
        featureType: string,
        srsName: (string|undefined),
        handle: (string|undefined),
        nativeElements: Array.<Object>,
        gmlOptions: (olx.format.GMLOptions|undefined)}}
        */
        declare interface WFSWriteTransactionOptions {
            featureNS: string,
                featurePrefix: string,
                featureType: string,
                srsName?: string,
                handle?: string,
                nativeElements: GlobalObject[],
                gmlOptions?: undefined.GMLOptions
        }

        /**
         * 
         * @typedef  
         */
        declare interface WKTOptions {
            splitCollection?: boolean
        }

        /**
         * 
         * @typedef  *     layers: (Array.<string>|undefined)
        }}
        */
        declare interface WMSGetFeatureInfoOptions {
            layers?: string[]
        }
    }


    /**
     * 
     * @classdesc  * Helper class for providing HTML5 Geolocation capabilities.
    The [Geolocation API](http://www.w3.org/TR/geolocation-API/)
    is used to locate a user's position.

    To get notified of position changes, register a listener for the generic
    `change` event on your instance of `ol.Geolocation`.

    Example:

    var geolocation = new ol.Geolocation({
    // take the projection to use from the map's view
    projection: view.getProjection()
    });
    // listen to changes in position
    geolocation.on('change', function(evt) {
    window.console.log(geolocation.getPosition());
    });
     * @fires  error
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  Options.
     * @api  stable
    */
    declare class Geolocation mixins ol.Object {

        /**
         * 
         * @classdesc  * Helper class for providing HTML5 Geolocation capabilities.
        The [Geolocation API](http://www.w3.org/TR/geolocation-API/)
        is used to locate a user's position.

        To get notified of position changes, register a listener for the generic
        `change` event on your instance of `ol.Geolocation`.

        Example:

        var geolocation = new ol.Geolocation({
        // take the projection to use from the map's view
        projection: view.getProjection()
        });
        // listen to changes in position
        geolocation.on('change', function(evt) {
        window.console.log(geolocation.getPosition());
        });
         * @fires  error
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Options.
         * @api  stable
        */
        constructor(opt_options?: olx.GeolocationOptions): this;

        /**
         * Get the accuracy of the position in meters.
         * @return  The accuracy of the position measurement in
        meters.
         * @observable  * 
         * @api  stable
        */
        getAccuracy(): (number);

        /**
         * Get a geometry of the position accuracy.
         * @return  A geometry of the position accuracy.
         * @observable  * 
         * @api  stable
         */
        getAccuracyGeometry(): undefined.Geometry;

        /**
         * Get the altitude associated with the position.
         * @return  The altitude of the position in meters above mean
        sea level.
         * @observable  * 
         * @api  stable
        */
        getAltitude(): (number);

        /**
         * Get the altitude accuracy of the position.
         * @return  The accuracy of the altitude measurement in
        meters.
         * @observable  * 
         * @api  stable
        */
        getAltitudeAccuracy(): (number);

        /**
         * Get the heading as radians clockwise from North.
         * @return  The heading of the device in radians from north.
         * @observable  * 
         * @api  stable
         */
        getHeading(): (number);

        /**
         * Get the position of the device.
         * @return  The current position of the device reported
        in the current projection.
         * @observable  * 
         * @api  stable
        */
        getPosition(): (ol.Coordinate);

        /**
         * Get the projection associated with the position.
         * @return  The projection the position is
        reported in.
         * @observable  * 
         * @api  stable
        */
        getProjection(): (undefined.Projection);

        /**
         * Get the speed in meters per second.
         * @return  The instantaneous speed of the device in meters
        per second.
         * @observable  * 
         * @api  stable
        */
        getSpeed(): (number);

        /**
         * Determine if the device location is being tracked.
         * @return  The device location is being tracked.
         * @observable  * 
         * @api  stable
         */
        getTracking(): boolean;

        /**
         * Get the tracking options.
         * @see  http://www.w3.org/TR/geolocation-API/#position-options
         * @return  PositionOptions as defined by
        the [HTML5 Geolocation spec
        ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
         * @observable  * 
         * @api  stable
        */
        getTrackingOptions(): (PositionOptions);

        /**
         * Set the projection to use for transforming the coordinates.
         * @param  The projection the position is
        reported in.
         * @observable  * 
         * @api  stable
        */
        setProjection(projection: undefined.Projection): void;

        /**
         * Enable or disable tracking.
         * @param  Enable tracking.
         * @observable  * 
         * @api  stable
         */
        setTracking(tracking: boolean): void;

        /**
         * Set the tracking options.
         * @see  http://www.w3.org/TR/geolocation-API/#position-options
         * @param  PositionOptions as defined by the
        [HTML5 Geolocation spec
        ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
         * @observable  * 
         * @api  stable
        */
        setTrackingOptions(options: PositionOptions): void
    }
    declare module 'geom' {

        /**
         * 
         * @classdesc  * Circle geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Center.
         * @param  Radius.
         * @param  Layout.
         * @api  
         */
        declare class Circle mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Circle geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Center.
             * @param  Radius.
             * @param  Layout.
             * @api  
             */
            constructor(center: ol.Coordinate, opt_radius?: number, opt_layout?: undefined.GeometryLayout): this;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  
             */
            clone(): undefined.Circle;

            /**
             * Return the center of the circle as {@link ol.Coordinate coordinate}.
             * @return  Center.
             * @api  
             */
            getCenter(): ol.Coordinate;

            /**
             * Return the radius of the circle.
             * @return  Radius.
             * @api  
             */
            getRadius(): number;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the center of the circle as {@link ol.Coordinate coordinate}.
             * @param  Center.
             * @api  
             */
            setCenter(center: ol.Coordinate): void;

            /**
             * Set the center (as {@link ol.Coordinate coordinate}) and the radius (as
             * number) of the circle.
             * @param  Center.
             * @param  Radius.
             * @param  Layout.
             * @api  
             */
            setCenterAndRadius(
                center: ol.Coordinate,
                radius: number,
                opt_layout?: undefined.GeometryLayout): void;

            /**
             * Set the radius of the circle. The radius is in the units of the projection.
             * @param  Radius.
             * @api  
             */
            setRadius(radius: number): void
        }

        /**
         * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
         * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
        `'GeometryCollection'`, `'Circle'`.
         * @enum  {string}
        */
        declare type GeometryType = string;

        /**
         * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
         * or measure ('M') coordinate is available. Supported values are `'XY'`,
        `'XYZ'`, `'XYM'`, `'XYZM'`.
         * @enum  {string}
        */
        declare type GeometryLayout = string;

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for vector geometries.

        To get notified of changes to the geometry, register a listener for the
        generic `change` event on your geometry instance.
         * @constructor  * 
         * @extends  {ol.Object}
         * @api  stable
        */
        declare class Geometry mixins ol.Object {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for vector geometries.

            To get notified of changes to the geometry, register a listener for the
            generic `change` event on your geometry instance.
             * @constructor  * 
             * @extends  {ol.Object}
             * @api  stable
            */
            constructor(): this;

            /**
             * Return the closest point of the geometry to the passed point as
             * {
             * @link  ol.Coordinate coordinate}.
             * @param  Point.
             * @param  Closest point.
             * @return  Closest point.
             * @api  stable
             */
            getClosestPoint(point: ol.Coordinate, opt_closestPoint?: ol.Coordinate): ol.Coordinate;

            /**
             * Returns true if this geometry includes the specified coordinate. If the
             * coordinate is on the boundary of the geometry, returns false.
             * @param  Coordinate.
             * @return  Contains coordinate.
             * @api  
             */
            intersectsCoordinate(coordinate: ol.Coordinate): boolean;

            /**
             * Get the extent of the geometry.
             * @param  Extent.
             * @return  extent Extent.
             * @api  stable
             */
            getExtent(opt_extent?: ol.Extent): ol.Extent;

            /**
             * Rotate the geometry around a given coordinate. This modifies the geometry
             * coordinates in place.
             * @abstract  * 
             * @param  Rotation angle in radians.
             * @param  The rotation center.
             * @api  
             */
            rotate(angle: number, anchor: ol.Coordinate): void;

            /**
             * Scale the geometry (with an optional origin).  This modifies the geometry
             * coordinates in place.
             * @abstract  * 
             * @param  The scaling factor in the x-direction.
             * @param  The scaling factor in the y-direction (defaults to
            sx).
             * @param  The scale origin (defaults to the center
            of the geometry extent).
             * @api  
            */
            scale(sx: number, opt_sy?: number, opt_anchor?: ol.Coordinate): void;

            /**
             * Create a simplified version of this geometry.  For linestrings, this uses
             * the the {@link
            https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
            Douglas Peucker} algorithm.  For polygons, a quantization-based
            simplification is used to preserve topology.
             * @function  * 
             * @param  The tolerance distance for simplification.
             * @return  A new, simplified version of the original
            geometry.
             * @api  
            */
            simplify(tolerance: number): undefined.Geometry;

            /**
             * Transform each coordinate of the geometry from one coordinate reference
             * system to another. The geometry is modified in place.
            For example, a line will be transformed to a line and a circle to a circle.
            If you do not want the geometry modified in place, first `clone()` it and
            then use this function on the clone.
             * @param  The current projection.  Can be a
            string identifier or a {
             * @link  ol.proj.Projection} object.
             * @param  The desired projection.  Can be a
            string identifier or a {
             * @link  ol.proj.Projection} object.
             * @return  This geometry.  Note that original geometry is
            modified in place.
             * @api  stable
            */
            transform(source: ol.ProjectionLike, destination: ol.ProjectionLike): undefined.Geometry
        }

        /**
         * 
         * @classdesc  * An array of {
         * @link  ol.geom.Geometry} objects.
         * @constructor  * 
         * @extends  {ol.geom.Geometry}
         * @param  Geometries.
         * @api  stable
         */
        declare class GeometryCollection mixins undefined.Geometry {

            /**
             * 
             * @classdesc  * An array of {
             * @link  ol.geom.Geometry} objects.
             * @constructor  * 
             * @extends  {ol.geom.Geometry}
             * @param  Geometries.
             * @api  stable
             */
            constructor(opt_geometries?: undefined.Geometry[]): this;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.GeometryCollection;

            /**
             * Return the geometries that make up this geometry collection.
             * @return  Geometries.
             * @api  stable
             */
            getGeometries(): undefined.Geometry[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the geometries that make up this geometry collection.
             * @param  Geometries.
             * @api  stable
             */
            setGeometries(geometries: undefined.Geometry[]): void;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            applyTransform(transformFn: ol.TransformFunction): void;

            /**
             * Translate the geometry.
             * @param  Delta X.
             * @param  Delta Y.
             * @api  
             */
            translate(deltaX: number, deltaY: number): void
        }

        /**
         * 
         * @classdesc  * Linear ring geometry. Only used as part of polygon; cannot be rendered
        on its own.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
        */
        declare class LinearRing mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Linear ring geometry. Only used as part of polygon; cannot be rendered
            on its own.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
            */
            constructor(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.LinearRing;

            /**
             * Return the area of the linear ring on projected plane.
             * @return  Area (on projected plane).
             * @api  stable
             */
            getArea(): number;

            /**
             * Return the coordinates of the linear ring.
             * @return  Coordinates.
             * @api  stable
             */
            getCoordinates(): ol.Coordinate[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * Set the coordinates of the linear ring.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Linestring geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class LineString mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Linestring geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Append the passed coordinate to the coordinates of the linestring.
             * @param  Coordinate.
             * @api  stable
             */
            appendCoordinate(coordinate: ol.Coordinate): void;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.LineString;

            /**
             * Iterate over each segment, calling the provided callback.
             * If the callback returns a truthy value the function returns that
            value immediately. Otherwise the function returns `false`.
             * @param  Function
            called for each segment.
             * @param  The object to be used as the value of 'this'
            within callback.
             * @return  Value.
             * @template  * 
             * @api  
            */
            forEachSegment<T, S>(callback: (() => T), opt_this?: S): (T | boolean);

            /**
             * Returns the coordinate at `m` using linear interpolation, or `null` if no
             * such coordinate exists.

            `opt_extrapolate` controls extrapolation beyond the range of Ms in the
            MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
            M will return the first coordinate and Ms greater than the last M will
            return the last coordinate.
             * @param  M.
             * @param  Extrapolate. Default is `false`.
             * @return  Coordinate.
             * @api  stable
            */
            getCoordinateAtM(m: number, opt_extrapolate?: boolean): ol.Coordinate;

            /**
             * Return the coordinates of the linestring.
             * @return  Coordinates.
             * @api  stable
             */
            getCoordinates(): ol.Coordinate[];

            /**
             * Return the coordinate at the provided fraction along the linestring.
             * The `fraction` is a number between 0 and 1, where 0 is the start of the
            linestring and 1 is the end.
             * @param  Fraction.
             * @param  Optional coordinate whose values will
            be modified. If not provided, a new coordinate will be returned.
             * @return  Coordinate of the interpolated point.
             * @api  
            */
            getCoordinateAt(fraction: number, opt_dest?: ol.Coordinate): ol.Coordinate;

            /**
             * Return the length of the linestring on projected plane.
             * @return  Length (on projected plane).
             * @api  stable
             */
            getLength(): number;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinates of the linestring.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Multi-linestring geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class MultiLineString mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Multi-linestring geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate[][], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Append the passed linestring to the multilinestring.
             * @param  LineString.
             * @api  stable
             */
            appendLineString(lineString: undefined.LineString): void;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.MultiLineString;

            /**
             * Returns the coordinate at `m` using linear interpolation, or `null` if no
             * such coordinate exists.

            `opt_extrapolate` controls extrapolation beyond the range of Ms in the
            MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
            M will return the first coordinate and Ms greater than the last M will
            return the last coordinate.

            `opt_interpolate` controls interpolation between consecutive LineStrings
            within the MultiLineString. If `opt_interpolate` is `true` the coordinates
            will be linearly interpolated between the last coordinate of one LineString
            and the first coordinate of the next LineString.  If `opt_interpolate` is
            `false` then the function will return `null` for Ms falling between
            LineStrings.
             * @param  M.
             * @param  Extrapolate. Default is `false`.
             * @param  Interpolate. Default is `false`.
             * @return  Coordinate.
             * @api  stable
            */
            getCoordinateAtM(m: number, opt_extrapolate?: boolean, opt_interpolate?: boolean): ol.Coordinate;

            /**
             * Return the coordinates of the multilinestring.
             * @return  Coordinates.
             * @api  stable
             */
            getCoordinates(): ol.Coordinate[][];

            /**
             * Return the linestring at the specified index.
             * @param  Index.
             * @return  LineString.
             * @api  stable
             */
            getLineString(index: number): undefined.LineString;

            /**
             * Return the linestrings of this multilinestring.
             * @return  LineStrings.
             * @api  stable
             */
            getLineStrings(): undefined.LineString[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinates of the multilinestring.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[][], opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Multi-point geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class MultiPoint mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Multi-point geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Append the passed point to this multipoint.
             * @param  Point.
             * @api  stable
             */
            appendPoint(point: undefined.Point): void;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.MultiPoint;

            /**
             * Return the coordinates of the multipoint.
             * @return  Coordinates.
             * @api  stable
             */
            getCoordinates(): ol.Coordinate[];

            /**
             * Return the point at the specified index.
             * @param  Index.
             * @return  Point.
             * @api  stable
             */
            getPoint(index: number): undefined.Point;

            /**
             * Return the points of this multipoint.
             * @return  Points.
             * @api  stable
             */
            getPoints(): undefined.Point[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinates of the multipoint.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[], opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Multi-polygon geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class MultiPolygon mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Multi-polygon geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate[][][], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Append the passed polygon to this multipolygon.
             * @param  Polygon.
             * @api  stable
             */
            appendPolygon(polygon: undefined.Polygon): void;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.MultiPolygon;

            /**
             * Return the area of the multipolygon on projected plane.
             * @return  Area (on projected plane).
             * @api  stable
             */
            getArea(): number;

            /**
             * Get the coordinate array for this geometry.  This array has the structure
             * of a GeoJSON coordinate array for multi-polygons.
             * @param  Orient coordinates according to the right-hand
            rule (counter-clockwise for exterior and clockwise for interior rings).
            If `false`, coordinates will be oriented according to the left-hand rule
            (clockwise for exterior and counter-clockwise for interior rings).
            By default, coordinate orientation will depend on how the geometry was
            constructed.
             * @return  Coordinates.
             * @api  stable
            */
            getCoordinates(opt_right?: boolean): ol.Coordinate[][][];

            /**
             * Return the interior points as {@link ol.geom.MultiPoint multipoint}.
             * @return  Interior points.
             * @api  stable
             */
            getInteriorPoints(): undefined.MultiPoint;

            /**
             * Return the polygon at the specified index.
             * @param  Index.
             * @return  Polygon.
             * @api  stable
             */
            getPolygon(index: number): undefined.Polygon;

            /**
             * Return the polygons of this multipolygon.
             * @return  Polygons.
             * @api  stable
             */
            getPolygons(): undefined.Polygon[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinates of the multipolygon.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[][][], opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Point geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class Point mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Point geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate, opt_layout?: undefined.GeometryLayout): this;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.Point;

            /**
             * Return the coordinate of the point.
             * @return  Coordinates.
             * @api  stable
             */
            getCoordinates(): ol.Coordinate;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinate of the point.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate, opt_layout?: undefined.GeometryLayout): void
        }

        /**
         * 
         * @classdesc  * Polygon geometry.
         * @constructor  * 
         * @extends  {ol.geom.SimpleGeometry}
         * @param  Coordinates.
         * @param  Layout.
         * @api  stable
         */
        declare class Polygon mixins undefined.SimpleGeometry {

            /**
             * 
             * @classdesc  * Polygon geometry.
             * @constructor  * 
             * @extends  {ol.geom.SimpleGeometry}
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            constructor(coordinates: ol.Coordinate[][], opt_layout?: undefined.GeometryLayout): this;

            /**
             * Append the passed linear ring to this polygon.
             * @param  Linear ring.
             * @api  stable
             */
            appendLinearRing(linearRing: undefined.LinearRing): void;

            /**
             * Make a complete copy of the geometry.
             * @return  Clone.
             * @api  stable
             */
            clone(): undefined.Polygon;

            /**
             * Return the area of the polygon on projected plane.
             * @return  Area (on projected plane).
             * @api  stable
             */
            getArea(): number;

            /**
             * Get the coordinate array for this geometry.  This array has the structure
             * of a GeoJSON coordinate array for polygons.
             * @param  Orient coordinates according to the right-hand
            rule (counter-clockwise for exterior and clockwise for interior rings).
            If `false`, coordinates will be oriented according to the left-hand rule
            (clockwise for exterior and counter-clockwise for interior rings).
            By default, coordinate orientation will depend on how the geometry was
            constructed.
             * @return  Coordinates.
             * @api  stable
            */
            getCoordinates(opt_right?: boolean): ol.Coordinate[][];

            /**
             * Return an interior point of the polygon.
             * @return  Interior point.
             * @api  stable
             */
            getInteriorPoint(): undefined.Point;

            /**
             * Return the number of rings of the polygon,  this includes the exterior
             * ring and any interior rings.
             * @return  Number of rings.
             * @api  
             */
            getLinearRingCount(): number;

            /**
             * Return the Nth linear ring of the polygon geometry. Return `null` if the
             * given index is out of range.
            The exterior linear ring is available at index `0` and the interior rings
            at index `1` and beyond.
             * @param  Index.
             * @return  Linear ring.
             * @api  stable
            */
            getLinearRing(index: number): undefined.LinearRing;

            /**
             * Return the linear rings of the polygon.
             * @return  Linear rings.
             * @api  stable
             */
            getLinearRings(): undefined.LinearRing[];

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            getType(): undefined.GeometryType;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            intersectsExtent(extent: ol.Extent): boolean;

            /**
             * Set the coordinates of the polygon.
             * @param  Coordinates.
             * @param  Layout.
             * @api  stable
             */
            setCoordinates(coordinates: ol.Coordinate[][], opt_layout?: undefined.GeometryLayout): void;

            /**
             * Create an approximation of a circle on the surface of a sphere.
             * @param  The sphere.
             * @param  Center (`[lon, lat]` in degrees).
             * @param  The great-circle distance from the center to
            the polygon vertices.
             * @param  Optional number of vertices for the resulting
            polygon. Default is `32`.
             * @return  The "circular" polygon.
             * @api  stable
            */
            circular(
                sphere: ol.Sphere,
                center: ol.Coordinate,
                radius: number,
                opt_n?: number): undefined.Polygon;

            /**
             * Create a polygon from an extent. The layout used is `XY`.
             * @param  The extent.
             * @return  The polygon.
             * @api  
             */
            fromExtent(extent: ol.Extent): undefined.Polygon;

            /**
             * Create a regular polygon from a circle.
             * @param  Circle geometry.
             * @param  Number of sides of the polygon. Default is 32.
             * @param  Start angle for the first vertex of the polygon in
            radians. Default is 0.
             * @return  Polygon geometry.
             * @api  
            */
            fromCircle(
                circle: undefined.Circle,
                opt_sides?: number,
                opt_angle?: number): undefined.Polygon
        }

        /**
         * 
         * @classdesc  * Abstract base class; only used for creating subclasses; do not instantiate
        in apps, as cannot be rendered.
         * @constructor  * 
         * @extends  {ol.geom.Geometry}
         * @api  stable
        */
        declare class SimpleGeometry mixins undefined.Geometry {

            /**
             * 
             * @classdesc  * Abstract base class; only used for creating subclasses; do not instantiate
            in apps, as cannot be rendered.
             * @constructor  * 
             * @extends  {ol.geom.Geometry}
             * @api  stable
            */
            constructor(): this;

            /**
             * Return the first coordinate of the geometry.
             * @return  First coordinate.
             * @api  stable
             */
            getFirstCoordinate(): ol.Coordinate;

            /**
             * Return the last coordinate of the geometry.
             * @return  Last point.
             * @api  stable
             */
            getLastCoordinate(): ol.Coordinate;

            /**
             * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
             * @return  Layout.
             * @api  stable
             */
            getLayout(): undefined.GeometryLayout;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            applyTransform(transformFn: ol.TransformFunction): void;

            /**
             * 
             * @inheritDoc  * 
             * @api  stable
             */
            translate(deltaX: number, deltaY: number): void
        }
    }


    /**
     * Render a grid for a coordinate system on a map.
     * @constructor  * 
     * @param  Options.
     * @api  
     */
    declare class Graticule {

        /**
         * Render a grid for a coordinate system on a map.
         * @constructor  * 
         * @param  Options.
         * @api  
         */
        constructor(opt_options?: olx.GraticuleOptions): this;

        /**
         * Get the map associated with this graticule.
         * @return  The map.
         * @api  
         */
        getMap(): ol.Map;

        /**
         * Get the list of meridians.  Meridians are lines of equal longitude.
         * @return  The meridians.
         * @api  
         */
        getMeridians(): undefined.LineString[];

        /**
         * Get the list of parallels.  Pallels are lines of equal latitude.
         * @return  The parallels.
         * @api  
         */
        getParallels(): undefined.LineString[];

        /**
         * Set the map for this graticule.  The graticule will be rendered on the
         * provided map.
         * @param  Map.
         * @api  
         */
        setMap(map: ol.Map): void
    }
    declare module 'has' {
        declare     var DEVICE_PIXEL_RATIO: number;
        declare     var CANVAS: boolean;
        declare     var DEVICE_ORIENTATION: boolean;
        declare     var GEOLOCATION: boolean;
        declare     var TOUCH: boolean;
        declare     var WEBGL: boolean;
    }


    /**
     * 
     * @constructor  * 
     * @extends  {ol.ImageBase}
     * @param  Extent.
     * @param  Resolution.
     * @param  Pixel ratio.
     * @param  Attributions.
     * @param  Image source URI.
     * @param  Cross origin.
     * @param  Image load function.
     */
    declare class Image mixins ol.ImageBase {

        /**
         * 
         * @constructor  * 
         * @extends  {ol.ImageBase}
         * @param  Extent.
         * @param  Resolution.
         * @param  Pixel ratio.
         * @param  Attributions.
         * @param  Image source URI.
         * @param  Cross origin.
         * @param  Image load function.
         */
        constructor(extent: ol.Extent, resolution: (number), pixelRatio: number, attributions: ol.Attribution[], src: string, crossOrigin?: string, imageLoadFunction?: ol.ImageLoadFunctionType): this;

        /**
         * Get the HTML image element (may be a Canvas, Image, or Video).
         * @param  Object.
         * @return  Image.
         * @api  
         */
        getImage(opt_context?: GlobalObject): (HTMLCanvasElement | Image | HTMLVideoElement);

        /**
         * Load the image or retry if loading previously failed.
         * Loading is taken care of by the tile queue, and calling this method is
        only needed for preloading or for reloading in case of an error.
         * @api  
        */
        load(): void
    }

    /**
     * 
     * @constructor  * 
     * @extends  {ol.events.EventTarget}
     * @param  Extent.
     * @param  Resolution.
     * @param  Pixel ratio.
     * @param  State.
     * @param  Attributions.
     */
    declare class ImageBase mixins undefined.EventTarget {

        /**
         * 
         * @constructor  * 
         * @extends  {ol.events.EventTarget}
         * @param  Extent.
         * @param  Resolution.
         * @param  Pixel ratio.
         * @param  State.
         * @param  Attributions.
         */
        constructor(extent: ol.Extent, resolution: (number), pixelRatio: number, state: ol.ImageState, attributions: ol.Attribution[]): this
    }
    declare type ImageState = number;

    /**
     * 
     * @constructor  * 
     * @extends  {ol.Tile}
     * @param  Tile coordinate.
     * @param  State.
     * @param  Image source URI.
     * @param  Cross origin.
     * @param  Tile load function.
     */
    declare class ImageTile mixins ol.Tile {

        /**
         * 
         * @constructor  * 
         * @extends  {ol.Tile}
         * @param  Tile coordinate.
         * @param  State.
         * @param  Image source URI.
         * @param  Cross origin.
         * @param  Tile load function.
         */
        constructor(tileCoord: ol.TileCoord, state: undefined.State, src: string, crossOrigin?: string, tileLoadFunction?: ol.TileLoadFunctionType): this;

        /**
         * Get the image element for this tile.
         * @inheritDoc  * 
         * @api  
         */
        getImage(
            opt_context?: GlobalObject): (HTMLCanvasElement | HTMLImageElement | HTMLVideoElement)
    }

    /**
     * Inherit the prototype methods from one constructor into another.
     * 
    Usage:

         function ParentClass(a, b) { }
         ParentClass.prototype.foo = function(a) { }

         function ChildClass(a, b, c) {
           // Call parent constructor
           ParentClass.call(this, a, b);
         }
         ol.inherits(ChildClass, ParentClass);

         var child = new ChildClass('a', 'b', 'see');
         child.foo(); // This works.
     * @param  Child constructor.
     * @param  Parent constructor.
     * @function  * 
     * @api  
    */
    declare function inherits(childCtor: (() => any), parentCtor: (() => any)): void

    /**
     * 
     * @classdesc  * Events emitted by {
     * @link  ol.interaction.DragBox} instances are instances of
    this type.
     * @param  The event type.
     * @param  The event coordinate.
     * @param  Originating event.
     * @extends  {ol.events.Event}
     * @constructor  * 
     * @implements  {oli.DragBoxEvent}
    */
    declare class DragBoxEvent mixins undefined.Event {

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.DragBox} instances are instances of
        this type.
         * @param  The event type.
         * @param  The event coordinate.
         * @param  Originating event.
         * @extends  {ol.events.Event}
         * @constructor  * 
         * @implements  {oli.DragBoxEvent}
        */
        constructor(type: string, coordinate: ol.Coordinate, mapBrowserEvent: ol.MapBrowserEvent): this;

        /**
         * The coordinate of the drag event.
         * @const  * 
         * @type  * 
         * @api  stable
         */
        coordinate: ol.Coordinate;

        /**
         * 
         * @const  * 
         * @type  * 
         * @api  
         */
        mapBrowserEvent: ol.MapBrowserEvent
    }
    declare module 'interaction' {

        /**
         * 
         * @classdesc  * Allows the user to zoom by double-clicking on the map.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
         */
        declare class DoubleClickZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom by double-clicking on the map.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DoubleClickZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
             * doubleclick) and eventually zooms the map.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.DoubleClickZoom}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Handles input of vector data by drag and drop.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @fires  ol.interaction.DragAndDropEvent
         * @param  Options.
         * @api  stable
         */
        declare class DragAndDrop mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Handles input of vector data by drag and drop.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @fires  ol.interaction.DragAndDropEvent
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DragAndDropOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} unconditionally and
             * neither prevents the browser default nor stops event propagation.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.DragAndDrop}
             * @api  
             */
            handleEvent: any
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.DragAndDrop} instances are instances
        of this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.interaction.DragAndDropEvent}
         * @param  Type.
         * @param  File.
         * @param  Features.
         * @param  Projection.
        */
        declare class DragAndDropEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.DragAndDrop} instances are instances
            of this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.interaction.DragAndDropEvent}
             * @param  Type.
             * @param  File.
             * @param  Features.
             * @param  Projection.
            */
            constructor(type: undefined.DragAndDropEventType, file: File, opt_features?: ol.Feature[], opt_projection?: undefined.Projection): this;

            /**
             * The features parsed from dropped data.
             * @type  * 
             * @api  stable
             */
            features: ol.Feature[];

            /**
             * The dropped file.
             * @type  * 
             * @api  stable
             */
            file: File;

            /**
             * The feature projection.
             * @type  * 
             * @api  
             */
            projection: undefined.Projection
        }
        declare type DragAndDropEventType = string;

        /**
         * 
         * @classdesc  * Allows the user to draw a vector box by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when the shift or other key is held down. This is used, for example,
        for zooming to a specific area of the map
        (see {
         * @link  ol.interaction.DragZoom} and
        {
         * @link  ol.interaction.DragRotateAndZoom}).

        This interaction is only supported for mouse devices.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.DragBoxEvent
         * @param  Options.
         * @api  stable
        */
        declare class DragBox mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to draw a vector box by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when the shift or other key is held down. This is used, for example,
            for zooming to a specific area of the map
            (see {
             * @link  ol.interaction.DragZoom} and
            {
             * @link  ol.interaction.DragRotateAndZoom}).

            This interaction is only supported for mouse devices.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.DragBoxEvent
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragBoxOptions): this;

            /**
             * Returns geometry of last drawn box.
             * @return  Geometry.
             * @api  stable
             */
            getGeometry(): undefined.Polygon
        }

        /**
         * 
         * @classdesc  * Allows the user to pan the map by dragging the map.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
         */
        declare class DragPan mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to pan the map by dragging the map.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DragPanOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to rotate the map by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when the alt and shift keys are held down.

        This interaction is only supported for mouse devices.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class DragRotate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to rotate the map by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when the alt and shift keys are held down.

            This interaction is only supported for mouse devices.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragRotateOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom and rotate the map by clicking and dragging
        on the map.  By default, this interaction is limited to when the shift
        key is held down.

        This interaction is only supported for mouse devices.

        And this interaction is not included in the default interactions.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class DragRotateAndZoom mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to zoom and rotate the map by clicking and dragging
            on the map.  By default, this interaction is limited to when the shift
            key is held down.

            This interaction is only supported for mouse devices.

            And this interaction is not included in the default interactions.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragRotateAndZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when a key, shift by default, is held down.

        To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
        your custom one configured with `className`.
         * @constructor  * 
         * @extends  {ol.interaction.DragBox}
         * @param  Options.
         * @api  stable
        */
        declare class DragZoom mixins undefined.DragBox {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when a key, shift by default, is held down.

            To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
            your custom one configured with `className`.
             * @constructor  * 
             * @extends  {ol.interaction.DragBox}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Draw} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.DrawEvent}
         * @param  Type.
         * @param  The feature drawn.
        */
        declare class DrawEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Draw} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.DrawEvent}
             * @param  Type.
             * @param  The feature drawn.
            */
            constructor(type: undefined.DrawEventType, feature: ol.Feature): this;

            /**
             * The feature being drawn.
             * @type  * 
             * @api  stable
             */
            feature: ol.Feature
        }
        declare type DrawEventType = string;

        /**
         * 
         * @classdesc  * Interaction for drawing feature geometries.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.interaction.DrawEvent
         * @param  Options.
         * @api  stable
         */
        declare class Draw mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for drawing feature geometries.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.interaction.DrawEvent
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.DrawOptions): this;

            /**
             * Remove last point of the feature currently being drawn.
             * @api  
             */
            removeLastPoint(): void;

            /**
             * Stop drawing and add the sketch feature to the target layer.
             * The {@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before
            inserting the feature.
             * @api  
            */
            finishDrawing(): void;

            /**
             * Extend an existing geometry by adding additional points. This only works
             * on features with `LineString` geometries, where the interaction will
            extend lines by adding points to the end of the coordinates array.
             * @param  Feature to be extended.
             * @api  
            */
            extend(feature: ol.Feature): void;

            /**
             * Create a `geometryFunction` for `mode: 'Circle'` that will create a regular
             * polygon with a user specified number of sides and start angle instead of an
            `ol.geom.Circle` geometry.
             * @param  Number of sides of the regular polygon. Default is
            32.
             * @param  Angle of the first point in radians. 0 means East.
            Default is the angle defined by the heading from the center of the
            regular polygon to the current pointer position.
             * @return  Function that draws a
            polygon.
             * @api  
            */
            createRegularPolygon(opt_sides?: number, opt_angle?: number): ol.DrawGeometryFunctionType
        }

        /**
         * Set of controls included in maps by default. Unless configured otherwise,
         * this returns a collection containing an instance of each of the following
        controls:
        * {@link ol.control.Zoom}
        * {@link ol.control.Rotate}
        * {@link ol.control.Attribution}
         * @param  Defaults options.
         * @return  Controls.
         * @api  stable
        */
        declare     function defaults(opt_options?: undefined.DefaultsOptions): ol.Collection<undefined.Control >

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            User actions that change the state of the map. Some are similar to controls,
            but are not associated with a DOM element.
            For example, {
             * @link  ol.interaction.KeyboardZoom} is functionally the same as
            {
             * @link  ol.control.Zoom}, but triggered by a keyboard event not a button
            element event.
            Although interactions do not have a DOM element, some of them do render
            vectors and so are visible on the screen.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.Object}
             * @api  
            */
            declare class Interaction mixins ol.Object {

                /**
                 * 
                 * @classdesc  * Abstract base class; normally only used for creating subclasses and not
                instantiated in apps.
                User actions that change the state of the map. Some are similar to controls,
                but are not associated with a DOM element.
                For example, {
                 * @link  ol.interaction.KeyboardZoom} is functionally the same as
                {
                 * @link  ol.control.Zoom}, but triggered by a keyboard event not a button
                element event.
                Although interactions do not have a DOM element, some of them do render
                vectors and so are visible on the screen.
                 * @constructor  * 
                 * @param  Options.
                 * @extends  {ol.Object}
                 * @api  
                */
                constructor(options: undefined.InteractionOptions): this;

                /**
                 * Return whether the interaction is currently active.
                 * @return  `true` if the interaction is active, `false` otherwise.
                 * @observable  * 
                 * @api  
                 */
                getActive(): boolean;

                /**
                 * Get the map associated with this interaction.
                 * @return  Map.
                 * @api  
                 */
                getMap(): ol.Map;

                /**
                 * Activate or deactivate the interaction.
                 * @param  Active.
                 * @observable  * 
                 * @api  
                 */
                setActive(active: boolean): void
            }

        /**
         * 
         * @classdesc  * Allows the user to pan the map using keyboard arrows.
        Note that, although this interaction is by default included in maps,
        the keys can only be used when browser focus is on the element to which
        the keyboard events are attached. By default, this is the map div,
        though you can change this with the `keyboardEventTarget` in
        {
         * @link  ol.Map}. `document` never loses focus but, for any other element,
        focus will have to be on, and returned to, this element if the keys are to
        function.
        See also {
         * @link  ol.interaction.KeyboardZoom}.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
        */
        declare class KeyboardPan mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to pan the map using keyboard arrows.
            Note that, although this interaction is by default included in maps,
            the keys can only be used when browser focus is on the element to which
            the keyboard events are attached. By default, this is the map div,
            though you can change this with the `keyboardEventTarget` in
            {
             * @link  ol.Map}. `document` never loses focus but, for any other element,
            focus will have to be on, and returned to, this element if the keys are to
            function.
            See also {
             * @link  ol.interaction.KeyboardZoom}.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.KeyboardPanOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
             * `KeyEvent`, and decides the direction to pan to (if an arrow key was
            pressed).
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.KeyboardPan}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map using keyboard + and -.
        Note that, although this interaction is by default included in maps,
        the keys can only be used when browser focus is on the element to which
        the keyboard events are attached. By default, this is the map div,
        though you can change this with the `keyboardEventTarget` in
        {
         * @link  ol.Map}. `document` never loses focus but, for any other element,
        focus will have to be on, and returned to, this element if the keys are to
        function.
        See also {
         * @link  ol.interaction.KeyboardPan}.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.interaction.Interaction}
         * @api  stable
        */
        declare class KeyboardZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map using keyboard + and -.
            Note that, although this interaction is by default included in maps,
            the keys can only be used when browser focus is on the element to which
            the keyboard events are attached. By default, this is the map div,
            though you can change this with the `keyboardEventTarget` in
            {
             * @link  ol.Map}. `document` never loses focus but, for any other element,
            focus will have to be on, and returned to, this element if the keys are to
            function.
            See also {
             * @link  ol.interaction.KeyboardPan}.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.interaction.Interaction}
             * @api  stable
            */
            constructor(opt_options?: undefined.KeyboardZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
             * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
            key pressed was '+' or '-').
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.KeyboardZoom}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Modify} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.ModifyEvent}
         * @param  Type.
         * @param  The features modified.
         * @param  Associated
        {
         * @link  ol.MapBrowserPointerEvent}.
        */
        declare class ModifyEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Modify} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.ModifyEvent}
             * @param  Type.
             * @param  The features modified.
             * @param  Associated
            {
             * @link  ol.MapBrowserPointerEvent}.
            */
            constructor(type: ol.ModifyEventType, features: ol.Collection<ol.Feature>, mapBrowserPointerEvent: ol.MapBrowserPointerEvent): this;

            /**
             * The features being modified.
             * @type  * 
             * @api  
             */
            features: ol.Collection<ol.Feature>;

            /**
             * Associated {@link ol.MapBrowserEvent}.
             * @type  * 
             * @api  
             */
            mapBrowserEvent: ol.MapBrowserEvent
        }

        /**
         * 
         * @classdesc  * Interaction for modifying feature geometries.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @fires  ol.interaction.ModifyEvent
         * @api  
         */
        declare class Modify mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for modifying feature geometries.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @fires  ol.interaction.ModifyEvent
             * @api  
             */
            constructor(options: undefined.ModifyOptions): this;

            /**
             * Removes the vertex currently being pointed.
             * @return  True when a vertex was removed.
             * @api  
             */
            removePoint(): boolean
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by scrolling the mouse wheel.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
         */
        declare class MouseWheelZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by scrolling the mouse wheel.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.MouseWheelZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
             * mousewheel-event) and eventually zooms the map.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.MouseWheelZoom}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean;

            /**
             * Enable or disable using the mouse's location as an anchor when zooming
             * @param  true to zoom to the mouse's location, false
            to zoom to the center of the map
             * @api  
            */
            setMouseAnchor(useAnchor: boolean): void
        }

        /**
         * 
         * @classdesc  * Allows the user to rotate the map by twisting with two fingers
        on a touch screen.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class PinchRotate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to rotate the map by twisting with two fingers
            on a touch screen.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.PinchRotateOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by pinching with two fingers
        on a touch screen.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class PinchZoom mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by pinching with two fingers
            on a touch screen.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.PinchZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Base class that calls user-defined functions on `down`, `move` and `up`
        events. This class also manages "drag sequences".

        When the `handleDownEvent` user function returns `true` a drag sequence is
        started. During a drag sequence the `handleDragEvent` user function is
        called on `move` events. The drag sequence ends when the `handleUpEvent`
        user function is called and returns `false`.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.interaction.Interaction}
         * @api  
        */
        declare class Pointer mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Base class that calls user-defined functions on `down`, `move` and `up`
            events. This class also manages "drag sequences".

            When the `handleDownEvent` user function returns `true` a drag sequence is
            started. During a drag sequence the `handleDragEvent` user function is
            called on `move` events. The drag sequence ends when the `handleUpEvent`
            user function is called and returns `false`.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.interaction.Interaction}
             * @api  
            */
            constructor(opt_options?: undefined.PointerOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
             * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
            detected.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.Pointer}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Select} instances are instances of
        this type.
         * @param  The event type.
         * @param  Selected features.
         * @param  Deselected features.
         * @param  Associated
        {
         * @link  ol.MapBrowserEvent}.
         * @implements  {oli.SelectEvent}
         * @extends  {ol.events.Event}
         * @constructor  
        */
        declare class SelectEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Select} instances are instances of
            this type.
             * @param  The event type.
             * @param  Selected features.
             * @param  Deselected features.
             * @param  Associated
            {
             * @link  ol.MapBrowserEvent}.
             * @implements  {oli.SelectEvent}
             * @extends  {ol.events.Event}
             * @constructor  
            */
            constructor(type: string, selected: ol.Feature[], deselected: ol.Feature[], mapBrowserEvent: ol.MapBrowserEvent): this;

            /**
             * Selected features array.
             * @type  * 
             * @api  
             */
            selected: ol.Feature[];

            /**
             * Deselected features array.
             * @type  * 
             * @api  
             */
            deselected: ol.Feature[];

            /**
             * Associated {@link ol.MapBrowserEvent}.
             * @type  * 
             * @api  
             */
            mapBrowserEvent: ol.MapBrowserEvent
        }

        /**
         * 
         * @classdesc  * Interaction for selecting vector features. By default, selected features are
        styled differently, so this interaction can be used for visual highlighting,
        as well as selecting features for other actions, such as modification or
        output. There are three ways of controlling which features are selected:
        using the browser event as defined by the `condition` and optionally the
        `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
        further feature filter using the `filter` option.

        Selected features are added to an internal unmanaged layer.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @fires  ol.interaction.SelectEvent
         * @api  stable
        */
        declare class Select mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Interaction for selecting vector features. By default, selected features are
            styled differently, so this interaction can be used for visual highlighting,
            as well as selecting features for other actions, such as modification or
            output. There are three ways of controlling which features are selected:
            using the browser event as defined by the `condition` and optionally the
            `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
            further feature filter using the `filter` option.

            Selected features are added to an internal unmanaged layer.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @fires  ol.interaction.SelectEvent
             * @api  stable
            */
            constructor(opt_options?: undefined.SelectOptions): this;

            /**
             * Get the selected features.
             * @return  Features collection.
             * @api  stable
             */
            getFeatures(): ol.Collection<ol.Feature>;

            /**
             * Returns the associated {@link ol.layer.Vector vectorlayer} of
             * the (last) selected feature. Note that this will not work with any
            programmatic method like pushing features to
            {
             * @link  ol.interaction.Select#getFeatures collection}.
             * @param  Feature
             * @return  Layer.
             * @api  
            */
            getLayer(feature: (ol.Feature | undefined.Feature)): undefined.Vector;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} and may change the
             * selected state of features.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.Select}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean;

            /**
             * Remove the interaction from its current map, if any,  and attach it to a new
             * map, if any. Pass `null` to just remove the interaction from the current map.
             * @param  Map.
             * @api  stable
             */
            setMap(map: ol.Map): void
        }

        /**
         * 
         * @classdesc  * Handles snapping of vector features while modifying or drawing them.  The
        features can come from a {
         * @link  ol.source.Vector} or {
         * @link  ol.Collection}
        Any interaction object that allows the user to interact
        with the features using the mouse can benefit from the snapping, as long
        as it is added before.

        The snap interaction modifies map browser event `coordinate` and `pixel`
        properties to force the snap to occur to any interaction that them.

        Example:

        var snap = new ol.interaction.Snap({
        source: source
        });
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  
        */
        declare class Snap mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Handles snapping of vector features while modifying or drawing them.  The
            features can come from a {
             * @link  ol.source.Vector} or {
             * @link  ol.Collection}
            Any interaction object that allows the user to interact
            with the features using the mouse can benefit from the snapping, as long
            as it is added before.

            The snap interaction modifies map browser event `coordinate` and `pixel`
            properties to force the snap to occur to any interaction that them.

            Example:

            var snap = new ol.interaction.Snap({
            source: source
            });
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.SnapOptions): this;

            /**
             * Add a feature to the collection of features that we may snap to.
             * @param  Feature.
             * @param  Whether to listen to the geometry change or not
            Defaults to `true`.
             * @api  
            */
            addFeature(feature: ol.Feature, opt_listen?: boolean): void;

            /**
             * Remove a feature from the collection of features that we may snap to.
             * @param  Feature
             * @param  Whether to unlisten to the geometry change
            or not. Defaults to `true`.
             * @api  
            */
            removeFeature(feature: ol.Feature, opt_unlisten?: boolean): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Translate} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.interaction.TranslateEvent}
         * @param  Type.
         * @param  The features translated.
         * @param  The event coordinate.
        */
        declare class TranslateEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Translate} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.interaction.TranslateEvent}
             * @param  Type.
             * @param  The features translated.
             * @param  The event coordinate.
            */
            constructor(type: undefined.TranslateEventType, features: ol.Collection<ol.Feature>, coordinate: ol.Coordinate): this;

            /**
             * The features being translated.
             * @type  * 
             * @api  
             */
            features: ol.Collection<ol.Feature>;

            /**
             * The coordinate of the drag event.
             * @const  * 
             * @type  * 
             * @api  
             */
            coordinate: ol.Coordinate
        }
        declare type TranslateEventType = string;

        /**
         * 
         * @classdesc  * Interaction for translating (moving) features.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.interaction.TranslateEvent
         * @param  Options.
         * @api  
         */
        declare class Translate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for translating (moving) features.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.interaction.TranslateEvent
             * @param  Options.
             * @api  
             */
            constructor(options: undefined.TranslateOptions): this
        }

        /**
         * Object literal with config options for interactions.
         * @typedef  
         */
        declare interface InteractionOptions {
            handleEvent: (event: ol.MapBrowserEvent) => boolean
        }

        /**
         * 
         * @typedef  *     attributionOptions: (olx.control.AttributionOptions|undefined),
        rotate: (boolean|undefined),
        rotateOptions: (olx.control.RotateOptions|undefined),
        zoom: (boolean|undefined),
        zoomOptions: (olx.control.ZoomOptions|undefined)}}
        */
        declare interface DefaultsOptions {
            attribution?: boolean,
                attributionOptions?: undefined.AttributionOptions,
                rotate?: boolean,
                rotateOptions?: undefined.RotateOptions,
                zoom?: boolean,
                zoomOptions?: undefined.ZoomOptions
        }

        /**
         * 
         * @typedef  *     delta: (number|undefined)}}
         */
        declare interface DoubleClickZoomOptions {
            duration?: number,
                delta?: number
        }

        /**
         * 
         * @typedef  >|undefined),
        projection: ol.ProjectionLike,
        target: (Element|undefined)}}
        */
        declare interface DragAndDropOptions {
            formatConstructors?: ((n: undefined.Feature) => any)[],
                projection: ol.ProjectionLike,
                target?: Element
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        boxEndCondition: (ol.DragBoxEndConditionType|undefined)}}
        */
        declare interface DragBoxOptions {
            className?: string,
                condition?: ol.EventsConditionType,
                boxEndCondition?: ol.DragBoxEndConditionType
        }

        /**
         * 
         * @typedef  *     kinetic: (ol.Kinetic|undefined)}}
         */
        declare interface DragPanOptions {
            condition?: ol.EventsConditionType,
                kinetic?: ol.Kinetic
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface DragRotateAndZoomOptions {
            condition?: ol.EventsConditionType,
                duration?: number
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface DragRotateOptions {
            condition?: ol.EventsConditionType,
                duration?: number
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        duration: (number|undefined),
        out: (boolean|undefined)}}
        */
        declare interface DragZoomOptions {
            className?: string,
                condition?: ol.EventsConditionType,
                duration?: number,
                out?: boolean
        }

        /**
         * 
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        source: (ol.source.Vector|undefined),
        snapTolerance: (number|undefined),
        type: ol.geom.GeometryType,
        maxPoints: (number|undefined),
        minPoints: (number|undefined),
        finishCondition: (ol.EventsConditionType|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        geometryFunction: (ol.DrawGeometryFunctionType|undefined),
        geometryName: (string|undefined),
        condition: (ol.EventsConditionType|undefined),
        freehandCondition: (ol.EventsConditionType|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface DrawOptions {
            clickTolerance?: number,
                features?: ol.Collection<ol.Feature>,
                source?: undefined.Vector,
                snapTolerance?: number,
                type: undefined.GeometryType,
                maxPoints?: number,
                minPoints?: number,
                finishCondition?: ol.EventsConditionType,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                geometryFunction?: ol.DrawGeometryFunctionType,
                geometryName?: string,
                condition?: ol.EventsConditionType,
                freehandCondition?: ol.EventsConditionType,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        layers: (undefined|Array.<ol.layer.Layer>|function(ol.layer.Layer): boolean)
        }}
        */
        declare interface TranslateOptions {
            features?: ol.Collection<ol.Feature>,
                layers?: (undefined.Layer[] | ((layer: undefined.Layer) => boolean))
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined),
        pixelDelta: (number|undefined)}}
        */
        declare interface KeyboardPanOptions {
            condition?: ol.EventsConditionType,
                duration?: number,
                pixelDelta?: number
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        delta: (number|undefined)}}
        */
        declare interface KeyboardZoomOptions {
            duration?: number,
                condition?: ol.EventsConditionType,
                delta?: number
        }

        /**
         * 
         * @typedef  *     deleteCondition: (ol.EventsConditionType|undefined),
        pixelTolerance: (number|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        features: ol.Collection.<ol.Feature>,
        wrapX: (boolean|undefined)}}
        */
        declare interface ModifyOptions {
            condition?: ol.EventsConditionType,
                deleteCondition?: ol.EventsConditionType,
                pixelTolerance?: number,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                features: ol.Collection<ol.Feature>,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     useAnchor: (boolean|undefined)}}
         */
        declare interface MouseWheelZoomOptions {
            duration?: number,
                useAnchor?: boolean
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface PinchRotateOptions {
            duration?: number,
                threshold?: number
        }

        /**
         * 
         * @typedef  
         */
        declare interface PinchZoomOptions {
            duration?: number
        }

        /**
         * 
         * @typedef  *     handleDragEvent: (function(ol.MapBrowserPointerEvent)|undefined),
        handleEvent: (function(ol.MapBrowserEvent):boolean|undefined),
        handleMoveEvent: (function(ol.MapBrowserPointerEvent)|undefined),
        handleUpEvent: (function(ol.MapBrowserPointerEvent):boolean|undefined)}}
        */
        declare interface PointerOptions {
            handleDownEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleDragEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleMoveEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleUpEvent?: ((event: ol.MapBrowserPointerEvent) => boolean)
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        layers: (undefined|Array.<ol.layer.Layer>|function(ol.layer.Layer): boolean),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        removeCondition: (ol.EventsConditionType|undefined),
        toggleCondition: (ol.EventsConditionType|undefined),
        multi: (boolean|undefined),
        features: (ol.Collection.<ol.Feature>|undefined),
        filter: (ol.SelectFilterFunction|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface SelectOptions {
            addCondition?: ol.EventsConditionType,
                condition?: ol.EventsConditionType,
                layers?: (undefined.Layer[] | ((layer: undefined.Layer) => boolean)),
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                removeCondition?: ol.EventsConditionType,
                toggleCondition?: ol.EventsConditionType,
                multi?: boolean,
                features?: ol.Collection<ol.Feature>,
                filter?: ol.SelectFilterFunction,
                wrapX?: boolean
        }

        /**
         * Options for snap
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        pixelTolerance: (number|undefined),
        source: (ol.source.Vector|undefined),
        edge: (boolean|undefined),
        vertex: (boolean|undefined)
        }}
        */
        declare interface SnapOptions {
            features?: ol.Collection<ol.Feature>,
                edge?: boolean,
                vertex?: boolean,
                pixelTolerance?: number,
                source?: undefined.Vector
        }
    }


    /**
     * 
     * @classdesc  * Implementation of inertial deceleration for map movement.
     * @constructor  * 
     * @param  Rate of decay (must be negative).
     * @param  Minimum velocity (pixels/millisecond).
     * @param  Delay to consider to calculate the kinetic
    initial values (milliseconds).
     * @struct  * 
     * @api  
    */
    declare class Kinetic {

        /**
         * 
         * @classdesc  * Implementation of inertial deceleration for map movement.
         * @constructor  * 
         * @param  Rate of decay (must be negative).
         * @param  Minimum velocity (pixels/millisecond).
         * @param  Delay to consider to calculate the kinetic
        initial values (milliseconds).
         * @struct  * 
         * @api  
        */
        constructor(decay: number, minVelocity: number, delay: number): this
    }
    declare module 'layer' {

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Note that with `ol.layer.Base` and all its subclasses, any property set in
        the options is set as a {
         * @link  ol.Object} property on the layer object, so
        is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Layer options.
         * @api  stable
        */
        declare class Base mixins ol.Object {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Note that with `ol.layer.Base` and all its subclasses, any property set in
            the options is set as a {
             * @link  ol.Object} property on the layer object, so
            is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.Object}
             * @param  Layer options.
             * @api  stable
            */
            constructor(options: undefined.BaseOptions): this;

            /**
             * Return the {@link ol.Extent extent} of the layer or `undefined` if it
             * will be visible regardless of extent.
             * @return  The layer extent.
             * @observable  * 
             * @api  stable
             */
            getExtent(): (ol.Extent);

            /**
             * Return the maximum resolution of the layer.
             * @return  The maximum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            getMaxResolution(): number;

            /**
             * Return the minimum resolution of the layer.
             * @return  The minimum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            getMinResolution(): number;

            /**
             * Return the opacity of the layer (between 0 and 1).
             * @return  The opacity of the layer.
             * @observable  * 
             * @api  stable
             */
            getOpacity(): number;

            /**
             * Return the visibility of the layer (`true` or `false`).
             * @return  The visibility of the layer.
             * @observable  * 
             * @api  stable
             */
            getVisible(): boolean;

            /**
             * Return the Z-index of the layer, which is used to order layers before
             * rendering. The default Z-index is 0.
             * @return  The Z-index of the layer.
             * @observable  * 
             * @api  
             */
            getZIndex(): number;

            /**
             * Set the extent at which the layer is visible.  If `undefined`, the layer
             * will be visible at all extents.
             * @param  The extent of the layer.
             * @observable  * 
             * @api  stable
             */
            setExtent(extent: (ol.Extent)): void;

            /**
             * Set the maximum resolution at which the layer is visible.
             * @param  The maximum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            setMaxResolution(maxResolution: number): void;

            /**
             * Set the minimum resolution at which the layer is visible.
             * @param  The minimum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            setMinResolution(minResolution: number): void;

            /**
             * Set the opacity of the layer, allowed values range from 0 to 1.
             * @param  The opacity of the layer.
             * @observable  * 
             * @api  stable
             */
            setOpacity(opacity: number): void;

            /**
             * Set the visibility of the layer (`true` or `false`).
             * @param  The visibility of the layer.
             * @observable  * 
             * @api  stable
             */
            setVisible(visible: boolean): void;

            /**
             * Set Z-index of the layer, which is used to order layers before rendering.
             * The default Z-index is 0.
             * @param  The z-index of the layer.
             * @observable  * 
             * @api  
             */
            setZIndex(zindex: number): void
        }

        /**
         * 
         * @classdesc  * A {
         * @link  ol.Collection} of layers that are handled together.

        A generic `change` event is triggered when the group/Collection changes.
         * @constructor  * 
         * @extends  {ol.layer.Base}
         * @param  Layer options.
         * @api  stable
        */
        declare class Group mixins undefined.Base {

            /**
             * 
             * @classdesc  * A {
             * @link  ol.Collection} of layers that are handled together.

            A generic `change` event is triggered when the group/Collection changes.
             * @constructor  * 
             * @extends  {ol.layer.Base}
             * @param  Layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.GroupOptions): this;

            /**
             * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
             * in this group.
             * @return  Collection of
            {
             * @link  ol.layer.Base layers} that are part of this group.
             * @observable  * 
             * @api  stable
            */
            getLayers(): ol.Collection<undefined.Base>;

            /**
             * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
             * in this group.
             * @param  Collection of
            {
             * @link  ol.layer.Base layers} that are part of this group.
             * @observable  * 
             * @api  stable
            */
            setLayers(layers: ol.Collection<undefined.Base>): void
        }

        /**
         * 
         * @classdesc  * Layer for rendering vector data as a heatmap.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Vector}
         * @fires  ol.render.Event
         * @param  Options.
         * @api  
        */
        declare class Heatmap mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer for rendering vector data as a heatmap.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Vector}
             * @fires  ol.render.Event
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.HeatmapOptions): this;

            /**
             * Return the blur size in pixels.
             * @return  Blur size in pixels.
             * @api  * 
             * @observable  
             */
            getBlur(): number;

            /**
             * Return the gradient colors as array of strings.
             * @return  Colors.
             * @api  * 
             * @observable  
             */
            getGradient(): string[];

            /**
             * Return the size of the radius in pixels.
             * @return  Radius size in pixel.
             * @api  * 
             * @observable  
             */
            getRadius(): number;

            /**
             * Set the blur size in pixels.
             * @param  Blur size in pixels.
             * @api  * 
             * @observable  
             */
            setBlur(blur: number): void;

            /**
             * Set the gradient colors as array of strings.
             * @param  Gradient.
             * @api  * 
             * @observable  
             */
            setGradient(colors: string[]): void;

            /**
             * Set the size of the radius in pixels.
             * @param  Radius size in pixel.
             * @api  * 
             * @observable  
             */
            setRadius(radius: number): void
        }

        /**
         * 
         * @classdesc  * Server-rendered images that are available for arbitrary extents and
        resolutions.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Layer options.
         * @api  stable
        */
        declare class Image mixins undefined.Layer {

            /**
             * 
             * @classdesc  * Server-rendered images that are available for arbitrary extents and
            resolutions.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ImageOptions): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        A visual representation of raster or vector map data.
        Layers group together those properties that pertain to how the data is to be
        displayed, irrespective of the source of that data.

        Layers are usually added to a map with {
         * @link  ol.Map#addLayer}. Components
        like {
         * @link  ol.interaction.Select} use unmanaged layers internally. These
        unmanaged layers are associated with the map using
        {
         * @link  ol.layer.Layer#setMap} instead.

        A generic `change` event is fired when the state of the source changes.
         * @constructor  * 
         * @extends  {ol.layer.Base}
         * @fires  ol.render.Event
         * @param  Layer options.
         * @api  stable
        */
        declare class Layer mixins undefined.Base {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            A visual representation of raster or vector map data.
            Layers group together those properties that pertain to how the data is to be
            displayed, irrespective of the source of that data.

            Layers are usually added to a map with {
             * @link  ol.Map#addLayer}. Components
            like {
             * @link  ol.interaction.Select} use unmanaged layers internally. These
            unmanaged layers are associated with the map using
            {
             * @link  ol.layer.Layer#setMap} instead.

            A generic `change` event is fired when the state of the source changes.
             * @constructor  * 
             * @extends  {ol.layer.Base}
             * @fires  ol.render.Event
             * @param  Layer options.
             * @api  stable
            */
            constructor(options: undefined.LayerOptions): this;

            /**
             * Get the layer source.
             * @return  The layer source (or `null` if not yet set).
             * @observable  * 
             * @api  stable
             */
            getSource(): undefined.Source;

            /**
             * Sets the layer to be rendered on top of other layers on a map. The map will
             * not manage this layer in its layers collection, and the callback in
            {
             * @link  ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
            is useful for temporary layers. To remove an unmanaged layer from the map,
            use `#setMap(null)`.

            To add the layer to a map and have it managed by the map, use
            {
             * @link  ol.Map#addLayer} instead.
             * @param  Map.
             * @api  
            */
            setMap(map: ol.Map): void;

            /**
             * Set the layer source.
             * @param  The layer source.
             * @observable  * 
             * @api  stable
             */
            setSource(source: undefined.Source): void
        }

        /**
         * 
         * @classdesc  * For layer sources that provide pre-rendered, tiled images in grids that are
        organized by zoom levels for specific resolutions.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Tile layer options.
         * @api  stable
        */
        declare class Tile mixins undefined.Layer {

            /**
             * 
             * @classdesc  * For layer sources that provide pre-rendered, tiled images in grids that are
            organized by zoom levels for specific resolutions.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Tile layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.TileOptions): this;

            /**
             * Return the level as number to which we will preload tiles up to.
             * @return  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            getPreload(): number;

            /**
             * Set the level as number to which we will preload tiles up to.
             * @param  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            setPreload(preload: number): void;

            /**
             * Whether we use interim tiles on error.
             * @return  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            getUseInterimTilesOnError(): boolean;

            /**
             * Set whether we use interim tiles on error.
             * @param  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            setUseInterimTilesOnError(useInterimTilesOnError: boolean): void
        }

        /**
         * 
         * @classdesc  * Vector data that is rendered client-side.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Options.
         * @api  stable
        */
        declare class Vector mixins undefined.Layer {

            /**
             * 
             * @classdesc  * Vector data that is rendered client-side.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.VectorOptions): this;

            /**
             * Return the associated {@link ol.source.Vector vectorsource} of the layer.
             * @return  Source.
             * @api  stable
             */
            getSource(): undefined.Vector;

            /**
             * Get the style for features.  This returns whatever was passed to the `style`
             * option at construction or to the `setStyle` method.
             * @return  *     Layer style.
             * @api  stable
             */
            getStyle(): (undefined.Style | undefined.Style[] | ol.StyleFunction);

            /**
             * Get the style function.
             * @return  Layer style function.
             * @api  stable
             */
            getStyleFunction(): (ol.StyleFunction);

            /**
             * Set the style for features.  This can be a single style object, an array
             * of styles, or a function that takes a feature and resolution and returns
            an array of styles. If it is `undefined` the default style is used. If
            it is `null` the layer has no style (a `null` style), so only features
            that have their own styles will be rendered in the layer. See
            {style Layer style.
             * @link  ol.style} for information on the default style.
             * @api  stable
            */
            setStyle(style: (undefined.Style | undefined.Style[] | ol.StyleFunction)): void
        }

        /**
         * 
         * @enum  {string}
        Render mode for vector tiles:
        * `'image'`: Vector tiles are rendered as images. Great performance, but
        point symbols and texts are always rotated with the view and pixels are
        scaled during zoom animations.
        * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
        are scaled during zoom animations. Point symbols and texts are accurately
        rendered as vectors and can stay upright on rotated views.
        * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
        even during animations, but slower performance than the other options.
         * @api  
        */
        declare type VectorTileRenderType = string;

        /**
         * 
         * @classdesc  * Layer for vector tile data that is rendered client-side.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Vector}
         * @param  Options.
         * @api  
        */
        declare class VectorTile mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer for vector tile data that is rendered client-side.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Vector}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.VectorTileOptions): this;

            /**
             * Return the level as number to which we will preload tiles up to.
             * @return  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            getPreload(): number;

            /**
             * Whether we use interim tiles on error.
             * @return  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            getUseInterimTilesOnError(): boolean;

            /**
             * Set the level as number to which we will preload tiles up to.
             * @param  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            setPreload(preload: number): void;

            /**
             * Set whether we use interim tiles on error.
             * @param  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            setUseInterimTilesOnError(useInterimTilesOnError: boolean): void
        }

        /**
         * 
         * @typedef  *     visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface BaseOptions {
            opacity?: number,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     source: (ol.source.Source|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface LayerOptions {
            opacity?: number,
                source?: undefined.Source,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        layers: (Array.<ol.layer.Base>|ol.Collection.<ol.layer.Base>|undefined)}}
        */
        declare interface GroupOptions {
            opacity?: number,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number,
                layers?: (undefined.Base[] | ol.Collection<undefined.Base>)
        }

        /**
         * 
         * @typedef  *     radius: (number|undefined),
        blur: (number|undefined),
        shadow: (number|undefined),
        weight: (string|function(ol.Feature):number|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        source: (ol.source.Vector|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface HeatmapOptions {
            gradient?: string[],
                radius?: number,
                blur?: number,
                shadow?: number,
                weight: (string | ((feature: ol.Feature) => number)),
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source: undefined.Vector,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        source: (ol.source.Image|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface ImageOptions {
            opacity?: number,
                source: undefined.Image,
                map?: ol.Map,
                visible?: boolean,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     preload: (number|undefined),
        source: (ol.source.Tile|undefined),
        map: (ol.Map|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        useInterimTilesOnError: (boolean|undefined)}}
        */
        declare interface TileOptions {
            opacity?: number,
                preload?: number,
                source: undefined.Tile,
                map?: ol.Map,
                visible?: boolean,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                useInterimTilesOnError?: boolean
        }

        /**
         * 
         * @typedef  *     minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        source: (ol.source.Vector|undefined),
        map: (ol.Map|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorOptions {
            renderOrder?: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                renderBuffer?: number,
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        renderMode: (ol.layer.VectorTileRenderType|string|undefined),
        renderOrder: (function(ol.Feature, ol.Feature):number|undefined),
        source: (ol.source.VectorTile|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorTileOptions {
            renderBuffer?: number,
                renderMode?: (undefined.VectorTileRenderType | string),
                renderOrder: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source?: undefined.VectorTile,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }
    }

    declare module 'loadingstrategy' {

        /**
         * Strategy function for loading all features with a single request.
         * @param  Extent.
         * @param  Resolution.
         * @return  Extents.
         * @api  
         */
        declare     function all(extent: ol.Extent, resolution: number): ol.Extent[]

        /**
         * Strategy function for loading features based on the view's extent and
         * resolution.
         * @param  Extent.
         * @param  Resolution.
         * @return  Extents.
         * @api  
         */
        declare     function bbox(extent: ol.Extent, resolution: number): ol.Extent[]

        /**
         * Create an XHR feature loader for a `url` and `format`. The feature loader
         * loads features (with XHR), parses the features, and adds them to the
        vector tile.
         * @param  Feature URL service.
         * @param  Feature format.
         * @return  The feature loader.
         * @api  
        */
        declare     function tile(
            url: (string | ol.FeatureUrlFunction),
            format: undefined.Feature): ol.FeatureLoader
    }


    /**
     * 
     * @classdesc  * The map is the core component of OpenLayers. For a map to render, a view,
    one or more layers, and a target container are needed:

    var map = new ol.Map({
    view: new ol.View({
    center: [0, 0],
    zoom: 1
    }),
    layers: [
    new ol.layer.Tile({
    source: new ol.source.OSM()
    })
    ],
    target: 'map'
    });

    The above snippet creates a map using a {
     * @link  ol.layer.Tile} to display
    {
     * @link  ol.source.OSM} OSM data and render it to a DOM element with the
    id `map`.

    The constructor places a viewport container (with CSS class name
    `ol-viewport`) in the target element (see `getViewport()`), and then two
    further elements within the viewport: one with CSS class name
    `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
    CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
    option of {
     * @link  ol.Overlay} for the difference). The map itself is placed in
    a further element within the viewport, either DOM or Canvas, depending on the
    renderer.

    Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
    provided by the library. This is what is accessed by `getLayerGroup` and
    `setLayerGroup`. Layers entered in the options are added to this group, and
    `addLayer` and `removeLayer` change the layer collection in the group.
    `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
    Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
    entered in the options or added with `addLayer` can be groups, which can
    contain further groups, and so on.
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  Map options.
     * @fires  ol.MapBrowserEvent
     * @fires  ol.MapEvent
     * @fires  ol.render.Event#postcompose
     * @fires  ol.render.Event#precompose
     * @api  stable
    */
    declare class Map mixins ol.Object {

        /**
         * 
         * @classdesc  * The map is the core component of OpenLayers. For a map to render, a view,
        one or more layers, and a target container are needed:

        var map = new ol.Map({
        view: new ol.View({
        center: [0, 0],
        zoom: 1
        }),
        layers: [
        new ol.layer.Tile({
        source: new ol.source.OSM()
        })
        ],
        target: 'map'
        });

        The above snippet creates a map using a {
         * @link  ol.layer.Tile} to display
        {
         * @link  ol.source.OSM} OSM data and render it to a DOM element with the
        id `map`.

        The constructor places a viewport container (with CSS class name
        `ol-viewport`) in the target element (see `getViewport()`), and then two
        further elements within the viewport: one with CSS class name
        `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
        CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
        option of {
         * @link  ol.Overlay} for the difference). The map itself is placed in
        a further element within the viewport, either DOM or Canvas, depending on the
        renderer.

        Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
        provided by the library. This is what is accessed by `getLayerGroup` and
        `setLayerGroup`. Layers entered in the options are added to this group, and
        `addLayer` and `removeLayer` change the layer collection in the group.
        `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
        Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
        entered in the options or added with `addLayer` can be groups, which can
        contain further groups, and so on.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Map options.
         * @fires  ol.MapBrowserEvent
         * @fires  ol.MapEvent
         * @fires  ol.render.Event#postcompose
         * @fires  ol.render.Event#precompose
         * @api  stable
        */
        constructor(options: olx.MapOptions): this;

        /**
         * Add the given control to the map.
         * @param  Control.
         * @api  stable
         */
        addControl(control: undefined.Control): void;

        /**
         * Add the given interaction to the map.
         * @param  Interaction to add.
         * @api  stable
         */
        addInteraction(interaction: undefined.Interaction): void;

        /**
         * Adds the given layer to the top of this map. If you want to add a layer
         * elsewhere in the stack, use `getLayers()` and the methods available on
        {
         * @link  ol.Collection}.
         * @param  Layer.
         * @api  stable
        */
        addLayer(layer: undefined.Base): void;

        /**
         * Add the given overlay to the map.
         * @param  Overlay.
         * @api  stable
         */
        addOverlay(overlay: ol.Overlay): void;

        /**
         * Add functions to be called before rendering. This can be used for attaching
         * animations before updating the map's view.  The {@link ol.animation}
        namespace provides several static methods for creating prerender functions.
         * @param  Any number of pre-render functions.
         * @api  
        */
        beforeRender(var_args: ol.PreRenderFunction): void;

        /**
         * Detect features that intersect a pixel on the viewport, and execute a
         * callback with each intersecting feature. Layers included in the detection can
        be configured through `opt_layerFilter`.
         * @param  Pixel.
         * @param  Feature callback. The callback will be
        called with two arguments. The first argument is one
        {
         * @link  ol.Feature feature} or
        {
         * @link  ol.render.Feature render feature} at the pixel, the second is
        the {
         * @link  ol.layer.Layer layer} of the feature and will be null for
        unmanaged layers. To stop detection, callback functions can return a
        truthy value.
         * @param  Value to use as `this` when executing `callback`.
         * @param  Layer
        filter function. The filter function will receive one argument, the
        {
         * @link  ol.layer.Layer layer-candidate} and it should return a boolean
        value. Only layers which are visible and for which this function returns
        `true` will be tested for features. By default, all visible layers will
        be tested.
         * @param  Value to use as `this` when executing `layerFilter`.
         * @return  Callback result, i.e. the return value of last
        callback execution, or the first truthy callback return value.
         * @template  * 
         * @api  stable
        */
        forEachFeatureAtPixel<S, T, U>(
            pixel: ol.Pixel,
            callback: ((feature: (ol.Feature | undefined.Feature), layer: undefined.Layer) => T),
            opt_this?: S,
            opt_layerFilter?: ((layer: undefined.Layer) => boolean),
            opt_this2?: U): (T);

        /**
         * Detect layers that have a color value at a pixel on the viewport, and
         * execute a callback with each matching layer. Layers included in the
        detection can be configured through `opt_layerFilter`.
         * @param  Pixel.
         * @param  Layer
        callback. This callback will recieve two arguments: first is the
        {
         * @link  ol.layer.Layer layer}, second argument is {
         * @link  ol.Color}
        and will be null for layer types that do not currently support this
        argument. To stop detection callback functions can return a truthy value.
         * @param  Value to use as `this` when executing `callback`.
         * @param  Layer
        filter function. The filter function will receive one argument, the
        {
         * @link  ol.layer.Layer layer-candidate} and it should return a boolean
        value. Only layers which are visible and for which this function returns
        `true` will be tested for features. By default, all visible layers will
        be tested.
         * @param  Value to use as `this` when executing `layerFilter`.
         * @return  Callback result, i.e. the return value of last
        callback execution, or the first truthy callback return value.
         * @template  * 
         * @api  stable
        */
        forEachLayerAtPixel<S, T, U>(
            pixel: ol.Pixel,
            callback: ((layer: undefined.Layer, color: ol.Color) => T),
            opt_this?: S,
            opt_layerFilter?: ((layer: undefined.Layer) => boolean),
            opt_this2?: U): (T);

        /**
         * Detect if features intersect a pixel on the viewport. Layers included in the
         * detection can be configured through `opt_layerFilter`.
         * @param  Pixel.
         * @param  Layer
        filter function. The filter function will receive one argument, the
        {
         * @link  ol.layer.Layer layer-candidate} and it should return a boolean
        value. Only layers which are visible and for which this function returns
        `true` will be tested for features. By default, all visible layers will
        be tested.
         * @param  Value to use as `this` when executing `layerFilter`.
         * @return  Is there a feature at the given pixel?
         * @template  * 
         * @api  
        */
        hasFeatureAtPixel<U>(
            pixel: ol.Pixel,
            opt_layerFilter?: ((layer: undefined.Layer) => boolean),
            opt_this?: U): boolean;

        /**
         * Returns the geographical coordinate for a browser event.
         * @param  Event.
         * @return  Coordinate.
         * @api  stable
         */
        getEventCoordinate(event: Event): ol.Coordinate;

        /**
         * Returns the map pixel position for a browser event relative to the viewport.
         * @param  Event.
         * @return  Pixel.
         * @api  stable
         */
        getEventPixel(event: Event): ol.Pixel;

        /**
         * Get the target in which this map is rendered.
         * Note that this returns what is entered as an option or in setTarget:
        if that was an element, it returns an element; if a string, it returns that.
         * @return  The Element or id of the Element that the
        map is rendered in.
         * @observable  * 
         * @api  stable
        */
        getTarget(): (Element | string);

        /**
         * Get the DOM element into which this map is rendered. In contrast to
         * `getTarget` this method always return an `Element`, or `null` if the
        map has no target.
         * @return  The element that the map is rendered in.
         * @api  
        */
        getTargetElement(): Element;

        /**
         * Get the coordinate for a given pixel.  This returns a coordinate in the
         * map view projection.
         * @param  Pixel position in the map viewport.
         * @return  The coordinate for the pixel position.
         * @api  stable
         */
        getCoordinateFromPixel(pixel: ol.Pixel): ol.Coordinate;

        /**
         * Get the map controls. Modifying this collection changes the controls
         * associated with the map.
         * @return  Controls.
         * @api  stable
         */
        getControls(): ol.Collection<undefined.Control>;

        /**
         * Get the map overlays. Modifying this collection changes the overlays
         * associated with the map.
         * @return  Overlays.
         * @api  stable
         */
        getOverlays(): ol.Collection<ol.Overlay>;

        /**
         * Get an overlay by its identifier (the value returned by overlay.getId()).
         * Note that the index treats string and numeric identifiers as the same. So
        `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
         * @param  Overlay identifier.
         * @return  Overlay.
         * @api  
        */
        getOverlayById(id: (string | number)): ol.Overlay;

        /**
         * Get the map interactions. Modifying this collection changes the interactions
         * associated with the map.

        Interactions are used for e.g. pan, zoom and rotate.
         * @return  Interactions.
         * @api  stable
        */
        getInteractions(): ol.Collection<undefined.Interaction>;

        /**
         * Get the layergroup associated with this map.
         * @return  A layer group containing the layers in this map.
         * @observable  * 
         * @api  stable
         */
        getLayerGroup(): undefined.Group;

        /**
         * Get the collection of layers associated with this map.
         * @return  Layers.
         * @api  stable
         */
        getLayers(): ol.Collection<undefined.Base>;

        /**
         * Get the pixel for a coordinate.  This takes a coordinate in the map view
         * projection and returns the corresponding pixel.
         * @param  A map coordinate.
         * @return  A pixel position in the map viewport.
         * @api  stable
         */
        getPixelFromCoordinate(coordinate: ol.Coordinate): ol.Pixel;

        /**
         * Get the size of this map.
         * @return  The size in pixels of the map in the DOM.
         * @observable  * 
         * @api  stable
         */
        getSize(): (ol.Size);

        /**
         * Get the view associated with this map. A view manages properties such as
         * center and resolution.
         * @return  The view that controls this map.
         * @observable  * 
         * @api  stable
         */
        getView(): ol.View;

        /**
         * Get the element that serves as the map viewport.
         * @return  Viewport.
         * @api  stable
         */
        getViewport(): Element;

        /**
         * Requests an immediate render in a synchronous manner.
         * @api  stable
         */
        renderSync(): void;

        /**
         * Request a map rendering (at the next animation frame).
         * @api  stable
         */
        render(): void;

        /**
         * Remove the given control from the map.
         * @param  Control.
         * @return  The removed control (or undefined
        if the control was not found).
         * @api  stable
        */
        removeControl(control: undefined.Control): (undefined.Control);

        /**
         * Remove the given interaction from the map.
         * @param  Interaction to remove.
         * @return  The removed interaction (or
        undefined if the interaction was not found).
         * @api  stable
        */
        removeInteraction(interaction: undefined.Interaction): (undefined.Interaction);

        /**
         * Removes the given layer from the map.
         * @param  Layer.
         * @return  The removed layer (or undefined if the
        layer was not found).
         * @api  stable
        */
        removeLayer(layer: undefined.Base): (undefined.Base);

        /**
         * Remove the given overlay from the map.
         * @param  Overlay.
         * @return  The removed overlay (or undefined
        if the overlay was not found).
         * @api  stable
        */
        removeOverlay(overlay: ol.Overlay): (ol.Overlay);

        /**
         * Sets the layergroup of this map.
         * @param  A layer group containing the layers in
        this map.
         * @observable  * 
         * @api  stable
        */
        setLayerGroup(layerGroup: undefined.Group): void;

        /**
         * Set the size of this map.
         * @param  The size in pixels of the map in the DOM.
         * @observable  * 
         * @api  
         */
        setSize(size: (ol.Size)): void;

        /**
         * Set the target element to render this map into.
         * @param  The Element or id of the Element
        that the map is rendered in.
         * @observable  * 
         * @api  stable
        */
        setTarget(target: (Element | string)): void;

        /**
         * Set the view for this map.
         * @param  The view that controls this map.
         * @observable  * 
         * @api  stable
         */
        setView(view: ol.View): void;

        /**
         * Force a recalculation of the map viewport size.  This should be called when
         * third-party code changes the size of the map viewport.
         * @api  stable
         */
        updateSize(): void
    }

    /**
     * 
     * @classdesc  * Events emitted as map browser events are instances of this type.
    See {
     * @link  ol.Map} for which events trigger a map browser event.
     * @constructor  * 
     * @extends  {ol.MapEvent}
     * @implements  {oli.MapBrowserEvent}
     * @param  Event type.
     * @param  Map.
     * @param  Browser event.
     * @param  Is the map currently being dragged?
     * @param  Frame state.
    */
    declare class MapBrowserEvent mixins ol.MapEvent {

        /**
         * 
         * @classdesc  * Events emitted as map browser events are instances of this type.
        See {
         * @link  ol.Map} for which events trigger a map browser event.
         * @constructor  * 
         * @extends  {ol.MapEvent}
         * @implements  {oli.MapBrowserEvent}
         * @param  Event type.
         * @param  Map.
         * @param  Browser event.
         * @param  Is the map currently being dragged?
         * @param  Frame state.
        */
        constructor(type: string, map: ol.Map, browserEvent: Event, opt_dragging?: boolean, opt_frameState?: olx.FrameState): this;

        /**
         * The original browser event.
         * @const  * 
         * @type  * 
         * @api  stable
         */
        originalEvent: Event;

        /**
         * The pixel of the original browser event.
         * @type  * 
         * @api  stable
         */
        pixel: ol.Pixel;

        /**
         * The coordinate of the original browser event.
         * @type  * 
         * @api  stable
         */
        coordinate: ol.Coordinate;

        /**
         * Indicates if the map is currently being dragged. Only set for
         * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
         * @type  * 
         * @api  stable
         */
        dragging: boolean
    }

    /**
     * 
     * @constructor  * 
     * @extends  {ol.MapBrowserEvent}
     * @param  Event type.
     * @param  Map.
     * @param  Pointer event.
     * @param  Is the map currently being dragged?
     * @param  Frame state.
     */
    declare class MapBrowserPointerEvent mixins ol.MapBrowserEvent {
        pointerEvent: undefined.PointerEvent
    }

    /**
     * 
     * @classdesc  * Events emitted as map events are instances of this type.
    See {
     * @link  ol.Map} for which events trigger a map event.
     * @constructor  * 
     * @extends  {ol.events.Event}
     * @implements  {oli.MapEvent}
     * @param  Event type.
     * @param  Map.
     * @param  Frame state.
    */
    declare class MapEvent mixins undefined.Event {

        /**
         * 
         * @classdesc  * Events emitted as map events are instances of this type.
        See {
         * @link  ol.Map} for which events trigger a map event.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.MapEvent}
         * @param  Event type.
         * @param  Map.
         * @param  Frame state.
        */
        constructor(type: string, map: ol.Map, opt_frameState?: olx.FrameState): this;

        /**
         * The map where the event occurred.
         * @type  * 
         * @api  stable
         */
        map: ol.Map;

        /**
         * The frame state at the time of the event.
         * @type  * 
         * @api  
         */
        frameState: olx.FrameState
    }

    /**
     * 
     * @classdesc  * Events emitted by {
     * @link  ol.Object} instances are instances of this type.
     * @param  The event type.
     * @param  The property name.
     * @param  The old value for `key`.
     * @extends  {ol.events.Event}
     * @implements  {oli.ObjectEvent}
     * @constructor  
     */
    declare class ObjectEvent mixins undefined.Event {

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.Object} instances are instances of this type.
         * @param  The event type.
         * @param  The property name.
         * @param  The old value for `key`.
         * @extends  {ol.events.Event}
         * @implements  {oli.ObjectEvent}
         * @constructor  
         */
        constructor(type: string, key: string, oldValue: any): this;

        /**
         * The name of the property whose value is changing.
         * @type  * 
         * @api  stable
         */
        key: string;

        /**
         * The old value. To get the new value use `e.target.get(e.key)` where
         * `e` is the event object.
         * @type  * 
         * @api  stable
         */
        oldValue: any
    }

    /**
     * 
     * @classdesc  * Abstract base class; normally only used for creating subclasses and not
    instantiated in apps.
    Most non-trivial classes inherit from this.

    This extends {
     * @link  ol.Observable} with observable properties, where each
    property is observable as well as the object as a whole.

    Classes that inherit from this have pre-defined properties, to which you can
    add your owns. The pre-defined properties are listed in this documentation as
    'Observable Properties', and have their own accessors; for example,
    {
     * @link  ol.Map} has a `target` property, accessed with `getTarget()`  and
    changed with `setTarget()`. Not all properties are however settable. There
    are also general-purpose accessors `get()` and `set()`. For example,
    `get('target')` is equivalent to `getTarget()`.

    The `set` accessors trigger a change event, and you can monitor this by
    registering a listener. For example, {
     * @link  ol.View} has a `center`
    property, so `view.on('change:center', function(evt) {...});` would call the
    function whenever the value of the center property changes. Within the
    function, `evt.target` would be the view, so `evt.target.getCenter()` would
    return the new center.

    You can add your own observable properties with
    `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
    You can listen for changes on that property value with
    `object.on('change:prop', listener)`. You can get a list of all
    properties with {
     * @link  ol.Object#getProperties object.getProperties()}.

    Note that the observable properties are separate from standard JS properties.
    You can, for example, give your map object a title with
    `map.title='New title'` and with `map.set('title', 'Another title')`. The
    first will be a `hasOwnProperty`; the second will appear in
    `getProperties()`. Only the second is observable.

    Properties can be deleted by using the unset method. E.g.
    object.unset('foo').
     * @constructor  * 
     * @extends  {ol.Observable}
     * @param  An object with key-value pairs.
     * @fires  ol.ObjectEvent
     * @api  
    */
    declare class Object mixins ol.Observable {

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Most non-trivial classes inherit from this.

        This extends {
         * @link  ol.Observable} with observable properties, where each
        property is observable as well as the object as a whole.

        Classes that inherit from this have pre-defined properties, to which you can
        add your owns. The pre-defined properties are listed in this documentation as
        'Observable Properties', and have their own accessors; for example,
        {
         * @link  ol.Map} has a `target` property, accessed with `getTarget()`  and
        changed with `setTarget()`. Not all properties are however settable. There
        are also general-purpose accessors `get()` and `set()`. For example,
        `get('target')` is equivalent to `getTarget()`.

        The `set` accessors trigger a change event, and you can monitor this by
        registering a listener. For example, {
         * @link  ol.View} has a `center`
        property, so `view.on('change:center', function(evt) {...});` would call the
        function whenever the value of the center property changes. Within the
        function, `evt.target` would be the view, so `evt.target.getCenter()` would
        return the new center.

        You can add your own observable properties with
        `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
        You can listen for changes on that property value with
        `object.on('change:prop', listener)`. You can get a list of all
        properties with {
         * @link  ol.Object#getProperties object.getProperties()}.

        Note that the observable properties are separate from standard JS properties.
        You can, for example, give your map object a title with
        `map.title='New title'` and with `map.set('title', 'Another title')`. The
        first will be a `hasOwnProperty`; the second will appear in
        `getProperties()`. Only the second is observable.

        Properties can be deleted by using the unset method. E.g.
        object.unset('foo').
         * @constructor  * 
         * @extends  {ol.Observable}
         * @param  An object with key-value pairs.
         * @fires  ol.ObjectEvent
         * @api  
        */
        constructor(opt_values?: {
            [k: string]: any
        }): this;

        /**
         * Gets a value.
         * @param  Key name.
         * @return  Value.
         * @api  stable
         */
        get(key: string): any;

        /**
         * Get a list of object property names.
         * @return  List of property names.
         * @api  stable
         */
        getKeys(): string[];

        /**
         * Get an object of all property names and values.
         * @return  Object.
         * @api  stable
         */
        getProperties(): {
            [k: string]: any
        };

        /**
         * Sets a value.
         * @param  Key name.
         * @param  Value.
         * @param  Update without triggering an event.
         * @api  stable
         */
        set(key: string, value: any, opt_silent?: boolean): void;

        /**
         * Sets a collection of key-value pairs.  Note that this changes any existing
         * properties and adds new ones (it does not remove any existing properties).
         * @param  Values.
         * @param  Update without triggering an event.
         * @api  stable
         */
        setProperties(values: {
            [k: string]: any
        }, opt_silent?: boolean): void;

        /**
         * Unsets a property.
         * @param  Key name.
         * @param  Unset without triggering an event.
         * @api  stable
         */
        unset(key: string, opt_silent?: boolean): void
    }

    /**
     * 
     * @classdesc  * Abstract base class; normally only used for creating subclasses and not
    instantiated in apps.
    An event target providing convenient methods for listener registration
    and unregistration. A generic `change` event is always available through
    {
     * @link  ol.Observable#changed}.
     * @constructor  * 
     * @extends  {ol.events.EventTarget}
     * @fires  ol.events.Event
     * @struct  * 
     * @api  stable
    */
    declare class Observable mixins undefined.EventTarget {

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        An event target providing convenient methods for listener registration
        and unregistration. A generic `change` event is always available through
        {
         * @link  ol.Observable#changed}.
         * @constructor  * 
         * @extends  {ol.events.EventTarget}
         * @fires  ol.events.Event
         * @struct  * 
         * @api  stable
        */
        constructor(): this;

        /**
         * Removes an event listener using the key returned by `on()` or `once()`.
         * @param  The key returned by `on()`
        or `once()` (or an array of keys).
         * @api  stable
        */
        unByKey(key: (ol.EventsKey | ol.EventsKey[])): void;

        /**
         * Increases the revision counter and dispatches a 'change' event.
         * @api  
         */
        changed(): void;

        /**
         * Dispatches an event and calls all listeners listening for events
         * of this type. The event parameter can either be a string or an
        Object with a `type` property.target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
        string} event Event object.
         * @function  * 
         * @api  
        */
        dispatchEvent(event: (GlobalObject | undefined.Event | string)): void;

        /**
         * Get the version number for this object.  Each time the object is modified,
         * its version number will be incremented.
         * @return  Revision.
         * @api  
         */
        getRevision(): number;

        /**
         * Listen for a certain type of event.
         * @param  The event type or array of event types.
         * @param  The listener function.
         * @param  The object to use as `this` in `listener`.
         * @return  Unique key for the listener. If
        called with an array of event types as the first argument, the return
        will be an array of keys.
         * @api  stable
        */
        on(
            type: (string | string[]),
            listener: Function,
            opt_this?: GlobalObject): (ol.EventsKey | ol.EventsKey[]);

        /**
         * Listen once for a certain type of event.
         * @param  The event type or array of event types.
         * @param  The listener function.
         * @param  The object to use as `this` in `listener`.
         * @return  Unique key for the listener. If
        called with an array of event types as the first argument, the return
        will be an array of keys.
         * @api  stable
        */
        once(
            type: (string | string[]),
            listener: Function,
            opt_this?: GlobalObject): (ol.EventsKey | ol.EventsKey[]);

        /**
         * Unlisten for a certain type of event.
         * @param  The event type or array of event types.
         * @param  The listener function.
         * @param  The object which was used as `this` by the
        `listener`.
         * @api  stable
        */
        un(type: (string | string[]), listener: Function, opt_this?: GlobalObject): void;

        /**
         * Removes an event listener using the key returned by `on()` or `once()`.
         * Note that using the {@link ol.Observable.unByKey} static function is to
        be preferred.
         * @param  The key returned by `on()`
        or `once()` (or an array of keys).
         * @function  * 
         * @api  stable
        */
        unByKey(key: (ol.EventsKey | ol.EventsKey[])): void
    }

    /**
     * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
     * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
    `'top-center'`, `'top-right'`
     * @enum  {string}
    */
    declare type OverlayPositioning = string;

    /**
     * 
     * @classdesc  * An element to be displayed over the map and attached to a single map
    location.  Like {
     * @link  ol.control.Control}, Overlays are visible widgets.
    Unlike Controls, they are not in a fixed position on the screen, but are tied
    to a geographical coordinate, so panning the map will move an Overlay but not
    a Control.

    Example:

    var popup = new ol.Overlay({
    element: document.getElementById('popup')
    });
    popup.setPosition(coordinate);
    map.addOverlay(popup);
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  Overlay options.
     * @api  stable
    */
    declare class Overlay mixins ol.Object {

        /**
         * 
         * @classdesc  * An element to be displayed over the map and attached to a single map
        location.  Like {
         * @link  ol.control.Control}, Overlays are visible widgets.
        Unlike Controls, they are not in a fixed position on the screen, but are tied
        to a geographical coordinate, so panning the map will move an Overlay but not
        a Control.

        Example:

        var popup = new ol.Overlay({
        element: document.getElementById('popup')
        });
        popup.setPosition(coordinate);
        map.addOverlay(popup);
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Overlay options.
         * @api  stable
        */
        constructor(options: olx.OverlayOptions): this;

        /**
         * Get the DOM element of this overlay.
         * @return  The Element containing the overlay.
         * @observable  * 
         * @api  stable
         */
        getElement(): (Element);

        /**
         * Get the overlay identifier which is set on constructor.
         * @return  Id.
         * @api  
         */
        getId(): (number | string);

        /**
         * Get the map associated with this overlay.
         * @return  The map that the overlay is part of.
         * @observable  * 
         * @api  stable
         */
        getMap(): (ol.Map);

        /**
         * Get the offset of this overlay.
         * @return  The offset.
         * @observable  * 
         * @api  stable
         */
        getOffset(): number[];

        /**
         * Get the current position of this overlay.
         * @return  The spatial point that the overlay is
        anchored at.
         * @observable  * 
         * @api  stable
        */
        getPosition(): (ol.Coordinate);

        /**
         * Get the current positioning of this overlay.
         * @return  How the overlay is positioned
        relative to its point on the map.
         * @observable  * 
         * @api  stable
        */
        getPositioning(): ol.OverlayPositioning;

        /**
         * Set the DOM element to be associated with this overlay.
         * @param  The Element containing the overlay.
         * @observable  * 
         * @api  stable
         */
        setElement(element: (Element)): void;

        /**
         * Set the map to be associated with this overlay.
         * @param  The map that the overlay is part of.
         * @observable  * 
         * @api  stable
         */
        setMap(map: (ol.Map)): void;

        /**
         * Set the offset for this overlay.
         * @param  Offset.
         * @observable  * 
         * @api  stable
         */
        setOffset(offset: number[]): void;

        /**
         * Set the position for this overlay. If the position is `undefined` the
         * overlay is hidden.
         * @param  The spatial point that the overlay
        is anchored at.
         * @observable  * 
         * @api  stable
        */
        setPosition(position: (ol.Coordinate)): void;

        /**
         * Set the positioning for this overlay.
         * @param  how the overlay is
        positioned relative to its point on the map.
         * @observable  * 
         * @api  stable
        */
        setPositioning(positioning: ol.OverlayPositioning): void
    }
    declare module 'pointer' {

        /**
         * 
         * @classdesc  * A class for pointer events.

        This class is used as an abstraction for mouse events,
        touch events and even native pointer events.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @param  The type of the event to create.
         * @param  The event.
         * @param  An optional dictionary of
        initial event properties.
        */
        declare class PointerEvent {}
    }

    declare module 'proj' {

        /**
         * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
         * `'nautical'`, `'metric'`, `'us'`.
         * @enum  {string}
         */
        declare type Units = string;
        declare     var METERS_PER_UNIT: {
            [k: string]: number
        };

        /**
         * 
         * @classdesc  * Projection definition class. One of these is created for each projection
        supported in the application and stored in the {
         * @link  ol.proj} namespace.
        You can use these in applications, but this is not required, as API params
        and options use {
         * @link  ol.ProjectionLike} which means the simple string
        code will suffice.

        You can use {
         * @link  ol.proj.get} to retrieve the object for a particular
        projection.

        The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
        with the following aliases:
        * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
        urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
        http://www.opengis.net/gml/srs/epsg.xml#4326,
        urn:x-ogc:def:crs:EPSG:4326
        * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
        urn:ogc:def:crs:EPSG:6.18:3:3857,
        http://www.opengis.net/gml/srs/epsg.xml#3857

        If you use proj4js, aliases can be added using `proj4.defs()`; see
        [documentation](https://github.com/proj4js/proj4js). To set an alternative
        namespace for proj4, use {
         * @link  ol.proj.setProj4}.
         * @constructor  * 
         * @param  Projection options.
         * @struct  * 
         * @api  stable
        */
        declare class Projection {

            /**
             * 
             * @classdesc  * Projection definition class. One of these is created for each projection
            supported in the application and stored in the {
             * @link  ol.proj} namespace.
            You can use these in applications, but this is not required, as API params
            and options use {
             * @link  ol.ProjectionLike} which means the simple string
            code will suffice.

            You can use {
             * @link  ol.proj.get} to retrieve the object for a particular
            projection.

            The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
            with the following aliases:
            * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
            urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
            http://www.opengis.net/gml/srs/epsg.xml#4326,
            urn:x-ogc:def:crs:EPSG:4326
            * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
            urn:ogc:def:crs:EPSG:6.18:3:3857,
            http://www.opengis.net/gml/srs/epsg.xml#3857

            If you use proj4js, aliases can be added using `proj4.defs()`; see
            [documentation](https://github.com/proj4js/proj4js). To set an alternative
            namespace for proj4, use {
             * @link  ol.proj.setProj4}.
             * @constructor  * 
             * @param  Projection options.
             * @struct  * 
             * @api  stable
            */
            constructor(options: olx.ProjectionOptions): this;

            /**
             * Get the code for this projection, e.g. 'EPSG:4326'.
             * @return  Code.
             * @api  stable
             */
            getCode(): string;

            /**
             * Get the validity extent for this projection.
             * @return  Extent.
             * @api  stable
             */
            getExtent(): ol.Extent;

            /**
             * Get the units of this projection.
             * @return  Units.
             * @api  stable
             */
            getUnits(): undefined.Units;

            /**
             * Get the amount of meters per unit of this projection.  If the projection is
             * not configured with `metersPerUnit` or a units identifier, the return is
            `undefined`.
             * @return  Meters.
             * @api  stable
            */
            getMetersPerUnit(): (number);

            /**
             * Get the world extent for this projection.
             * @return  Extent.
             * @api  
             */
            getWorldExtent(): ol.Extent;

            /**
             * Is this projection a global projection which spans the whole world?
             * @return  Whether the projection is global.
             * @api  stable
             */
            isGlobal(): boolean;

            /**
             * Set if the projection is a global projection which spans the whole world
             * @param  Whether the projection is global.
             * @api  stable
             */
            setGlobal(global: boolean): void;

            /**
             * Set the validity extent for this projection.
             * @param  Extent.
             * @api  stable
             */
            setExtent(extent: ol.Extent): void;

            /**
             * Set the world extent for this projection.
             * @param  World extent
            [minlon, minlat, maxlon, maxlat].
             * @api  
            */
            setWorldExtent(worldExtent: ol.Extent): void;

            /**
             * Set the getPointResolution function for this projection.
             * @param  Function
             * @api  
             */
            setGetPointResolution(func: ((resolution: number, coords: ol.Coordinate) => number)): void;

            /**
             * Get the resolution of the point in degrees or distance units.
             * For projections with degrees as the unit this will simply return the
            provided resolution. The default for other projections is to estimate
            the point resolution by transforming the 'point' pixel to EPSG:4326,
            measuring its width and height on the normal sphere,
            and taking the average of the width and height.
            An alternative implementation may be given when constructing a
            projection. For many local projections,
            such a custom function will return the resolution unchanged.
             * @param  Resolution in projection units.
             * @param  Point.
             * @return  Point resolution in projection units.
             * @api  
            */
            getPointResolution(resolution: number, point: ol.Coordinate): number
        }

        /**
         * Register proj4. If not explicitly registered, it will be assumed that
         * proj4js will be loaded in the global namespace. For example in a
        browserify ES6 environment you could use:

             import ol from 'openlayers';
             import proj4 from 'proj4';
             ol.proj.setProj4(proj4);
         * @param  Proj4.
         * @api  
        */
        declare     function setProj4(proj4: any): void

        /**
         * Registers transformation functions that don't alter coordinates. Those allow
         * to transform between projections with equal meaning.
         * @param  Projections.
         * @api  
         */
        declare     function addEquivalentProjections(projections: undefined.Projection[]): void

        /**
         * Add a Projection object to the list of supported projections that can be
         * looked up by their code.
         * @param  Projection instance.
         * @api  stable
         */
        declare     function addProjection(projection: undefined.Projection): void

        /**
         * Registers coordinate transform functions to convert coordinates between the
         * source projection and the destination projection.
        The forward and inverse functions convert coordinate pairs; this function
        converts these into the functions used internally which also handle
        extents and coordinate arrays.
         * @param  Source projection.
         * @param  Destination projection.
         * @param  The forward transform
        function (that is, from the source projection to the destination
        projection) that takes a {
         * @link  ol.Coordinate} as argument and returns
        the transformed {
         * @link  ol.Coordinate}.
         * @param  The inverse transform
        function (that is, from the destination projection to the source
        projection) that takes a {
         * @link  ol.Coordinate} as argument and returns
        the transformed {
         * @link  ol.Coordinate}.
         * @api  stable
        */
        declare     function addCoordinateTransforms(
            source: ol.ProjectionLike,
            destination: ol.ProjectionLike,
            forward: ((coords: ol.Coordinate) => ol.Coordinate),
            inverse: ((coords: ol.Coordinate) => ol.Coordinate)): void

        /**
         * Transforms a coordinate from longitude/latitude to a different projection.
         * @param  Coordinate as longitude and latitude, i.e.
        an array with longitude as 1st and latitude as 2nd element.
         * @param  Target projection. The
        default is Web Mercator, i.e. 'EPSG:3857'.
         * @return  Coordinate projected to the target projection.
         * @api  stable
        */
        declare     function fromLonLat(coordinate: ol.Coordinate, opt_projection?: ol.ProjectionLike): ol.Coordinate

        /**
         * Transforms a coordinate to longitude/latitude.
         * @param  Projected coordinate.
         * @param  Projection of the coordinate.
        The default is Web Mercator, i.e. 'EPSG:3857'.
         * @return  Coordinate as longitude and latitude, i.e. an array
        with longitude as 1st and latitude as 2nd element.
         * @api  stable
        */
        declare     function toLonLat(coordinate: ol.Coordinate, opt_projection?: ol.ProjectionLike): ol.Coordinate

        /**
         * Fetches a Projection object for the code specified.
         * @param  Either a code string which is
        a combination of authority and identifier such as "EPSG:4326", or an
        existing projection object, or undefined.
         * @return  Projection object, or null if not in list.
         * @api  stable
        */
        declare     function get(projectionLike: ol.ProjectionLike): undefined.Projection

        /**
         * Checks if two projections are the same, that is every coordinate in one
         * projection does represent the same geographic point as the same coordinate in
        the other projection.
         * @param  Projection 1.
         * @param  Projection 2.
         * @return  Equivalent.
         * @api  
        */
        declare     function equivalent(projection1: undefined.Projection, projection2: undefined.Projection): boolean

        /**
         * Given the projection-like objects, searches for a transformation
         * function to convert a coordinates array from the source projection to the
        destination projection.
         * @param  Source.
         * @param  Destination.
         * @return  Transform function.
         * @api  stable
        */
        declare     function getTransform(
            source: ol.ProjectionLike,
            destination: ol.ProjectionLike): ol.TransformFunction

        /**
         * Transforms a coordinate from source projection to destination projection.
         * This returns a new coordinate (and does not modify the original).

        See {@link ol.proj.transformExtent} for extent transformation.
        See the transform method of {@link ol.geom.Geometry} and its subclasses for
        geometry transforms.
         * @param  Coordinate.
         * @param  Source projection-like.
         * @param  Destination projection-like.
        */
        declare     function transform(
            coordinate: ol.Coordinate,
            source: ol.ProjectionLike,
            destination: ol.ProjectionLike): ol.Coordinate

        /**
         * Transforms an extent from source projection to destination projection.  This
         * returns a new extent (and does not modify the original).
         * @param  The extent to transform.
         * @param  Source projection-like.
         * @param  Destination projection-like.
         * @return  The transformed extent.
         * @api  stable
         */
        declare     function transformExtent(
            extent: ol.Extent,
            source: ol.ProjectionLike,
            destination: ol.ProjectionLike): ol.Extent
    }

    declare module 'render' {
        declare module 'canvas' {

            /**
             * 
             * @classdesc  * A concrete subclass of {
             * @link  ol.render.VectorContext} that implements
            direct rendering of features and geometries to an HTML5 Canvas context.
            Instances of this class are created internally by the library and
            provided to application code as vectorContext member of the
            {
             * @link  ol.render.Event} object associated with postcompose, precompose and
            render events emitted by layers and maps.
             * @constructor  * 
             * @extends  {ol.render.VectorContext}
             * @param  Context.
             * @param  Pixel ratio.
             * @param  Extent.
             * @param  Transform.
             * @param  View rotation.
             * @struct  
            */
            declare class Immediate mixins undefined.VectorContext {

                /**
                 * 
                 * @classdesc  * A concrete subclass of {
                 * @link  ol.render.VectorContext} that implements
                direct rendering of features and geometries to an HTML5 Canvas context.
                Instances of this class are created internally by the library and
                provided to application code as vectorContext member of the
                {
                 * @link  ol.render.Event} object associated with postcompose, precompose and
                render events emitted by layers and maps.
                 * @constructor  * 
                 * @extends  {ol.render.VectorContext}
                 * @param  Context.
                 * @param  Pixel ratio.
                 * @param  Extent.
                 * @param  Transform.
                 * @param  View rotation.
                 * @struct  
                */
                constructor(context: CanvasRenderingContext2D, pixelRatio: number, extent: ol.Extent, transform: any, viewRotation: number): this;

                /**
                 * Render a circle geometry into the canvas.  Rendering is immediate and uses
                 * the current fill and stroke styles.
                 * @param  Circle geometry.
                 * @api  
                 */
                drawCircle(geometry: undefined.Circle): void;

                /**
                 * Set the rendering style.  Note that since this is an immediate rendering API,
                 * any `zIndex` on the provided style will be ignored.
                 * @param  The rendering style.
                 * @api  
                 */
                setStyle(style: undefined.Style): void;

                /**
                 * Render a geometry into the canvas.  Call
                 * {
                 * @link  ol.render.canvas.Immediate#setStyle} first to set the rendering style.
                 * @param  The geometry to render.
                 * @api  
                 */
                drawGeometry(geometry: (undefined.Geometry | undefined.Feature)): void;

                /**
                 * Render a feature into the canvas.  Note that any `zIndex` on the provided
                 * style will be ignored - features are rendered immediately in the order that
                this method is called.  If you need `zIndex` support, you should be using an
                {
                 * @link  ol.layer.Vector} instead.
                 * @param  Feature.
                 * @param  Style.
                 * @api  
                */
                drawFeature(feature: ol.Feature, style: undefined.Style): void
            }
        }


        /**
         * 
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.render.Event}
         * @param  Type.
         * @param  Vector context.
         * @param  Frame state.
         * @param  Context.
         * @param  WebGL Context.
         */
        declare class Event mixins undefined.Event {

            /**
             * 
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.render.Event}
             * @param  Type.
             * @param  Vector context.
             * @param  Frame state.
             * @param  Context.
             * @param  WebGL Context.
             */
            constructor(type: undefined.EventType, opt_vectorContext?: undefined.VectorContext, opt_frameState?: olx.FrameState, opt_context?: CanvasRenderingContext2D, opt_glContext?: any): this;

            /**
             * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
             * @type  * 
             * @api  
             */
            vectorContext: undefined.VectorContext;

            /**
             * An object representing the current render frame state.
             * @type  * 
             * @api  
             */
            frameState: olx.FrameState;

            /**
             * Canvas context. Only available when a Canvas renderer is used, null
             * otherwise.
             * @type  * 
             * @api  
             */
            context: CanvasRenderingContext2D;

            /**
             * WebGL context. Only available when a WebGL renderer is used, null
             * otherwise.
             * @type  * 
             * @api  
             */
            glContext: any
        }
        declare type EventType = string;

        /**
         * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like
         * structure, optimized for rendering and styling. Geometry access through the
        API is limited to getting the type and extent of the geometry.
         * @constructor  * 
         * @param  Geometry type.
         * @param  Flat coordinates. These always need
        to be right-handed for polygons.
         * @param  Ends or Endss.
         * @param  Properties.
        */
        declare class Feature {

            /**
             * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like
             * structure, optimized for rendering and styling. Geometry access through the
            API is limited to getting the type and extent of the geometry.
             * @constructor  * 
             * @param  Geometry type.
             * @param  Flat coordinates. These always need
            to be right-handed for polygons.
             * @param  Ends or Endss.
             * @param  Properties.
            */
            constructor(type: undefined.GeometryType, flatCoordinates: number[], ends: (number[] | number[][]), properties: {
                [k: string]: any
            }): this;

            /**
             * Get a feature property by its key.
             * @param  Key
             * @return  Value for the requested key.
             * @api  
             */
            get(key: string): any;

            /**
             * Get the extent of this feature's geometry.
             * @return  Extent.
             * @api  
             */
            getExtent(): ol.Extent;

            /**
             * Get the feature for working with its geometry.
             * @return  Feature.
             * @api  
             */
            getGeometry(): undefined.Feature;

            /**
             * Get the feature properties.
             * @return  Feature properties.
             * @api  
             */
            getProperties(): {
                [k: string]: any
            };

            /**
             * Get the type of this feature's geometry.
             * @return  Geometry type.
             * @api  
             */
            getType(): undefined.GeometryType
        }

        /**
         * Context for drawing geometries.  A vector context is available on render
         * events and does not need to be constructed directly.
         * @constructor  * 
         * @struct  * 
         * @api  
         */
        declare class VectorContext {

            /**
             * Context for drawing geometries.  A vector context is available on render
             * events and does not need to be constructed directly.
             * @constructor  * 
             * @struct  * 
             * @api  
             */
            constructor(): this
        }

        /**
         * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
         * to the context's canvas.

        The units for geometry coordinates are css pixels relative to the top left
        corner of the canvas element.
        ```js
        var canvas = document.createElement('canvas');
        var render = ol.render.toContext(canvas.getContext('2d'),
             { size: [100, 100] });
        render.setFillStrokeStyle(new ol.style.Fill({ color: blue }));
        render.drawPolygon(
             new ol.geom.Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
        ```
         * @param  Canvas context.
         * @param  Options.
         * @return  Canvas Immediate.
         * @api  
        */
        declare     function toContext(
            context: CanvasRenderingContext2D,
            opt_options?: undefined.ToContextOptions): undefined.Immediate

        /**
         * 
         * @typedef  *     pixelRatio: (number|undefined)}}
         */
        declare interface ToContextOptions {
            size?: ol.Size,
                pixelRatio?: number
        }
    }


    /**
     * Available renderers: `'canvas'`, `'dom'` or `'webgl'`.
     * @enum  {string}
     */
    declare type RendererType = string;

    /**
     * Raster operation type. Supported values are `'pixel'` and `'image'`.
     * @enum  {string}
     */
    declare type RasterOperationType = string;
    declare module 'source' {

        /**
         * 
         * @classdesc  * Layer source for Bing Maps tile data.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Bing Maps options.
         * @api  stable
         */
        declare class BingMaps mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for Bing Maps tile data.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Bing Maps options.
             * @api  stable
             */
            constructor(options: undefined.BingMapsOptions): this;

            /**
             * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’
             * Terms Of Use.
             * @const  * 
             * @type  * 
             * @api  
             */
            TOS_ATTRIBUTION: ol.Attribution
        }

        /**
         * 
         * @classdesc  * Layer source for the CartoDB tiles.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  CartoDB options.
         * @api  
         */
        declare class CartoDB mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the CartoDB tiles.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  CartoDB options.
             * @api  
             */
            constructor(options: undefined.CartoDBOptions): this;

            /**
             * Returns the current config.
             * @return  The current configuration.
             * @api  
             */
            getConfig(): GlobalObject;

            /**
             * Updates the carto db config.
             * @param  a key-value lookup. Values will replace current values
            in the config.
             * @api  
            */
            updateConfig(config: GlobalObject): void;

            /**
             * Sets the CartoDB config
             * @param  In the case of anonymous maps, a CartoDB configuration
            object.
            If using named maps, a key-value lookup with the template parameters.
             * @api  
            */
            setConfig(config: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Layer source to cluster vector data. Works out of the box with point
        geometries. For other geometry types, or if not all geometries should be
        considered for clustering, a custom `geometryFunction` can be defined.
         * @constructor  * 
         * @param  Constructor options.
         * @extends  {ol.source.Vector}
         * @api  
        */
        declare class Cluster mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer source to cluster vector data. Works out of the box with point
            geometries. For other geometry types, or if not all geometries should be
            considered for clustering, a custom `geometryFunction` can be defined.
             * @constructor  * 
             * @param  Constructor options.
             * @extends  {ol.source.Vector}
             * @api  
            */
            constructor(options: undefined.ClusterOptions): this;

            /**
             * Get a reference to the wrapped source.
             * @return  Source.
             * @api  
             */
            getSource(): undefined.Vector;

            /**
             * Set the distance in pixels between clusters.
             * @param  The distance in pixels.
             * @api  
             */
            setDistance(distance: number): void
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for sources providing a single image.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @param  Single image source options.
         * @api  
        */
        declare class Image mixins undefined.Source {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for sources providing a single image.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @param  Single image source options.
             * @api  
            */
            constructor(options: ol.SourceImageOptions): this
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Image} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.ImageEvent}
         * @param  Type.
         * @param  The image.
        */
        declare class ImageEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Image} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.ImageEvent}
             * @param  Type.
             * @param  The image.
            */
            constructor(type: string, image: ol.Image): this;

            /**
             * The image related to the event.
             * @type  * 
             * @api  
             */
            image: ol.Image
        }

        /**
         * 
         * @classdesc  * Source for data from ArcGIS Rest services providing single, untiled images.
        Useful when underlying map service has labels.

        If underlying map service is not using labels,
        take advantage of ol image caching and use
        {
         * @link  ol.source.TileArcGISRest} data source.
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Image ArcGIS Rest Options.
         * @api  
        */
        declare class ImageArcGISRest mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for data from ArcGIS Rest services providing single, untiled images.
            Useful when underlying map service has labels.

            If underlying map service is not using labels,
            take advantage of ol image caching and use
            {
             * @link  ol.source.TileArcGISRest} data source.
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Image ArcGIS Rest Options.
             * @api  
            */
            constructor(opt_options?: undefined.ImageArcGISRestOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Return the URL used for this ArcGIS source.
             * @return  URL.
             * @api  stable
             */
            getUrl(): (string);

            /**
             * Set the image load function of the source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: (string)): void;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Base class for image sources where a canvas element is the image.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @param  Constructor options.
         * @api  
         */
        declare class ImageCanvas mixins undefined.Image {

            /**
             * 
             * @classdesc  * Base class for image sources where a canvas element is the image.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @param  Constructor options.
             * @api  
             */
            constructor(options: undefined.ImageCanvasOptions): this
        }

        /**
         * 
         * @classdesc  * Source for images from Mapguide servers
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageMapGuide mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for images from Mapguide servers
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.ImageMapGuideOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void;

            /**
             * Set the image load function of the MapGuide source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void
        }

        /**
         * 
         * @classdesc  * A layer source for displaying a single, static image.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageStatic mixins undefined.Image {

            /**
             * 
             * @classdesc  * A layer source for displaying a single, static image.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.ImageStaticOptions): this
        }

        /**
         * 
         * @classdesc  * An image source whose images are canvas elements into which vector features
        read from a vector source (`ol.source.Vector`) are drawn. An
        `ol.source.ImageVector` object is to be used as the `source` of an image
        layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
        as opposed to being re-rendered, during animations and interactions. So, like
        any other image layer, an image layer configured with an
        `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
        vector layer, where vector features are re-drawn during animations and
        interactions.
         * @constructor  * 
         * @extends  {ol.source.ImageCanvas}
         * @param  Options.
         * @api  
        */
        declare class ImageVector mixins undefined.ImageCanvas {

            /**
             * 
             * @classdesc  * An image source whose images are canvas elements into which vector features
            read from a vector source (`ol.source.Vector`) are drawn. An
            `ol.source.ImageVector` object is to be used as the `source` of an image
            layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
            as opposed to being re-rendered, during animations and interactions. So, like
            any other image layer, an image layer configured with an
            `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
            vector layer, where vector features are re-drawn during animations and
            interactions.
             * @constructor  * 
             * @extends  {ol.source.ImageCanvas}
             * @param  Options.
             * @api  
            */
            constructor(options: undefined.ImageVectorOptions): this;

            /**
             * Get a reference to the wrapped source.
             * @return  Source.
             * @api  
             */
            getSource(): undefined.Vector;

            /**
             * Get the style for features.  This returns whatever was passed to the `style`
             * option at construction or to the `setStyle` method.
             * @return  *     Layer style.
             * @api  stable
             */
            getStyle(): (undefined.Style | undefined.Style[] | ol.StyleFunction);

            /**
             * Get the style function.
             * @return  Layer style function.
             * @api  stable
             */
            getStyleFunction(): (ol.StyleFunction);

            /**
             * Set the style for features.  This can be a single style object, an array
             * of styles, or a function that takes a feature and resolution and returns
            an array of styles. If it is `undefined` the default style is used. If
            it is `null` the layer has no style (a `null` style), so only features
            that have their own styles will be rendered in the layer. See
            {style Layer style.
             * @link  ol.style} for information on the default style.
             * @api  stable
            */
            setStyle(style: (undefined.Style | undefined.Style[] | ol.StyleFunction)): void
        }

        /**
         * 
         * @classdesc  * Source for WMS servers providing single, untiled images.
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageWMS mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for WMS servers providing single, untiled images.
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.ImageWMSOptions): this;

            /**
             * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
             * projection. Return `undefined` if the GetFeatureInfo URL cannot be
            constructed.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Projection.
             * @param  GetFeatureInfo params. `INFO_FORMAT` at least should
            be provided. If `QUERY_LAYERS` is not provided then the layers specified
            in the `LAYERS` parameter will be used. `VERSION` should not be
            specified here.
             * @return  GetFeatureInfo URL.
             * @api  stable
            */
            getGetFeatureInfoUrl(
                coordinate: ol.Coordinate,
                resolution: number,
                projection: ol.ProjectionLike,
                params: GlobalObject): (string);

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Return the URL used for this WMS source.
             * @return  URL.
             * @api  stable
             */
            getUrl(): (string);

            /**
             * Set the image load function of the source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: (string)): void;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Layer source for the OpenStreetMap tile server.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  Open Street Map options.
         * @api  stable
         */
        declare class OSM mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the OpenStreetMap tile server.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  Open Street Map options.
             * @api  stable
             */
            constructor(opt_options?: undefined.OSMOptions): this;

            /**
             * The attribution containing a link to the OpenStreetMap Copyright and License
             * page.
             * @const  * 
             * @type  * 
             * @api  
             */
            ATTRIBUTION: ol.Attribution
        }

        /**
         * 
         * @classdesc  * A source that transforms data from any number of input sources using an array
        of {
         * @link  ol.RasterOperation} functions to transform input pixel values into
        output pixel values.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @fires  ol.source.RasterEvent
         * @param  Options.
         * @api  
        */
        declare class Raster mixins undefined.Image {

            /**
             * 
             * @classdesc  * A source that transforms data from any number of input sources using an array
            of {
             * @link  ol.RasterOperation} functions to transform input pixel values into
            output pixel values.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @fires  ol.source.RasterEvent
             * @param  Options.
             * @api  
            */
            constructor(options: undefined.RasterOptions): this;

            /**
             * Set the operation.
             * @param  New operation.
             * @param  Functions that will be available to operations run
            in a worker.
             * @api  
            */
            setOperation(operation: ol.RasterOperation, opt_lib?: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Raster} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.RasterEvent}
         * @param  Type.
         * @param  The frame state.
         * @param  An object made available to operations.
        */
        declare class RasterEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Raster} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.RasterEvent}
             * @param  Type.
             * @param  The frame state.
             * @param  An object made available to operations.
            */
            constructor(type: string, frameState: olx.FrameState, data: GlobalObject): this;

            /**
             * The raster extent.
             * @type  * 
             * @api  
             */
            extent: ol.Extent;

            /**
             * The pixel resolution (map units per pixel).
             * @type  * 
             * @api  
             */
            resolution: number;

            /**
             * An object made available to all operations.  This can be used by operations
             * as a storage object (e.g. for calculating statistics).
             * @type  * 
             * @api  
             */
            data: GlobalObject
        }

        /**
         * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
         * @enum  {string}
         */
        declare type State = string;

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for {
         * @link  ol.layer.Layer} sources.

        A generic `change` event is triggered when the state of the source changes.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Source options.
         * @api  stable
        */
        declare class Source mixins ol.Object {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for {
             * @link  ol.layer.Layer} sources.

            A generic `change` event is triggered when the state of the source changes.
             * @constructor  * 
             * @extends  {ol.Object}
             * @param  Source options.
             * @api  stable
            */
            constructor(options: ol.SourceSourceOptions): this;

            /**
             * Get the attributions of the source.
             * @return  Attributions.
             * @api  stable
             */
            getAttributions(): ol.Attribution[];

            /**
             * Get the logo of the source.
             * @return  Logo.
             * @api  stable
             */
            getLogo(): (string | olx.LogoOptions);

            /**
             * Get the projection of the source.
             * @return  Projection.
             * @api  
             */
            getProjection(): undefined.Projection;

            /**
             * Get the state of the source, see {@link ol.source.State} for possible states.
             * @return  State.
             * @api  
             */
            getState(): undefined.State;

            /**
             * Refreshes the source and finally dispatches a 'change' event.
             * @api  
             */
            refresh(): void;

            /**
             * Set the attributions of the source.
             * @param  Attributions.
            Can be passed as `string`, `Array<string>`, `{
             * @link  ol.Attribution}`,
            `Array<{
             * @link  ol.Attribution}>` or `undefined`.
             * @api  
            */
            setAttributions(attributions: (ol.AttributionLike)): void
        }

        /**
         * 
         * @classdesc  * Layer source for the Stamen tile server.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  Stamen options.
         * @api  stable
         */
        declare class Stamen mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the Stamen tile server.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  Stamen options.
             * @api  stable
             */
            constructor(options: undefined.StamenOptions): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for sources providing images divided into a tile grid.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @param  Tile source options.
         * @api  
        */
        declare class Tile mixins undefined.Source {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for sources providing images divided into a tile grid.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @param  Tile source options.
             * @api  
            */
            constructor(options: ol.SourceTileOptions): this;

            /**
             * Return the tile grid of the tile source.
             * @return  Tile grid.
             * @api  stable
             */
            getTileGrid(): undefined.TileGrid
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Tile} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.TileEvent}
         * @param  Type.
         * @param  The tile.
        */
        declare class TileEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Tile} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.TileEvent}
             * @param  Type.
             * @param  The tile.
            */
            constructor(type: string, tile: ol.Tile): this;

            /**
             * The tile related to the event.
             * @type  * 
             * @api  
             */
            tile: ol.Tile
        }

        /**
         * 
         * @classdesc  * Layer source for tile data from ArcGIS Rest services. Map and Image
        Services are supported.

        For cached ArcGIS services, better performance is available using the
        {
         * @link  ol.source.XYZ} data source.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Tile ArcGIS Rest
        options.
         * @api  
        */
        declare class TileArcGISRest mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from ArcGIS Rest services. Map and Image
            Services are supported.

            For cached ArcGIS services, better performance is available using the
            {
             * @link  ol.source.XYZ} data source.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Tile ArcGIS Rest
            options.
             * @api  
            */
            constructor(opt_options?: undefined.TileArcGISRestOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  
             */
            getParams(): GlobalObject;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * A pseudo tile source, which does not fetch tiles from a server, but renders
        a grid outline for the tile grid/projection along with the coordinates for
        each tile. See examples/canvas-tiles for an example.

        Uses Canvas context2d, so requires Canvas support.
         * @constructor  * 
         * @extends  {ol.source.Tile}
         * @param  Debug tile options.
         * @api  
        */
        declare class TileDebug mixins undefined.Tile {

            /**
             * 
             * @classdesc  * A pseudo tile source, which does not fetch tiles from a server, but renders
            a grid outline for the tile grid/projection along with the coordinates for
            each tile. See examples/canvas-tiles for an example.

            Uses Canvas context2d, so requires Canvas support.
             * @constructor  * 
             * @extends  {ol.source.Tile}
             * @param  Debug tile options.
             * @api  
            */
            constructor(options: undefined.TileDebugOptions): this
        }

        /**
         * 
         * @classdesc  * Base class for sources providing images divided into a tile grid.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.UrlTile}
         * @param  Image tile options.
         * @api  
         */
        declare class TileImage mixins undefined.UrlTile {

            /**
             * 
             * @classdesc  * Base class for sources providing images divided into a tile grid.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.UrlTile}
             * @param  Image tile options.
             * @api  
             */
            constructor(options: undefined.TileImageOptions): this;

            /**
             * Sets whether to render reprojection edges or not (usually for debugging).
             * @param  Render the edges.
             * @api  
             */
            setRenderReprojectionEdges(render: boolean): void;

            /**
             * Sets the tile grid to use when reprojecting the tiles to the given
             * projection instead of the default tile grid for the projection.

            This can be useful when the default tile grid cannot be created
            (e.g. projection has no extent defined) or
            for optimization reasons (custom tile size, resolutions, ...).
             * @param  Projection.
             * @param  Tile grid to use for the projection.
             * @api  
            */
            setTileGridForProjection(projection: ol.ProjectionLike, tilegrid: undefined.TileGrid): void
        }
        declare type TileJSON = JSON;

        /**
         * 
         * @classdesc  * Layer source for UTFGrid interaction data loaded from TileJSON format.
         * @constructor  * 
         * @extends  {ol.source.Tile}
         * @param  Source options.
         * @api  
         */
        declare class TileUTFGrid mixins undefined.Tile {

            /**
             * 
             * @classdesc  * Layer source for UTFGrid interaction data loaded from TileJSON format.
             * @constructor  * 
             * @extends  {ol.source.Tile}
             * @param  Source options.
             * @api  
             */
            constructor(options: undefined.TileUTFGridOptions): this;

            /**
             * Return the template from TileJSON.
             * @return  The template from TileJSON.
             * @api  
             */
            getTemplate(): (string);

            /**
             * Calls the callback (synchronously by default) with the available data
             * for given coordinate and resolution (or `null` if not yet loaded or
            in case of an error).
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Callback.
             * @param  The object to use as `this` in the callback.
             * @param  If `true` the callback is always async.
            The tile data is requested if not yet loaded.
             * @template  * 
             * @api  
            */
            forDataAtCoordinateAndResolution<T>(
                coordinate: ol.Coordinate,
                resolution: number,
                callback: ((d: any) => any),
                opt_this?: T,
                opt_request?: boolean): void
        }

        /**
         * 
         * @classdesc  * Layer source for tile data from WMS servers.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Tile WMS options.
         * @api  stable
         */
        declare class TileWMS mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from WMS servers.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Tile WMS options.
             * @api  stable
             */
            constructor(opt_options?: undefined.TileWMSOptions): this;

            /**
             * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
             * projection. Return `undefined` if the GetFeatureInfo URL cannot be
            constructed.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Projection.
             * @param  GetFeatureInfo params. `INFO_FORMAT` at least should
            be provided. If `QUERY_LAYERS` is not provided then the layers specified
            in the `LAYERS` parameter will be used. `VERSION` should not be
            specified here.
             * @return  GetFeatureInfo URL.
             * @api  stable
            */
            getGetFeatureInfoUrl(
                coordinate: ol.Coordinate,
                resolution: number,
                projection: ol.ProjectionLike,
                params: GlobalObject): (string);

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Base class for sources providing tiles divided into a tile grid over http.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.Tile}
         * @param  Image tile options.
         */
        declare class UrlTile mixins undefined.Tile {

            /**
             * 
             * @classdesc  * Base class for sources providing tiles divided into a tile grid over http.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.Tile}
             * @param  Image tile options.
             */
            constructor(options: ol.SourceUrlTileOptions): this;

            /**
             * Return the tile load function of the source.
             * @return  TileLoadFunction
             * @api  
             */
            getTileLoadFunction(): ol.TileLoadFunctionType;

            /**
             * Return the tile URL function of the source.
             * @return  TileUrlFunction
             * @api  
             */
            getTileUrlFunction(): ol.TileUrlFunctionType;

            /**
             * Return the URLs used for this source.
             * When a tileUrlFunction is used instead of url or urls,
            null will be returned.
             * @return  URLs.
             * @api  
            */
            getUrls(): (string[]);

            /**
             * Set the tile load function of the source.
             * @param  Tile load function.
             * @api  
             */
            setTileLoadFunction(tileLoadFunction: ol.TileLoadFunctionType): void;

            /**
             * Set the tile URL function of the source.
             * @param  Tile URL function.
             * @param  Optional new tile key for the source.
             * @api  
             */
            setTileUrlFunction(tileUrlFunction: ol.TileUrlFunctionType, opt_key?: string): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: string): void;

            /**
             * Set the URLs to use for requests.
             * @param  URLs.
             * @api  stable
             */
            setUrls(urls: string[]): void
        }

        /**
         * 
         * @classdesc  * Provides a source of features for vector layers. Vector features provided
        by this source are suitable for editing. See {
         * @link  ol.source.VectorTile} for
        vector data that is optimized for rendering.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @fires  ol.source.VectorEvent
         * @param  Vector source options.
         * @api  stable
        */
        declare class Vector mixins undefined.Source {

            /**
             * 
             * @classdesc  * Provides a source of features for vector layers. Vector features provided
            by this source are suitable for editing. See {
             * @link  ol.source.VectorTile} for
            vector data that is optimized for rendering.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @fires  ol.source.VectorEvent
             * @param  Vector source options.
             * @api  stable
            */
            constructor(opt_options?: undefined.VectorOptions): this;

            /**
             * Add a single feature to the source.  If you want to add a batch of features
             * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
            instead.
             * @param  Feature to add.
             * @api  stable
            */
            addFeature(feature: ol.Feature): void;

            /**
             * Add a batch of features to the source.
             * @param  Features to add.
             * @api  stable
             */
            addFeatures(features: ol.Feature[]): void;

            /**
             * Remove all features from the source.
             * @param  Skip dispatching of {
             * @link  removefeature} events.
             * @api  stable
             */
            clear(opt_fast?: boolean): void;

            /**
             * Iterate through all features on the source, calling the provided callback
             * with each one.  If the callback returns any "truthy" value, iteration will
            stop and the function will return the same value.
             * @param  Called with each feature
            on the source.  Return a truthy value to stop iteration.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  stable
            */
            forEachFeature<T, S>(callback: ((feature: ol.Feature) => S), opt_this?: T): (S);

            /**
             * Iterate through all features whose bounding box intersects the provided
             * extent (note that the feature's geometry may not intersect the extent),
            calling the callback with each feature.  If the callback returns a "truthy"
            value, iteration will stop and the function will return the same value.

            If you are interested in features whose geometry intersects an extent, call
            the {@link ol.source.Vector#forEachFeatureIntersectingExtent
            source.forEachFeatureIntersectingExtent()} method instead.

            When `useSpatialIndex` is set to false, this method will loop through all
            features, equivalent to {@link ol.source.Vector#forEachFeature}.
             * @param  Extent.
             * @param  Called with each feature
            whose bounding box intersects the provided extent.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  
            */
            forEachFeatureInExtent<T, S>(
                extent: ol.Extent,
                callback: ((feature: ol.Feature) => S),
                opt_this?: T): (S);

            /**
             * Iterate through all features whose geometry intersects the provided extent,
             * calling the callback with each feature.  If the callback returns a "truthy"
            value, iteration will stop and the function will return the same value.

            If you only want to test for bounding box intersection, call the
            {
             * @link  ol.source.Vector#forEachFeatureInExtent
            source.forEachFeatureInExtent()} method instead.
             * @param  Extent.
             * @param  Called with each feature
            whose geometry intersects the provided extent.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  
            */
            forEachFeatureIntersectingExtent<T, S>(
                extent: ol.Extent,
                callback: ((feature: ol.Feature) => S),
                opt_this?: T): (S);

            /**
             * Get the features collection associated with this source. Will be `null`
             * unless the source was configured with `useSpatialIndex` set to `false`, or
            with an {@link ol.Collection} as `features`.
             * @return  The collection of features.
             * @api  
            */
            getFeaturesCollection(): ol.Collection<ol.Feature>;

            /**
             * Get all features on the source.
             * @return  Features.
             * @api  stable
             */
            getFeatures(): ol.Feature[];

            /**
             * Get all features whose geometry intersects the provided coordinate.
             * @param  Coordinate.
             * @return  Features.
             * @api  stable
             */
            getFeaturesAtCoordinate(coordinate: ol.Coordinate): ol.Feature[];

            /**
             * Get all features in the provided extent.  Note that this returns all features
             * whose bounding boxes intersect the given extent (so it may include features
            whose geometries do not intersect the extent).

            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @param  Extent.
             * @return  Features.
             * @api  
            */
            getFeaturesInExtent(extent: ol.Extent): ol.Feature[];

            /**
             * Get the closest feature to the provided coordinate.
             * 
            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @param  Coordinate.
             * @param  Feature filter function.
            The filter function will receive one argument, the {
             * @link  ol.Feature feature}
            and it should return a boolean value. By default, no filtering is made.
             * @return  Closest feature.
             * @api  stable
            */
            getClosestFeatureToCoordinate(
                coordinate: ol.Coordinate,
                opt_filter?: ((feature: ol.Feature) => boolean)): ol.Feature;

            /**
             * Get the extent of the features currently in the source.
             * 
            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @return  Extent.
             * @api  stable
            */
            getExtent(): ol.Extent;

            /**
             * Get a feature by its identifier (the value returned by feature.getId()).
             * Note that the index treats string and numeric identifiers as the same.  So
            `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
             * @param  Feature identifier.
             * @return  The feature (or `null` if not found).
             * @api  stable
            */
            getFeatureById(id: (string | number)): ol.Feature;

            /**
             * Get the format associated with this source.
             * @return  The feature format.
             * @api  
             */
            getFormat(): (undefined.Feature);

            /**
             * Get the url associated with this source.
             * @return  The url.
             * @api  
             */
            getUrl(): (string | ol.FeatureUrlFunction);

            /**
             * Remove a single feature from the source.  If you want to remove all features
             * at once, use the {@link ol.source.Vector#clear source.clear()} method
            instead.
             * @param  Feature to remove.
             * @api  stable
            */
            removeFeature(feature: ol.Feature): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Vector} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.VectorEvent}
         * @param  Type.
         * @param  Feature.
        */
        declare class VectorEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Vector} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.VectorEvent}
             * @param  Type.
             * @param  Feature.
            */
            constructor(type: string, opt_feature?: ol.Feature): this;

            /**
             * The feature being added or removed.
             * @type  * 
             * @api  stable
             */
            feature: ol.Feature
        }

        /**
         * 
         * @classdesc  * Class for layer sources providing vector data divided into a tile grid, to be
        used with {
         * @link  ol.layer.VectorTile}. Although this source receives tiles
        with vector features from the server, it is not meant for feature editing.
        Features are optimized for rendering, their geometries are clipped at or near
        tile boundaries and simplified for a view resolution. See
        {
         * @link  ol.source.Vector} for vector sources that are suitable for feature
        editing.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.UrlTile}
         * @param  Vector tile options.
         * @api  
        */
        declare class VectorTile mixins undefined.UrlTile {

            /**
             * 
             * @classdesc  * Class for layer sources providing vector data divided into a tile grid, to be
            used with {
             * @link  ol.layer.VectorTile}. Although this source receives tiles
            with vector features from the server, it is not meant for feature editing.
            Features are optimized for rendering, their geometries are clipped at or near
            tile boundaries and simplified for a view resolution. See
            {
             * @link  ol.source.Vector} for vector sources that are suitable for feature
            editing.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.UrlTile}
             * @param  Vector tile options.
             * @api  
            */
            constructor(options: undefined.VectorTileOptions): this
        }
        declare module 'wms' {

            /**
             * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
             *      `'qgis'`. These are servers that have vendor parameters beyond the WMS
                 specification that OpenLayers can make use of.
             * @enum  {string}
            */
            declare type ServerType = string;
        }


        /**
         * Request encoding. One of 'KVP', 'REST'.
         * @enum  {string}
         */
        declare type WMTSRequestEncoding = string;

        /**
         * 
         * @classdesc  * Layer source for tile data from WMTS servers.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  WMTS options.
         * @api  stable
         */
        declare class WMTS mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from WMTS servers.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  WMTS options.
             * @api  stable
             */
            constructor(options: undefined.WMTSOptions): this;

            /**
             * Get the dimensions, i.e. those passed to the constructor through the
             * "dimensions" option, and possibly updated using the updateDimensions
            method.
             * @return  Dimensions.
             * @api  
            */
            getDimensions(): GlobalObject;

            /**
             * Return the image format of the WMTS source.
             * @return  Format.
             * @api  
             */
            getFormat(): string;

            /**
             * Return the layer of the WMTS source.
             * @return  Layer.
             * @api  
             */
            getLayer(): string;

            /**
             * Return the matrix set of the WMTS source.
             * @return  MatrixSet.
             * @api  
             */
            getMatrixSet(): string;

            /**
             * Return the request encoding, either "KVP" or "REST".
             * @return  Request encoding.
             * @api  
             */
            getRequestEncoding(): undefined.WMTSRequestEncoding;

            /**
             * Return the style of the WMTS source.
             * @return  Style.
             * @api  
             */
            getStyle(): string;

            /**
             * Return the version of the WMTS source.
             * @return  Version.
             * @api  
             */
            getVersion(): string;

            /**
             * Update the dimensions.
             * @param  Dimensions.
             * @api  
             */
            updateDimensions(dimensions: GlobalObject): void;

            /**
             * Generate source options from a capabilities object.
             * @param  An object representing the capabilities document.
             * @param  Configuration properties for the layer.  Defaults for
            the layer will apply if not provided.

            Required config properties:
            - layer - {string} The layer identifier.

            Optional config properties:
            - matrixSet - {string} The matrix set identifier, required if there is
            more than one matrix set in the layer capabilities.
            - projection - {string} The desired CRS when no matrixSet is specified.
            eg: "EPSG:3857". If the desired projection is not available,
            an error is thrown.
            - requestEncoding - {string} url encoding format for the layer. Default is
            the first tile url format found in the GetCapabilities response.
            - style - {string} The name of the style
            - format - {string} Image format for the layer. Default is the first
            format returned in the GetCapabilities response.
             * @return  WMTS source options object.
             * @api  
            */
            optionsFromCapabilities(wmtsCap: GlobalObject, config: GlobalObject): undefined.WMTSOptions
        }

        /**
         * 
         * @classdesc  * Layer source for tile data with URLs in a set XYZ format that are
        defined in a URL template. By default, this follows the widely-used
        Google grid where `x` 0 and `y` 0 are in the top left. Grids like
        TMS where `x` 0 and `y` 0 are in the bottom left can be used by
        using the `{-y}` placeholder in the URL template, so long as the
        source does not have a custom tile grid. In this case,
        {
         * @link  ol.source.TileImage} can be used with a `tileUrlFunction`
        such as:

        tileUrlFunction: function(coordinate) {
        return 'http://mapserver.com/' + coordinate[0] + '/' +
        coordinate[1] + '/' + coordinate[2] + '.png';
        }
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  XYZ options.
         * @api  stable
        */
        declare class XYZ mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data with URLs in a set XYZ format that are
            defined in a URL template. By default, this follows the widely-used
            Google grid where `x` 0 and `y` 0 are in the top left. Grids like
            TMS where `x` 0 and `y` 0 are in the bottom left can be used by
            using the `{-y}` placeholder in the URL template, so long as the
            source does not have a custom tile grid. In this case,
            {
             * @link  ol.source.TileImage} can be used with a `tileUrlFunction`
            such as:

            tileUrlFunction: function(coordinate) {
            return 'http://mapserver.com/' + coordinate[0] + '/' +
            coordinate[1] + '/' + coordinate[2] + '.png';
            }
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  XYZ options.
             * @api  stable
            */
            constructor(opt_options?: undefined.XYZOptions): this
        }

        /**
         * 
         * @classdesc  * Layer source for tile data in Zoomify format.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Options.
         * @api  stable
         */
        declare class Zoomify mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data in Zoomify format.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.ZoomifyOptions): this
        }

        /**
         * 
         * @typedef  *     culture: (string|undefined),
        key: string,
        imagerySet: string,
        maxZoom: (number|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface BingMapsOptions {
            cacheSize?: number,
                culture?: string,
                key: string,
                imagerySet: string,
                maxZoom?: number,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     distance: (number|undefined),
        extent: (ol.Extent|undefined),
        format: (ol.format.Feature|undefined),
        geometryFunction: (undefined|function(ol.Feature):ol.geom.Point),
        logo: (string|undefined),
        projection: ol.ProjectionLike,
        source: ol.source.Vector,
        wrapX: (boolean|undefined)}}
        */
        declare interface ClusterOptions {
            attributions?: ol.AttributionLike,
                distance?: number,
                extent?: ol.Extent,
                geometryFunction?: ((feature: ol.Feature) => undefined.Point),
                format?: undefined.Feature,
                logo?: string,
                projection?: ol.ProjectionLike,
                source: undefined.Vector,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     jsonp: (boolean|undefined),
        tileJSON: (TileJSON|undefined),
        url: (string|undefined)}}
        */
        declare interface TileUTFGridOptions {
            jsonp?: boolean,
                preemptive?: boolean,
                tileJSON?: TileJSON,
                url?: string
        }

        /**
         * 
         * @typedef  *            cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        state: (ol.source.State|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileImageOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                state?: undefined.State,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        renderMode: (ol.layer.VectorTileRenderType|string|undefined),
        renderOrder: (function(ol.Feature, ol.Feature):number|undefined),
        source: (ol.source.VectorTile|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorTileOptions {
            renderBuffer?: number,
                renderMode?: (undefined.VectorTileRenderType | string),
                renderOrder: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source?: undefined.VectorTile,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     displayDpi: (number|undefined),
        metersPerUnit: (number|undefined),
        hidpi: (boolean|undefined),
        useOverlay: (boolean|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: (Object|undefined)}}
        */
        declare interface ImageMapGuideOptions {
            url?: string,
                displayDpi?: number,
                metersPerUnit?: number,
                hidpi?: boolean,
                useOverlay?: boolean,
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                imageLoadFunction?: ol.ImageLoadFunctionType,
                params?: GlobalObject
        }

        /**
         * 
         * @typedef  *     layer: string,
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined)}}
        */
        declare interface MapQuestOptions {
            cacheSize?: number,
                layer: string,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string
        }

        /**
         * 
         * @typedef  *     tileGrid: (ol.tilegrid.TileGrid|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileDebugOptions {
            projection: ol.ProjectionLike,
                tileGrid?: undefined.TileGrid,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        maxZoom: (number|undefined),
        opaque: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface OSMOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                maxZoom?: number,
                opaque?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: Object.<string,*>,
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        url: (string|undefined)}}
        */
        declare interface ImageArcGISRestOptions {
            attributions?: ol.Attribution[],
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                imageLoadFunction?: ol.ImageLoadFunctionType,
                params?: {
                    [k: string]: any
                },
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                url?: string
        }

        /**
         * 
         * @typedef  *     canvasFunction: ol.CanvasFunctionType,
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        state: (ol.source.State|undefined)}}
        */
        declare interface ImageCanvasOptions {
            attributions?: ol.AttributionLike,
                canvasFunction: ol.CanvasFunctionType,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                state?: undefined.State
        }

        /**
         * 
         * @typedef  *     logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        renderBuffer: (number|undefined),
        resolutions: (Array.<number>|undefined),
        source: ol.source.Vector,
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined)}}
        */
        declare interface ImageVectorOptions {
            attributions?: ol.AttributionLike,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                ratio?: number,
                renderBuffer?: number,
                resolutions?: number[],
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction)
        }

        /**
         * 
         * @typedef  *     operation: (ol.RasterOperation|undefined),
        lib: (Object|undefined),
        threads: (number|undefined),
        operationType: (ol.RasterOperationType|undefined)}}
         * @api  
        */
        declare interface RasterOptions {
            sources: undefined.Source[],
                operation?: ol.RasterOperation,
                lib?: GlobalObject,
                threads?: number,
                operationType?: ol.RasterOperationType
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        hidpi: (boolean|undefined),
        serverType: (ol.source.wms.ServerType|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: Object.<string,*>,
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        url: (string|undefined)}}
        */
        declare interface ImageWMSOptions {
            attributions?: ol.AttributionLike,
                crossOrigin?: (string),
                hidpi?: boolean,
                serverType?: (undefined.ServerType | string),
                imageLoadFunction?: ol.ImageLoadFunctionType,
                logo?: (string | olx.LogoOptions),
                params: {
                    [k: string]: any
                },
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                url?: string
        }

        /**
         * 
         * @typedef  *     layer: string,
        minZoom: (number|undefined),
        maxZoom: (number|undefined),
        opaque: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined)}}
        */
        declare interface StamenOptions {
            cacheSize?: number,
                layer: string,
                minZoom?: number,
                maxZoom?: number,
                opaque?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        imageExtent: (ol.Extent),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        imageSize: (ol.Size|undefined),
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        url: string}}
        */
        declare interface ImageStaticOptions {
            attributions?: ol.AttributionLike,
                crossOrigin?: (string),
                imageExtent: ol.Extent,
                imageLoadFunction?: ol.ImageLoadFunctionType,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                imageSize?: ol.Size,
                url: string
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        params: (Object.<string, *>|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileArcGISRestOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                params?: {
                    [k: string]: any
                },
                logo?: (string | olx.LogoOptions),
                tileGrid?: undefined.TileGrid,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                wrapX?: boolean,
                urls?: string[]
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        jsonp: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: string,
        wrapX: (boolean|undefined)}}
        */
        declare interface TileJSONOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                jsonp?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url: string,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        params: Object.<string,*>,
        crossOrigin: (null|string|undefined),
        gutter: (number|undefined),
        hidpi: (boolean|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        serverType: (ol.source.wms.ServerType|string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileWMSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                params: {
                    [k: string]: any
                },
                crossOrigin?: (string),
                gutter?: number,
                hidpi?: boolean,
                logo?: (string | olx.LogoOptions),
                tileGrid?: undefined.TileGrid,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                serverType?: (undefined.ServerType | string),
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        source: (ol.source.Vector|undefined),
        map: (ol.Map|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorOptions {
            renderOrder?: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                renderBuffer?: number,
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (string|null|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: ol.tilegrid.WMTS,
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        requestEncoding: (ol.source.WMTSRequestEncoding|string|undefined),
        layer: string,
        style: string,
        tilePixelRatio: (number|undefined),
        version: (string|undefined),
        format: (string|undefined),
        matrixSet: string,
        dimensions: (!Object|undefined),
        url: (string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        urls: (Array.<string>|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface WMTSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                tileGrid: undefined.WMTS,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                requestEncoding?: (undefined.WMTSRequestEncoding | string),
                layer: string,
                style: string,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tilePixelRatio?: number,
                version?: string,
                format?: string,
                matrixSet: string,
                dimensions?: GlobalObject,
                url?: string,
                tileLoadFunction?: ol.TileLoadFunctionType,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileSize: (number|ol.Size|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface XYZOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                maxZoom?: number,
                minZoom?: number,
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileSize?: (number | ol.Size),
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        wrapX: (boolean|undefined),
        config: (Object|undefined),
        map: (string|undefined),
        account: string}}
        */
        declare interface CartoDBOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                maxZoom?: number,
                minZoom?: number,
                wrapX?: boolean,
                config?: GlobalObject,
                map?: string,
                account: string
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        reprojectionErrorThreshold: (number|undefined),
        url: !string,
        tierSizeCalculation: (string|undefined),
        size: ol.Size}}
        */
        declare interface ZoomifyOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                reprojectionErrorThreshold?: number,
                url: string,
                tierSizeCalculation?: string,
                size: ol.Size
        }
    }


    /**
     * 
     * @classdesc  * Class to create objects that can be used with {
     * @link  * ol.geom.Polygon.circular}.

    For example to create a sphere whose radius is equal to the semi-major
    axis of the WGS84 ellipsoid:

    ```js
    var wgs84Sphere= new ol.Sphere(6378137);
    ```
     * @constructor  * 
     * @param  Radius.
     * @api  
    */
    declare class Sphere {

        /**
         * 
         * @classdesc  * Class to create objects that can be used with {
         * @link  * ol.geom.Polygon.circular}.

        For example to create a sphere whose radius is equal to the semi-major
        axis of the WGS84 ellipsoid:

        ```js
        var wgs84Sphere= new ol.Sphere(6378137);
        ```
         * @constructor  * 
         * @param  Radius.
         * @api  
        */
        constructor(radius: number): this;

        /**
         * Returns the geodesic area for a list of coordinates.
         * 
        [Reference](http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409)
        Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
        Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
        Laboratory, Pasadena, CA, June 2007
         * @param  List of coordinates of a linear
        ring. If the ring is oriented clockwise, the area will be positive,
        otherwise it will be negative.
         * @return  Area.
         * @api  
        */
        geodesicArea(coordinates: ol.Coordinate[]): number;

        /**
         * Returns the distance from c1 to c2 using the haversine formula.
         * @param  Coordinate 1.
         * @param  Coordinate 2.
         * @return  Haversine distance.
         * @api  
         */
        haversineDistance(c1: ol.Coordinate, c2: ol.Coordinate): number
    }
    declare module 'style' {

        /**
         * Manages the creation of image atlases.
         * 
        Images added to this manager will be inserted into an atlas, which
        will be used for rendering.
        The `size` given in the constructor is the size for the first
        atlas. After that, when new atlases are created, they will have
        twice the size as the latest atlas (until `maxSize` is reached).

        If an application uses many images or very large images, it is recommended
        to set a higher `size` value to avoid the creation of too many atlases.
         * @constructor  * 
         * @struct  * 
         * @api  * 
         * @param  Options.
        */
        declare class AtlasManager {

            /**
             * Manages the creation of image atlases.
             * 
            Images added to this manager will be inserted into an atlas, which
            will be used for rendering.
            The `size` given in the constructor is the size for the first
            atlas. After that, when new atlases are created, they will have
            twice the size as the latest atlas (until `maxSize` is reached).

            If an application uses many images or very large images, it is recommended
            to set a higher `size` value to avoid the creation of too many atlases.
             * @constructor  * 
             * @struct  * 
             * @api  * 
             * @param  Options.
            */
            constructor(opt_options?: undefined.AtlasManagerOptions): this
        }

        /**
         * 
         * @classdesc  * Set circle style for vector features.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
         */
        declare class Circle mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set circle style for vector features.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
             */
            constructor(opt_options?: undefined.CircleOptions): this;

            /**
             * Get the fill style for the circle.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Get the image used to render the circle.
             * @param  Pixel ratio.
             * @return  Canvas element.
             * @api  
             */
            getImage(pixelRatio: number): HTMLCanvasElement;

            /**
             * Get the circle radius.
             * @return  Radius.
             * @api  
             */
            getRadius(): number;

            /**
             * Get the stroke style for the circle.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke
        }

        /**
         * 
         * @classdesc  * Set fill style for vector features.
         * @constructor  * 
         * @param  Options.
         * @api  
         */
        declare class Fill {

            /**
             * 
             * @classdesc  * Set fill style for vector features.
             * @constructor  * 
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.FillOptions): this;

            /**
             * Get the fill color.
             * @return  Color.
             * @api  
             */
            getColor(): (ol.Color | ol.ColorLike);

            /**
             * Set the color.
             * @param  Color.
             * @api  
             */
            setColor(color: (ol.Color | ol.ColorLike)): void
        }

        /**
         * Icon anchor units. One of 'fraction', 'pixels'.
         * @enum  {string}
         */
        declare type IconAnchorUnits = string;

        /**
         * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
         * @enum  {string}
         */
        declare type IconOrigin = string;

        /**
         * 
         * @classdesc  * Set icon style for vector features.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
         */
        declare class Icon mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set icon style for vector features.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
             */
            constructor(opt_options?: undefined.IconOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getAnchor(): number[];

            /**
             * Get the image icon.
             * @param  Pixel ratio.
             * @return  Image or Canvas element.
             * @api  
             */
            getImage(pixelRatio: number): (Image | HTMLCanvasElement);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getOrigin(): number[];

            /**
             * Get the image URL.
             * @return  Image src.
             * @api  
             */
            getSrc(): (string);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getSize(): ol.Size;

            /**
             * Load not yet loaded URI.
             * When rendering a feature with an icon style, the vector renderer will
            automatically call this method. However, you might want to call this
            method yourself for preloading or other purposes.
             * @api  
            */
            load(): void
        }

        /**
         * 
         * @classdesc  * A base class used for creating subclasses and not instantiated in
        apps. Base class for {
         * @link  ol.style.Icon}, {
         * @link  ol.style.Circle} and
        {
         * @link  ol.style.RegularShape}.
         * @constructor  * 
         * @param  Options.
         * @api  
        */
        declare class Image {

            /**
             * 
             * @classdesc  * A base class used for creating subclasses and not instantiated in
            apps. Base class for {
             * @link  ol.style.Icon}, {
             * @link  ol.style.Circle} and
            {
             * @link  ol.style.RegularShape}.
             * @constructor  * 
             * @param  Options.
             * @api  
            */
            constructor(options: ol.StyleImageOptions): this;

            /**
             * Get the symbolizer opacity.
             * @return  Opacity.
             * @api  
             */
            getOpacity(): number;

            /**
             * Determine whether the symbolizer rotates with the map.
             * @return  Rotate with map.
             * @api  
             */
            getRotateWithView(): boolean;

            /**
             * Get the symoblizer rotation.
             * @return  Rotation.
             * @api  
             */
            getRotation(): number;

            /**
             * Get the symbolizer scale.
             * @return  Scale.
             * @api  
             */
            getScale(): number;

            /**
             * Determine whether the symbolizer should be snapped to a pixel.
             * @return  The symbolizer should snap to a pixel.
             * @api  
             */
            getSnapToPixel(): boolean;

            /**
             * Set the opacity.
             * @param  Opacity.
             * @api  
             */
            setOpacity(opacity: number): void;

            /**
             * Set the rotation.
             * @param  Rotation.
             * @api  
             */
            setRotation(rotation: number): void;

            /**
             * Set the scale.
             * @param  Scale.
             * @api  
             */
            setScale(scale: number): void
        }

        /**
         * 
         * @classdesc  * Set regular shape style for vector features. The resulting shape will be
        a regular polygon when `radius` is provided, or a star when `radius1` and
        `radius2` are provided.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
        */
        declare class RegularShape mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set regular shape style for vector features. The resulting shape will be
            a regular polygon when `radius` is provided, or a star when `radius1` and
            `radius2` are provided.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
            */
            constructor(options: undefined.RegularShapeOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getAnchor(): number[];

            /**
             * Get the angle used in generating the shape.
             * @return  Shape's rotation in radians.
             * @api  
             */
            getAngle(): number;

            /**
             * Get the fill style for the shape.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getImage(pixelRatio: number): (HTMLCanvasElement | HTMLVideoElement | Image);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getOrigin(): number[];

            /**
             * Get the number of points for generating the shape.
             * @return  Number of points for stars and regular polygons.
             * @api  
             */
            getPoints(): number;

            /**
             * Get the (primary) radius for the shape.
             * @return  Radius.
             * @api  
             */
            getRadius(): number;

            /**
             * Get the secondary radius for the shape.
             * @return  Radius2.
             * @api  
             */
            getRadius2(): number;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getSize(): ol.Size;

            /**
             * Get the stroke style for the shape.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke
        }

        /**
         * 
         * @classdesc  * Set stroke style for vector features.
        Note that the defaults given are the Canvas defaults, which will be used if
        option is not defined. The `get` functions return whatever was entered in
        the options; they will not return the default.
         * @constructor  * 
         * @param  Options.
         * @api  
        */
        declare class Stroke {

            /**
             * 
             * @classdesc  * Set stroke style for vector features.
            Note that the defaults given are the Canvas defaults, which will be used if
            option is not defined. The `get` functions return whatever was entered in
            the options; they will not return the default.
             * @constructor  * 
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.StrokeOptions): this;

            /**
             * Get the stroke color.
             * @return  Color.
             * @api  
             */
            getColor(): (ol.Color | string);

            /**
             * Get the line cap type for the stroke.
             * @return  Line cap.
             * @api  
             */
            getLineCap(): (string);

            /**
             * Get the line dash style for the stroke.
             * @return  Line dash.
             * @api  
             */
            getLineDash(): number[];

            /**
             * Get the line join type for the stroke.
             * @return  Line join.
             * @api  
             */
            getLineJoin(): (string);

            /**
             * Get the miter limit for the stroke.
             * @return  Miter limit.
             * @api  
             */
            getMiterLimit(): (number);

            /**
             * Get the stroke width.
             * @return  Width.
             * @api  
             */
            getWidth(): (number);

            /**
             * Set the color.
             * @param  Color.
             * @api  
             */
            setColor(color: (ol.Color | string)): void;

            /**
             * Set the line cap.
             * @param  Line cap.
             * @api  
             */
            setLineCap(lineCap: (string)): void;

            /**
             * Set the line dash.
             * 
            Please note that Internet Explorer 10 and lower [do not support][mdn] the
            `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
            property will have no visual effect in these browsers.

            [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
             * @param  Line dash.
             * @api  
            */
            setLineDash(lineDash: number[]): void;

            /**
             * Set the line join.
             * @param  Line join.
             * @api  
             */
            setLineJoin(lineJoin: (string)): void;

            /**
             * Set the miter limit.
             * @param  Miter limit.
             * @api  
             */
            setMiterLimit(miterLimit: (number)): void;

            /**
             * Set the width.
             * @param  Width.
             * @api  
             */
            setWidth(width: (number)): void
        }

        /**
         * 
         * @classdesc  * Container for vector feature rendering styles. Any changes made to the style
        or its children through `set*()` methods will not take effect until the
        feature or layer that uses the style is re-rendered.
         * @constructor  * 
         * @struct  * 
         * @param  Style options.
         * @api  
        */
        declare class Style {

            /**
             * 
             * @classdesc  * Container for vector feature rendering styles. Any changes made to the style
            or its children through `set*()` methods will not take effect until the
            feature or layer that uses the style is re-rendered.
             * @constructor  * 
             * @struct  * 
             * @param  Style options.
             * @api  
            */
            constructor(opt_options?: undefined.StyleOptions): this;

            /**
             * Get the geometry to be rendered.
             * @return  * Feature property or geometry or function that returns the geometry that will
            be rendered with this style.
             * @api  
            */
            getGeometry(): (string | undefined.Geometry | ol.StyleGeometryFunction);

            /**
             * Get the function used to generate a geometry for rendering.
             * @return  Function that is called with a feature
            and returns the geometry to render instead of the feature's geometry.
             * @api  
            */
            getGeometryFunction(): ol.StyleGeometryFunction;

            /**
             * Get the fill style.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Get the image style.
             * @return  Image style.
             * @api  
             */
            getImage(): undefined.Image;

            /**
             * Get the stroke style.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke;

            /**
             * Get the text style.
             * @return  Text style.
             * @api  
             */
            getText(): undefined.Text;

            /**
             * Get the z-index for the style.
             * @return  ZIndex.
             * @api  
             */
            getZIndex(): (number);

            /**
             * Set a geometry that is rendered instead of the feature's geometry.
             * @param  Feature property or geometry or function returning a geometry to render
            for this style.
             * @api  
            */
            setGeometry(geometry: (string | undefined.Geometry | ol.StyleGeometryFunction)): void;

            /**
             * Set the z-index.
             * @param  ZIndex.
             * @api  
             */
            setZIndex(zIndex: (number)): void
        }

        /**
         * 
         * @classdesc  * Set text style for vector features.
         * @constructor  * 
         * @param  Options.
         * @api  
         */
        declare class Text {

            /**
             * 
             * @classdesc  * Set text style for vector features.
             * @constructor  * 
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.TextOptions): this;

            /**
             * Get the font name.
             * @return  Font.
             * @api  
             */
            getFont(): (string);

            /**
             * Get the x-offset for the text.
             * @return  Horizontal text offset.
             * @api  
             */
            getOffsetX(): number;

            /**
             * Get the y-offset for the text.
             * @return  Vertical text offset.
             * @api  
             */
            getOffsetY(): number;

            /**
             * Get the fill style for the text.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Determine whether the text rotates with the map.
             * @return  Rotate with map.
             * @api  
             */
            getRotateWithView(): (boolean);

            /**
             * Get the text rotation.
             * @return  Rotation.
             * @api  
             */
            getRotation(): (number);

            /**
             * Get the text scale.
             * @return  Scale.
             * @api  
             */
            getScale(): (number);

            /**
             * Get the stroke style for the text.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke;

            /**
             * Get the text to be rendered.
             * @return  Text.
             * @api  
             */
            getText(): (string);

            /**
             * Get the text alignment.
             * @return  Text align.
             * @api  
             */
            getTextAlign(): (string);

            /**
             * Get the text baseline.
             * @return  Text baseline.
             * @api  
             */
            getTextBaseline(): (string);

            /**
             * Set the font.
             * @param  Font.
             * @api  
             */
            setFont(font: (string)): void;

            /**
             * Set the x offset.
             * @param  Horizontal text offset.
             * @api  
             */
            setOffsetX(offsetX: number): void;

            /**
             * Set the y offset.
             * @param  Vertical text offset.
             * @api  
             */
            setOffsetY(offsetY: number): void;

            /**
             * Set the fill.
             * @param  Fill style.
             * @api  
             */
            setFill(fill: undefined.Fill): void;

            /**
             * Set the rotation.
             * @param  Rotation.
             * @api  
             */
            setRotation(rotation: (number)): void;

            /**
             * Set the scale.
             * @param  Scale.
             * @api  
             */
            setScale(scale: (number)): void;

            /**
             * Set the stroke.
             * @param  Stroke style.
             * @api  
             */
            setStroke(stroke: undefined.Stroke): void;

            /**
             * Set the text.
             * @param  Text.
             * @api  
             */
            setText(text: (string)): void;

            /**
             * Set the text alignment.
             * @param  Text align.
             * @api  
             */
            setTextAlign(textAlign: (string)): void;

            /**
             * Set the text baseline.
             * @param  Text baseline.
             * @api  
             */
            setTextBaseline(textBaseline: (string)): void
        }

        /**
         * 
         * @typedef  *     radius: number,
        snapToPixel: (boolean|undefined),
        stroke: (ol.style.Stroke|undefined),
        atlasManager: (ol.style.AtlasManager|undefined)}}
        */
        declare interface CircleOptions {
            fill?: undefined.Fill,
                radius: number,
                snapToPixel?: boolean,
                stroke?: undefined.Stroke,
                atlasManager?: undefined.AtlasManager
        }

        /**
         * 
         * @typedef  
         */
        declare interface FillOptions {
            color?: (ol.Color | ol.ColorLike)
        }

        /**
         * 
         * @typedef  *     anchorOrigin: (ol.style.IconOrigin|undefined),
        anchorXUnits: (ol.style.IconAnchorUnits|undefined),
        anchorYUnits: (ol.style.IconAnchorUnits|undefined),
        color: (ol.Color|string|undefined),
        crossOrigin: (null|string|undefined),
        img: (Image|HTMLCanvasElement|undefined),
        offset: (Array.<number>|undefined),
        offsetOrigin: (ol.style.IconOrigin|undefined),
        opacity: (number|undefined),
        scale: (number|undefined),
        snapToPixel: (boolean|undefined),
        rotateWithView: (boolean|undefined),
        rotation: (number|undefined),
        size: (ol.Size|undefined),
        imgSize: (ol.Size|undefined),
        src: (string|undefined)}}
        */
        declare interface IconOptions {
            anchor?: number[],
                anchorOrigin?: undefined.IconOrigin,
                anchorXUnits?: undefined.IconAnchorUnits,
                anchorYUnits?: undefined.IconAnchorUnits,
                color?: (ol.Color | string),
                crossOrigin?: (string),
                img?: (any | HTMLCanvasElement),
                offset?: number[],
                offsetOrigin?: undefined.IconOrigin,
                opacity?: number,
                scale?: number,
                snapToPixel?: boolean,
                rotateWithView?: boolean,
                rotation?: number,
                size?: ol.Size,
                imgSize?: ol.Size,
                src: string
        }

        /**
         * Specify radius for regular polygons, or radius1 and radius2 for stars.
         * @typedef  *     points: number,
        radius: (number|undefined),
        radius1: (number|undefined),
        radius2: (number|undefined),
        angle: (number|undefined),
        snapToPixel: (boolean|undefined),
        stroke: (ol.style.Stroke|undefined),
        rotation: (number|undefined),
        rotateWithView: (boolean|undefined),
        atlasManager: (ol.style.AtlasManager|undefined)}}
        */
        declare interface RegularShapeOptions {
            fill?: undefined.Fill,
                points: number,
                radius?: number,
                radius1?: number,
                radius2?: number,
                angle?: number,
                snapToPixel?: boolean,
                stroke?: undefined.Stroke
        }

        /**
         * 
         * @typedef  *     lineCap: (string|undefined),
        lineJoin: (string|undefined),
        lineDash: (Array.<number>|undefined),
        miterLimit: (number|undefined),
        width: (number|undefined)}}
        */
        declare interface StrokeOptions {
            color?: ol.Color | string,
                lineCap?: string,
                lineJoin?: string,
                lineDash?: number[],
                miterLimit?: number,
                width?: number
        }

        /**
         * 
         * @typedef  *     offsetX: (number|undefined),
        offsetY: (number|undefined),
        scale: (number|undefined),
        rotateWithView: (boolean|undefined),
        rotation: (number|undefined),
        text: (string|undefined),
        textAlign: (string|undefined),
        textBaseline: (string|undefined),
        fill: (ol.style.Fill|undefined),
        stroke: (ol.style.Stroke|undefined)}}
        */
        declare interface TextOptions {
            font?: string,
                offsetX?: number,
                offsetY?: number,
                scale?: number,
                rotation?: number,
                text?: string,
                textAlign?: string,
                textBaseline?: string,
                fill?: undefined.Fill,
                stroke?: undefined.Stroke
        }

        /**
         * 
         * @typedef  *     fill: (ol.style.Fill|undefined),
        image: (ol.style.Image|undefined),
        stroke: (ol.style.Stroke|undefined),
        text: (ol.style.Text|undefined),
        zIndex: (number|undefined)}}
        */
        declare interface StyleOptions {
            geometry?: (string | undefined.Geometry | ol.StyleGeometryFunction),
                fill?: undefined.Fill,
                image?: undefined.Image,
                stroke?: undefined.Stroke,
                text?: undefined.Text,
                zIndex?: number
        }

        /**
         * 
         * @typedef  *     maxSize: (number|undefined),
        space: (number|undefined)}}
        */
        declare interface AtlasManagerOptions {
            initialSize?: number,
                maxSize?: number,
                space?: number
        }
    }

    declare module 'Tile' {

        /**
         * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
         * @enum  {string}
         */
        declare type State = string;
    }

    declare module 'tilegrid' {

        /**
         * Creates a tile grid with a standard XYZ tiling scheme.
         * @param  Tile grid options.
         * @return  Tile grid instance.
         * @api  
         */
        declare     function createXYZ(opt_options?: undefined.XYZOptions): undefined.TileGrid

        /**
         * 
         * @classdesc  * Base class for setting the grid pattern for sources accessing tiled-image
        servers.
         * @constructor  * 
         * @param  Tile grid options.
         * @struct  * 
         * @api  stable
        */
        declare class TileGrid {

            /**
             * 
             * @classdesc  * Base class for setting the grid pattern for sources accessing tiled-image
            servers.
             * @constructor  * 
             * @param  Tile grid options.
             * @struct  * 
             * @api  stable
            */
            constructor(options: undefined.TileGridOptions): this;

            /**
             * Call a function with each tile coordinate for a given extent and zoom level.
             * @param  Extent.
             * @param  Zoom level.
             * @param  Function called with each tile coordinate.
             * @api  
             */
            forEachTileCoord(
                extent: ol.Extent,
                zoom: number,
                callback: ((coords: ol.TileCoord) => any)): void;

            /**
             * Get the maximum zoom level for the grid.
             * @return  Max zoom.
             * @api  
             */
            getMaxZoom(): number;

            /**
             * Get the minimum zoom level for the grid.
             * @return  Min zoom.
             * @api  
             */
            getMinZoom(): number;

            /**
             * Get the origin for the grid at the given zoom level.
             * @param  Z.
             * @return  Origin.
             * @api  stable
             */
            getOrigin(z: number): ol.Coordinate;

            /**
             * Get the resolution for the given zoom level.
             * @param  Z.
             * @return  Resolution.
             * @api  stable
             */
            getResolution(z: number): number;

            /**
             * Get the list of resolutions for the tile grid.
             * @return  Resolutions.
             * @api  stable
             */
            getResolutions(): number[];

            /**
             * Get the extent of a tile coordinate.
             * @param  Tile coordinate.
             * @param  Temporary extent object.
             * @return  Extent.
             * @api  
             */
            getTileCoordExtent(tileCoord: ol.TileCoord, opt_extent?: ol.Extent): ol.Extent;

            /**
             * Get the tile coordinate for the given map coordinate and resolution.  This
             * method considers that coordinates that intersect tile boundaries should be
            assigned the higher tile coordinate.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Destination ol.TileCoord object.
             * @return  Tile coordinate.
             * @api  
            */
            getTileCoordForCoordAndResolution(
                coordinate: ol.Coordinate,
                resolution: number,
                opt_tileCoord?: ol.TileCoord): ol.TileCoord;

            /**
             * Get a tile coordinate given a map coordinate and zoom level.
             * @param  Coordinate.
             * @param  Zoom level.
             * @param  Destination ol.TileCoord object.
             * @return  Tile coordinate.
             * @api  
             */
            getTileCoordForCoordAndZ(
                coordinate: ol.Coordinate,
                z: number,
                opt_tileCoord?: ol.TileCoord): ol.TileCoord;

            /**
             * Get the tile size for a zoom level. The type of the return value matches the
             * `tileSize` or `tileSizes` that the tile grid was configured with. To always
            get an `ol.Size`, run the result through `ol.size.toSize()`.
             * @param  Z.
             * @return  Tile size.
             * @api  stable
            */
            getTileSize(z: number): (number | ol.Size);

            /**
             * 
             * @param  Resolution.
             * @param  If 0, the nearest resolution will be used.
            If 1, the nearest lower resolution will be used. If -1, the nearest
            higher resolution will be used. Default is 0.
             * @return  Z.
             * @api  
            */
            getZForResolution(resolution: number, opt_direction?: number): number
        }

        /**
         * 
         * @classdesc  * Set the grid pattern for sources accessing WMTS tiled-image servers.
         * @constructor  * 
         * @extends  {ol.tilegrid.TileGrid}
         * @param  WMTS options.
         * @struct  * 
         * @api  
         */
        declare class WMTS mixins undefined.TileGrid {

            /**
             * 
             * @classdesc  * Set the grid pattern for sources accessing WMTS tiled-image servers.
             * @constructor  * 
             * @extends  {ol.tilegrid.TileGrid}
             * @param  WMTS options.
             * @struct  * 
             * @api  
             */
            constructor(options: undefined.WMTSOptions): this;

            /**
             * Get the list of matrix identifiers.
             * @return  MatrixIds.
             * @api  
             */
            getMatrixIds(): string[];

            /**
             * Create a tile grid from a WMTS capabilities matrix set.
             * @param  An object representing a matrixSet in the
            capabilities document.
             * @param  An optional extent to restrict the tile
            ranges the server provides.
             * @return  WMTS tileGrid instance.
             * @api  
            */
            createFromCapabilitiesMatrixSet(matrixSet: GlobalObject, opt_extent?: ol.Extent): undefined.WMTS
        }

        /**
         * 
         * @typedef  *     minZoom: (number|undefined),
        origin: (ol.Coordinate|undefined),
        origins: (Array.<ol.Coordinate>|undefined),
        resolutions: !Array.<number>,
        sizes: (Array.<ol.Size>|undefined),
        tileSize: (number|ol.Size|undefined),
        tileSizes: (Array.<number|ol.Size>|undefined)}}
        */
        declare interface TileGridOptions {
            extent?: ol.Extent,
                minZoom?: number,
                origin?: ol.Coordinate,
                origins?: ol.Coordinate[],
                resolutions: number[],
                tileSize?: (number | ol.Size),
                tileSizes?: ((number | ol.Size)[])
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (string|null|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: ol.tilegrid.WMTS,
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        requestEncoding: (ol.source.WMTSRequestEncoding|string|undefined),
        layer: string,
        style: string,
        tilePixelRatio: (number|undefined),
        version: (string|undefined),
        format: (string|undefined),
        matrixSet: string,
        dimensions: (!Object|undefined),
        url: (string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        urls: (Array.<string>|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface WMTSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                tileGrid: undefined.WMTS,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                requestEncoding?: (undefined.WMTSRequestEncoding | string),
                layer: string,
                style: string,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tilePixelRatio?: number,
                version?: string,
                format?: string,
                matrixSet: string,
                dimensions?: GlobalObject,
                url?: string,
                tileLoadFunction?: ol.TileLoadFunctionType,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileSize: (number|ol.Size|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface XYZOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                maxZoom?: number,
                minZoom?: number,
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileSize?: (number | ol.Size),
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }
    }


    /**
     * 
     * @typedef  
     */
    declare type AttributionLike = (string | string[] | ol.Attribution | ol.Attribution[]);

    /**
     * A function returning the canvas element (`{HTMLCanvasElement}`)
     * used by the source as an image. The arguments passed to the function are:
    {
     * @link  ol.Extent} the image extent, `{number}` the image resolution,
    `{number}` the device pixel ratio, {
     * @link  ol.Size} the image size, and
    {
     * @link  ol.proj.Projection} the image projection. The canvas returned by
    this function is cached by the source. The this keyword inside the function
    references the {
     * @link  ol.source.ImageCanvas}.
     * @typedef  
    */
    declare type CanvasFunctionType = (
        extent: ol.Extent,
        resolution: number,
        pixelRatio: number,
        size: ol.Size,
        proj: undefined.Projection) => HTMLCanvasElement;

    /**
     * A color represented as a short array [red, green, blue, alpha].
     * red, green, and blue should be integers in the range 0..255 inclusive.
    alpha should be a float in the range 0..1 inclusive. If no alpha value is
    given then `1` will be used.
     * @typedef  
    */
    declare type Color = ([number, number, number, number] | Uint8Array | Uint8ClampedArray);

    /**
     * A type accepted by CanvasRenderingContext2D.fillStyle.
     * Represents a color, pattern, or gradient.
     * @typedef  
     */
    declare type ColorLike = (string | CanvasPattern | CanvasGradient);

    /**
     * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
     * @typedef  
     */
    declare type Coordinate = [number, number];

    /**
     * A function that takes a {@link ol.Coordinate} and transforms it into a
     * `{string}`.
     * @typedef  
     */
    declare type CoordinateFormatType = (coords?: ol.Coordinate) => string;

    /**
     * A function that takes a {@link ol.MapBrowserEvent} and two
     * {
     * @link  ol.Pixel}s and returns a `{boolean}`. If the condition is met,
    true should be returned.
     * @typedef  
    */
    declare type DragBoxEndConditionType = (event: ol.MapBrowserEvent, pixel1: ol.Pixel, pixel2: ol.Pixel) => boolean;

    /**
     * Function that takes coordinates and an optional existing geometry as
     * arguments, and returns a geometry. The optional existing geometry is the
    geometry that is returned when the function is called without a second
    argument.
     * @typedef  , ol.geom.SimpleGeometry=):
    ol.geom.SimpleGeometry}
    */
    declare type DrawGeometryFunctionType = (
        coords: (ol.Coordinate | ol.Coordinate[] | ol.Coordinate[][]),
        geo: undefined.SimpleGeometry) => undefined.SimpleGeometry;

    /**
     * A function that takes an {@link ol.MapBrowserEvent} and returns a
     * `{boolean}`. If the condition is met, true should be returned.
     * @typedef  
     */
    declare type EventsConditionType = (event: ol.MapBrowserEvent) => boolean;

    /**
     * Key to use with {@link ol.Observable#unByKey}.
     * @typedef  *     boundListener: (ol.EventsListenerFunctionType|undefined),
    callOnce: boolean,
    deleteIndex: (number|undefined),
    listener: ol.EventsListenerFunctionType,
    target: (EventTarget|ol.events.EventTarget),
    type: string}}
    */
    declare type EventsKey = Object;

    /**
     * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
     * @typedef  
     */
    declare type Extent = [number, number, number, number];

    /**
     * {
     * @link  ol.source.Vector} sources use a function of this type to load
    features.

    This function takes an {
     * @link  ol.Extent} representing the area to be loaded,
    a `{number}` representing the resolution (map units per pixel) and an
    {
     * @link  ol.proj.Projection} for the projection  as arguments. `this` within
    the function is bound to the {
     * @link  ol.source.Vector} it's called from.

    The function is responsible for loading the features and adding them to the
    source.
     * @typedef  
    */
    declare type FeatureLoader = (extent: ol.Extent, resolution: number, proj: undefined.Projection) => void;

    /**
     * A function that returns an array of {@link ol.style.Style styles} given a
     * resolution. The `this` keyword inside the function references the
    {
     * @link  ol.Feature} to be styled.
     * @typedef  (ol.style.Style|Array.<ol.style.Style>)}
    */
    declare type FeatureStyleFunction = (resolution: number) => (undefined.Style | undefined.Style[]);

    /**
     * {
     * @link  ol.source.Vector} sources use a function of this type to get the url
    to load features from.

    This function takes an {
     * @link  ol.Extent} representing the area to be loaded,
    a `{number}` representing the resolution (map units per pixel) and an
    {
     * @link  ol.proj.Projection} for the projection  as arguments and returns a
    `{string}` representing the URL.
     * @typedef  
    */
    declare type FeatureUrlFunction = (extent: ol.Extent, resolution: number, proj: undefined.Projection) => string;

    /**
     * A function that takes an {@link ol.Image} for the image and a `{string}` for
     * the src as arguments. It is supposed to make it so the underlying image
    {
     * @link  ol.Image#getImage} is assigned the content specified by the src. If
    not specified, the default is

    function(image, src) {
    image.getImage().src = src;
    }

    Providing a custom `imageLoadFunction` can be useful to load images with
    post requests or - in general - through XHR requests, where the src of the
    image element would be set to a data URI when the content is loaded.
     * @typedef  
    */
    declare type ImageLoadFunctionType = (image: ol.Image, url: string) => void;

    /**
     * A function that takes an {@link ol.Extent} and a resolution as arguments, and
     * returns an array of {@link ol.Extent} with the extents to load. Usually this
    is one of the standard {@link ol.loadingstrategy} strategies.
     * @typedef  
    */
    declare type LoadingStrategy = (extent: ol.Extent, resolution: number) => ol.Extent[];
    declare type ModifyEventType = string;

    /**
     * An array with two elements, representing a pixel. The first element is the
     * x-coordinate, the second the y-coordinate of the pixel.
     * @typedef  
     */
    declare type Pixel = [number, number];

    /**
     * Function to perform manipulations before rendering. This function is called
     * with the {@link ol.Map} as first and an optional {@link olx.FrameState} as
    second argument. Return `true` to keep this function for the next frame,
    `false` to remove it.
     * @typedef  
    */
    declare type PreRenderFunction = (map: ol.Map, state?: olx.FrameState) => boolean;

    /**
     * A projection as {@link ol.proj.Projection}, SRS identifier string or
     * undefined.
     * @typedef  
     */
    declare type ProjectionLike = (undefined.Projection | string);

    /**
     * A function that takes an array of input data, performs some operation, and
     * returns an array of ouput data.
    For `pixel` type operations, the function will be called with an array of
    pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
    range of 0 - 255. It should return a single pixel array.
    For `'image'` type operations, functions will be called with an array of
    {
     * @link  ImageData https://developer.mozilla.org/en-US/docs/Web/API/ImageData}
    and should return a single {
     * @link  ImageData
    https://developer.mozilla.org/en-US/docs/Web/API/ImageData}.  The operations
    are called with a second "data" argument, which can be used for storage.  The
    data object is accessible from raster events, where it can be initialized in
    "beforeoperations" and accessed again in "afteroperations".
     * @typedef  (Array.<number>|ImageData)}
    */
    declare type RasterOperation = (data: (number[][] | ImageData[]), obj: GlobalObject) => (number[] | ImageData);

    /**
     * A function that takes an {@link ol.Feature} or {@link ol.render.Feature} and
     * an {@link ol.layer.Layer} and returns `true` if the feature may be selected
    or `false` otherwise.
     * @typedef  }
    */
    declare type SelectFilterFunction = (feature: (ol.Feature | undefined.Feature), layer: undefined.Layer) => boolean;

    /**
     * An array of numbers representing a size: `[width, height]`.
     * @typedef  
     */
    declare type Size = [number, number];

    /**
     * 
     * @typedef  *            extent: (null|ol.Extent|undefined),
    logo: (string|olx.LogoOptions|undefined),
    projection: ol.ProjectionLike,
    resolutions: (Array.<number>|undefined),
    state: (ol.source.State|undefined)}}
    */
    declare interface SourceImageOptions {
        attributions?: ol.AttributionLike,
            extent?: (ol.Extent),
            logo?: (string | olx.LogoOptions),
            projection: ol.ProjectionLike,
            resolutions?: number[],
            state?: undefined.State
    }

    /**
     * 
     * @typedef  *            logo: (string|olx.LogoOptions|undefined),
    projection: ol.ProjectionLike,
    state: (ol.source.State|undefined),
    wrapX: (boolean|undefined)}}
    */
    declare interface SourceSourceOptions {
        attributions?: ol.AttributionLike,
            logo?: (string | olx.LogoOptions),
            projection: ol.ProjectionLike,
            state?: undefined.State,
            wrapX?: boolean
    }

    /**
     * 
     * @typedef  *            cacheSize: (number|undefined),
    extent: (ol.Extent|undefined),
    logo: (string|olx.LogoOptions|undefined),
    opaque: (boolean|undefined),
    projection: ol.ProjectionLike,
    state: (ol.source.State|undefined),
    tileGrid: (ol.tilegrid.TileGrid|undefined),
    tileLoadFunction: ol.TileLoadFunctionType,
    tilePixelRatio: (number|undefined),
    tileUrlFunction: (ol.TileUrlFunctionType|undefined),
    url: (string|undefined),
    urls: (Array.<string>|undefined),
    wrapX: (boolean|undefined)}}
    */
    declare interface SourceUrlTileOptions {
        attributions?: ol.AttributionLike,
            cacheSize?: number,
            extent?: ol.Extent,
            logo?: (string | olx.LogoOptions),
            opaque?: boolean,
            projection: ol.ProjectionLike,
            state?: undefined.State,
            tileGrid?: undefined.TileGrid,
            tileLoadFunction: ol.TileLoadFunctionType,
            tilePixelRatio?: number,
            tileUrlFunction?: ol.TileUrlFunctionType,
            url?: string,
            urls?: string[],
            wrapX?: boolean
    }

    /**
     * 
     * @typedef  *            cacheSize: (number|undefined),
    extent: (ol.Extent|undefined),
    logo: (string|olx.LogoOptions|undefined),
    opaque: (boolean|undefined),
    tilePixelRatio: (number|undefined),
    projection: ol.ProjectionLike,
    state: (ol.source.State|undefined),
    tileGrid: (ol.tilegrid.TileGrid|undefined),
    wrapX: (boolean|undefined)}}
    */
    declare interface SourceTileOptions {
        attributions?: ol.AttributionLike,
            cacheSize?: number,
            extent?: ol.Extent,
            logo?: (string | olx.LogoOptions),
            opaque?: boolean,
            tilePixelRatio?: number,
            projection: ol.ProjectionLike,
            state?: undefined.State,
            tileGrid?: undefined.TileGrid,
            wrapX?: boolean
    }

    /**
     * 
     * @typedef  *            rotateWithView: boolean,
    rotation: number,
    scale: number,
    snapToPixel: boolean}}
    */
    declare interface StyleImageOptions {
        opacity: number,
            rotateWithView: boolean,
            rotation: number,
            scale: number,
            snapToPixel: boolean
    }

    /**
     * A function that takes an {@link ol.Feature} and a `{number}` representing
     * the view's resolution. The function should return a {@link ol.style.Style}
    or an array of them. This way e.g. a vector layer can be styled.
     * @typedef  (ol.style.Style|Array.<ol.style.Style>)}
    */
    declare type StyleFunction = (
        feature: (ol.Feature | undefined.Feature),
        resolution: number) => (undefined.Style | undefined.Style[]);

    /**
     * A function that takes an {@link ol.Feature} as argument and returns an
     * {
     * @link  ol.geom.Geometry} that will be rendered and styled for the feature.
     * @typedef  (ol.geom.Geometry|ol.render.Feature|undefined)}
     */
    declare type StyleGeometryFunction = (
        feature: (ol.Feature | undefined.Feature)) => (undefined.Geometry | undefined.Feature);

    /**
     * An array of three numbers representing the location of a tile in a tile
     * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
     * @typedef  
     */
    declare type TileCoord = [number, number, number];

    /**
     * A function that takes an {@link ol.Tile} for the tile and a `{string}` for
     * the url as arguments.
     * @typedef  
     */
    declare type TileLoadFunctionType = (tile: ol.Tile, url: string) => void;

    /**
     * {
     * @link  ol.source.Tile} sources use a function of this type to get the url
    that provides a tile for a given tile coordinate.

    This function takes an {
     * @link  ol.TileCoord} for the tile coordinate, a
    `{number}` representing the pixel ratio and an {
     * @link  ol.proj.Projection} for
    the projection  as arguments and returns a `{string}` representing the tile
    URL, or undefined if no tile should be requested for the passed tile
    coordinate.
     * @typedef  
    */
    declare type TileUrlFunctionType = (coords: ol.TileCoord, pixelRatio: number, proj: undefined.Projection) => string;

    /**
     * A transform function accepts an array of input coordinate values, an optional
     * output array, and an optional dimension (default should be 2).  The function
    transforms the input coordinate values, populates the output array, and
    returns the output array.
     * @typedef  
    */
    declare type TransformFunction = (array: number[], out?: number[], dimension?: number) => number[];

    /**
     * Number of features; bounds/extent.
     * @typedef  *            bounds: ol.Extent}}
     */
    declare type WFSFeatureCollectionMetadata = Object;

    /**
     * Total deleted; total inserted; total updated; array of insert ids.
     * @typedef  *            totalInserted: number,
    totalUpdated: number,
    insertIds: Array.<string>}}
    */
    declare type WFSTransactionResponse = Object;

    /**
     * 
     * @constructor  * 
     * @extends  {ol.Tile}
     * @param  Tile coordinate.
     * @param  State.
     * @param  Data source url.
     * @param  Feature format.
     * @param  Tile load function.
     */
    declare class VectorTile mixins ol.Tile {

        /**
         * 
         * @constructor  * 
         * @extends  {ol.Tile}
         * @param  Tile coordinate.
         * @param  State.
         * @param  Data source url.
         * @param  Feature format.
         * @param  Tile load function.
         */
        constructor(tileCoord: ol.TileCoord, state: undefined.State, src: string, format: undefined.Feature, tileLoadFunction: ol.TileLoadFunctionType): this;

        /**
         * Get the feature format assigned for reading this tile's features.
         * @return  Feature format.
         * @api  
         */
        getFormat(): undefined.Feature;

        /**
         * 
         * @param  Features.
         * @api  
         */
        setFeatures(features: ol.Feature[]): void;

        /**
         * Set the projection of the features that were added with {@link #setFeatures}.
         * @param  Feature projection.
         * @api  
         */
        setProjection(projection: undefined.Projection): void;

        /**
         * Set the feature loader for reading this tile's features.
         * @param  Feature loader.
         * @api  
         */
        setLoader(loader: ol.FeatureLoader): void
    }

    /**
     * 
     * @classdesc  * An ol.View object represents a simple 2D view of the map.

    This is the object to act upon to change the center, resolution,
    and rotation of the map.

    ### The view states

    An `ol.View` is determined by three states: `center`, `resolution`,
    and `rotation`. Each state has a corresponding getter and setter, e.g.
    `getCenter` and `setCenter` for the `center` state.

    An `ol.View` has a `projection`. The projection determines the
    coordinate system of the center, and its units determine the units of the
    resolution (projection units per pixel). The default projection is
    Spherical Mercator (EPSG:3857).

    ### The constraints

    `setCenter`, `setResolution` and `setRotation` can be used to change the
    states of the view. Any value can be passed to the setters. And the value
    that is passed to a setter will effectively be the value set in the view,
    and returned by the corresponding getter.

    But an `ol.View` object also has a *resolution constraint*, a
    *rotation constraint* and a *center constraint*.

    As said above, no constraints are applied when the setters are used to set
    new states for the view. Applying constraints is done explicitly through
    the use of the `constrain*` functions (`constrainResolution` and
    `constrainRotation` and `constrainCenter`).

    The main users of the constraints are the interactions and the
    controls. For example, double-clicking on the map changes the view to
    the "next" resolution. And releasing the fingers after pinch-zooming
    snaps to the closest resolution (with an animation).

    The *resolution constraint* snaps to specific resolutions. It is
    determined by the following options: `resolutions`, `maxResolution`,
    `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
    options are ignored. See documentation for each option for more
    information.

    The *rotation constraint* snaps to specific angles. It is determined
    by the following options: `enableRotation` and `constrainRotation`.
    By default the rotation value is snapped to zero when approaching the
    horizontal.

    The *center constraint* is determined by the `extent` option. By
    default the center is not constrained at all.
     * @constructor  * 
     * @extends  {ol.Object}
     * @param  View options.
     * @api  stable
    */
    declare class View mixins ol.Object {

        /**
         * 
         * @classdesc  * An ol.View object represents a simple 2D view of the map.

        This is the object to act upon to change the center, resolution,
        and rotation of the map.

        ### The view states

        An `ol.View` is determined by three states: `center`, `resolution`,
        and `rotation`. Each state has a corresponding getter and setter, e.g.
        `getCenter` and `setCenter` for the `center` state.

        An `ol.View` has a `projection`. The projection determines the
        coordinate system of the center, and its units determine the units of the
        resolution (projection units per pixel). The default projection is
        Spherical Mercator (EPSG:3857).

        ### The constraints

        `setCenter`, `setResolution` and `setRotation` can be used to change the
        states of the view. Any value can be passed to the setters. And the value
        that is passed to a setter will effectively be the value set in the view,
        and returned by the corresponding getter.

        But an `ol.View` object also has a *resolution constraint*, a
        *rotation constraint* and a *center constraint*.

        As said above, no constraints are applied when the setters are used to set
        new states for the view. Applying constraints is done explicitly through
        the use of the `constrain*` functions (`constrainResolution` and
        `constrainRotation` and `constrainCenter`).

        The main users of the constraints are the interactions and the
        controls. For example, double-clicking on the map changes the view to
        the "next" resolution. And releasing the fingers after pinch-zooming
        snaps to the closest resolution (with an animation).

        The *resolution constraint* snaps to specific resolutions. It is
        determined by the following options: `resolutions`, `maxResolution`,
        `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
        options are ignored. See documentation for each option for more
        information.

        The *rotation constraint* snaps to specific angles. It is determined
        by the following options: `enableRotation` and `constrainRotation`.
        By default the rotation value is snapped to zero when approaching the
        horizontal.

        The *center constraint* is determined by the `extent` option. By
        default the center is not constrained at all.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  View options.
         * @api  stable
        */
        constructor(opt_options?: olx.ViewOptions): this;

        /**
         * Get the constrained center of this view.
         * @param  Center.
         * @return  Constrained center.
         * @api  
         */
        constrainCenter(center: (ol.Coordinate)): (ol.Coordinate);

        /**
         * Get the constrained resolution of this view.
         * @param  Resolution.
         * @param  Delta. Default is `0`.
         * @param  Direction. Default is `0`.
         * @return  Constrained resolution.
         * @api  
         */
        constrainResolution(resolution: (number), opt_delta?: number, opt_direction?: number): (number);

        /**
         * Get the constrained rotation of this view.
         * @param  Rotation.
         * @param  Delta. Default is `0`.
         * @return  Constrained rotation.
         * @api  
         */
        constrainRotation(rotation: (number), opt_delta?: number): (number);

        /**
         * Get the view center.
         * @return  The center of the view.
         * @observable  * 
         * @api  stable
         */
        getCenter(): (ol.Coordinate);

        /**
         * Calculate the extent for the current view state and the passed size.
         * The size is the pixel dimensions of the box into which the calculated extent
        should fit. In most cases you want to get the extent of the entire map,
        that is `map.getSize()`.
         * @param  Box pixel size.
         * @return  Extent.
         * @api  stable
        */
        calculateExtent(size: ol.Size): ol.Extent;

        /**
         * Get the maximum resolution of the view.
         * @return  The maximum resolution of the view.
         * @api  
         */
        getMaxResolution(): number;

        /**
         * Get the minimum resolution of the view.
         * @return  The minimum resolution of the view.
         * @api  
         */
        getMinResolution(): number;

        /**
         * Get the view projection.
         * @return  The projection of the view.
         * @api  stable
         */
        getProjection(): undefined.Projection;

        /**
         * Get the view resolution.
         * @return  The resolution of the view.
         * @observable  * 
         * @api  stable
         */
        getResolution(): (number);

        /**
         * Get the resolutions for the view. This returns the array of resolutions
         * passed to the constructor of the {ol.View}, or undefined if none were given.
         * @return  The resolutions of the view.
         * @api  stable
         */
        getResolutions(): (number[]);

        /**
         * Get the view rotation.
         * @return  The rotation of the view in radians.
         * @observable  * 
         * @api  stable
         */
        getRotation(): number;

        /**
         * Get the current zoom level. Return undefined if the current
         * resolution is undefined or not within the "resolution constraints".
         * @return  Zoom.
         * @api  stable
         */
        getZoom(): (number);

        /**
         * Fit the given geometry or extent based on the given map size and border.
         * The size is pixel dimensions of the box to fit the extent into.
        In most cases you will want to use the map size, that is `map.getSize()`.
        Takes care of the map angle.
         * @param  Geometry.
         * @param  Box pixel size.
         * @param  Options.
         * @api  
        */
        fit(
            geometry: (undefined.SimpleGeometry | ol.Extent),
            size: ol.Size,
            opt_options?: undefined.FitOptions): void;

        /**
         * Center on coordinate and view position.
         * @param  Coordinate.
         * @param  Box pixel size.
         * @param  Position on the view to center on.
         * @api  
         */
        centerOn(coordinate: ol.Coordinate, size: ol.Size, position: ol.Pixel): void;

        /**
         * Rotate the view around a given coordinate.
         * @param  New rotation value for the view.
         * @param  The rotation center.
         * @api  stable
         */
        rotate(rotation: number, opt_anchor?: ol.Coordinate): void;

        /**
         * Set the center of the current view.
         * @param  The center of the view.
         * @observable  * 
         * @api  stable
         */
        setCenter(center: (ol.Coordinate)): void;

        /**
         * Set the resolution for this view.
         * @param  The resolution of the view.
         * @observable  * 
         * @api  stable
         */
        setResolution(resolution: (number)): void;

        /**
         * Set the rotation for this view.
         * @param  The rotation of the view in radians.
         * @observable  * 
         * @api  stable
         */
        setRotation(rotation: number): void;

        /**
         * Zoom to a specific zoom level.
         * @param  Zoom level.
         * @api  stable
         */
        setZoom(zoom: number): void
    }
}
declare module 'olx' {
    declare module 'animation' {

        /**
         * Generate an animated transition that will "bounce" the resolution as it
         * approaches the final value.
         * @param  Bounce options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function bounce(options: undefined.BounceOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view center.
         * @param  Pan options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function pan(options: undefined.PanOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view rotation.
         * @param  Rotate options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function rotate(options: undefined.RotateOptions): ol.PreRenderFunction

        /**
         * Generate an animated transition while updating the view resolution.
         * @param  Zoom options.
         * @return  Pre-render function.
         * @api  
         */
        declare     function zoom(options: undefined.ZoomOptions): ol.PreRenderFunction

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface BounceOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface PanOptions {
            source: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     anchor: (ol.Coordinate|undefined),
        start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface RotateOptions {
            rotation?: number,
                anchor?: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface ZoomOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }
    }

    declare module 'control' {

        /**
         * 
         * @classdesc  * Control to show all the attributions associated with the layer sources
        in the map. This control is one of the default controls included in maps.
        By default it will show in the bottom right portion of the map, but this can
        be changed by using a css selector for `.ol-attribution`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Attribution options.
         * @api  stable
        */
        declare class Attribution mixins undefined.Control {

            /**
             * 
             * @classdesc  * Control to show all the attributions associated with the layer sources
            in the map. This control is one of the default controls included in maps.
            By default it will show in the bottom right portion of the map, but this can
            be changed by using a css selector for `.ol-attribution`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Attribution options.
             * @api  stable
            */
            constructor(opt_options?: undefined.AttributionOptions): this;

            /**
             * Update the attribution element.
             * @param  Map event.
             * @this  {ol.control.Attribution}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void;

            /**
             * Return `true` if the attribution is collapsible, `false` otherwise.
             * @return  True if the widget is collapsible.
             * @api  stable
             */
            getCollapsible(): boolean;

            /**
             * Set whether the attribution should be collapsible.
             * @param  True if the widget is collapsible.
             * @api  stable
             */
            setCollapsible(collapsible: boolean): void;

            /**
             * Collapse or expand the attribution according to the passed parameter. Will
             * not do anything if the attribution isn't collapsible or if the current
            collapsed state is already the one requested.
             * @param  True if the widget is collapsed.
             * @api  stable
            */
            setCollapsed(collapsed: boolean): void;

            /**
             * Return `true` when the attribution is currently collapsed or `false`
             * otherwise.
             * @return  True if the widget is collapsed.
             * @api  stable
             */
            getCollapsed(): boolean
        }

        /**
         * 
         * @classdesc  * A control is a visible widget with a DOM element in a fixed position on the
        screen. They can involve user input (buttons), or be informational only;
        the position is determined using CSS. By default these are placed in the
        container with CSS class name `ol-overlaycontainer-stopevent`, but can use
        any outside DOM element.

        This is the base class for controls. You can use it for simple custom
        controls by creating the element with listeners, creating an instance:
        ```js
        var myControl = new ol.control.Control({element: myElement});
        ```
        and then adding this to the map.

        The main advantage of having this as a control rather than a simple separate
        DOM element is that preventing propagation is handled for you. Controls
        will also be `ol.Object`s in a `ol.Collection`, so you can use their
        methods.

        You can also extend this base for your own control class. See
        examples/custom-controls for an example of how to do this.
         * @constructor  * 
         * @extends  {ol.Object}
         * @implements  {oli.control.Control}
         * @param  Control options.
         * @api  stable
        */
        declare class Control mixins ol.Object {

            /**
             * 
             * @classdesc  * A control is a visible widget with a DOM element in a fixed position on the
            screen. They can involve user input (buttons), or be informational only;
            the position is determined using CSS. By default these are placed in the
            container with CSS class name `ol-overlaycontainer-stopevent`, but can use
            any outside DOM element.

            This is the base class for controls. You can use it for simple custom
            controls by creating the element with listeners, creating an instance:
            ```js
            var myControl = new ol.control.Control({element: myElement});
            ```
            and then adding this to the map.

            The main advantage of having this as a control rather than a simple separate
            DOM element is that preventing propagation is handled for you. Controls
            will also be `ol.Object`s in a `ol.Collection`, so you can use their
            methods.

            You can also extend this base for your own control class. See
            examples/custom-controls for an example of how to do this.
             * @constructor  * 
             * @extends  {ol.Object}
             * @implements  {oli.control.Control}
             * @param  Control options.
             * @api  stable
            */
            constructor(options: undefined.ControlOptions): this;

            /**
             * Get the map associated with this control.
             * @return  Map.
             * @api  stable
             */
            getMap(): ol.Map;

            /**
             * Remove the control from its current map and attach it to the new map.
             * Subclasses may set up event handlers to get notified about changes to
            the map here.
             * @param  Map.
             * @api  stable
            */
            setMap(map: ol.Map): void;

            /**
             * This function is used to set a target element for the control. It has no
             * effect if it is called after the control has been added to the map (i.e.
            after `setMap` is called on the control). If no `target` is set in the
            options passed to the control constructor and if `setTarget` is not called
            then the control is added to the map's overlay container.
             * @param  Target.
             * @api  
            */
            setTarget(target: (Element | string)): void
        }

        /**
         * 
         * @classdesc  * Provides a button that when clicked fills up the full screen with the map.
        The full screen source element is by default the element containing the map viewport unless
        overriden by providing the `source` option. In which case, the dom
        element introduced using this parameter will be displayed in full screen.

        When in full screen mode, a close button is shown to exit full screen mode.
        The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
        toggle the map in full screen mode.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Options.
         * @api  stable
        */
        declare class FullScreen mixins undefined.Control {

            /**
             * 
             * @classdesc  * Provides a button that when clicked fills up the full screen with the map.
            The full screen source element is by default the element containing the map viewport unless
            overriden by providing the `source` option. In which case, the dom
            element introduced using this parameter will be displayed in full screen.

            When in full screen mode, a close button is shown to exit full screen mode.
            The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
            toggle the map in full screen mode.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.FullScreenOptions): this
        }

        /**
         * Set of controls included in maps by default. Unless configured otherwise,
         * this returns a collection containing an instance of each of the following
        controls:
        * {@link ol.control.Zoom}
        * {@link ol.control.Rotate}
        * {@link ol.control.Attribution}
         * @param  Defaults options.
         * @return  Controls.
         * @api  stable
        */
        declare     function defaults(opt_options?: undefined.DefaultsOptions): ol.Collection<undefined.Control >

            /**
             * 
             * @classdesc  * A control to show the 2D coordinates of the mouse cursor. By default, these
            are in the view projection, but can be in any supported projection.
            By default the control is shown in the top right corner of the map, but this
            can be changed by using the css selector `.ol-mouse-position`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Mouse position
            options.
             * @api  stable
            */
            declare class MousePosition mixins undefined.Control {

                /**
                 * 
                 * @classdesc  * A control to show the 2D coordinates of the mouse cursor. By default, these
                are in the view projection, but can be in any supported projection.
                By default the control is shown in the top right corner of the map, but this
                can be changed by using the css selector `.ol-mouse-position`.
                 * @constructor  * 
                 * @extends  {ol.control.Control}
                 * @param  Mouse position
                options.
                 * @api  stable
                */
                constructor(opt_options?: undefined.MousePositionOptions): this;

                /**
                 * Update the mouseposition element.
                 * @param  Map event.
                 * @this  {ol.control.MousePosition}
                 * @api  
                 */
                render(mapEvent: ol.MapEvent): void;

                /**
                 * Return the coordinate format type used to render the current position or
                 * undefined.
                 * @return  The format to render the current
                position in.
                 * @observable  * 
                 * @api  stable
                */
                getCoordinateFormat(): (ol.CoordinateFormatType);

                /**
                 * Return the projection that is used to report the mouse position.
                 * @return  The projection to report mouse
                position in.
                 * @observable  * 
                 * @api  stable
                */
                getProjection(): (undefined.Projection);

                /**
                 * Set the coordinate format type used to render the current position.
                 * @param  The format to render the current
                position in.
                 * @observable  * 
                 * @api  stable
                */
                setCoordinateFormat(format: ol.CoordinateFormatType): void;

                /**
                 * Set the projection that is used to report the mouse position.
                 * @param  The projection to report mouse
                position in.
                 * @observable  * 
                 * @api  stable
                */
                setProjection(projection: undefined.Projection): void
            }

        /**
         * Create a new control with a map acting as an overview map for an other
         * defined map.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  OverviewMap options.
         * @api  
         */
        declare class OverviewMap mixins undefined.Control {

            /**
             * Create a new control with a map acting as an overview map for an other
             * defined map.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  OverviewMap options.
             * @api  
             */
            constructor(opt_options?: undefined.OverviewMapOptions): this;

            /**
             * Update the overview map element.
             * @param  Map event.
             * @this  {ol.control.OverviewMap}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void;

            /**
             * Return `true` if the overview map is collapsible, `false` otherwise.
             * @return  True if the widget is collapsible.
             * @api  stable
             */
            getCollapsible(): boolean;

            /**
             * Set whether the overview map should be collapsible.
             * @param  True if the widget is collapsible.
             * @api  stable
             */
            setCollapsible(collapsible: boolean): void;

            /**
             * Collapse or expand the overview map according to the passed parameter. Will
             * not do anything if the overview map isn't collapsible or if the current
            collapsed state is already the one requested.
             * @param  True if the widget is collapsed.
             * @api  stable
            */
            setCollapsed(collapsed: boolean): void;

            /**
             * Determine if the overview map is collapsed.
             * @return  The overview map is collapsed.
             * @api  stable
             */
            getCollapsed(): boolean;

            /**
             * Return the overview map.
             * @return  Overview map.
             * @api  
             */
            getOverviewMap(): ol.Map
        }

        /**
         * 
         * @classdesc  * A button control to reset rotation to 0.
        To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
        selector is added to the button when the rotation is 0.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Rotate options.
         * @api  stable
        */
        declare class Rotate mixins undefined.Control {

            /**
             * 
             * @classdesc  * A button control to reset rotation to 0.
            To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
            selector is added to the button when the rotation is 0.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Rotate options.
             * @api  stable
            */
            constructor(opt_options?: undefined.RotateOptions): this;

            /**
             * Update the rotate control element.
             * @param  Map event.
             * @this  {ol.control.Rotate}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void
        }
        declare module 'ScaleLine' {

            /**
             * 
             * @enum  {string}
             * @api  
             */
            declare type Property = string;

            /**
             * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
             * `'nautical'`, `'metric'`, `'us'`.
             * @enum  {string}
             */
            declare type Units = string;
        }


        /**
         * 
         * @classdesc  * A control with 2 buttons, one for zoom in and one for zoom out.
        This control is one of the default controls of a map. To style this control
        use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Zoom options.
         * @api  stable
        */
        declare class Zoom mixins undefined.Control {

            /**
             * 
             * @classdesc  * A control with 2 buttons, one for zoom in and one for zoom out.
            This control is one of the default controls of a map. To style this control
            use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Zoom options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomOptions): this
        }

        /**
         * 
         * @classdesc  * A slider type of control for zooming.

        Example:

        map.addControl(new ol.control.ZoomSlider());
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Zoom slider options.
         * @api  stable
        */
        declare class ZoomSlider mixins undefined.Control {

            /**
             * 
             * @classdesc  * A slider type of control for zooming.

            Example:

            map.addControl(new ol.control.ZoomSlider());
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Zoom slider options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomSliderOptions): this;

            /**
             * Update the zoomslider element.
             * @param  Map event.
             * @this  {ol.control.ZoomSlider}
             * @api  
             */
            render(mapEvent: ol.MapEvent): void
        }

        /**
         * 
         * @classdesc  * A button control which, when pressed, changes the map view to a specific
        extent. To style this control use the css selector `.ol-zoom-extent`.
         * @constructor  * 
         * @extends  {ol.control.Control}
         * @param  Options.
         * @api  stable
        */
        declare class ZoomToExtent mixins undefined.Control {

            /**
             * 
             * @classdesc  * A button control which, when pressed, changes the map view to a specific
            extent. To style this control use the css selector `.ol-zoom-extent`.
             * @constructor  * 
             * @extends  {ol.control.Control}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ZoomToExtentOptions): this
        }

        /**
         * 
         * @typedef  *     collapsible: (boolean|undefined),
        collapsed: (boolean|undefined),
        tipLabel: (string|undefined),
        label: (string|Node|undefined),
        collapseLabel: (string|Node|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined)}}
        */
        declare interface AttributionOptions {
            className?: string,
                target?: Element,
                collapsible?: boolean,
                collapsed?: boolean,
                tipLabel?: string,
                label?: (string | Node),
                collapseLabel?: (string | Node),
                render?: ((event: ol.MapEvent) => any)
        }

        /**
         * 
         * @typedef  *     render: (function(ol.MapEvent)|undefined),
        target: (Element|string|undefined)}}
        */
        declare interface ControlOptions {
            element?: Element,
                render?: ((event: ol.MapEvent) => any),
                target?: (Element | string)
        }

        /**
         * 
         * @typedef  *     attributionOptions: (olx.control.AttributionOptions|undefined),
        rotate: (boolean|undefined),
        rotateOptions: (olx.control.RotateOptions|undefined),
        zoom: (boolean|undefined),
        zoomOptions: (olx.control.ZoomOptions|undefined)}}
        */
        declare interface DefaultsOptions {
            attribution?: boolean,
                attributionOptions?: undefined.AttributionOptions,
                rotate?: boolean,
                rotateOptions?: undefined.RotateOptions,
                zoom?: boolean,
                zoomOptions?: undefined.ZoomOptions
        }

        /**
         * 
         * @typedef  *     label: (string|Node|undefined),
        labelActive: (string|Node|undefined),
        tipLabel: (string|undefined),
        keys: (boolean|undefined),
        target: (Element|undefined),
        source: (Element|string|undefined)}}
        */
        declare interface FullScreenOptions {
            className?: string,
                label?: (string | Node),
                labelActive?: (string | Node),
                tipLabel?: string,
                keys?: boolean,
                target?: Element,
                source?: (Element | string)
        }

        /**
         * 
         * @typedef  *     coordinateFormat: (ol.CoordinateFormatType|undefined),
        projection: ol.ProjectionLike,
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        undefinedHTML: (string|undefined)}}
        */
        declare interface MousePositionOptions {
            className?: string,
                coordinateFormat?: ol.CoordinateFormatType,
                projection: ol.ProjectionLike,
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                undefinedHTML?: string
        }

        /**
         * 
         * @typedef  *     collapseLabel: (string|Node|undefined),
        collapsible: (boolean|undefined),
        label: (string|Node|undefined),
        layers: (Array.<ol.layer.Layer>|ol.Collection.<ol.layer.Layer>|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        tipLabel: (string|undefined),
        view: (ol.View|undefined)}}
        */
        declare interface OverviewMapOptions {
            collapsed?: boolean,
                collapseLabel?: (string | Node),
                collapsible?: boolean,
                label?: (string | Node),
                layers?: (undefined.Layer[] | ol.Collection<undefined.Layer>),
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                tipLabel?: string,
                view?: ol.View
        }

        /**
         * 
         * @typedef  *     minWidth: (number|undefined),
        render: (function(ol.MapEvent)|undefined),
        target: (Element|undefined),
        units: (ol.control.ScaleLine.Units|string|undefined)}}
        */
        declare interface ScaleLineOptions {
            className?: string,
                minWidth?: number,
                render?: ((event: ol.MapEvent) => any),
                target?: Element,
                units?: (undefined.Units | string)
        }

        /**
         * 
         * @typedef  *     anchor: (ol.Coordinate|undefined),
        start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface RotateOptions {
            rotation?: number,
                anchor?: ol.Coordinate,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     start: (number|undefined),
        duration: (number|undefined),
        easing: (function(number):number|undefined)}}
        */
        declare interface ZoomOptions {
            resolution: number,
                start?: number,
                duration?: number,
                easing: ((t: number) => number)
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined),
        maxResolution: (number|undefined),
        minResolution: (number|undefined),
        render: (function(ol.MapEvent)|undefined)}}
        */
        declare interface ZoomSliderOptions {
            className?: string,
                duration?: number,
                maxResolution?: number,
                minResolution?: number,
                render?: ((event: ol.MapEvent) => any)
        }

        /**
         * 
         * @typedef  *     target: (Element|undefined),
        label: (string|Node|undefined),
        tipLabel: (string|undefined),
        extent: (ol.Extent|undefined)}}
        */
        declare interface ZoomToExtentOptions {
            className?: string,
                target?: Element,
                label?: (string | Node),
                tipLabel?: string,
                extent?: ol.Extent
        }
    }

    declare module 'format' {

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the EsriJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  
         */
        declare class EsriJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the EsriJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.EsriJSONOptions): this;

            /**
             * Read a feature from a EsriJSON Feature source.  Only works for Feature,
             * use `readFeatures` to read FeatureCollection source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  
             */
            readFeature(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a EsriJSON source.  Works with both Feature and
             * FeatureCollection sources.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  
             */
            readFeatures(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a geometry from a EsriJSON source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  
             */
            readGeometry(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a EsriJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  
             */
            readProjection(
                source: (ArrayBuffer |
                    Document |
                    Node |
                    GlobalObject |
                    string)): undefined.Projection;

            /**
             * Encode a geometry as a EsriJSON string.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a geometry as a EsriJSON object.
             * @param  Geometry.
             * @param  Write options.
             * @return  Object.
             * @api  
             */
            writeGeometryObject(
                geometry: undefined.Geometry,
                opt_options?: undefined.WriteOptions): EsriJSONGeometry;

            /**
             * Encode a feature as a EsriJSON Feature string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a feature as a esriJSON Feature object.
             * @param  Feature.
             * @param  Write options.
             * @return  Object.
             * @api  
             */
            writeFeatureObject(feature: ol.Feature, opt_options?: undefined.WriteOptions): GlobalObject;

            /**
             * Encode an array of features as EsriJSON.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  EsriJSON.
             * @api  
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a EsriJSON object.
             * @param  Features.
             * @param  Write options.
             * @return  EsriJSON Object.
             * @api  
             */
            writeFeaturesObject(features: ol.Feature[], opt_options?: undefined.WriteOptions): GlobalObject
        }
        declare type EsriJSONGeometry = JSON;

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for feature formats.
        {ol.format.Feature} subclasses provide the ability to decode and encode
        {
         * @link  ol.Feature} objects from a variety of commonly used geospatial
        file formats.  See the documentation for each format for more details.
         * @constructor  * 
         * @api  stable
        */
        declare class Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for feature formats.
            {ol.format.Feature} subclasses provide the ability to decode and encode
            {
             * @link  ol.Feature} objects from a variety of commonly used geospatial
            file formats.  See the documentation for each format for more details.
             * @constructor  * 
             * @api  stable
            */
            constructor(): this
        }
        declare type GeoJSONFeature = JSON;
        declare type GeoJSONFeatureCollection = JSON;
        declare type GeoJSONGeometry = JSON;
        declare type GeoJSONGeometryCollection = JSON;

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GeoJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  stable
         */
        declare class GeoJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GeoJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.GeoJSONOptions): this;

            /**
             * Read a feature from a GeoJSON Feature source.  Only works for Feature,
             * use `readFeatures` to read FeatureCollection source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a GeoJSON source.  Works with both Feature and
             * FeatureCollection sources.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a geometry from a GeoJSON source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a GeoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode a feature as a GeoJSON Feature string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a feature as a GeoJSON Feature object.
             * @param  Feature.
             * @param  Write options.
             * @return  Object.
             * @api  stable
             */
            writeFeatureObject(feature: ol.Feature, opt_options?: undefined.WriteOptions): GeoJSONFeature;

            /**
             * Encode an array of features as GeoJSON.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a GeoJSON object.
             * @param  Features.
             * @param  Write options.
             * @return  GeoJSON Object.
             * @api  stable
             */
            writeFeaturesObject(
                features: ol.Feature[],
                opt_options?: undefined.WriteOptions): GeoJSONFeatureCollection;

            /**
             * Encode a geometry as a GeoJSON string.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  GeoJSON.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode a geometry as a GeoJSON object.
             * @param  Geometry.
             * @param  Write options.
             * @return  Object.
             * @api  stable
             */
            writeGeometryObject(
                geometry: undefined.Geometry,
                opt_options?: undefined.WriteOptions): (GeoJSONGeometry | GeoJSONGeometryCollection)
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format
        version 3.1.1.
        Currently only supports GML 3.1.1 Simple Features profile.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  stable
        */
        declare class GML mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format
            version 3.1.1.
            Currently only supports GML 3.1.1 Simple Features profile.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  stable
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Encode an array of features in GML 3.1.1 Simple Features.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GML 3.1.1 format as an XML node.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format,
        version 2.1.2.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  
        */
        declare class GML2 mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format,
            version 2.1.2.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  
            */
            constructor(opt_options?: undefined.GMLOptions): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GML format
        version 3.1.1.
        Currently only supports GML 3.1.1 Simple Features profile.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.GMLBase}
         * @api  
        */
        declare class GML3 mixins undefined.GMLBase {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GML format
            version 3.1.1.
            Currently only supports GML 3.1.1 Simple Features profile.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.GMLBase}
             * @api  
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Encode a geometry in GML 3.1.1 Simple Features.
             * @param  Geometry.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeGeometryNode(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): Node;

            /**
             * Encode an array of features in GML 3.1.1 Simple Features.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GML 3.1.1 format as an XML node.
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Feature base format for reading and writing data in the GML format.
        This class cannot be instantiated, it contains only base content that
        is shared with versioned format classes ol.format.GML2 and
        ol.format.GML3.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.XMLFeature}
        */
        declare class GMLBase mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Feature base format for reading and writing data in the GML format.
            This class cannot be instantiated, it contains only base content that
            is shared with versioned format classes ol.format.GML2 and
            ol.format.GML3.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.XMLFeature}
            */
            constructor(opt_options?: undefined.GMLOptions): this;

            /**
             * Read all features from a GML FeatureCollection.
             * @function  * 
             * @param  Source.
             * @param  Options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[]
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the GPX format.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  stable
         */
        declare class GPX mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the GPX format.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.GPXOptions): this;

            /**
             * Read the first feature from a GPX source.
             * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
            into MultiLineString. Any properties on route and track waypoints are ignored.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
            */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a GPX source.
             * Routes (`<rte>`) are converted into LineString geometries, and tracks (`<trk>`)
            into MultiLineString. Any properties on route and track waypoints are ignored.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
            */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from a GPX source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode an array of features in the GPX format.
             * LineString geometries are output as routes (`<rte>`), and MultiLineString
            as tracks (`<trk>`).
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  Result.
             * @api  stable
            */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the GPX format as an XML node.
             * LineString geometries are output as routes (`<rte>`), and MultiLineString
            as tracks (`<trk>`).
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
            */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * IGC altitude/z. One of 'barometric', 'gps', 'none'.
         * @enum  {string}
         */
        declare type IGCZ = string;

        /**
         * 
         * @classdesc  * Feature format for `*.igc` flight recording files.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Options.
         * @api  
         */
        declare class IGC mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Feature format for `*.igc` flight recording files.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.IGCOptions): this;

            /**
             * Read the feature from the IGC source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read the feature from the source. As IGC sources contain a single
             * feature, this will return the feature in an array.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from the IGC source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for JSON feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class JSONFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for JSON feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the KML format.

        Note that the KML format uses the URL() constructor. Older browsers such as IE
        which do not support this will need a URL polyfill to be loaded before use.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  stable
        */
        declare class KML mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the KML format.

            Note that the KML format uses the URL() constructor. Older browsers such as IE
            which do not support this will need a URL polyfill to be loaded before use.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.KMLOptions): this;

            /**
             * Read the first feature from a KML source. MultiGeometries are converted into
             * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
            MultiLineString/MultiPolygon if they are all of the same type.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
            */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a KML source. MultiGeometries are converted into
             * GeometryCollections if they are a mix of geometry types, and into MultiPoint/
            MultiLineString/MultiPolygon if they are all of the same type.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
            */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the name of the KML.
             * @param  Souce.
             * @return  Name.
             * @api  stable
             */
            readName(source: (Document | Node | string)): (string);

            /**
             * Read the network links of the KML.
             * @param  Source.
             * @return  Network links.
             * @api  
             */
            readNetworkLinks(source: (Document | Node | string)): GlobalObject[];

            /**
             * Read the projection from a KML source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Encode an array of features in the KML format. GeometryCollections, MultiPoints,
             * MultiLineStrings, and MultiPolygons are output as MultiGeometries.
             * @function  * 
             * @param  Features.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features in the KML format as an XML node. GeometryCollections,
             * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
             * @param  Features.
             * @param  Options.
             * @return  Node.
             * @api  
             */
            writeFeaturesNode(features: ol.Feature[], opt_options?: undefined.WriteOptions): Node
        }

        /**
         * 
         * @classdesc  * Feature format for reading data in the Mapbox MVT format.
         * @constructor  * 
         * @extends  {ol.format.Feature}
         * @param  Options.
         * @api  
         */
        declare class MVT mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the Mapbox MVT format.
             * @constructor  * 
             * @extends  {ol.format.Feature}
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.MVTOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            readFeatures(
                source: (Document |
                    Node |
                    ArrayBuffer |
                    GlobalObject |
                    string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Sets the layers that features will be read from.
             * @param  Layers.
             * @api  
             */
            setLayers(layers: string[]): void
        }
        declare module 'ogc' {
            declare module 'filter' {
                declare interface Filter {}
            }

        }


        /**
         * 
         * @classdesc  * Feature format for reading data in the
        [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @api  stable
        */
        declare class OSMXML mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the
            [OSMXML format](http://wiki.openstreetmap.org/wiki/OSM_XML).
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @api  stable
            */
            constructor(): this;

            /**
             * Read all features from an OSM source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the projection from an OSM source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the Encoded
        Polyline Algorithm Format.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Optional configuration object.
         * @api  stable
        */
        declare class Polyline mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the Encoded
            Polyline Algorithm Format.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Optional configuration object.
             * @api  stable
            */
            constructor(opt_options?: undefined.PolylineOptions): this;

            /**
             * Encode a list of n-dimensional points and return an encoded string
             * 
            Attention: This function will modify the passed array!
             * @param  A list of n-dimensional points.
             * @param  The number of dimension of the points in the list.
             * @param  The factor by which the numbers will be
            multiplied. The remaining decimal places will get rounded away.
            Default is `1e5`.
             * @return  The encoded string.
             * @api  
            */
            encodeDeltas(numbers: number[], stride: number, opt_factor?: number): string;

            /**
             * Decode a list of n-dimensional points from an encoded string
             * @param  An encoded string.
             * @param  The number of dimension of the points in the
            encoded string.
             * @param  The factor by which the resulting numbers will
            be divided. Default is `1e5`.
             * @return  A list of n-dimensional points.
             * @api  
            */
            decodeDeltas(encoded: string, stride: number, opt_factor?: number): number[];

            /**
             * Encode a list of floating point numbers and return an encoded string
             * 
            Attention: This function will modify the passed array!
             * @param  A list of floating point numbers.
             * @param  The factor by which the numbers will be
            multiplied. The remaining decimal places will get rounded away.
            Default is `1e5`.
             * @return  The encoded string.
             * @api  
            */
            encodeFloats(numbers: number[], opt_factor?: number): string;

            /**
             * Decode a list of floating point numbers from an encoded string
             * @param  An encoded string.
             * @param  The factor by which the result will be divided.
            Default is `1e5`.
             * @return  A list of floating point numbers.
             * @api  
            */
            decodeFloats(encoded: string, opt_factor?: number): number[];

            /**
             * Read the feature from the Polyline source. The coordinates are assumed to be
             * in two dimensions and in latitude, longitude order.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read the feature from the source. As Polyline sources contain a single
             * feature, this will return the feature in an array.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read the geometry from the source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Read the projection from a Polyline source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection;

            /**
             * Write a single geometry in Polyline format.
             * @function  * 
             * @param  Geometry.
             * @param  Write options.
             * @return  Geometry.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry, opt_options?: undefined.WriteOptions): string
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for text feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class TextFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for text feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Feature format for reading data in the TopoJSON format.
         * @constructor  * 
         * @extends  {ol.format.JSONFeature}
         * @param  Options.
         * @api  stable
         */
        declare class TopoJSON mixins undefined.JSONFeature {

            /**
             * 
             * @classdesc  * Feature format for reading data in the TopoJSON format.
             * @constructor  * 
             * @extends  {ol.format.JSONFeature}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.TopoJSONOptions): this;

            /**
             * Read all features from a TopoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Features.
             * @api  stable
             */
            readFeatures(source: (Document | Node | GlobalObject | string)): ol.Feature[];

            /**
             * Read the projection from a TopoJSON source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(object: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Feature format for reading and writing data in the WFS format.
        By default, supports WFS version 1.1.0. You can pass a GML format
        as option if you want to read a WFS that contains GML2 (WFS 1.0.0).
        Also see {
         * @link  ol.format.GMLBase} which is used by this format.
         * @constructor  * 
         * @param  Optional configuration object.
         * @extends  {ol.format.XMLFeature}
         * @api  stable
        */
        declare class WFS mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Feature format for reading and writing data in the WFS format.
            By default, supports WFS version 1.1.0. You can pass a GML format
            as option if you want to read a WFS that contains GML2 (WFS 1.0.0).
            Also see {
             * @link  ol.format.GMLBase} which is used by this format.
             * @constructor  * 
             * @param  Optional configuration object.
             * @extends  {ol.format.XMLFeature}
             * @api  stable
            */
            constructor(opt_options?: undefined.WFSOptions): this;

            /**
             * Read all features from a WFS FeatureCollection.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read transaction response of the source.
             * @param  Source.
             * @return  Transaction response.
             * @api  stable
             */
            readTransactionResponse(source: (Document | Node | GlobalObject | string)): (ol.WFSTransactionResponse);

            /**
             * Read feature collection metadata of the source.
             * @param  Source.
             * @return  *     FeatureCollection metadata.
             * @api  stable
             */
            readFeatureCollectionMetadata(
                source: (Document | Node | GlobalObject | string)): (ol.WFSFeatureCollectionMetadata);

            /**
             * Encode format as WFS `GetFeature` and return the Node.
             * @param  Options.
             * @return  Result.
             * @api  stable
             */
            writeGetFeature(options: undefined.WFSWriteGetFeatureOptions): Node;

            /**
             * Encode format as WFS `Transaction` and return the Node.
             * @param  The features to insert.
             * @param  The features to update.
             * @param  The features to delete.
             * @param  Write options.
             * @return  Result.
             * @api  stable
             */
            writeTransaction(
                inserts: ol.Feature[],
                updates: ol.Feature[],
                deletes: ol.Feature[],
                options: undefined.WFSWriteTransactionOptions): Node;

            /**
             * Read the projection from a WFS source.
             * @function  * 
             * @param  Source.
             * @return  Projection.
             * @api  stable
             */
            readProjection(source: (Document | Node | GlobalObject | string)): undefined.Projection
        }

        /**
         * 
         * @classdesc  * Geometry format for reading and writing data in the `WellKnownText` (WKT)
        format.
         * @constructor  * 
         * @extends  {ol.format.TextFeature}
         * @param  Options.
         * @api  stable
        */
        declare class WKT mixins undefined.TextFeature {

            /**
             * 
             * @classdesc  * Geometry format for reading and writing data in the `WellKnownText` (WKT)
            format.
             * @constructor  * 
             * @extends  {ol.format.TextFeature}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.WKTOptions): this;

            /**
             * Read a feature from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Feature.
             * @api  stable
             */
            readFeature(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature;

            /**
             * Read all features from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[];

            /**
             * Read a single geometry from a WKT source.
             * @function  * 
             * @param  Source.
             * @param  Read options.
             * @return  Geometry.
             * @api  stable
             */
            readGeometry(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): undefined.Geometry;

            /**
             * Encode a feature as a WKT string.
             * @function  * 
             * @param  Feature.
             * @param  Write options.
             * @return  WKT string.
             * @api  stable
             */
            writeFeature(feature: ol.Feature, opt_options?: undefined.WriteOptions): string;

            /**
             * Encode an array of features as a WKT string.
             * @function  * 
             * @param  Features.
             * @param  Write options.
             * @return  WKT string.
             * @api  stable
             */
            writeFeatures(features: ol.Feature[], opt_options?: undefined.WriteOptions): string;

            /**
             * Write a single geometry as a WKT string.
             * @function  * 
             * @param  Geometry.
             * @return  WKT string.
             * @api  stable
             */
            writeGeometry(geometry: undefined.Geometry): string
        }

        /**
         * 
         * @classdesc  * Format for reading WMS capabilities data
         * @constructor  * 
         * @extends  {ol.format.XML}
         * @api  
         */
        declare class WMSCapabilities mixins undefined.XML {

            /**
             * 
             * @classdesc  * Format for reading WMS capabilities data
             * @constructor  * 
             * @extends  {ol.format.XML}
             * @api  
             */
            constructor(): this;

            /**
             * Read a WMS capabilities document.
             * @function  * 
             * @param  The XML source.
             * @return  An object representing the WMS capabilities.
             * @api  
             */
            read(source: (Document | Node | string)): GlobalObject
        }

        /**
         * 
         * @classdesc  * Format for reading WMSGetFeatureInfo format. It uses
        {
         * @link  ol.format.GML2} to read features.
         * @constructor  * 
         * @extends  {ol.format.XMLFeature}
         * @param  Options.
         * @api  
        */
        declare class WMSGetFeatureInfo mixins undefined.XMLFeature {

            /**
             * 
             * @classdesc  * Format for reading WMSGetFeatureInfo format. It uses
            {
             * @link  ol.format.GML2} to read features.
             * @constructor  * 
             * @extends  {ol.format.XMLFeature}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.WMSGetFeatureInfoOptions): this;

            /**
             * Read all features from a WMSGetFeatureInfo response.
             * @function  * 
             * @param  Source.
             * @param  Options.
             * @return  Features.
             * @api  stable
             */
            readFeatures(
                source: (Document | Node | GlobalObject | string),
                opt_options?: undefined.ReadOptions): ol.Feature[]
        }

        /**
         * 
         * @classdesc  * Format for reading WMTS capabilities data.
         * @constructor  * 
         * @extends  {ol.format.XML}
         * @api  
         */
        declare class WMTSCapabilities mixins undefined.XML {

            /**
             * 
             * @classdesc  * Format for reading WMTS capabilities data.
             * @constructor  * 
             * @extends  {ol.format.XML}
             * @api  
             */
            constructor(): this;

            /**
             * Read a WMTS capabilities document.
             * @function  * 
             * @param  The XML source.
             * @return  An object representing the WMTS capabilities.
             * @api  
             */
            read(source: (Document | Node | string)): GlobalObject
        }

        /**
         * 
         * @classdesc  * Generic format for reading non-feature XML data
         * @constructor  * 
         * @struct  
         */
        declare class XML {

            /**
             * 
             * @classdesc  * Generic format for reading non-feature XML data
             * @constructor  * 
             * @struct  
             */
            constructor(): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for XML feature formats.
         * @constructor  * 
         * @extends  {ol.format.Feature}
        */
        declare class XMLFeature mixins undefined.Feature {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for XML feature formats.
             * @constructor  * 
             * @extends  {ol.format.Feature}
            */
            constructor(): this
        }

        /**
         * 
         * @typedef  *     featureProjection: ol.ProjectionLike,
        rightHanded: (boolean|undefined)}}
        */
        declare interface ReadOptions {
            dataProjection: ol.ProjectionLike,
                featureProjection: ol.ProjectionLike
        }

        /**
         * 
         * @typedef  *     featureProjection: ol.ProjectionLike,
        rightHanded: (boolean|undefined),
        decimals: (number|undefined)}}
        */
        declare interface WriteOptions {
            dataProjection: ol.ProjectionLike,
                featureProjection: ol.ProjectionLike,
                rightHanded?: boolean,
                decimals?: number
        }

        /**
         * 
         * @typedef  *     geometryName: (string|undefined)}}
         */
        declare interface GeoJSONOptions {
            defaultDataProjection: ol.ProjectionLike,
                geometryName?: string
        }

        /**
         * 
         * @typedef  
         */
        declare interface EsriJSONOptions {
            geometryName?: string
        }

        /**
         * 
         * @typedef  *>)=)|
        function(ol.geom.GeometryType,Array.<number>,
        (Array.<number>|Array.<Array.<number>>),Object.<string, *>)|
        undefined),
        geometryName: (string|undefined),
        layers: (Array.<string>|undefined),
        layerName: (string|undefined)}}
        */
        declare interface MVTOptions {
            featureClass?: (((geom: (undefined.Geometry | {
                    [k: string]: any
                })) => any) | ((
                    geom: undefined.GeometryType,
                    arg2: number[],
                    arg3: (number[] | number[][]),
                    arg4: {
                        [k: string]: any
                    }) => any)),
                geometryName?: string,
                layerName?: string,
                layers?: string[]
        }

        /**
         * 
         * @typedef  *     geometryLayout: (ol.geom.GeometryLayout|undefined)}}
         */
        declare interface PolylineOptions {
            factor?: number,
                geometryLayout?: undefined.GeometryLayout
        }

        /**
         * 
         * @typedef  
         */
        declare interface TopoJSONOptions {
            defaultDataProjection: ol.ProjectionLike
        }

        /**
         * 
         * @typedef  
         */
        declare interface IGCOptions {
            altitudeMode?: undefined.IGCZ
        }

        /**
         * 
         * @typedef  *     defaultStyle: (Array.<ol.style.Style>|undefined),
        showPointNames: (boolean|undefined),
        writeStyles: (boolean|undefined)}}
        */
        declare interface KMLOptions {
            extractStyles?: boolean,
                showPointNames?: boolean,
                defaultStyle?: undefined.Style[],
                writeStyles?: boolean
        }

        /**
         * 
         * @typedef  *     featureType: (Array.<string>|string|undefined),
        srsName: string,
        surface: (boolean|undefined),
        curve: (boolean|undefined),
        multiCurve: (boolean|undefined),
        multiSurface: (boolean|undefined),
        schemaLocation: (string|undefined)}}
        */
        declare interface GMLOptions {
            featureNS?: ({
                    [k: string]: string
                } | string),
                featureType?: (string[] | string),
                srsName: string,
                surface?: boolean,
                curve?: boolean,
                multiCurve?: boolean,
                multiSurface?: boolean,
                schemaLocation?: string
        }

        /**
         * 
         * @typedef  )}}
         */
        declare interface GPXOptions {
            readExtensions?: ((feature: ol.Feature, node: Node) => any)
        }

        /**
         * 
         * @typedef  *     featureType: (Array.<string>|string|undefined),
        gmlFormat: (ol.format.GMLBase|undefined),
        schemaLocation: (string|undefined)}}
        */
        declare interface WFSOptions {
            featureNS?: ({
                    [k: string]: string
                } | string),
                featureType?: (string[] | string),
                gmlFormat?: undefined.GMLBase,
                schemaLocation?: string
        }

        /**
         * 
         * @typedef  *     featurePrefix: string,
        featureTypes: Array.<string>,
        srsName: (string|undefined),
        handle: (string|undefined),
        outputFormat: (string|undefined),
        maxFeatures: (number|undefined),
        geometryName: (string|undefined),
        propertyNames: (Array.<string>|undefined),
        startIndex: (number|undefined),
        count: (number|undefined),
        bbox: (ol.Extent|undefined),
        filter: (ol.format.ogc.filter.Filter|undefined),
        resultType: (string|undefined)}}
        */
        declare interface WFSWriteGetFeatureOptions {
            featureNS: string,
                featurePrefix: string,
                featureTypes: string[],
                srsName?: string,
                handle?: string,
                outputFormat?: string,
                maxFeatures?: number,
                geometryName?: string,
                propertyNames?: string[],
                startIndex?: number,
                count?: number,
                bbox?: ol.Extent,
                filter?: undefined.Filter,
                resultType?: string
        }

        /**
         * 
         * @typedef  *     featurePrefix: string,
        featureType: string,
        srsName: (string|undefined),
        handle: (string|undefined),
        nativeElements: Array.<Object>,
        gmlOptions: (olx.format.GMLOptions|undefined)}}
        */
        declare interface WFSWriteTransactionOptions {
            featureNS: string,
                featurePrefix: string,
                featureType: string,
                srsName?: string,
                handle?: string,
                nativeElements: GlobalObject[],
                gmlOptions?: undefined.GMLOptions
        }

        /**
         * 
         * @typedef  
         */
        declare interface WKTOptions {
            splitCollection?: boolean
        }

        /**
         * 
         * @typedef  *     layers: (Array.<string>|undefined)
        }}
        */
        declare interface WMSGetFeatureInfoOptions {
            layers?: string[]
        }
    }

    declare module 'interaction' {

        /**
         * 
         * @classdesc  * Allows the user to zoom by double-clicking on the map.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
         */
        declare class DoubleClickZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom by double-clicking on the map.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DoubleClickZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
             * doubleclick) and eventually zooms the map.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.DoubleClickZoom}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Handles input of vector data by drag and drop.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @fires  ol.interaction.DragAndDropEvent
         * @param  Options.
         * @api  stable
         */
        declare class DragAndDrop mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Handles input of vector data by drag and drop.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @fires  ol.interaction.DragAndDropEvent
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DragAndDropOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} unconditionally and
             * neither prevents the browser default nor stops event propagation.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.DragAndDrop}
             * @api  
             */
            handleEvent: any
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.DragAndDrop} instances are instances
        of this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.interaction.DragAndDropEvent}
         * @param  Type.
         * @param  File.
         * @param  Features.
         * @param  Projection.
        */
        declare class DragAndDropEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.DragAndDrop} instances are instances
            of this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.interaction.DragAndDropEvent}
             * @param  Type.
             * @param  File.
             * @param  Features.
             * @param  Projection.
            */
            constructor(type: undefined.DragAndDropEventType, file: File, opt_features?: ol.Feature[], opt_projection?: undefined.Projection): this;

            /**
             * The features parsed from dropped data.
             * @type  * 
             * @api  stable
             */
            features: ol.Feature[];

            /**
             * The dropped file.
             * @type  * 
             * @api  stable
             */
            file: File;

            /**
             * The feature projection.
             * @type  * 
             * @api  
             */
            projection: undefined.Projection
        }
        declare type DragAndDropEventType = string;

        /**
         * 
         * @classdesc  * Allows the user to draw a vector box by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when the shift or other key is held down. This is used, for example,
        for zooming to a specific area of the map
        (see {
         * @link  ol.interaction.DragZoom} and
        {
         * @link  ol.interaction.DragRotateAndZoom}).

        This interaction is only supported for mouse devices.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.DragBoxEvent
         * @param  Options.
         * @api  stable
        */
        declare class DragBox mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to draw a vector box by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when the shift or other key is held down. This is used, for example,
            for zooming to a specific area of the map
            (see {
             * @link  ol.interaction.DragZoom} and
            {
             * @link  ol.interaction.DragRotateAndZoom}).

            This interaction is only supported for mouse devices.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.DragBoxEvent
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragBoxOptions): this;

            /**
             * Returns geometry of last drawn box.
             * @return  Geometry.
             * @api  stable
             */
            getGeometry(): undefined.Polygon
        }

        /**
         * 
         * @classdesc  * Allows the user to pan the map by dragging the map.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
         */
        declare class DragPan mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to pan the map by dragging the map.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.DragPanOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to rotate the map by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when the alt and shift keys are held down.

        This interaction is only supported for mouse devices.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class DragRotate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to rotate the map by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when the alt and shift keys are held down.

            This interaction is only supported for mouse devices.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragRotateOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom and rotate the map by clicking and dragging
        on the map.  By default, this interaction is limited to when the shift
        key is held down.

        This interaction is only supported for mouse devices.

        And this interaction is not included in the default interactions.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class DragRotateAndZoom mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to zoom and rotate the map by clicking and dragging
            on the map.  By default, this interaction is limited to when the shift
            key is held down.

            This interaction is only supported for mouse devices.

            And this interaction is not included in the default interactions.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragRotateAndZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by clicking and dragging on the map,
        normally combined with an {
         * @link  ol.events.condition} that limits
        it to when a key, shift by default, is held down.

        To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
        your custom one configured with `className`.
         * @constructor  * 
         * @extends  {ol.interaction.DragBox}
         * @param  Options.
         * @api  stable
        */
        declare class DragZoom mixins undefined.DragBox {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by clicking and dragging on the map,
            normally combined with an {
             * @link  ol.events.condition} that limits
            it to when a key, shift by default, is held down.

            To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
            your custom one configured with `className`.
             * @constructor  * 
             * @extends  {ol.interaction.DragBox}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.DragZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Draw} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.DrawEvent}
         * @param  Type.
         * @param  The feature drawn.
        */
        declare class DrawEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Draw} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.DrawEvent}
             * @param  Type.
             * @param  The feature drawn.
            */
            constructor(type: undefined.DrawEventType, feature: ol.Feature): this;

            /**
             * The feature being drawn.
             * @type  * 
             * @api  stable
             */
            feature: ol.Feature
        }
        declare type DrawEventType = string;

        /**
         * 
         * @classdesc  * Interaction for drawing feature geometries.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.interaction.DrawEvent
         * @param  Options.
         * @api  stable
         */
        declare class Draw mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for drawing feature geometries.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.interaction.DrawEvent
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.DrawOptions): this;

            /**
             * Remove last point of the feature currently being drawn.
             * @api  
             */
            removeLastPoint(): void;

            /**
             * Stop drawing and add the sketch feature to the target layer.
             * The {@link ol.interaction.DrawEventType.DRAWEND} event is dispatched before
            inserting the feature.
             * @api  
            */
            finishDrawing(): void;

            /**
             * Extend an existing geometry by adding additional points. This only works
             * on features with `LineString` geometries, where the interaction will
            extend lines by adding points to the end of the coordinates array.
             * @param  Feature to be extended.
             * @api  
            */
            extend(feature: ol.Feature): void;

            /**
             * Create a `geometryFunction` for `mode: 'Circle'` that will create a regular
             * polygon with a user specified number of sides and start angle instead of an
            `ol.geom.Circle` geometry.
             * @param  Number of sides of the regular polygon. Default is
            32.
             * @param  Angle of the first point in radians. 0 means East.
            Default is the angle defined by the heading from the center of the
            regular polygon to the current pointer position.
             * @return  Function that draws a
            polygon.
             * @api  
            */
            createRegularPolygon(opt_sides?: number, opt_angle?: number): ol.DrawGeometryFunctionType
        }

        /**
         * Set of controls included in maps by default. Unless configured otherwise,
         * this returns a collection containing an instance of each of the following
        controls:
        * {@link ol.control.Zoom}
        * {@link ol.control.Rotate}
        * {@link ol.control.Attribution}
         * @param  Defaults options.
         * @return  Controls.
         * @api  stable
        */
        declare     function defaults(opt_options?: undefined.DefaultsOptions): ol.Collection<undefined.Control >

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            User actions that change the state of the map. Some are similar to controls,
            but are not associated with a DOM element.
            For example, {
             * @link  ol.interaction.KeyboardZoom} is functionally the same as
            {
             * @link  ol.control.Zoom}, but triggered by a keyboard event not a button
            element event.
            Although interactions do not have a DOM element, some of them do render
            vectors and so are visible on the screen.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.Object}
             * @api  
            */
            declare class Interaction mixins ol.Object {

                /**
                 * 
                 * @classdesc  * Abstract base class; normally only used for creating subclasses and not
                instantiated in apps.
                User actions that change the state of the map. Some are similar to controls,
                but are not associated with a DOM element.
                For example, {
                 * @link  ol.interaction.KeyboardZoom} is functionally the same as
                {
                 * @link  ol.control.Zoom}, but triggered by a keyboard event not a button
                element event.
                Although interactions do not have a DOM element, some of them do render
                vectors and so are visible on the screen.
                 * @constructor  * 
                 * @param  Options.
                 * @extends  {ol.Object}
                 * @api  
                */
                constructor(options: undefined.InteractionOptions): this;

                /**
                 * Return whether the interaction is currently active.
                 * @return  `true` if the interaction is active, `false` otherwise.
                 * @observable  * 
                 * @api  
                 */
                getActive(): boolean;

                /**
                 * Get the map associated with this interaction.
                 * @return  Map.
                 * @api  
                 */
                getMap(): ol.Map;

                /**
                 * Activate or deactivate the interaction.
                 * @param  Active.
                 * @observable  * 
                 * @api  
                 */
                setActive(active: boolean): void
            }

        /**
         * 
         * @classdesc  * Allows the user to pan the map using keyboard arrows.
        Note that, although this interaction is by default included in maps,
        the keys can only be used when browser focus is on the element to which
        the keyboard events are attached. By default, this is the map div,
        though you can change this with the `keyboardEventTarget` in
        {
         * @link  ol.Map}. `document` never loses focus but, for any other element,
        focus will have to be on, and returned to, this element if the keys are to
        function.
        See also {
         * @link  ol.interaction.KeyboardZoom}.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
        */
        declare class KeyboardPan mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to pan the map using keyboard arrows.
            Note that, although this interaction is by default included in maps,
            the keys can only be used when browser focus is on the element to which
            the keyboard events are attached. By default, this is the map div,
            though you can change this with the `keyboardEventTarget` in
            {
             * @link  ol.Map}. `document` never loses focus but, for any other element,
            focus will have to be on, and returned to, this element if the keys are to
            function.
            See also {
             * @link  ol.interaction.KeyboardZoom}.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.KeyboardPanOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
             * `KeyEvent`, and decides the direction to pan to (if an arrow key was
            pressed).
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.KeyboardPan}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map using keyboard + and -.
        Note that, although this interaction is by default included in maps,
        the keys can only be used when browser focus is on the element to which
        the keyboard events are attached. By default, this is the map div,
        though you can change this with the `keyboardEventTarget` in
        {
         * @link  ol.Map}. `document` never loses focus but, for any other element,
        focus will have to be on, and returned to, this element if the keys are to
        function.
        See also {
         * @link  ol.interaction.KeyboardPan}.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.interaction.Interaction}
         * @api  stable
        */
        declare class KeyboardZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map using keyboard + and -.
            Note that, although this interaction is by default included in maps,
            the keys can only be used when browser focus is on the element to which
            the keyboard events are attached. By default, this is the map div,
            though you can change this with the `keyboardEventTarget` in
            {
             * @link  ol.Map}. `document` never loses focus but, for any other element,
            focus will have to be on, and returned to, this element if the keys are to
            function.
            See also {
             * @link  ol.interaction.KeyboardPan}.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.interaction.Interaction}
             * @api  stable
            */
            constructor(opt_options?: undefined.KeyboardZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
             * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
            key pressed was '+' or '-').
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.KeyboardZoom}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Modify} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.ModifyEvent}
         * @param  Type.
         * @param  The features modified.
         * @param  Associated
        {
         * @link  ol.MapBrowserPointerEvent}.
        */
        declare class ModifyEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Modify} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.ModifyEvent}
             * @param  Type.
             * @param  The features modified.
             * @param  Associated
            {
             * @link  ol.MapBrowserPointerEvent}.
            */
            constructor(type: ol.ModifyEventType, features: ol.Collection<ol.Feature>, mapBrowserPointerEvent: ol.MapBrowserPointerEvent): this;

            /**
             * The features being modified.
             * @type  * 
             * @api  
             */
            features: ol.Collection<ol.Feature>;

            /**
             * Associated {@link ol.MapBrowserEvent}.
             * @type  * 
             * @api  
             */
            mapBrowserEvent: ol.MapBrowserEvent
        }

        /**
         * 
         * @classdesc  * Interaction for modifying feature geometries.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @fires  ol.interaction.ModifyEvent
         * @api  
         */
        declare class Modify mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for modifying feature geometries.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @fires  ol.interaction.ModifyEvent
             * @api  
             */
            constructor(options: undefined.ModifyOptions): this;

            /**
             * Removes the vertex currently being pointed.
             * @return  True when a vertex was removed.
             * @api  
             */
            removePoint(): boolean
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by scrolling the mouse wheel.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @api  stable
         */
        declare class MouseWheelZoom mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by scrolling the mouse wheel.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.MouseWheelZoomOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
             * mousewheel-event) and eventually zooms the map.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.MouseWheelZoom}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean;

            /**
             * Enable or disable using the mouse's location as an anchor when zooming
             * @param  true to zoom to the mouse's location, false
            to zoom to the center of the map
             * @api  
            */
            setMouseAnchor(useAnchor: boolean): void
        }

        /**
         * 
         * @classdesc  * Allows the user to rotate the map by twisting with two fingers
        on a touch screen.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class PinchRotate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to rotate the map by twisting with two fingers
            on a touch screen.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.PinchRotateOptions): this
        }

        /**
         * 
         * @classdesc  * Allows the user to zoom the map by pinching with two fingers
        on a touch screen.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  stable
        */
        declare class PinchZoom mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Allows the user to zoom the map by pinching with two fingers
            on a touch screen.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.PinchZoomOptions): this
        }

        /**
         * 
         * @classdesc  * Base class that calls user-defined functions on `down`, `move` and `up`
        events. This class also manages "drag sequences".

        When the `handleDownEvent` user function returns `true` a drag sequence is
        started. During a drag sequence the `handleDragEvent` user function is
        called on `move` events. The drag sequence ends when the `handleUpEvent`
        user function is called and returns `false`.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.interaction.Interaction}
         * @api  
        */
        declare class Pointer mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Base class that calls user-defined functions on `down`, `move` and `up`
            events. This class also manages "drag sequences".

            When the `handleDownEvent` user function returns `true` a drag sequence is
            started. During a drag sequence the `handleDragEvent` user function is
            called on `move` events. The drag sequence ends when the `handleUpEvent`
            user function is called and returns `false`.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.interaction.Interaction}
             * @api  
            */
            constructor(opt_options?: undefined.PointerOptions): this;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
             * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
            detected.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.Pointer}
             * @api  
            */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Select} instances are instances of
        this type.
         * @param  The event type.
         * @param  Selected features.
         * @param  Deselected features.
         * @param  Associated
        {
         * @link  ol.MapBrowserEvent}.
         * @implements  {oli.SelectEvent}
         * @extends  {ol.events.Event}
         * @constructor  
        */
        declare class SelectEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Select} instances are instances of
            this type.
             * @param  The event type.
             * @param  Selected features.
             * @param  Deselected features.
             * @param  Associated
            {
             * @link  ol.MapBrowserEvent}.
             * @implements  {oli.SelectEvent}
             * @extends  {ol.events.Event}
             * @constructor  
            */
            constructor(type: string, selected: ol.Feature[], deselected: ol.Feature[], mapBrowserEvent: ol.MapBrowserEvent): this;

            /**
             * Selected features array.
             * @type  * 
             * @api  
             */
            selected: ol.Feature[];

            /**
             * Deselected features array.
             * @type  * 
             * @api  
             */
            deselected: ol.Feature[];

            /**
             * Associated {@link ol.MapBrowserEvent}.
             * @type  * 
             * @api  
             */
            mapBrowserEvent: ol.MapBrowserEvent
        }

        /**
         * 
         * @classdesc  * Interaction for selecting vector features. By default, selected features are
        styled differently, so this interaction can be used for visual highlighting,
        as well as selecting features for other actions, such as modification or
        output. There are three ways of controlling which features are selected:
        using the browser event as defined by the `condition` and optionally the
        `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
        further feature filter using the `filter` option.

        Selected features are added to an internal unmanaged layer.
         * @constructor  * 
         * @extends  {ol.interaction.Interaction}
         * @param  Options.
         * @fires  ol.interaction.SelectEvent
         * @api  stable
        */
        declare class Select mixins undefined.Interaction {

            /**
             * 
             * @classdesc  * Interaction for selecting vector features. By default, selected features are
            styled differently, so this interaction can be used for visual highlighting,
            as well as selecting features for other actions, such as modification or
            output. There are three ways of controlling which features are selected:
            using the browser event as defined by the `condition` and optionally the
            `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
            further feature filter using the `filter` option.

            Selected features are added to an internal unmanaged layer.
             * @constructor  * 
             * @extends  {ol.interaction.Interaction}
             * @param  Options.
             * @fires  ol.interaction.SelectEvent
             * @api  stable
            */
            constructor(opt_options?: undefined.SelectOptions): this;

            /**
             * Get the selected features.
             * @return  Features collection.
             * @api  stable
             */
            getFeatures(): ol.Collection<ol.Feature>;

            /**
             * Returns the associated {@link ol.layer.Vector vectorlayer} of
             * the (last) selected feature. Note that this will not work with any
            programmatic method like pushing features to
            {
             * @link  ol.interaction.Select#getFeatures collection}.
             * @param  Feature
             * @return  Layer.
             * @api  
            */
            getLayer(feature: (ol.Feature | undefined.Feature)): undefined.Vector;

            /**
             * Handles the {@link ol.MapBrowserEvent map browser event} and may change the
             * selected state of features.
             * @param  Map browser event.
             * @return  `false` to stop event propagation.
             * @this  {ol.interaction.Select}
             * @api  
             */
            handleEvent(mapBrowserEvent: ol.MapBrowserEvent): boolean;

            /**
             * Remove the interaction from its current map, if any,  and attach it to a new
             * map, if any. Pass `null` to just remove the interaction from the current map.
             * @param  Map.
             * @api  stable
             */
            setMap(map: ol.Map): void
        }

        /**
         * 
         * @classdesc  * Handles snapping of vector features while modifying or drawing them.  The
        features can come from a {
         * @link  ol.source.Vector} or {
         * @link  ol.Collection}
        Any interaction object that allows the user to interact
        with the features using the mouse can benefit from the snapping, as long
        as it is added before.

        The snap interaction modifies map browser event `coordinate` and `pixel`
        properties to force the snap to occur to any interaction that them.

        Example:

        var snap = new ol.interaction.Snap({
        source: source
        });
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @param  Options.
         * @api  
        */
        declare class Snap mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Handles snapping of vector features while modifying or drawing them.  The
            features can come from a {
             * @link  ol.source.Vector} or {
             * @link  ol.Collection}
            Any interaction object that allows the user to interact
            with the features using the mouse can benefit from the snapping, as long
            as it is added before.

            The snap interaction modifies map browser event `coordinate` and `pixel`
            properties to force the snap to occur to any interaction that them.

            Example:

            var snap = new ol.interaction.Snap({
            source: source
            });
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.SnapOptions): this;

            /**
             * Add a feature to the collection of features that we may snap to.
             * @param  Feature.
             * @param  Whether to listen to the geometry change or not
            Defaults to `true`.
             * @api  
            */
            addFeature(feature: ol.Feature, opt_listen?: boolean): void;

            /**
             * Remove a feature from the collection of features that we may snap to.
             * @param  Feature
             * @param  Whether to unlisten to the geometry change
            or not. Defaults to `true`.
             * @api  
            */
            removeFeature(feature: ol.Feature, opt_unlisten?: boolean): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.interaction.Translate} instances are instances of
        this type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.interaction.TranslateEvent}
         * @param  Type.
         * @param  The features translated.
         * @param  The event coordinate.
        */
        declare class TranslateEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.interaction.Translate} instances are instances of
            this type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.interaction.TranslateEvent}
             * @param  Type.
             * @param  The features translated.
             * @param  The event coordinate.
            */
            constructor(type: undefined.TranslateEventType, features: ol.Collection<ol.Feature>, coordinate: ol.Coordinate): this;

            /**
             * The features being translated.
             * @type  * 
             * @api  
             */
            features: ol.Collection<ol.Feature>;

            /**
             * The coordinate of the drag event.
             * @const  * 
             * @type  * 
             * @api  
             */
            coordinate: ol.Coordinate
        }
        declare type TranslateEventType = string;

        /**
         * 
         * @classdesc  * Interaction for translating (moving) features.
         * @constructor  * 
         * @extends  {ol.interaction.Pointer}
         * @fires  ol.interaction.TranslateEvent
         * @param  Options.
         * @api  
         */
        declare class Translate mixins undefined.Pointer {

            /**
             * 
             * @classdesc  * Interaction for translating (moving) features.
             * @constructor  * 
             * @extends  {ol.interaction.Pointer}
             * @fires  ol.interaction.TranslateEvent
             * @param  Options.
             * @api  
             */
            constructor(options: undefined.TranslateOptions): this
        }

        /**
         * Object literal with config options for interactions.
         * @typedef  
         */
        declare interface InteractionOptions {
            handleEvent: (event: ol.MapBrowserEvent) => boolean
        }

        /**
         * 
         * @typedef  *     attributionOptions: (olx.control.AttributionOptions|undefined),
        rotate: (boolean|undefined),
        rotateOptions: (olx.control.RotateOptions|undefined),
        zoom: (boolean|undefined),
        zoomOptions: (olx.control.ZoomOptions|undefined)}}
        */
        declare interface DefaultsOptions {
            attribution?: boolean,
                attributionOptions?: undefined.AttributionOptions,
                rotate?: boolean,
                rotateOptions?: undefined.RotateOptions,
                zoom?: boolean,
                zoomOptions?: undefined.ZoomOptions
        }

        /**
         * 
         * @typedef  *     delta: (number|undefined)}}
         */
        declare interface DoubleClickZoomOptions {
            duration?: number,
                delta?: number
        }

        /**
         * 
         * @typedef  >|undefined),
        projection: ol.ProjectionLike,
        target: (Element|undefined)}}
        */
        declare interface DragAndDropOptions {
            formatConstructors?: ((n: undefined.Feature) => any)[],
                projection: ol.ProjectionLike,
                target?: Element
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        boxEndCondition: (ol.DragBoxEndConditionType|undefined)}}
        */
        declare interface DragBoxOptions {
            className?: string,
                condition?: ol.EventsConditionType,
                boxEndCondition?: ol.DragBoxEndConditionType
        }

        /**
         * 
         * @typedef  *     kinetic: (ol.Kinetic|undefined)}}
         */
        declare interface DragPanOptions {
            condition?: ol.EventsConditionType,
                kinetic?: ol.Kinetic
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface DragRotateAndZoomOptions {
            condition?: ol.EventsConditionType,
                duration?: number
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface DragRotateOptions {
            condition?: ol.EventsConditionType,
                duration?: number
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        duration: (number|undefined),
        out: (boolean|undefined)}}
        */
        declare interface DragZoomOptions {
            className?: string,
                condition?: ol.EventsConditionType,
                duration?: number,
                out?: boolean
        }

        /**
         * 
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        source: (ol.source.Vector|undefined),
        snapTolerance: (number|undefined),
        type: ol.geom.GeometryType,
        maxPoints: (number|undefined),
        minPoints: (number|undefined),
        finishCondition: (ol.EventsConditionType|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        geometryFunction: (ol.DrawGeometryFunctionType|undefined),
        geometryName: (string|undefined),
        condition: (ol.EventsConditionType|undefined),
        freehandCondition: (ol.EventsConditionType|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface DrawOptions {
            clickTolerance?: number,
                features?: ol.Collection<ol.Feature>,
                source?: undefined.Vector,
                snapTolerance?: number,
                type: undefined.GeometryType,
                maxPoints?: number,
                minPoints?: number,
                finishCondition?: ol.EventsConditionType,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                geometryFunction?: ol.DrawGeometryFunctionType,
                geometryName?: string,
                condition?: ol.EventsConditionType,
                freehandCondition?: ol.EventsConditionType,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        layers: (undefined|Array.<ol.layer.Layer>|function(ol.layer.Layer): boolean)
        }}
        */
        declare interface TranslateOptions {
            features?: ol.Collection<ol.Feature>,
                layers?: (undefined.Layer[] | ((layer: undefined.Layer) => boolean))
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined),
        pixelDelta: (number|undefined)}}
        */
        declare interface KeyboardPanOptions {
            condition?: ol.EventsConditionType,
                duration?: number,
                pixelDelta?: number
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        delta: (number|undefined)}}
        */
        declare interface KeyboardZoomOptions {
            duration?: number,
                condition?: ol.EventsConditionType,
                delta?: number
        }

        /**
         * 
         * @typedef  *     deleteCondition: (ol.EventsConditionType|undefined),
        pixelTolerance: (number|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        features: ol.Collection.<ol.Feature>,
        wrapX: (boolean|undefined)}}
        */
        declare interface ModifyOptions {
            condition?: ol.EventsConditionType,
                deleteCondition?: ol.EventsConditionType,
                pixelTolerance?: number,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                features: ol.Collection<ol.Feature>,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     useAnchor: (boolean|undefined)}}
         */
        declare interface MouseWheelZoomOptions {
            duration?: number,
                useAnchor?: boolean
        }

        /**
         * 
         * @typedef  *     duration: (number|undefined)}}
         */
        declare interface PinchRotateOptions {
            duration?: number,
                threshold?: number
        }

        /**
         * 
         * @typedef  
         */
        declare interface PinchZoomOptions {
            duration?: number
        }

        /**
         * 
         * @typedef  *     handleDragEvent: (function(ol.MapBrowserPointerEvent)|undefined),
        handleEvent: (function(ol.MapBrowserEvent):boolean|undefined),
        handleMoveEvent: (function(ol.MapBrowserPointerEvent)|undefined),
        handleUpEvent: (function(ol.MapBrowserPointerEvent):boolean|undefined)}}
        */
        declare interface PointerOptions {
            handleDownEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleDragEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleMoveEvent?: ((event: ol.MapBrowserPointerEvent) => boolean),
                handleUpEvent?: ((event: ol.MapBrowserPointerEvent) => boolean)
        }

        /**
         * 
         * @typedef  *     condition: (ol.EventsConditionType|undefined),
        layers: (undefined|Array.<ol.layer.Layer>|function(ol.layer.Layer): boolean),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        removeCondition: (ol.EventsConditionType|undefined),
        toggleCondition: (ol.EventsConditionType|undefined),
        multi: (boolean|undefined),
        features: (ol.Collection.<ol.Feature>|undefined),
        filter: (ol.SelectFilterFunction|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface SelectOptions {
            addCondition?: ol.EventsConditionType,
                condition?: ol.EventsConditionType,
                layers?: (undefined.Layer[] | ((layer: undefined.Layer) => boolean)),
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                removeCondition?: ol.EventsConditionType,
                toggleCondition?: ol.EventsConditionType,
                multi?: boolean,
                features?: ol.Collection<ol.Feature>,
                filter?: ol.SelectFilterFunction,
                wrapX?: boolean
        }

        /**
         * Options for snap
         * @typedef  *     features: (ol.Collection.<ol.Feature>|undefined),
        pixelTolerance: (number|undefined),
        source: (ol.source.Vector|undefined),
        edge: (boolean|undefined),
        vertex: (boolean|undefined)
        }}
        */
        declare interface SnapOptions {
            features?: ol.Collection<ol.Feature>,
                edge?: boolean,
                vertex?: boolean,
                pixelTolerance?: number,
                source?: undefined.Vector
        }
    }

    declare module 'layer' {

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Note that with `ol.layer.Base` and all its subclasses, any property set in
        the options is set as a {
         * @link  ol.Object} property on the layer object, so
        is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Layer options.
         * @api  stable
        */
        declare class Base mixins ol.Object {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Note that with `ol.layer.Base` and all its subclasses, any property set in
            the options is set as a {
             * @link  ol.Object} property on the layer object, so
            is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.Object}
             * @param  Layer options.
             * @api  stable
            */
            constructor(options: undefined.BaseOptions): this;

            /**
             * Return the {@link ol.Extent extent} of the layer or `undefined` if it
             * will be visible regardless of extent.
             * @return  The layer extent.
             * @observable  * 
             * @api  stable
             */
            getExtent(): (ol.Extent);

            /**
             * Return the maximum resolution of the layer.
             * @return  The maximum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            getMaxResolution(): number;

            /**
             * Return the minimum resolution of the layer.
             * @return  The minimum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            getMinResolution(): number;

            /**
             * Return the opacity of the layer (between 0 and 1).
             * @return  The opacity of the layer.
             * @observable  * 
             * @api  stable
             */
            getOpacity(): number;

            /**
             * Return the visibility of the layer (`true` or `false`).
             * @return  The visibility of the layer.
             * @observable  * 
             * @api  stable
             */
            getVisible(): boolean;

            /**
             * Return the Z-index of the layer, which is used to order layers before
             * rendering. The default Z-index is 0.
             * @return  The Z-index of the layer.
             * @observable  * 
             * @api  
             */
            getZIndex(): number;

            /**
             * Set the extent at which the layer is visible.  If `undefined`, the layer
             * will be visible at all extents.
             * @param  The extent of the layer.
             * @observable  * 
             * @api  stable
             */
            setExtent(extent: (ol.Extent)): void;

            /**
             * Set the maximum resolution at which the layer is visible.
             * @param  The maximum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            setMaxResolution(maxResolution: number): void;

            /**
             * Set the minimum resolution at which the layer is visible.
             * @param  The minimum resolution of the layer.
             * @observable  * 
             * @api  stable
             */
            setMinResolution(minResolution: number): void;

            /**
             * Set the opacity of the layer, allowed values range from 0 to 1.
             * @param  The opacity of the layer.
             * @observable  * 
             * @api  stable
             */
            setOpacity(opacity: number): void;

            /**
             * Set the visibility of the layer (`true` or `false`).
             * @param  The visibility of the layer.
             * @observable  * 
             * @api  stable
             */
            setVisible(visible: boolean): void;

            /**
             * Set Z-index of the layer, which is used to order layers before rendering.
             * The default Z-index is 0.
             * @param  The z-index of the layer.
             * @observable  * 
             * @api  
             */
            setZIndex(zindex: number): void
        }

        /**
         * 
         * @classdesc  * A {
         * @link  ol.Collection} of layers that are handled together.

        A generic `change` event is triggered when the group/Collection changes.
         * @constructor  * 
         * @extends  {ol.layer.Base}
         * @param  Layer options.
         * @api  stable
        */
        declare class Group mixins undefined.Base {

            /**
             * 
             * @classdesc  * A {
             * @link  ol.Collection} of layers that are handled together.

            A generic `change` event is triggered when the group/Collection changes.
             * @constructor  * 
             * @extends  {ol.layer.Base}
             * @param  Layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.GroupOptions): this;

            /**
             * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
             * in this group.
             * @return  Collection of
            {
             * @link  ol.layer.Base layers} that are part of this group.
             * @observable  * 
             * @api  stable
            */
            getLayers(): ol.Collection<undefined.Base>;

            /**
             * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
             * in this group.
             * @param  Collection of
            {
             * @link  ol.layer.Base layers} that are part of this group.
             * @observable  * 
             * @api  stable
            */
            setLayers(layers: ol.Collection<undefined.Base>): void
        }

        /**
         * 
         * @classdesc  * Layer for rendering vector data as a heatmap.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Vector}
         * @fires  ol.render.Event
         * @param  Options.
         * @api  
        */
        declare class Heatmap mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer for rendering vector data as a heatmap.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Vector}
             * @fires  ol.render.Event
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.HeatmapOptions): this;

            /**
             * Return the blur size in pixels.
             * @return  Blur size in pixels.
             * @api  * 
             * @observable  
             */
            getBlur(): number;

            /**
             * Return the gradient colors as array of strings.
             * @return  Colors.
             * @api  * 
             * @observable  
             */
            getGradient(): string[];

            /**
             * Return the size of the radius in pixels.
             * @return  Radius size in pixel.
             * @api  * 
             * @observable  
             */
            getRadius(): number;

            /**
             * Set the blur size in pixels.
             * @param  Blur size in pixels.
             * @api  * 
             * @observable  
             */
            setBlur(blur: number): void;

            /**
             * Set the gradient colors as array of strings.
             * @param  Gradient.
             * @api  * 
             * @observable  
             */
            setGradient(colors: string[]): void;

            /**
             * Set the size of the radius in pixels.
             * @param  Radius size in pixel.
             * @api  * 
             * @observable  
             */
            setRadius(radius: number): void
        }

        /**
         * 
         * @classdesc  * Server-rendered images that are available for arbitrary extents and
        resolutions.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Layer options.
         * @api  stable
        */
        declare class Image mixins undefined.Layer {

            /**
             * 
             * @classdesc  * Server-rendered images that are available for arbitrary extents and
            resolutions.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.ImageOptions): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        A visual representation of raster or vector map data.
        Layers group together those properties that pertain to how the data is to be
        displayed, irrespective of the source of that data.

        Layers are usually added to a map with {
         * @link  ol.Map#addLayer}. Components
        like {
         * @link  ol.interaction.Select} use unmanaged layers internally. These
        unmanaged layers are associated with the map using
        {
         * @link  ol.layer.Layer#setMap} instead.

        A generic `change` event is fired when the state of the source changes.
         * @constructor  * 
         * @extends  {ol.layer.Base}
         * @fires  ol.render.Event
         * @param  Layer options.
         * @api  stable
        */
        declare class Layer mixins undefined.Base {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            A visual representation of raster or vector map data.
            Layers group together those properties that pertain to how the data is to be
            displayed, irrespective of the source of that data.

            Layers are usually added to a map with {
             * @link  ol.Map#addLayer}. Components
            like {
             * @link  ol.interaction.Select} use unmanaged layers internally. These
            unmanaged layers are associated with the map using
            {
             * @link  ol.layer.Layer#setMap} instead.

            A generic `change` event is fired when the state of the source changes.
             * @constructor  * 
             * @extends  {ol.layer.Base}
             * @fires  ol.render.Event
             * @param  Layer options.
             * @api  stable
            */
            constructor(options: undefined.LayerOptions): this;

            /**
             * Get the layer source.
             * @return  The layer source (or `null` if not yet set).
             * @observable  * 
             * @api  stable
             */
            getSource(): undefined.Source;

            /**
             * Sets the layer to be rendered on top of other layers on a map. The map will
             * not manage this layer in its layers collection, and the callback in
            {
             * @link  ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
            is useful for temporary layers. To remove an unmanaged layer from the map,
            use `#setMap(null)`.

            To add the layer to a map and have it managed by the map, use
            {
             * @link  ol.Map#addLayer} instead.
             * @param  Map.
             * @api  
            */
            setMap(map: ol.Map): void;

            /**
             * Set the layer source.
             * @param  The layer source.
             * @observable  * 
             * @api  stable
             */
            setSource(source: undefined.Source): void
        }

        /**
         * 
         * @classdesc  * For layer sources that provide pre-rendered, tiled images in grids that are
        organized by zoom levels for specific resolutions.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Tile layer options.
         * @api  stable
        */
        declare class Tile mixins undefined.Layer {

            /**
             * 
             * @classdesc  * For layer sources that provide pre-rendered, tiled images in grids that are
            organized by zoom levels for specific resolutions.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Tile layer options.
             * @api  stable
            */
            constructor(opt_options?: undefined.TileOptions): this;

            /**
             * Return the level as number to which we will preload tiles up to.
             * @return  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            getPreload(): number;

            /**
             * Set the level as number to which we will preload tiles up to.
             * @param  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            setPreload(preload: number): void;

            /**
             * Whether we use interim tiles on error.
             * @return  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            getUseInterimTilesOnError(): boolean;

            /**
             * Set whether we use interim tiles on error.
             * @param  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            setUseInterimTilesOnError(useInterimTilesOnError: boolean): void
        }

        /**
         * 
         * @classdesc  * Vector data that is rendered client-side.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Layer}
         * @fires  ol.render.Event
         * @param  Options.
         * @api  stable
        */
        declare class Vector mixins undefined.Layer {

            /**
             * 
             * @classdesc  * Vector data that is rendered client-side.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Layer}
             * @fires  ol.render.Event
             * @param  Options.
             * @api  stable
            */
            constructor(opt_options?: undefined.VectorOptions): this;

            /**
             * Return the associated {@link ol.source.Vector vectorsource} of the layer.
             * @return  Source.
             * @api  stable
             */
            getSource(): undefined.Vector;

            /**
             * Get the style for features.  This returns whatever was passed to the `style`
             * option at construction or to the `setStyle` method.
             * @return  *     Layer style.
             * @api  stable
             */
            getStyle(): (undefined.Style | undefined.Style[] | ol.StyleFunction);

            /**
             * Get the style function.
             * @return  Layer style function.
             * @api  stable
             */
            getStyleFunction(): (ol.StyleFunction);

            /**
             * Set the style for features.  This can be a single style object, an array
             * of styles, or a function that takes a feature and resolution and returns
            an array of styles. If it is `undefined` the default style is used. If
            it is `null` the layer has no style (a `null` style), so only features
            that have their own styles will be rendered in the layer. See
            {style Layer style.
             * @link  ol.style} for information on the default style.
             * @api  stable
            */
            setStyle(style: (undefined.Style | undefined.Style[] | ol.StyleFunction)): void
        }

        /**
         * 
         * @enum  {string}
        Render mode for vector tiles:
        * `'image'`: Vector tiles are rendered as images. Great performance, but
        point symbols and texts are always rotated with the view and pixels are
        scaled during zoom animations.
        * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
        are scaled during zoom animations. Point symbols and texts are accurately
        rendered as vectors and can stay upright on rotated views.
        * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
        even during animations, but slower performance than the other options.
         * @api  
        */
        declare type VectorTileRenderType = string;

        /**
         * 
         * @classdesc  * Layer for vector tile data that is rendered client-side.
        Note that any property set in the options is set as a {
         * @link  ol.Object}
        property on the layer object; for example, setting `title: 'My Title'` in the
        options means that `title` is observable, and has get/set accessors.
         * @constructor  * 
         * @extends  {ol.layer.Vector}
         * @param  Options.
         * @api  
        */
        declare class VectorTile mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer for vector tile data that is rendered client-side.
            Note that any property set in the options is set as a {
             * @link  ol.Object}
            property on the layer object; for example, setting `title: 'My Title'` in the
            options means that `title` is observable, and has get/set accessors.
             * @constructor  * 
             * @extends  {ol.layer.Vector}
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.VectorTileOptions): this;

            /**
             * Return the level as number to which we will preload tiles up to.
             * @return  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            getPreload(): number;

            /**
             * Whether we use interim tiles on error.
             * @return  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            getUseInterimTilesOnError(): boolean;

            /**
             * Set the level as number to which we will preload tiles up to.
             * @param  The level to preload tiles up to.
             * @observable  * 
             * @api  
             */
            setPreload(preload: number): void;

            /**
             * Set whether we use interim tiles on error.
             * @param  Use interim tiles on error.
             * @observable  * 
             * @api  
             */
            setUseInterimTilesOnError(useInterimTilesOnError: boolean): void
        }

        /**
         * 
         * @typedef  *     visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface BaseOptions {
            opacity?: number,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     source: (ol.source.Source|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface LayerOptions {
            opacity?: number,
                source?: undefined.Source,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        zIndex: (number|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        layers: (Array.<ol.layer.Base>|ol.Collection.<ol.layer.Base>|undefined)}}
        */
        declare interface GroupOptions {
            opacity?: number,
                visible?: boolean,
                extent?: ol.Extent,
                zIndex?: number,
                minResolution?: number,
                maxResolution?: number,
                layers?: (undefined.Base[] | ol.Collection<undefined.Base>)
        }

        /**
         * 
         * @typedef  *     radius: (number|undefined),
        blur: (number|undefined),
        shadow: (number|undefined),
        weight: (string|function(ol.Feature):number|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        source: (ol.source.Vector|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface HeatmapOptions {
            gradient?: string[],
                radius?: number,
                blur?: number,
                shadow?: number,
                weight: (string | ((feature: ol.Feature) => number)),
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source: undefined.Vector,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        source: (ol.source.Image|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined)}}
        */
        declare interface ImageOptions {
            opacity?: number,
                source: undefined.Image,
                map?: ol.Map,
                visible?: boolean,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number
        }

        /**
         * 
         * @typedef  *     preload: (number|undefined),
        source: (ol.source.Tile|undefined),
        map: (ol.Map|undefined),
        visible: (boolean|undefined),
        extent: (ol.Extent|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        useInterimTilesOnError: (boolean|undefined)}}
        */
        declare interface TileOptions {
            opacity?: number,
                preload?: number,
                source: undefined.Tile,
                map?: ol.Map,
                visible?: boolean,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                useInterimTilesOnError?: boolean
        }

        /**
         * 
         * @typedef  *     minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        source: (ol.source.Vector|undefined),
        map: (ol.Map|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorOptions {
            renderOrder?: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                renderBuffer?: number,
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        renderMode: (ol.layer.VectorTileRenderType|string|undefined),
        renderOrder: (function(ol.Feature, ol.Feature):number|undefined),
        source: (ol.source.VectorTile|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorTileOptions {
            renderBuffer?: number,
                renderMode?: (undefined.VectorTileRenderType | string),
                renderOrder: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source?: undefined.VectorTile,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }
    }

    declare module 'parser' {

    }

    declare module 'render' {
        declare module 'canvas' {

            /**
             * 
             * @classdesc  * A concrete subclass of {
             * @link  ol.render.VectorContext} that implements
            direct rendering of features and geometries to an HTML5 Canvas context.
            Instances of this class are created internally by the library and
            provided to application code as vectorContext member of the
            {
             * @link  ol.render.Event} object associated with postcompose, precompose and
            render events emitted by layers and maps.
             * @constructor  * 
             * @extends  {ol.render.VectorContext}
             * @param  Context.
             * @param  Pixel ratio.
             * @param  Extent.
             * @param  Transform.
             * @param  View rotation.
             * @struct  
            */
            declare class Immediate mixins undefined.VectorContext {

                /**
                 * 
                 * @classdesc  * A concrete subclass of {
                 * @link  ol.render.VectorContext} that implements
                direct rendering of features and geometries to an HTML5 Canvas context.
                Instances of this class are created internally by the library and
                provided to application code as vectorContext member of the
                {
                 * @link  ol.render.Event} object associated with postcompose, precompose and
                render events emitted by layers and maps.
                 * @constructor  * 
                 * @extends  {ol.render.VectorContext}
                 * @param  Context.
                 * @param  Pixel ratio.
                 * @param  Extent.
                 * @param  Transform.
                 * @param  View rotation.
                 * @struct  
                */
                constructor(context: CanvasRenderingContext2D, pixelRatio: number, extent: ol.Extent, transform: any, viewRotation: number): this;

                /**
                 * Render a circle geometry into the canvas.  Rendering is immediate and uses
                 * the current fill and stroke styles.
                 * @param  Circle geometry.
                 * @api  
                 */
                drawCircle(geometry: undefined.Circle): void;

                /**
                 * Set the rendering style.  Note that since this is an immediate rendering API,
                 * any `zIndex` on the provided style will be ignored.
                 * @param  The rendering style.
                 * @api  
                 */
                setStyle(style: undefined.Style): void;

                /**
                 * Render a geometry into the canvas.  Call
                 * {
                 * @link  ol.render.canvas.Immediate#setStyle} first to set the rendering style.
                 * @param  The geometry to render.
                 * @api  
                 */
                drawGeometry(geometry: (undefined.Geometry | undefined.Feature)): void;

                /**
                 * Render a feature into the canvas.  Note that any `zIndex` on the provided
                 * style will be ignored - features are rendered immediately in the order that
                this method is called.  If you need `zIndex` support, you should be using an
                {
                 * @link  ol.layer.Vector} instead.
                 * @param  Feature.
                 * @param  Style.
                 * @api  
                */
                drawFeature(feature: ol.Feature, style: undefined.Style): void
            }
        }


        /**
         * 
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.render.Event}
         * @param  Type.
         * @param  Vector context.
         * @param  Frame state.
         * @param  Context.
         * @param  WebGL Context.
         */
        declare class Event mixins undefined.Event {

            /**
             * 
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.render.Event}
             * @param  Type.
             * @param  Vector context.
             * @param  Frame state.
             * @param  Context.
             * @param  WebGL Context.
             */
            constructor(type: undefined.EventType, opt_vectorContext?: undefined.VectorContext, opt_frameState?: olx.FrameState, opt_context?: CanvasRenderingContext2D, opt_glContext?: any): this;

            /**
             * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
             * @type  * 
             * @api  
             */
            vectorContext: undefined.VectorContext;

            /**
             * An object representing the current render frame state.
             * @type  * 
             * @api  
             */
            frameState: olx.FrameState;

            /**
             * Canvas context. Only available when a Canvas renderer is used, null
             * otherwise.
             * @type  * 
             * @api  
             */
            context: CanvasRenderingContext2D;

            /**
             * WebGL context. Only available when a WebGL renderer is used, null
             * otherwise.
             * @type  * 
             * @api  
             */
            glContext: any
        }
        declare type EventType = string;

        /**
         * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like
         * structure, optimized for rendering and styling. Geometry access through the
        API is limited to getting the type and extent of the geometry.
         * @constructor  * 
         * @param  Geometry type.
         * @param  Flat coordinates. These always need
        to be right-handed for polygons.
         * @param  Ends or Endss.
         * @param  Properties.
        */
        declare class Feature {

            /**
             * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like
             * structure, optimized for rendering and styling. Geometry access through the
            API is limited to getting the type and extent of the geometry.
             * @constructor  * 
             * @param  Geometry type.
             * @param  Flat coordinates. These always need
            to be right-handed for polygons.
             * @param  Ends or Endss.
             * @param  Properties.
            */
            constructor(type: undefined.GeometryType, flatCoordinates: number[], ends: (number[] | number[][]), properties: {
                [k: string]: any
            }): this;

            /**
             * Get a feature property by its key.
             * @param  Key
             * @return  Value for the requested key.
             * @api  
             */
            get(key: string): any;

            /**
             * Get the extent of this feature's geometry.
             * @return  Extent.
             * @api  
             */
            getExtent(): ol.Extent;

            /**
             * Get the feature for working with its geometry.
             * @return  Feature.
             * @api  
             */
            getGeometry(): undefined.Feature;

            /**
             * Get the feature properties.
             * @return  Feature properties.
             * @api  
             */
            getProperties(): {
                [k: string]: any
            };

            /**
             * Get the type of this feature's geometry.
             * @return  Geometry type.
             * @api  
             */
            getType(): undefined.GeometryType
        }

        /**
         * Context for drawing geometries.  A vector context is available on render
         * events and does not need to be constructed directly.
         * @constructor  * 
         * @struct  * 
         * @api  
         */
        declare class VectorContext {

            /**
             * Context for drawing geometries.  A vector context is available on render
             * events and does not need to be constructed directly.
             * @constructor  * 
             * @struct  * 
             * @api  
             */
            constructor(): this
        }

        /**
         * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
         * to the context's canvas.

        The units for geometry coordinates are css pixels relative to the top left
        corner of the canvas element.
        ```js
        var canvas = document.createElement('canvas');
        var render = ol.render.toContext(canvas.getContext('2d'),
             { size: [100, 100] });
        render.setFillStrokeStyle(new ol.style.Fill({ color: blue }));
        render.drawPolygon(
             new ol.geom.Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
        ```
         * @param  Canvas context.
         * @param  Options.
         * @return  Canvas Immediate.
         * @api  
        */
        declare     function toContext(
            context: CanvasRenderingContext2D,
            opt_options?: undefined.ToContextOptions): undefined.Immediate

        /**
         * 
         * @typedef  *     pixelRatio: (number|undefined)}}
         */
        declare interface ToContextOptions {
            size?: ol.Size,
                pixelRatio?: number
        }
    }

    declare module 'source' {

        /**
         * 
         * @classdesc  * Layer source for Bing Maps tile data.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Bing Maps options.
         * @api  stable
         */
        declare class BingMaps mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for Bing Maps tile data.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Bing Maps options.
             * @api  stable
             */
            constructor(options: undefined.BingMapsOptions): this;

            /**
             * The attribution containing a link to the Microsoft® Bing™ Maps Platform APIs’
             * Terms Of Use.
             * @const  * 
             * @type  * 
             * @api  
             */
            TOS_ATTRIBUTION: ol.Attribution
        }

        /**
         * 
         * @classdesc  * Layer source for the CartoDB tiles.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  CartoDB options.
         * @api  
         */
        declare class CartoDB mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the CartoDB tiles.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  CartoDB options.
             * @api  
             */
            constructor(options: undefined.CartoDBOptions): this;

            /**
             * Returns the current config.
             * @return  The current configuration.
             * @api  
             */
            getConfig(): GlobalObject;

            /**
             * Updates the carto db config.
             * @param  a key-value lookup. Values will replace current values
            in the config.
             * @api  
            */
            updateConfig(config: GlobalObject): void;

            /**
             * Sets the CartoDB config
             * @param  In the case of anonymous maps, a CartoDB configuration
            object.
            If using named maps, a key-value lookup with the template parameters.
             * @api  
            */
            setConfig(config: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Layer source to cluster vector data. Works out of the box with point
        geometries. For other geometry types, or if not all geometries should be
        considered for clustering, a custom `geometryFunction` can be defined.
         * @constructor  * 
         * @param  Constructor options.
         * @extends  {ol.source.Vector}
         * @api  
        */
        declare class Cluster mixins undefined.Vector {

            /**
             * 
             * @classdesc  * Layer source to cluster vector data. Works out of the box with point
            geometries. For other geometry types, or if not all geometries should be
            considered for clustering, a custom `geometryFunction` can be defined.
             * @constructor  * 
             * @param  Constructor options.
             * @extends  {ol.source.Vector}
             * @api  
            */
            constructor(options: undefined.ClusterOptions): this;

            /**
             * Get a reference to the wrapped source.
             * @return  Source.
             * @api  
             */
            getSource(): undefined.Vector;

            /**
             * Set the distance in pixels between clusters.
             * @param  The distance in pixels.
             * @api  
             */
            setDistance(distance: number): void
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for sources providing a single image.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @param  Single image source options.
         * @api  
        */
        declare class Image mixins undefined.Source {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for sources providing a single image.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @param  Single image source options.
             * @api  
            */
            constructor(options: ol.SourceImageOptions): this
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Image} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.ImageEvent}
         * @param  Type.
         * @param  The image.
        */
        declare class ImageEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Image} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.ImageEvent}
             * @param  Type.
             * @param  The image.
            */
            constructor(type: string, image: ol.Image): this;

            /**
             * The image related to the event.
             * @type  * 
             * @api  
             */
            image: ol.Image
        }

        /**
         * 
         * @classdesc  * Source for data from ArcGIS Rest services providing single, untiled images.
        Useful when underlying map service has labels.

        If underlying map service is not using labels,
        take advantage of ol image caching and use
        {
         * @link  ol.source.TileArcGISRest} data source.
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Image ArcGIS Rest Options.
         * @api  
        */
        declare class ImageArcGISRest mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for data from ArcGIS Rest services providing single, untiled images.
            Useful when underlying map service has labels.

            If underlying map service is not using labels,
            take advantage of ol image caching and use
            {
             * @link  ol.source.TileArcGISRest} data source.
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Image ArcGIS Rest Options.
             * @api  
            */
            constructor(opt_options?: undefined.ImageArcGISRestOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Return the URL used for this ArcGIS source.
             * @return  URL.
             * @api  stable
             */
            getUrl(): (string);

            /**
             * Set the image load function of the source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: (string)): void;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Base class for image sources where a canvas element is the image.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @param  Constructor options.
         * @api  
         */
        declare class ImageCanvas mixins undefined.Image {

            /**
             * 
             * @classdesc  * Base class for image sources where a canvas element is the image.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @param  Constructor options.
             * @api  
             */
            constructor(options: undefined.ImageCanvasOptions): this
        }

        /**
         * 
         * @classdesc  * Source for images from Mapguide servers
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageMapGuide mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for images from Mapguide servers
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.ImageMapGuideOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void;

            /**
             * Set the image load function of the MapGuide source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void
        }

        /**
         * 
         * @classdesc  * A layer source for displaying a single, static image.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageStatic mixins undefined.Image {

            /**
             * 
             * @classdesc  * A layer source for displaying a single, static image.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(options: undefined.ImageStaticOptions): this
        }

        /**
         * 
         * @classdesc  * An image source whose images are canvas elements into which vector features
        read from a vector source (`ol.source.Vector`) are drawn. An
        `ol.source.ImageVector` object is to be used as the `source` of an image
        layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
        as opposed to being re-rendered, during animations and interactions. So, like
        any other image layer, an image layer configured with an
        `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
        vector layer, where vector features are re-drawn during animations and
        interactions.
         * @constructor  * 
         * @extends  {ol.source.ImageCanvas}
         * @param  Options.
         * @api  
        */
        declare class ImageVector mixins undefined.ImageCanvas {

            /**
             * 
             * @classdesc  * An image source whose images are canvas elements into which vector features
            read from a vector source (`ol.source.Vector`) are drawn. An
            `ol.source.ImageVector` object is to be used as the `source` of an image
            layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
            as opposed to being re-rendered, during animations and interactions. So, like
            any other image layer, an image layer configured with an
            `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
            vector layer, where vector features are re-drawn during animations and
            interactions.
             * @constructor  * 
             * @extends  {ol.source.ImageCanvas}
             * @param  Options.
             * @api  
            */
            constructor(options: undefined.ImageVectorOptions): this;

            /**
             * Get a reference to the wrapped source.
             * @return  Source.
             * @api  
             */
            getSource(): undefined.Vector;

            /**
             * Get the style for features.  This returns whatever was passed to the `style`
             * option at construction or to the `setStyle` method.
             * @return  *     Layer style.
             * @api  stable
             */
            getStyle(): (undefined.Style | undefined.Style[] | ol.StyleFunction);

            /**
             * Get the style function.
             * @return  Layer style function.
             * @api  stable
             */
            getStyleFunction(): (ol.StyleFunction);

            /**
             * Set the style for features.  This can be a single style object, an array
             * of styles, or a function that takes a feature and resolution and returns
            an array of styles. If it is `undefined` the default style is used. If
            it is `null` the layer has no style (a `null` style), so only features
            that have their own styles will be rendered in the layer. See
            {style Layer style.
             * @link  ol.style} for information on the default style.
             * @api  stable
            */
            setStyle(style: (undefined.Style | undefined.Style[] | ol.StyleFunction)): void
        }

        /**
         * 
         * @classdesc  * Source for WMS servers providing single, untiled images.
         * @constructor  * 
         * @fires  ol.source.ImageEvent
         * @extends  {ol.source.Image}
         * @param  Options.
         * @api  stable
         */
        declare class ImageWMS mixins undefined.Image {

            /**
             * 
             * @classdesc  * Source for WMS servers providing single, untiled images.
             * @constructor  * 
             * @fires  ol.source.ImageEvent
             * @extends  {ol.source.Image}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.ImageWMSOptions): this;

            /**
             * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
             * projection. Return `undefined` if the GetFeatureInfo URL cannot be
            constructed.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Projection.
             * @param  GetFeatureInfo params. `INFO_FORMAT` at least should
            be provided. If `QUERY_LAYERS` is not provided then the layers specified
            in the `LAYERS` parameter will be used. `VERSION` should not be
            specified here.
             * @return  GetFeatureInfo URL.
             * @api  stable
            */
            getGetFeatureInfoUrl(
                coordinate: ol.Coordinate,
                resolution: number,
                projection: ol.ProjectionLike,
                params: GlobalObject): (string);

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Return the image load function of the source.
             * @return  The image load function.
             * @api  
             */
            getImageLoadFunction(): ol.ImageLoadFunctionType;

            /**
             * Return the URL used for this WMS source.
             * @return  URL.
             * @api  stable
             */
            getUrl(): (string);

            /**
             * Set the image load function of the source.
             * @param  Image load function.
             * @api  
             */
            setImageLoadFunction(imageLoadFunction: ol.ImageLoadFunctionType): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: (string)): void;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Layer source for the OpenStreetMap tile server.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  Open Street Map options.
         * @api  stable
         */
        declare class OSM mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the OpenStreetMap tile server.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  Open Street Map options.
             * @api  stable
             */
            constructor(opt_options?: undefined.OSMOptions): this;

            /**
             * The attribution containing a link to the OpenStreetMap Copyright and License
             * page.
             * @const  * 
             * @type  * 
             * @api  
             */
            ATTRIBUTION: ol.Attribution
        }

        /**
         * 
         * @classdesc  * A source that transforms data from any number of input sources using an array
        of {
         * @link  ol.RasterOperation} functions to transform input pixel values into
        output pixel values.
         * @constructor  * 
         * @extends  {ol.source.Image}
         * @fires  ol.source.RasterEvent
         * @param  Options.
         * @api  
        */
        declare class Raster mixins undefined.Image {

            /**
             * 
             * @classdesc  * A source that transforms data from any number of input sources using an array
            of {
             * @link  ol.RasterOperation} functions to transform input pixel values into
            output pixel values.
             * @constructor  * 
             * @extends  {ol.source.Image}
             * @fires  ol.source.RasterEvent
             * @param  Options.
             * @api  
            */
            constructor(options: undefined.RasterOptions): this;

            /**
             * Set the operation.
             * @param  New operation.
             * @param  Functions that will be available to operations run
            in a worker.
             * @api  
            */
            setOperation(operation: ol.RasterOperation, opt_lib?: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Raster} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.RasterEvent}
         * @param  Type.
         * @param  The frame state.
         * @param  An object made available to operations.
        */
        declare class RasterEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Raster} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.RasterEvent}
             * @param  Type.
             * @param  The frame state.
             * @param  An object made available to operations.
            */
            constructor(type: string, frameState: olx.FrameState, data: GlobalObject): this;

            /**
             * The raster extent.
             * @type  * 
             * @api  
             */
            extent: ol.Extent;

            /**
             * The pixel resolution (map units per pixel).
             * @type  * 
             * @api  
             */
            resolution: number;

            /**
             * An object made available to all operations.  This can be used by operations
             * as a storage object (e.g. for calculating statistics).
             * @type  * 
             * @api  
             */
            data: GlobalObject
        }

        /**
         * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
         * @enum  {string}
         */
        declare type State = string;

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for {
         * @link  ol.layer.Layer} sources.

        A generic `change` event is triggered when the state of the source changes.
         * @constructor  * 
         * @extends  {ol.Object}
         * @param  Source options.
         * @api  stable
        */
        declare class Source mixins ol.Object {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for {
             * @link  ol.layer.Layer} sources.

            A generic `change` event is triggered when the state of the source changes.
             * @constructor  * 
             * @extends  {ol.Object}
             * @param  Source options.
             * @api  stable
            */
            constructor(options: ol.SourceSourceOptions): this;

            /**
             * Get the attributions of the source.
             * @return  Attributions.
             * @api  stable
             */
            getAttributions(): ol.Attribution[];

            /**
             * Get the logo of the source.
             * @return  Logo.
             * @api  stable
             */
            getLogo(): (string | olx.LogoOptions);

            /**
             * Get the projection of the source.
             * @return  Projection.
             * @api  
             */
            getProjection(): undefined.Projection;

            /**
             * Get the state of the source, see {@link ol.source.State} for possible states.
             * @return  State.
             * @api  
             */
            getState(): undefined.State;

            /**
             * Refreshes the source and finally dispatches a 'change' event.
             * @api  
             */
            refresh(): void;

            /**
             * Set the attributions of the source.
             * @param  Attributions.
            Can be passed as `string`, `Array<string>`, `{
             * @link  ol.Attribution}`,
            `Array<{
             * @link  ol.Attribution}>` or `undefined`.
             * @api  
            */
            setAttributions(attributions: (ol.AttributionLike)): void
        }

        /**
         * 
         * @classdesc  * Layer source for the Stamen tile server.
         * @constructor  * 
         * @extends  {ol.source.XYZ}
         * @param  Stamen options.
         * @api  stable
         */
        declare class Stamen mixins undefined.XYZ {

            /**
             * 
             * @classdesc  * Layer source for the Stamen tile server.
             * @constructor  * 
             * @extends  {ol.source.XYZ}
             * @param  Stamen options.
             * @api  stable
             */
            constructor(options: undefined.StamenOptions): this
        }

        /**
         * 
         * @classdesc  * Abstract base class; normally only used for creating subclasses and not
        instantiated in apps.
        Base class for sources providing images divided into a tile grid.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @param  Tile source options.
         * @api  
        */
        declare class Tile mixins undefined.Source {

            /**
             * 
             * @classdesc  * Abstract base class; normally only used for creating subclasses and not
            instantiated in apps.
            Base class for sources providing images divided into a tile grid.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @param  Tile source options.
             * @api  
            */
            constructor(options: ol.SourceTileOptions): this;

            /**
             * Return the tile grid of the tile source.
             * @return  Tile grid.
             * @api  stable
             */
            getTileGrid(): undefined.TileGrid
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Tile} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.TileEvent}
         * @param  Type.
         * @param  The tile.
        */
        declare class TileEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Tile} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.TileEvent}
             * @param  Type.
             * @param  The tile.
            */
            constructor(type: string, tile: ol.Tile): this;

            /**
             * The tile related to the event.
             * @type  * 
             * @api  
             */
            tile: ol.Tile
        }

        /**
         * 
         * @classdesc  * Layer source for tile data from ArcGIS Rest services. Map and Image
        Services are supported.

        For cached ArcGIS services, better performance is available using the
        {
         * @link  ol.source.XYZ} data source.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Tile ArcGIS Rest
        options.
         * @api  
        */
        declare class TileArcGISRest mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from ArcGIS Rest services. Map and Image
            Services are supported.

            For cached ArcGIS services, better performance is available using the
            {
             * @link  ol.source.XYZ} data source.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Tile ArcGIS Rest
            options.
             * @api  
            */
            constructor(opt_options?: undefined.TileArcGISRestOptions): this;

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  
             */
            getParams(): GlobalObject;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * A pseudo tile source, which does not fetch tiles from a server, but renders
        a grid outline for the tile grid/projection along with the coordinates for
        each tile. See examples/canvas-tiles for an example.

        Uses Canvas context2d, so requires Canvas support.
         * @constructor  * 
         * @extends  {ol.source.Tile}
         * @param  Debug tile options.
         * @api  
        */
        declare class TileDebug mixins undefined.Tile {

            /**
             * 
             * @classdesc  * A pseudo tile source, which does not fetch tiles from a server, but renders
            a grid outline for the tile grid/projection along with the coordinates for
            each tile. See examples/canvas-tiles for an example.

            Uses Canvas context2d, so requires Canvas support.
             * @constructor  * 
             * @extends  {ol.source.Tile}
             * @param  Debug tile options.
             * @api  
            */
            constructor(options: undefined.TileDebugOptions): this
        }

        /**
         * 
         * @classdesc  * Base class for sources providing images divided into a tile grid.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.UrlTile}
         * @param  Image tile options.
         * @api  
         */
        declare class TileImage mixins undefined.UrlTile {

            /**
             * 
             * @classdesc  * Base class for sources providing images divided into a tile grid.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.UrlTile}
             * @param  Image tile options.
             * @api  
             */
            constructor(options: undefined.TileImageOptions): this;

            /**
             * Sets whether to render reprojection edges or not (usually for debugging).
             * @param  Render the edges.
             * @api  
             */
            setRenderReprojectionEdges(render: boolean): void;

            /**
             * Sets the tile grid to use when reprojecting the tiles to the given
             * projection instead of the default tile grid for the projection.

            This can be useful when the default tile grid cannot be created
            (e.g. projection has no extent defined) or
            for optimization reasons (custom tile size, resolutions, ...).
             * @param  Projection.
             * @param  Tile grid to use for the projection.
             * @api  
            */
            setTileGridForProjection(projection: ol.ProjectionLike, tilegrid: undefined.TileGrid): void
        }
        declare type TileJSON = JSON;

        /**
         * 
         * @classdesc  * Layer source for UTFGrid interaction data loaded from TileJSON format.
         * @constructor  * 
         * @extends  {ol.source.Tile}
         * @param  Source options.
         * @api  
         */
        declare class TileUTFGrid mixins undefined.Tile {

            /**
             * 
             * @classdesc  * Layer source for UTFGrid interaction data loaded from TileJSON format.
             * @constructor  * 
             * @extends  {ol.source.Tile}
             * @param  Source options.
             * @api  
             */
            constructor(options: undefined.TileUTFGridOptions): this;

            /**
             * Return the template from TileJSON.
             * @return  The template from TileJSON.
             * @api  
             */
            getTemplate(): (string);

            /**
             * Calls the callback (synchronously by default) with the available data
             * for given coordinate and resolution (or `null` if not yet loaded or
            in case of an error).
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Callback.
             * @param  The object to use as `this` in the callback.
             * @param  If `true` the callback is always async.
            The tile data is requested if not yet loaded.
             * @template  * 
             * @api  
            */
            forDataAtCoordinateAndResolution<T>(
                coordinate: ol.Coordinate,
                resolution: number,
                callback: ((d: any) => any),
                opt_this?: T,
                opt_request?: boolean): void
        }

        /**
         * 
         * @classdesc  * Layer source for tile data from WMS servers.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Tile WMS options.
         * @api  stable
         */
        declare class TileWMS mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from WMS servers.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Tile WMS options.
             * @api  stable
             */
            constructor(opt_options?: undefined.TileWMSOptions): this;

            /**
             * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
             * projection. Return `undefined` if the GetFeatureInfo URL cannot be
            constructed.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Projection.
             * @param  GetFeatureInfo params. `INFO_FORMAT` at least should
            be provided. If `QUERY_LAYERS` is not provided then the layers specified
            in the `LAYERS` parameter will be used. `VERSION` should not be
            specified here.
             * @return  GetFeatureInfo URL.
             * @api  stable
            */
            getGetFeatureInfoUrl(
                coordinate: ol.Coordinate,
                resolution: number,
                projection: ol.ProjectionLike,
                params: GlobalObject): (string);

            /**
             * Get the user-provided params, i.e. those passed to the constructor through
             * the "params" option, and possibly updated using the updateParams method.
             * @return  Params.
             * @api  stable
             */
            getParams(): GlobalObject;

            /**
             * Update the user-provided params.
             * @param  Params.
             * @api  stable
             */
            updateParams(params: GlobalObject): void
        }

        /**
         * 
         * @classdesc  * Base class for sources providing tiles divided into a tile grid over http.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.Tile}
         * @param  Image tile options.
         */
        declare class UrlTile mixins undefined.Tile {

            /**
             * 
             * @classdesc  * Base class for sources providing tiles divided into a tile grid over http.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.Tile}
             * @param  Image tile options.
             */
            constructor(options: ol.SourceUrlTileOptions): this;

            /**
             * Return the tile load function of the source.
             * @return  TileLoadFunction
             * @api  
             */
            getTileLoadFunction(): ol.TileLoadFunctionType;

            /**
             * Return the tile URL function of the source.
             * @return  TileUrlFunction
             * @api  
             */
            getTileUrlFunction(): ol.TileUrlFunctionType;

            /**
             * Return the URLs used for this source.
             * When a tileUrlFunction is used instead of url or urls,
            null will be returned.
             * @return  URLs.
             * @api  
            */
            getUrls(): (string[]);

            /**
             * Set the tile load function of the source.
             * @param  Tile load function.
             * @api  
             */
            setTileLoadFunction(tileLoadFunction: ol.TileLoadFunctionType): void;

            /**
             * Set the tile URL function of the source.
             * @param  Tile URL function.
             * @param  Optional new tile key for the source.
             * @api  
             */
            setTileUrlFunction(tileUrlFunction: ol.TileUrlFunctionType, opt_key?: string): void;

            /**
             * Set the URL to use for requests.
             * @param  URL.
             * @api  stable
             */
            setUrl(url: string): void;

            /**
             * Set the URLs to use for requests.
             * @param  URLs.
             * @api  stable
             */
            setUrls(urls: string[]): void
        }

        /**
         * 
         * @classdesc  * Provides a source of features for vector layers. Vector features provided
        by this source are suitable for editing. See {
         * @link  ol.source.VectorTile} for
        vector data that is optimized for rendering.
         * @constructor  * 
         * @extends  {ol.source.Source}
         * @fires  ol.source.VectorEvent
         * @param  Vector source options.
         * @api  stable
        */
        declare class Vector mixins undefined.Source {

            /**
             * 
             * @classdesc  * Provides a source of features for vector layers. Vector features provided
            by this source are suitable for editing. See {
             * @link  ol.source.VectorTile} for
            vector data that is optimized for rendering.
             * @constructor  * 
             * @extends  {ol.source.Source}
             * @fires  ol.source.VectorEvent
             * @param  Vector source options.
             * @api  stable
            */
            constructor(opt_options?: undefined.VectorOptions): this;

            /**
             * Add a single feature to the source.  If you want to add a batch of features
             * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
            instead.
             * @param  Feature to add.
             * @api  stable
            */
            addFeature(feature: ol.Feature): void;

            /**
             * Add a batch of features to the source.
             * @param  Features to add.
             * @api  stable
             */
            addFeatures(features: ol.Feature[]): void;

            /**
             * Remove all features from the source.
             * @param  Skip dispatching of {
             * @link  removefeature} events.
             * @api  stable
             */
            clear(opt_fast?: boolean): void;

            /**
             * Iterate through all features on the source, calling the provided callback
             * with each one.  If the callback returns any "truthy" value, iteration will
            stop and the function will return the same value.
             * @param  Called with each feature
            on the source.  Return a truthy value to stop iteration.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  stable
            */
            forEachFeature<T, S>(callback: ((feature: ol.Feature) => S), opt_this?: T): (S);

            /**
             * Iterate through all features whose bounding box intersects the provided
             * extent (note that the feature's geometry may not intersect the extent),
            calling the callback with each feature.  If the callback returns a "truthy"
            value, iteration will stop and the function will return the same value.

            If you are interested in features whose geometry intersects an extent, call
            the {@link ol.source.Vector#forEachFeatureIntersectingExtent
            source.forEachFeatureIntersectingExtent()} method instead.

            When `useSpatialIndex` is set to false, this method will loop through all
            features, equivalent to {@link ol.source.Vector#forEachFeature}.
             * @param  Extent.
             * @param  Called with each feature
            whose bounding box intersects the provided extent.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  
            */
            forEachFeatureInExtent<T, S>(
                extent: ol.Extent,
                callback: ((feature: ol.Feature) => S),
                opt_this?: T): (S);

            /**
             * Iterate through all features whose geometry intersects the provided extent,
             * calling the callback with each feature.  If the callback returns a "truthy"
            value, iteration will stop and the function will return the same value.

            If you only want to test for bounding box intersection, call the
            {
             * @link  ol.source.Vector#forEachFeatureInExtent
            source.forEachFeatureInExtent()} method instead.
             * @param  Extent.
             * @param  Called with each feature
            whose geometry intersects the provided extent.
             * @param  The object to use as `this` in the callback.
             * @return  The return value from the last call to the callback.
             * @template  * 
             * @api  
            */
            forEachFeatureIntersectingExtent<T, S>(
                extent: ol.Extent,
                callback: ((feature: ol.Feature) => S),
                opt_this?: T): (S);

            /**
             * Get the features collection associated with this source. Will be `null`
             * unless the source was configured with `useSpatialIndex` set to `false`, or
            with an {@link ol.Collection} as `features`.
             * @return  The collection of features.
             * @api  
            */
            getFeaturesCollection(): ol.Collection<ol.Feature>;

            /**
             * Get all features on the source.
             * @return  Features.
             * @api  stable
             */
            getFeatures(): ol.Feature[];

            /**
             * Get all features whose geometry intersects the provided coordinate.
             * @param  Coordinate.
             * @return  Features.
             * @api  stable
             */
            getFeaturesAtCoordinate(coordinate: ol.Coordinate): ol.Feature[];

            /**
             * Get all features in the provided extent.  Note that this returns all features
             * whose bounding boxes intersect the given extent (so it may include features
            whose geometries do not intersect the extent).

            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @param  Extent.
             * @return  Features.
             * @api  
            */
            getFeaturesInExtent(extent: ol.Extent): ol.Feature[];

            /**
             * Get the closest feature to the provided coordinate.
             * 
            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @param  Coordinate.
             * @param  Feature filter function.
            The filter function will receive one argument, the {
             * @link  ol.Feature feature}
            and it should return a boolean value. By default, no filtering is made.
             * @return  Closest feature.
             * @api  stable
            */
            getClosestFeatureToCoordinate(
                coordinate: ol.Coordinate,
                opt_filter?: ((feature: ol.Feature) => boolean)): ol.Feature;

            /**
             * Get the extent of the features currently in the source.
             * 
            This method is not available when the source is configured with
            `useSpatialIndex` set to `false`.
             * @return  Extent.
             * @api  stable
            */
            getExtent(): ol.Extent;

            /**
             * Get a feature by its identifier (the value returned by feature.getId()).
             * Note that the index treats string and numeric identifiers as the same.  So
            `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
             * @param  Feature identifier.
             * @return  The feature (or `null` if not found).
             * @api  stable
            */
            getFeatureById(id: (string | number)): ol.Feature;

            /**
             * Get the format associated with this source.
             * @return  The feature format.
             * @api  
             */
            getFormat(): (undefined.Feature);

            /**
             * Get the url associated with this source.
             * @return  The url.
             * @api  
             */
            getUrl(): (string | ol.FeatureUrlFunction);

            /**
             * Remove a single feature from the source.  If you want to remove all features
             * at once, use the {@link ol.source.Vector#clear source.clear()} method
            instead.
             * @param  Feature to remove.
             * @api  stable
            */
            removeFeature(feature: ol.Feature): void
        }

        /**
         * 
         * @classdesc  * Events emitted by {
         * @link  ol.source.Vector} instances are instances of this
        type.
         * @constructor  * 
         * @extends  {ol.events.Event}
         * @implements  {oli.source.VectorEvent}
         * @param  Type.
         * @param  Feature.
        */
        declare class VectorEvent mixins undefined.Event {

            /**
             * 
             * @classdesc  * Events emitted by {
             * @link  ol.source.Vector} instances are instances of this
            type.
             * @constructor  * 
             * @extends  {ol.events.Event}
             * @implements  {oli.source.VectorEvent}
             * @param  Type.
             * @param  Feature.
            */
            constructor(type: string, opt_feature?: ol.Feature): this;

            /**
             * The feature being added or removed.
             * @type  * 
             * @api  stable
             */
            feature: ol.Feature
        }

        /**
         * 
         * @classdesc  * Class for layer sources providing vector data divided into a tile grid, to be
        used with {
         * @link  ol.layer.VectorTile}. Although this source receives tiles
        with vector features from the server, it is not meant for feature editing.
        Features are optimized for rendering, their geometries are clipped at or near
        tile boundaries and simplified for a view resolution. See
        {
         * @link  ol.source.Vector} for vector sources that are suitable for feature
        editing.
         * @constructor  * 
         * @fires  ol.source.TileEvent
         * @extends  {ol.source.UrlTile}
         * @param  Vector tile options.
         * @api  
        */
        declare class VectorTile mixins undefined.UrlTile {

            /**
             * 
             * @classdesc  * Class for layer sources providing vector data divided into a tile grid, to be
            used with {
             * @link  ol.layer.VectorTile}. Although this source receives tiles
            with vector features from the server, it is not meant for feature editing.
            Features are optimized for rendering, their geometries are clipped at or near
            tile boundaries and simplified for a view resolution. See
            {
             * @link  ol.source.Vector} for vector sources that are suitable for feature
            editing.
             * @constructor  * 
             * @fires  ol.source.TileEvent
             * @extends  {ol.source.UrlTile}
             * @param  Vector tile options.
             * @api  
            */
            constructor(options: undefined.VectorTileOptions): this
        }
        declare module 'wms' {

            /**
             * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
             *      `'qgis'`. These are servers that have vendor parameters beyond the WMS
                 specification that OpenLayers can make use of.
             * @enum  {string}
            */
            declare type ServerType = string;
        }


        /**
         * Request encoding. One of 'KVP', 'REST'.
         * @enum  {string}
         */
        declare type WMTSRequestEncoding = string;

        /**
         * 
         * @classdesc  * Layer source for tile data from WMTS servers.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  WMTS options.
         * @api  stable
         */
        declare class WMTS mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data from WMTS servers.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  WMTS options.
             * @api  stable
             */
            constructor(options: undefined.WMTSOptions): this;

            /**
             * Get the dimensions, i.e. those passed to the constructor through the
             * "dimensions" option, and possibly updated using the updateDimensions
            method.
             * @return  Dimensions.
             * @api  
            */
            getDimensions(): GlobalObject;

            /**
             * Return the image format of the WMTS source.
             * @return  Format.
             * @api  
             */
            getFormat(): string;

            /**
             * Return the layer of the WMTS source.
             * @return  Layer.
             * @api  
             */
            getLayer(): string;

            /**
             * Return the matrix set of the WMTS source.
             * @return  MatrixSet.
             * @api  
             */
            getMatrixSet(): string;

            /**
             * Return the request encoding, either "KVP" or "REST".
             * @return  Request encoding.
             * @api  
             */
            getRequestEncoding(): undefined.WMTSRequestEncoding;

            /**
             * Return the style of the WMTS source.
             * @return  Style.
             * @api  
             */
            getStyle(): string;

            /**
             * Return the version of the WMTS source.
             * @return  Version.
             * @api  
             */
            getVersion(): string;

            /**
             * Update the dimensions.
             * @param  Dimensions.
             * @api  
             */
            updateDimensions(dimensions: GlobalObject): void;

            /**
             * Generate source options from a capabilities object.
             * @param  An object representing the capabilities document.
             * @param  Configuration properties for the layer.  Defaults for
            the layer will apply if not provided.

            Required config properties:
            - layer - {string} The layer identifier.

            Optional config properties:
            - matrixSet - {string} The matrix set identifier, required if there is
            more than one matrix set in the layer capabilities.
            - projection - {string} The desired CRS when no matrixSet is specified.
            eg: "EPSG:3857". If the desired projection is not available,
            an error is thrown.
            - requestEncoding - {string} url encoding format for the layer. Default is
            the first tile url format found in the GetCapabilities response.
            - style - {string} The name of the style
            - format - {string} Image format for the layer. Default is the first
            format returned in the GetCapabilities response.
             * @return  WMTS source options object.
             * @api  
            */
            optionsFromCapabilities(wmtsCap: GlobalObject, config: GlobalObject): undefined.WMTSOptions
        }

        /**
         * 
         * @classdesc  * Layer source for tile data with URLs in a set XYZ format that are
        defined in a URL template. By default, this follows the widely-used
        Google grid where `x` 0 and `y` 0 are in the top left. Grids like
        TMS where `x` 0 and `y` 0 are in the bottom left can be used by
        using the `{-y}` placeholder in the URL template, so long as the
        source does not have a custom tile grid. In this case,
        {
         * @link  ol.source.TileImage} can be used with a `tileUrlFunction`
        such as:

        tileUrlFunction: function(coordinate) {
        return 'http://mapserver.com/' + coordinate[0] + '/' +
        coordinate[1] + '/' + coordinate[2] + '.png';
        }
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  XYZ options.
         * @api  stable
        */
        declare class XYZ mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data with URLs in a set XYZ format that are
            defined in a URL template. By default, this follows the widely-used
            Google grid where `x` 0 and `y` 0 are in the top left. Grids like
            TMS where `x` 0 and `y` 0 are in the bottom left can be used by
            using the `{-y}` placeholder in the URL template, so long as the
            source does not have a custom tile grid. In this case,
            {
             * @link  ol.source.TileImage} can be used with a `tileUrlFunction`
            such as:

            tileUrlFunction: function(coordinate) {
            return 'http://mapserver.com/' + coordinate[0] + '/' +
            coordinate[1] + '/' + coordinate[2] + '.png';
            }
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  XYZ options.
             * @api  stable
            */
            constructor(opt_options?: undefined.XYZOptions): this
        }

        /**
         * 
         * @classdesc  * Layer source for tile data in Zoomify format.
         * @constructor  * 
         * @extends  {ol.source.TileImage}
         * @param  Options.
         * @api  stable
         */
        declare class Zoomify mixins undefined.TileImage {

            /**
             * 
             * @classdesc  * Layer source for tile data in Zoomify format.
             * @constructor  * 
             * @extends  {ol.source.TileImage}
             * @param  Options.
             * @api  stable
             */
            constructor(opt_options?: undefined.ZoomifyOptions): this
        }

        /**
         * 
         * @typedef  *     culture: (string|undefined),
        key: string,
        imagerySet: string,
        maxZoom: (number|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface BingMapsOptions {
            cacheSize?: number,
                culture?: string,
                key: string,
                imagerySet: string,
                maxZoom?: number,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     distance: (number|undefined),
        extent: (ol.Extent|undefined),
        format: (ol.format.Feature|undefined),
        geometryFunction: (undefined|function(ol.Feature):ol.geom.Point),
        logo: (string|undefined),
        projection: ol.ProjectionLike,
        source: ol.source.Vector,
        wrapX: (boolean|undefined)}}
        */
        declare interface ClusterOptions {
            attributions?: ol.AttributionLike,
                distance?: number,
                extent?: ol.Extent,
                geometryFunction?: ((feature: ol.Feature) => undefined.Point),
                format?: undefined.Feature,
                logo?: string,
                projection?: ol.ProjectionLike,
                source: undefined.Vector,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     jsonp: (boolean|undefined),
        tileJSON: (TileJSON|undefined),
        url: (string|undefined)}}
        */
        declare interface TileUTFGridOptions {
            jsonp?: boolean,
                preemptive?: boolean,
                tileJSON?: TileJSON,
                url?: string
        }

        /**
         * 
         * @typedef  *            cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        state: (ol.source.State|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileImageOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                state?: undefined.State,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     map: (ol.Map|undefined),
        minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        renderMode: (ol.layer.VectorTileRenderType|string|undefined),
        renderOrder: (function(ol.Feature, ol.Feature):number|undefined),
        source: (ol.source.VectorTile|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorTileOptions {
            renderBuffer?: number,
                renderMode?: (undefined.VectorTileRenderType | string),
                renderOrder: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                source?: undefined.VectorTile,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     displayDpi: (number|undefined),
        metersPerUnit: (number|undefined),
        hidpi: (boolean|undefined),
        useOverlay: (boolean|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: (Object|undefined)}}
        */
        declare interface ImageMapGuideOptions {
            url?: string,
                displayDpi?: number,
                metersPerUnit?: number,
                hidpi?: boolean,
                useOverlay?: boolean,
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                imageLoadFunction?: ol.ImageLoadFunctionType,
                params?: GlobalObject
        }

        /**
         * 
         * @typedef  *     layer: string,
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined)}}
        */
        declare interface MapQuestOptions {
            cacheSize?: number,
                layer: string,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string
        }

        /**
         * 
         * @typedef  *     tileGrid: (ol.tilegrid.TileGrid|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileDebugOptions {
            projection: ol.ProjectionLike,
                tileGrid?: undefined.TileGrid,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        maxZoom: (number|undefined),
        opaque: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface OSMOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                maxZoom?: number,
                opaque?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: Object.<string,*>,
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        url: (string|undefined)}}
        */
        declare interface ImageArcGISRestOptions {
            attributions?: ol.Attribution[],
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                imageLoadFunction?: ol.ImageLoadFunctionType,
                params?: {
                    [k: string]: any
                },
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                url?: string
        }

        /**
         * 
         * @typedef  *     canvasFunction: ol.CanvasFunctionType,
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        state: (ol.source.State|undefined)}}
        */
        declare interface ImageCanvasOptions {
            attributions?: ol.AttributionLike,
                canvasFunction: ol.CanvasFunctionType,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                state?: undefined.State
        }

        /**
         * 
         * @typedef  *     logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        renderBuffer: (number|undefined),
        resolutions: (Array.<number>|undefined),
        source: ol.source.Vector,
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined)}}
        */
        declare interface ImageVectorOptions {
            attributions?: ol.AttributionLike,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                ratio?: number,
                renderBuffer?: number,
                resolutions?: number[],
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction)
        }

        /**
         * 
         * @typedef  *     operation: (ol.RasterOperation|undefined),
        lib: (Object|undefined),
        threads: (number|undefined),
        operationType: (ol.RasterOperationType|undefined)}}
         * @api  
        */
        declare interface RasterOptions {
            sources: undefined.Source[],
                operation?: ol.RasterOperation,
                lib?: GlobalObject,
                threads?: number,
                operationType?: ol.RasterOperationType
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        hidpi: (boolean|undefined),
        serverType: (ol.source.wms.ServerType|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        params: Object.<string,*>,
        projection: ol.ProjectionLike,
        ratio: (number|undefined),
        resolutions: (Array.<number>|undefined),
        url: (string|undefined)}}
        */
        declare interface ImageWMSOptions {
            attributions?: ol.AttributionLike,
                crossOrigin?: (string),
                hidpi?: boolean,
                serverType?: (undefined.ServerType | string),
                imageLoadFunction?: ol.ImageLoadFunctionType,
                logo?: (string | olx.LogoOptions),
                params: {
                    [k: string]: any
                },
                projection: ol.ProjectionLike,
                ratio?: number,
                resolutions?: number[],
                url?: string
        }

        /**
         * 
         * @typedef  *     layer: string,
        minZoom: (number|undefined),
        maxZoom: (number|undefined),
        opaque: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined)}}
        */
        declare interface StamenOptions {
            cacheSize?: number,
                layer: string,
                minZoom?: number,
                maxZoom?: number,
                opaque?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string
        }

        /**
         * 
         * @typedef  *     crossOrigin: (null|string|undefined),
        imageExtent: (ol.Extent),
        imageLoadFunction: (ol.ImageLoadFunctionType|undefined),
        imageSize: (ol.Size|undefined),
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        url: string}}
        */
        declare interface ImageStaticOptions {
            attributions?: ol.AttributionLike,
                crossOrigin?: (string),
                imageExtent: ol.Extent,
                imageLoadFunction?: ol.ImageLoadFunctionType,
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                imageSize?: ol.Size,
                url: string
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        params: (Object.<string, *>|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileArcGISRestOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                params?: {
                    [k: string]: any
                },
                logo?: (string | olx.LogoOptions),
                tileGrid?: undefined.TileGrid,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                wrapX?: boolean,
                urls?: string[]
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        jsonp: (boolean|undefined),
        reprojectionErrorThreshold: (number|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: string,
        wrapX: (boolean|undefined)}}
        */
        declare interface TileJSONOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                jsonp?: boolean,
                reprojectionErrorThreshold?: number,
                tileLoadFunction?: ol.TileLoadFunctionType,
                url: string,
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        params: Object.<string,*>,
        crossOrigin: (null|string|undefined),
        gutter: (number|undefined),
        hidpi: (boolean|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        serverType: (ol.source.wms.ServerType|string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface TileWMSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                params: {
                    [k: string]: any
                },
                crossOrigin?: (string),
                gutter?: number,
                hidpi?: boolean,
                logo?: (string | olx.LogoOptions),
                tileGrid?: undefined.TileGrid,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                serverType?: (undefined.ServerType | string),
                tileLoadFunction?: ol.TileLoadFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     minResolution: (number|undefined),
        maxResolution: (number|undefined),
        opacity: (number|undefined),
        renderBuffer: (number|undefined),
        source: (ol.source.Vector|undefined),
        map: (ol.Map|undefined),
        style: (ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|undefined),
        updateWhileAnimating: (boolean|undefined),
        updateWhileInteracting: (boolean|undefined),
        visible: (boolean|undefined)}}
        */
        declare interface VectorOptions {
            renderOrder?: (feature1: ol.Feature, feature2: ol.Feature) => number,
                map?: ol.Map,
                extent?: ol.Extent,
                minResolution?: number,
                maxResolution?: number,
                opacity?: number,
                renderBuffer?: number,
                source: undefined.Vector,
                style?: (undefined.Style | undefined.Style[] | ol.StyleFunction),
                updateWhileAnimating?: boolean,
                updateWhileInteracting?: boolean,
                visible?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (string|null|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: ol.tilegrid.WMTS,
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        requestEncoding: (ol.source.WMTSRequestEncoding|string|undefined),
        layer: string,
        style: string,
        tilePixelRatio: (number|undefined),
        version: (string|undefined),
        format: (string|undefined),
        matrixSet: string,
        dimensions: (!Object|undefined),
        url: (string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        urls: (Array.<string>|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface WMTSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                tileGrid: undefined.WMTS,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                requestEncoding?: (undefined.WMTSRequestEncoding | string),
                layer: string,
                style: string,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tilePixelRatio?: number,
                version?: string,
                format?: string,
                matrixSet: string,
                dimensions?: GlobalObject,
                url?: string,
                tileLoadFunction?: ol.TileLoadFunctionType,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileSize: (number|ol.Size|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface XYZOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                maxZoom?: number,
                minZoom?: number,
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileSize?: (number | ol.Size),
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        projection: ol.ProjectionLike,
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        wrapX: (boolean|undefined),
        config: (Object|undefined),
        map: (string|undefined),
        account: string}}
        */
        declare interface CartoDBOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                projection: ol.ProjectionLike,
                maxZoom?: number,
                minZoom?: number,
                wrapX?: boolean,
                config?: GlobalObject,
                map?: string,
                account: string
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        reprojectionErrorThreshold: (number|undefined),
        url: !string,
        tierSizeCalculation: (string|undefined),
        size: ol.Size}}
        */
        declare interface ZoomifyOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                reprojectionErrorThreshold?: number,
                url: string,
                tierSizeCalculation?: string,
                size: ol.Size
        }
    }

    declare module 'style' {

        /**
         * Manages the creation of image atlases.
         * 
        Images added to this manager will be inserted into an atlas, which
        will be used for rendering.
        The `size` given in the constructor is the size for the first
        atlas. After that, when new atlases are created, they will have
        twice the size as the latest atlas (until `maxSize` is reached).

        If an application uses many images or very large images, it is recommended
        to set a higher `size` value to avoid the creation of too many atlases.
         * @constructor  * 
         * @struct  * 
         * @api  * 
         * @param  Options.
        */
        declare class AtlasManager {

            /**
             * Manages the creation of image atlases.
             * 
            Images added to this manager will be inserted into an atlas, which
            will be used for rendering.
            The `size` given in the constructor is the size for the first
            atlas. After that, when new atlases are created, they will have
            twice the size as the latest atlas (until `maxSize` is reached).

            If an application uses many images or very large images, it is recommended
            to set a higher `size` value to avoid the creation of too many atlases.
             * @constructor  * 
             * @struct  * 
             * @api  * 
             * @param  Options.
            */
            constructor(opt_options?: undefined.AtlasManagerOptions): this
        }

        /**
         * 
         * @classdesc  * Set circle style for vector features.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
         */
        declare class Circle mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set circle style for vector features.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
             */
            constructor(opt_options?: undefined.CircleOptions): this;

            /**
             * Get the fill style for the circle.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Get the image used to render the circle.
             * @param  Pixel ratio.
             * @return  Canvas element.
             * @api  
             */
            getImage(pixelRatio: number): HTMLCanvasElement;

            /**
             * Get the circle radius.
             * @return  Radius.
             * @api  
             */
            getRadius(): number;

            /**
             * Get the stroke style for the circle.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke
        }

        /**
         * 
         * @classdesc  * Set fill style for vector features.
         * @constructor  * 
         * @param  Options.
         * @api  
         */
        declare class Fill {

            /**
             * 
             * @classdesc  * Set fill style for vector features.
             * @constructor  * 
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.FillOptions): this;

            /**
             * Get the fill color.
             * @return  Color.
             * @api  
             */
            getColor(): (ol.Color | ol.ColorLike);

            /**
             * Set the color.
             * @param  Color.
             * @api  
             */
            setColor(color: (ol.Color | ol.ColorLike)): void
        }

        /**
         * Icon anchor units. One of 'fraction', 'pixels'.
         * @enum  {string}
         */
        declare type IconAnchorUnits = string;

        /**
         * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
         * @enum  {string}
         */
        declare type IconOrigin = string;

        /**
         * 
         * @classdesc  * Set icon style for vector features.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
         */
        declare class Icon mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set icon style for vector features.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
             */
            constructor(opt_options?: undefined.IconOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getAnchor(): number[];

            /**
             * Get the image icon.
             * @param  Pixel ratio.
             * @return  Image or Canvas element.
             * @api  
             */
            getImage(pixelRatio: number): (Image | HTMLCanvasElement);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getOrigin(): number[];

            /**
             * Get the image URL.
             * @return  Image src.
             * @api  
             */
            getSrc(): (string);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getSize(): ol.Size;

            /**
             * Load not yet loaded URI.
             * When rendering a feature with an icon style, the vector renderer will
            automatically call this method. However, you might want to call this
            method yourself for preloading or other purposes.
             * @api  
            */
            load(): void
        }

        /**
         * 
         * @classdesc  * A base class used for creating subclasses and not instantiated in
        apps. Base class for {
         * @link  ol.style.Icon}, {
         * @link  ol.style.Circle} and
        {
         * @link  ol.style.RegularShape}.
         * @constructor  * 
         * @param  Options.
         * @api  
        */
        declare class Image {

            /**
             * 
             * @classdesc  * A base class used for creating subclasses and not instantiated in
            apps. Base class for {
             * @link  ol.style.Icon}, {
             * @link  ol.style.Circle} and
            {
             * @link  ol.style.RegularShape}.
             * @constructor  * 
             * @param  Options.
             * @api  
            */
            constructor(options: ol.StyleImageOptions): this;

            /**
             * Get the symbolizer opacity.
             * @return  Opacity.
             * @api  
             */
            getOpacity(): number;

            /**
             * Determine whether the symbolizer rotates with the map.
             * @return  Rotate with map.
             * @api  
             */
            getRotateWithView(): boolean;

            /**
             * Get the symoblizer rotation.
             * @return  Rotation.
             * @api  
             */
            getRotation(): number;

            /**
             * Get the symbolizer scale.
             * @return  Scale.
             * @api  
             */
            getScale(): number;

            /**
             * Determine whether the symbolizer should be snapped to a pixel.
             * @return  The symbolizer should snap to a pixel.
             * @api  
             */
            getSnapToPixel(): boolean;

            /**
             * Set the opacity.
             * @param  Opacity.
             * @api  
             */
            setOpacity(opacity: number): void;

            /**
             * Set the rotation.
             * @param  Rotation.
             * @api  
             */
            setRotation(rotation: number): void;

            /**
             * Set the scale.
             * @param  Scale.
             * @api  
             */
            setScale(scale: number): void
        }

        /**
         * 
         * @classdesc  * Set regular shape style for vector features. The resulting shape will be
        a regular polygon when `radius` is provided, or a star when `radius1` and
        `radius2` are provided.
         * @constructor  * 
         * @param  Options.
         * @extends  {ol.style.Image}
         * @api  
        */
        declare class RegularShape mixins undefined.Image {

            /**
             * 
             * @classdesc  * Set regular shape style for vector features. The resulting shape will be
            a regular polygon when `radius` is provided, or a star when `radius1` and
            `radius2` are provided.
             * @constructor  * 
             * @param  Options.
             * @extends  {ol.style.Image}
             * @api  
            */
            constructor(options: undefined.RegularShapeOptions): this;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getAnchor(): number[];

            /**
             * Get the angle used in generating the shape.
             * @return  Shape's rotation in radians.
             * @api  
             */
            getAngle(): number;

            /**
             * Get the fill style for the shape.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getImage(pixelRatio: number): (HTMLCanvasElement | HTMLVideoElement | Image);

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getOrigin(): number[];

            /**
             * Get the number of points for generating the shape.
             * @return  Number of points for stars and regular polygons.
             * @api  
             */
            getPoints(): number;

            /**
             * Get the (primary) radius for the shape.
             * @return  Radius.
             * @api  
             */
            getRadius(): number;

            /**
             * Get the secondary radius for the shape.
             * @return  Radius2.
             * @api  
             */
            getRadius2(): number;

            /**
             * 
             * @inheritDoc  * 
             * @api  
             */
            getSize(): ol.Size;

            /**
             * Get the stroke style for the shape.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke
        }

        /**
         * 
         * @classdesc  * Set stroke style for vector features.
        Note that the defaults given are the Canvas defaults, which will be used if
        option is not defined. The `get` functions return whatever was entered in
        the options; they will not return the default.
         * @constructor  * 
         * @param  Options.
         * @api  
        */
        declare class Stroke {

            /**
             * 
             * @classdesc  * Set stroke style for vector features.
            Note that the defaults given are the Canvas defaults, which will be used if
            option is not defined. The `get` functions return whatever was entered in
            the options; they will not return the default.
             * @constructor  * 
             * @param  Options.
             * @api  
            */
            constructor(opt_options?: undefined.StrokeOptions): this;

            /**
             * Get the stroke color.
             * @return  Color.
             * @api  
             */
            getColor(): (ol.Color | string);

            /**
             * Get the line cap type for the stroke.
             * @return  Line cap.
             * @api  
             */
            getLineCap(): (string);

            /**
             * Get the line dash style for the stroke.
             * @return  Line dash.
             * @api  
             */
            getLineDash(): number[];

            /**
             * Get the line join type for the stroke.
             * @return  Line join.
             * @api  
             */
            getLineJoin(): (string);

            /**
             * Get the miter limit for the stroke.
             * @return  Miter limit.
             * @api  
             */
            getMiterLimit(): (number);

            /**
             * Get the stroke width.
             * @return  Width.
             * @api  
             */
            getWidth(): (number);

            /**
             * Set the color.
             * @param  Color.
             * @api  
             */
            setColor(color: (ol.Color | string)): void;

            /**
             * Set the line cap.
             * @param  Line cap.
             * @api  
             */
            setLineCap(lineCap: (string)): void;

            /**
             * Set the line dash.
             * 
            Please note that Internet Explorer 10 and lower [do not support][mdn] the
            `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
            property will have no visual effect in these browsers.

            [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
             * @param  Line dash.
             * @api  
            */
            setLineDash(lineDash: number[]): void;

            /**
             * Set the line join.
             * @param  Line join.
             * @api  
             */
            setLineJoin(lineJoin: (string)): void;

            /**
             * Set the miter limit.
             * @param  Miter limit.
             * @api  
             */
            setMiterLimit(miterLimit: (number)): void;

            /**
             * Set the width.
             * @param  Width.
             * @api  
             */
            setWidth(width: (number)): void
        }

        /**
         * 
         * @classdesc  * Container for vector feature rendering styles. Any changes made to the style
        or its children through `set*()` methods will not take effect until the
        feature or layer that uses the style is re-rendered.
         * @constructor  * 
         * @struct  * 
         * @param  Style options.
         * @api  
        */
        declare class Style {

            /**
             * 
             * @classdesc  * Container for vector feature rendering styles. Any changes made to the style
            or its children through `set*()` methods will not take effect until the
            feature or layer that uses the style is re-rendered.
             * @constructor  * 
             * @struct  * 
             * @param  Style options.
             * @api  
            */
            constructor(opt_options?: undefined.StyleOptions): this;

            /**
             * Get the geometry to be rendered.
             * @return  * Feature property or geometry or function that returns the geometry that will
            be rendered with this style.
             * @api  
            */
            getGeometry(): (string | undefined.Geometry | ol.StyleGeometryFunction);

            /**
             * Get the function used to generate a geometry for rendering.
             * @return  Function that is called with a feature
            and returns the geometry to render instead of the feature's geometry.
             * @api  
            */
            getGeometryFunction(): ol.StyleGeometryFunction;

            /**
             * Get the fill style.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Get the image style.
             * @return  Image style.
             * @api  
             */
            getImage(): undefined.Image;

            /**
             * Get the stroke style.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke;

            /**
             * Get the text style.
             * @return  Text style.
             * @api  
             */
            getText(): undefined.Text;

            /**
             * Get the z-index for the style.
             * @return  ZIndex.
             * @api  
             */
            getZIndex(): (number);

            /**
             * Set a geometry that is rendered instead of the feature's geometry.
             * @param  Feature property or geometry or function returning a geometry to render
            for this style.
             * @api  
            */
            setGeometry(geometry: (string | undefined.Geometry | ol.StyleGeometryFunction)): void;

            /**
             * Set the z-index.
             * @param  ZIndex.
             * @api  
             */
            setZIndex(zIndex: (number)): void
        }

        /**
         * 
         * @classdesc  * Set text style for vector features.
         * @constructor  * 
         * @param  Options.
         * @api  
         */
        declare class Text {

            /**
             * 
             * @classdesc  * Set text style for vector features.
             * @constructor  * 
             * @param  Options.
             * @api  
             */
            constructor(opt_options?: undefined.TextOptions): this;

            /**
             * Get the font name.
             * @return  Font.
             * @api  
             */
            getFont(): (string);

            /**
             * Get the x-offset for the text.
             * @return  Horizontal text offset.
             * @api  
             */
            getOffsetX(): number;

            /**
             * Get the y-offset for the text.
             * @return  Vertical text offset.
             * @api  
             */
            getOffsetY(): number;

            /**
             * Get the fill style for the text.
             * @return  Fill style.
             * @api  
             */
            getFill(): undefined.Fill;

            /**
             * Determine whether the text rotates with the map.
             * @return  Rotate with map.
             * @api  
             */
            getRotateWithView(): (boolean);

            /**
             * Get the text rotation.
             * @return  Rotation.
             * @api  
             */
            getRotation(): (number);

            /**
             * Get the text scale.
             * @return  Scale.
             * @api  
             */
            getScale(): (number);

            /**
             * Get the stroke style for the text.
             * @return  Stroke style.
             * @api  
             */
            getStroke(): undefined.Stroke;

            /**
             * Get the text to be rendered.
             * @return  Text.
             * @api  
             */
            getText(): (string);

            /**
             * Get the text alignment.
             * @return  Text align.
             * @api  
             */
            getTextAlign(): (string);

            /**
             * Get the text baseline.
             * @return  Text baseline.
             * @api  
             */
            getTextBaseline(): (string);

            /**
             * Set the font.
             * @param  Font.
             * @api  
             */
            setFont(font: (string)): void;

            /**
             * Set the x offset.
             * @param  Horizontal text offset.
             * @api  
             */
            setOffsetX(offsetX: number): void;

            /**
             * Set the y offset.
             * @param  Vertical text offset.
             * @api  
             */
            setOffsetY(offsetY: number): void;

            /**
             * Set the fill.
             * @param  Fill style.
             * @api  
             */
            setFill(fill: undefined.Fill): void;

            /**
             * Set the rotation.
             * @param  Rotation.
             * @api  
             */
            setRotation(rotation: (number)): void;

            /**
             * Set the scale.
             * @param  Scale.
             * @api  
             */
            setScale(scale: (number)): void;

            /**
             * Set the stroke.
             * @param  Stroke style.
             * @api  
             */
            setStroke(stroke: undefined.Stroke): void;

            /**
             * Set the text.
             * @param  Text.
             * @api  
             */
            setText(text: (string)): void;

            /**
             * Set the text alignment.
             * @param  Text align.
             * @api  
             */
            setTextAlign(textAlign: (string)): void;

            /**
             * Set the text baseline.
             * @param  Text baseline.
             * @api  
             */
            setTextBaseline(textBaseline: (string)): void
        }

        /**
         * 
         * @typedef  *     radius: number,
        snapToPixel: (boolean|undefined),
        stroke: (ol.style.Stroke|undefined),
        atlasManager: (ol.style.AtlasManager|undefined)}}
        */
        declare interface CircleOptions {
            fill?: undefined.Fill,
                radius: number,
                snapToPixel?: boolean,
                stroke?: undefined.Stroke,
                atlasManager?: undefined.AtlasManager
        }

        /**
         * 
         * @typedef  
         */
        declare interface FillOptions {
            color?: (ol.Color | ol.ColorLike)
        }

        /**
         * 
         * @typedef  *     anchorOrigin: (ol.style.IconOrigin|undefined),
        anchorXUnits: (ol.style.IconAnchorUnits|undefined),
        anchorYUnits: (ol.style.IconAnchorUnits|undefined),
        color: (ol.Color|string|undefined),
        crossOrigin: (null|string|undefined),
        img: (Image|HTMLCanvasElement|undefined),
        offset: (Array.<number>|undefined),
        offsetOrigin: (ol.style.IconOrigin|undefined),
        opacity: (number|undefined),
        scale: (number|undefined),
        snapToPixel: (boolean|undefined),
        rotateWithView: (boolean|undefined),
        rotation: (number|undefined),
        size: (ol.Size|undefined),
        imgSize: (ol.Size|undefined),
        src: (string|undefined)}}
        */
        declare interface IconOptions {
            anchor?: number[],
                anchorOrigin?: undefined.IconOrigin,
                anchorXUnits?: undefined.IconAnchorUnits,
                anchorYUnits?: undefined.IconAnchorUnits,
                color?: (ol.Color | string),
                crossOrigin?: (string),
                img?: (any | HTMLCanvasElement),
                offset?: number[],
                offsetOrigin?: undefined.IconOrigin,
                opacity?: number,
                scale?: number,
                snapToPixel?: boolean,
                rotateWithView?: boolean,
                rotation?: number,
                size?: ol.Size,
                imgSize?: ol.Size,
                src: string
        }

        /**
         * Specify radius for regular polygons, or radius1 and radius2 for stars.
         * @typedef  *     points: number,
        radius: (number|undefined),
        radius1: (number|undefined),
        radius2: (number|undefined),
        angle: (number|undefined),
        snapToPixel: (boolean|undefined),
        stroke: (ol.style.Stroke|undefined),
        rotation: (number|undefined),
        rotateWithView: (boolean|undefined),
        atlasManager: (ol.style.AtlasManager|undefined)}}
        */
        declare interface RegularShapeOptions {
            fill?: undefined.Fill,
                points: number,
                radius?: number,
                radius1?: number,
                radius2?: number,
                angle?: number,
                snapToPixel?: boolean,
                stroke?: undefined.Stroke
        }

        /**
         * 
         * @typedef  *     lineCap: (string|undefined),
        lineJoin: (string|undefined),
        lineDash: (Array.<number>|undefined),
        miterLimit: (number|undefined),
        width: (number|undefined)}}
        */
        declare interface StrokeOptions {
            color?: ol.Color | string,
                lineCap?: string,
                lineJoin?: string,
                lineDash?: number[],
                miterLimit?: number,
                width?: number
        }

        /**
         * 
         * @typedef  *     offsetX: (number|undefined),
        offsetY: (number|undefined),
        scale: (number|undefined),
        rotateWithView: (boolean|undefined),
        rotation: (number|undefined),
        text: (string|undefined),
        textAlign: (string|undefined),
        textBaseline: (string|undefined),
        fill: (ol.style.Fill|undefined),
        stroke: (ol.style.Stroke|undefined)}}
        */
        declare interface TextOptions {
            font?: string,
                offsetX?: number,
                offsetY?: number,
                scale?: number,
                rotation?: number,
                text?: string,
                textAlign?: string,
                textBaseline?: string,
                fill?: undefined.Fill,
                stroke?: undefined.Stroke
        }

        /**
         * 
         * @typedef  *     fill: (ol.style.Fill|undefined),
        image: (ol.style.Image|undefined),
        stroke: (ol.style.Stroke|undefined),
        text: (ol.style.Text|undefined),
        zIndex: (number|undefined)}}
        */
        declare interface StyleOptions {
            geometry?: (string | undefined.Geometry | ol.StyleGeometryFunction),
                fill?: undefined.Fill,
                image?: undefined.Image,
                stroke?: undefined.Stroke,
                text?: undefined.Text,
                zIndex?: number
        }

        /**
         * 
         * @typedef  *     maxSize: (number|undefined),
        space: (number|undefined)}}
        */
        declare interface AtlasManagerOptions {
            initialSize?: number,
                maxSize?: number,
                space?: number
        }
    }

    declare module 'tilegrid' {

        /**
         * Creates a tile grid with a standard XYZ tiling scheme.
         * @param  Tile grid options.
         * @return  Tile grid instance.
         * @api  
         */
        declare     function createXYZ(opt_options?: undefined.XYZOptions): undefined.TileGrid

        /**
         * 
         * @classdesc  * Base class for setting the grid pattern for sources accessing tiled-image
        servers.
         * @constructor  * 
         * @param  Tile grid options.
         * @struct  * 
         * @api  stable
        */
        declare class TileGrid {

            /**
             * 
             * @classdesc  * Base class for setting the grid pattern for sources accessing tiled-image
            servers.
             * @constructor  * 
             * @param  Tile grid options.
             * @struct  * 
             * @api  stable
            */
            constructor(options: undefined.TileGridOptions): this;

            /**
             * Call a function with each tile coordinate for a given extent and zoom level.
             * @param  Extent.
             * @param  Zoom level.
             * @param  Function called with each tile coordinate.
             * @api  
             */
            forEachTileCoord(
                extent: ol.Extent,
                zoom: number,
                callback: ((coords: ol.TileCoord) => any)): void;

            /**
             * Get the maximum zoom level for the grid.
             * @return  Max zoom.
             * @api  
             */
            getMaxZoom(): number;

            /**
             * Get the minimum zoom level for the grid.
             * @return  Min zoom.
             * @api  
             */
            getMinZoom(): number;

            /**
             * Get the origin for the grid at the given zoom level.
             * @param  Z.
             * @return  Origin.
             * @api  stable
             */
            getOrigin(z: number): ol.Coordinate;

            /**
             * Get the resolution for the given zoom level.
             * @param  Z.
             * @return  Resolution.
             * @api  stable
             */
            getResolution(z: number): number;

            /**
             * Get the list of resolutions for the tile grid.
             * @return  Resolutions.
             * @api  stable
             */
            getResolutions(): number[];

            /**
             * Get the extent of a tile coordinate.
             * @param  Tile coordinate.
             * @param  Temporary extent object.
             * @return  Extent.
             * @api  
             */
            getTileCoordExtent(tileCoord: ol.TileCoord, opt_extent?: ol.Extent): ol.Extent;

            /**
             * Get the tile coordinate for the given map coordinate and resolution.  This
             * method considers that coordinates that intersect tile boundaries should be
            assigned the higher tile coordinate.
             * @param  Coordinate.
             * @param  Resolution.
             * @param  Destination ol.TileCoord object.
             * @return  Tile coordinate.
             * @api  
            */
            getTileCoordForCoordAndResolution(
                coordinate: ol.Coordinate,
                resolution: number,
                opt_tileCoord?: ol.TileCoord): ol.TileCoord;

            /**
             * Get a tile coordinate given a map coordinate and zoom level.
             * @param  Coordinate.
             * @param  Zoom level.
             * @param  Destination ol.TileCoord object.
             * @return  Tile coordinate.
             * @api  
             */
            getTileCoordForCoordAndZ(
                coordinate: ol.Coordinate,
                z: number,
                opt_tileCoord?: ol.TileCoord): ol.TileCoord;

            /**
             * Get the tile size for a zoom level. The type of the return value matches the
             * `tileSize` or `tileSizes` that the tile grid was configured with. To always
            get an `ol.Size`, run the result through `ol.size.toSize()`.
             * @param  Z.
             * @return  Tile size.
             * @api  stable
            */
            getTileSize(z: number): (number | ol.Size);

            /**
             * 
             * @param  Resolution.
             * @param  If 0, the nearest resolution will be used.
            If 1, the nearest lower resolution will be used. If -1, the nearest
            higher resolution will be used. Default is 0.
             * @return  Z.
             * @api  
            */
            getZForResolution(resolution: number, opt_direction?: number): number
        }

        /**
         * 
         * @classdesc  * Set the grid pattern for sources accessing WMTS tiled-image servers.
         * @constructor  * 
         * @extends  {ol.tilegrid.TileGrid}
         * @param  WMTS options.
         * @struct  * 
         * @api  
         */
        declare class WMTS mixins undefined.TileGrid {

            /**
             * 
             * @classdesc  * Set the grid pattern for sources accessing WMTS tiled-image servers.
             * @constructor  * 
             * @extends  {ol.tilegrid.TileGrid}
             * @param  WMTS options.
             * @struct  * 
             * @api  
             */
            constructor(options: undefined.WMTSOptions): this;

            /**
             * Get the list of matrix identifiers.
             * @return  MatrixIds.
             * @api  
             */
            getMatrixIds(): string[];

            /**
             * Create a tile grid from a WMTS capabilities matrix set.
             * @param  An object representing a matrixSet in the
            capabilities document.
             * @param  An optional extent to restrict the tile
            ranges the server provides.
             * @return  WMTS tileGrid instance.
             * @api  
            */
            createFromCapabilitiesMatrixSet(matrixSet: GlobalObject, opt_extent?: ol.Extent): undefined.WMTS
        }

        /**
         * 
         * @typedef  *     minZoom: (number|undefined),
        origin: (ol.Coordinate|undefined),
        origins: (Array.<ol.Coordinate>|undefined),
        resolutions: !Array.<number>,
        sizes: (Array.<ol.Size>|undefined),
        tileSize: (number|ol.Size|undefined),
        tileSizes: (Array.<number|ol.Size>|undefined)}}
        */
        declare interface TileGridOptions {
            extent?: ol.Extent,
                minZoom?: number,
                origin?: ol.Coordinate,
                origins?: ol.Coordinate[],
                resolutions: number[],
                tileSize?: (number | ol.Size),
                tileSizes?: ((number | ol.Size)[])
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (string|null|undefined),
        logo: (string|olx.LogoOptions|undefined),
        tileGrid: ol.tilegrid.WMTS,
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        requestEncoding: (ol.source.WMTSRequestEncoding|string|undefined),
        layer: string,
        style: string,
        tilePixelRatio: (number|undefined),
        version: (string|undefined),
        format: (string|undefined),
        matrixSet: string,
        dimensions: (!Object|undefined),
        url: (string|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        urls: (Array.<string>|undefined),
        tileClass: (function(new: ol.ImageTile, ol.TileCoord,
        ol.Tile.State, string, ?string,
        ol.TileLoadFunctionType)|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface WMTSOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                tileGrid: undefined.WMTS,
                projection: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                requestEncoding?: (undefined.WMTSRequestEncoding | string),
                layer: string,
                style: string,
                tileClass?: ((
                    n: ol.ImageTile,
                    coords: ol.TileCoord,
                    state: undefined.State,
                    s1: string,
                    s2: string,
                    type: ol.TileLoadFunctionType) => any),
                tilePixelRatio?: number,
                version?: string,
                format?: string,
                matrixSet: string,
                dimensions?: GlobalObject,
                url?: string,
                tileLoadFunction?: ol.TileLoadFunctionType,
                urls?: string[],
                wrapX?: boolean
        }

        /**
         * 
         * @typedef  *     cacheSize: (number|undefined),
        crossOrigin: (null|string|undefined),
        logo: (string|olx.LogoOptions|undefined),
        opaque: (boolean|undefined),
        projection: ol.ProjectionLike,
        reprojectionErrorThreshold: (number|undefined),
        maxZoom: (number|undefined),
        minZoom: (number|undefined),
        tileGrid: (ol.tilegrid.TileGrid|undefined),
        tileLoadFunction: (ol.TileLoadFunctionType|undefined),
        tilePixelRatio: (number|undefined),
        tileSize: (number|ol.Size|undefined),
        tileUrlFunction: (ol.TileUrlFunctionType|undefined),
        url: (string|undefined),
        urls: (Array.<string>|undefined),
        wrapX: (boolean|undefined)}}
        */
        declare interface XYZOptions {
            attributions?: ol.AttributionLike,
                cacheSize?: number,
                crossOrigin?: (string),
                logo?: (string | olx.LogoOptions),
                opaque?: boolean,
                projection?: ol.ProjectionLike,
                reprojectionErrorThreshold?: number,
                maxZoom?: number,
                minZoom?: number,
                tileGrid?: undefined.TileGrid,
                tileLoadFunction?: ol.TileLoadFunctionType,
                tilePixelRatio?: number,
                tileSize?: (number | ol.Size),
                tileUrlFunction?: ol.TileUrlFunctionType,
                url?: string,
                urls?: string[],
                wrapX?: boolean
        }
    }


    /**
     * 
     * @typedef  *     collapsible: (boolean|undefined),
    collapsed: (boolean|undefined),
    tipLabel: (string|undefined),
    label: (string|Node|undefined),
    collapseLabel: (string|Node|undefined),
    render: (function(ol.MapEvent)|undefined),
    target: (Element|undefined)}}
    */
    declare interface AttributionOptions {
        className?: string,
            target?: Element,
            collapsible?: boolean,
            collapsed?: boolean,
            tipLabel?: string,
            label?: (string | Node),
            collapseLabel?: (string | Node),
            render?: ((event: ol.MapEvent) => any)
    }

    /**
     * 
     * @typedef  
     */
    declare interface DeviceOrientationOptions {
        tracking?: boolean
    }

    /**
     * 
     * @typedef  *     trackingOptions: (PositionOptions|undefined),
    projection: ol.ProjectionLike}}
    */
    declare interface GeolocationOptions {
        tracking?: boolean,
            trackingOptions?: PositionOptions,
            projection: ol.ProjectionLike
    }

    /**
     * Object literal with config options for the map logo.
     * @typedef  
     */
    declare interface LogoOptions {
        href: string,
            src: string
    }

    /**
     * 
     * @typedef  *     maxLines: (number|undefined),
    strokeStyle: (ol.style.Stroke|undefined),
    targetSize: (number|undefined)}}
    */
    declare interface GraticuleOptions {
        map?: ol.Map,
            maxLines?: number,
            strokeStyle?: undefined.Stroke,
            targetSize?: number
    }

    /**
     * Object literal with config options for the map.
     * @typedef  *     pixelRatio: (number|undefined),
    interactions: (ol.Collection.<ol.interaction.Interaction>|Array.<ol.interaction.Interaction>|undefined),
    keyboardEventTarget: (Element|Document|string|undefined),
    layers: (Array.<ol.layer.Base>|ol.Collection.<ol.layer.Base>|undefined),
    loadTilesWhileAnimating: (boolean|undefined),
    loadTilesWhileInteracting: (boolean|undefined),
    logo: (boolean|string|olx.LogoOptions|Element|undefined),
    overlays: (ol.Collection.<ol.Overlay>|Array.<ol.Overlay>|undefined),
    renderer: (ol.RendererType|Array.<ol.RendererType|string>|string|undefined),
    target: (Element|string|undefined),
    view: (ol.View|undefined)}}
    */
    declare interface MapOptions {
        controls?: (ol.Collection<undefined.Control>| undefined.Control[]),
            pixelRatio?: number,
            interactions?: (ol.Collection<undefined.Interaction>| undefined.Interaction[]),
            keyboardEventTarget?: (Element | Document | string),
            layers?: (undefined.Base[] | ol.Collection<undefined.Base>),
            loadTilesWhileAnimating?: boolean,
            loadTilesWhileInteracting?: boolean,
            logo?: (boolean | string | olx.LogoOptions | Element),
            overlays?: (ol.Collection<ol.Overlay>| ol.Overlay[]),
            renderer?: (ol.RendererType | (ol.RendererType | string)[] | string),
            target?: (Element | string),
            view?: ol.View
    }

    /**
     * Object literal with config options for the overlay.
     * @typedef  *     element: (Element|undefined),
    offset: (Array.<number>|undefined),
    position: (ol.Coordinate|undefined),
    positioning: (ol.OverlayPositioning|string|undefined),
    stopEvent: (boolean|undefined),
    insertFirst: (boolean|undefined),
    autoPan: (boolean|undefined),
    autoPanAnimation: (olx.animation.PanOptions|undefined),
    autoPanMargin: (number|undefined)}}
    */
    declare interface OverlayOptions {
        id?: (number | string),
            element?: Element,
            offset?: number[],
            position?: ol.Coordinate,
            positioning?: (ol.OverlayPositioning | string),
            stopEvent?: boolean,
            insertFirst?: boolean,
            autoPan?: boolean,
            autoPanAnimation?: undefined.PanOptions,
            autoPanMargin?: number
    }

    /**
     * Object literal with config options for the projection.
     * @typedef  *     units: (ol.proj.Units|string|undefined),
    extent: (ol.Extent|undefined),
    axisOrientation: (string|undefined),
    global: (boolean|undefined),
    metersPerUnit: (number|undefined),
    worldExtent: (ol.Extent|undefined),
    getPointResolution: (function(number, ol.Coordinate):number|undefined) }}
    */
    declare interface ProjectionOptions {
        code: string,
            units?: (undefined.Units | string),
            extent?: ol.Extent,
            axisOrientation?: string,
            global?: boolean,
            metersPerUnit?: number,
            worldExtent?: ol.Extent,
            getPointResolution?: ((resolution: number, coords: ol.Coordinate) => number)
    }
    declare module 'view' {

        /**
         * 
         * @typedef  *     padding: (!Array.<number>|undefined),
        constrainResolution: (boolean|undefined),
        nearest: (boolean|undefined),
        maxZoom: (number|undefined),
        minResolution: (number|undefined)}}
        */
        declare interface FitOptions {
            padding?: number[],
                constrainResolution?: boolean,
                nearest?: boolean,
                maxZoom?: number,
                minResolution?: number
        }
    }


    /**
     * Object literal with config options for the view.
     * @typedef  *     constrainRotation: (boolean|number|undefined),
    enableRotation: (boolean|undefined),
    extent: (ol.Extent|undefined),
    minResolution: (number|undefined),
    maxResolution: (number|undefined),
    minZoom: (number|undefined),
    maxZoom: (number|undefined),
    projection: ol.ProjectionLike,
    resolution: (number|undefined),
    resolutions: (Array.<number>|undefined),
    rotation: (number|undefined),
    zoom: (number|undefined),
    zoomFactor: (number|undefined)}}
    */
    declare interface ViewOptions {
        center?: ol.Coordinate,
            constrainRotation?: (boolean | number),
            enableRotation?: boolean,
            extent?: ol.Extent,
            maxResolution?: number,
            minResolution?: number,
            maxZoom?: number,
            minZoom?: number,
            projection?: ol.ProjectionLike,
            resolution?: number,
            resolutions?: number[],
            rotation?: number,
            zoom?: number,
            zoomFactor?: number
    }

    /**
     * 
     * @typedef  *     attributions: Object.<string, ol.Attribution>,
    coordinateToPixelTransform: ol.Transform,
    extent: (null|ol.Extent),
    focus: ol.Coordinate,
    index: number,
    layerStates: Object.<number, ol.LayerState>,
    layerStatesArray: Array.<ol.LayerState>,
    logos: Object.<string, (string|Element)>,
    pixelRatio: number,
    pixelToCoordinateTransform: ol.Transform,
    postRenderFunctions: Array.<ol.PostRenderFunction>,
    size: ol.Size,
    skippedFeatureUids: Object.<string, boolean>,
    tileQueue: ol.TileQueue,
    time: number,
    usedTiles: Object.<string, Object.<string, ol.TileRange>>,
    viewState: olx.ViewState,
    viewHints: Array.<number>,
    wantedTiles: !Object.<string, Object.<string, boolean>>}}
    */
    declare interface FrameState {
        pixelRatio: number,
            time: number,
            viewState: olx.ViewState
    }

    /**
     * 
     * @typedef  *     projection: ol.proj.Projection,
    resolution: number,
    rotation: number}}
    */
    declare interface ViewState {
        center: ol.Coordinate,
            projection: undefined.Projection,
            resolution: number,
            rotation: number
    }
}
declare module 'openlayers' {
    declare module.exports: typeof ol
}