// @flow
/**
 * Flowtype definitions for selenium-webdriver-2.53.1
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$chrome: {
        getDefaultService: typeof chrome$getDefaultService,
        setDefaultService: typeof chrome$setDefaultService,
    }
    /**
     * Creates a new WebDriver client for Chrome.
     * @extends  {webdriver.WebDriver}
     */
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options.
     * @param  The session to use; will use
    the {
     * @link  getDefaultService default service} by default.
     * @param  The control flow to use, or
    {
     * @code  null} to use the currently active flow.
     * @constructor  
    */
    constructor(opt_config?: webdriver$Options | webdriver$Capabilities, opt_service?: remote$DriverService, opt_flow?: undefined.ControlFlow): this
}

declare interface chrome$IOptionsValues {
    args: string[],
        binary?: string,
        detach: boolean,
        extensions: string[],
        localState?: any,
        logFile?: string,
        prefs?: any
}

declare interface chrome$IPerfLoggingPrefs {
    enableNetwork: boolean,
        enablePage: boolean,
        enableTimeline: boolean,
        tracingCategories: string,
        bufferUsageReportingInterval: number
}


/**
 * Class for managing ChromeDriver specific options.
 */
declare class Options {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities
     * object.
     * @param  The capabilities object.
     * @return  The ChromeDriver options.
     */
    fromCapabilities(capabilities: webdriver$Capabilities): chrome$Options;

    /**
     * Add additional command line arguments to use when launching the Chrome
     * browser.  Each argument may be specified with or without the "--" prefix
    (e.g. "--foo" and "foo"). Arguments with an associated value should be
    delimited by an "=": "foo=bar".
     * @param  The arguments to add.
     * @return  A self reference.
    */
    addArguments(...var_args: string[]): chrome$Options;

    /**
     * List of Chrome command line switches to exclude that ChromeDriver by default
     * passes when starting Chrome.  Do not prefix switches with "--".
     * @param  The switches to exclude.
     * @return  A self reference.
     */
    excludeSwitches(...var_args: string[]): chrome$Options;

    /**
     * Add additional extensions to install when launching Chrome. Each extension
     * should be specified as the path to the packed CRX file, or a Buffer for an
    extension.
     * @param  The
    extensions to add.
     * @return  A self reference.
    */
    addExtensions(...var_args: any[]): chrome$Options;

    /**
     * Sets the path to the Chrome binary to use. On Mac OS X, this path should
     * reference the actual Chrome executable, not just the application binary
    (e.g. "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome").

    The binary path be absolute or relative to the chromedriver server
    executable, but it must exist on the machine that will launch Chrome.
     * @param  The path to the Chrome binary to use.
     * @return  A self reference.
    */
    setChromeBinaryPath(path: string): chrome$Options;

    /**
     * Sets whether to leave the started Chrome browser running if the controlling
     * ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is
    called.
     * @param  Whether to leave the browser running if the
    chromedriver service is killed before the session.
     * @return  A self reference.
    */
    detachDriver(detach: boolean): chrome$Options;

    /**
     * Sets the user preferences for Chrome's user profile. See the "Preferences"
     * file in Chrome's user data directory for examples.
     * @param  Dictionary of user preferences to use.
     * @return  A self reference.
     */
    setUserPreferences(prefs: any): chrome$Options;

    /**
     * Sets the logging preferences for the new session.
     * @param  The logging preferences.
     * @return  A self reference.
     */
    setLoggingPrefs(prefs: undefined.Preferences): chrome$Options;

    /**
     * Sets the performance logging preferences. Options include:
     * 
    - `enableNetwork`: Whether or not to collect events from Network domain.
    - `enablePage`: Whether or not to collect events from Page domain.
    - `enableTimeline`: Whether or not to collect events from Timeline domain.
         Note: when tracing is enabled, Timeline domain is implicitly disabled,
         unless `enableTimeline` is explicitly set to true.
    - `tracingCategories`: A comma-separated string of Chrome tracing categories
         for which trace events should be collected. An unspecified or empty
         string disables tracing.
    - `bufferUsageReportingInterval`: The requested number of milliseconds
         between DevTools trace buffer usage events. For example, if 1000, then
         once per second, DevTools will report how full the trace buffer is. If a
         report indicates the buffer usage is 100%, a warning will be issued.enablePage: boolean,
    enableTimeline: boolean,
    tracingCategories: string,
    bufferUsageReportingInterval: number}} prefs The performance
    logging preferences.
     * @return  A self reference.
    */
    setPerfLoggingPrefs(prefs: chrome$IPerfLoggingPrefs): chrome$Options;

    /**
     * Sets preferences for the "Local State" file in Chrome's user data
     * directory.
     * @param  Dictionary of local state preferences.
     * @return  A self reference.
     */
    setLocalState(state: any): chrome$Options;

    /**
     * Sets the name of the activity hosting a Chrome-based Android WebView. This
     * option must be set to connect to an [Android WebView](
    https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)
     * @param  The activity name.
     * @return  A self reference.
    */
    androidActivity(name: string): chrome$Options;

    /**
     * Sets the device serial number to connect to via ADB. If not specified, the
     * ChromeDriver will select an unused device at random. An error will be
    returned if all devices already have active sessions.
     * @param  The device serial number to connect to.
     * @return  A self reference.
    */
    androidDeviceSerial(serial: string): chrome$Options;

    /**
     * Configures the ChromeDriver to launch Chrome on Android via adb. This
     * function is shorthand for
    {
     * @link  #androidPackage options.androidPackage('com.android.chrome')}.
     * @return  A self reference.
    */
    androidChrome(): chrome$Options;

    /**
     * Sets the package name of the Chrome or WebView app.
     * @param  The package to connect to, or `null` to disable Android
    and switch back to using desktop Chrome.
     * @return  A self reference.
    */
    androidPackage(pkg: string): chrome$Options;

    /**
     * Sets the process name of the Activity hosting the WebView (as given by `ps`).
     * If not specified, the process name is assumed to be the same as
    {
     * @link  #androidPackage}.
     * @param  The main activity name.
     * @return  A self reference.
    */
    androidProcess(processName: string): chrome$Options;

    /**
     * Sets whether to connect to an already-running instead of the specified
     * {
     * @linkplain  #androidProcess app} instead of launching the app with a clean
    data directory.
     * @param  Whether to connect to a running instance.
     * @return  A self reference.
    */
    androidUseRunningApp(useRunning: boolean): chrome$Options;

    /**
     * Sets the path to Chrome's log file. This path should exist on the machine
     * that will launch Chrome.
     * @param  Path to the log file to use.
     * @return  A self reference.
     */
    setChromeLogFile(path: string): chrome$Options;

    /**
     * Sets the directory to store Chrome minidumps in. This option is only
     * supported when ChromeDriver is running on Linux.
     * @param  The directory path.
     * @return  A self reference.
     */
    setChromeMinidumpPath(path: string): chrome$Options;

    /**
     * Configures Chrome to emulate a mobile device. For more information, refer
     * to the ChromeDriver project page on [mobile emulation][em]. Configuration
    options include:

    - `deviceName`: The name of a pre-configured [emulated device][devem]
    - `width`: screen width, in pixels
    - `height`: screen height, in pixels
    - `pixelRatio`: screen pixel ratio

    __Example 1: Using a Pre-configured Device__

         let options = new chrome.Options().setMobileEmulation(
             {deviceName: 'Google Nexus 5'});

         let driver = new chrome.Driver(options);

    __Example 2: Using Custom Screen Configuration__

         let options = new chrome.Options().setMobileEmulation({
             width: 360,
             height: 640,
             pixelRatio: 3.0
         });

         let driver = new chrome.Driver(options);


    [em]: https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation
    [devem]: https://developer.chrome.com/devtools/docs/device-mode{width: number, height: number, pixelRatio: number})} config The
        mobile emulation configuration, or `null` to disable emulation.
     * @return  A self reference.
    */
    setMobileEmulation(config: any): chrome$Options;

    /**
     * Sets the proxy settings for the new session.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): chrome$Options;

    /**
     * Converts this options instance to a {@link webdriver.Capabilities} object.
     * @param  The capabilities to merge
    these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities?: webdriver$Capabilities): webdriver$Capabilities
}


/**
 * Creates {@link remote.DriverService} instances that manage a ChromeDriver
 * server.
 */
declare class ServiceBuilder {

    /**
     * 
     * @param  Path to the server executable to use. If omitted,
    the builder will attempt to locate the chromedriver on the current
    PATH.
     * @throws  {Error} If provided executable does not exist, or the chromedriver
    cannot be found on the PATH.
     * @constructor  
    */
    constructor(opt_exe?: string): this;

    /**
     * Sets the port to start the ChromeDriver on.
     * @param  The port to use, or 0 for any free port.
     * @return  A self reference.
     * @throws  {Error} If the port is invalid.
     */
    usingPort(port: number): chrome$ServiceBuilder;

    /**
     * Sets which port adb is listening to. _The ChromeDriver will connect to adb
     * if an {@linkplain Options#androidPackage Android session} is requested, but
    adb *must* be started beforehand._
     * @param  Which port adb is running on.
     * @return  A self reference.
    */
    setAdbPort(port: number): chrome$ServiceBuilder;

    /**
     * Sets the path of the log file the driver should log to. If a log file is
     * not specified, the driver will log to stderr.
     * @param  Path of the log file to use.
     * @return  A self reference.
     */
    loggingTo(path: string): chrome$ServiceBuilder;

    /**
     * Enables verbose logging.
     * @return  A self reference.
     */
    enableVerboseLogging(): chrome$ServiceBuilder;

    /**
     * Sets the number of threads the driver should use to manage HTTP requests.
     * By default, the driver will use 4 threads.
     * @param  The number of threads to use.
     * @return  A self reference.
     */
    setNumHttpThreads(n: number): chrome$ServiceBuilder;

    /**
     * Sets the base path for WebDriver REST commands (e.g. "/wd/hub").
     * By default, the driver will accept commands relative to "/".
     * @param  The base path to use.
     * @return  A self reference.
     */
    setUrlBasePath(path: string): chrome$ServiceBuilder;

    /**
     * Defines the stdio configuration for the driver service. See
     * {>)} config The
      configuration to use.
     * @code  child_process.spawn} for more information.
     * @return  A self reference.
    */
    setStdio(config: string | Array<string | number | any>): chrome$ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be
     * inherited by every browser session started by the server.
     * @param  The environment to use.
     * @return  A self reference.
     */
    withEnvironment(env: {
        [key: string]: string
    }): chrome$ServiceBuilder;

    /**
     * Creates a new DriverService using this instance's current configuration.
     * @return  A new driver service using this instance's
    current configuration.
     * @throws  {Error} If the driver exectuable was not specified and a default
    could not be found on the current PATH.
    */
    build(): remote$DriverService
}


/**
 * Returns the default ChromeDriver service. If such a service has not been
 * configured, one will be constructed using the default configuration for
a ChromeDriver executable found on the system PATH.
 * @return  The default ChromeDriver service.
*/
declare function chrome$getDefaultService(): remote$DriverService


/**
 * Sets the default service to use for new ChromeDriver instances.
 * @param  The service to use.
 * @throws  {Error} If the default service is currently running.
 */
declare function chrome$setDefaultService(service: remote$DriverService): void
declare var npm$namespace$edge: {
    getDefaultService: typeof edge$getDefaultService,
    setDefaultService: typeof edge$setDefaultService,
}
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options.
     * @param  The session to use; will use
    the {
     * @linkplain  #getDefaultService default service} by default.
     * @param  The control flow to use, or
    {
     * @code  null} to use the currently active flow.
    */
    constructor(opt_config?: webdriver$Capabilities | chrome$Options, opt_service?: remote$DriverService, opt_flow?: undefined.ControlFlow): this;

    /**
     * This function is a no-op as file detectors are not supported by this
     * implementation.
     * @override  
     */
    setFileDetector(): void
}


/**
 * Class for managing MicrosoftEdgeDriver specific options.
 */
declare class Options {

    /**
     * Extracts the MicrosoftEdgeDriver specific options from the given
     * capabilities object.
     * @param  The capabilities object.
     * @return  The MicrosoftEdgeDriver options.
     */
    fromCapabilities(cap: webdriver$Capabilities): edge$Options;

    /**
     * Sets the proxy settings for the new session.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): edge$Options;

    /**
     * Sets the page load strategy for Edge.
     * Supported values are "normal", "eager", and "none";
     * @param  The page load strategy to use.
     * @return  A self reference.
     */
    setPageLoadStrategy(pageLoadStrategy: string): edge$Options;

    /**
     * Converts this options instance to a {@link capabilities.Capabilities}
     * object.
     * @param  The capabilities to
    merge these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities: webdriver$Capabilities): webdriver$Capabilities
}


/**
 * Creates {@link remote.DriverService} instances that manage a
 * MicrosoftEdgeDriver server in a child process.
 */
declare class ServiceBuilder {

    /**
     * 
     * @param  Path to the server executable to use. If omitted,
    the builder will attempt to locate the MicrosoftEdgeDriver on the current
    PATH.
     * @throws  {Error} If provided executable does not exist, or the
    MicrosoftEdgeDriver cannot be found on the PATH.
    */
    constructor(opt_exe?: string): this;

    /**
     * Defines the stdio configuration for the driver service. See
     * {>)}
      config The configuration to use.
     * @code  child_process.spawn} for more information.
     * @return  A self reference.
    */
    setStdio(config: string | Array<string | number | any>): edge$ServiceBuilder;

    /**
     * Sets the port to start the MicrosoftEdgeDriver on.
     * @param  The port to use, or 0 for any free port.
     * @return  A self reference.
     * @throws  {Error} If the port is invalid.
     */
    usingPort(port: number): edge$ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be
     * inherited by every browser session started by the server.
     * @param  The environment to use.
     * @return  A self reference.
     */
    withEnvironment(env: Object): edge$ServiceBuilder;

    /**
     * Creates a new DriverService using this instance's current configuration.
     * @return  A new driver service using this instance's
    current configuration.
     * @throws  {Error} If the driver exectuable was not specified and a default
    could not be found on the current PATH.
    */
    build(): remote$DriverService
}


/**
 * Returns the default ChromeDriver service. If such a service has not been
 * configured, one will be constructed using the default configuration for
a ChromeDriver executable found on the system PATH.
 * @return  The default ChromeDriver service.
*/
declare function edge$getDefaultService(): remote$DriverService


/**
 * Sets the default service to use for new ChromeDriver instances.
 * @param  The service to use.
 * @throws  {Error} If the default service is currently running.
 */
declare function edge$setDefaultService(service: remote$DriverService): void
declare var npm$namespace$executors: {
        createExecutor: typeof executors$createExecutor,
    }
    /**
     * Creates a command executor that uses WebDriver's JSON wire protocol.<string>)} url The server's URL,
     *     or a promise that will resolve to that URL.
     * @param  (optional) The URL of the HTTP proxy for the
    client to use.
     * @returns  /lib/command.Executor} The new command executor.
    */
declare function executors$createExecutor(
    url: string | undefined.Promise<string>,
    opt_agent?: string,
    opt_proxy?: string): webdriver$Executor
declare var npm$namespace$firefox: {
        findWires: typeof firefox$findWires,
        createWiresService: typeof firefox$createWiresService,
        prepareProfile: typeof firefox$prepareProfile,
    }
    /**
     * Manages a Firefox subprocess configured for use with WebDriver.
     */
declare class Binary {

    /**
     * 
     * @param  Path to the Firefox binary to use. If not
    specified, will attempt to locate Firefox on the current system.
     * @constructor  
    */
    constructor(opt_exe?: string): this;

    /**
     * Add arguments to the command line used to start Firefox.
     * @param  Either the arguments to add as
    varargs, or the arguments as an array.
    */
    addArguments(...var_args: string[]): void;

    /**
     * Launches Firefox and eturns a promise that will be fulfilled when the process
     * terminates.
     * @param  Path to the profile directory to use.
     * @return  A promise for the process result.
     * @throws  {Error} If this instance has already been started.
     */
    launch(profile: string): undefined.Promise<any>;

    /**
     * Kills the managed Firefox process.
     * @return  A promise for when the process has terminated.
     */
    kill(): undefined.Promise<void >
}


/**
 * Models a Firefox proifle directory for use with the FirefoxDriver. The
 * {
 * @code  Proifle} directory uses an in-memory model until {
 * @link  #writeToDisk}
is called.
*/
declare class Profile {

    /**
     * 
     * @param  Path to an existing Firefox profile directory to
    use a template for this profile. If not specified, a blank profile will
    be used.
     * @constructor  
    */
    constructor(opt_dir?: string): this;

    /**
     * Registers an extension to be included with this profile.
     * @param  Path to the extension to include, as either an
    unpacked extension directory or the path to a xpi file.
    */
    addExtension(extension: string): void;

    /**
     * Sets a desired preference for this profile.
     * @param  The preference key.
     * @param  The preference value.
     * @throws  {Error} If attempting to set a frozen preference.
     */
    setPreference(key: string, value: string): void;
    setPreference(key: string, value: number): void;
    setPreference(key: string, value: boolean): void;

    /**
     * Returns the currently configured value of a profile preference. This does
     * not include any defaults defined in the profile's template directory user.js
    file (if a template were specified on construction).
     * @param  The desired preference.
     * @return  The current value of the
    requested preference.
    */
    getPreference(key: string): any;

    /**
     * 
     * @return  The port this profile is currently configured to use, or
    0 if the port will be selected at random when the profile is written
    to disk.
    */
    getPort(): number;

    /**
     * Sets the port to use for the WebDriver extension loaded by this profile.
     * @param  The desired port, or 0 to use any free port.
     */
    setPort(port: number): void;

    /**
     * 
     * @return  Whether the FirefoxDriver is configured to automatically
    accept untrusted SSL certificates.
    */
    acceptUntrustedCerts(): boolean;

    /**
     * Sets whether the FirefoxDriver should automatically accept untrusted SSL
     * certificates.
     * @param  .
     */
    setAcceptUntrustedCerts(value: boolean): void;

    /**
     * Sets whether to assume untrusted certificates come from untrusted issuers.
     * @param  .
     */
    setAssumeUntrustedCertIssuer(value: boolean): void;

    /**
     * 
     * @return  Whether to assume untrusted certs come from untrusted
    issuers.
    */
    assumeUntrustedCertIssuer(): boolean;

    /**
     * Sets whether to use native events with this profile.
     * @param  .
     */
    setNativeEventsEnabled(enabled: boolean): void;

    /**
     * Returns whether native events are enabled in this profile.
     * @return  .
     */
    nativeEventsEnabled(): boolean;

    /**
     * Writes this profile to disk.
     * @param  Whether to exclude the WebDriver
    extension from the generated profile. Used to reduce the size of an
    {
     * @link  #encode() encoded profile} since the server will always install
    the extension itself.
     * @return  A promise for the path to the new
    profile directory.
    */
    writeToDisk(opt_excludeWebDriverExt?: boolean): undefined.Promise<string>;

    /**
     * Encodes this profile as a zipped, base64 encoded directory.
     * @return  A promise for the encoded profile.
     */
    encode(): undefined.Promise<string >
}


/**
 * Configuration options for the FirefoxDriver.
 */
declare class Options {

    /**
     * Sets the profile to use. The profile may be specified as a
     * {
     * @link  Profile} object or as the path to an existing Firefox profile to use
    as a template.
     * @param  The profile to use.
     * @return  A self reference.
    */
    setProfile(profile: string | any): firefox$Options;

    /**
     * Sets the binary to use. The binary may be specified as the path to a Firefox
     * executable, or as a {@link Binary} object.
     * @param  The binary to use.
     * @return  A self reference.
     */
    setBinary(binary: string | any): firefox$Options;

    /**
     * Sets the logging preferences for the new session.
     * @param  The logging preferences.
     * @return  A self reference.
     */
    setLoggingPreferences(prefs: undefined.Preferences): firefox$Options;

    /**
     * Sets the proxy to use.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): firefox$Options;

    /**
     * Sets whether to use Mozilla's Marionette to drive the browser.
     * @see  https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette/WebDriver
     */
    useMarionette(marionette: any): firefox$Options;

    /**
     * Converts these options to a {@link capabilities.Capabilities} instance.
     * @return  A new capabilities object.
     */
    toCapabilities(): webdriver$Capabilities
}


/**
 * 
 * @return  .
 * @throws  {Error}
 */
declare function firefox$findWires(): string


/**
 * 
 * @param  .
 * @return  .
 */
declare function firefox$createWiresService(binary: string | any): remote$DriverService


/**
 * 
 * @param  The profile to prepare.
 * @param  The port the FirefoxDriver should listen on.
 * @return  a promise for the path to the profile directory.
 */
declare function firefox$prepareProfile(profile: string | any, port: number): any


/**
 * A WebDriver client for Firefox.
 */
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The
    configuration options for this driver, specified as either an
    {
     * @link  Options} or {
     * @link  capabilities.Capabilities}, or as a raw hash
    object.
     * @param  The flow to
    schedule commands through. Defaults to the active flow object.
    */
    constructor(opt_config?: firefox$Options | webdriver$Capabilities | Object, opt_flow?: undefined.ControlFlow): this;

    /**
     * This function is a no-op as file detectors are not supported by this
     * implementation.
     * @override  
     */
    setFileDetector(): void
}
declare var npm$namespace$http: {
        headersToString: typeof http$headersToString,
        post: typeof http$post,
        del: typeof http$del,
        get: typeof http$get,
        resource: typeof http$resource,
        sendRequest: typeof http$sendRequest,
        tryParse: typeof http$tryParse,
        parseHttpResponse: typeof http$parseHttpResponse,
        buildPath: typeof http$buildPath,
    }
    /**
     * Converts a headers map to a HTTP header block string.
     * @param  The map to convert.
     * @return  The headers as a string.
     */
declare function http$headersToString(headers: any): string


/**
 * Represents a HTTP request message. This class is a "partial" request and only
 * defines the path on the server to send a request to. It is each client's
responsibility to build the full URL for the final request.
 * @final  
*/
declare class HttpRequest {

    /**
     * 
     * @param  The HTTP method to use for the request.
     * @param  The path on the server to send the request to.
     * @param  This request's non-serialized JSON payload data.
     */
    constructor(method: string, path: string, opt_data?: Object): this;

    /**
     * 
     * @override  
     */
    toString(): string
}


/**
 * Represents a HTTP response message.
 * @final  
 */
declare class HttpResponse {

    /**
     * 
     * @param  The response code.
     * @param  The response headers. All header names
    will be converted to lowercase strings for consistent lookups.
     * @param  The response body.
    */
    constructor(status: number, headers: Object, body: string): this;

    /**
     * 
     * @override  
     */
    toString(): string
}

declare function http$post(path: string): any

declare function http$del(path: string): any

declare function http$get(path: string): any

declare function http$resource(method: string, path: string): any


/**
 * A basic HTTP client used to send messages to a remote end.
 */
declare class HttpClient {

    /**
     * 
     * @param  URL for the WebDriver server to send commands to.
     * @param  The agent to use for each request.
    Defaults to `http.globalAgent`.
     * @param  The proxy to use for the connection to the
    server. Default is to use no proxy.
    */
    constructor(serverUrl: string, opt_agent?: any, opt_proxy?: string): this;

    /**
     * Sends a request to the server. The client will automatically follow any
     * redirects returned by the server, fulfilling the returned promise with the
    final response.
     * @param  The request to send.
     * @return  <HttpResponse>} A promise that will be fulfilled
    with the server's response.
    */
    send(httpRequest: http$HttpRequest): undefined.Promise<http$HttpResponse >
}


/**
 * Sends a single HTTP request.
 * @param  The request options.
 * @param  The function to call if the
request succeeds.
 * @param  The function to call if the request fails.
 * @param  The data to send with the request.
 * @param  The proxy server to use for the request.
*/
declare function http$sendRequest(
    options: Object,
    onOk: any,
    onError: any,
    opt_data?: string,
    opt_proxy?: string): any


/**
 * A command executor that communicates with the server using HTTP + JSON.
 * 
By default, each instance of this class will use the legacy wire protocol
from [Selenium project][json]. The executor will automatically switch to the
[W3C wire protocol][w3c] if the remote end returns a compliant response to
a new session command.

[json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol
[w3c]: https://w3c.github.io/webdriver/webdriver-spec.html
 * @implements  {cmd.Executor}
*/
declare class Executor {

    /**
     * 
     * @param  The client to use for sending requests to the
    server.
    */
    constructor(client: http$HttpClient): this;

    /**
     * Defines a new command for use with this executor. When a command is sent,
     * the {@code path} will be preprocessed using the command's parameters; any
    path segments prefixed with ":" will be replaced by the parameter of the
    same name. For example, given "/person/:name" and the parameters
    "{name: 'Bob'}", the final command path will be "/person/Bob".
     * @param  The command name.
     * @param  The HTTP method to use when sending this command.
     * @param  The path to send the command to, relative to
    the WebDriver server's command root and of the form
    "/path/:variable/segment".
    */
    defineCommand(name: string, method: string, path: string): void;

    /**
     * 
     * @override  
     */
    execute(command: any): any
}


/**
 * 
 * @param  .
 * @return  .
 */
declare function http$tryParse(str: string): any


/**
 * Callback used to parse {@link HttpResponse} objects from a
 * {
 * @link  HttpClient}.
 * @param  The HTTP response to parse.
 * @param  Whether the response should be processed using the
W3C wire protocol.
 * @return  The parsed response.
 * @throws  {WebDriverError} If the HTTP response is an error.
*/
declare function http$parseHttpResponse(httpResponse: http$HttpResponse, w3c: boolean): any


/**
 * Builds a fully qualified path using the given set of command parameters. Each
 * path segment prefixed with ':' will be replaced by the value of the
corresponding parameter. All parameters spliced into the path will be
removed from the parameter map.
 * @param  The original resource path.
 * @param  The parameters object to splice into the path.
 * @return  The modified path.
*/
declare function http$buildPath(path: string, parameters: Object): string
/**
 * A WebDriver client for Microsoft's Internet Explorer.
 */
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options.
     * @param  The control flow to use,
    or {
     * @code  null} to use the currently active flow.
    */
    constructor(opt_config?: webdriver$Capabilities | firefox$Options, opt_flow?: undefined.ControlFlow): this;

    /**
     * This function is a no-op as file detectors are not supported by this
     * implementation.
     * @override  
     */
    setFileDetector(): void
}


/**
 * Class for managing IEDriver specific options.
 */
declare class Options {
    constructor(): this;

    /**
     * Extracts the IEDriver specific options from the given capabilities
     * object.
     * @param  The capabilities object.
     * @return  The IEDriver options.
     */
    fromCapabilities(caps: webdriver$Capabilities): ie$Options;

    /**
     * Whether to disable the protected mode settings check when the session is
     * created. Disbling this setting may lead to significant instability as the
    browser may become unresponsive/hang. Only "best effort" support is provided
    when using this capability.

    For more information, refer to the IEDriver's
    [required system configuration](http://goo.gl/eH0Yi3).
     * @param  Whether to ignore protected mode settings.
     * @return  A self reference.
    */
    introduceFlakinessByIgnoringProtectedModeSettings(ignoreSettings: boolean): ie$Options;

    /**
     * Indicates whether to skip the check that the browser's zoom level is set to
     * 100%.
     * @param  Whether to ignore the browser's zoom level settings.
     * @return  A self reference.
     */
    ignoreZoomSetting(ignore: boolean): ie$Options;

    /**
     * Sets the initial URL loaded when IE starts. This is intended to be used with
     * {
     * @link  #ignoreProtectedModeSettings} to allow the user to initialize IE in
    the proper Protected Mode zone. Setting this option may cause browser
    instability or flaky and unresponsive code. Only "best effort" support is
    provided when using this option.
     * @param  The initial browser URL.
     * @return  A self reference.
    */
    initialBrowserUrl(url: string): ie$Options;

    /**
     * Configures whether to enable persistent mouse hovering (true by default).
     * Persistent hovering is achieved by continuously firing mouse over events at
    the last location the mouse cursor has been moved to.
     * @param  Whether to enable persistent hovering.
     * @return  A self reference.
    */
    enablePersistentHover(enable: boolean): ie$Options;

    /**
     * Configures whether the driver should attempt to remove obsolete
     * {
     * @linkplain  webdriver.WebElement WebElements} from its internal cache on
    page navigation (true by default). Disabling this option will cause the
    driver to run with a larger memory footprint.
     * @param  Whether to enable element reference cleanup.
     * @return  A self reference.
    */
    enableElementCacheCleanup(enable: boolean): ie$Options;

    /**
     * Configures whether to require the IE window to have input focus before
     * performing any user interactions (i.e. mouse or keyboard events). This
    option is disabled by default, but delivers much more accurate interaction
    events when enabled.
     * @param  Whether to require window focus.
     * @return  A self reference.
    */
    requireWindowFocus(require: boolean): ie$Options;

    /**
     * Configures the timeout, in milliseconds, that the driver will attempt to
     * located and attach to a newly opened instance of Internet Explorer. The
    default is zero, which indicates waiting indefinitely.
     * @param  How long to wait for IE.
     * @return  A self reference.
    */
    browserAttachTimeout(timeout: number): ie$Options;

    /**
     * Configures whether to launch Internet Explorer using the CreateProcess API.
     * If this option is not specified, IE is launched using IELaunchURL, if
    available. For IE 8 and above, this option requires the TabProcGrowth
    registry value to be set to 0.
     * @param  Whether to use the CreateProcess API.
     * @return  A self reference.
    */
    forceCreateProcessApi(force: boolean): ie$Options;

    /**
     * Specifies command-line switches to use when launching Internet Explorer.
     * This is only valid when used with {@link #forceCreateProcessApi}.
     * @param  The arguments to add.
     * @return  A self reference.
     */
    addArguments(...var_args: Array<string>): ie$Options;

    /**
     * Configures whether proxies should be configured on a per-process basis. If
     * not set, setting a {@linkplain #setProxy proxy} will configure the system
    proxy. The default behavior is to use the system proxy.
     * @param  Whether to enable per-process proxy settings.
     * @return  A self reference.
    */
    usePerProcessProxy(enable: boolean): ie$Options;

    /**
     * Configures whether to clear the cache, cookies, history, and saved form data
     * before starting the browser. _Using this capability will clear session data
    for all running instances of Internet Explorer, including those started
    manually._
     * @param  Whether to clear all session data on startup.
     * @return  A self reference.
    */
    ensureCleanSession(cleanSession: boolean): ie$Options;

    /**
     * Sets the path to the log file the driver should log to.
     * @param  The log file path.
     * @return  A self reference.
     */
    setLogFile(file: string): ie$Options;

    /**
     * Sets the IEDriverServer's logging {@linkplain Level level}.
     * @param  The logging level.
     * @return  A self reference.
     */
    setLogLevel(level: undefined.Level): ie$Options;

    /**
     * Sets the IP address of the driver's host adapter.
     * @param  The IP address to use.
     * @return  A self reference.
     */
    setHost(host: string): ie$Options;

    /**
     * Sets the path of the temporary data directory to use.
     * @param  The log file path.
     * @return  A self reference.
     */
    setExtractPath(path: string): ie$Options;

    /**
     * Sets whether the driver should start in silent mode.
     * @param  Whether to run in silent mode.
     * @return  A self reference.
     */
    silent(silent: boolean): ie$Options;

    /**
     * Sets the proxy settings for the new session.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): ie$Options;

    /**
     * Converts this options instance to a {@link capabilities.Capabilities}
     * object.
     * @param  The capabilities to
    merge these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities: webdriver$Capabilities): webdriver$Capabilities
}
declare var npm$namespace$opera: {
        setDefaultService: typeof opera$setDefaultService,
        getDefaultService: typeof opera$getDefaultService,
    }
    /**
     * Creates {@link remote.DriverService} instances that manages an
     * [OperaDriver](https://github.com/operasoftware/operachromiumdriver)
    server in a child process.
    */
declare class ServiceBuilder {

    /**
     * 
     * @param  Path to the server executable to use. If omitted,
    the builder will attempt to locate the operadriver on the current
    PATH.
     * @throws  {Error} If provided executable does not exist, or the operadriver
    cannot be found on the PATH.
    */
    constructor(opt_exe?: string): this;

    /**
     * Sets the port to start the OperaDriver on.
     * @param  The port to use, or 0 for any free port.
     * @return  A self reference.
     * @throws  {Error} If the port is invalid.
     */
    usingPort(port: number): opera$ServiceBuilder;

    /**
     * Sets the path of the log file the driver should log to. If a log file is
     * not specified, the driver will log to stderr.
     * @param  Path of the log file to use.
     * @return  A self reference.
     */
    loggingTo(path: string): opera$ServiceBuilder;

    /**
     * Enables verbose logging.
     * @return  A self reference.
     */
    enableVerboseLogging(): opera$ServiceBuilder;

    /**
     * Silence sthe drivers output.
     * @return  A self reference.
     */
    silent(): opera$ServiceBuilder;

    /**
     * Defines the stdio configuration for the driver service. See
     * {>)}
      config The configuration to use.
     * @code  child_process.spawn} for more information.
     * @return  A self reference.
    */
    setStdio(config: string | Array<string | number | any>): opera$ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be
     * inherited by every browser session started by the server.
     * @param  The environment to use.
     * @return  A self reference.
     */
    withEnvironment(env: Object): opera$ServiceBuilder;

    /**
     * Creates a new DriverService using this instance's current configuration.
     * @return  A new driver service using this instance's
    current configuration.
     * @throws  {Error} If the driver exectuable was not specified and a default
    could not be found on the current PATH.
    */
    build(): remote$DriverService
}


/**
 * Sets the default service to use for new ChromeDriver instances.
 * @param  The service to use.
 * @throws  {Error} If the default service is currently running.
 */
declare function opera$setDefaultService(service: remote$DriverService): void


/**
 * Returns the default ChromeDriver service. If such a service has not been
 * configured, one will be constructed using the default configuration for
a ChromeDriver executable found on the system PATH.
 * @return  The default ChromeDriver service.
*/
declare function opera$getDefaultService(): remote$DriverService


/**
 * Class for managing {@linkplain Driver OperaDriver} specific options.
 */
declare class Options {

    /**
     * Extracts the OperaDriver specific options from the given capabilities
     * object.
     * @param  The capabilities object.
     * @return  The OperaDriver options.
     */
    fromCapabilities(caps: webdriver$Capabilities): opera$Options;

    /**
     * Add additional command line arguments to use when launching the Opera
     * browser.  Each argument may be specified with or without the "--" prefix
    (e.g. "--foo" and "foo"). Arguments with an associated value should be
    delimited by an "=": "foo=bar".
     * @param  The arguments to add.
     * @return  A self reference.
    */
    addArguments(...var_args: Array<string>): opera$Options;

    /**
     * Add additional extensions to install when launching Opera. Each extension
     * should be specified as the path to the packed CRX file, or a Buffer for an
    extension.
     * @param  The
    extensions to add.
     * @return  A self reference.
    */
    addExtensions(...var_args: Array<any>): opera$Options;

    /**
     * Sets the path to the Opera binary to use. On Mac OS X, this path should
     * reference the actual Opera executable, not just the application binary. The
    binary path be absolute or relative to the operadriver server executable, but
    it must exist on the machine that will launch Opera.
     * @param  The path to the Opera binary to use.
     * @return  A self reference.
    */
    setOperaBinaryPath(path: string): opera$Options;

    /**
     * Sets the logging preferences for the new session./lib/logging.Preferences} prefs The logging preferences.
     * @return  A self reference.
     */
    setLoggingPrefs(prefs: undefined.Preferences): opera$Options;

    /**
     * Sets the proxy settings for the new session.
     * @param  The proxy configuration to use.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): opera$Options;

    /**
     * Converts this options instance to a {@link capabilities.Capabilities}
     *      object.
     * @param  The capabilities to
    merge these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities?: webdriver$Capabilities): webdriver$Capabilities
}

declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options.
     * @param  The session to use; will use
    the {
     * @link  getDefaultService default service} by default.
     * @param  The control flow to use,
    or {
     * @code  null} to use the currently active flow.
    */
    constructor(opt_config?: webdriver$Capabilities | opera$Options, opt_service?: remote$DriverService, opt_flow?: undefined.ControlFlow): this;

    /**
     * This function is a no-op as file detectors are not supported by this
     * implementation.
     * @override  
     */
    setFileDetector(): void
}
/**
 * A record object that defines the configuration options for a DriverService
 * instance.
 * @record  
 */
declare interface remote$ServiceOptions {}


/**
 * Manages the life and death of a native executable WebDriver server.
 * 
It is expected that the driver server implements the
https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol.
Furthermore, the managed server should support multiple concurrent sessions,
so that this class may be reused for multiple clients.
*/
declare class DriverService {

    /**
     * 
     * @param  Path to the executable to run.
     * @param  Configuration options for the service.
     */
    constructor(executable: string, options: remote$ServiceOptions): this;

    /**
     * 
     * @return  <string>} A promise that resolves to
    the server's address.
     * @throws  {Error} If the server has not been started.
    */
    address(): undefined.Promise<string>;

    /**
     * Returns whether the underlying process is still running. This does not take
     * into account whether the process is in the process of shutting down.
     * @return  Whether the underlying service process is running.
     */
    isRunning(): boolean;

    /**
     * Starts the server if it is not already running.
     * @param  How long to wait, in milliseconds, for the
    server to start accepting requests. Defaults to 30 seconds.
     * @return  <string>} A promise that will resolve
    to the server's base URL when it has started accepting requests. If the
    timeout expires before the server has started, the promise will be
    rejected.
    */
    start(opt_timeoutMs?: number): undefined.Promise<string>;

    /**
     * Stops the service if it is not currently running. This function will kill
     * the server immediately. To synchronize with the active control flow, use
    {
     * @link  #stop()}.
     * @return  A promise that will be resolved when
    the server has been stopped.
    */
    kill(): undefined.Promise<any>;

    /**
     * Schedules a task in the current control flow to stop the server if it is
     * currently running.
     * @return  A promise that will be resolved when
    the server has been stopped.
    */
    stop(): undefined.Promise<any >
}
declare var npm$namespace$safari: {
    findSafariExecutable: typeof safari$findSafariExecutable,
    createConnectFile: typeof safari$createConnectFile,
    cleanSession: typeof safari$cleanSession,
    getRandomString: typeof safari$getRandomString,
}
declare class Server {}


/**
 * 
 * @return  A promise that will resolve with the path
to Safari on the current system.
*/
declare function safari$findSafariExecutable(): any


/**
 * 
 * @param  The URL to connect to.
 * @return  A promise for the path to a file that Safari can
open on start-up to trigger a new connection to the WebSocket server.
*/
declare function safari$createConnectFile(serverUrl: string): any


/**
 * Deletes all session data files if so desired.
 * @param  .
 * @return  A list of promises for the deleted files.
 */
declare function safari$cleanSession(desiredCapabilities: webdriver$Capabilities): any[]


/**
 * 
 * @return  . 
 */
declare function safari$getRandomString(): string


/**
 * 
 * @implements  {command.Executor}
 */
declare class CommandExecutor {}


/**
 * Configuration options specific to the {@link Driver SafariDriver}.
 */
declare class Options {

    /**
     * Extracts the SafariDriver specific options from the given capabilities
     * object.
     * @param  The capabilities object.
     * @return  The ChromeDriver options.
     */
    fromCapabilities(capabilities: webdriver$Capabilities): safari$Options;

    /**
     * Sets whether to force Safari to start with a clean session. Enabling this
     * option will cause all global browser data to be deleted.
     * @param  Whether to make sure the session has no cookies,
    cache entries, local storage, or databases.
     * @return  A self reference.
    */
    setCleanSession(clean: boolean): safari$Options;

    /**
     * Sets the logging preferences for the new session./lib/logging.Preferences} prefs The logging preferences.
     * @return  A self reference.
     */
    setLoggingPrefs(prefs: undefined.Preferences): safari$Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     * @param  The capabilities to
    merge these options into, if any.
     * @return  The capabilities.
    */
    toCapabilities(opt_capabilities: webdriver$Capabilities): webdriver$Capabilities
}


/**
 * A WebDriver client for Safari. This class should never be instantiated
 * directly; instead, use the {@linkplain ./builder.Builder Builder}:

     var driver = new Builder()
         .forBrowser('safari')
         .build();
*/
declare class Driver mixins webdriver$WebDriver {

    /**
     * 
     * @param  The configuration
    options for the new session.
     * @param  The control flow to create
    the driver under.
    */
    constructor(opt_config?: safari$Options | webdriver$Capabilities, opt_flow?: undefined.ControlFlow): this
}
declare class IError mixins Error {
    constructor(opt_error?: string): this;
    code(): number
}


/**
 * The base WebDriver error type. This error type is only used directly when a
 * more appropriate category is not defined for the offending error.
 */
declare class WebDriverError mixins IError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An attempt was made to select an element that cannot be selected.
 */
declare class ElementNotSelectableError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An element command could not be completed because the element is not visible
 * on the page.
 */
declare class ElementNotVisibleError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * The arguments passed to a command are either invalid or malformed.
 */
declare class InvalidArgumentError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An illegal attempt was made to set a cookie under a different domain than
 * the current page.
 */
declare class InvalidCookieDomainError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * The coordinates provided to an interactions operation are invalid.
 */
declare class InvalidElementCoordinatesError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An element command could not be completed because the element is in an
 * invalid state, e.g. attempting to click an element that is no longer attached
to the document.
*/
declare class InvalidElementStateError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * Argument was an invalid selector.
 */
declare class InvalidSelectorError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * Occurs when a command is directed to a session that does not exist.
 */
declare class NoSuchSessionError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An error occurred while executing JavaScript supplied by the user.
 */
declare class JavascriptError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * The target for mouse interaction is not in the browsers viewport and cannot
 * be brought into that viewport.
 */
declare class MoveTargetOutOfBoundsError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An attempt was made to operate on a modal dialog when one was not open.
 */
declare class NoSuchAlertError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An element could not be located on the page using the given search
 * parameters.
 */
declare class NoSuchElementError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A request to switch to a frame could not be satisfied because the frame
 * could not be found.
 */
declare class NoSuchFrameError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A request to switch to a window could not be satisfied because the window
 * could not be found.
 */
declare class NoSuchWindowError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A script did not complete before its timeout expired.
 */
declare class ScriptTimeoutError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A new session could not be created.
 */
declare class SessionNotCreatedError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An element command failed because the referenced element is no longer
 * attached to the DOM.
 */
declare class StaleElementReferenceError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * An operation did not completErrorCodee before its timeout expired.
 */
declare class TimeoutError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A request to set a cookies value could not be satisfied.
 */
declare class UnableToSetCookieError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A screen capture operation was not possible.
 */
declare class UnableToCaptureScreenError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * A modal dialog was open, blocking this operation.
 */
declare class UnexpectedAlertOpenError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any.
     * @param  the text of the open dialog, if available.
     */
    constructor(opt_error?: string, opt_text?: string): this;

    /**
     * 
     * @return  The text displayed with the unhandled alert,
    if available.
    */
    getAlertText(): string
}


/**
 * A command could not be executed because the remote end is not aware of it.
 */
declare class UnknownCommandError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * The requested command matched a known URL but did not match an method for
 * that URL.
 */
declare class UnknownMethodError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


/**
 * Reports an unsupport operation.
 */
declare class UnsupportedOperationError mixins WebDriverError {

    /**
     * 
     * @param  the error message, if any. 
     */
    constructor(opt_error?: string): this
}


declare var npm$namespace$logging: {
        getLevel: typeof logging$getLevel,
    }
    /**
     * A hash describing log preferences.
     * @typedef  
     */
declare class Preferences {
    setLevel(type: string | Type, level: logging$Level | string | number): void;
    toJSON(): {
        [key: string]: string
    }
}


/**
 * Defines a message level that may be used to control logging output.
 * @final  
 */
declare class Level {
    name_: string;
    value_: number;

    /**
     * 
     * @param  the level's name.
     * @param  the level's numeric value.
     */
    constructor(name: string, level: number): this;

    /**
     * 
     * @override  
     */
    toString(): string;

    /**
     * This logger's name. 
     */
    name(): string;

    /**
     * The numeric log level. 
     */
    value(): number;

    /**
     * Indicates no log messages should be recorded.
     * @const  
     */
    OFF: logging$Level;

    /**
     * Log messages with a level of `1000` or higher.
     * @const  
     */
    SEVERE: logging$Level;

    /**
     * Log messages with a level of `900` or higher.
     * @const  
     */
    WARNING: logging$Level;

    /**
     * Log messages with a level of `800` or higher.
     * @const  
     */
    INFO: logging$Level;

    /**
     * Log messages with a level of `700` or higher.
     * @const  
     */
    DEBUG: logging$Level;

    /**
     * Log messages with a level of `500` or higher.
     * @const  
     */
    FINE: logging$Level;

    /**
     * Log messages with a level of `400` or higher.
     * @const  
     */
    FINER: logging$Level;

    /**
     * Log messages with a level of `300` or higher.
     * @const  
     */
    FINEST: logging$Level;

    /**
     * Indicates all log messages should be recorded.
     * @const  
     */
    ALL: logging$Level
}


/**
 * Converts a level name or value to a {@link webdriver.logging.Level} value.
 * If the name/value is not recognized, {@link webdriver.logging.Level.ALL}
will be returned.
 * @param  The log level name, or value, to
convert .
 * @return  The converted level.
*/
declare function logging$getLevel(nameOrValue: string | number): logging$Level

declare interface logging$IEntryJSON {
    level: string,
        message: string,
        timestamp: number,
        type: string
}


/**
 * A single log entry.
 */
declare class Entry {

    /**
     * 
     * @param  The entry level.
     * @param  The log message.
     * @param  The time this entry was generated, in
    milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
    current time will be used.
     * @param  The log type, if known.
     * @constructor  
    */
    constructor(level: logging$Level | string | number, message: string, opt_timestamp?: number, opt_type?: string | Type): this;

    /**
     * 
     * @type  
     */
    level: logging$Level;

    /**
     * 
     * @type  
     */
    message: string;

    /**
     * 
     * @type  
     */
    timestamp: number;

    /**
     * 
     * @type  
     */
    type: string;

    /**
     * 
     * @return  *           type: string}} The JSON representation of this entry.
     */
    toJSON(): logging$IEntryJSON
}


/**
 * An object used to log debugging messages. Loggers use a hierarchical,
 * dot-separated naming scheme. For instance, "foo" is considered the parent of
the "foo.bar" and an ancestor of "foo.bar.baz".

Each logger may be assigned a {@linkplain #setLevel log level}, which
controls which level of messages will be reported to the
{
 * @linkplain  #addHandler handlers} attached to this instance. If a log level
is not explicitly set on a logger, it will inherit its parent.

This class should never be directly instantiated. Instead, users should
obtain logger references using the {
 * @linkplain  ./logging.getLogger()
getLogger()} function.
 * @final  
*/
declare class Logger {

    /**
     * 
     * @param  the name of this logger.
     * @param  the initial level for this logger.
     */
    constructor(name: string, opt_level?: logging$Level): this;

    /**
     * 
     * @private  {string} 
     */
    name_: string;

    /**
     * 
     * @private  {Level} 
     */
    level_: logging$Level;

    /**
     * 
     * @private  {Logger} 
     */
    parent_: logging$Logger;

    /**
     * 
     * @private  {Set<function(!Entry)>} 
     */
    handlers_: any;

    /**
     * 
     * @return  the name of this logger. 
     */
    getName(): string;

    /**
     * 
     * @param  the new level for this logger, or `null` if the logger
    should inherit its level from its parent logger.
    */
    setLevel(level: logging$Level): void;

    /**
     * 
     * @return  the log level for this logger. 
     */
    getLevel(): logging$Level;

    /**
     * 
     * @return  the effective level for this logger.
     */
    getEffectiveLevel(): logging$Level;

    /**
     * 
     * @param  the level to check.
     * @return  whether messages recorded at the given level are loggable
    by this instance.
    */
    isLoggable(level: logging$Level): boolean;

    /**
     * Adds a handler to this logger. The handler will be invoked for each message
     * logged with this instance, or any of its descendants.
     * @param  the handler to add.
     */
    addHandler(handler: any): void;

    /**
     * Removes a handler from this logger.
     * @param  the handler to remove.
     * @return  whether a handler was successfully removed.
     */
    removeHandler(handler: any): void;

    /**
     * Logs a message at the given level. The message may be defined as a string
     * or as a function that will return the message. If a function is provided,
    it will only be invoked if this logger's
    {
     * @linkplain  #getEffectiveLevel() effective log level} includes the given
    `level`.
     * @param  the level at which to log the message.
     * @param  the message to log, or a
    function that will return the message.
    */
    log(level: logging$Level, loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.SEVERE} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    severe(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.WARNING} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    warning(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.INFO} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    info(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.DEBUG} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    debug(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINE} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    fine(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINER} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    finer(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINEST} log level.
     * @param  the message to log, or a
    function that will return the message.
    */
    finest(loggable: string | Function): void
}


/**
 * Maintains a collection of loggers.
 * @final  
 */
declare class LogManager {

    /**
     * Retrieves a named logger, creating it in the process. This function will
     * implicitly create the requested logger, and any of its parents, if they
    do not yet exist.
     * @param  the logger's name.
     * @return  the requested logger.
    */
    getLogger(name: string): logging$Logger;

    /**
     * Creates a new logger.
     * @param  the logger's name.
     * @param  the logger's parent.
     * @return  the new logger.
     * @private  
     */
    createLogger_(name: string, parent: logging$Logger): logging$Logger
}


declare var npm$namespace$promise: {
        all: typeof promise$all,
        asap: typeof promise$asap,
        controlFlow: typeof promise$controlFlow,
        createFlow: typeof promise$createFlow,
        isPromise: typeof promise$isPromise,
        isGenerator: typeof promise$isGenerator,
        delayed: typeof promise$delayed,
        filter: typeof promise$filter,
        defer: typeof promise$defer,
        fulfilled: typeof promise$fulfilled,
        map: typeof promise$map,
        rejected: typeof promise$rejected,
        checkedNodeCall: typeof promise$checkedNodeCall,
        consume: typeof promise$consume,
        when: typeof promise$when,
        fullyResolved: typeof promise$fullyResolved,
        setDefaultFlow: typeof promise$setDefaultFlow,
    }
    /**
     * Given an array of promises, will return a promise that will be fulfilled
     * with the fulfillment values of the input array's values. If any of the
    input array's promises are rejected, the returned promise will be rejected
    with the same reason.
     * @param  An array of
    promises to wait on.
     * @return  A promise that is
    fulfilled with an array containing the fulfilled values of the
    input array, or rejected with the same reason as the first
    rejected value.
     * @template  
    */
declare function promise$all<T>(arr: Array<T | promise$Promise<T >> ): promise$Promise<T[] >


    /**
     * Invokes the appropriate callback function as soon as a promised
     * {
     * @code  value} is resolved. This function is similar to
    {
     * @link  webdriver.promise.when}, except it does not return a new promise.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
    */
    declare function promise$asap(value: any, callback: Function, opt_errback?: Function): void


/**
 * 
 * @return  The currently active control flow.
 */
declare function promise$controlFlow(): promise$ControlFlow


/**
 * Creates a new control flow. The provided callback will be invoked as the
 * first task within the new flow, with the flow as its sole argument. Returns
a promise that resolves to the callback result.
 * @param  The entry point
to the newly created flow.
 * @return  A promise that resolves to the callback
result.
*/
declare function promise$createFlow<R>(callback: (flow: promise$ControlFlow) => R): promise$Promise<R >


    /**
     * Determines whether a {@code value} should be treated as a promise.
     * Any object whose "then" property is a function will be considered a promise.
     * @param  The value to test.
     * @return  Whether the value is a promise.
     */
    declare function promise$isPromise(value: any): boolean


/**
 * Tests is a function is a generator.
 * @param  The function to test.
 * @return  Whether the function is a generator.
 */
declare function promise$isGenerator(fn: Function): boolean


/**
 * Creates a promise that will be resolved at a set time in the future.
 * @param  The amount of time, in milliseconds, to wait before
resolving the promise.
 * @return  The promise.
*/
declare function promise$delayed(ms: number): promise$Promise<void >


    /**
     * Calls a function for each element in an array, and if the function returns
     * true adds the element to a new array.

    If the return value of the filter function is a promise, this function
    will wait for it to be fulfilled before determining whether to insert the
    element into the new array.

    If the filter function throws or returns a rejected promise, the promise
    returned by this function will be rejected with the same reason. Only the
    first failure will be reported; all subsequent errors will be silently
    ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  |ManagedPromise<boolean>)} fn The function
    to call for each element in the array.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$filter<T>(
        arr: Array<T>| promise$Promise<Array<T >> ,
        fn: (element: T, type: any, index: number, array: T[]) => any,
        opt_self?: any): promise$Promise<T[] >


    /**
     * Creates a new deferred object.
     * @return  The new deferred object.
     */
    declare function promise$defer<T>(): promise$Deferred<T >


    /**
     * Creates a promise that has been resolved with the given value.
     * @param  The resolved value.
     * @return  The resolved promise.
     * @template  
     */
    declare function promise$fulfilled<T>(opt_value?: T): promise$Promise<T >


    /**
     * Calls a function for each element in an array and inserts the result into a
     * new array, which is used as the fulfillment value of the promise returned
    by this function.

    If the return value of the mapping function is a promise, this function
    will wait for it to be fulfilled before inserting it into the new array.

    If the mapping function throws or returns a rejected promise, the
    promise returned by this function will be rejected with the same reason.
    Only the first failure will be reported; all subsequent errors will be
    silently ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  The
    function to call for each element in the array. This function should
    expect three arguments (the element, the index, and the array itself.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$map<T>(
        arr: Array<T>| promise$Promise<Array<T >> ,
        fn: (self: any, type: any, index: number, array: any[]) => any,
        opt_self?: any): promise$Promise<T[] >


    /**
     * Creates a promise that has been rejected with the given reason.*=} opt_reason The rejection reason; may be any value, but is
     *     usually an Error or a string.
     * @return  The rejected promise.
     * @template  
     */
    declare function promise$rejected<T>(opt_reason?: any): promise$Promise<T >


    /**
     * Wraps a function that expects a node-style callback as its final
     * argument. This callback expects two arguments: an error value (which will be
    null if the call succeeded), and the success value as the second argument.
    The callback will the resolve or reject the returned promise, based on its
    arguments.
     * @param  The function to wrap.
     * @param  The arguments to apply to the function, excluding the
    final callback.
     * @return  A promise that will be resolved with the
    result of the provided function's callback.
    */
    declare function promise$checkedNodeCall<T>(fn: Function, ...var_args: any[]): promise$Promise<T >


    /**
     * Consumes a {@code GeneratorFunction}. Each time the generator yields a
     * promise, this function will wait for it to be fulfilled before feeding the
    fulfilled value back into {@code next}. Likewise, if a yielded promise is
    rejected, the rejection error will be passed to {@code throw}.

    __Example 1:__ the Fibonacci Sequence.

         promise.consume(function fibonacci() {
           var n1 = 1, n2 = 1;
           for (var i = 0; i<4; ++i) {
             var tmp = yield n1 + n2;
             n1 = n2;
             n2 = tmp;
           }
           return n1 + n2;
         }).then(function(result) {
           console.log(result);  // 13
         });

    __Example 2:__ a generator that throws.

         promise.consume(function () {
           yield promise.delayed(250).then(function() {
             throw Error('boom');
           });
         }).catch(function(e) {
           console.log(e.toString());  // Error: boom
         });
     * @param  The generator function to execute.
     * @param  The object to use as "this" when invoking the
    initial generator.
     * @param  Any arguments to pass to the initial generator.
     * @return  A promise that will resolve to the
    generator's final result.
     * @throws  {TypeError} If the given function is not a generator.
    */
    declare function promise$consume<T>(
        generatorFn: Function,
        opt_self?: any,
        ...var_args: any[]): promise$Promise<T >


    /**
     * Registers an observer on a promised {@code value}, returning a new promise
     * that will be resolved when the value is. If {@code value} is not a promise,
    then the return promise will be immediately resolved.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
     * @return  A new promise.
    */
    declare function promise$when<T, R>(
        value: T | promise$Promise<T>,
        opt_callback?: (value: T) => any,
        opt_errback?: (error: any) => any): promise$Promise<R >


    /**
     * Returns a promise that will be resolved with the input value in a
     * fully-resolved state. If the value is an array, each element will be fully
    resolved. Likewise, if the value is an object, all keys will be fully
    resolved. In both cases, all nested arrays and objects will also be
    fully resolved.  All fields are resolved in place; the returned promise will
    resolve on {@code value} and not a copy.

    Warning: This function makes no checks against objects that contain
    cyclical references:

         var value = {};
         value['self'] = value;
         promise.fullyResolved(value);  // Stack overflow.
     * @param  The value to fully resolve.
     * @return  A promise for a fully resolved version
    of the input value.
    */
    declare function promise$fullyResolved<T>(value: any): promise$Promise<T >


    /**
     * Changes the default flow to use when no others are active.
     * @param  The new default flow.
     * @throws  {Error} If the default flow is not currently active.
     */
    declare function promise$setDefaultFlow(flow: promise$ControlFlow): void


/**
 * Error used when the computation of a promise is cancelled.
 */
declare class CancellationError mixins Error {

    /**
     * 
     * @param  The cancellation message.
     */
    constructor(opt_msg?: string): this
}

declare interface promise$IThenable<T>{

    /**
     * Cancels the computation of this promise's value, rejecting the promise in
     * the process. This method is a no-op if the promise has already been
    resolved.
     * @param  The reason this promise is being
    cancelled. This value will be wrapped in a {
     * @link  CancellationError}.
    */
    cancel(opt_reason?: string | Error): void,

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean,

    /**
     * Registers listeners for when this instance is resolved.
     * @param  The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param  The function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    then<R>(
        opt_callback?: (value: T) => R | promise$IThenable<R>,
        opt_errback?: (error: any) => R | promise$IThenable<R>): promise$Promise<R>,

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:

         // Synchronous API:
         try {
           doSynchronousWork();
         } catch (ex) {
           console.error(ex);
         }

         // Asynchronous promise API:
         doAsynchronousWork().catch(function(ex) {
           console.error(ex);
         });
     * @param  The
    function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    catch<R>(errback: Function): promise$Promise<R >
}


/**
 * Thenable is a promise-like object with a {@code then} method which may be
 * used to schedule callbacks on a promised value.
 * @interface  * 
 * @template  
 */
declare class Thenable<T>mixins IThenable<T>{

    /**
     * Cancels the computation of this promise's value, rejecting the promise in
     * the process. This method is a no-op if the promise has already been
    resolved.
     * @param  The reason this promise is being
    cancelled. This value will be wrapped in a {
     * @link  CancellationError}.
    */
    cancel(opt_reason?: string | Error): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved.
     * @param  The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param  The function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    then<R>(
        opt_callback?: (value: T) => R | promise$IThenable<R>,
        opt_errback?: (error: any) => R | promise$IThenable<R>): promise$Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:

         // Synchronous API:
         try {
           doSynchronousWork();
         } catch (ex) {
           console.error(ex);
         }

         // Asynchronous promise API:
         doAsynchronousWork().catch(function(ex) {
           console.error(ex);
         });
     * @param  The
    function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    catch<R>(errback: Function): promise$Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:

         // Synchronous API:
         try {
           doSynchronousWork();
         } finally {
           cleanUp();
         }

         // Asynchronous promise API:
         doAsynchronousWork().finally(cleanUp);

    __Note:__ similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:

         try {
           throw Error('one');
         } finally {
           throw Error('two');  // Hides Error: one
         }

         promise.rejected(Error('one'))
             .finally(function() {
               throw Error('two');  // Hides Error: one
             });
     * @param  The function to call when
    this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    finally<R>(callback: Function): promise$Promise<R>;

    /**
     * Adds a property to a class prototype to allow runtime checks of whether
     * instances of that class implement the Thenable interface. This function
    will also ensure the prototype's {@code then} function is exported from
    compiled code.
     * @param  The
    constructor whose prototype to modify.
    */
    addImplementation(ctor: Function): void;

    /**
     * Checks if an object has been tagged for implementing the Thenable
     * interface as defined by {@link Thenable.addImplementation}.
     * @param  The object to test.
     * @return  Whether the object is an implementation of the Thenable
    interface.
    */
    isImplementation(object: any): boolean
}

declare interface promise$IFulfilledCallback<T>{
    (value: T | promise$IThenable<T>| promise$Thenable<T>| void): void
}

declare interface promise$IRejectedCallback {
    (reason: any): void
}


/**
 * Represents the eventual value of a completed operation. Each promise may be
 * in one of three states: pending, fulfilled, or rejected. Each promise starts
in the pending state and may make a single transition to either a
fulfilled or rejected state, at which point the promise is considered
resolved.
 * @implements  {promise.Thenable<T>}
 * @template  * 
 * @see  http://promises-aplus.github.io/promises-spec/
*/
declare class Promise<T>mixins IThenable<T>{

    /**
     * 
     * @param  Function that is invoked immediately to begin computation of this
    promise's value. The function should accept a pair of callback
    functions, one for fulfilling the promise and another for rejecting it.
     * @param  The control flow
    this instance was created under. Defaults to the currently active flow.
    */
    constructor(resolver: (
        onFulfilled: promise$IFulfilledCallback<T>,
        onRejected: promise$IRejectedCallback) => void, opt_flow?: promise$ControlFlow): this;
    constructor(): this;

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process.
     * @param  The reason this promise is being cancelled. If not an
    {
     * @code  Error}, one will be created using the value's string
    representation.
    */
    cancel(opt_reason?: string | Error): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved. This function most
     * overridden by subtypes.
     * @param opt_callback The function to call if this promise is
    successfully resolved. The function should expect a single argument: the
    promise's resolved value.
     * @param opt_errback The function to call if this promise is
    rejected. The function should expect a single argument: the rejection
    reason.
     * @return  A new promise which will be resolved
    with the result of the invoked callback.
    */
    then(opt_callback?: Function, opt_errback?: Function): promise$Promise<any>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): promise$Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:

         // Synchronous API:
         try {
           doSynchronousWork();
         } catch (ex) {
           console.error(ex);
         }

         // Asynchronous promise API:
         doAsynchronousWork().catch(function(ex) {
           console.error(ex);
         });
     * @param  The
    function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    catch<R>(errback: Function): promise$Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: Function): promise$Promise<R >
}


/**
 * Represents a value that will be resolved at some point in the future. This
 * class represents the protected "producer" half of a Promise - each Deferred
has a {@code promise} property that may be returned to consumers for
registering callbacks, reserving the ability to resolve the deferred to the
producer.

<p>If this Deferred is rejected and there are no listeners registered before
the next turn of the event loop, the rejection will be passed to the
{
 * @link  webdriver.promise.ControlFlow} as an unhandled failure.

<p>If this Deferred is cancelled, the cancellation reason will be forward to
the Deferred's canceller function (if provided). The canceller may return a
truth-y value to override the reason provided for rejection.
 * @extends  {webdriver.promise.Promise}
*/
declare class Deferred<T>mixins Promise<T>{

    /**
     * 
     * @param  The control flow
    this instance was created under. This should only be provided during
    unit tests.
     * @constructor  
    */
    constructor(opt_flow?: promise$ControlFlow): this;
    State_: {
        BLOCKED: number,
        PENDING: number,
        REJECTED: number,
        RESOLVED: number
    };

    /**
     * The consumer promise for this instance. Provides protected access to the
     * callback registering functions.
     * @type  
     */
    promise: promise$Promise<T>;

    /**
     * Rejects this promise. If the error is itself a promise, this instance will
     * be chained to it and be rejected with the error's resolved value.*=} opt_error The rejection reason, typically either a
        {
     * @code  Error} or a {
     * @code  string}.
    */
    reject(opt_error?: any): void;
    errback(opt_error?: any): void;

    /**
     * Resolves this promise with the given value. If the value is itself a
     * promise and not a reference to this deferred, this instance will wait for
    it before resolving.*=} opt_value The resolved value.
    */
    fulfill(opt_value?: T): void;

    /**
     * Removes all of the listeners previously registered on this deferred.
     * @throws  {Error} If this deferred has already been resolved.
     */
    removeAll(): void
}

declare interface promise$IControlFlowTimer {
    clearInterval: (ms: number) => void,
        clearTimeout: (ms: number) => void,
        setInterval: (fn: Function, ms: number) => number,
        setTimeout: (fn: Function, ms: number) => number
}


/**
 * Handles the execution of scheduled tasks, each of which may be an
 * asynchronous operation. The control flow will ensure tasks are executed in
the ordered scheduled, starting each task only once those before it have
completed.

Each task scheduled within this flow may return a
{
 * @link  webdriver.promise.Promise} to indicate it is an asynchronous
operation. The ControlFlow will wait for such promises to be resolved before
marking the task as completed.

Tasks and each callback registered on a {
 * @link  webdriver.promise.Promise}
will be run in their own ControlFlow frame.  Any tasks scheduled within a
frame will take priority over previously scheduled tasks. Furthermore, if any
of the tasks in the frame fail, the remainder of the tasks in that frame will
be discarded and the failure will be propagated to the user through the
callback/task's promised result.

Each time a ControlFlow empties its task queue, it will fire an
{
 * @link  webdriver.promise.ControlFlow.EventType.IDLE IDLE} event. Conversely,
whenever the flow terminates due to an unhandled error, it will remove all
remaining tasks in its queue and fire an
{
 * @link  webdriver.promise.ControlFlow.EventType.UNCAUGHT_EXCEPTION
UNCAUGHT_EXCEPTION} event. If there are no listeners registered with the
flow, the error will be rethrown to the global error handler.
 * @extends  {EventEmitter}
 * @final  
*/
declare class ControlFlow mixins EventEmitter {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Events that may be emitted by an {@link webdriver.promise.ControlFlow}.
     * @enum  {string}
     */
    EventType: {

        /**
         * Emitted when all tasks have been successfully executed. 
         */
        IDLE: string,

        /**
         * Emitted when a ControlFlow has been reset. 
         */
        RESET: string,

        /**
         * Emitted whenever a new task has been scheduled. 
         */
        SCHEDULE_TASK: string,

        /**
         * Emitted whenever a control flow aborts due to an unhandled promise
         * rejection. This event will be emitted along with the offending rejection
        reason. Upon emitting this event, the control flow will empty its task
        queue and revert to its initial state.
        */
        UNCAUGHT_EXCEPTION: string
    };

    /**
     * Returns a string representation of this control flow, which is its current
     * {
     * @link  #getSchedule() schedule}, sans task stack traces.
     * @return  The string representation of this contorl flow.
     * @override  
     */
    toString(): string;

    /**
     * Resets this instance, clearing its queue and removing all event listeners.
     */
    reset(): void;

    /**
     * Generates an annotated string describing the internal state of this control
     * flow, including the currently executing as well as pending tasks. If
    {
     * @code  opt_includeStackTraces === true}, the string will include the
    stack trace from when each task was scheduled.
     * @param  Whether to include the stack traces
    from when each task was scheduled. Defaults to false.
     * @return  String representation of this flow's internal state.
    */
    getSchedule(opt_includeStackTraces?: boolean): string;

    /**
     * Schedules a task for execution. If there is nothing currently in the
     * queue, the task will be executed in the next turn of the event loop. If
    the task function is a generator, the task will be executed using
    {<T>)} fn The function to
      call to start the task. If the function returns a
      {
     * @link  webdriver.promise.consume}.
     * @link  webdriver.promise.Promise}, this instance will wait for it to be
    resolved before starting the next task.
     * @param  A description of the task.
     * @return  <T>} A promise that will be resolved
    with the result of the action.
     * @template  
    */
    execute<T>(
        fn: () => (T | promise$Promise<T>),
        opt_description?: string): promise$Promise<T>;

    /**
     * Inserts a {@code setTimeout} into the command queue. This is equivalent to
     * a thread sleep in a synchronous programming language.
     * @param  The timeout delay, in milliseconds.
     * @param  A description to accompany the timeout.
     * @return  A promise that will be resolved with
    the result of the action.
    */
    timeout(ms: number, opt_description?: string): promise$Promise<void>;

    /**
     * Schedules a task that shall wait for a condition to hold. Each condition
     * function may return any value, but it will always be evaluated as a boolean.

    Condition functions may schedule sub-tasks with this instance, however,
    their execution time will be factored into whether a wait has timed out.

    In the event a condition returns a Promise, the polling loop will wait for
    it to be resolved before evaluating whether the condition has been satisfied.
    The resolution time for a promise is factored into whether a wait has timed
    out.

    If the condition function throws, or returns a rejected promise, the
    wait task will fail.

    If the condition is defined as a promise, the flow will wait for it to
    settle. If the timeout expires before the promise settles, the promise
    returned by this function will be rejected.

    If this function is invoked with `timeout === 0`, or the timeout is omitted,
    the flow will wait indefinitely for the condition to be satisfied.<T>|function())} condition The condition to poll,
        or a promise to wait on.
     * @param  How long to wait, in milliseconds, for the
    condition to hold before timing out. If omitted, the flow will wait
    indefinitely.
     * @param  An optional error message to include if the
    wait times out; defaults to the empty string.
     * @return  <T>} A promise that will be fulfilled
    when the condition has been satisified. The promise shall be rejected if
    the wait times out waiting for the condition.
     * @throws  {TypeError} If condition is not a function or promise or if timeout
    is not a number >= 0.
     * @template  
    */
    wait<T>(
        condition: promise$Promise<T>| Function,
        opt_timeout?: number,
        opt_message?: string): promise$Promise<T >
}


declare var npm$namespace$until: {
        ableToSwitchToFrame: typeof until$ableToSwitchToFrame,
        alertIsPresent: typeof until$alertIsPresent,
        elementIsDisabled: typeof until$elementIsDisabled,
        elementIsEnabled: typeof until$elementIsEnabled,
        elementIsNotSelected: typeof until$elementIsNotSelected,
        elementIsNotVisible: typeof until$elementIsNotVisible,
        elementIsSelected: typeof until$elementIsSelected,
        elementIsVisible: typeof until$elementIsVisible,
        elementLocated: typeof until$elementLocated,
        elementTextContains: typeof until$elementTextContains,
        elementTextIs: typeof until$elementTextIs,
        elementTextMatches: typeof until$elementTextMatches,
        elementsLocated: typeof until$elementsLocated,
        stalenessOf: typeof until$stalenessOf,
        titleContains: typeof until$titleContains,
        titleIs: typeof until$titleIs,
        titleMatches: typeof until$titleMatches,
    }
    /**
     * Defines a condition to
     */
declare class Condition<T>{

    /**
     * 
     * @param  A descriptive error message. Should complete the
    sentence "Waiting [...]"
     * @param  The condition function to
    evaluate on each iteration of the wait loop.
     * @constructor  
    */
    constructor(message: string, fn: (webdriver: webdriver$WebDriver) => any): this;

    /**
     * 
     * @return  A description of this condition. 
     */
    description(): string;

    /**
     * 
     * @type  
     */
    fn(webdriver: webdriver$WebDriver): any
}


/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as

1. a numeric index into
     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)
     for the currently selected frame.
2. a {@link ./webdriver.WebElement}, which must reference a FRAME or IFRAME
     element on the current page.
3. a locator which may be used to first locate a FRAME or IFRAME on the
     current page before attempting to switch to it.

Upon successful resolution of this condition, the driver will be left
focused on the new frame./webdriver.WebElement|By|
          function(!./webdriver.WebDriver): !./webdriver.WebElement)} frame
    The frame identifier.
 * @return  A new condition.
*/
declare function until$ableToSwitchToFrame(
    frame: number | webdriver$WebElement | webdriver$By | ((webdriver: webdriver$WebDriver) => webdriver$WebElement)): until$Condition<boolean >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  /webdriver.Alert>} The new condition.
     */
    declare function until$alertIsPresent(): until$Condition<webdriver$Alert >


    /**
     * Creates a condition that will wait for the given element to be disabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsDisabled(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be enabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsEnabled(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be deselected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsNotSelected(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be in the DOM,
     * yet not visible to the user.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsNotVisible(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be selected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsSelected(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to become visible.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsVisible(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will loop until an element is
     * {
     * @link  ./webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator to use.
     * @return  The new condition.
     */
    declare function until$elementLocated(locator: webdriver$By | Function): until$Condition<webdriver$WebElement >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to contain the given
    substring.
     * @param  The element to test.
     * @param  The substring to search for.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextContains(element: webdriver$WebElement, substr: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match the given
    {
     * @code  text} exactly.
     * @param  The element to test.
     * @param  The expected text.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextIs(element: webdriver$WebElement, text: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match a regular
    expression.
     * @param  The element to test.
     * @param  The regular expression to test against.
     * @return  <boolean>} The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextMatches(element: webdriver$WebElement, regex: RegExp): until$Condition<boolean >


    /**
     * Creates a condition that will loop until at least one element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new
    condition.
    */
    declare function until$elementsLocated(locator: webdriver$By | Function): until$Condition<webdriver$WebElement[] >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  <boolean>} The new condition.
    */
    declare function until$stalenessOf(element: webdriver$WebElement): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare function until$titleContains(substr: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  <boolean>} The new condition.
     */
    declare function until$titleIs(title: string): until$Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given regular expression.
     * @param  The regular expression to test against.
     * @return  The new condition.
     */
    declare function until$titleMatches(regex: RegExp): until$Condition<boolean >

    declare interface webdriver$ILocation {
        x: number,
            y: number
    }

declare interface webdriver$ISize {
    width: number,
        height: number
}


/**
 * Class for defining sequences of complex user interactions. Each sequence
 * will not be executed until {@link #perform} is called.

Example:

     new ActionSequence(driver).
         keyDown(Key.SHIFT).
         click(element1).
         click(element2).
         dragAndDrop(element3, element4).
         keyUp(Key.SHIFT).
         perform();
*/
declare class ActionSequence {

    /**
     * 
     * @param  The driver instance to use.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Executes this action sequence.
     * @return  A promise that will be resolved once
    this sequence has completed.
    */
    perform(): undefined.Promise<void>;

    /**
     * Moves the mouse.  The location to move to may be specified in terms of the
     * mouse's current location, an offset relative to the top-left corner of an
    element, or an element (in which case the middle of the element is used)./webdriver.WebElement|{x: number, y: number})} location The
        location to drag to, as either another WebElement or an offset in
        pixels.
     * @param  If the target {
     * @code  location}
    is defined as a {
     * @link  ./webdriver.WebElement}, this parameter defines
    an offset within that element. The offset should be specified in pixels
    relative to the top-left corner of the element's bounding box. If
    omitted, the element's center will be used as the target offset.
     * @return  A self reference.
    */
    mouseMove(
        location: webdriver$WebElement | webdriver$ILocation,
        opt_offset?: webdriver$ILocation): webdriver$ActionSequence;

    /**
     * Presses a mouse button. The mouse button will not be released until
     * {/webdriver.WebElement|input.Button)=} opt_elementOrButton Either
      the element to interact with or the button to click with.
      Defaults to {@link input.Button.LEFT} if neither an element nor
      button is specified.
     * @link  #mouseUp} is called, regardless of whether that call is made in this
    sequence or another. The behavior for out-of-order events (e.g. mouseDown,
    click) is undefined.

    If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:

    sequence.mouseMove(element).mouseDown()

    Warning: this method currently only supports the left mouse button. See
    [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047).
     * @param  The button to use. Defaults to
    {
     * @link  input.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    mouseDown(
        opt_elementOrButton?: webdriver$WebElement | webdriver$Button,
        opt_button?: webdriver$Button): webdriver$ActionSequence;

    /**
     * Releases a mouse button. Behavior is undefined for calling this function
     * without a previous call to {@link #mouseDown}.

    If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:

         sequence.mouseMove(element).mouseUp()

    Warning: this method currently only supports the left mouse button. See
    [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047)./webdriver.WebElement|input.Button)=} opt_elementOrButton Either
        the element to interact with or the button to click with.
        Defaults to {@link input.Button.LEFT} if neither an element nor
        button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  input.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    mouseUp(
        opt_elementOrButton?: webdriver$WebElement | webdriver$Button,
        opt_button?: webdriver$Button): webdriver$ActionSequence;

    /**
     * Convenience function for performing a "drag and drop" manuever. The target
     * element may be moved to the location of another element, or by an offset (in
    pixels)./webdriver.WebElement} element The element to drag./webdriver.WebElement|{x: number, y: number})} location The
        location to drag to, either as another WebElement or an offset in
        pixels.
     * @return  A self reference.
    */
    dragAndDrop(
        element: webdriver$WebElement,
        location: webdriver$WebElement | webdriver$ILocation): webdriver$ActionSequence;

    /**
     * Clicks a mouse button.
     * 
    If an element is provided, the mouse will first be moved to the center
    of that element. This is equivalent to:

         sequence.mouseMove(element).click()/webdriver.WebElement|input.Button)=} opt_elementOrButton Either
        the element to interact with or the button to click with.
        Defaults to {@link input.Button.LEFT} if neither an element nor
        button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  input.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    click(
        opt_elementOrButton?: webdriver$WebElement | webdriver$Button,
        opt_button?: webdriver$Button): webdriver$ActionSequence;

    /**
     * Double-clicks a mouse button.
     * 
    If an element is provided, the mouse will first be moved to the center of
    that element. This is equivalent to:

         sequence.mouseMove(element).doubleClick()

    Warning: this method currently only supports the left mouse button. See
    [issue 4047](http://code.google.com/p/selenium/issues/detail?id=4047)./webdriver.WebElement|input.Button)=} opt_elementOrButton Either
        the element to interact with or the button to click with.
        Defaults to {@link input.Button.LEFT} if neither an element nor
        button is specified.
     * @param  The button to use. Defaults to
    {
     * @link  input.Button.LEFT}. Ignored if a button is provided as the
    first argument.
     * @return  A self reference.
    */
    doubleClick(
        opt_elementOrButton?: webdriver$WebElement | webdriver$Button,
        opt_button?: webdriver$Button): webdriver$ActionSequence;

    /**
     * Performs a modifier key press. The modifier key is <em>not released</em>
     * until {@link #keyUp} or {@link #sendKeys} is called. The key press will be
    targetted at the currently focused element.
     * @param  The modifier key to push. Must be one of
    {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    keyDown(key: Key): webdriver$ActionSequence;

    /**
     * Performs a modifier key release. The release is targetted at the currently
     * focused element.
     * @param  The modifier key to release. Must be one of
    {ALT, CONTROL, SHIFT, COMMAND, META}.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    keyUp(key: Key): webdriver$ActionSequence;

    /**
     * Simulates typing multiple keys. Each modifier key encountered in the
     * sequence will not be released until it is encountered again. All key events
    will be targetted at the currently focused element.
     * @param  The keys to type.
     * @return  A self reference.
     * @throws  {Error} If the key is not a valid modifier key.
    */
    sendKeys(...var_args: Array<string | Key>): webdriver$ActionSequence
}


/**
 * Class for defining sequences of user touch interactions. Each sequence
 * will not be executed until {@link #perform} is called.

Example:

     new webdriver.TouchSequence(driver).
         tapAndHold({x: 0, y: 0}).
         move({x: 3, y: 4}).
         release({x: 10, y: 10}).
         perform();
*/
declare class TouchSequence {
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Executes this action sequence.
     * @return  A promise that will be resolved once
    this sequence has completed.
    */
    perform(): undefined.Promise<void>;

    /**
     * Taps an element.
     * @param  The element to tap.
     * @return  A self reference.
     */
    tap(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Double taps an element.
     * @param  The element to double tap.
     * @return  A self reference.
     */
    doubleTap(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Long press on an element.
     * @param  The element to long press.
     * @return  A self reference.
     */
    longPress(elem: webdriver$WebElement): webdriver$TouchSequence;

    /**
     * Touch down at the given location.
     * @param  The location to touch down at.
     * @return  A self reference.
     */
    tapAndHold(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Move a held {@linkplain #tapAndHold touch} to the specified location.
     * @param  The location to move to.
     * @return  A self reference.
     */
    move(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Release a held {@linkplain #tapAndHold touch} at the specified location.
     * @param  The location to release at.
     * @return  A self reference.
     */
    release(location: webdriver$ILocation): webdriver$TouchSequence;

    /**
     * Scrolls the touch screen by the given offset.
     * @param  The offset to scroll to.
     * @return  A self reference.
     */
    scroll(offset: webdriver$IOffset): webdriver$TouchSequence;

    /**
     * Scrolls the touch screen, starting on `elem` and moving by the specified
     * offset.
     * @param  The element where scroll starts.
     * @param  The offset to scroll to.
     * @return  A self reference.
     */
    scrollFromElement(elem: webdriver$WebElement, offset: webdriver$IOffset): webdriver$TouchSequence;

    /**
     * Flick, starting anywhere on the screen, at speed xspeed and yspeed.
     * @param  The speed to flick in each
    direction, in pixels per second.
     * @return  A self reference.
    */
    flick(speed: webdriver$ISpeed): webdriver$TouchSequence;

    /**
     * Flick starting at elem and moving by x and y at specified speed.
     * @param  The element where flick starts.
     * @param  The offset to flick to.
     * @param  The speed to flick at in pixels per second.
     * @return  A self reference.
     */
    flickElement(
        elem: webdriver$WebElement,
        offset: webdriver$IOffset,
        speed: number): webdriver$TouchSequence
}

declare interface webdriver$IOffset {
    x: number,
        y: number
}

declare interface webdriver$ISpeed {
    xspeed: number,
        yspeed: number
}


/**
 * Represents a modal dialog such as {@code alert}, {@code confirm}, or
 * {
 * @code  prompt}. Provides functions to retrieve the message displayed with
the alert, accept or dismiss the alert, and set the response text (in the
case of {
 * @code  prompt}).
*/
declare class Alert {

    /**
     * 
     * @param  The driver controlling the browser this alert
    is attached to.
     * @param  The message text displayed with this alert.
    */
    constructor(driver: webdriver$WebDriver, text: string): this;

    /**
     * Retrieves the message text displayed with this alert. For instance, if the
     * alert were opened with alert("hello"), then this would return "hello".
     * @return  A promise that will be resolved to the
    text displayed with this alert.
    */
    getText(): undefined.Promise<string>;

    /**
     * Sets the username and password in an alert prompting for credentials (such
     * as a Basic HTTP Auth prompt). This method will implicitly
    {
     * @linkplain  #accept() submit} the dialog.
     * @param  The username to send.
     * @param  The password to send.
     * @return  <void>} A promise that will be resolved when this
    command has completed.
    */
    authenticateAs(username: string, password: string): undefined.Promise<void>;

    /**
     * Accepts this alert.
     * @return  A promise that will be resolved when
    this command has completed.
    */
    accept(): undefined.Promise<void>;

    /**
     * Dismisses this alert.
     * @return  A promise that will be resolved when
    this command has completed.
    */
    dismiss(): undefined.Promise<void>;

    /**
     * Sets the response text on this alert. This command will return an error if
     * the underlying alert does not support response text (e.g. window.alert and
    window.confirm).
     * @param  The text to set.
     * @return  A promise that will be resolved when
    this command has completed.
    */
    sendKeys(text: string): undefined.Promise<void >
}


/**
 * AlertPromise is a promise that will be fulfilled with an Alert. This promise
 * serves as a forward proxy on an Alert, allowing calls to be scheduled
directly on this instance before the underlying Alert has been fulfilled. In
other words, the following two statements are equivalent:

     driver.switchTo().alert().dismiss();
     driver.switchTo().alert().then(function(alert) {
       return alert.dismiss();
     });
 * @implements  {promise.Thenable.<!webdriver.Alert>}
 * @final  
*/
declare class AlertPromise mixins Alert {

    /**
     * <!Alert>} alert A thenable
     *    that will be fulfilled with the promised alert.
     * @param  The driver controlling the browser this
    alert is attached to.
    */
    constructor(driver: webdriver$WebDriver, alert: undefined.Promise<webdriver$Alert>): this
}


/**
 * 
 * @deprecated  Use {
 * @link  error.UnexpectedAlertOpenError} instead. 
 */
declare class UnhandledAlertError mixins undefined.UnexpectedAlertOpenError {}


/**
 * Recognized browser names.
 * @enum  {string}
 */
declare interface webdriver$IBrowser {
    ANDROID: string,
        CHROME: string,
        EDGE: string,
        FIREFOX: string,
        IE: string,
        INTERNET_EXPLORER: string,
        IPAD: string,
        IPHONE: string,
        OPERA: string,
        PHANTOM_JS: string,
        SAFARI: string,
        HTMLUNIT: string
}

declare var Browser: webdriver$IBrowser;

declare interface webdriver$ProxyConfig {
    proxyType: string,
        proxyAutoconfigUrl?: string,
        ftpProxy?: string,
        httpProxy?: string,
        sslProxy?: string,
        noProxy?: string
}


/**
 * Creates new {@link webdriver.WebDriver WebDriver} instances. The environment
 * variables listed below may be used to override a builder's configuration,
allowing quick runtime changes.

- {
 * @code  SELENIUM_BROWSER}: defines the target browser in the form
{
 * @code  browser[:version][:platform]}.

- {
 * @code  SELENIUM_REMOTE_URL}: defines the remote URL for all builder
instances. This environment variable should be set to a fully qualified
URL for a WebDriver server (e.g. http://localhost:4444/wd/hub). This
option always takes precedence over {
 * @code  SELENIUM_SERVER_JAR}.

- {
 * @code  SELENIUM_SERVER_JAR}: defines the path to the
<a href="http://selenium-release.storage.googleapis.com/index.html">
standalone Selenium server</a> jar to use. The server will be started the
first time a WebDriver instance and be killed when the process exits.

Suppose you had mytest.js that created WebDriver with

var driver = new webdriver.Builder()
.forBrowser('chrome')
.build();

This test could be made to use Firefox on the local machine by running with
`SELENIUM_BROWSER=firefox node mytest.js`. Rather than change the code to
target Google Chrome on a remote machine, you can simply set the
`SELENIUM_BROWSER` and `SELENIUM_REMOTE_URL` environment variables:

SELENIUM_BROWSER=chrome:36:LINUX \
SELENIUM_REMOTE_URL=http://www.example.com:4444/wd/hub \
node mytest.js

You could also use a local copy of the standalone Selenium server:

SELENIUM_BROWSER=chrome:36:LINUX \
SELENIUM_SERVER_JAR=/path/to/selenium-server-standalone.jar \
node mytest.js
*/
declare class Builder {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Configures this builder to ignore any environment variable overrides and to
     * only use the configuration specified through this instance's API.
     * @return  A self reference.
     */
    disableEnvironmentOverrides(): webdriver$Builder;

    /**
     * Creates a new WebDriver client based on this builder's current
     * configuration.

    While this method will immediately return a new WebDriver instance, any
    commands issued against it will be deferred until the associated browser
    has been fully initialized. Users may call {@link #buildAsync()} to obtain
    a promise that will not be fulfilled until the browser has been created
    (the difference is purely in style).
     * @return  A new WebDriver instance.
     * @throws  {Error} If the current configuration is invalid.
     * @see  #buildAsync()
    */
    build(): webdriver$WebDriver;

    /**
     * Creates a new WebDriver client based on this builder's current
     * configuration. This method returns a promise that will not be fulfilled
    until the new browser session has been fully initialized.

    __Note:__ this method is purely a convenience wrapper around
    {
     * @link  #build()}.
     * @return  <!webdriver.WebDriver>} A promise that will be
    fulfilled with the newly created WebDriver instance once the browser
    has been fully initialized.
     * @see  #build()
    */
    buildAsync(): undefined.Promise<webdriver$WebDriver>;

    /**
     * Configures the target browser for clients created by this instance.
     * Any calls to {@link #withCapabilities} after this function will
    overwrite these settings.

    <p>You may also define the target browser using the {@code SELENIUM_BROWSER}
    environment variable. If set, this environment variable should be of the
    form {@code browser[:[version][:platform]]}.
     * @param  The name of the target browser;
    common defaults are available on the {
     * @link  webdriver.Browser} enum.
     * @param  A desired version; may be omitted if any
    version should be used.
     * @param  The desired platform; may be omitted if any
    version may be used.
     * @return  A self reference.
    */
    forBrowser(name: string, opt_version?: string, opt_platform?: string): webdriver$Builder;

    /**
     * Returns the base set of capabilities this instance is currently configured
     * to use.
     * @return  The current capabilities for this builder.
     */
    getCapabilities(): webdriver$Capabilities;

    /**
     * 
     * @return  The URL of the WebDriver server this instance is configured
    to use.
    */
    getServerUrl(): string;

    /**
     * 
     * @return  The URL of the proxy server to use for the WebDriver's
    HTTP connections, or `null` if not set.
    */
    getWebDriverProxy(): string;

    /**
     * Sets the default action to take with an unexpected alert before returning
     * an error.
     * @param  The desired behavior; should be "accept", "dismiss",
    or "ignore". Defaults to "dismiss".
     * @return  A self reference.
    */
    setAlertBehavior(behavior: string): webdriver$Builder;

    /**
     * Sets Chrome-specific options for drivers created by this builder. Any
     * logging or proxy settings defined on the given options will take precedence
    over those set through {@link #setLoggingPrefs} and {@link #setProxy},
    respectively.
     * @param  The ChromeDriver options to use.
     * @return  A self reference.
    */
    setChromeOptions(options: chrome$Options): webdriver$Builder;

    /**
     * Sets the control flow that created drivers should execute actions in. If
     * the flow is never set, or is set to {@code null}, it will use the active
    flow at the time {@link #build()} is called.
     * @param  The control flow to use, or
    {
     * @code  null} to
     * @return  A self reference.
    */
    setControlFlow(flow: undefined.ControlFlow): webdriver$Builder;

    /**
     * Set {@linkplain edge.Options options} specific to Microsoft's Edge browser
     * for drivers created by this builder. Any proxy settings defined on the
    given options will take precedence over those set through
    {
     * @link  #setProxy}.
     * @param  The MicrosoftEdgeDriver options to use.
     * @return  A self reference.
    */
    setEdgeOptions(options: edge$Options): webdriver$Builder;

    /**
     * Sets whether native events should be used.
     * @param  Whether to enable native events.
     * @return  A self reference.
     */
    setEnableNativeEvents(enabled: boolean): webdriver$Builder;

    /**
     * Sets Firefox-specific options for drivers created by this builder. Any
     * logging or proxy settings defined on the given options will take precedence
    over those set through {@link #setLoggingPrefs} and {@link #setProxy},
    respectively.
     * @param  The FirefoxDriver options to use.
     * @return  A self reference.
    */
    setFirefoxOptions(options: firefox$Options): webdriver$Builder;

    /**
     * Set Internet Explorer specific {@linkplain ie.Options options} for drivers
     * created by this builder. Any proxy settings defined on the given options
    will take precedence over those set through {@link #setProxy}.
     * @param  The IEDriver options to use.
     * @return  A self reference.
    */
    setIeOptions(options: ie$Options): webdriver$Builder;

    /**
     * Sets the logging preferences for the created session. Preferences may be
     * changed by repeated calls, or by calling {@link #withCapabilities}.
     * @param  The
    desired logging preferences.
     * @return  A self reference.
    */
    setLoggingPrefs(prefs: undefined.Preferences | Object): webdriver$Builder;

    /**
     * Sets Opera specific {@linkplain opera.Options options} for drivers created
     * by this builder. Any logging or proxy settings defined on the given options
    will take precedence over those set through {@link #setLoggingPrefs} and
    {
     * @link  #setProxy}, respectively.
     * @param  The OperaDriver options to use.
     * @return  A self reference.
    */
    setOperaOptions(options: opera$Options): webdriver$Builder;

    /**
     * Sets the proxy configuration to use for WebDriver clients created by this
     * builder. Any calls to {@link #withCapabilities} after this function will
    overwrite these settings.
     * @param  The configuration to use.
     * @return  A self reference.
    */
    setProxy(config: webdriver$ProxyConfig): webdriver$Builder;

    /**
     * Sets Safari specific {@linkplain safari.Options options} for drivers
     * created by this builder. Any logging settings defined on the given options
    will take precedence over those set through {@link #setLoggingPrefs}.
     * @param  The Safari options to use.
     * @return  A self reference.
    */
    setSafari(options: safari$Options): webdriver$Builder;

    /**
     * Sets how elements should be scrolled into view for interaction.
     * @param  The desired scroll behavior: either 0 to align with
    the top of the viewport or 1 to align with the bottom.
     * @return  A self reference.
    */
    setScrollBehavior(behavior: number): webdriver$Builder;

    /**
     * Sets the URL of a remote WebDriver server to use. Once a remote URL has been
     * specified, the builder direct all new clients to that server. If this method
    is never called, the Builder will attempt to create all clients locally.

    <p>As an alternative to this method, you may also set the
    {
     * @code  SELENIUM_REMOTE_URL} environment variable.
     * @param  The URL of a remote server to use.
     * @return  A self reference.
    */
    usingServer(url: string): webdriver$Builder;

    /**
     * Sets the URL of the proxy to use for the WebDriver's HTTP connections.
     * If this method is never called, the Builder will create a connection
    without a proxy.
     * @param  The URL of a proxy to use.
     * @return  A self reference.
    */
    usingWebDriverProxy(proxy: string): webdriver$Builder;

    /**
     * Sets the desired capabilities when requesting a new session. This will
     * overwrite any previously set capabilities.
     * @param  The desired
    capabilities for a new session.
     * @return  A self reference.
    */
    withCapabilities(capabilities: Object | webdriver$Capabilities): webdriver$Builder
}


/**
 * Describes a mechanism for locating an element on the page.
 * @final  
 */
declare class By {

    /**
     * 
     * @param  the name of the location strategy to use.
     * @param  the value to search for.
     */
    constructor(using: string, value: string): this;

    /**
     * Locates elements that have a specific class name.
     * @param  The class name to search for.
     * @return  The new locator.
     * @see  http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
     * @see  http://www.w3.org/TR/CSS2/selector.html#class-html
     */
    className(name: string): webdriver$By;

    /**
     * Locates elements using a CSS selector.
     * @param  The CSS selector to use.
     * @return  The new locator.
     * @see  http://www.w3.org/TR/CSS2/selector.html
     */
    css(selector: string): webdriver$By;

    /**
     * Locates eleemnts by the ID attribute. This locator uses the CSS selector
     * `*[id="$ID"]`, _not_ `document.getElementById`.
     * @param  The ID to search for.
     * @return  The new locator.
     */
    id(id: string): webdriver$By;

    /**
     * Locates link elements whose
     * {
     * @linkplain  webdriver.WebElement#getText visible text} matches the given
    string.
     * @param  The link text to search for.
     * @return  The new locator.
    */
    linkText(text: string): webdriver$By;

    /**
     * Locates an elements by evaluating a
     * {
     * @linkplain  webdriver.WebDriver#executeScript JavaScript expression}.
    The result of this expression must be an element or list of elements.
     * @param  The script to execute.
     * @param  The arguments to pass to the script.
     * @return  /webdriver.WebDriver): !./promise.Promise}
    A new JavaScript-based locator function.
    */
    js(
        script: string | Function,
        ...var_args: Array<any>): (webdriver: webdriver$WebDriver) => undefined.Promise<any>;

    /**
     * Locates elements whose `name` attribute has the given value.
     * @param  The name attribute to search for.
     * @return  The new locator.
     */
    name(name: string): webdriver$By;

    /**
     * Locates link elements whose
     * {
     * @linkplain  webdriver.WebElement#getText visible text} contains the given
    substring.
     * @param  The substring to check for in a link's visible text.
     * @return  The new locator.
    */
    partialLinkText(text: string): webdriver$By;

    /**
     * Locates elements with a given tag name.
     * @param  The tag name to search for.
     * @return  The new locator.
     * @deprecated  Use {
     * @link  By.css() By.css(tagName)} instead.
     */
    tagName(name: string): webdriver$By;

    /**
     * Locates elements matching a XPath selector. Care should be taken when
     * using an XPath selector with a {@link webdriver.WebElement} as WebDriver
    will respect the context in the specified in the selector. For example,
    given the selector `//div`, WebDriver will search from the document root
    regardless of whether the locator was used with a WebElement.
     * @param  The XPath selector to use.
     * @return  The new locator.
     * @see  http://www.w3.org/TR/xpath/
    */
    xpath(xpath: string): webdriver$By;

    /**
     * 
     * @override  
     */
    toString(): string
}


/**
 * Short-hand expressions for the primary element locator strategies.
 * For example the following two statements are equivalent:

     var e1 = driver.findElement(webdriver.By.id('foo'));
     var e2 = driver.findElement({id: 'foo'});

Care should be taken when using JavaScript minifiers (such as the
Closure compiler), as locator hashes will always be parsed using
the un-obfuscated properties listed.
 * @typedef  {className: string}|
{css: string}|
{id: string}|
{js: string}|
{linkText: string}|
{name: string}|
{partialLinkText: string}|
{tagName: string}|
{xpath: string})}
*/
declare type webdriver$ByHash = {
        className: string
    } |
    {
        css: string
    } |
    {
        id: string
    } |
    {
        js: string
    } |
    {
        linkText: string
    } |
    {
        name: string
    } |
    {
        partialLinkText: string
    } |
    {
        tagName: string
    } |
    {
        xpath: string
    };


/**
 * Common webdriver capability keys.
 * @enum  {string}
 */
declare interface webdriver$ICapability {

    /**
     * Indicates whether a driver should accept all SSL certs by default. This
     * capability only applies when requesting a new session. To query whether
    a driver can handle insecure SSL certs, see
    {
     * @link  webdriver.Capability.SECURE_SSL}.
    */
    ACCEPT_SSL_CERTS: string,

        /**
         * The browser name. Common browser names are defined in the
         * {
         * @link  webdriver.Browser} enum.
         */
        BROWSER_NAME: string,

        /**
         * Defines how elements should be scrolled into the viewport for interaction.
         * This capability will be set to zero (0) if elements are aligned with the
        top of the viewport, or one (1) if aligned with the bottom. The default
        behavior is to align with the top of the viewport.
        */
        ELEMENT_SCROLL_BEHAVIOR: string,

        /**
         * Whether the driver is capable of handling modal alerts (e.g. alert,
         * confirm, prompt). To define how a driver <i>should</i> handle alerts,
        use {@link webdriver.Capability.UNEXPECTED_ALERT_BEHAVIOR}.
        */
        HANDLES_ALERTS: string,

        /**
         * Key for the logging driver logging preferences.
         */
        LOGGING_PREFS: string,

        /**
         * Whether this session generates native events when simulating user input.
         *   
         */
        NATIVE_EVENTS: string,

        /**
         * Describes the platform the browser is running on. Will be one of
         * ANDROID, IOS, LINUX, MAC, UNIX, or WINDOWS. When <i>requesting</i> a
        session, ANY may be used to indicate no platform preference (this is
        semantically equivalent to omitting the platform capability).
        */
        PLATFORM: string,

        /**
         * Describes the proxy configuration to use for a new WebDriver session.
         */
        PROXY: string,

        /**
         * Whether the driver supports changing the brower's orientation. 
         */
        ROTATABLE: string,

        /**
         * Whether a driver is only capable of handling secure SSL certs. To request
         * that a driver accept insecure SSL certs by default, use
        {
         * @link  webdriver.Capability.ACCEPT_SSL_CERTS}.
        */
        SECURE_SSL: string,

        /**
         * Whether the driver supports manipulating the app cache. 
         */
        SUPPORTS_APPLICATION_CACHE: string,

        /**
         * Whether the driver supports locating elements with CSS selectors. 
         */
        SUPPORTS_CSS_SELECTORS: string,

        /**
         * Whether the browser supports JavaScript. 
         */
        SUPPORTS_JAVASCRIPT: string,

        /**
         * Whether the driver supports controlling the browser's location info. 
         */
        SUPPORTS_LOCATION_CONTEXT: string,

        /**
         * Whether the driver supports taking screenshots. 
         */
        TAKES_SCREENSHOT: string,

        /**
         * Defines how the driver should handle unexpected alerts. The value should
         * be one of "accept", "dismiss", or "ignore.
         */
        UNEXPECTED_ALERT_BEHAVIOR: string,

        /**
         * Defines the browser version. 
         */
        VERSION: string
}

declare var Capability: webdriver$ICapability;

declare class Capabilities {

    /**
     * 
     * @param  Another set of
    capabilities to merge into this instance.
     * @constructor  
    */
    constructor(opt_other?: webdriver$Capabilities | Object): this;

    /**
     * 
     * @return  The JSON representation of this instance. 
     */
    toJSON(): any;

    /**
     * Merges another set of capabilities into this instance. Any duplicates in
     * the provided set will override those already set on this instance.
     * @param  The capabilities to
    merge into this instance.
     * @return  A self reference.
    */
    merge(other: webdriver$Capabilities | Object): webdriver$Capabilities;

    /**
     * 
     * @param  The capability to set.
     * @param  The capability value.  Capability values must be JSON
    serializable. Pass {
     * @code  null} to unset the capability.
     * @return  A self reference.
    */
    set(key: string, value: any): webdriver$Capabilities;

    /**
     * Sets the logging preferences. Preferences may be specified as a
     * {
     * @link  webdriver.logging.Preferences} instance, or a as a map of log-type to
    log-level.
     * @param  The
    logging preferences.
     * @return  A self reference.
    */
    setLoggingPrefs(prefs: undefined.Preferences | Object): webdriver$Capabilities;

    /**
     * Sets the proxy configuration for this instance.
     * @param  The desired proxy configuration.
     * @return  A self reference.
     */
    setProxy(proxy: webdriver$ProxyConfig): webdriver$Capabilities;

    /**
     * Sets whether native events should be used.
     * @param  Whether to enable native events.
     * @return  A self reference.
     */
    setEnableNativeEvents(enabled: boolean): webdriver$Capabilities;

    /**
     * Sets how elements should be scrolled into view for interaction.
     * @param  The desired scroll behavior: either 0 to align with
    the top of the viewport or 1 to align with the bottom.
     * @return  A self reference.
    */
    setScrollBehavior(behavior: number): webdriver$Capabilities;

    /**
     * Sets the default action to take with an unexpected alert before returning
     * an error.
     * @param  The desired behavior; should be "accept", "dismiss",
    or "ignore". Defaults to "dismiss".
     * @return  A self reference.
    */
    setAlertBehavior(behavior: string): webdriver$Capabilities;

    /**
     * 
     * @param  The capability to return.
     * @return  The capability with the given key, or {
     * @code  null} if it has
    not been set.
    */
    get(key: string): any;

    /**
     * 
     * @param  The capability to check.
     * @return  Whether the specified capability is set.
     */
    has(key: string): boolean;

    /**
     * 
     * @return  A basic set of capabilities for Android.
     */
    android(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Chrome.
     */
    chrome(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Microsoft Edge.
     */
    edge(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Firefox.
     */
    firefox(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for
    Internet Explorer.
    */
    ie(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for iPad.
     */
    ipad(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for iPhone.
     */
    iphone(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Opera.
     */
    opera(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for
    PhantomJS.
    */
    phantomjs(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for Safari.
     */
    safari(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for HTMLUnit.
     */
    htmlunit(): webdriver$Capabilities;

    /**
     * 
     * @return  A basic set of capabilities for HTMLUnit
      with enabled Javascript.
    */
    htmlunitwithjs(): webdriver$Capabilities
}


/**
 * An enumeration of valid command string.
 */
declare interface webdriver$ICommandName {
    GET_SERVER_STATUS: string,
        NEW_SESSION: string,
        GET_SESSIONS: string,
        DESCRIBE_SESSION: string,
        CLOSE: string,
        QUIT: string,
        GET_CURRENT_URL: string,
        GET: string,
        GO_BACK: string,
        GO_FORWARD: string,
        REFRESH: string,
        ADD_COOKIE: string,
        GET_COOKIE: string,
        GET_ALL_COOKIES: string,
        DELETE_COOKIE: string,
        DELETE_ALL_COOKIES: string,
        GET_ACTIVE_ELEMENT: string,
        FIND_ELEMENT: string,
        FIND_ELEMENTS: string,
        FIND_CHILD_ELEMENT: string,
        FIND_CHILD_ELEMENTS: string,
        CLEAR_ELEMENT: string,
        CLICK_ELEMENT: string,
        SEND_KEYS_TO_ELEMENT: string,
        SUBMIT_ELEMENT: string,
        GET_CURRENT_WINDOW_HANDLE: string,
        GET_WINDOW_HANDLES: string,
        GET_WINDOW_POSITION: string,
        SET_WINDOW_POSITION: string,
        GET_WINDOW_SIZE: string,
        SET_WINDOW_SIZE: string,
        MAXIMIZE_WINDOW: string,
        SWITCH_TO_WINDOW: string,
        SWITCH_TO_FRAME: string,
        GET_PAGE_SOURCE: string,
        GET_TITLE: string,
        EXECUTE_SCRIPT: string,
        EXECUTE_ASYNC_SCRIPT: string,
        GET_ELEMENT_TEXT: string,
        GET_ELEMENT_TAG_NAME: string,
        IS_ELEMENT_SELECTED: string,
        IS_ELEMENT_ENABLED: string,
        IS_ELEMENT_DISPLAYED: string,
        GET_ELEMENT_LOCATION: string,
        GET_ELEMENT_LOCATION_IN_VIEW: string,
        GET_ELEMENT_SIZE: string,
        GET_ELEMENT_ATTRIBUTE: string,
        GET_ELEMENT_VALUE_OF_CSS_PROPERTY: string,
        ELEMENT_EQUALS: string,
        SCREENSHOT: string,
        IMPLICITLY_WAIT: string,
        SET_SCRIPT_TIMEOUT: string,
        SET_TIMEOUT: string,
        ACCEPT_ALERT: string,
        DISMISS_ALERT: string,
        GET_ALERT_TEXT: string,
        SET_ALERT_TEXT: string,
        EXECUTE_SQL: string,
        GET_LOCATION: string,
        SET_LOCATION: string,
        GET_APP_CACHE: string,
        GET_APP_CACHE_STATUS: string,
        CLEAR_APP_CACHE: string,
        IS_BROWSER_ONLINE: string,
        SET_BROWSER_ONLINE: string,
        GET_LOCAL_STORAGE_ITEM: string,
        GET_LOCAL_STORAGE_KEYS: string,
        SET_LOCAL_STORAGE_ITEM: string,
        REMOVE_LOCAL_STORAGE_ITEM: string,
        CLEAR_LOCAL_STORAGE: string,
        GET_LOCAL_STORAGE_SIZE: string,
        GET_SESSION_STORAGE_ITEM: string,
        GET_SESSION_STORAGE_KEYS: string,
        SET_SESSION_STORAGE_ITEM: string,
        REMOVE_SESSION_STORAGE_ITEM: string,
        CLEAR_SESSION_STORAGE: string,
        GET_SESSION_STORAGE_SIZE: string,
        SET_SCREEN_ORIENTATION: string,
        GET_SCREEN_ORIENTATION: string,
        CLICK: string,
        DOUBLE_CLICK: string,
        MOUSE_DOWN: string,
        MOUSE_UP: string,
        MOVE_TO: string,
        SEND_KEYS_TO_ACTIVE_ELEMENT: string,
        TOUCH_SINGLE_TAP: string,
        TOUCH_DOWN: string,
        TOUCH_UP: string,
        TOUCH_MOVE: string,
        TOUCH_SCROLL: string,
        TOUCH_DOUBLE_TAP: string,
        TOUCH_LONG_PRESS: string,
        TOUCH_FLICK: string,
        GET_AVAILABLE_LOG_TYPES: string,
        GET_LOG: string,
        GET_SESSION_LOGS: string,
        UPLOAD_FILE: string
}

declare var CommandName: webdriver$ICommandName;


/**
 * Describes a command to be executed by the WebDriverJS framework.
 * @param  The name of this command.
 * @constructor  
 */
declare class Command {

    /**
     * 
     * @param  The name of this command.
     * @constructor  
     */
    constructor(name: string): this;

    /**
     * 
     * @return  This command's name.
     */
    getName(): string;

    /**
     * Sets a parameter to send with this command.
     * @param  The parameter name.
     * @param  The parameter value.
     * @return  A self reference.
     */
    setParameter(name: string, value: any): webdriver$Command;

    /**
     * Sets the parameters for this command.
     * @param  The command parameters.
     * @return  A self reference.
     */
    setParameters(parameters: any): webdriver$Command;

    /**
     * Returns a named command parameter.
     * @param  The parameter key to look up.
     * @return  The parameter value, or undefined if it has not been set.
     */
    getParameter(key: string): any;

    /**
     * 
     * @return  The parameters to send with this command.
     */
    getParameters(): any
}


/**
 * Handles the execution of WebDriver {@link Command commands}.
 * @interface  
 */
declare class Executor {

    /**
     * Executes the given {@code command}. If there is an error executing the
     * command, the provided callback will be invoked with the offending error.
    Otherwise, the callback will be invoked with a null Error and non-null
    response object.
     * @param  The command to execute.
     * @return  <?>} A promise that will be fulfilled with
    the command result.
    */
    execute(command: webdriver$Command): undefined.Promise<any >
}


/**
 * Wraps a promised {@link Executor}, ensuring no commands are executed until
 * the wrapped executor has been fully resolved.
 * @implements  {Executor}
 */
declare class DeferredExecutor {

    /**
     * <Executor>} delegate The promised delegate, which
     *     may be provided by any promise-like thenable object.
     */
    constructor(delegate: undefined.Promise<webdriver$Executor>): this
}


/**
 * Describes an event listener registered on an {@linkplain EventEmitter}.
 */
declare class Listener {

    /**
     * 
     * @param  The acutal listener function.
     * @param  The object in whose scope to invoke the
    listener.
     * @param  Whether this listener should only be used once.
    */
    constructor(fn: Function, scope: Object, oneshot: boolean): this
}


/**
 * Object that can emit events for others to listen for. This is used instead
 * of Closure's event system because it is much more light weight. The API is
based on Node's EventEmitters.
*/
declare class EventEmitter {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Fires an event and calls all listeners.
     * @param  The type of event to emit.
     * @param  Any arguments to pass to each listener.
     */
    emit(type: string, ...var_args: any[]): void;

    /**
     * Returns a mutable list of listeners for a specific type of event.
     * @param  The type of event to retrieve the listeners for.
     * @return  The registered listeners for the given event
    type.
    */
    listeners(type: string): any;

    /**
     * Registers a listener.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @param  Whether the listener should b (e removed after
    the first event is fired.
     * @return  A self reference.
     * @private  
    */
    addListener(
        type: string,
        fn: Function,
        opt_scope?: any,
        opt_oneshot?: boolean): webdriver$EventEmitter;

    /**
     * Registers a one-time listener which will be called only the first time an
     * event is emitted, after which it will be removed.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @return  A self reference.
     */
    once(type: string, fn: any, opt_scope?: any): webdriver$EventEmitter;

    /**
     * An alias for {@code #addListener()}.
     * @param  The type of event to listen for.
     * @param  The function to invoke when the event is fired.
     * @param  The object in whose scope to invoke the listener.
     * @return  A self reference.
     */
    on(type: string, fn: Function, opt_scope?: any): webdriver$EventEmitter;

    /**
     * Removes a previously registered event listener.
     * @param  The type of event to unregister.
     * @param  The handler function to remove.
     * @return  A self reference.
     */
    removeListener(type: string, listenerFn: Function): webdriver$EventEmitter;

    /**
     * Removes all listeners for a specific type of event. If no event is
     * specified, all listeners across all types will be removed.
     * @param  The type of event to remove listeners from.
     * @return  A self reference.
     */
    removeAllListeners(opt_type?: string): webdriver$EventEmitter
}


/**
 * Interface for navigating back and forth in the browser history.
 */
declare class Navigation {

    /**
     * Interface for navigating back and forth in the browser history.
     * 
    This class should never be instantiated directly. Insead, obtain an instance
    with

        webdriver.navigate()
     * @see  WebDriver#navigate()
    */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Schedules a command to navigate to a new URL.
     * @param  The URL to navigate to.
     * @return  A promise that will be resolved
    when the URL has been loaded.
    */
    to(url: string): undefined.Promise<void>;

    /**
     * Schedules a command to move backwards in the browser history.
     * @return  A promise that will be resolved
    when the navigation event has completed.
    */
    back(): undefined.Promise<void>;

    /**
     * Schedules a command to move forwards in the browser history.
     * @return  A promise that will be resolved
    when the navigation event has completed.
    */
    forward(): undefined.Promise<void>;

    /**
     * Schedules a command to refresh the current page.
     * @return  A promise that will be resolved
    when the navigation event has completed.
    */
    refresh(): undefined.Promise<void >
}

declare interface webdriver$IWebDriverOptionsCookie {
    name: string,
        value: string,
        path?: string,
        domain?: string,
        secure?: boolean,
        expiry?: number
}


/**
 * Provides methods for managing browser and driver state.
 */
declare class Options {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Schedules a command to add a cookie.
     * @param  The cookie name.
     * @param  The cookie value.
     * @param  The cookie path.
     * @param  The cookie domain.
     * @param  Whether the cookie is secure.
     * @param  When the cookie expires. If specified
    as a number, should be in milliseconds since midnight,
    January 1, 1970 UTC.
     * @return  <void>} A promise that will be resolved
    when the cookie has been added to the page.
    */
    addCookie(
        name: string,
        value: string,
        opt_path?: string,
        opt_domain?: string,
        opt_isSecure?: boolean,
        opt_expiry?: number | Date): undefined.Promise<void>;

    /**
     * Schedules a command to delete all cookies visible to the current page.
     * @return  A promise that will be resolved when all
    cookies have been deleted.
    */
    deleteAllCookies(): undefined.Promise<void>;

    /**
     * Schedules a command to delete the cookie with the given name. This command is
     * a no-op if there is no cookie with the given name visible to the current
    page.
     * @param  The name of the cookie to delete.
     * @return  A promise that will be resolved when the
    cookie has been deleted.
    */
    deleteCookie(name: string): undefined.Promise<void>;

    /**
     * Schedules a command to retrieve all cookies visible to the current page.
     * Each cookie will be returned as a JSON object as described by the WebDriver
    wire protocol.
     * @return  A promise that will be resolved with the
    cookies visible to the current page.
     * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
    */
    getCookies(): undefined.Promise<webdriver$IWebDriverOptionsCookie[]>;

    /**
     * Schedules a command to retrieve the cookie with the given name. Returns null
     * if there is no such cookie. The cookie will be returned as a JSON object as
    described by the WebDriver wire protocol.
     * @param  The name of the cookie to retrieve.
     * @return  A promise that will be resolved with the
    named cookie, or {
     * @code  null} if there is no such cookie.
     * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol#Cookie_JSON_Object
    */
    getCookie(name: string): undefined.Promise<webdriver$IWebDriverOptionsCookie>;

    /**
     * 
     * @return  The interface for managing driver
    logs.
    */
    logs(): webdriver$Logs;

    /**
     * 
     * @return  The interface for managing driver
    timeouts.
    */
    timeouts(): webdriver$Timeouts;

    /**
     * 
     * @return  The interface for managing the
    current window.
    */
    window(): webdriver$Window
}


/**
 * An interface for managing timeout behavior for WebDriver instances.
 */
declare class Timeouts {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Specifies the amount of time the driver should wait when searching for an
     * element if it is not immediately present.
    <p/>
    When searching for a single element, the driver should poll the page
    until the element has been found, or this timeout expires before failing
    with a {@code bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching
    for multiple elements, the driver should poll the page until at least one
    element has been found or this timeout has expired.
    <p/>
    Setting the wait timeout to 0 (its default value), disables implicit
    waiting.
    <p/>
    Increasing the implicit wait timeout should be used judiciously as it
    will have an adverse effect on test run time, especially when used with
    slower location strategies like XPath.
     * @param  The amount of time to wait, in milliseconds.
     * @return  A promise that will be resolved when the
    implicit wait timeout has been set.
    */
    implicitlyWait(ms: number): undefined.Promise<void>;

    /**
     * Sets the amount of time to wait, in milliseconds, for an asynchronous script
     * to finish execution before returning an error. If the timeout is less than or
    equal to 0, the script will be allowed to run indefinitely.
     * @param  The amount of time to wait, in milliseconds.
     * @return  A promise that will be resolved when the
    script timeout has been set.
    */
    setScriptTimeout(ms: number): undefined.Promise<void>;

    /**
     * Sets the amount of time to wait for a page load to complete before returning
     * an error.  If the timeout is negative, page loads may be indefinite.
     * @param  The amount of time to wait, in milliseconds.
     * @return  A promise that will be resolved when
    the timeout has been set.
    */
    pageLoadTimeout(ms: number): undefined.Promise<void >
}


/**
 * An interface for managing the current window.
 */
declare class Window {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Retrieves the window's current position, relative to the top left corner of
     * the screen.
     * @return  A promise that will be resolved with the
    window's position in the form of a {x:number, y:number} object literal.
    */
    getPosition(): undefined.Promise<webdriver$ILocation>;

    /**
     * Repositions the current window.
     * @param  The desired horizontal position, relative to the left side
    of the screen.
     * @param  The desired vertical position, relative to the top of the
    of the screen.
     * @return  A promise that will be resolved when the
    command has completed.
    */
    setPosition(x: number, y: number): undefined.Promise<void>;

    /**
     * Retrieves the window's current size.
     * @return  A promise that will be resolved with the
    window's size in the form of a {width:number, height:number} object
    literal.
    */
    getSize(): undefined.Promise<webdriver$ISize>;

    /**
     * Resizes the current window.
     * @param  The desired window width.
     * @param  The desired window height.
     * @return  A promise that will be resolved when the
    command has completed.
    */
    setSize(width: number, height: number): undefined.Promise<void>;

    /**
     * Maximizes the current window.
     * @return  A promise that will be resolved when the
    command has completed.
    */
    maximize(): undefined.Promise<void >
}


/**
 * Interface for managing WebDriver log records.
 */
declare class Logs {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Fetches available log entries for the given type.
     * 
    <p/>Note that log buffers are reset after each call, meaning that
    available log entries correspond to those entries not yet returned for a
    given log type. In practice, this means that this call will return the
    available log entries since the last call, or from the start of the
    session.
     * @param  The desired log type.
     * @return  A
    promise that will resolve to a list of log entries for the specified
    type.
    */
    get(type: undefined.Type): undefined.Promise<undefined.Entry[]>;

    /**
     * Retrieves the log types available to this driver.
     * @return  A
    promise that will resolve to a list of available log types.
    */
    getAvailableLogTypes(): undefined.Promise<string[] >
}


/**
 * An interface for changing the focus of the driver to another frame or window.
 */
declare class TargetLocator {

    /**
     * 
     * @param  The parent driver.
     * @constructor  
     */
    constructor(driver: webdriver$WebDriver): this;

    /**
     * Schedules a command retrieve the {@code document.activeElement} element on
     * the current document, or {@code document.body} if activeElement is not
    available.
     * @return  The active element.
    */
    activeElement(): webdriver$WebElementPromise;

    /**
     * Schedules a command to switch focus of all future commands to the first frame
     * on the page.
     * @return  A promise that will be resolved when the
    driver has changed focus to the default content.
    */
    defaultContent(): undefined.Promise<void>;

    /**
     * Schedules a command to switch the focus of all future commands to another
     * frame on the page. The target frame may be specified as one of the
    following:

    - A number that specifies a (zero-based) index into [window.frames](
       https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).
    - A {@link WebElement} reference, which correspond to a `frame` or `iframe`
       DOM element.
    - The `null` value, to select the topmost frame on the page. Passing `null`
       is the same as calling {@link #defaultContent defaultContent()}.

    If the specified frame can not be found, the returned promise will be
    rejected with a {@linkplain error.NoSuchFrameError}.
     * @param  The frame locator.
     * @return  <void>} A promise that will be resolved
    when the driver has changed focus to the specified frame.
    */
    frame(nameOrIndex: number | webdriver$WebElement): undefined.Promise<void>;

    /**
     * Schedules a command to switch the focus of all future commands to another
     * window. Windows may be specified by their {@code window.name} attribute or
    by its handle (as returned by {@link WebDriver#getWindowHandles}).

    If the specified window cannot be found, the returned promise will be
    rejected with a {@linkplain error.NoSuchWindowError}.
     * @param  The name or window handle of the window to
    switch focus to.
     * @return  <void>} A promise that will be resolved
    when the driver has changed focus to the specified window.
    */
    window(nameOrHandle: string): undefined.Promise<void>;

    /**
     * Schedules a command to change focus to the active modal dialog, such as
     * those opened by `window.alert()`, `window.confirm()`, and
    `window.prompt()`. The returned promise will be rejected with a
    {
     * @linkplain  error.NoSuchAlertError} if there are no open alerts.
     * @return  The open alert.
    */
    alert(): webdriver$AlertPromise
}


/**
 * Used with {@link webdriver.WebElement#sendKeys WebElement#sendKeys} on file
 * input elements ({@code <input type="file">}) to detect when the entered key
sequence defines the path to a file.

By default, {@linkplain webdriver.WebElement WebElement's} will enter all
key sequences exactly as entered. You may set a
{
 * @linkplain  webdriver.WebDriver#setFileDetector file detector} on the parent
WebDriver instance to define custom behavior for handling file elements. Of
particular note is the {
 * @link  selenium-webdriver/remote.FileDetector}, which
should be used when running against a remote
[Selenium Server](http://docs.seleniumhq.org/download/).
*/
declare class FileDetector {

    /**
     * 
     * @constructor  
     */
    constructor(): this;

    /**
     * Handles the file specified by the given path, preparing it for use with
     * the current browser. If the path does not refer to a valid file, it will
    be returned unchanged, otherwisee a path suitable for use with the current
    browser will be returned.

    This default implementation is a no-op. Subtypes may override this
    function for custom tailored file handling.
     * @param  The driver for the current browser.
     * @param  The path to process.
     * @return  <string>} A promise for the processed
    file path.
     * @package  
    */
    handleFile(driver: webdriver$WebDriver, path: string): undefined.Promise<string >
}


/**
 * Creates a new WebDriver client, which provides control over a browser.
 * 
Every WebDriver command returns a {@code webdriver.promise.Promise} that
represents the result of that command. Callbacks may be registered on this
object to manipulate the command result or catch an expected error. Any
commands scheduled with a callback are considered sub-commands and will
execute before the next command in the current frame. For example:

   var message = [];
   driver.call(message.push, message, 'a').then(function() {
     driver.call(message.push, message, 'b');
   });
   driver.call(message.push, message, 'c');
   driver.call(function() {
     alert('message is abc? ' + (message.join('') == 'abc'));
   });
*/
declare class WebDriver {

    /**
     * <!Session>)} session Either a
     *     known session or a promise that will be resolved to a session.
     * @param  The executor to use when sending
    commands to the browser.
     * @param  The flow to
    schedule commands through. Defaults to the active flow object.
    */
    constructor(session: webdriver$Session | undefined.Promise<webdriver$Session>, executor: webdriver$Executor, opt_flow?: undefined.ControlFlow): this;

    /**
     * Creates a new WebDriver client for an existing session.
     * @param  Command executor to use when querying
    for session details.
     * @param  ID of the session to attach to.
     * @param  The control flow all
    driver commands should execute under. Defaults to the
    {
     * @link  promise.controlFlow() currently active}  control flow.
     * @return  A new client for the specified session.
    */
    attachToSession(
        executor: webdriver$Executor,
        sessionId: string,
        opt_flow?: undefined.ControlFlow): webdriver$WebDriver;

    /**
     * Creates a new WebDriver session./capabilities.Capabilities} desiredCapabilities The desired
     *    capabilities for the new session.
     * @param  The executor to create the new session
    with.
     * @param  The control flow all driver
    commands should execute under, including the initial session creation.
    Defaults to the {
     * @link  promise.controlFlow() currently active}
    control flow.
     * @return  The driver for the newly created session.
    */
    createSession(
        executor: webdriver$Executor,
        desiredCapabilities: webdriver$Capabilities,
        opt_flow?: undefined.ControlFlow): webdriver$WebDriver;

    /**
     * 
     * @return  The control flow used by this
    instance.
    */
    controlFlow(): undefined.ControlFlow;

    /**
     * Schedules a {@link command.Command} to be executed by this driver's
     * {
     * @link  command.Executor}.
     * @param  The command to schedule.
     * @param  A description of the command for debugging.
     * @return  <T>} A promise that will be resolved
    with the command result.
     * @template  
    */
    schedule<T>(command: webdriver$Command, description: string): undefined.Promise<T>;

    /**
     * Sets the {@linkplain input.FileDetector file detector} that should be
     * used with this instance.
     * @param  The detector to use or {
     * @code  null}.
     */
    setFileDetector(detector: webdriver$FileDetector): void;

    /**
     * 
     * @return  A promise for this
    client's session.
    */
    getSession(): undefined.Promise<webdriver$Session>;

    /**
     * 
     * @return  A promise
    that will resolve with the this instance's capabilities.
    */
    getCapabilities(): undefined.Promise<webdriver$Capabilities>;

    /**
     * Schedules a command to quit the current session. After calling quit, this
     * instance will be invalidated and may no longer be used to issue commands
    against the browser.
     * @return  A promise that will be resolved
    when the command has completed.
    */
    quit(): undefined.Promise<void>;

    /**
     * Creates a new action sequence using this driver. The sequence will not be
     * scheduled for execution until {@link actions.ActionSequence#perform} is
    called. Example:

         driver.actions().
             mouseDown(element1).
             mouseMove(element2).
             mouseUp().
             perform();
     * @return  A new action sequence for this instance.
    */
    actions(): webdriver$ActionSequence;

    /**
     * Creates a new touch sequence using this driver. The sequence will not be
     * scheduled for execution until {@link actions.TouchSequence#perform} is
    called. Example:

         driver.touchActions().
             tap(element1).
             doubleTap(element2).
             perform();
     * @return  A new touch sequence for this instance.
    */
    touchActions(): webdriver$TouchSequence;

    /**
     * Schedules a command to execute JavaScript in the context of the currently
     * selected frame or window. The script fragment will be executed as the body
    of an anonymous function. If the script is provided as a function object,
    that function will be converted to a string for injection into the target
    window.

    Any arguments provided in addition to the script will be included as script
    arguments and may be referenced using the {@code arguments} object.
    Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
    Arrays and objects may also be used as script arguments as long as each item
    adheres to the types previously mentioned.

    The script may refer to any variables accessible from the current window.
    Furthermore, the script will execute in the window's context, thus
    {
     * @code  document} may be used to refer to the current document. Any local
    variables will not be available once the script has finished executing,
    though global variables will persist.

    If the script has a return value (i.e. if the script contains a return
    statement), then the following steps will be taken for resolving this
    functions return value:

    - For a HTML element, the value will resolve to a
    {
     * @link  webdriver.WebElement}
    - Null and undefined return values will resolve to null</li>
    - Booleans, numbers, and strings will resolve as is</li>
    - Functions will resolve to their string representation</li>
    - For arrays and objects, each member item will be converted according to
    the rules above
     * @param  The script to execute.
     * @param  The arguments to pass to the script.
     * @return  A promise that will resolve to the
    scripts return value.
     * @template  
    */
    executeScript<T>(script: string | Function, ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to execute asynchronous JavaScript in the context of the
     * currently selected frame or window. The script fragment will be executed as
    the body of an anonymous function. If the script is provided as a function
    object, that function will be converted to a string for injection into the
    target window.

    Any arguments provided in addition to the script will be included as script
    arguments and may be referenced using the {@code arguments} object.
    Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
    Arrays and objects may also be used as script arguments as long as each item
    adheres to the types previously mentioned.

    Unlike executing synchronous JavaScript with {@link #executeScript},
    scripts executed with this function must explicitly signal they are finished
    by invoking the provided callback. This callback will always be injected
    into the executed function as the last argument, and thus may be referenced
    with {@code arguments[arguments.length - 1]}. The following steps will be
    taken for resolving this functions return value against the first argument
    to the script's callback function:

    - For a HTML element, the value will resolve to a
         {
     * @link  webdriver.WebElement}
    - Null and undefined return values will resolve to null
    - Booleans, numbers, and strings will resolve as is
    - Functions will resolve to their string representation
    - For arrays and objects, each member item will be converted according to
    the rules above

    __Example #1:__ Performing a sleep that is synchronized with the currently
    selected window:

    var start = new Date().getTime();
    driver.executeAsyncScript(
    'window.setTimeout(arguments[arguments.length - 1], 500);').
    then(function() {
    console.log(
        'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
    });

    __Example #2:__ Synchronizing a test with an AJAX application:

    var button = driver.findElement(By.id('compose-button'));
    button.click();
    driver.executeAsyncScript(
    'var callback = arguments[arguments.length - 1];' +
    'mailClient.getComposeWindowWidget().onload(callback);');
    driver.switchTo().frame('composeWidget');
    driver.findElement(By.id('to')).sendKeys('dog
     * @example  .com');

    __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
    this example, the inject script is specified with a function literal. When
    using this format, the function is converted to a string for injection, so it
    should not reference any symbols not defined in the scope of the page under
    test.

    driver.executeAsyncScript(function() {
    var callback = arguments[arguments.length - 1];
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/resource/data.json", true);
    xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
    callback(xhr.responseText);
    }
    }
    xhr.send('');
    }).then(function(str) {
    console.log(JSON.parse(str)['food']);
    });
     * @param  The script to execute.
     * @param  The arguments to pass to the script.
     * @return  A promise that will resolve to the
    scripts return value.
     * @template  
    */
    executeAsyncScript<T>(script: string | Function, ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to execute a custom function.
     * @param  The function to
    execute.
     * @param  The object in whose scope to execute the function.
     * @param  Any arguments to pass to the function.
     * @return  A promise that will be resolved'
    with the function's result.
     * @template  
    */
    call<T>(
        fn: (...var_args: any[]) => (T | undefined.Promise<T>),
        opt_scope?: any,
        ...var_args: any[]): undefined.Promise<T>;

    /**
     * Schedules a command to wait for a condition to hold. The condition may be
     * specified by a {@link webdriver.until.Condition}, as a custom function, or
    as a {@link webdriver.promise.Promise}.

    For a {@link webdriver.until.Condition} or function, the wait will repeatedly
    evaluate the condition until it returns a truthy value. If any errors occur
    while evaluating the condition, they will be allowed to propagate. In the
    event a condition returns a {@link webdriver.promise.Promise promise}, the
    polling loop will wait for it to be resolved and use the resolved value for
    whether the condition has been satisified. Note the resolution time for
    a promise is factored into whether a wait has timed out.

    *Example: waiting up to 10 seconds for an element to be present and visible
    on the page.

         var button = driver.wait(until.elementLocated(By.id('foo'), 10000);
         button.click();

    This function may also be used to block the command flow on the resolution
    of a {@link webdriver.promise.Promise promise}. When given a promise, the
    command will simply wait for its resolution before completing. A timeout may
    be provided to fail the command if the promise does not resolve before the
    timeout expires.

    *Example: Suppose you have a function, `startTestServer`, that returns a
    promise for when a server is ready for requests. You can block a `WebDriver`
    client on this promise with:

         var started = startTestServer();
         driver.wait(started, 5  1000, 'Server should start within 5 seconds');
         driver.get(getServerUrl());<T>|
              webdriver.until.Condition<T>|
              function(!webdriver.WebDriver): T)} condition The condition to
        wait on, defined as a promise, condition object, or  a function to
        evaluate as a condition.
     * @param  How long to wait for the condition to be true.
     * @param  An optional message to use if the wait times
    out.
     * @return  <T>} A promise that will be fulfilled
    with the first truthy value returned by the condition function, or
    rejected if the condition times out.
     * @template  
    */
    wait<T>(
        condition: undefined.Promise<T>| undefined.Condition<T>| ((driver: webdriver$WebDriver) => T),
        timeout?: number,
        opt_message?: string): undefined.Promise<T>;

    /**
     * Schedules a command to make the driver sleep for the given amount of time.
     * @param  The amount of time, in milliseconds, to sleep.
     * @return  A promise that will be resolved
    when the sleep has finished.
    */
    sleep(ms: number): undefined.Promise<void>;

    /**
     * Schedules a command to retrieve they current window handle.
     * @return  A promise that will be
    resolved with the current window handle.
    */
    getWindowHandle(): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the current list of available window handles.
     * @return  A promise that will
    be resolved with an array of window handles.
    */
    getAllWindowHandles(): undefined.Promise<string[]>;

    /**
     * Schedules a command to retrieve the current page's source. The page source
     * returned is a representation of the underlying DOM: do not expect it to be
    formatted or escaped in the same way as the response sent from the web
    server.
     * @return  A promise that will be
    resolved with the current page source.
    */
    getPageSource(): undefined.Promise<string>;

    /**
     * Schedules a command to close the current window.
     * @return  A promise that will be resolved
    when this command has completed.
    */
    close(): undefined.Promise<void>;

    /**
     * Schedules a command to navigate to the given URL.
     * @param  The fully qualified URL to open.
     * @return  A promise that will be resolved
    when the document has finished loading.
    */
    get(url: string): undefined.Promise<void>;

    /**
     * Schedules a command to retrieve the URL of the current page.
     * @return  A promise that will be
    resolved with the current URL.
    */
    getCurrentUrl(): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the current page's title.
     * @return  A promise that will be
    resolved with the current page's title.
    */
    getTitle(): undefined.Promise<string>;

    /**
     * Schedule a command to find an element on the page. If the element cannot be
     * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned
    by the driver. Unlike other commands, this error cannot be suppressed. In
    other words, scheduling a command to find an element doubles as an assert
    that the element is present on the page. To test whether an element is
    present on the page, use {@link #isElementPresent} instead.

    The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:

    var e1 = driver.findElement(By.id('foo'));
    var e2 = driver.findElement({id:'foo'});

    You may also provide a custom locator function, which takes as input this
    instance and returns a {
     * @link  WebElement}, or a promise that will resolve
    to a WebElement. If the returned promise resolves to an array of
    WebElements, WebDriver will use the first element. For example, to find the
    first visible link on a page, you could write:

    var link = driver.findElement(firstVisibleLink);

    function firstVisibleLink(driver) {
    var links = driver.findElements(By.tagName('a'));
    return promise.filter(links, function(link) {
    return link.isDisplayed();
    });
    }
     * @param  The locator to use.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(locator: webdriver$By | Function): webdriver$WebElementPromise;

    /**
     * Schedules a command to test if an element is present on the page.
     * 
    If given a DOM element, this function will check if it belongs to the
    document the driver is currently focused on. Otherwise, the function will
    test if at least one element can be found with the given search criteria.
     * @param  The locator to use.
     * @return  <boolean>} A promise that will resolve
    with whether the element is present on the page.
     * @deprecated  This method will be removed in Selenium 3.0 for consistency
    with the other Selenium language bindings. This method is equivalent
    to

    driver.findElements(locator).then(e => !!e.length);
    */
    isElementPresent(locatorOrElement: webdriver$By | Function): undefined.Promise<boolean>;

    /**
     * Schedule a command to search for multiple elements on the page.
     * @param  The locator to use.
     * @return  A
    promise that will resolve to an array of WebElements.
    */
    findElements(locator: webdriver$By | Function): undefined.Promise<webdriver$WebElement[]>;

    /**
     * Schedule a command to take a screenshot. The driver makes a best effort to
     * return a screenshot of the following, in order of preference:

    1. Entire page
    2. Current window
    3. Visible portion of the current frame
    4. The entire display containing the browser
     * @return  <string>} A promise that will be
    resolved to the screenshot as a base-64 encoded PNG.
    */
    takeScreenshot(): undefined.Promise<string>;

    /**
     * 
     * @return  The options interface for this
    instance.
    */
    manage(): webdriver$Options;

    /**
     * 
     * @return  The navigation interface for this
    instance.
    */
    navigate(): webdriver$Navigation;

    /**
     * 
     * @return  The target locator interface for
    this instance.
    */
    switchTo(): webdriver$TargetLocator
}

declare interface webdriver$IWebElementId {
    [ELEMENT: string]: string
}


/**
 * Represents a DOM element. WebElements can be found by searching from the
 * document root using a {@code webdriver.WebDriver} instance, or by searching
under another {@code webdriver.WebElement}:
<pre><code>
   driver.get('http://www.google.com');
   var searchForm = driver.findElement(By.tagName('form'));
   var searchBox = searchForm.findElement(By.name('q'));
   searchBox.sendKeys('webdriver');
</code></pre>

The WebElement is implemented as a promise for compatibility with the promise
API. It will always resolve itself when its internal state has been fully
resolved and commands may be issued against the element. This can be used to
catch errors when an element cannot be located on the page:
<pre><code>
   driver.findElement(By.id('not-there')).then(function(element) {
     alert('Found an element that was not expected to be there!');
   }, function(error) {
     alert('The element was not found, as expected');
   });
</code></pre>
*/
declare interface webdriver$IWebElement {

    /**
     * Schedules a command to click on this element.
     * @return  A promise that will be resolved when
    the click command has completed.
    */
    click(): undefined.Promise<void>,

        /**
         * Schedules a command to type a sequence on the DOM element represented by this
         * instance.
        <p/>
        Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
        processed in the keysequence, that key state is toggled until one of the
        following occurs:
        <ul>
        <li>The modifier key is encountered again in the sequence. At this point the
        state of the key is toggled (along with the appropriate keyup/down events).
        </li>
        <li>The {@code webdriver.Key.NULL} key is encountered in the sequence. When
        this key is encountered, all modifier keys current in the down state are
        released (with accompanying keyup events). The NULL key can be used to
        simulate common keyboard shortcuts:
        <code>
             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");
        </code></li>
        <li>The end of the keysequence is encountered. When there are no more keys
        to type, all depressed modifier keys are released (with accompanying keyup
        events).
        </li>
        </ul>
        <strong>Note:</strong> On browsers where native keyboard events are not yet
        supported (e.g. Firefox on OS X), key events will be synthesized. Special
        punctionation keys will be synthesized according to a standard QWERTY en-us
        keyboard layout.
         * @param  The sequence of keys to
        type. All arguments will be joined into a single sequence (var_args is
        permitted for convenience).
         * @return  A promise that will be resolved when all
        keys have been typed.
        */
        sendKeys(...var_args: string[]): undefined.Promise<void>,

        /**
         * Schedules a command to query for the tag/node name of this element.
         * @return  A promise that will be resolved with the
        element's tag name.
        */
        getTagName(): undefined.Promise<string>,

        /**
         * Schedules a command to query for the computed style of the element
         * represented by this instance. If the element inherits the named style from
        its parent, the parent will be queried for its value.  Where possible, color
        values will be converted to their hex representation (e.g. #00ff00 instead of
        rgb(0, 255, 0)).
        <p/>
        <em>Warning:</em> the value returned will be as the browser interprets it, so
        it may be tricky to form a proper assertion.
         * @param  The name of the CSS style property to look
        up.
         * @return  A promise that will be resolved with the
        requested CSS value.
        */
        getCssValue(cssStyleProperty: string): undefined.Promise<string>,

        /**
         * Schedules a command to query for the value of the given attribute of the
         * element. Will return the current value even if it has been modified after the
        page has been loaded. More exactly, this method will return the value of the
        given attribute, unless that attribute is not present, in which case the
        value of the property with the same name is returned. If neither value is
        set, null is returned. The "style" attribute is converted as best can be to a
        text representation with a trailing semi-colon. The following are deemed to
        be "boolean" attributes and will be returned as thus:

        <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,
        defaultchecked, defaultselected, defer, disabled, draggable, ended,
        formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
        loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
        paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
        selected, spellcheck, truespeed, willvalidate

        <p>Finally, the following commonly mis-capitalized attribute/property names
        are evaluated as expected:
        <ul>
           <li>"class"
           <li>"readonly"
        </ul>
         * @param  The name of the attribute to query.
         * @return  A promise that will be resolved with the
        attribute's value.
        */
        getAttribute(attributeName: string): undefined.Promise<string>,

        /**
         * Get the visible (i.e. not hidden by CSS) innerText of this element, including
         * sub-elements, without any leading or trailing whitespace.
         * @return  A promise that will be resolved with the
        element's visible text.
        */
        getText(): undefined.Promise<string>,

        /**
         * Schedules a command to compute the size of this element's bounding box, in
         * pixels.
         * @return  A promise that will be resolved with the
        element's size as a {
         * @code  {width:number, height:number}} object.
        */
        getSize(): undefined.Promise<webdriver$ISize>,

        /**
         * Schedules a command to compute the location of this element in page space.
         * @return  A promise that will be resolved to the
        element's location as a {
         * @code  {x:number, y:number}} object.
        */
        getLocation(): undefined.Promise<webdriver$ILocation>,

        /**
         * Schedules a command to query whether the DOM element represented by this
         * instance is enabled, as dicted by the {@code disabled} attribute.
         * @return  A promise that will be resolved with
        whether this element is currently enabled.
        */
        isEnabled(): undefined.Promise<boolean>,

        /**
         * Schedules a command to query whether this element is selected.
         * @return  A promise that will be resolved with
        whether this element is currently selected.
        */
        isSelected(): undefined.Promise<boolean>,

        /**
         * Schedules a command to submit the form containing this element (or this
         * element if it is a FORM element). This command is a no-op if the element is
        not contained in a form.
         * @return  A promise that will be resolved when
        the form has been submitted.
        */
        submit(): undefined.Promise<void>,

        /**
         * Schedules a command to clear the {@code value} of this element. This command
         * has no effect if the underlying DOM element is neither a text INPUT element
        nor a TEXTAREA element.
         * @return  A promise that will be resolved when
        the element has been cleared.
        */
        clear(): undefined.Promise<void>,

        /**
         * Schedules a command to test whether this element is currently displayed.
         * @return  A promise that will be resolved with
        whether this element is currently visible on the page.
        */
        isDisplayed(): undefined.Promise<boolean>,

        /**
         * Schedules a command to retrieve the outer HTML of this element.
         * @return  A promise that will be resolved with
        the element's outer HTML.
        */
        getOuterHtml(): undefined.Promise<string>,

        /**
         * 
         * @return  A promise
        that resolves to this element's JSON representation as defined by the
        WebDriver wire protocol.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol
        */
        getId(): undefined.Promise<webdriver$IWebElementId>,

        /**
         * Schedules a command to retrieve the inner HTML of this element.
         * @return  A promise that will be resolved with the
        element's inner HTML.
        */
        getInnerHtml(): undefined.Promise<string >
}

declare interface webdriver$IWebElementFinders {

    /**
     * Schedule a command to find a descendant of this element. If the element
     * cannot be found, a {@code bot.ErrorCode.NO_SUCH_ELEMENT} result will
    be returned by the driver. Unlike other commands, this error cannot be
    suppressed. In other words, scheduling a command to find an element doubles
    as an assert that the element is present on the page. To test whether an
    element is present on the page, use {@code #isElementPresent} instead.

    <p>The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:
    <code><pre>
    var e1 = element.findElement(By.id('foo'));
    var e2 = element.findElement({id:'foo'});
    </pre></code>

    <p>You may also provide a custom locator function, which takes as input
    this WebDriver instance and returns a {
     * @link  webdriver.WebElement}, or a
    promise that will resolve to a WebElement. For example, to find the first
    visible link on a page, you could write:
    <code><pre>
    var link = element.findElement(firstVisibleLink);

    function firstVisibleLink(element) {
    var links = element.findElements(By.tagName('a'));
    return webdriver.promise.filter(links, function(link) {
    return links.isDisplayed();
    }).then(function(visibleLinks) {
    return visibleLinks[0];
    });
    }
    </pre></code>
     * @param  The
    locator strategy to use when searching for the element.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(locator: webdriver$By | Function): webdriver$WebElementPromise,

        /**
         * Schedules a command to test if there is at least one descendant of this
         * element that matches the given search criteria.
         * @param  The
        locator strategy to use when searching for the element.
         * @return  A promise that will be
        resolved with whether an element could be located on the page.
        */
        isElementPresent(locator: webdriver$By | Function): undefined.Promise<boolean>,

        /**
         * Schedules a command to find all of the descendants of this element that
         * match the given search criteria.
         * @param  The
        locator strategy to use when searching for the elements.
         * @return  A
        promise that will resolve to an array of WebElements.
        */
        findElements(locator: webdriver$By | Function): undefined.Promise<webdriver$WebElement[] >
}


/**
 * Defines an object that can be asynchronously serialized to its WebDriver
 * wire representation.
 * @constructor  * 
 * @template  
 */
declare interface webdriver$Serializable<T>{

    /**
     * Returns either this instance's serialized represention, if immediately
     * available, or a promise for its serialized representation. This function is
    conceptually equivalent to objects that have a {@code toJSON()} property,
    except the serialize() result may be a promise or an object containing a
    promise (which are not directly JSON friendly).
     * @return  This instance's serialized wire format.
    */
    serialize(): T | undefined.IThenable<T >
}


/**
 * Represents a DOM element. WebElements can be found by searching from the
 * document root using a {@link webdriver.WebDriver} instance, or by searching
under another WebElement:

     driver.get('http://www.google.com');
     var searchForm = driver.findElement(By.tagName('form'));
     var searchBox = searchForm.findElement(By.name('q'));
     searchBox.sendKeys('webdriver');

The WebElement is implemented as a promise for compatibility with the promise
API. It will always resolve itself when its internal state has been fully
resolved and commands may be issued against the element. This can be used to
catch errors when an element cannot be located on the page:

     driver.findElement(By.id('not-there')).then(function(element) {
       alert('Found an element that was not expected to be there!');
     }, function(error) {
       alert('The element was not found, as expected');
     });
 * @extends  {webdriver.Serializable.<webdriver.WebElement.Id>}
*/
declare class WebElement mixins Serializable<webdriver$IWebElementId>{

    /**
     * 
     * @param  the parent WebDriver instance for this element.
     * @param  The server-assigned opaque ID for
    the underlying DOM element.
    */
    constructor(driver: webdriver$WebDriver, id: undefined.Promise<string>| string): this;

    /**
     * 
     * @param  The raw ID.
     * @param  Whether to exclude the legacy element key.
     * @return  The element ID for use with WebDriver's wire protocol.
     */
    buildId(id: string, opt_noLegacy?: boolean): Object;

    /**
     * Extracts the encoded WebElement ID from the object.
     * @param  The object to extract the ID from.
     * @return  the extracted ID.
     * @throws  {TypeError} if the object is not a valid encoded ID.
     */
    extractId(obj: webdriver$IWebElementId): string;

    /**
     * 
     * @param  the object to test.
     * @return  whether the object is a valid encoded WebElement ID.
     */
    isId(obj: webdriver$IWebElementId): boolean;

    /**
     * Compares two WebElements for equality.
     * @param  A WebElement.
     * @param  A WebElement.
     * @return  <boolean>} A promise that will be
    resolved to whether the two WebElements are equal.
    */
    equals(a: webdriver$WebElement, b: webdriver$WebElement): undefined.Promise<boolean>;

    /**
     * 
     * @return  The parent driver for this instance.
     */
    getDriver(): webdriver$WebDriver;

    /**
     * 
     * @return  <string>} A promise that resolves to
    the server-assigned opaque ID assigned to this element.
    */
    getId(): undefined.Promise<string>;

    /**
     * 
     * @deprecated  Use {
     * @link  #getId()} instead.
     */
    getRawId(): any;

    /**
     * Schedule a command to find a descendant of this element. If the element
     * cannot be found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will
    be returned by the driver. Unlike other commands, this error cannot be
    suppressed. In other words, scheduling a command to find an element doubles
    as an assert that the element is present on the page. To test whether an
    element is present on the page, use {@link #isElementPresent} instead.

    The search criteria for an element may be defined using one of the
    factories in the {@link webdriver.By} namespace, or as a short-hand
    {
     * @link  webdriver.By.Hash} object. For example, the following two statements
    are equivalent:

    var e1 = element.findElement(By.id('foo'));
    var e2 = element.findElement({id:'foo'});

    You may also provide a custom locator function, which takes as input
    this WebDriver instance and returns a {
     * @link  webdriver.WebElement}, or a
    promise that will resolve to a WebElement. For example, to find the first
    visible link on a page, you could write:

    var link = element.findElement(firstVisibleLink);

    function firstVisibleLink(element) {
    var links = element.findElements(By.tagName('a'));
    return webdriver.promise.filter(links, function(link) {
    return links.isDisplayed();
    }).then(function(visibleLinks) {
    return visibleLinks[0];
    });
    }
     * @param  The locator strategy to use when
    searching for the element.
     * @return  A WebElement that can be used to issue
    commands against the located element. If the element is not found, the
    element will be invalidated and all scheduled commands aborted.
    */
    findElement(locator: webdriver$By | Function): webdriver$WebElementPromise;

    /**
     * Schedules a command to test if there is at least one descendant of this
     * element that matches the given search criteria.
     * @param  The locator strategy to use when
    searching for the element.
     * @return  <boolean>} A promise that will be
    resolved with whether an element could be located on the page.
     * @deprecated  This method will be removed in Selenium 3.0 for consistency
    with the other Selenium language bindings. This method is equivalent
    to

    element.findElements(locator).then(e => !!e.length);
    */
    isElementPresent(locator: webdriver$By | Function): undefined.Promise<boolean>;

    /**
     * Schedules a command to find all of the descendants of this element that
     * match the given search criteria.
     * @param  The locator strategy to use when
    searching for the element.
     * @return  <!Array<!WebElement>>} A
    promise that will resolve to an array of WebElements.
    */
    findElements(locator: webdriver$By | Function): undefined.Promise<webdriver$WebElement[]>;

    /**
     * Schedules a command to click on this element.
     * @return  A promise that will be resolved
    when the click command has completed.
    */
    click(): undefined.Promise<void>;

    /**
     * Schedules a command to type a sequence on the DOM element represented by this
     * promsieinstance.

    Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
    processed in the keysequence, that key state is toggled until one of the
    following occurs:

    - The modifier key is encountered again in the sequence. At this point the
       state of the key is toggled (along with the appropriate keyup/down events).
    - The {@link webdriver.Key.NULL} key is encountered in the sequence. When
       this key is encountered, all modifier keys current in the down state are
       released (with accompanying keyup events). The NULL key can be used to
       simulate common keyboard shortcuts:

             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");

    - The end of the keysequence is encountered. When there are no more keys
       to type, all depressed modifier keys are released (with accompanying keyup
       events).

    If this element is a file input ({@code <input type="file">}), the
    specified key sequence should specify the path to the file to attach to
    the element. This is analgous to the user clicking "Browse..." and entering
    the path into the file select dialog.

         var form = driver.findElement(By.css('form'));
         var element = form.findElement(By.css('input[type=file]'));
         element.sendKeys('/path/to/file.txt');
         form.submit();

    For uploads to function correctly, the entered path must reference a file
    on the _browser's_ machine, not the local machine running this script. When
    running against a remote Selenium server, a {@link webdriver.FileDetector}
    may be used to transparently copy files to the remote machine before
    attempting to upload them in the browser.

    __Note:__ On browsers where native keyboard events are not supported
    (e.g. Firefox on OS X), key events will be synthesized. Special
    punctionation keys will be synthesized according to a standard QWERTY en-us
    keyboard layout.<string>)} var_args The sequence
        of keys to type. All arguments will be joined into a single sequence.
     * @return  A promise that will be resolved
    when all keys have been typed.
    */
    sendKeys(
        ...var_args: Array<string | undefined.Promise<string >> ): undefined.Promise<void>;

    /**
     * Schedules a command to query for the tag/node name of this element.
     * @return  A promise that will be
    resolved with the element's tag name.
    */
    getTagName(): undefined.Promise<string>;

    /**
     * Schedules a command to query for the computed style of the element
     * represented by this instance. If the element inherits the named style from
    its parent, the parent will be queried for its value.  Where possible, color
    values will be converted to their hex representation (e.g. #00ff00 instead of
    rgb(0, 255, 0)).

    _Warning:_ the value returned will be as the browser interprets it, so
    it may be tricky to form a proper assertion.
     * @param  The name of the CSS style property to look
    up.
     * @return  <string>} A promise that will be
    resolved with the requested CSS value.
    */
    getCssValue(cssStyleProperty: string): undefined.Promise<string>;

    /**
     * Schedules a command to query for the value of the given attribute of the
     * element. Will return the current value, even if it has been modified after
    the page has been loaded. More exactly, this method will return the value of
    the given attribute, unless that attribute is not present, in which case the
    value of the property with the same name is returned. If neither value is
    set, null is returned (for example, the "value" property of a textarea
    element). The "style" attribute is converted as best can be to a
    text representation with a trailing semi-colon. The following are deemed to
    be "boolean" attributes and will return either "true" or null:

    async, autofocus, autoplay, checked, compact, complete, controls, declare,
    defaultchecked, defaultselected, defer, disabled, draggable, ended,
    formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
    loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
    paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
    selected, spellcheck, truespeed, willvalidate

    Finally, the following commonly mis-capitalized attribute/property names
    are evaluated as expected:

    - "class"
    - "readonly"
     * @param  The name of the attribute to query.
     * @return  A promise that will be
    resolved with the attribute's value. The returned value will always be
    either a string or null.
    */
    getAttribute(attributeName: string): undefined.Promise<string>;

    /**
     * Get the visible (i.e. not hidden by CSS) innerText of this element, including
     * sub-elements, without any leading or trailing whitespace.
     * @return  A promise that will be
    resolved with the element's visible text.
    */
    getText(): undefined.Promise<string>;

    /**
     * Schedules a command to compute the size of this element's bounding box, in
     * pixels.
     * @return  A
    promise that will be resolved with the element's size as a
    {
     * @code  {width:number, height:number}} object.
    */
    getSize(): undefined.Promise<webdriver$ISize>;

    /**
     * Schedules a command to compute the location of this element in page space.
     * @return  A promise that
    will be resolved to the element's location as a
    {
     * @code  {x:number, y:number}} object.
    */
    getLocation(): undefined.Promise<webdriver$ILocation>;

    /**
     * Schedules a command to query whether the DOM element represented by this
     * instance is enabled, as dicted by the {@code disabled} attribute.
     * @return  A promise that will be
    resolved with whether this element is currently enabled.
    */
    isEnabled(): undefined.Promise<boolean>;

    /**
     * Schedules a command to query whether this element is selected.
     * @return  A promise that will be
    resolved with whether this element is currently selected.
    */
    isSelected(): undefined.Promise<boolean>;

    /**
     * Schedules a command to submit the form containing this element (or this
     * element if it is a FORM element). This command is a no-op if the element is
    not contained in a form.
     * @return  A promise that will be resolved
    when the form has been submitted.
    */
    submit(): undefined.Promise<void>;

    /**
     * Schedules a command to clear the `value` of this element. This command has
     * no effect if the underlying DOM element is neither a text INPUT element
    nor a TEXTAREA element.
     * @return  <void>} A promise that will be resolved
    when the element has been cleared.
    */
    clear(): undefined.Promise<void>;

    /**
     * Schedules a command to test whether this element is currently displayed.
     * @return  A promise that will be
    resolved with whether this element is currently visible on the page.
    */
    isDisplayed(): undefined.Promise<boolean>;

    /**
     * Take a screenshot of the visible region encompassed by this element's
     * bounding rectangle.
     * @param  Optional argument that indicates whether the
    element should be scrolled into view before taking a screenshot.
    Defaults to false.
     * @return  <string>} A promise that will be
    resolved to the screenshot as a base-64 encoded PNG.
    */
    takeScreenshot(opt_scroll?: boolean): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the outer HTML of this element.
     * @return  A promise that will be
    resolved with the element's outer HTML.
    */
    getOuterHtml(): undefined.Promise<string>;

    /**
     * Schedules a command to retrieve the inner HTML of this element.
     * @return  A promise that will be resolved with the
    element's inner HTML.
    */
    getInnerHtml(): undefined.Promise<string>;

    /**
     * 
     * @override  
     */
    serialize(): undefined.Promise<webdriver$IWebElementId >
}


/**
 * WebElementPromise is a promise that will be fulfilled with a WebElement.
 * This serves as a forward proxy on WebElement, allowing calls to be
scheduled without directly on this instance before the underlying
WebElement has been fulfilled. In other words, the following two statements
are equivalent:
<pre><code>
     driver.findElement({id: 'my-button'}).click();
     driver.findElement({id: 'my-button'}).then(function(el) {
       return el.click();
     });
</code></pre>
 * @param  The parent WebDriver instance for this
element.
 * @param  A promise
that will resolve to the promised element.
 * @constructor  * 
 * @extends  {webdriver.WebElement}
 * @implements  {webdriver.promise.Thenable.<!webdriver.WebElement>}
 * @final  
*/
declare class WebElementPromise mixins WebElement, undefined.IThenable<webdriver$WebElement>{

    /**
     * <!WebElement>} el A promise
     *    that will resolve to the promised element.
     * @param  The parent WebDriver instance for this
    element.
    */
    constructor(driver: webdriver$WebDriver, el: undefined.Promise<webdriver$WebElement>): this;

    /**
     * Cancels the computation of this promise's value, rejecting the promise in the
     * process. This method is a no-op if the promise has alreayd been resolved.
     * @param  The reason this promise is being cancelled.
     */
    cancel(opt_reason?: string): void;

    /**
     * 
     * @return  Whether this promise's value is still being computed. 
     */
    isPending(): boolean;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: webdriver$WebElement) => undefined.Promise<R>,
        opt_errback?: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers listeners for when this instance is resolved.
     * @param opt_callback The
    function to call if this promise is successfully resolved. The function
    should expect a single argument: the promise's resolved value.
     * @param opt_errback The
    function to call if this promise is rejected. The function should expect
    a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
    */
    then<R>(
        opt_callback?: (value: webdriver$WebElement) => R,
        opt_errback?: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } catch (ex) {
         console.error(ex);
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenCatch(function(ex) {
         console.error(ex);
       });
    </code></pre>
     * @param  The function
    to call if this promise is rejected. The function should expect a single
    argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    thenCatch<R>(errback: (error: any) => any): undefined.Promise<R>;

    /**
     * Registers a listener to invoke when this promise is resolved, regardless
     * of whether the promise's value was successfully computed. This function
    is synonymous with the {@code finally} clause in a synchronous API:
    <pre><code>
       // Synchronous API:
       try {
         doSynchronousWork();
       } finally {
         cleanUp();
       }

       // Asynchronous promise API:
       doAsynchronousWork().thenFinally(cleanUp);
    </code></pre>

    <b>Note:</b> similar to the {@code finally} clause, if the registered
    callback returns a rejected promise or throws an error, it will silently
    replace the rejection error (if any) from this promise:
    <pre><code>
       try {
         throw Error('one');
       } finally {
         throw Error('two');  // Hides Error: one
       }

       webdriver.promise.rejected(Error('one'))
           .thenFinally(function() {
             throw Error('two');  // Hides Error: one
           });
    </code></pre>
     * @param  The function
    to call when this promise is resolved.
     * @return  A promise that will be fulfilled
    with the callback result.
     * @template  
    */
    thenFinally<R>(callback: () => any): undefined.Promise<R>;

    /**
     * Registers a listener for when this promise is rejected. This is synonymous
     * with the {@code catch} clause in a synchronous API:

         // Synchronous API:
         try {
           doSynchronousWork();
         } catch (ex) {
           console.error(ex);
         }

         // Asynchronous promise API:
         doAsynchronousWork().catch(function(ex) {
           console.error(ex);
         });
     * @param  The
    function to call if this promise is rejected. The function should
    expect a single argument: the rejection reason.
     * @return  A new promise which will be
    resolved with the result of the invoked callback.
     * @template  
    */
    catch<R>(errback: Function): undefined.Promise<R >
}


/**
 * Contains information about a WebDriver session.
 */
declare class Session {

    /**
     * 
     * @param  The session ID.
     * @param  The session
    capabilities.
     * @constructor  
    */
    constructor(id: string, capabilities: webdriver$Capabilities | Object): this;

    /**
     * 
     * @return  This session's ID.
     */
    getId(): string;

    /**
     * 
     * @return  This session's capabilities.
     */
    getCapabilities(): webdriver$Capabilities;

    /**
     * Retrieves the value of a specific capability.
     * @param  The capability to retrieve.
     * @return  The capability value.
     */
    getCapability(key: string): any;

    /**
     * Returns the JSON representation of this object, which is just the string
     * session ID.
     * @return  The JSON representation of this Session.
     */
    toJSON(): string
}
declare var npm$namespace$testing: {
        describe: typeof testing$describe,
        xdescribe: typeof testing$xdescribe,
        after: typeof testing$after,
        afterEach: typeof testing$afterEach,
        before: typeof testing$before,
        beforeEach: typeof testing$beforeEach,
        it: typeof testing$it,
        iit: typeof testing$iit,
        xit: typeof testing$xit,
    }
    /**
     * Registers a new test suite.
     * @param name The suite name.
     * @param fn The suite function, or {
     * @code  undefined} to define a pending test suite.
     */
declare function testing$describe(name: string, fn: Function): void


/**
 * Defines a suppressed test suite.
 * @param name The suite name.
 * @param fn The suite function, or {
 * @code  undefined} to define a pending test suite.
 */
declare function testing$xdescribe(name: string, fn: Function): void


/**
 * Register a function to call after the current suite finishes.
 * @param fn 
 */
declare function testing$after(fn: Function): void


/**
 * Register a function to call after each test in a suite.
 * @param fn 
 */
declare function testing$afterEach(fn: Function): void


/**
 * Register a function to call before the current suite starts.
 * @param fn 
 */
declare function testing$before(fn: Function): void


/**
 * Register a function to call before each test in a suite.
 * @param fn 
 */
declare function testing$beforeEach(fn: Function): void


/**
 * Add a test to the current suite.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$it(name: string, fn: Function): void


/**
 * An alias for {@link #it()} that flags the test as the only one that should
 * be run within the current suite.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$iit(name: string, fn: Function): void


/**
 * Adds a test to the current suite while suppressing it so it is not run.
 * @param name The test name.
 * @param fn The test function, or {
 * @code  undefined} to define a pending test case.
 */
declare function testing$xit(name: string, fn: Function): voiddeclare module 'selenium-webdriver/chrome' {
    declare module.exports: typeof chrome
}
declare module 'selenium-webdriver/executors' {
    declare module.exports: typeof executors
}
declare module 'selenium-webdriver' {
    declare module.exports: typeof webdriver
}
declare module 'selenium-webdriver/testing' {
    declare module.exports: typeof testing
}