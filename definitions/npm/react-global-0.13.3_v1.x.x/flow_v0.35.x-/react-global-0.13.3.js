/**
 * Flowtype definitions for react-global-0.13.3
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'addons' {
    declare export var CSSTransitionGroup: ___React$CSSTransitionGroup;
    declare export var TransitionGroup: ___React$TransitionGroup;
    declare export var LinkedStateMixin: ___React$LinkedStateMixin;
    declare export var PureRenderMixin: ___React$PureRenderMixin;
    declare export function batchedUpdates<A, B>(callback: (a: A, b: B) => any, a: A, b: B): void
    declare export function classSet(cx: {
        [key: string]: boolean
    }): string
    declare export function cloneWithProps<P>(element: DOMElement<P>, props: P): DOMElement<P >
        declare export function createFragment(object: {
        [key: string]: ReactNode
    }): ReactFragment
    declare export function update(value: any[], spec: ___React$UpdateArraySpec): any[]
}


declare interface ___React$TransitionGroupProps {
    component?: ReactType,
        childFactory?: (child: ReactElement<any>) => ReactElement<any >
}

declare type ___React$CSSTransitionGroupProps = {
    transitionName: string,
    transitionAppear?: boolean,
    transitionEnter?: boolean,
    transitionLeave?: boolean
} & ___React$TransitionGroupProps


declare type ___React$CSSTransitionGroup = ComponentClass<___React$CSSTransitionGroupProps>;

declare type ___React$TransitionGroup = ComponentClass<___React$TransitionGroupProps>;

declare interface ___React$ReactLink<T>{
    value: T,
    requestChange(newValue: T): void
}

declare type ___React$LinkedStateMixin = {
    linkState<T>(key: string): ___React$ReactLink<T >
} & Mixin


declare type ___React$PureRenderMixin = {} & Mixin


declare interface ___React$UpdateSpecCommand {
    $set?: any,
        $merge?: {},
        $apply(value: any): any
}

declare interface ___React$UpdateSpecPath {
    [key: string]: ___React$UpdateSpec
}

declare type ___React$UpdateSpec = ___React$UpdateSpecCommand | ___React$UpdateSpecPath;

declare type ___React$UpdateArraySpec = {
    $push?: any[],
    $unshift?: any[],
    $splice?: any[][]
} & ___React$UpdateSpecCommand


declare interface ___React$ComponentPerfContext {
    current: string,
        owner: string
}

declare interface ___React$NumericPerfContext {
    [key: string]: number
}

declare interface ___React$Measurements {
    exclusive: ___React$NumericPerfContext,
        inclusive: ___React$NumericPerfContext,
        render: ___React$NumericPerfContext,
        counts: ___React$NumericPerfContext,
        writes: ___React$NumericPerfContext,
        displayNames: {
            [key: string]: ___React$ComponentPerfContext
        },
        totalTime: number
}


declare var npm$namespace$ReactPerf: {
    start: typeof ReactPerf$start,
    stop: typeof ReactPerf$stop,
    printInclusive: typeof ReactPerf$printInclusive,
    printExclusive: typeof ReactPerf$printExclusive,
    printWasted: typeof ReactPerf$printWasted,
    printDOM: typeof ReactPerf$printDOM,
    getLastMeasurements: typeof ReactPerf$getLastMeasurements,
}
declare export function ReactPerf$start(): void

declare export function ReactPerf$stop(): void

declare export function ReactPerf$printInclusive(measurements: ___React$Measurements[]): void

declare export function ReactPerf$printExclusive(measurements: ___React$Measurements[]): void

declare export function ReactPerf$printWasted(measurements: ___React$Measurements[]): void

declare export function ReactPerf$printDOM(measurements: ___React$Measurements[]): void

declare export function ReactPerf$getLastMeasurements(): ___React$Measurements[]

declare interface ___React$MockedComponentClass {
    new(): any
}


declare var npm$namespace$ReactTestUtils: {
    renderIntoDocument: typeof ReactTestUtils$renderIntoDocument,
    mockComponent: typeof ReactTestUtils$mockComponent,
    isElementOfType: typeof ReactTestUtils$isElementOfType,
    isTextComponent: typeof ReactTestUtils$isTextComponent,
    isDOMComponent: typeof ReactTestUtils$isDOMComponent,
    isCompositeComponent: typeof ReactTestUtils$isCompositeComponent,
    isCompositeComponentWithType: typeof ReactTestUtils$isCompositeComponentWithType,
    findAllInRenderedTree: typeof ReactTestUtils$findAllInRenderedTree,
    scryRenderedDOMComponentsWithClass: typeof ReactTestUtils$scryRenderedDOMComponentsWithClass,
    findRenderedDOMComponentWithClass: typeof ReactTestUtils$findRenderedDOMComponentWithClass,
    scryRenderedDOMComponentsWithTag: typeof ReactTestUtils$scryRenderedDOMComponentsWithTag,
    findRenderedDOMComponentWithTag: typeof ReactTestUtils$findRenderedDOMComponentWithTag,
    scryRenderedComponentsWithType: typeof ReactTestUtils$scryRenderedComponentsWithType,
    findRenderedComponentWithType: typeof ReactTestUtils$findRenderedComponentWithType,
    createRenderer: typeof ReactTestUtils$createRenderer,
}
declare export function ReactTestUtils$renderIntoDocument<P>(element: ReactElement<P>): Component<P, any >

    declare export function ReactTestUtils$mockComponent(
    mocked: ___React$MockedComponentClass,
    mockTagName?: string): typeof ReactTestUtils

declare export function ReactTestUtils$isElementOfType(element: ReactElement<any>, type: ReactType): boolean

declare export function ReactTestUtils$isTextComponent(instance: Component<any, any>): boolean

declare export function ReactTestUtils$isDOMComponent(instance: Component<any, any>): boolean

declare export function ReactTestUtils$isCompositeComponent(instance: Component<any, any>): boolean

declare export function ReactTestUtils$isCompositeComponentWithType(instance: Component<any, any>, type: ComponentClass<any>): boolean

declare export function ReactTestUtils$findAllInRenderedTree(
    tree: Component<any, any>,
    fn: (i: Component<any, any>) => boolean): Component<any, any >

    declare export function ReactTestUtils$scryRenderedDOMComponentsWithClass(tree: Component<any, any>, className: string): DOMComponent<any>[]

declare export function ReactTestUtils$findRenderedDOMComponentWithClass(tree: Component<any, any>, className: string): DOMComponent<any >

    declare export function ReactTestUtils$scryRenderedDOMComponentsWithTag(tree: Component<any, any>, tagName: string): DOMComponent<any>[]

declare export function ReactTestUtils$findRenderedDOMComponentWithTag(tree: Component<any, any>, tagName: string): DOMComponent<any >

    declare export function ReactTestUtils$scryRenderedComponentsWithType<P>(tree: Component<any, any>, type: ComponentClass<P>): Component<P, {}>[]

declare export function ReactTestUtils$findRenderedComponentWithType<P>(tree: Component<any, any>, type: ComponentClass<P>): Component<P, {} >

    declare export function ReactTestUtils$createRenderer(): ___React$ShallowRenderer

declare interface ___React$SyntheticEventData {
    altKey?: boolean,
        button?: number,
        buttons?: number,
        clientX?: number,
        clientY?: number,
        changedTouches?: TouchList,
        charCode?: boolean,
        clipboardData?: DataTransfer,
        ctrlKey?: boolean,
        deltaMode?: number,
        deltaX?: number,
        deltaY?: number,
        deltaZ?: number,
        detail?: number,
        getModifierState(key: string): boolean,
        key?: string,
        keyCode?: number,
        locale?: string,
        location?: number,
        metaKey?: boolean,
        pageX?: number,
        pageY?: number,
        relatedTarget?: EventTarget,
        repeat?: boolean,
        screenX?: number,
        screenY?: number,
        shiftKey?: boolean,
        targetTouches?: TouchList,
        touches?: TouchList,
        view?: AbstractView,
        which?: number
}

declare interface ___React$EventSimulator {
    (element: Element, eventData?: ___React$SyntheticEventData): void,
    (component: Component<any, any>, eventData?: ___React$SyntheticEventData): void
}

declare export var blur: ___React$EventSimulator;

declare export var change: ___React$EventSimulator;

declare export var click: ___React$EventSimulator;

declare export var cut: ___React$EventSimulator;

declare export var doubleClick: ___React$EventSimulator;

declare export var drag: ___React$EventSimulator;

declare export var dragEnd: ___React$EventSimulator;

declare export var dragEnter: ___React$EventSimulator;

declare export var dragExit: ___React$EventSimulator;

declare export var dragLeave: ___React$EventSimulator;

declare export var dragOver: ___React$EventSimulator;

declare export var dragStart: ___React$EventSimulator;

declare export var drop: ___React$EventSimulator;

declare export var focus: ___React$EventSimulator;

declare export var input: ___React$EventSimulator;

declare export var keyDown: ___React$EventSimulator;

declare export var keyPress: ___React$EventSimulator;

declare export var keyUp: ___React$EventSimulator;

declare export var mouseDown: ___React$EventSimulator;

declare export var mouseEnter: ___React$EventSimulator;

declare export var mouseLeave: ___React$EventSimulator;

declare export var mouseMove: ___React$EventSimulator;

declare export var mouseOut: ___React$EventSimulator;

declare export var mouseOver: ___React$EventSimulator;

declare export var mouseUp: ___React$EventSimulator;

declare export var paste: ___React$EventSimulator;

declare export var scroll: ___React$EventSimulator;

declare export var submit: ___React$EventSimulator;

declare export var touchCancel: ___React$EventSimulator;

declare export var touchEnd: ___React$EventSimulator;

declare export var touchMove: ___React$EventSimulator;

declare export var touchStart: ___React$EventSimulator;

declare export var wheel: ___React$EventSimulator;

declare class ShallowRenderer {
    getRenderOutput<E>(): E;
    getRenderOutput(): ReactElement<any>;
    render(element: ReactElement<any>, context?: any): void;
    unmount(): void
}