/**
 * Flowtype definitions for ember-1.11.3
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
var Handlebars: HandlebarsStatic;
declare interface EmberStates$Transition {
    targetName: string,
        urlMethod: string,
        intent: any,
        params: {} | any,
        pivotHandler: any,
        resolveIndex: number,
        handlerInfos: any,
        resolvedModels: {} | any,
        isActive: boolean,
        state: any,
        queryParams: {} | any,
        queryParamsOnly: boolean,
        isTransition: boolean,

        /**
         * The Transition's internal promise. Calling `.then` on this property
         * is that same as calling `.then` on the Transition object itself, but
        this property is exposed for when you want to pass around a
        Transition's promise, but not the Transition object itself, since
        Transition object can be externally `abort`ed, while the promise
        cannot.
        */
        promise: undefined.Promise,

        /**
         * Custom state can be stored on a Transition's `data` object.
         * This can be useful for decorating a Transition within an earlier
        hook and shared with a later hook. Properties set on `data` will
        be copied to new transitions generated by calling `retry` on this
        transition.
        */
        data: any,

        /**
         * A standard promise hook that resolves if the transition
         * succeeds and rejects if it fails/redirects/aborts.

        Forwards to the internal `promise` property which you can
        use in situations where you want to pass around a thennable,
        but not the Transition itself.
         * @arg  {Function} onFulfilled
         * @arg  {Function} onRejected
         * @arg  {String} label optional string for labeling the promise. Useful for tooling.
         * @return  
        */
        then(
            onFulfilled: Function,
            onRejected?: Function,
            label?: string): undefined.Promise,

        /**
         * Forwards to the internal `promise` property which you can
         * use in situations where you want to pass around a thennable,
        but not the Transition itself.
         * @method  catch
         * @arg  {Function} onRejection
         * @arg  {String} label optional string for labeling the promise.
        Useful for tooling.
         * @return  
        */
        catch (onRejection: Function, label?: string): undefined.Promise,

        /**
         * Forwards to the internal `promise` property which you can
         * use in situations where you want to pass around a thennable,
        but not the Transition itself.
         * @method  finally
         * @arg  {Function} callback
         * @arg  {String} label optional string for labeling the promise.
        Useful for tooling.
         * @return  
        */
        finally(callback: Function, label?: string): undefined.Promise,

        /**
         * Aborts the Transition. Note you can also implicitly abort a transition
         * by initiating another transition while a previous one is underway.
         */
        abort(): EmberStates$Transition,
        normalize(manager: Ember$StateManager, contexts: any[]): void,

        /**
         * Retries a previously-aborted transition (making sure to abort the
         * transition if it's still active). Returns a new transition that
        represents the new attempt to transition.
        */
        retry(): EmberStates$Transition,

        /**
         * Sets the URL-changing method to be employed at the end of a
         * successful transition. By default, a new Transition will just
        use `updateURL`, but passing 'replace' to this method will
        cause the URL to update using 'replaceWith' instead. Omitting
        a parameter will disable the URL change, allowing for transitions
        that don't update the URL at completion (this is also used for
        handleURL, since the URL has already changed before the
        transition took place).
         * @arg  {String} method the type of URL-changing method to use
        at the end of a transition. Accepted values are 'replace',
        falsy values, or any other non-falsy value (which is
        interpreted as an updateURL transition).
         * @return  this transition
        */
        method(method: string): EmberStates$Transition,

        /**
         * Fires an event on the current list of resolved/resolving
         * handlers within this transition. Useful for firing events
        on route hierarchies that haven't fully been entered yet.

        Note: This method is also aliased as `send`
         * @arg  {Boolean} [ignoreFailure=false] a boolean specifying whether unhandled events throw an error
         * @arg  {String} name the name of the event to fire
        */
        trigger(ignoreFailure: boolean, eventName: string): void,

        /**
         * Fires an event on the current list of resolved/resolving
         * handlers within this transition. Useful for firing events
        on route hierarchies that haven't fully been entered yet.

        Note: This method is also aliased as `send`
         * @arg  {String} name the name of the event to fire
        */
        trigger(eventName: string): void,

        /**
         * Transitions are aborted and their promises rejected
         * when redirects occur; this method returns a promise
        that will follow any redirects that occur and fulfill
        with the value fulfilled by any redirecting transitions
        that occur.
         * @return  a promise that fulfills with the same
        value that the final redirecting transition fulfills with
        */
        followRedirects(): undefined.Promise
}
declare class Adapter {
    asyncEnd(): void;
    asyncStart(): void;
    exception(error: string): void
}

declare class QUnitAdapter mixins Adapter {}
declare interface Function {
    observes(...args: string[]): Function,
        observesBefore(...args: string[]): Function,
        on(...args: string[]): Function,
        property(...args: string[]): Function
}
declare interface String {
    camelize(): string,
        capitalize(): string,
        classify(): string,
        dasherize(): string,
        decamelize(): string,
        fmt(...args: string[]): string,
        htmlSafe(): typeof undefined,
        loc(...args: string[]): string,
        underscore(): string,
        w(): string[]
}
declare interface Array<T>{
    constructor(arr: any[]): void,
    activate(): void,
    addArrayObserver(target: any, opts?: EnumerableConfigurationOptions): any[],
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): any[],
    any(callback: Function, target?: any): boolean,
    anyBy(key: string, value?: string): boolean,
    arrayContentDidChange(startIdx: number, removeAmt: number, addAmt: number): any[],
    arrayContentWillChange(startIdx: number, removeAmt: number, addAmt: number): any[],
    someProperty(key: string, value?: any): boolean,
    clear(): any[],
    compact(): any[],
    contains(obj: any): boolean,
    enumerableContentDidChange(start: number, removing: number, adding: number): any,
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any,
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any,
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any,
    enumerableContentDidChange(removing: number, adding: number): any,
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any,
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any,
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any,
    enumerableContentWillChange(removing: number, adding: number): any[],
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): any[],
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): any[],
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any[],
    every(callback: Function, target?: any): boolean,
    everyBy(key: string, value?: string): boolean,
    everyProperty(key: string, value?: any): boolean,
    filter(callback: Function, target?: any): any[],
    filterBy(key: string, value?: string): any[],

    /**
     * Returns the first item in the array for which the callback returns true.
     * This method works similar to the `filter()` method defined in JavaScript 1.6
    except that it will stop working on the array once a match is found.
    The callback method you provide should have the following signature (all
    parameters are optional):
    ```javascript
    function(item, index, enumerable);
    ```
    - `item` is the current item in the iteration.
    - `index` is the current index in the iteration.
    - `enumerable` is the enumerable object itself.
    It should return the `true` to include the item in the results, `false`
    otherwise.
    Note that in addition to a callback, you can also pass an optional target
    object that will be set as `this` on the context. This is a good way
    to give your iterator function access to the current object.
     * @function  find
     * @arg  callback The callback to execute
     * @arg  {Object} [target] The target object to use
     * @return  Found item or `undefined`.
    */
    find(callback: Function, target?: any): any,
    findBy(key: string, value?: string): any,
    forEach(callback: Function, target?: any): any,
    getEach(key: string): any[],
    indexOf(object: any, startAt?: number): number,
    insertAt(idx: number, object: any): any[],
    invoke(methodName: string, ...args: any[]): any[],
    lastIndexOf(object: any, startAt?: number): number,
    map(callback: Function, target?: any): any[],
    mapBy(key: string): any[],
    nextObject(index: number, previousObject: any, context: any): any,
    objectAt(idx: number): any,
    objectsAt(...args: number[]): any[],
    popObject(): any,
    pushObject(obj: any): any,
    pushObjects(...args: any[]): any[],
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any,
    reject: ItemIndexEnumerableCallbackTarget,
    rejectBy(key: string, value?: string): any[],
    removeArrayObserver(target: any, opts: EnumerableConfigurationOptions): any[],
    removeAt(start: number, len: number): any,
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): any[],
    replace(idx: number, amt: number, objects: any[]): void,
    reverseObjects(): any[],
    setEach(key: string, value?: any): any,
    setObjects(objects: any[]): any[],
    shiftObject(): any,
    slice(beginIndex?: number, endIndex?: number): any[],
    some(callback: Function, target?: any): boolean,
    toArray(): any[],
    uniq(): any[],
    unshiftObject(object: any): any,
    unshiftObjects(objects: any[]): any[],
    without(value: any): any[],
    []: any[],
    @each: Ember$EachProxy,
    Boolean: boolean,
    firstObject: any,
    hasEnumerableObservers: boolean,
    lastObject: any,
    addObject(object: any): any,
    addObjects(objects: Ember$Enumerable): any[],
    removeObject(object: any): any,
    removeObjects(objects: Ember$Enumerable): any[],
    addObserver: ModifyObserver,
    beginPropertyChanges(): any[],
    cacheFor(keyName: string): any,
    decrementProperty(keyName: string, decrement?: number): number,
    endPropertyChanges(): any[],
    get(keyName: string): any,
    getProperties(...args: string[]): {},
    getProperties(keys: string[]): {},
    getWithDefault(keyName: string, defaultValue: any): any,
    hasObserverFor(key: string): boolean,
    incrementProperty(keyName: string, increment?: number): number,
    notifyPropertyChange(keyName: string): any[],
    propertyDidChange(keyName: string): any[],
    propertyWillChange(keyName: string): any[],
    removeObserver(key: string, target: any, method: string): Ember$Observable,
    removeObserver(key: string, target: any, method: Function): Ember$Observable,
    set(keyName: string, value: any): any[],
    setProperties(hash: {}): any[],
    toggleProperty(keyName: string): any,
    copy(deep: boolean): any[],
    frozenCopy(): any[],
    isAny(key: string, value?: string): boolean,
    isEvery(key: string, value?: string): boolean
}
declare interface ApplicationCreateArguments {
    customEvents?: {},
        rootElement?: string,

        /**
         * Basic logging of successful transitions.
         */
        LOG_TRANSITIONS?: boolean,

        /**
         * Detailed logging of all routing steps.
         */
        LOG_TRANSITIONS_INTERNAL?: boolean
}
declare interface ApplicationInitializerArguments {
    name?: string,
        initialize?: ApplicationInitializerFunction
}
declare interface ApplicationInitializerFunction {
    (container: Ember$Container, application: Ember$Application): void
}
declare interface CoreObjectArguments {

    /**
     * An overridable method called when objects are instantiated. By default, does nothing unless it is
     * overridden during class definition. NOTE: If you do override init for a framework class like Ember.View
    or Ember.ArrayController, be sure to call this._super() in your init declaration! If you don't, Ember
    may not have an opportunity to do important setup work, and you'll see strange behavior in your application.
    */
    init?: Function,

        /**
         * Override to implement teardown.
         */
        willDestroy?: Function, [propName: string]: any
}
declare interface EnumerableConfigurationOptions {
    willChange?: boolean,
        didChange?: boolean
}
declare interface ItemIndexEnumerableCallbackTarget {
    (callback: ItemIndexEnumerableCallback, target?: any): any[]
}
declare interface ItemIndexEnumerableCallback {
    (item: any, index: number, enumerable: Ember$Enumerable): void
}
declare interface ReduceCallback {
    (previousValue: any, item: any, index: number, enumerable: Ember$Enumerable): void
}
declare interface TransitionsHash {
    contexts: any[],
        exitStates: Ember$State[],
        enterStates: Ember$State[],
        resolveState: Ember$State
}
declare interface ActionsHash {
    willTransition?: Function,
        error?: Function
}
declare interface DisconnectOutletOptions {
    outlet?: string,
        parentView?: string
}
declare interface RenderOptions {
    into?: string,
        controller?: string,
        model?: any,
        outlet?: string,
        view?: string
}
declare interface ModifyObserver {
    (obj: any, path: string, target: any, method?: Function): void,
    (obj: any, path: string, target: any, method?: string): void,
    (obj: any, path: string, func: Function, method?: Function): void,
    (obj: any, path: string, func: Function, method?: string): void
}
declare
var npm$namespace$Ember: {
    A: typeof Ember$A,
    DEFAULT_GETTER_FUNCTION: typeof Ember$DEFAULT_GETTER_FUNCTION,
    MANDATORY_SETTER_FUNCTION: typeof Ember$MANDATORY_SETTER_FUNCTION,
    addBeforeObserver: typeof Ember$addBeforeObserver,
    addListener: typeof Ember$addListener,
    aliasMethod: typeof Ember$aliasMethod,
    assert: typeof Ember$assert,
    beforeObserver: typeof Ember$beforeObserver,
    beforeObserversFor: typeof Ember$beforeObserversFor,
    beginPropertyChanges: typeof Ember$beginPropertyChanges,
    bind: typeof Ember$bind,
    cacheFor: typeof Ember$cacheFor,
    canInvoke: typeof Ember$canInvoke,
    changeProperties: typeof Ember$changeProperties,
    compare: typeof Ember$compare,
    controllerFor: typeof Ember$controllerFor,
    copy: typeof Ember$copy,
    create: typeof Ember$create,
    debug: typeof Ember$debug,
    defineProperty: typeof Ember$defineProperty,
    deprecate: typeof Ember$deprecate,
    deprecateFunc: typeof Ember$deprecateFunc,
    destroy: typeof Ember$destroy,
    endPropertyChanges: typeof Ember$endPropertyChanges,
    finishChains: typeof Ember$finishChains,
    flushPendingChains: typeof Ember$flushPendingChains,
    generateController: typeof Ember$generateController,
    generateGuid: typeof Ember$generateGuid,
    get: typeof Ember$get,
    getMeta: typeof Ember$getMeta,
    getWithDefault: typeof Ember$getWithDefault,
    guidFor: typeof Ember$guidFor,
    handleErrors: typeof Ember$handleErrors,
    hasListeners: typeof Ember$hasListeners,
    hasOwnProperty: typeof Ember$hasOwnProperty,
    immediateObserver: typeof Ember$immediateObserver,
    inspect: typeof Ember$inspect,
    instrument: typeof Ember$instrument,
    isArray: typeof Ember$isArray,
    isEmpty: typeof Ember$isEmpty,
    isEqual: typeof Ember$isEqual,
    isGlobalPath: typeof Ember$isGlobalPath,
    isNone: typeof Ember$isNone,
    isPrototypeOf: typeof Ember$isPrototypeOf,
    isWatching: typeof Ember$isWatching,
    keys: typeof Ember$keys,
    listenersDiff: typeof Ember$listenersDiff,
    listenersFor: typeof Ember$listenersFor,
    listenersUnion: typeof Ember$listenersUnion,
    makeArray: typeof Ember$makeArray,
    merge: typeof Ember$merge,
    meta: typeof Ember$meta,
    metaPath: typeof Ember$metaPath,
    mixin: typeof Ember$mixin,
    normalizeTuple: typeof Ember$normalizeTuple,
    observer: typeof Ember$observer,
    observersFor: typeof Ember$observersFor,
    onLoad: typeof Ember$onLoad,
    oneWay: typeof Ember$oneWay,
    overrideChains: typeof Ember$overrideChains,
    propertyDidChange: typeof Ember$propertyDidChange,
    propertyIsEnumerable: typeof Ember$propertyIsEnumerable,
    propertyWillChange: typeof Ember$propertyWillChange,
    removeBeforeObserver: typeof Ember$removeBeforeObserver,
    removeChainWatcher: typeof Ember$removeChainWatcher,
    removeListener: typeof Ember$removeListener,
    removeObserver: typeof Ember$removeObserver,
    required: typeof Ember$required,
    rewatch: typeof Ember$rewatch,
    runLoadHooks: typeof Ember$runLoadHooks,
    sendEvent: typeof Ember$sendEvent,
    set: typeof Ember$set,
    setMeta: typeof Ember$setMeta,
    setProperties: typeof Ember$setProperties,
    subscribe: typeof Ember$subscribe,
    toLocaleString: typeof Ember$toLocaleString,
    toString: typeof Ember$toString,
    tryCatchFinally: typeof Ember$tryCatchFinally,
    tryFinally: typeof Ember$tryFinally,
    tryInvoke: typeof Ember$tryInvoke,
    trySet: typeof Ember$trySet,
    typeOf: typeof Ember$typeOf,
    unwatch: typeof Ember$unwatch,
    unwatchKey: typeof Ember$unwatchKey,
    unwatchPath: typeof Ember$unwatchPath,
    valueOf: typeof Ember$valueOf,
    warn: typeof Ember$warn,
    watch: typeof Ember$watch,
    watchKey: typeof Ember$watchKey,
    watchPath: typeof Ember$watchPath,
    watchedEvents: typeof Ember$watchedEvents,
    wrap: typeof Ember$wrap,
}
declare
var $: JQueryStatic;


/**
 * Creates an Ember.NativeArray from an Array like object. Does not modify the original object.
 * Ember.A is not needed if Ember.EXTEND_PROTOTYPES is true (the default value). However, it is
recommended that you use Ember.A when creating addons for ember or when you can not garentee
that Ember.EXTEND_PROTOTYPES will be true.
*/
declare
function Ember$A(arr?: any[]): Em$NativeArray


/**
 * The Ember.ActionHandler mixin implements support for moving an actions property to an _actions
 * property at extend time, and adding _actions to the object's mergedProperties list.
 */
declare class ActionHandlerMixin {

    /**
     * Triggers a named action on the ActionHandler
     */
    send(name: string, ...args: any[]): void;

    /**
     * The collection of functions, keyed by name, available on this ActionHandler as action targets.
     */
    actions: ActionsHash
}


/**
 * An instance of Ember.Application is the starting point for every Ember application. It helps to
 * instantiate, initialize and coordinate the many objects that make up your app.
 */
declare class Application mixins Namespace {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    initializer(args?: ApplicationInitializerArguments): void;

    /**
     * Call advanceReadiness after any asynchronous setup logic has completed.
     * Each call to deferReadiness must be matched by a call to advanceReadiness
    or the application will never become ready and routing will not begin.
    */
    advanceReadiness(): void;

    /**
     * Use this to defer readiness until some condition is true.
     * 
    This allows you to perform asynchronous setup logic and defer
    booting your application until the setup has finished.

    However, if the setup requires a loading UI, it might be better
    to use the router for this purpose.
    */
    deferReadiness(): void;

    /**
     * defines an injection or typeInjection
     */
    inject(factoryNameOrType: string, property: string, injectionName: string): void;

    /**
     * This injects the test helpers into the window's scope. If a function of the
     * same name has already been defined it will be cached (so that it can be reset
    if the helper is removed with `unregisterHelper` or `removeTestHelpers`).
    Any callbacks registered with `onInjectHelpers` will be called once the
    helpers have been injected.
    */
    injectTestHelpers(): void;

    /**
     * registers a factory for later injection
     * @param fullName type:name (e.g., 'model:user')
     * @param factory (e.g., App.Person)
     */
    register(fullName: string, factory: Function, options?: {}): void;

    /**
     * This removes all helpers that have been registered, and resets and functions
     * that were overridden by the helpers.
     */
    removeTestHelpers(): void;

    /**
     * Reset the application. This is typically used only in tests.
     */
    reset(): void;

    /**
     * This hook defers the readiness of the application, so that you can start
     * the app when your tests are ready to run. It also sets the router's
    location to 'none', so that the window's location will not be modified
    (preventing both accidental leaking of state between tests and interference
    with your testing framework).
    */
    setupForTesting(): void;

    /**
     * The DOM events for which the event dispatcher should listen.
     */
    customEvents: {};

    /**
     * The Ember.EventDispatcher responsible for delegating events to this application's views.
     */
    eventDispatcher: Em$EventDispatcher;

    /**
     * Set this to provide an alternate class to Ember.DefaultResolver
     */
    resolver: Em$DefaultResolver;

    /**
     * The root DOM element of the Application. This can be specified as an
     * element or a jQuery-compatible selector string.

    This is the element that will be passed to the Application's, eventDispatcher,
    which sets up the listeners for event delegation. Every view in your application
    should be a child of the element you specify here.
    */
    rootElement: HTMLElement;

    /**
     * Called when the Application has become ready.
     * The call will be delayed until the DOM has become ready.
     */
    ready: Function;

    /**
     * Application's router.
     */
    Router: Em$Router
}


/**
 * This module implements Observer-friendly Array-like behavior. This mixin is picked up by the
 * Array class as well as other controllers, etc. that want to appear to be arrays.
 */
declare class Array mixins Enumerable {
    addArrayObserver(target: any, opts?: EnumerableConfigurationOptions): any[];
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Em$Enumerable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    arrayContentDidChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    arrayContentWillChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    someProperty(key: string, value?: string): boolean;
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Em$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Em$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Em$Enumerable, adding: Em$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Em$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Em$Enumerable): any;
    enumerableContentDidChange(removing: Em$Enumerable, adding: Em$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Em$Enumerable;
    enumerableContentWillChange(removing: Em$Enumerable, adding: number): Em$Enumerable;
    enumerableContentWillChange(removing: number, adding: Em$Enumerable): Em$Enumerable;
    enumerableContentWillChange(removing: Em$Enumerable, adding: Em$Enumerable): Em$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target?: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    indexOf(object: any, startAt: number): number;
    invoke(methodName: string, ...args: any[]): any[];
    lastIndexOf(object: any, startAt: number): number;
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    objectAt(idx: number): any;
    objectsAt(...args: number[]): any[];
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeArrayObserver(target: any, opts: EnumerableConfigurationOptions): any[];
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Em$Enumerable;
    setEach(key: string, value?: any): any;
    slice(beginIndex?: number, endIndex?: number): any[];
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Em$Enumerable;
    without(value: any): Em$Enumerable;
    @each: Em$EachProxy;
    Boolean: boolean;
    []: any[];
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    length: number
}


/**
 * Provides a way for you to publish a collection of objects so that you can easily bind to the
 * collection from a Handlebars #each helper, an Ember.CollectionView, or other controllers.
 */
declare class ArrayController mixins ArrayProxy, SortableMixin, ControllerMixin {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    lookupItemController(object: any): string;
    arrangedContent: any;
    itemController: string;
    sortAscending: boolean;
    sortFunction: Em$Comparable;
    sortProperties: any[];
    replaceRoute(name: string, ...args: any[]): void;
    transitionToRoute(name: string, ...args: any[]): void;
    controllers: {};
    needs: string[];
    target: any;
    model: any;
    queryParams: any;
    send(name: string, ...args: any[]): void;
    actions: {}
}

declare
var ArrayPolyfills: {
    map: typeof undefined,
    forEach: typeof undefined,
    indexOf: typeof undefined
};


/**
 * An ArrayProxy wraps any other object that implements Ember.Array and/or Ember.MutableArray,
 * forwarding all requests. This makes it very useful for a number of binding use cases or other cases
where being able to swap out the underlying array is useful.
*/
declare class ArrayProxy mixins Object, MutableArray {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    addArrayObserver(target: any, opts?: EnumerableConfigurationOptions): any[];
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Em$Enumerable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    arrayContentDidChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    arrayContentWillChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    someProperty(key: string, value?: string): boolean;
    clear(): any[];
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Em$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Em$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Em$Enumerable, adding: Em$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Em$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Em$Enumerable): any;
    enumerableContentDidChange(removing: Em$Enumerable, adding: Em$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Em$Enumerable;
    enumerableContentWillChange(removing: Em$Enumerable, adding: number): Em$Enumerable;
    enumerableContentWillChange(removing: number, adding: Em$Enumerable): Em$Enumerable;
    enumerableContentWillChange(removing: Em$Enumerable, adding: Em$Enumerable): Em$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    indexOf(object: any, startAt: number): number;
    insertAt(idx: number, object: any): any[];
    invoke(methodName: string, ...args: any[]): any[];
    lastIndexOf(object: any, startAt: number): number;
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    objectAt(idx: number): any;
    objectAtContent(idx: number): any;
    objectsAt(...args: number[]): any[];
    popObject(): any;
    pushObject(obj: any): any;
    pushObjects(...args: any[]): any[];
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeArrayObserver(target: any, opts: EnumerableConfigurationOptions): any[];
    removeAt(start: number, len: number): any;
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Em$Enumerable;
    replace(idx: number, amt: number, objects: any[]): any;
    replaceContent(idx: number, amt: number, objects: any[]): void;
    reverseObjects(): any[];
    setEach(key: string, value?: any): any;
    setObjects(objects: any[]): any[];
    shiftObject(): any;
    slice(beginIndex?: number, endIndex?: number): any[];
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Em$Enumerable;
    unshiftObject(object: any): any;
    unshiftObjects(objects: any[]): any[];
    without(value: any): Em$Enumerable;
    []: any[];
    @each: Em$EachProxy;
    Boolean: boolean;
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    length: number;
    addObject(object: any): any;
    addObjects(objects: Em$Enumerable): Ember$MutableEnumberable;
    removeObject(object: any): any;
    removeObjects(objects: Em$Enumerable): Ember$MutableEnumberable
}

declare
var BOOTED: boolean;


/**
 * Connects the properties of two objects so that whenever the value of one property changes,
 * the other property will be changed also.
 */
declare class Binding {
    constructor(toPath: string, fromPath: string): this;
    connect(obj: any): Ember$Binding;
    copy(): Ember$Binding;
    disconnect(obj: any): Ember$Binding;
    from(path: string): Ember$Binding;
    oneWay(from: string, flag?: boolean): Ember$Binding;
    to(path: string): Ember$Binding;
    to(pathTuple: any[]): Ember$Binding;
    toString(): string
}

declare class Button mixins View, TargetActionSupport {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    triggerAction(opts: {}): boolean
}


/**
 * The internal class used to create text inputs when the {{input}} helper is used
 * with type of checkbox. See Handlebars.helpers.input for usage details.
 */
declare class Checkbox mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}


/**
 * An Ember.View descendent responsible for managing a collection (an array or array-like object)
 * by maintaining a child view object and associated DOM representation for each item in the array
and ensuring that child views and their associated rendered HTML are updated when items in the
array are added, removed, or replaced.
*/
declare class CollectionView mixins ContainerView {
    arrayDidChange(content: any[], start: number, removed: number, added: number): void;
    arrayWillChange(content: any[], start: number, removed: number): void;
    createChildView(viewClass: {}, attrs?: {}): Ember$CollectionView;
    destroy(): Ember$CollectionView;
    init(): void;
    CONTAINER_MAP: {};
    content: any[];
    emptyView: Em$View;
    itemViewClass: Em$View
}


/**
 * Implements some standard methods for comparing objects. Add this mixin to any class
 * you create that can compare its instances.
 */
declare class Comparable {
    compare(a: any, b: any): number
}


/**
 * A view that is completely isolated. Property access in its templates go to the view object
 * and actions are targeted at the view object. There is no access to the surrounding context or
outer controller; all contextual information is passed in.
*/
declare class Component mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    sendAction(action: string, context: any): void;
    targetObject: Em$Controller
}


/**
 * A computed property transforms an objects function into a property.
 * By default the function backing the computed property will only be called once and the result
will be cached. You can specify various properties that your computed property is dependent on.
This will force the cached result to be recomputed if the dependencies are modified.
*/
declare class ComputedProperty {
    cacheable(aFlag?: boolean): Ember$ComputedProperty;
    get(keyName: string): any;
    meta(meta: {}): Ember$ComputedProperty;
    property(...args: string[]): Ember$ComputedProperty;
    readOnly(): Ember$ComputedProperty;
    set(keyName: string, newValue: any, oldValue: string): any;
    volatile(): Ember$ComputedProperty
}

declare class Container {
    constructor(parent: Ember$Container): this;
    parent: Ember$Container;
    children: any[];
    resolver: Function;
    registry: {};
    cache: {};
    typeInjections: {};
    injections: {};
    child(): Ember$Container;
    set(object: {}, key: string, value: any): void;

    /**
     * registers a factory for later injection
     * @param fullName type:name (e.g., 'model:user')
     * @param factory (e.g., App.Person)
     */
    register(fullName: string, factory: Function, options?: {}): void;
    unregister(fullName: string): void;
    resolve(fullName: string): Function;
    describe(fullName: string): string;
    normalize(fullName: string): string;
    makeToString(factory: any, fullName: string): Function;
    lookup(fullName: string, options?: {}): any;
    lookupFactory(fullName: string): any;
    has(fullName: string): boolean;
    optionsForType(type: string, options: {}): void;
    options(type: string, options: {}): void;
    injection(factoryName: string, property: string, injectionName: string): void;
    factoryInjection(factoryName: string, property: string, injectionName: string): void;
    destroy(): void;
    reset(): void
}


/**
 * An Ember.View subclass that implements Ember.MutableArray allowing programatic
 * management of its child views.
 */
declare class ContainerView mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}

declare class Controller mixins Object, ControllerMixin {
    replaceRoute(name: string, ...args: any[]): void;
    transitionToRoute(name: string, ...args: any[]): void;
    controllers: {};
    model: any;
    needs: string[];
    queryParams: any;
    target: any;
    send(name: string, ...args: any[]): void;
    actions: ActionsHash
}


/**
 * Additional methods for the ControllerMixin.
 */
declare class ControllerMixin mixins ActionHandlerMixin {
    replaceRoute(name: string, ...args: any[]): void;
    transitionToRoute(name: string, ...args: any[]): void;
    controllers: {};
    model: any;
    needs: string[];
    queryParams: any;
    target: any
}


/**
 * Implements some standard methods for copying an object. Add this mixin to any object you
 * create that can create a copy of itself. This mixin is added automatically to the built-in array.
You should generally implement the copy() method to return a copy of the receiver.
Note that frozenCopy() will only work if you also implement Ember.Freezable.
*/
declare class Copyable {
    copy(deep: boolean): Ember$Copyable;
    frozenCopy(): Ember$Copyable
}

declare class CoreObject {

    /**
     * An overridable method called when objects are instantiated. By default,
     * does nothing unless it is overridden during class definition.
     * @method  init
     */
    init(): void;

    /**
     * Defines the properties that will be concatenated from the superclass (instead of overridden).
     * @property  concatenatedProperties
     * @type  Array
     * @default  null
     */
    concatenatedProperties: any[];

    /**
     * Destroyed object property flag. If this property is true the observers and bindings were
     * already removed by the effect of calling the destroy() method.
     * @property  isDestroyed
     * @default  false
     */
    isDestroyed: boolean;

    /**
     * Destruction scheduled flag. The destroy() method has been called. The object stays intact
     * until the end of the run loop at which point the isDestroyed flag is set.
     * @property  isDestroying
     * @default  false
     */
    isDestroying: boolean;

    /**
     * Destroys an object by setting the `isDestroyed` flag and removing its
     * metadata, which effectively destroys observers and bindings.
    If you try to set a property on a destroyed object, an exception will be
    raised.
    Note that destruction is scheduled for the end of the run loop and does not
    happen immediately.  It will set an isDestroying flag immediately.
     * @method  destroy
     * @return  receiver
    */
    destroy(): Ember$CoreObject;

    /**
     * Override to implement teardown.
     * @method  willDestroy
     */
    willDestroy(): void;

    /**
     * Returns a string representation which attempts to provide more information than Javascript's toString
     * typically does, in a generic way for all Ember objects (e.g., "<App.Person:ember1024>").
     * @method  toString
     * @return  string representation
     */
    toString(): string;
    isClass: boolean;
    isMethod: boolean;

    /**
     * Creates a new subclass.
     * @method  extend
     * @static  
     * @param  - Object containing values to use within the new class
     */
    extend<T>(args?: CoreObjectArguments): T;

    /**
     * Creates a new subclass.
     * @method  extend
     * @static  
     * @param  - One or more Mixin classes
     * @param  - Object containing values to use within the new class
     */
    extend<T>(mixins?: Em$Mixin, args?: CoreObjectArguments): T;

    /**
     * Creates a new subclass.
     * @method  extend
     * @param  - Object containing values to use within the new class
    Non-static method because Ember classes aren't currently 'real' TypeScript classes.
    */
    extend<T>(args?: CoreObjectArguments): T;

    /**
     * Creates a new subclass.
     * @method  extend
     * @param  - One or more Mixin classes
     * @param  - Object containing values to use within the new class
    Non-static method because Ember classes aren't currently 'real' TypeScript classes.
    */
    extend<T>(mixins?: Em$Mixin, args?: CoreObjectArguments): T;

    /**
     * Equivalent to doing extend(arguments).create(). If possible use the normal create method instead.
     * @method  createWithMixins
     * @static  
     * @param args **
     */
    createWithMixins<T>(args?: {}): T;

    /**
     * Creates an instance of the class.
     * @method  create
     * @static  
     * @param args - A hash containing values with which to initialize the newly instantiated object.
     */
    create<T>(args?: {}): T;

    /**
     * Augments a constructor's prototype with additional properties and functions.
     * To add functions and properties to the constructor itself, see reopenClass.
     * @method  reopen
     */
    reopen<T>(args?: {}): T;

    /**
     * Augments a constructor's own properties and functions.
     * To add functions and properties to instances of a constructor by extending the
    constructor's prototype see reopen.
     * @method  reopenClass
    */
    reopenClass<T>(args?: {}): T;
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Returns the original hash that was passed to meta().
     * @method  metaForProperty
     * @static  
     * @param key property name
     */
    metaForProperty(key: string): {};

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     * @method  eachComputedProperty
     * @static  
     * @param  
     * @param  
     */
    eachComputedProperty(callback: Function, binding: {}): void
}


/**
 * An abstract class that exists to give view-like behavior to both Ember's main view class Ember.View
 * and other classes like Ember._SimpleMetamorphView that don't need the fully functionaltiy of Ember.View.
Unless you have specific needs for CoreView, you will use Ember.View in your applications.
*/
declare class CoreView mixins Object, ActionHandlerMixin {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    send(name: string, ...args: any[]): void;
    actions: ActionsHash;
    parentView: Ember$CoreView
}

declare class DAG {
    add(name: string): any;
    map(name: string, value: any): void;
    addEdge(fromName: string, toName: string): void;
    topsort(fn: Function): void;
    addEdges(name: string, value: any, before: any, after: any): void;
    names: any[];
    vertices: {}
}

declare
function Ember$DEFAULT_GETTER_FUNCTION(name: string): Function


/**
 * The DefaultResolver defines the default lookup rules to resolve container lookups before consulting
 * the container for registered items:
templates are looked up on Ember.TEMPLATES
other names are looked up on the application after converting the name.
For example, controller:post looks up App.PostController by default.
*/
declare class DefaultResolver {
    resolve(fullName: string): {};
    namespace: Ember$Application
}

declare class Deferred {
    reject(value: any): void;
    resolve(value: any): void;
    then(resolve: Function, reject: Function): void
}

declare class DeferredMixin mixins Mixin {
    reject(value: any): void;
    resolve(value: any): void;
    then(resolve: Function, reject: Function): void
}


/**
 * Objects of this type can implement an interface to respond to requests to get and set.
 * The default implementation handles simple properties.
You generally won't need to create or subclass this directly.
*/
declare class Descriptor {}

declare
var EMPTY_META: {};

declare
var ENV: {};

declare
var EXTEND_PROTOTYPES: boolean;


/**
 * This is the object instance returned when you get the @each property on an array. It uses
 * the unknownProperty handler to automatically create EachArray instances for property names.
 */
declare class EachProxy mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    unknownProperty(keyName: string, value: any): any[]
}


/**
 * This mixin defines the common interface implemented by enumerable objects in Ember. Most of these
 * methods follow the standard Array iteration API defined up to JavaScript 1.8 (excluding language-specific
features that cannot be emulated in older versions of JavaScript).
This mixin is applied automatically to the Array class on page load, so you can use any of these methods
on simple arrays. If Array already implements one of these methods, the mixin will not override them.
*/
declare class Enumerable {
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    someProperty(key: string, value?: string): boolean;
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    invoke(methodName: string, ...args: any[]): any[];
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    setEach(key: string, value?: any): any;
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Enumerable;
    without(value: any): Ember$Enumerable;
    []: any[];
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any
}

declare
var EnumerableUtils: {};

declare
var Error: any;


/**
 * Handles delegating browser events to their corresponding Ember.Views. For example, when you click on
 * a view, Ember.EventDispatcher ensures that that view's mouseDown method gets called.
 */
declare class EventDispatcher mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    events: {}
}


/**
 * This mixin allows for Ember objects to subscribe to and emit events.
 * You can also chain multiple event subscriptions.
 */
declare class Evented {
    has(name: string): boolean;
    off(name: string, target: any, method: Function): Ember$Evented;
    on(name: string, target: any, method: Function): Ember$Evented;
    one(name: string, target: any, method: Function): Ember$Evented;
    trigger(name: string, ...args: string[]): void
}

declare
var FROZEN_ERROR: string;

declare class Freezable {
    freeze(): Ember$Freezable;
    isFrozen: boolean
}

declare
var GUID_KEY: string;


declare
var npm$namespace$Handlebars: {
    compile: typeof Handlebars$compile,
    get: typeof Handlebars$get,
    helper: typeof Handlebars$helper,
    precompile: typeof Handlebars$precompile,
    registerBoundHelper: typeof Handlebars$registerBoundHelper,
    registerHelper: typeof Handlebars$registerHelper,
    registerPartial: typeof Handlebars$registerPartial,
    K: typeof Handlebars$K,
    createFrame: typeof Handlebars$createFrame,
    Exception: typeof Handlebars$Exception,
    parse: typeof Handlebars$parse,
    print: typeof Handlebars$print,
    log: typeof Handlebars$log,
}
declare
function Handlebars$compile(string: string): Function

declare
function Handlebars$get(root: any, path: string, options?: {}): any

declare
function Handlebars$helper(name: string, func: Function, dependentKeys?: string): void

declare class helpers {
    action(actionName: string, context: any, options?: {}): void;
    bindAttr(options?: {}): string;
    connectOutlet(outletName: string, view: {}): void;
    control(path: string, modelPath: string, options?: {}): string;
    debugger(property: string): void;
    disconnectOutlet(outletName: string): void;
    each(name: string, path: string, options?: {}): void;
    if (context: Function, options?: {}): string;
    init(): void;
    input(options?: {}): void;
    linkTo(routeName: string, context: any, options?: {}): string;
    loc(str: string): void;
    log(property: string): void;
    outlet(property: string): string;
    partial(partialName: string): void;
    render(name: string, context?: string, options?: {}): string;
    textarea(options?: {}): void;
    unbound(property: string): string;
    unless(context: Function, options?: {}): string;
    view(path: string, options?: {}): string;
    with(context: Function, options?: {}): string;
    yield(options?: {}): string
}

declare
function Handlebars$precompile(string: string): void

declare
function Handlebars$registerBoundHelper(name: string, func: Function, dependentKeys?: string): void

declare class Compiler {}

declare class JavaScriptCompiler {}

declare
function Handlebars$registerHelper(name: string, fn: Function, inverse?: boolean): void

declare
function Handlebars$registerPartial(name: string, str: any): void

declare
function Handlebars$K(): any

declare
function Handlebars$createFrame(objec: any): any

declare
function Handlebars$Exception(message: string): void

declare class SafeString {
    constructor(str: string): this;
    toString(): string
}

declare
function Handlebars$parse(string: string): any

declare
function Handlebars$print(ast: any): void

declare
var logger: typeof undefined;

declare
function Handlebars$log(level: string, str: string): void

declare class HashLocation mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}

declare class HistoryLocation mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    rootURL: string
}

declare
var IS_BINDING: RegExp;

declare class Instrumentation {
    getProperties(obj: any, list: any[]): {};
    getProperties(obj: any, ...args: string[]): {};
    instrument(name: string, payload: any, callback: Function, binding: any): void;
    reset(): void;
    subscribe(pattern: string, object: any): void;
    unsubscribe(subscriber: any): void
}

declare
var K: Function;

declare
var LOG_BINDINGS: boolean;

declare
var LOG_STACKTRACE_ON_DEPRECATION: boolean;

declare
var LOG_VERSION: boolean;

declare class LinkView mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    init(): void;
    active: any;
    activeClass: string;
    attributeBindings: any;
    classNameBindings: string[];
    disabled: any;
    disabledClass: string;
    eventName: string;
    href: any;
    loading: any;
    loadingClass: string;
    loadingHref: string;
    rel: any;
    replace: boolean;
    title: any;
    click: Function
}

declare class Location {
    create(options?: {}): any;
    registerImplementation(name: string, implementation: any): void
}

declare
var Logger: {
    assert(param: any): void,
    debug(...args: any[]): void,
    error(...args: any[]): void,
    info(...args: any[]): void,
    log(...args: any[]): void,
    warn(...args: any[]): void
};

declare
function Ember$MANDATORY_SETTER_FUNCTION(value: string): void

declare
var META_KEY: string;

declare class Map {
    copy(): Ember$Map;
    create(): Ember$Map;
    forEach(callback: Function, self: any): void;
    get(key: any): any;
    has(key: any): boolean;
    remove(key: any): boolean;
    set(key: any, value: any): void;
    length: number
}

declare class MapWithDefault mixins Map {
    copy(): Ember$MapWithDefault;
    create(): Ember$MapWithDefault
}

declare class Mixin {
    apply(obj: any): any;

    /**
     * Creates an instance of the class.
     * @param arguments A hash containing values with which to initialize the newly instantiated object.
     */
    create<T>(...args: CoreObjectArguments[]): T;
    detect(obj: any): boolean;
    reopen<T>(args?: {}): T
}

declare class MutableArray mixins Array, MutableEnumberable {
    addArrayObserver(target: any, opts?: EnumerableConfigurationOptions): any[];
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    arrayContentDidChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    arrayContentWillChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    someProperty(key: string, value?: string): boolean;
    clear(): any[];
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    indexOf(object: any, startAt: number): number;
    insertAt(idx: number, object: any): any[];
    invoke(methodName: string, ...args: any[]): any[];
    lastIndexOf(object: any, startAt: number): number;
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    objectAt(idx: number): any;
    objectsAt(...args: number[]): any[];
    popObject(): any;
    pushObject(obj: any): any;
    pushObjects(...args: any[]): any[];
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeArrayObserver(target: any, opts: EnumerableConfigurationOptions): any[];
    removeAt(start: number, len: number): any;
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    replace(idx: number, amt: number, objects: any[]): any;
    reverseObjects(): any[];
    setEach(key: string, value?: any): any;
    setObjects(objects: any[]): any[];
    shiftObject(): any;
    slice(beginIndex?: number, endIndex?: number): any[];
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Enumerable;
    unshiftObject(object: any): any;
    unshiftObjects(objects: any[]): any[];
    without(value: any): Ember$Enumerable;
    []: any[];
    @each: Ember$EachProxy;
    Boolean: boolean;
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    length: number;
    addObject(object: any): any;
    addObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    removeObject(object: any): any;
    removeObjects(objects: Ember$Enumerable): Ember$MutableEnumberable
}

declare class MutableEnumberable mixins Enumerable {
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    addObject(object: any): any;
    addObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    someProperty(key: string, value?: string): boolean;
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    invoke(methodName: string, ...args: any[]): any[];
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    removeObject(object: any): any;
    removeObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    setEach(key: string, value?: any): any;
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Enumerable;
    without(value: any): Ember$Enumerable;
    []: any[];
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any
}

declare
var NAME_KEY: string;

declare class Namespace mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}

declare class NativeArray mixins MutableArray, Observable, Copyable {
    constructor(arr: any[]): this;
    activate(): void;
    addArrayObserver(target: any, opts?: EnumerableConfigurationOptions): any[];
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    arrayContentDidChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    arrayContentWillChange(startIdx: number, removeAmt: number, addAmt: number): any[];
    someProperty(key: string, value?: any): boolean;
    clear(): any[];
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: any): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    indexOf(object: any, startAt: number): number;
    insertAt(idx: number, object: any): any[];
    invoke(methodName: string, ...args: any[]): any[];
    lastIndexOf(object: any, startAt: number): number;
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    objectAt(idx: number): any;
    objectsAt(...args: number[]): any[];
    popObject(): any;
    pushObject(obj: any): any;
    pushObjects(...args: any[]): any[];
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeArrayObserver(target: any, opts: EnumerableConfigurationOptions): any[];
    removeAt(start: number, len: number): any;
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    replace(idx: number, amt: number, objects: any[]): any;
    reverseObjects(): any[];
    setEach(key: string, value?: any): any;
    setObjects(objects: any[]): any[];
    shiftObject(): any;
    slice(beginIndex?: number, endIndex?: number): any[];
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Enumerable;
    unshiftObject(object: any): any;
    unshiftObjects(objects: any[]): any[];
    without(value: any): Ember$Enumerable;
    []: any[];
    @each: Ember$EachProxy;
    Boolean: boolean;
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    length: number;
    addObject(object: any): any;
    addObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    removeObject(object: any): any;
    removeObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    addObserver: ModifyObserver;
    beginPropertyChanges(): Em$Observable;
    cacheFor(keyName: string): any;
    decrementProperty(keyName: string, decrement?: number): number;
    endPropertyChanges(): Em$Observable;
    get(keyName: string): any;
    getProperties(...args: string[]): {};
    getProperties(keys: string[]): {};
    getWithDefault(keyName: string, defaultValue: any): any;
    hasObserverFor(key: string): boolean;
    incrementProperty(keyName: string, increment?: number): number;
    notifyPropertyChange(keyName: string): Em$Observable;
    propertyDidChange(keyName: string): Em$Observable;
    propertyWillChange(keyName: string): Em$Observable;
    removeObserver(key: string, target: any, method: string): void;
    removeObserver(key: string, target: any, method: Function): void;
    set(keyName: string, value: any): Em$Observable;
    setProperties(hash: {}): Em$Observable;
    toggleProperty(keyName: string): any;
    copy(deep: boolean): Ember$Copyable;
    frozenCopy(): Ember$Copyable
}

declare class NoneLocation mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}

declare
var ORDER_DEFINITION: string[];

declare class Object mixins CoreObject, Observable {
    addObserver: ModifyObserver;
    beginPropertyChanges(): Em$Observable;
    cacheFor(keyName: string): any;
    decrementProperty(keyName: string, decrement?: number): number;
    endPropertyChanges(): Em$Observable;

    /**
     * Retrieves the value of a property from the object
     * @param keyName 
     * @returns  
     */
    get(keyName: string): any;

    /**
     * Retrieves the value of a property from the object
     * @param keyName 
     * @returns  
     */
    get<T>(keyName: string): T;
    getProperties(...args: string[]): {};
    getProperties(keys: string[]): {};
    getWithDefault(keyName: string, defaultValue: any): any;
    hasObserverFor(key: string): boolean;
    incrementProperty(keyName: string, increment?: number): number;
    notifyPropertyChange(keyName: string): Em$Observable;
    propertyDidChange(keyName: string): Em$Observable;
    propertyWillChange(keyName: string): Em$Observable;
    removeObserver(key: string, target: any, method: string): Em$Observable;
    removeObserver(key: string, target: any, method: Function): Em$Observable;
    set(keyName: string, value: any): Em$Observable;
    setProperties(hash: {}): Em$Observable;
    toggleProperty(keyName: string): any
}

declare class ObjectController mixins ObjectProxy, ControllerMixin {
    replaceRoute(name: string, ...args: any[]): void;
    transitionToRoute(name: string, ...args: any[]): void;
    controllers: Ember$Object;
    needs: string[];
    target: any;
    model: any;
    queryParams: any;
    send(name: string, ...args: any[]): void;
    actions: {}
}

declare class ObjectProxy mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;

    /**
     * The object whose properties will be forwarded.
     */
    content: Ember$Object
}

declare class Observable {
    addObserver: ModifyObserver;
    beginPropertyChanges(): Ember$Observable;
    cacheFor(keyName: string): any;
    decrementProperty(keyName: string, decrement?: number): number;
    endPropertyChanges(): Ember$Observable;
    get(keyName: string): any;
    getProperties(...args: string[]): {};
    getProperties(keys: string[]): {};
    getWithDefault(keyName: string, defaultValue: any): any;
    hasObserverFor(key: string): boolean;
    incrementProperty(keyName: string, increment?: number): number;
    notifyPropertyChange(keyName: string): Ember$Observable;
    propertyDidChange(keyName: string): Ember$Observable;
    propertyWillChange(keyName: string): Ember$Observable;
    removeObserver(key: string, target: {}, method: string): void;
    removeObserver(key: string, target: {}, method: Function): void;
    set(keyName: string, value: any): Ember$Observable;
    setProperties(hash: {}): Ember$Observable;

    /**
     * Set the value of a boolean property to the opposite of its current value.
     */
    toggleProperty(keyName: string): boolean
}

declare class OrderedSet {
    add(obj: any): void;
    clear(): void;
    copy(): Ember$OrderedSet;
    create(): Ember$OrderedSet;
    forEach(fn: Function, self: any): void;
    has(obj: any): boolean;
    isEmpty(): boolean;
    remove(obj: any): void;
    toArray(): any[]
}

declare interface RSVP$PromiseResolve {
    (value?: any): void
}

declare interface RSVP$PromiseReject {
    (reason?: any): void
}

declare interface RSVP$PromiseResolverFunction {
    (resolve: RSVP$PromiseResolve, reject: RSVP$PromiseReject): void
}

declare class Promise {

    /**
     * Promise objects represent the eventual result of an asynchronous operation. The
     * primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promise's eventual value or the reason
    why the promise cannot be fulfilled.
     * @class  RSVP.Promise
     * @param  
     * @param  optional string for labeling the promise.
    Useful for tooling.
     * @constructor  
    */
    constructor(resolver: RSVP$PromiseResolverFunction, label?: string): this;

    /**
     * The primary way of interacting with a promise is through its `then` method,
     * which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
     * @method  then
     * @param  
     * @param  
     * @param  optional string for labeling the promise.
    Useful for tooling.
     * @return  
    */
    then(onFulfilled?: Function, onRejected?: Function): RSVP$Promise;

    /**
     * `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
     * as the catch block of a try/catch statement.
     * @method  catch
     * @param  
     * @param  optional string for labeling the promise.
    Useful for tooling.
     * @return  
    */
    catch (onRejection: Function, label?: string): RSVP$Promise;

    /**
     * `finally` will be invoked regardless of the promise's fate just as native
     * try/catch/finally behaves
     * @method  finally
     * @param  
     * @param  optional string for labeling the promise.
    Useful for tooling.
     * @return  
    */
    finally(callback: Function, label?: string): RSVP$Promise
}

declare class RenderBuffer {
    addClass(className: string): Ember$RenderBuffer;
    attr(name: string, value: any): any;
    element(): HTMLElement;
    id(id: string): Ember$RenderBuffer;
    prop(name: string, value: string): any;
    push(string: string): Ember$RenderBuffer;
    removeAttr(name: string): Ember$RenderBuffer;
    removeProp(name: string): Ember$RenderBuffer;
    string(): string;
    style(name: string, value: string): Ember$RenderBuffer;
    classes: any[];
    elementAttributes: {};
    elementId: string;
    elementProperties: {};
    elementStyle: {};
    elementTag: string;
    parentBuffer: Ember$RenderBuffer
}


/**
 * The `Ember.Route` class is used to define individual routes. Refer to
 * the [routing guide](http://emberjs.com/guides/routing/) for documentation.
 */
declare class Route mixins Object, ActionHandlerMixin, Evented {
    isClass: boolean;
    isMethod: boolean;

    /**
     * This hook is executed when the router enters the route. It is not executed
     * when the model for the route changes.
     * @method  activate
     */
    activate: Function;

    /**
     * This hook is called after this route's model has resolved.
     * It follows identical async/promise semantics to `beforeModel`
    but is provided the route's resolved model in addition to
    the `transition`, and is therefore suited to performing
    logic that can only take place after the model has already
    resolved.

    Refer to documentation for `beforeModel` for a description
    of transition-pausing semantics when a promise is returned
    from this hook.
     * @method  afterModel
     * @param  the value returned from `model`,
    or its resolved value if it was a promise
     * @param  
     * @return  if the value returned from this hook is
    a promise, the transition will pause until the transition
    resolves. Otherwise, non-promise return values are not
    utilized in any way.
    */
    afterModel(resolvedModel: any, transition: EmberStates$Transition): RSVP$Promise;

    /**
     * This hook is the first of the route entry validation hooks
     * called when an attempt is made to transition into a route
    or one of its children. It is called before `model` and
    `afterModel`, and is appropriate for cases when:
    1) A decision can be made to redirect elsewhere without
         needing to resolve the model first.
    2) Any async operations need to occur first before the
         model is attempted to be resolved.
    This hook is provided the current `transition` attempt
    as a parameter, which can be used to `.abort()` the transition,
    save it for a later `.retry()`, or retrieve values set
    on it from a previous hook. You can also just call
    `this.transitionTo` to another route to implicitly
    abort the `transition`.
    You can return a promise from this hook to pause the
    transition until the promise resolves (or rejects). This could
    be useful, for instance, for retrieving async code from
    the server that is required to enter a route.
     * @method  beforeModel
     * @param  
     * @return  if the value returned from this hook is
    a promise, the transition will pause until the transition
    resolves. Otherwise, non-promise return values are not
    utilized in any way.
    */
    beforeModel(transition: EmberStates$Transition): RSVP$Promise;

    /**
     * The controller associated with this route.
     * @property  controller
     * @type  Ember.Controller
     * @since  1.6.0
     */
    controller: Ember$Controller;

    /**
     * Returns the controller for a particular route or name.
     * The controller instance must already have been created, either through entering the
    associated route or using `generateController`.
     * @method  controllerFor
     * @param  the name of the route or controller
     * @return  
    */
    controllerFor(name: string): Ember$Controller;

    /**
     * The name of the controller to associate with this route.
     * By default, Ember will lookup a route's controller that matches the name
    of the route (i.e. `App.PostController` for `App.PostRoute`). However,
    if you would like to define a specific controller to use, you can do so
    using this property.
    This is useful in many ways, as the controller specified will be:
     passed to the `setupController` method.
     used as the controller for the view being rendered by the route.
     returned from a call to `controllerFor` for the route.
     * @property  controllerName
     * @type  String
     * @default  null
     * @since  1.4.0
    */
    controllerName: string;

    /**
     * This hook is executed when the router completely exits this route. It is
     * not executed when the model for the route changes.
     * @method  deactivate
     */
    deactivate: Function;

    /**
     * Deserializes value of the query parameter based on defaultValueType
     * @method  deserializeQueryParam
     * @param  
     * @param  
     * @param  
     */
    deserializeQueryParam(value: any, urlKey: string, defaultValueType: string): any;

    /**
     * Disconnects a view that has been rendered into an outlet.
     * You may pass any or all of the following options to `disconnectOutlet`:
     `outlet`: the name of the outlet to clear (default: 'main')
     `parentView`: the name of the view containing the outlet to clear
         (default: the view rendered by the parent route)
     * @method  disconnectOutlet
     * @param  the options hash or outlet name
    */
    disconnectOutlet(options: DisconnectOutletOptions | string): void;

    /**
     * 
     * @method  findModel
     * @param  the model type
     * @param  the value passed to find
     */
    findModel(type: string, value: any): any;

    /**
     * Generates a controller for a route.
     * If the optional model is passed then the controller type is determined automatically,
    e.g., an ArrayController for arrays.
     * @method  generateController
     * @param  the name of the controller
     * @param  the model to infer the type of the controller (optional)
    */
    generateController(name: string, model: {}): Ember$Controller;

    /**
     * Perform a synchronous transition into another route without attempting
     * to resolve promises, update the URL, or abort any currently active
    asynchronous transitions (i.e. regular transitions caused by
    `transitionTo` or URL changes).
    This method is handy for performing intermediate transitions on the
    way to a final destination route, and is called internally by the
    default implementations of the `error` and `loading` handlers.
     * @method  intermediateTransitionTo
     * @param  the name of the route
     * @param  the model(s) to be used while transitioning
    to the route.
     * @since  1.2.0
    */
    intermediateTransitionTo(name: string, ...models: any[]): void;

    /**
     * A hook you can implement to convert the URL into the model for
     * this route.
     * @method  model
     * @param  the parameters extracted from the URL
     * @param  
     * @return  the model for this route. If
    a promise is returned, the transition will pause until
    the promise resolves, and the resolved value of the promise
    will be used as the model for this route.
    */
    model(params: {}, transition: EmberStates$Transition): any | RSVP$Promise;

    /**
     * Returns the model of a parent (or any ancestor) route
     * in a route hierarchy.  During a transition, all routes
    must resolve a model object, and if a route
    needs access to a parent route's model in order to
    resolve a model (or just reuse the model from a parent),
    it can call `this.modelFor(theNameOfParentRoute)` to
    retrieve it.
     * @method  modelFor
     * @param  the name of the route
     * @return  the model object
    */
    modelFor(name: string): {};

    /**
     * Retrieves parameters, for current route using the state.params
     * variable and getQueryParamsFor, using the supplied routeName.
     * @method  paramsFor
     * @param  
     */
    paramsFor(name: string): any;

    /**
     * Configuration hash for this route's queryParams.
     * @property  queryParams
     * @for  Ember.Route
     * @type  Hash
     */
    queryParams: {};

    /**
     * Refresh the model on this route and any child routes, firing the
     * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
    to how routes are entered when transitioning in from other route.
    The current route params (e.g. `article_id`) will be passed in
    to the respective model hooks, and if a different model is returned,
    `setupController` and associated route hooks will re-fire as well.
    An example usage of this method is re-querying the server for the
    latest information using the same parameters as when the route
    was first entered.
    Note that this will cause `model` hooks to fire even on routes
    that were provided a model object when the route was initially
    entered.
     * @method  refresh
     * @return  the transition object associated with this
    attempted transition
     * @since  1.4.0
    */
    redirect(): EmberStates$Transition;

    /**
     * Refresh the model on this route and any child routes, firing the
     * `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
    to how routes are entered when transitioning in from other route.
    The current route params (e.g. `article_id`) will be passed in
    to the respective model hooks, and if a different model is returned,
    `setupController` and associated route hooks will re-fire as well.
    An example usage of this method is re-querying the server for the
    latest information using the same parameters as when the route
    was first entered.
    Note that this will cause `model` hooks to fire even on routes
    that were provided a model object when the route was initially
    entered.
     * @method  refresh
     * @return  the transition object associated with this
    attempted transition
     * @since  1.4.0
    */
    refresh(): EmberStates$Transition;

    /**
     * `render` is used to render a template into a region of another template
     * (indicated by an `{{outlet}}`). `render` is used both during the entry
    phase of routing (via the `renderTemplate` hook) and later in response to
    user interaction.
     * @method  render
     * @param  the name of the template to render
     * @param  the options
     * @param  .into] the template to render into,
    referenced by name. Defaults to the parent template
     * @param  .outlet] the outlet inside `options.template` to render into.
    Defaults to 'main'
     * @param  .controller] the controller to use for this template,
    referenced by name or as a controller instance. Defaults to the Route's paired controller
     * @param  .model] the model object to set on `options.controller`.
    Defaults to the return value of the Route's model hook
    */
    render(name: string, options?: RenderOptions): void;

    /**
     * A hook you can use to render the template for the current route.
     * This method is called with the controller for the current route and the
    model supplied by the `model` hook. By default, it renders the route's
    template, configured with the controller for the route.
    This method can be overridden to set up and render additional or
    alternative templates.
     * @method  renderTemplate
     * @param  the route's controller
     * @param  the route's model
    */
    renderTemplate(controller: Ember$Controller, model: {}): void;

    /**
     * Transition into another route while replacing the current URL, if possible.
     * This will replace the current history entry instead of adding a new one.
    Beside that, it is identical to `transitionTo` in all other respects. See
    'transitionTo' for additional information regarding multiple models.
     * @method  replaceWith
     * @param  the name of the route or a URL
     * @param  the model(s) or identifier(s) to be used while
    transitioning to the route.
     * @return  the transition object associated with this
    attempted transition
    */
    replaceWith(name: string, ...models: any[]): void;

    /**
     * A hook you can use to reset controller values either when the model
     * changes or the route is exiting.
     * @method  resetController
     * @param  instance
     * @param  
     * @param  
     * @since  1.7.0
     */
    resetController(controller: Ember$Controller, isExiting: boolean, transition: any): void;

    /**
     * A hook you can implement to convert the route's model into parameters
     * for the URL.

    The default `serialize` method will insert the model's `id` into the
    route's dynamic segment (in this case, `:post_id`) if the segment contains '_id'.
    If the route has multiple dynamic segments or does not contain '_id', `serialize`
    will return `Ember.getProperties(model, params)`
    This method is called when `transitionTo` is called with a context
    in order to populate the URL.
     * @method  serialize
     * @param  the route's model
     * @param  an Array of parameter names for the current
    route (in the example, `['post_id']`.
     * @return  the serialized parameters
    */
    serialize(model: {}, params: string[]): string;

    /**
     * Serializes value of the query parameter based on defaultValueType
     * @method  serializeQueryParam
     * @param  
     * @param  
     * @param  
     */
    serializeQueryParam(value: any, urlKey: string, defaultValueType: string): string;

    /**
     * Serializes the query parameter key
     * @method  serializeQueryParamKey
     * @param  
     */
    serializeQueryParamKey(controllerPropertyName: string): string;

    /**
     * A hook you can use to setup the controller for the current route.
     * This method is called with the controller for the current route and the
    model supplied by the `model` hook.
    By default, the `setupController` hook sets the `model` property of
    the controller to the `model`.
    If you implement the `setupController` hook in your Route, it will
    prevent this default behavior. If you want to preserve that behavior
    when implementing your `setupController` function, make sure to call
    `_super`
     * @method  setupController
     * @param  instance
     * @param  
    */
    setupController(controller: Ember$Controller, model: {}): void;

    /**
     * Store property provides a hook for data persistence libraries to inject themselves.
     * By default, this store property provides the exact same functionality previously
    in the model hook.
    Currently, the required interface is:
    `store.find(modelName, findArguments)`
     * @method  store
     * @param  
    */
    store(store: any): any;

    /**
     * The name of the template to use by default when rendering this routes
     * template.
    This is similar with `viewName`, but is useful when you just want a custom
    template without a view.
     * @property  templateName
     * @type  String
     * @default  null
     * @since  1.4.0
    */
    templateName: string;

    /**
     * Transition the application into another route. The route may
     * be either a single route or route path
     * @method  transitionTo
     * @param  the name of the route or a URL
     * @param  the model(s) or identifier(s) to be used while
    transitioning to the route.
     * @param  optional hash with a queryParams property
    containing a mapping of query parameters
     * @return  the transition object associated with this
    attempted transition
    */
    transitionTo(name: string, ...object: any[]): EmberStates$Transition;

    /**
     * The name of the view to use by default when rendering this routes template.
     * When rendering a template, the route will, by default, determine the
    template and view to use from the name of the route itself. If you need to
    define a specific view, set this property.
    This is useful when multiple routes would benefit from using the same view
    because it doesn't require a custom `renderTemplate` method.
     * @property  viewName
     * @type  String
     * @default  null
     * @since  1.4.0
    */
    viewName: string;

    /**
     * Sends an action to the router, which will delegate it to the currently
     * active route hierarchy per the bubbling rules explained under actions
     * @method  send
     * @param  The action to trigger
     * @param  a context to send with the action
     */
    send(name: string, ...args: any[]): void;

    /**
     * The collection of functions, keyed by name, available on this
     * `ActionHandler` as action targets.
    These functions will be invoked when a matching `{{action}}` is triggered
    from within a template and the application's current route is this route.
    Actions can also be invoked from other parts of your application
    via `ActionHandler#send`.
    The `actions` hash will inherit action handlers from
    the `actions` hash defined on extended parent classes
    or mixins rather than just replace the entire hash.

    Within a Controller, Route, View or Component's action handler,
    the value of the `this` context is the Controller, Route, View or
    Component object:

    It is also possible to call `this._super.apply(this, arguments)` from within an
    action handler if it overrides a handler defined on a parent
    class or mixin.

    ## Bubbling
    By default, an action will stop bubbling once a handler defined
    on the `actions` hash handles it. To continue bubbling the action,
    you must return `true` from the handler
     * @property  actions
     * @type  Hash
     * @default  null
    */
    actions: ActionsHash;

    /**
     * Subscribes to a named event with given function.
     * 
    An optional target can be passed in as the 2nd argument that will
    be set as the "this" for the callback. This is a good way to give your
    function access to the object triggering the event. When the target
    parameter is used the callback becomes the third argument.
     * @method  on
     * @param  The name of the event
     * @param  The "this" binding for the callback
     * @param  The callback to execute
     * @return  this
    */
    on(name: string, target: any, method: Function): Ember$Evented;

    /**
     * Subscribes a function to a named event and then cancels the subscription
     * after the first time the event is triggered. It is good to use ``one`` when
    you only care about the first time an event has taken place.
    This function takes an optional 2nd argument that will become the "this"
    value for the callback. If this argument is passed then the 3rd argument
    becomes the function.
     * @method  one
     * @param  The name of the event
     * @param  The "this" binding for the callback
     * @param  The callback to execute
     * @return  this
    */
    one(name: string, target: any, method: Function): Ember$Evented;

    /**
     * Triggers a named event for the object. Any additional arguments
     * will be passed as parameters to the functions that are subscribed to the
    event....} args Optional arguments to pass on
     * @method  trigger
     * @param  The name of the event
    */
    trigger(name: string, ...args: string[]): void;

    /**
     * Cancels subscription for given name, target, and method.
     * @method  off
     * @param  The name of the event
     * @param  The target of the subscription
     * @param  The function of the subscription
     * @return  this
     */
    off(name: string, target: any, method: Function): Ember$Evented;

    /**
     * Checks to see if object has any subscriptions for named event.
     * @method  has
     * @param  The name of the event
     * @return  does the object have a subscription for event
     */
    has(name: string): boolean
}

declare class Router mixins Object {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    map(callback: Function): Ember$Router
}

declare class RouterDSL {
    resource(name: string, options?: {}, callback?: Function): void;
    resource(name: string, callback: Function): void;
    route(name: string, options?: {}): void
}

declare
var SHIM_ES5: boolean;

declare
var STRINGS: boolean;

declare class Select mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    content: any[];
    groupView: Em$View;
    multiple: boolean;
    optionGroupPath: string;
    optionLabelPath: string;
    optionValuePath: string;
    optionView: Em$View;
    prompt: string;
    selection: any;
    value: string
}

declare class SelectOption mixins View {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean
}

declare class Set mixins CoreObject, MutableEnumberable, Copyable, Freezable {
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Set;
    addObject(object: any): any;
    addObjects(objects: Ember$Enumerable): Ember$Set;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    someProperty(key: string, value?: string): boolean;
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Set;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Set;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Set;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Set;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    invoke(methodName: string, ...args: any[]): any[];
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Set;
    removeObject(object: any): any;
    removeObjects(objects: Ember$Enumerable): Ember$Set;
    setEach(key: string, value?: any): any;
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Set;
    without(value: any): Ember$Set;
    []: any[];
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    copy(deep: boolean): Ember$Set;
    frozenCopy(): Ember$Set;
    freeze(): Ember$Set;
    isFrozen: boolean;
    add(obj: any): Ember$Set;
    addEach(...args: any[]): Ember$Set;
    clear(): Ember$Set;
    isEqual(obj: Ember$Set): boolean;
    pop(): any;
    push(obj: any): Ember$Set;
    remove(obj: any): Ember$Set;
    removeEach(...args: any[]): Ember$Set;
    shift(): any;
    unshift(obj: any): Ember$Set;
    length: number
}

declare class SortableMixin mixins MutableEnumberable {
    addEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    addObject(object: any): any;
    addObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    any(callback: Function, target?: any): boolean;
    anyBy(key: string, value?: string): boolean;
    someProperty(key: string, value?: string): boolean;
    compact(): any[];
    contains(obj: any): boolean;
    enumerableContentDidChange(start: number, removing: number, adding: number): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(start: number, removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(start: number, removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: number, adding: number): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: number): any;
    enumerableContentDidChange(removing: number, adding: Ember$Enumerable): any;
    enumerableContentDidChange(removing: Ember$Enumerable, adding: Ember$Enumerable): any;
    enumerableContentWillChange(removing: number, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: number): Ember$Enumerable;
    enumerableContentWillChange(removing: number, adding: Ember$Enumerable): Ember$Enumerable;
    enumerableContentWillChange(removing: Ember$Enumerable, adding: Ember$Enumerable): Ember$Enumerable;
    every(callback: Function, target?: any): boolean;
    everyBy(key: string, value?: string): boolean;
    everyProperty(key: string, value?: string): boolean;
    filter(callback: Function, target: any): any[];
    filterBy(key: string, value?: string): any[];
    find(callback: Function, target: any): any;
    findBy(key: string, value?: string): any;
    forEach(callback: Function, target?: any): any;
    getEach(key: string): any[];
    invoke(methodName: string, ...args: any[]): any[];
    map: ItemIndexEnumerableCallbackTarget;
    mapBy(key: string): any[];
    nextObject(index: number, previousObject: any, context: any): any;
    reduce(callback: ReduceCallback, initialValue: any, reducerProperty: string): any;
    reject: ItemIndexEnumerableCallbackTarget;
    rejectBy(key: string, value?: string): any[];
    removeEnumerableObserver(target: any, opts: EnumerableConfigurationOptions): Ember$Enumerable;
    removeObject(object: any): any;
    removeObjects(objects: Ember$Enumerable): Ember$MutableEnumberable;
    setEach(key: string, value?: any): any;
    some(callback: Function, target?: any): boolean;
    toArray(): any[];
    uniq(): Ember$Enumerable;
    without(value: any): Ember$Enumerable;
    []: any[];
    arrangedContent: any;
    firstObject: any;
    hasEnumerableObservers: boolean;
    lastObject: any;
    sortAscending: boolean;
    sortFunction: Ember$Comparable;
    sortProperties: any[]
}

declare class State mixins Object, Evented {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    has(name: string): boolean;
    off(name: string, target: any, method: Function): Ember$State;
    on(name: string, target: any, method: Function): Ember$State;
    one(name: string, target: any, method: Function): Ember$State;
    trigger(name: string, ...args: string[]): void;
    getPathsCache(stateManager: {}, path: string): {};
    init(): void;
    setPathsCache(stateManager: {}, path: string, transitions: any): void;
    transitionTo(target: string): void;
    hasContext: boolean;
    isLeaf: boolean;
    name: string;
    parentState: Ember$State;
    path: string;
    enter: Function;
    exit: Function;
    setup: Function
}

declare class StateManager mixins State {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    contextFreeTransition(currentState: Ember$State, path: string): TransitionsHash;
    enterState(transition: TransitionsHash): void;
    getState(name: string): Ember$State;
    getStateByPath(root: Ember$State, path: string): Ember$State;
    getStateMeta(state: Ember$State, key: string): any;
    getStatesInPath(root: Ember$State, path: string): Ember$State[];
    goToState(path: string, context: any): void;
    send(event: string): void;
    setStateMeta(state: Ember$State, key: string, value: any): any;
    stateMetaFor(state: Ember$State): {};
    transitionTo(path: string, context: any): void;
    triggerSetupContext(transitions: TransitionsHash): void;
    unhandledEvent(manager: Ember$StateManager, event: string): any;
    currentPath: string;
    currentState: Ember$State;
    errorOnUnhandledEvents: boolean;
    transitionEvent: string
}


declare
var npm$namespace$String: {
    camelize: typeof String$camelize,
    capitalize: typeof String$capitalize,
    classify: typeof String$classify,
    dasherize: typeof String$dasherize,
    decamelize: typeof String$decamelize,
    fmt: typeof String$fmt,
    htmlSafe: typeof String$htmlSafe,
    loc: typeof String$loc,
    underscore: typeof String$underscore,
    w: typeof String$w,
}
declare
function String$camelize(str: string): string

declare
function String$capitalize(str: string): string

declare
function String$classify(str: string): string

declare
function String$dasherize(str: string): string

declare
function String$decamelize(str: string): string

declare
function String$fmt(...args: string[]): string

declare
function String$htmlSafe(str: string): void

declare
function String$loc(...args: string[]): string

declare
function String$underscore(str: string): string

declare
function String$w(str: string): string[]

declare
var TEMPLATES: {};

declare class TargetActionSupport {
    triggerAction(opts: {}): boolean
}

declare class Test {
    click(selector: string): RSVP$Promise;
    fillin(selector: string, text: string): RSVP$Promise;
    find(selector: string): JQuery;
    findWithAssert(selector: string): JQuery;
    injectTestHelpers(): void;
    keyEvent(selector: string, type: string, keyCode: number): RSVP$Promise;
    oninjectHelpers(callback: Function): void;
    promise(resolver: Function): RSVP$Promise;
    registerHelper(name: string, helperMethod: Function): void;
    removeTestHelpers(): void;
    setupForTesting(): void;
    unregisterHelper(name: string): void;
    visit(url: string): RSVP$Promise;
    wait(value: any): RSVP$Promise;
    adapter: Ember$Object;
    testHelpers: {}
}

declare class TextArea mixins View, TextSupport {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    cancel(event: Function): void;
    focusIn(event: Function): void;
    focusOut(event: Function): void;
    insertNewLine(event: Function): void;
    keyPress(event: Function): void;
    action: string;
    bubbles: boolean;
    onEvent: string
}

declare class TextField mixins View, TextSupport {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    cancel(event: Function): void;
    focusIn(event: Function): void;
    focusOut(event: Function): void;
    insertNewLine(event: Function): void;
    keyPress(event: Function): void;
    action: string;
    bubbles: boolean;
    onEvent: string;
    pattern: string;
    size: string;
    type: string;
    value: string
}

declare class TextSupport {
    cancel(event: Function): void;
    focusIn(event: Function): void;
    focusOut(event: Function): void;
    insertNewLine(event: Function): void;
    keyPress(event: Function): void;
    action: string;
    bubbles: boolean;
    onEvent: string
}

declare
var VERSION: string;

declare class View mixins CoreView {
    detect(obj: any): boolean;
    detectInstance(obj: any): boolean;

    /**
     * Iterate over each computed property for the class, passing its name and any
     * associated metadata (see metaForProperty) to the callback.
     */
    eachComputedProperty(callback: Function, binding: {}): void;

    /**
     * Returns the original hash that was passed to meta().
     * @param key property name
     */
    metaForProperty(key: string): {};
    isClass: boolean;
    isMethod: boolean;
    $(): JQuery;
    append(): Ember$View;
    appendTo(A: string): Ember$View;
    appendTo(A: HTMLElement): Ember$View;
    appendTo(A: JQuery): Ember$View;
    createChildView(viewClass: {}, attrs?: {}): Ember$View;
    createChildView(viewClass: string, attrs?: {}): Ember$View;
    createElement(): Ember$View;
    destroy(): Ember$View;
    destroyElement(): Ember$View;
    findElementInParentElement(parentElement: HTMLElement): HTMLElement;
    remove(): Ember$View;
    removeAllChildren(): Ember$View;
    removeChild(view: Ember$View): Ember$View;
    removeFromParent(): Ember$View;
    render(buffer: Ember$RenderBuffer): void;
    replaceIn(A: string): Ember$View;
    replaceIn(A: HTMLElement): Ember$View;
    replaceIn(A: JQuery): Ember$View;
    rerender(): void;
    ariaRole: string;
    attributeBindings: any;
    classNameBindings: string[];
    classNames: string[];
    context: any;
    controller: any;
    element: HTMLElement;
    isView: boolean;
    isVisible: boolean;
    layout: Function;
    layoutName: string;
    nearestChildOf: Ember$View;
    nearestOfType: Ember$View;
    nearestWithProperty: Ember$View;
    tagName: string;
    template: Function;
    templateName: string;
    templates: {};
    views: {};
    didInsertElement: Function;
    parentViewDidChange: Function;
    willClearRender: Function;
    willDestroyElement: Function;
    willInsertElement: Function
}

declare class ViewTargetActionSupport mixins Mixin {
    target: any;
    actionContext: any
}

declare
var ViewUtils: {};

declare
function Ember$addBeforeObserver(obj: any, path: string, target: any, method: Function): any

declare
function Ember$addListener(
    obj: any,
    eventName: string,
    target: any,
    method: Function,
    once?: boolean): void

declare
var addObserver: ModifyObserver;

declare
var alias: typeof deprecateFunc;

declare
function Ember$aliasMethod(methodName: string): Ember$Descriptor

declare
var anyUnprocessedMixins: boolean;

declare
function Ember$assert(desc: string, test: boolean): void

declare
function Ember$beforeObserver(func: Function, propertyName: string): Function

declare
function Ember$beforeObserversFor(obj: any, path: string): string[]

declare
function Ember$beginPropertyChanges(): void

declare
function Ember$bind(obj: any, to: string, from: string): Ember$Binding

declare
function Ember$cacheFor(obj: any, key: string): any

declare
function Ember$canInvoke(obj: any, methodName: string): boolean

declare
function Ember$changeProperties(callback: Function, binding?: any): void

declare
function Ember$compare(v: any, w: any): number

declare
var computed: {
    (...args: any[]): Ember$ComputedProperty,
    alias(dependentKey: string): Ember$ComputedProperty,
    and(...args: string[]): Ember$ComputedProperty,
    any(...args: string[]): Ember$ComputedProperty,
    bool(dependentKey: string): Ember$ComputedProperty,
    defaultTo(defaultPath: string): Ember$ComputedProperty,
    empty(dependentKey: string): Ember$ComputedProperty,
    equal(dependentKey: string, value: any): Ember$ComputedProperty,
    gt(dependentKey: string, value: number): Ember$ComputedProperty,
    gte(dependentKey: string, value: number): Ember$ComputedProperty,
    lt(dependentKey: string, value: number): Ember$ComputedProperty,
    lte(dependentKey: string, value: number): Ember$ComputedProperty,
    map(...args: string[]): Ember$ComputedProperty,
    match(dependentKey: string, regexp: RegExp): Ember$ComputedProperty,
    none(dependentKey: string): Ember$ComputedProperty,
    not(dependentKey: string): Ember$ComputedProperty,
    notEmpty(dependentKey: string): Ember$ComputedProperty,
    oneWay(dependentKey: string): Ember$ComputedProperty,
    or(...args: string[]): Ember$ComputedProperty
};

declare
var config: {};

declare
function Ember$controllerFor(
    container: Ember$Container,
    controllerName: string,
    lookupOptions?: {}): Ember$Controller

declare
function Ember$copy(obj: any, deep: boolean): any


/**
 * Creates an instance of the CoreObject class.
 * @param arguments A hash containing values with which to initialize the newly instantiated object.
 */
declare
function Ember$create(arguments?: {}): Ember$CoreObject

declare
function Ember$debug(message: string): void

declare
function Ember$defineProperty(obj: any, keyName: string, desc: {}): void

declare
function Ember$deprecate(message: string, test?: boolean): void

declare
function Ember$deprecateFunc(message: string, func: Function): Function

declare
function Ember$destroy(obj: any): void

declare
var empty: typeof deprecateFunc;

declare
function Ember$endPropertyChanges(): void

declare
var exports: {};

declare
function Ember$finishChains(obj: any): void

declare
function Ember$flushPendingChains(): void

declare
function Ember$generateController(
    container: Ember$Container,
    controllerName: string,
    context: any): Ember$Controller

declare
function Ember$generateGuid(obj: any, prefix?: string): string

declare
function Ember$get(root: any, path: string, options?: {}): any

declare
function Ember$getMeta(obj: any, property: string): any

declare
var getPath: typeof deprecateFunc;

declare
function Ember$getWithDefault(root: string, key: string, defaultValue: any): any

declare
function Ember$guidFor(obj: any): string

declare
function Ember$handleErrors(func: Function, context: any): any

declare
function Ember$hasListeners(context: any, name: string): boolean

declare
function Ember$hasOwnProperty(prop: string): boolean

declare
function Ember$immediateObserver(func: Function, ...propertyNames: any[]): Function

declare
var imports: {};

declare
function Ember$inspect(obj: any): string

declare
function Ember$instrument(name: string, payload: any, callback: Function, binding: any): void

declare
function Ember$isArray(obj: any): boolean

declare
function Ember$isEmpty(obj: any): boolean

declare
function Ember$isEqual(a: any, b: any): boolean

declare
function Ember$isGlobalPath(path: string): boolean

declare
var isNamespace: boolean;

declare
function Ember$isNone(obj: any): boolean

declare
function Ember$isPrototypeOf(obj: {}): boolean

declare
function Ember$isWatching(obj: any, key: string): boolean

declare
function Ember$keys(obj: any): any[]

declare
function Ember$listenersDiff(obj: any, eventName: string, otherActions: any[]): any[]

declare
function Ember$listenersFor(obj: any, eventName: string): any[]

declare
function Ember$listenersUnion(obj: any, eventName: string, otherActions: any[]): void

declare
var lookup: {};

declare
function Ember$makeArray(obj: any): any[]

declare
function Ember$merge(original: any, updates: any): any

declare
function Ember$meta(obj: any, writable?: boolean): {}

declare
function Ember$metaPath(obj: any, path: string, writable?: boolean): any

declare
function Ember$mixin(obj: any, ...args: any[]): any

declare
var none: typeof deprecateFunc;

declare
function Ember$normalizeTuple(target: any, path: string): any[]

declare
function Ember$observer(...args: any[]): Function

declare
function Ember$observersFor(obj: any, path: string): any[]

declare
function Ember$onLoad(name: string, callback: Function): void

declare
function Ember$oneWay(obj: any, to: string, from: string): Ember$Binding

declare
var onError: Error;

declare
function Ember$overrideChains(obj: any, keyName: string, m: any): boolean

declare
var platform: {
    addBeforeObserver: ModifyObserver,
    addObserver: ModifyObserver,
    defineProperty(obj: any, keyName: string, desc: {}): void,
    removeBeforeObserver: ModifyObserver,
    removeObserver: ModifyObserver,
    hasPropertyAccessors: boolean
};

declare
function Ember$propertyDidChange(obj: any, keyName: string): void

declare
function Ember$propertyIsEnumerable(prop: string): boolean

declare
function Ember$propertyWillChange(obj: any, keyName: string): void

declare
function Ember$removeBeforeObserver(obj: any, path: string, target: any, method: Function): any

declare
function Ember$removeChainWatcher(obj: any, keyName: string, node: any): void

declare
function Ember$removeListener(obj: any, eventName: string, target: any, method: Function): void

declare
function Ember$removeObserver(obj: any, path: string, target: any, method: Function): any

declare
function Ember$required(): Ember$Descriptor

declare
function Ember$rewatch(obj: any): void

declare
var run: {
    (target: any, method: Function): void,
    begin(): void,
    cancel(timer: any): void,
    debounce(target: any, method: Function, ...args: any[]): void,
    debounce(target: any, method: string, ...args: any[]): void,
    end(): void,
    join(target: any, method: Function, ...args: any[]): any,
    join(target: any, method: string, ...args: any[]): any,
    later(target: any, method: Function, ...args: any[]): string,
    later(target: any, method: string, ...args: any[]): string,
    next(target: any, method: Function, ...args: any[]): number,
    next(target: any, method: string, ...args: any[]): number,
    once(target: any, method: Function, ...args: any[]): number,
    once(target: any, method: string, ...args: any[]): number,
    schedule(queue: string, target: any, method: Function, ...args: any[]): void,
    schedule(queue: string, target: any, method: string, ...args: any[]): void,
    scheduleOnce(queue: string, target: any, method: Function, ...args: any[]): void,
    scheduleOnce(queue: string, target: any, method: string, ...args: any[]): void,
    sync(): void,
    throttle(target: any, method: Function, ...args: any[]): void,
    throttle(target: any, method: string, ...args: any[]): void,
    queues: any[]
};

declare
function Ember$runLoadHooks(name: string, object: any): void

declare
function Ember$sendEvent(obj: any, eventName: string, params?: any[], actions?: any[]): boolean

declare
function Ember$set(obj: any, keyName: string, value: any): any

declare
function Ember$setMeta(obj: any, property: string, value: any): void

declare
var setPath: typeof deprecateFunc;

declare
function Ember$setProperties(self: any, hash: {}): any

declare
function Ember$subscribe(pattern: string, object: any): void

declare
function Ember$toLocaleString(): string

declare
function Ember$toString(): string

declare
function Ember$tryCatchFinally(
    tryable: Function,
    catchable: Function,
    finalizer: Function,
    binding?: any): any

declare
function Ember$tryFinally(tryable: Function, finalizer: Function, binding?: any): any

declare
function Ember$tryInvoke(obj: any, methodName: string, args?: any[]): any

declare
function Ember$trySet(obj: any, path: string, value: any): void

declare
var trySetPath: typeof deprecateFunc;

declare
function Ember$typeOf(item: any): string

declare
function Ember$unwatch(obj: any, keyPath: string): void

declare
function Ember$unwatchKey(obj: any, keyName: string): void

declare
function Ember$unwatchPath(obj: any, keyPath: string): void

declare
var uuid: number;

declare
function Ember$valueOf(): {}

declare
function Ember$warn(message: string, test?: boolean): void

declare
function Ember$watch(obj: any, keyPath: string): void

declare
function Ember$watchKey(obj: any, keyName: string): void

declare
function Ember$watchPath(obj: any, keyPath: string): void

declare
function Ember$watchedEvents(obj: {}): any[]

declare
function Ember$wrap(func: Function, superFunc: Function): Functiondeclare
var $: typeof undefined;

declare
var A: typeof undefined;

declare class ActionHandlerMixin mixins Ember$ActionHandlerMixin {}

declare class Application mixins Ember$Application {}

declare class Array mixins Ember$Array {}

declare class ArrayController mixins Ember$ArrayController {}

declare
var ArrayPolyfills: typeof undefined;

declare class ArrayProxy mixins Ember$ArrayProxy {}

declare
var BOOTED: typeof undefined;

declare class Binding mixins Ember$Binding {}

declare class Button mixins Ember$Button {}

declare class Checkbox mixins Ember$Checkbox {}

declare class CollectionView mixins Ember$CollectionView {}

declare class Comparable mixins Ember$Comparable {}

declare class Component mixins Ember$Component {}

declare class ComputedProperty mixins Ember$ComputedProperty {}

declare class Container mixins Ember$Container {}

declare class ContainerView mixins Ember$ContainerView {}

declare class Controller mixins Ember$Controller {}

declare class ControllerMixin mixins Ember$ControllerMixin {}

declare class Copyable mixins Ember$Copyable {}

declare class CoreObject mixins Ember$CoreObject {}

declare class CoreView mixins Ember$CoreView {}

declare class DAG mixins Ember$DAG {}

declare
var DEFAULT_GETTER_FUNCTION: typeof undefined;

declare class DefaultResolver mixins Ember$DefaultResolver {}

declare class Deffered mixins Ember$Deferred {}

declare class DeferredMixin mixins Ember$DeferredMixin {}

declare class Descriptor mixins Ember$Descriptor {}

declare
var EMPTY_META: typeof undefined;

declare
var ENV: typeof undefined;

declare
var EXTEND_PROTOTYPES: typeof undefined;

declare class EachProxy mixins Ember$EachProxy {}

declare class Enumerable mixins Ember$Enumerable {}

declare
var EnumerableUtils: typeof undefined;

declare
var Error: typeof undefined;

declare class EventDispatcher mixins Ember$EventDispatcher {}

declare class Evented mixins Ember$Evented {}

declare
var FROZEN_ERROR: typeof undefined;

declare class Freezable mixins Ember$Freezable {}

declare
var GUID_KEY: typeof undefined;

declare
var compile: typeof undefined;

declare
var get: typeof undefined;

declare
var helper: typeof undefined;

declare class helpers mixins undefined.helpers {}

declare
var precompile: typeof undefined;

declare
var registerBoundHelper: typeof undefined;

declare class Compiler mixins undefined.Compiler {}

declare class JavaScriptCompiler mixins undefined.JavaScriptCompiler {}

declare
var registerHelper: typeof undefined;

declare
var registerPartial: typeof undefined;

declare
var K: typeof undefined;

declare
var createFrame: typeof undefined;

declare
var Exception: typeof undefined;

declare class SafeString mixins undefined.SafeString {}

declare
var parse: typeof undefined;

declare
var print: typeof undefined;

declare
var logger: typeof undefined;

declare
var log: typeof undefined;

declare class HashLocation mixins Ember$HashLocation {}

declare class HistoryLocation mixins Ember$HistoryLocation {}

declare
var IS_BINDING: typeof undefined;

declare class Instrumentation mixins Ember$Instrumentation {}

declare
var K: typeof undefined;

declare
var LOG_BINDINGS: typeof undefined;

declare
var LOG_STACKTRACE_ON_DEPRECATION: typeof undefined;

declare
var LOG_VERSION: typeof undefined;

declare class LinkView mixins Ember$LinkView {}

declare class Location mixins Ember$Location {}

declare
var Logger: typeof undefined;

declare
var MANDATORY_SETTER_FUNCTION: typeof undefined;

declare
var META_KEY: typeof undefined;

declare class Map mixins Ember$Map {}

declare class MapWithDefault mixins Ember$MapWithDefault {}

declare class Mixin mixins Ember$Mixin {}

declare class MutableArray mixins Ember$MutableArray {}

declare class MutableEnumerable mixins Ember$MutableEnumberable {}

declare
var NAME_KEY: typeof undefined;

declare class Namespace mixins Ember$Namespace {}

declare class NativeArray mixins Ember$NativeArray {}

declare class NoneLocation mixins Ember$NoneLocation {}

declare
var ORDER_DEFINITION: typeof undefined;

declare class Object mixins Ember$Object {}

declare class ObjectController mixins Ember$ObjectController {}

declare class ObjectProxy mixins Ember$ObjectProxy {}

declare class Observable mixins Ember$Observable {}

declare class OrderedSet mixins Ember$OrderedSet {}

declare interface RSVP$PromiseResolve {
    (value?: any): void
}

declare interface RSVP$PromiseReject {
    (reason?: any): void
}

declare interface RSVP$PromiseResolverFunction {
    (resolve: RSVP$PromiseResolve, reject: RSVP$PromiseReject): void
}

declare class Promise mixins undefined.Promise {}

declare class RenderBuffer mixins Ember$RenderBuffer {}

declare class Route mixins Ember$Route {}

declare class Router mixins Ember$Router {}

declare class RouterDSL mixins Ember$RouterDSL {}

declare
var SHIM_ES5: typeof undefined;

declare
var STRINGS: typeof undefined;

declare class Select mixins Ember$Select {}

declare class SelectOption mixins Ember$SelectOption {}

declare class Set mixins Ember$Set {}

declare class SortableMixin mixins Ember$SortableMixin {}

declare class State mixins Ember$State {}

declare class StateManager mixins Ember$StateManager {}

declare
var camelize: typeof undefined;

declare
var capitalize: typeof undefined;

declare
var classify: typeof undefined;

declare
var dasherize: typeof undefined;

declare
var decamelize: typeof undefined;

declare
var fmt: typeof undefined;

declare
var htmlSafe: typeof undefined;

declare
var loc: typeof undefined;

declare
var underscore: typeof undefined;

declare
var w: typeof undefined;

declare
var TEMPLATES: typeof undefined;

declare class TargetActionSupport mixins Ember$TargetActionSupport {}

declare class Test mixins Ember$Test {}

declare class TextArea mixins Ember$TextArea {}

declare class TextField mixins Ember$TextField {}

declare class TextSupport mixins Ember$TextSupport {}

declare
var VERSION: typeof undefined;

declare class View mixins Ember$View {}

declare class ViewTargetActionSupport mixins Ember$ViewTargetActionSupport {}

declare
var ViewUtils: typeof undefined;

declare
var addBeforeObserver: typeof undefined;

declare
var addListener: typeof undefined;

declare
var addObserver: typeof undefined;

declare
var alias: typeof undefined;

declare
var aliasMethod: typeof undefined;

declare
var anyUnprocessedMixins: typeof undefined;

declare
var assert: typeof undefined;

declare
var beforeObserver: typeof undefined;

declare
var beforeObserversFor: typeof undefined;

declare
var beginPropertyChanges: typeof undefined;

declare
var bind: typeof undefined;

declare
var cacheFor: typeof undefined;

declare
var canInvoke: typeof undefined;

declare
var changeProperties: typeof undefined;

declare
var compare: typeof undefined;

declare
var computed: typeof undefined;

declare
var config: typeof undefined;

declare
var controllerFor: typeof undefined;

declare
var copy: typeof undefined;

declare
var create: typeof undefined;

declare
var debug: typeof undefined;

declare
var defineProperty: typeof undefined;

declare
var deprecate: typeof undefined;

declare
var deprecateFunc: typeof undefined;

declare
var destroy: typeof undefined;

declare
var empty: typeof deprecateFunc;

declare
var endPropertyChanges: typeof undefined;

declare
var exports: typeof undefined;

declare
var finishChains: typeof undefined;

declare
var flushPendingChains: typeof undefined;

declare
var generateController: typeof undefined;

declare
var generateGuid: typeof undefined;

declare
var get: typeof undefined;

declare
var getMeta: typeof undefined;

declare
var getPath: typeof undefined;

declare
var getWithDefault: typeof undefined;

declare
var guidFor: typeof undefined;

declare
var handleErrors: typeof undefined;

declare
var hasListeners: typeof undefined;

declare
var hasOwnProperty: typeof undefined;

declare
var immediateObserver: typeof undefined;

declare
var imports: typeof undefined;

declare
var inspect: typeof undefined;

declare
var instrument: typeof undefined;

declare
var isArray: typeof undefined;

declare
var isEmpty: typeof undefined;

declare
var isEqual: typeof undefined;

declare
var isGlobalPath: typeof undefined;

declare
var isNamespace: typeof undefined;

declare
var isNone: typeof undefined;

declare
var isPrototypeOf: typeof undefined;

declare
var isWatching: typeof undefined;

declare
var keys: typeof undefined;

declare
var listenersDiff: typeof undefined;

declare
var listenersFor: typeof undefined;

declare
var listenersUnion: typeof undefined;

declare
var lookup: typeof undefined;

declare
var makeArray: typeof undefined;

declare
var merge: typeof undefined;

declare
var meta: typeof undefined;

declare
var metaPath: typeof undefined;

declare
var mixin: typeof undefined;

declare
var none: typeof undefined;

declare
var normalizeTuple: typeof undefined;

declare
var observer: typeof undefined;

declare
var observersFor: typeof undefined;

declare
var onLoad: typeof undefined;

declare
var oneWay: typeof undefined;

declare
var onError: typeof undefined;

declare
var overrideChains: typeof undefined;

declare
var platform: typeof undefined;

declare
var propertyDidChange: typeof undefined;

declare
var propertyIsEnumerable: typeof undefined;

declare
var propertyWillChange: typeof undefined;

declare
var removeBeforeObserver: typeof undefined;

declare
var removeChainWatcher: typeof undefined;

declare
var removeListener: typeof undefined;

declare
var removeObserver: typeof undefined;

declare
var required: typeof undefined;

declare
var rewatch: typeof undefined;

declare
var run: typeof undefined;

declare
var runLoadHooks: typeof undefined;

declare
var sendEvent: typeof undefined;

declare
var set: typeof undefined;

declare
var setMeta: typeof undefined;

declare
var setPath: typeof undefined;

declare
var setProperties: typeof undefined;

declare
var subscribe: typeof undefined;

declare
var toLocaleString: typeof undefined;

declare
var toString: typeof undefined;

declare
var tryCatchFinally: typeof undefined;

declare
var tryFinally: typeof undefined;

declare
var tryInvoke: typeof undefined;

declare
var trySet: typeof undefined;

declare
var trySetPath: typeof undefined;

declare
var typeOf: typeof undefined;

declare
var unwatch: typeof undefined;

declare
var unwatchKey: typeof undefined;

declare
var unwatchPath: typeof undefined;

declare
var uuid: typeof undefined;

declare
var valueOf: typeof undefined;

declare
var warn: typeof undefined;

declare
var watch: typeof undefined;

declare
var watchKey: typeof undefined;

declare
var watchPath: typeof undefined;

declare
var watchedEvents: typeof undefined;

declare
var wrap: typeof undefined;
declare module 'Ember' {
    declare var $: typeof undefined;
    declare var A: typeof undefined;
    declare class ActionHandlerMixin mixins Ember$ActionHandlerMixin {}
    declare class Application mixins Ember$Application {}
    declare class Array mixins Ember$Array {}
    declare class ArrayController mixins Ember$ArrayController {}
    declare var ArrayPolyfills: typeof undefined;
    declare class ArrayProxy mixins Ember$ArrayProxy {}
    declare var BOOTED: typeof undefined;
    declare class Binding mixins Ember$Binding {}
    declare class Button mixins Ember$Button {}
    declare class Checkbox mixins Ember$Checkbox {}
    declare class CollectionView mixins Ember$CollectionView {}
    declare class Comparable mixins Ember$Comparable {}
    declare class Component mixins Ember$Component {}
    declare class ComputedProperty mixins Ember$ComputedProperty {}
    declare class Container mixins Ember$Container {}
    declare class ContainerView mixins Ember$ContainerView {}
    declare class Controller mixins Ember$Controller {}
    declare class ControllerMixin mixins Ember$ControllerMixin {}
    declare class Copyable mixins Ember$Copyable {}
    declare class CoreObject mixins Ember$CoreObject {}
    declare class CoreView mixins Ember$CoreView {}
    declare class DAG mixins Ember$DAG {}
    declare var DEFAULT_GETTER_FUNCTION: typeof undefined;
    declare class DefaultResolver mixins Ember$DefaultResolver {}
    declare class Deffered mixins Ember$Deferred {}
    declare class DeferredMixin mixins Ember$DeferredMixin {}
    declare class Descriptor mixins Ember$Descriptor {}
    declare var EMPTY_META: typeof undefined;
    declare var ENV: typeof undefined;
    declare var EXTEND_PROTOTYPES: typeof undefined;
    declare class EachProxy mixins Ember$EachProxy {}
    declare class Enumerable mixins Ember$Enumerable {}
    declare var EnumerableUtils: typeof undefined;
    declare var Error: typeof undefined;
    declare class EventDispatcher mixins Ember$EventDispatcher {}
    declare class Evented mixins Ember$Evented {}
    declare var FROZEN_ERROR: typeof undefined;
    declare class Freezable mixins Ember$Freezable {}
    declare var GUID_KEY: typeof undefined;
    declare var compile: typeof undefined;

    declare var get: typeof undefined;

    declare var helper: typeof undefined;

    declare class helpers mixins undefined.helpers {}

    declare var precompile: typeof undefined;

    declare var registerBoundHelper: typeof undefined;

    declare class Compiler mixins undefined.Compiler {}

    declare class JavaScriptCompiler mixins undefined.JavaScriptCompiler {}

    declare var registerHelper: typeof undefined;

    declare var registerPartial: typeof undefined;

    declare var K: typeof undefined;

    declare var createFrame: typeof undefined;

    declare var Exception: typeof undefined;

    declare class SafeString mixins undefined.SafeString {}

    declare var parse: typeof undefined;

    declare var print: typeof undefined;

    declare var logger: typeof undefined;

    declare var log: typeof undefined;
    declare class HashLocation mixins Ember$HashLocation {}
    declare class HistoryLocation mixins Ember$HistoryLocation {}
    declare var IS_BINDING: typeof undefined;
    declare class Instrumentation mixins Ember$Instrumentation {}
    declare var K: typeof undefined;
    declare var LOG_BINDINGS: typeof undefined;
    declare var LOG_STACKTRACE_ON_DEPRECATION: typeof undefined;
    declare var LOG_VERSION: typeof undefined;
    declare class LinkView mixins Ember$LinkView {}
    declare class Location mixins Ember$Location {}
    declare var Logger: typeof undefined;
    declare var MANDATORY_SETTER_FUNCTION: typeof undefined;
    declare var META_KEY: typeof undefined;
    declare class Map mixins Ember$Map {}
    declare class MapWithDefault mixins Ember$MapWithDefault {}
    declare class Mixin mixins Ember$Mixin {}
    declare class MutableArray mixins Ember$MutableArray {}
    declare class MutableEnumerable mixins Ember$MutableEnumberable {}
    declare var NAME_KEY: typeof undefined;
    declare class Namespace mixins Ember$Namespace {}
    declare class NativeArray mixins Ember$NativeArray {}
    declare class NoneLocation mixins Ember$NoneLocation {}
    declare var ORDER_DEFINITION: typeof undefined;
    declare class Object mixins Ember$Object {}
    declare class ObjectController mixins Ember$ObjectController {}
    declare class ObjectProxy mixins Ember$ObjectProxy {}
    declare class Observable mixins Ember$Observable {}
    declare class OrderedSet mixins Ember$OrderedSet {}
    declare interface RSVP$PromiseResolve {
        (value?: any): void
    }

    declare interface RSVP$PromiseReject {
        (reason?: any): void
    }

    declare interface RSVP$PromiseResolverFunction {
        (resolve: RSVP$PromiseResolve, reject: RSVP$PromiseReject): void
    }

    declare class Promise mixins undefined.Promise {}
    declare class RenderBuffer mixins Ember$RenderBuffer {}
    declare class Route mixins Ember$Route {}
    declare class Router mixins Ember$Router {}
    declare class RouterDSL mixins Ember$RouterDSL {}
    declare var SHIM_ES5: typeof undefined;
    declare var STRINGS: typeof undefined;
    declare class Select mixins Ember$Select {}
    declare class SelectOption mixins Ember$SelectOption {}
    declare class Set mixins Ember$Set {}
    declare class SortableMixin mixins Ember$SortableMixin {}
    declare class State mixins Ember$State {}
    declare class StateManager mixins Ember$StateManager {}
    declare var camelize: typeof undefined;

    declare var capitalize: typeof undefined;

    declare var classify: typeof undefined;

    declare var dasherize: typeof undefined;

    declare var decamelize: typeof undefined;

    declare var fmt: typeof undefined;

    declare var htmlSafe: typeof undefined;

    declare var loc: typeof undefined;

    declare var underscore: typeof undefined;

    declare var w: typeof undefined;
    declare var TEMPLATES: typeof undefined;
    declare class TargetActionSupport mixins Ember$TargetActionSupport {}
    declare class Test mixins Ember$Test {}
    declare class TextArea mixins Ember$TextArea {}
    declare class TextField mixins Ember$TextField {}
    declare class TextSupport mixins Ember$TextSupport {}
    declare var VERSION: typeof undefined;
    declare class View mixins Ember$View {}
    declare class ViewTargetActionSupport mixins Ember$ViewTargetActionSupport {}
    declare var ViewUtils: typeof undefined;
    declare var addBeforeObserver: typeof undefined;
    declare var addListener: typeof undefined;
    declare var addObserver: typeof undefined;
    declare var alias: typeof undefined;
    declare var aliasMethod: typeof undefined;
    declare var anyUnprocessedMixins: typeof undefined;
    declare var assert: typeof undefined;
    declare var beforeObserver: typeof undefined;
    declare var beforeObserversFor: typeof undefined;
    declare var beginPropertyChanges: typeof undefined;
    declare var bind: typeof undefined;
    declare var cacheFor: typeof undefined;
    declare var canInvoke: typeof undefined;
    declare var changeProperties: typeof undefined;
    declare var compare: typeof undefined;
    declare var computed: typeof undefined;
    declare var config: typeof undefined;
    declare var controllerFor: typeof undefined;
    declare var copy: typeof undefined;
    declare var create: typeof undefined;
    declare var debug: typeof undefined;
    declare var defineProperty: typeof undefined;
    declare var deprecate: typeof undefined;
    declare var deprecateFunc: typeof undefined;
    declare var destroy: typeof undefined;
    declare var empty: typeof undefined;
    declare var endPropertyChanges: typeof undefined;
    declare var exports: typeof undefined;
    declare var finishChains: typeof undefined;
    declare var flushPendingChains: typeof undefined;
    declare var generateController: typeof undefined;
    declare var generateGuid: typeof undefined;
    declare var get: typeof undefined;
    declare var getMeta: typeof undefined;
    declare var getPath: typeof undefined;
    declare var getWithDefault: typeof undefined;
    declare var guidFor: typeof undefined;
    declare var handleErrors: typeof undefined;
    declare var hasListeners: typeof undefined;
    declare var hasOwnProperty: typeof undefined;
    declare var immediateObserver: typeof undefined;
    declare var imports: typeof undefined;
    declare var inspect: typeof undefined;
    declare var instrument: typeof undefined;
    declare var isArray: typeof undefined;
    declare var isEmpty: typeof undefined;
    declare var isEqual: typeof undefined;
    declare var isGlobalPath: typeof undefined;
    declare var isNamespace: typeof undefined;
    declare var isNone: typeof undefined;
    declare var isPrototypeOf: typeof undefined;
    declare var isWatching: typeof undefined;
    declare var keys: typeof undefined;
    declare var listenersDiff: typeof undefined;
    declare var listenersFor: typeof undefined;
    declare var listenersUnion: typeof undefined;
    declare var lookup: typeof undefined;
    declare var makeArray: typeof undefined;
    declare var merge: typeof undefined;
    declare var meta: typeof undefined;
    declare var metaPath: typeof undefined;
    declare var mixin: typeof undefined;
    declare var none: typeof undefined;
    declare var normalizeTuple: typeof undefined;
    declare var observer: typeof undefined;
    declare var observersFor: typeof undefined;
    declare var onLoad: typeof undefined;
    declare var oneWay: typeof undefined;
    declare var onError: typeof undefined;
    declare var overrideChains: typeof undefined;
    declare var platform: typeof undefined;
    declare var propertyDidChange: typeof undefined;
    declare var propertyIsEnumerable: typeof undefined;
    declare var propertyWillChange: typeof undefined;
    declare var removeBeforeObserver: typeof undefined;
    declare var removeChainWatcher: typeof undefined;
    declare var removeListener: typeof undefined;
    declare var removeObserver: typeof undefined;
    declare var required: typeof undefined;
    declare var rewatch: typeof undefined;
    declare var run: typeof undefined;
    declare var runLoadHooks: typeof undefined;
    declare var sendEvent: typeof undefined;
    declare var set: typeof undefined;
    declare var setMeta: typeof undefined;
    declare var setPath: typeof undefined;
    declare var setProperties: typeof undefined;
    declare var subscribe: typeof undefined;
    declare var toLocaleString: typeof undefined;
    declare var toString: typeof undefined;
    declare var tryCatchFinally: typeof undefined;
    declare var tryFinally: typeof undefined;
    declare var tryInvoke: typeof undefined;
    declare var trySet: typeof undefined;
    declare var trySetPath: typeof undefined;
    declare var typeOf: typeof undefined;
    declare var unwatch: typeof undefined;
    declare var unwatchKey: typeof undefined;
    declare var unwatchPath: typeof undefined;
    declare var uuid: typeof undefined;
    declare var valueOf: typeof undefined;
    declare var warn: typeof undefined;
    declare var watch: typeof undefined;
    declare var watchKey: typeof undefined;
    declare var watchPath: typeof undefined;
    declare var watchedEvents: typeof undefined;
    declare var wrap: typeof undefined;
}