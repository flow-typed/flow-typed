// @flow
/**
 * Flowtype definitions for mz
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'mz/fs' {


    declare interface Stats {
        isFile(): boolean,
            isDirectory(): boolean,
            isBlockDevice(): boolean,
            isCharacterDevice(): boolean,
            isSymbolicLink(): boolean,
            isFIFO(): boolean,
            isSocket(): boolean,
            dev: number,
            ino: number,
            mode: number,
            nlink: number,
            uid: number,
            gid: number,
            rdev: number,
            size: number,
            blksize: number,
            blocks: number,
            atime: Date,
            mtime: Date,
            ctime: Date,
            birthtime: Date
    }
    declare type FSWatcher = {
        close(): void
    }
    declare     export type ReadStream = {
        close(): void
    }
    declare     export type WriteStream = {
        close(): void,
        bytesWritten: number
    }

    /**
     * Asynchronous rename.
     * @param oldPath 
     * @param newPath 
     * @param callback No arguments other than a possible exception are given to the completion callback.
     */
    declare     export function rename(oldPath: string, newPath: string): Promise<void >

        /**
         * Synchronous rename
         * @param oldPath 
         * @param newPath 
         */
        declare     export function renameSync(oldPath: string, newPath: string): void
    declare     export function truncate(path: string, callback?: (err?: NodeJS.ErrnoException) => void): void
    declare     export function truncateSync(path: string, len?: number): void
    declare     export function ftruncate(fd: number): Promise<void >
        declare     export function ftruncateSync(fd: number, len?: number): void
    declare     export function chown(path: string, uid: number, gid: number): Promise<void >
        declare     export function chownSync(path: string, uid: number, gid: number): void
    declare     export function fchown(fd: number, uid: number, gid: number): Promise<void >
        declare     export function fchownSync(fd: number, uid: number, gid: number): void
    declare     export function lchown(path: string, uid: number, gid: number): Promise<void >
        declare     export function lchownSync(path: string, uid: number, gid: number): void
    declare     export function chmod(path: string, mode: number): Promise<void >
        declare     export function chmodSync(path: string, mode: number): void
    declare     export function fchmod(fd: number, mode: number): Promise<void >
        declare     export function fchmodSync(fd: number, mode: number): void
    declare     export function lchmod(
        path: string,
        mode: number,
        callback?: (err?: NodeJS.ErrnoException) => void): void
    declare     export function lchmodSync(path: string, mode: number): void
    declare     export function stat(path: string): Promise<Stats >
        declare     export function lstat(path: string): Promise<Stats >
        declare     export function fstat(fd: number): Promise<Stats >
        declare     export function statSync(path: string): Stats
    declare     export function lstatSync(path: string): Stats
    declare     export function fstatSync(fd: number): Stats
    declare     export function link(srcpath: string, dstpath: string): Promise<void >
        declare     export function linkSync(srcpath: string, dstpath: string): void
    declare     export function symlink(srcpath: string, dstpath: string, type?: string): Promise<void >
        declare     export function symlinkSync(srcpath: string, dstpath: string, type?: string): void
    declare     export function readlink(path: string): Promise<string >
        declare     export function readlinkSync(path: string): string
    declare     export function realpath(path: string): Promise<string >
        declare     export function realpathSync(path: string, cache?: {
        [path: string]: string
    }): string
    declare     export function unlink(path: string): Promise<void >
        declare     export function unlinkSync(path: string): void
    declare     export function rmdir(path: string): Promise<void >
        declare     export function rmdirSync(path: string): void
    declare     export function mkdir(path: string): Promise<void >
        declare     export function mkdirSync(path: string, mode?: number): void
    declare     export function readdir(path: string): Promise<string[] >
        declare     export function readdirSync(path: string): string[]
    declare     export function close(fd: number): Promise<void >
        declare     export function closeSync(fd: number): void
    declare     export function open(path: string, flags: string): Promise<number >
        declare     export function openSync(path: string, flags: string, mode?: number): number
    declare     export function utimes(path: string, atime: number, mtime: number): Promise<void >
        declare     export function utimesSync(path: string, atime: number, mtime: number): void
    declare     export function futimes(fd: number, atime: number, mtime: number): Promise<void >
        declare     export function futimesSync(fd: number, atime: number, mtime: number): void
    declare     export function fsync(fd: number): Promise<void >
        declare     export function fsyncSync(fd: number): void
    declare     export function write(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): Promise<[number, Buffer] >
        declare     export function writeSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): number
    declare     export function read(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): Promise<[number, Buffer] >
        declare     export function readSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): number
    declare     export function readFile(filename: string, encoding: string): Promise<string >
        declare     export function readFileSync(filename: string, encoding: string): string
    declare     export function writeFile(filename: string, data: any): Promise<void >
        declare     export function writeFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare     export function appendFile(
        filename: string,
        data: any,
        options: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): Promise<void >
        declare     export function appendFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare     export function watchFile(filename: string, listener: (curr: Stats, prev: Stats) => void): void
    declare     export function unwatchFile(filename: string, listener?: (curr: Stats, prev: Stats) => void): void
    declare     export function watch(
        filename: string,
        listener?: (event: string, filename: string) => any): FSWatcher
    declare     export function exists(path: string): Promise<boolean >
        declare     export function existsSync(path: string): boolean
    declare     export var F_OK: number;
    declare     export var R_OK: number;
    declare     export var W_OK: number;
    declare     export var X_OK: number;

    /**
     * Tests a user's permissions for the file specified by path. 
     */
    declare     export function access(path: string): Promise<void >

        /**
         * Synchronous version of fs.access. This throws if any accessibility checks fail, and does nothing otherwise. 
         */
        declare     export function accessSync(path: string, mode?: number): void
    declare     export function createReadStream(
        path: string,
        options?: {
            flags?: string,
            encoding?: string,
            fd?: number,
            mode?: number,
            autoClose?: boolean
        }): ReadStream
    declare     export function createWriteStream(
        path: string,
        options?: {
            flags?: string,
            encoding?: string,
            fd?: number,
            mode?: number
        }): WriteStream
}
declare module 'mz/dns' {
    declare     export function lookup(domain: string, family: number): Promise<[string, number] >
        declare     export function resolve(domain: string, rrtype: string): Promise<string[] >
        declare     export function resolve4(domain: string): Promise<string[] >
        declare     export function resolve6(domain: string): Promise<string[] >
        declare     export function resolveMx(domain: string): Promise<string[] >
        declare     export function resolveTxt(domain: string): Promise<string[] >
        declare     export function resolveSrv(domain: string): Promise<string[] >
        declare     export function resolveNs(domain: string): Promise<string[] >
        declare     export function resolveCname(domain: string): Promise<string[] >
        declare     export function reverse(ip: string): Promise<string[] >
}
declare module 'mz/crypto' {
    declare     export interface CredentialDetails {
        pfx: string,
            key: string,
            passphrase: string,
            cert: string,
            ca: any,
            crl: any,
            ciphers: string
    }
    declare     export interface Credentials {
        context?: any
    }
    declare     export function createCredentials(details: CredentialDetails): Credentials
    declare     export function createHash(algorithm: string): Hash
    declare     export function createHmac(algorithm: string, key: string): Hmac
    declare     export interface Hash {
        update(data: any, input_encoding?: string): Hash,
            digest(encoding: "buffer"): Buffer,
            digest(encoding: string): any,
            digest(): Buffer
    }
    declare     export type Hmac = {
        update(data: any, input_encoding?: string): Hmac,
        digest(encoding: "buffer"): Buffer,
        digest(encoding: string): any,
        digest(): Buffer
    }
    declare     export function createCipher(algorithm: string, password: any): Cipher
    declare     export function createCipheriv(algorithm: string, key: any, iv: any): Cipher
    declare     export interface Cipher {
        update(data: Buffer): Buffer,
            update(data: string, input_encoding?: string, output_encoding?: string): string,
            final(): Buffer,
            final(output_encoding: string): string,
            setAutoPadding(auto_padding: boolean): void
    }
    declare     export function createDecipher(algorithm: string, password: any): Decipher
    declare     export function createDecipheriv(algorithm: string, key: any, iv: any): Decipher
    declare     export interface Decipher {
        update(data: Buffer): Buffer,
            update(data: string, input_encoding?: string, output_encoding?: string): string,
            final(): Buffer,
            final(output_encoding: string): string,
            setAutoPadding(auto_padding: boolean): void
    }
    declare     export function createSign(algorithm: string): Signer
    declare     export type Signer = {
        update(data: any): void,
        sign(private_key: string, output_format: string): string
    }
    declare     export function createVerify(algorith: string): Verify
    declare     export type Verify = {
        update(data: any): void,
        verify(object: string, signature: string, signature_format?: string): boolean
    }
    declare     export function createDiffieHellman(prime_length: number): DiffieHellman
    declare     export interface DiffieHellman {
        generateKeys(encoding?: string): string,
            computeSecret(
                other_public_key: string,
                input_encoding?: string,
                output_encoding?: string): string,
            getPrime(encoding?: string): string,
            getGenerator(encoding: string): string,
            getPublicKey(encoding?: string): string,
            getPrivateKey(encoding?: string): string,
            setPublicKey(public_key: string, encoding?: string): void,
            setPrivateKey(public_key: string, encoding?: string): void
    }
    declare     export function getDiffieHellman(group_name: string): DiffieHellman
    declare     export function pbkdf2(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number): Promise<Buffer >
        declare     export function pbkdf2Sync(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number): Buffer
    declare     export function randomBytes(size: number): Promise<Buffer >
        declare     export function pseudoRandomBytes(size: number): Promise<Buffer >
        declare     export interface RsaPublicKey {
        key: string,
            padding?: any
    }
    declare     export interface RsaPrivateKey {
        key: string,
            passphrase?: string,
            padding?: any
    }
    declare     export function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer
    declare     export function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer
}
declare module 'mz/child_process' {


    declare     export type ChildProcess = {
        stdin: stream.Writable,
        stdout: stream.Readable,
        stderr: stream.Readable,
        stdio: (stream.Readable | stream.Writable)[],
        pid: number,
        kill(signal?: string): void,
        send(message: any, sendHandle?: any): void,
        disconnect(): void,
        unref(): void
    }
    declare     export function spawn(
        command: string,
        args?: string[],
        options?: {
            cwd?: string,
            stdio?: any,
            custom?: any,
            env?: any,
            detached?: boolean
        }): ChildProcess
    declare     export function exec(
        command: string,
        options: {
            cwd?: string,
            stdio?: any,
            customFds?: any,
            env?: any,
            encoding?: string,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string
        }): Promise<[Buffer, Buffer] >
        declare     export function execFile(file: string): Promise<[Buffer, Buffer] >
        declare     export function fork(
        modulePath: string,
        args?: string[],
        options?: {
            cwd?: string,
            env?: any,
            execPath?: string,
            execArgv?: string[],
            silent?: boolean,
            uid?: number,
            gid?: number
        }): ChildProcess
    declare     export function spawnSync(
        command: string,
        args?: string[],
        options?: {
            cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            uid?: number,
            gid?: number,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string,
            encoding?: string
        }): {
        pid: number,
        output: string[],
        stdout: string | Buffer,
        stderr: string | Buffer,
        status: number,
        signal: string,
        error: Error
    }
    declare     export function execSync(
        command: string,
        options?: {
            cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            uid?: number,
            gid?: number,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string,
            encoding?: string
        }): string | Buffer
    declare     export function execFileSync(
        command: string,
        args?: string[],
        options?: {
            cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            uid?: number,
            gid?: number,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string,
            encoding?: string
        }): string | Buffer
}
declare module 'mz/zlib' {

    declare     export interface ZlibOptions {
        chunkSize?: number,
            windowBits?: number,
            level?: number,
            memLevel?: number,
            strategy?: number,
            dictionary?: any
    }
    declare     export type Gzip = {}
    declare     export type Gunzip = {}
    declare     export type Deflate = {}
    declare     export type Inflate = {}
    declare     export type DeflateRaw = {}
    declare     export type InflateRaw = {}
    declare     export type Unzip = {}
    declare     export function createGzip(options?: ZlibOptions): Gzip
    declare     export function createGunzip(options?: ZlibOptions): Gunzip
    declare     export function createDeflate(options?: ZlibOptions): Deflate
    declare     export function createInflate(options?: ZlibOptions): Inflate
    declare     export function createDeflateRaw(options?: ZlibOptions): DeflateRaw
    declare     export function createInflateRaw(options?: ZlibOptions): InflateRaw
    declare     export function createUnzip(options?: ZlibOptions): Unzip
    declare     export function deflate(buf: Buffer): Promise<any >
        declare     export function deflateSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function deflateRaw(buf: Buffer): Promise<any >
        declare     export function deflateRawSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function gzip(buf: Buffer): Promise<any >
        declare     export function gzipSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function gunzip(buf: Buffer): Promise<any >
        declare     export function gunzipSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function inflate(buf: Buffer): Promise<any >
        declare     export function inflateSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function inflateRaw(buf: Buffer): Promise<any >
        declare     export function inflateRawSync(buf: Buffer, options?: ZlibOptions): any
    declare     export function unzip(buf: Buffer): Promise<any >
        declare     export function unzipSync(buf: Buffer, options?: ZlibOptions): any
    declare     export var Z_NO_FLUSH: number;
    declare     export var Z_PARTIAL_FLUSH: number;
    declare     export var Z_SYNC_FLUSH: number;
    declare     export var Z_FULL_FLUSH: number;
    declare     export var Z_FINISH: number;
    declare     export var Z_BLOCK: number;
    declare     export var Z_TREES: number;
    declare     export var Z_OK: number;
    declare     export var Z_STREAM_END: number;
    declare     export var Z_NEED_DICT: number;
    declare     export var Z_ERRNO: number;
    declare     export var Z_STREAM_ERROR: number;
    declare     export var Z_DATA_ERROR: number;
    declare     export var Z_MEM_ERROR: number;
    declare     export var Z_BUF_ERROR: number;
    declare     export var Z_VERSION_ERROR: number;
    declare     export var Z_NO_COMPRESSION: number;
    declare     export var Z_BEST_SPEED: number;
    declare     export var Z_BEST_COMPRESSION: number;
    declare     export var Z_DEFAULT_COMPRESSION: number;
    declare     export var Z_FILTERED: number;
    declare     export var Z_HUFFMAN_ONLY: number;
    declare     export var Z_RLE: number;
    declare     export var Z_FIXED: number;
    declare     export var Z_DEFAULT_STRATEGY: number;
    declare     export var Z_BINARY: number;
    declare     export var Z_TEXT: number;
    declare     export var Z_ASCII: number;
    declare     export var Z_UNKNOWN: number;
    declare     export var Z_DEFLATED: number;
    declare     export var Z_NULL: number;
}
declare module 'mz/readline' {


    declare     export interface Key {
        sequence?: string,
            name?: string,
            ctrl?: boolean,
            meta?: boolean,
            shift?: boolean
    }
    declare     export type ReadLine = {
        setPrompt(prompt: string): void,
        prompt(preserveCursor?: boolean): void,
        question(query: string, callback: (answer: string) => void): void,
        question(query: string): Promise<string>,
        pause(): ReadLine,
        resume(): ReadLine,
        close(): void,
        write(data: string | Buffer, key?: Key): void
    }
    declare     export interface Completer {
        (line: string): Promise<[string[], string]>,
            (line: string): [string[], string],
            (line: string, callback: (err: any, result: [string[], string]) => void): any,
            (line: string, callback: (err: any, result: CompleterResult) => void): any
    }
    declare     export interface CompleterResult {
        completions: string[],
            line: string
    }
    declare     export interface ReadLineOptions {
        input: NodeJS.ReadableStream,
            output?: NodeJS.WritableStream,
            completer?: Completer,
            terminal?: boolean,
            historySize?: number
    }
    declare     export function createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer,
        terminal?: boolean): ReadLine
    declare     export function cursorTo(stream: NodeJS.WritableStream, x: number, y: number): void
    declare     export function moveCursor(stream: NodeJS.WritableStream, dx: number | string, dy: number | string): void
    declare     export function clearLine(stream: NodeJS.WritableStream, dir: number): void
    declare     export function clearScreenDown(stream: NodeJS.WritableStream): void
}
declare module 'mz' {

}