/**
 * Flowtype definitions for mqtt
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'mqtt' {

    declare var npm$namespace$mqtt: {
        createClient: typeof mqtt$createClient,
        createSecureClient: typeof mqtt$createSecureClient,
        connect: typeof mqtt$connect,
        createConnection: typeof mqtt$createConnection,
        createServer: typeof mqtt$createServer,
        createSecureServer: typeof mqtt$createSecureServer,
    }
    declare interface mqtt$Packet {
        messageId: string, [key: string]: any
    }

    declare interface mqtt$Granted {

        /**
         * is a subscribed to topic
         */
        topic: string,

            /**
             * is the granted qos level on it
             */
            qos: number
    }

    declare interface mqtt$Topic {
        [topic: string]: number
    }


    /**
     * MQTT CLIENT
     */
    declare type mqtt$ClientOptions = {

        /**
         * 10 seconds, set to 0 to disable
         */
        keepalive?: number,

        /**
         * 'mqttjs_' + Math.random().toString(16).substr(2, 8)
         */
        clientId?: string,

        /**
         * 'MQTT'
         */
        protocolId?: string,

        /**
         * 4
         */
        protocolVersion?: number,

        /**
         * true, set to false to receive QoS 1 and 2 messages while offline
         */
        clean?: boolean,

        /**
         * 1000 milliseconds, interval between two reconnections
         */
        reconnectPeriod?: number,

        /**
         * 30 * 1000 milliseconds, time to wait before a CONNACK is received
         */
        connectTimeout?: number,

        /**
         * the username required by your broker, if any
         */
        username?: string,

        /**
         * the password required by your broker, if any
         */
        password?: string,

        /**
         * a Store for the incoming packets
         */
        incomingStore?: mqtt$Store,

        /**
         * a Store for the outgoing packets
         */
        outgoingStore?: mqtt$Store,

        /**
         * a message that will sent by the broker automatically when the client disconnect badly.
         */
        will?: {

            /**
             * the topic to publish
             */
            topic: string,

            /**
             * the message to publish
             */
            payload: string,

            /**
             * the QoS
             */
            qos: number,

            /**
             * the retain flag
             */
            retain: boolean
        }
    } & mqtt$SecureClientOptions


    declare interface mqtt$SecureClientOptions {

        /**
         * path to private key
         */
        keyPath?: string,

            /**
             * path to corresponding public cert
             */
            certPath?: string,
            rejectUnauthorized?: boolean
    }

    declare interface mqtt$ClientPublishOptions {

        /**
         * the QoS
         */
        qos?: number,

            /**
             * the retain flag
             */
            retain?: boolean
    }

    declare interface mqtt$ClientSubscribeOptions {

        /**
         * the QoS
         */
        qos?: number
    }

    declare interface mqtt$ClientSubscribeCallback {
        (err: any, granted: mqtt$Granted): void
    }


    /**
     * 
     * @deprecated  use connect() instead
    Create a new IClient (see: IClient)
     * @param port - broker port (default: 1883)
     * @param host - broker host (default: localhost)
     * @param options - connect options
    */
    declare function mqtt$createClient(port?: number, host?: string, options?: mqtt$ClientOptions): mqtt$Client


    /**
     * 
     * @deprecated  use connect() instead
    Create a new secure IClient
     * @param port 
     * @param host 
     * @param options - connection options, must include keys.
    */
    declare function mqtt$createSecureClient(port?: number, host?: string, options?: mqtt$SecureClientOptions): mqtt$Client


    /**
     * Create a new MqttClient (see: IClient)
     * 
    The brokerUrl supports normal connections using mqtt:// or tcp:// and secure connections using mqtts:// or ssl://.

      Passing the clientId is also supported, for example mqtt://user@localhost?clientId=123abc.
     * @param brokerUrl 
     * @param options 
    */
    declare function mqtt$connect(brokerUrl: string, options?: mqtt$ClientOptions): mqtt$Client


    /**
     * The Client class wraps a client connection to an MQTT broker over an arbitrary transport method (TCP, TLS, WebSocket, ecc).
     * 
    Client automatically handles the following:
      - Regular server pings
      - QoS flow
      - Automatic reconnections
      - Start publishing before being connected
    */
    declare type mqtt$Client = {
        (streamBuilder: any, options: mqtt$ClientOptions): mqtt$Client,

        /**
         * Publish a message to a topic
         * @param topic 
         * @param message 
         * @param options 
         * @param callback 
         */
        publish(
            topic: string,
            message: Buffer,
            options?: mqtt$ClientPublishOptions,
            callback?: Function): mqtt$Client,
        publish(
            topic: string,
            message: string,
            options?: mqtt$ClientPublishOptions,
            callback?: Function): mqtt$Client,

        /**
         * Subscribe to a topic or topics
         * @param topic to subscribe to or an Array of topics to subscribe to. It can also be an object.
         * @param the options to subscribe with
         * @param callback fired on suback
         */
        subscribe(
            topic: string,
            options?: mqtt$ClientSubscribeOptions,
            callback?: mqtt$ClientSubscribeCallback): mqtt$Client,
        subscribe(
            topic: string[],
            options?: mqtt$ClientSubscribeOptions,
            callback?: mqtt$ClientSubscribeCallback): mqtt$Client,
        subscribe(
            topic: mqtt$Topic,
            options?: mqtt$ClientSubscribeOptions,
            callback?: mqtt$ClientSubscribeCallback): mqtt$Client,

        /**
         * Unsubscribe from a topic or topics
         * @param topic is a String topic or an array of topics to unsubscribe from
         * @param options 
         * @param callback fired on unsuback
         */
        unsubscribe(
            topic: string,
            options?: mqtt$ClientSubscribeOptions,
            callback?: mqtt$ClientSubscribeCallback): mqtt$Client,
        unsubscribe(
            topic: string[],
            options?: mqtt$ClientSubscribeOptions,
            callback?: mqtt$ClientSubscribeCallback): mqtt$Client,

        /**
         * end - close connection
         * @param force passing it to true will close the client right away, without waiting for the in-flight messages to be acked.
        This parameter is optional.
         * @param callback 
        */
        end(force?: boolean, callback?: Function): mqtt$Client,

        /**
         * Handle messages with backpressure support, one at a time. Override at will, but always call callback, or the client will
         * hang.
         * @param packet 
         * @param callback 
         */
        handleMessage(packet: mqtt$Packet, callback: Function): mqtt$Client
    } & EventEmitter



    /**
     * STOREIn-memory implementation of the message store.
     * 
    Another implementaion is mqtt-level-store which uses Level-browserify to store the inflight data,
    making it usable both in Node and the Browser.
    */
    declare interface mqtt$Store {

        /**
         * Adds a packet to the store, a packet is anything that has a messageId property. The callback is called when the packet has
         * been stored.
         * @param packet 
         * @param callback 
         */
        put(packet: mqtt$Packet, callback: Function): mqtt$Store,

            /**
             * get a packet from the store
             * @param packet 
             * @param callback 
             */
            get(packet: mqtt$Packet, callback: Function): mqtt$Store,

            /**
             * Creates a stream with all the packets in the store.
             */
            createStream(): ReadableStream,

            /**
             * Removes a packet from the store, a packet is anything that has a messageId property. The callback is called when the packet
             * has been removed.
             * @param packet 
             * @param callback 
             */
            del(packet: mqtt$Packet, callback: Function): mqtt$Store,

            /**
             * Closes the Store.
             * @param callback 
             */
            close(callback: Function): void
    }


    /**
     * CONNECTION
     * @deprecated  use mqtt-connect instead
    Create a new MqttConnection (see: MqttConnection)
     * @param port - broker port (default: 1883)
     * @param host - broker host (default: localhost)
     * @param callback - fired on underlying stream connect
    */
    declare function mqtt$createConnection(port?: number, host?: string, callback?: Function): mqtt$Connection

    declare interface mqtt$ConnectOptions {

        /**
         * Protocol ID, usually MQIsdp.
         */
        protocolId?: string,

            /**
             * Protocol version, usually 3.
             */
            protocolVersion?: number,

            /**
             * keepalive period in seconds.
             */
            keepalive?: number,

            /**
             * client ID.
             */
            clientId?: string,

            /**
             * the client's will message options
             */
            will?: {

                /**
                 * the topic to publish
                 */
                topic: string,

                /**
                 * the message to publish
                 */
                payload: string,

                /**
                 * the QoS
                 */
                qos: number,

                /**
                 * the retain flag
                 */
                retain: boolean
            },

            /**
             * the 'clean start' flag.
             */
            clean?: boolean,

            /**
             * username for protocol v3.1.
             */
            username?: string,

            /**
             * password for protocol v3.1.
             */
            password?: string
    }

    declare interface mqtt$ConnectionPublishOptions {

        /**
         * the message ID of the packet, required if qos>0.
         */
        messageId?: number,

            /**
             * the topic to publish
             */
            topic?: string,

            /**
             * the message to publish
             */
            payload?: string,

            /**
             * the QoS
             */
            qos?: number,

            /**
             * the retain flag
             */
            retain?: boolean
    }


    /**
     * The MqttConnection class represents a raw MQTT connection, both on the server and on the client side. For client side
     * operations, it is strongly recommended that MqttClient is used, as MqttConnection requires a great deal of additional
    boilerplate such as setting up error handling and ping request/responses.

    If such fine grained control is required, MqttConnection can be instantiated using the mqtt.createConnection method.

    MqttServerClient is an unaltered subclass of MqttConnection and can be used in exactly the same way.
     * @link  https://github.com/mqttjs/MQTT.js/wiki/connection
    */
    declare type mqtt$Connection = {

        /**
         * Send an MQTT connect packet.
         * @param options 
         */
        connect(options?: mqtt$ConnectOptions): mqtt$Connection,

        /**
         * Send an MQTT connack packet.
         * @param options 
         */
        connack(options?: {
            returnCode: number
        }): mqtt$Connection,

        /**
         * Send an MQTT publish packet.
         * @param options 
         */
        publish(options?: mqtt$ConnectionPublishOptions): mqtt$Connection
    } & EventEmitter



    /**
     * SERVER
     * @deprecated  use connect instead
    Create a new MqttServer (see : IServer)
     * @param listener - callback called on server client event
    */
    declare function mqtt$createServer(listener?: Function): mqtt$Server


    /**
     * 
     * @deprecated  use connect instead
    Create a new MqttSecureServer
     * @param keyPath - path to private key file
     * @param certPath - path to corresponding public cert
     * @param listener - callback called on server client event
    */
    declare function mqtt$createSecureServer(keyPath: string, certPath: string, listener?: Function): mqtt$Server


    /**
     * The primary methods of instantiating mqtt.js server classes are through the mqtt.createServer and mqtt.createSecureServer
     * methods. The former returns an instance of MqttServer and and the latter returns an instance of MqttSecureServer.

    While it is possible to instantiate these classes through new MqttServer(), it is strongly recommended to use the factory
    methods
     * @link  https://github.com/mqttjs/MQTT.js/wiki/server
    */
    declare type mqtt$Server = {} & EventEmitter

    declare module.exports: typeof mqtt
}