// @flow
/**
 * Flowtype definitions for webpack
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'webpack' {

    declare interface webpack$Configuration {
        context?: string,
            entry?: string | string[] | webpack$Entry,

            /**
             * Choose a developer tool to enhance debugging. 
             */
            devtool?: string,

            /**
             * Options affecting the output. 
             */
            output?: webpack$Output,

            /**
             * Options affecting the normal modules (NormalModuleFactory) 
             */
            module?: webpack$Module,

            /**
             * Options affecting the resolving of modules. 
             */
            resolve?: webpack$Resolve,

            /**
             * Like resolve but for loaders. 
             */
            resolveLoader?: webpack$ResolveLoader,

            /**
             * Specify dependencies that shouldn’t be resolved by webpack, but should become dependencies of the resulting bundle.
             * The kind of the dependency depends on output.libraryTarget.
             */
            externals?: webpack$ExternalsElement | webpack$ExternalsElement[],

            /**
             * <ul>
             *    <li>"web" Compile for usage in a browser-like environment (default)</li>
               <li>"webworker" Compile as WebWorker</li>
               <li>"node" Compile for usage in a node.js-like environment (use require to load chunks)</li>
               <li>"async-node" Compile for usage in a node.js-like environment (use fs and vm to load chunks async)</li>
               <li>"node-webkit" Compile for usage in webkit, uses jsonp chunk loading but also supports builtin node.js modules plus require(“nw.gui”) (experimental)</li>
               <li>"atom" Compile for usage in electron (formerly known as atom-shell), supports require for modules necessary to run Electron.</li>
            <ul>
            */
            target?: string,

            /**
             * Report the first error as a hard error instead of tolerating it. 
             */
            bail?: boolean,

            /**
             * Capture timing information for each module. 
             */
            profile?: boolean,

            /**
             * Cache generated modules and chunks to improve performance for multiple incremental builds. 
             */
            cache?: boolean | any,

            /**
             * Enter watch mode, which rebuilds on file change. 
             */
            watch?: boolean,
            watchOptions?: compiler$WatchOptions,

            /**
             * Switch loaders to debug mode. 
             */
            debug?: boolean,

            /**
             * Can be used to configure the behaviour of webpack-dev-server when the webpack config is passed to webpack-dev-server CLI. 
             */
            devServer?: any,

            /**
             * Include polyfills or mocks for various node stuff 
             */
            node?: webpack$Node,

            /**
             * Set the value of require.amd and define.amd. 
             */
            amd?: {
                [moduleName: string]: boolean
            },

            /**
             * Used for recordsInputPath and recordsOutputPath 
             */
            recordsPath?: string,

            /**
             * Load compiler state from a json file. 
             */
            recordsInputPath?: string,

            /**
             * Store compiler state to a json file. 
             */
            recordsOutputPath?: string,

            /**
             * Add additional plugins to the compiler. 
             */
            plugins?: (webpack$Plugin | Function)[],

            /**
             * Stats options for logging  
             */
            stats?: compiler$StatsOptions
    }

    declare interface webpack$Entry {
        [name: string]: string | string[]
    }

    declare interface webpack$Output {

        /**
         * The output directory as absolute path (required). 
         */
        path?: string,

            /**
             * The filename of the entry chunk as relative path inside the output.path directory. 
             */
            filename?: string,

            /**
             * The filename of non-entry chunks as relative path inside the output.path directory. 
             */
            chunkFilename?: string,

            /**
             * The filename of the SourceMaps for the JavaScript files. They are inside the output.path directory. 
             */
            sourceMapFilename?: string,

            /**
             * Filename template string of function for the sources array in a generated SourceMap. 
             */
            devtoolModuleFilenameTemplate?: string,

            /**
             * Similar to output.devtoolModuleFilenameTemplate, but used in the case of duplicate module identifiers. 
             */
            devtoolFallbackModuleFilenameTemplate?: string,

            /**
             * Enable line to line mapped mode for all/specified modules.
             * Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source.
            It’s a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.
            true enables it for all modules (not recommended)
            */
            devtoolLineToLine?: boolean,

            /**
             * The filename of the Hot Update Chunks. They are inside the output.path directory. 
             */
            hotUpdateChunkFilename?: string,

            /**
             * The filename of the Hot Update Main File. It is inside the output.path directory. 
             */
            hotUpdateMainFilename?: string,

            /**
             * The output.path from the view of the Javascript / HTML page. 
             */
            publicPath?: string,

            /**
             * The JSONP function used by webpack for asnyc loading of chunks. 
             */
            jsonpFunction?: string,

            /**
             * The JSONP function used by webpack for async loading of hot update chunks. 
             */
            hotUpdateFunction?: string,

            /**
             * Include comments with information about the modules. 
             */
            pathinfo?: boolean,

            /**
             * If set, export the bundle as library. output.library is the name. 
             */
            library?: string,

            /**
             * Which format to export the library:
             * <ul>
               <li>"var" - Export by setting a variable: var Library = xxx (default)</li>
               <li>"this" - Export by setting a property of this: this["Library"] = xxx</li>
               <li>"commonjs" - Export by setting a property of exports: exports["Library"] = xxx</li>
               <li>"commonjs2" - Export by setting module.exports: module.exports = xxx</li>
               <li>"amd" - Export to AMD (optionally named)</li>
               <li>"umd" - Export to AMD, CommonJS2 or as property in root</li>
            </ul>
            */
            libraryTarget?: string,

            /**
             * If output.libraryTarget is set to umd and output.library is set, setting this to true will name the AMD module. 
             */
            umdNamedDefine?: boolean,

            /**
             * Prefixes every line of the source in the bundle with this string. 
             */
            sourcePrefix?: string,

            /**
             * This option enables cross-origin loading of chunks. 
             */
            crossOriginLoading?: string | boolean
    }

    declare interface webpack$Module {

        /**
         * A array of automatically applied loaders. 
         */
        loaders?: webpack$Loader[],

            /**
             * A array of applied pre loaders. 
             */
            preLoaders?: webpack$Loader[],

            /**
             * A array of applied post loaders. 
             */
            postLoaders?: webpack$Loader[],

            /**
             * A RegExp or an array of RegExps. Don’t parse files matching. 
             */
            noParse?: RegExp | RegExp[],
            unknownContextRequest?: string,
            unknownContextRecursive?: boolean,
            unknownContextRegExp?: RegExp,
            unknownContextCritical?: boolean,
            exprContextRequest?: string,
            exprContextRegExp?: RegExp,
            exprContextRecursive?: boolean,
            exprContextCritical?: boolean,
            wrappedContextRegExp?: RegExp,
            wrappedContextRecursive?: boolean,
            wrappedContextCritical?: boolean
    }

    declare interface webpack$Resolve {

        /**
         * Replace modules by other modules or paths. 
         */
        alias?: {
                [key: string]: string
            },

            /**
             * The directory (absolute path) that contains your modules.
             * May also be an array of directories.
            This setting should be used to add individual directories to the search path. 
            */
            root?: string | string[],

            /**
             * An array of directory names to be resolved to the current directory as well as its ancestors, and searched for modules.
             * This functions similarly to how node finds “node_modules” directories.
            For example, if the value is ["mydir"], webpack will look in “./mydir”, “../mydir”, “../../mydir”, etc.
            */
            modulesDirectories?: string[],

            /**
             * A directory (or array of directories absolute paths),
             * in which webpack should look for modules that weren’t found in resolve.root or resolve.modulesDirectories.
             */
            fallback?: string | string[],

            /**
             * An array of extensions that should be used to resolve modules.
             * For example, in order to discover CoffeeScript files, your array should contain the string ".coffee".
             */
            extensions?: string[],

            /**
             * Check these fields in the package.json for suitable files. 
             */
            packageMains?: (string | string[])[],

            /**
             * Check this field in the package.json for an object. Key-value-pairs are threaded as aliasing according to this spec 
             */
            packageAlias?: (string | string[])[],

            /**
             * Enable aggressive but unsafe caching for the resolving of a part of your files.
             * Changes to cached paths may cause failure (in rare cases). An array of RegExps, only a RegExp or true (all files) is expected.
            If the resolved path matches, it’ll be cached.
            */
            unsafeCache?: RegExp | RegExp[] | boolean
    }

    declare type webpack$ResolveLoader = {

        /**
         * It describes alternatives for the module name that are tried. 
         */
        moduleTemplates?: string[]
    } & webpack$Resolve


    declare type webpack$ExternalsElement = string | RegExp | webpack$ExternalsObjectElement | webpack$ExternalsFunctionElement;

    declare interface webpack$ExternalsObjectElement {
        [key: string]: boolean | string
    }

    declare interface webpack$ExternalsFunctionElement {
        (context: any, request: any, callback: (error: any, result: any) => void): any
    }

    declare interface webpack$WatchOptions {

        /**
         * Delay the rebuilt after the first change. Value is a time in ms. 
         */
        aggregateTimeout?: number,

            /**
             * true: use polling, number: use polling with specified interval 
             */
            poll?: boolean | number
    }

    declare interface webpack$Node {
        console?: boolean,
            global?: boolean,
            process?: boolean,
            Buffer?: boolean,
            ___filename?: boolean | string,
            ___dirname?: boolean | string, [nodeBuiltin: string]: boolean | string
    }

    declare type webpack$LoaderCondition = string | RegExp | ((absPath: string) => boolean);

    declare interface webpack$Loader {

        /**
         * A condition that must not be met 
         */
        exclude?: webpack$LoaderCondition | webpack$LoaderCondition[],

            /**
             * A condition that must be met 
             */
            include?: webpack$LoaderCondition | webpack$LoaderCondition[],

            /**
             * A condition that must be met 
             */
            test: webpack$LoaderCondition | webpack$LoaderCondition[],

            /**
             * A string of “!” separated loaders 
             */
            loader?: string,

            /**
             * A array of loaders as string 
             */
            loaders?: string[],
            query?: {
                [name: string]: any
            }
    }

    declare interface webpack$Plugin {}

    declare interface webpack$Webpack {
        (config: webpack$Configuration, callback?: compiler$CompilerCallback): compiler$Compiler,

        /**
         * optimize namespace
         */
        optimize: webpack$Optimize,

            /**
             * dependencies namespace
             */
            dependencies: webpack$Dependencies,

            /**
             * Replace resources that matches resourceRegExp with newResource.
             * If newResource is relative, it is resolve relative to the previous resource.
            If newResource is a function, it is expected to overwrite the ‘request’ attribute of the supplied object.
            */
            NormalModuleReplacementPlugin: webpack$NormalModuleReplacementPluginStatic,

            /**
             * Replaces the default resource, recursive flag or regExp generated by parsing with newContentResource,
             * newContentRecursive resp. newContextRegExp if the resource (directory) matches resourceRegExp.
            If newContentResource is relative, it is resolve relative to the previous resource.
            If newContentResource is a function, it is expected to overwrite the ‘request’ attribute of the supplied object.
            */
            ContextReplacementPlugin: webpack$ContextReplacementPluginStatic,

            /**
             * Don’t generate modules for requests matching the provided RegExp.
             */
            IgnorePlugin: webpack$IgnorePluginStatic,

            /**
             * A request for a normal module, which is resolved and built even before a require to it occurs.
             * This can boost performance. Try to profile the build first to determine clever prefetching points.
             */
            PrefetchPlugin: webpack$PrefetchPluginStatic,

            /**
             * Apply a plugin (or array of plugins) to one or more resolvers (as specified in types).
             */
            ResolverPlugin: webpack$ResolverPluginStatic,

            /**
             * Adds a banner to the top of each generated chunk.
             */
            BannerPlugin: webpack$BannerPluginStatic,

            /**
             * Define free variables. Useful for having development builds with debug logging or adding global constants.
             */
            DefinePlugin: webpack$DefinePluginStatic,

            /**
             * Automatically loaded modules.
             * Module (value) is loaded when the identifier (key) is used as free variable in a module.
            The identifier is filled with the exports of the loaded module.
            */
            ProvidePlugin: webpack$ProvidePluginStatic,

            /**
             * Adds SourceMaps for assets.
             */
            SourceMapDevToolPlugin: webpack$SourceMapDevToolPluginStatic,

            /**
             * Enables Hot Module Replacement. (This requires records data if not in dev-server mode, recordsPath)
             * Generates Hot Update Chunks of each chunk in the records.
            It also enables the API and makes __webpack_hash__ available in the bundle.
            */
            HotModuleReplacementPlugin: webpack$HotModuleReplacementPluginStatic,

            /**
             * Adds useful free vars to the bundle.
             */
            ExtendedAPIPlugin: webpack$ExtendedAPIPluginStatic,

            /**
             * When there are errors while compiling this plugin skips the emitting phase (and recording phase),
             * so there are no assets emitted that include errors. The emitted flag in the stats is false for all assets.
             */
            NoErrorsPlugin: webpack$NoErrorsPluginStatic,

            /**
             * Does not watch specified files matching provided paths or RegExps.
             */
            WatchIgnorePlugin: webpack$WatchIgnorePluginStatic
    }

    declare interface webpack$Optimize {

        /**
         * Search for equal or similar files and deduplicate them in the output.
         * This comes with some overhead for the entry chunk, but can reduce file size effectively.
        This is experimental and may crash, because of some missing implementations. (Report an issue)
        */
        DedupePlugin: optimize$DedupePluginStatic,

            /**
             * Limit the chunk count to a defined value. Chunks are merged until it fits.
             */
            LimitChunkCountPlugin: optimize$LimitChunkCountPluginStatic,

            /**
             * Merge small chunks that are lower than this min size (in chars). Size is approximated.
             */
            MinChunkSizePlugin: optimize$MinChunkSizePluginStatic,

            /**
             * Assign the module and chunk ids by occurrence count. Ids that are used often get lower (shorter) ids.
             * This make ids predictable, reduces to total file size and is recommended.
             */
            OccurenceOrderPlugin: optimize$OccurenceOrderPluginStatic,
            OccurrenceOrderPlugin: optimize$OccurenceOrderPluginStatic,

            /**
             * Minimize all JavaScript output of chunks. Loaders are switched into minimizing mode.
             * You can pass an object containing UglifyJs options.
             */
            UglifyJsPlugin: optimize$UglifyJsPluginStatic,
            CommonsChunkPlugin: optimize$CommonsChunkPluginStatic,

            /**
             * A plugin for a more aggressive chunk merging strategy.
             * Even similar chunks are merged if the total size is reduced enough.
            As an option modules that are not common in these chunks can be moved up the chunk tree to the parents.
            */
            AggressiveMergingPlugin: optimize$AggressiveMergingPluginStatic
    }

    declare interface webpack$Dependencies {

        /**
         * Support Labeled Modules.
         */
        LabeledModulesPlugin: dependencies$LabeledModulesPluginStatic
    }

    declare interface webpack$DirectoryDescriptionFilePluginStatic {
        new(file: string, files: string[]): webpack$Plugin
    }

    declare interface webpack$NormalModuleReplacementPluginStatic {
        new(resourceRegExp: any, newResource: any): webpack$Plugin
    }

    declare interface webpack$ContextReplacementPluginStatic {
        new(
            resourceRegExp: any,
            newContentResource?: any,
            newContentRecursive?: any,
            newContentRegExp?: any): webpack$Plugin
    }

    declare interface webpack$IgnorePluginStatic {
        new(requestRegExp: any, contextRegExp?: any): webpack$Plugin
    }

    declare interface webpack$PrefetchPluginStatic {
        new(context: any, request: any): webpack$Plugin,
        new(request: any): webpack$Plugin
    }

    declare interface webpack$ResolverPluginStatic {
        new(plugins: webpack$Plugin[], files?: string[]): webpack$Plugin,
        DirectoryDescriptionFilePlugin: webpack$DirectoryDescriptionFilePluginStatic,

            /**
             * This plugin will append a path to the module directory to find a match,
             * which can be useful if you have a module which has an incorrect “main” entry in its package.json/bower.json etc (e.g. "main": "Gruntfile.js").
            You can use this plugin as a special case to load the correct file for this module. Example:
            */
            FileAppendPlugin: webpack$FileAppendPluginStatic
    }

    declare interface webpack$FileAppendPluginStatic {
        new(files: string[]): webpack$Plugin
    }

    declare interface webpack$BannerPluginStatic {
        new(banner: any, options: any): webpack$Plugin
    }

    declare interface webpack$DefinePluginStatic {
        new(definitions: any): webpack$Plugin
    }

    declare interface webpack$ProvidePluginStatic {
        new(definitions: any): webpack$Plugin
    }

    declare interface webpack$SourceMapDevToolPluginStatic {
        new(options: any): webpack$Plugin
    }

    declare interface webpack$HotModuleReplacementPluginStatic {
        new(options?: any): webpack$Plugin
    }

    declare interface webpack$ExtendedAPIPluginStatic {
        new(): webpack$Plugin
    }

    declare interface webpack$NoErrorsPluginStatic {
        new(): webpack$Plugin
    }

    declare interface webpack$WatchIgnorePluginStatic {
        new(paths: RegExp[]): webpack$Plugin
    }

    declare interface optimize$DedupePluginStatic {
        new(): webpack$Plugin
    }

    declare interface optimize$LimitChunkCountPluginStatic {
        new(options: any): webpack$Plugin
    }

    declare interface optimize$MinChunkSizePluginStatic {
        new(options: any): webpack$Plugin
    }

    declare interface optimize$OccurenceOrderPluginStatic {
        new(preferEntry: boolean): webpack$Plugin
    }

    declare interface optimize$UglifyJsPluginStatic {
        new(options?: UglifyJS.MinifyOptions): webpack$Plugin
    }

    declare interface optimize$CommonsChunkPluginStatic {
        new(chunkName: string, filenames?: string | string[]): webpack$Plugin,
        new(options?: any): webpack$Plugin
    }

    declare interface optimize$AggressiveMergingPluginStatic {
        new(options: any): webpack$Plugin
    }

    declare interface dependencies$LabeledModulesPluginStatic {
        new(): webpack$Plugin
    }

    declare interface compiler$Compiler {

        /**
         * Builds the bundle(s). 
         */
        run(callback: compiler$CompilerCallback): void,

            /**
             * Builds the bundle(s) then starts the watcher, which rebuilds bundles whenever their source files change.
             * Returns a Watching instance. Note: since this will automatically run an initial build, so you only need to run watch (and not run).
             */
            watch(
                watchOptions: webpack$WatchOptions,
                handler: compiler$CompilerCallback): compiler$Watching,
            outputFileSystem: any,
            name: string,
            options: webpack$Configuration
    }

    declare interface compiler$Watching {
        close(callback: () => void): void
    }

    declare interface compiler$WatchOptions {

        /**
         * Delay the rebuilt after the first change. Value is a time in ms. 
         */
        aggregateTimeout?: number,

            /**
             * true: use polling, number: use polling with specified interval 
             */
            poll?: boolean | number
    }

    declare interface compiler$Stats {

        /**
         * Returns true if there were errors while compiling 
         */
        hasErrors(): boolean,

            /**
             * Returns true if there were warnings while compiling. 
             */
            hasWarnings(): boolean,

            /**
             * Return information as json object 
             */
            toJson(options?: compiler$StatsOptions): any,

            /**
             * Returns a formatted string of the result. 
             */
            toString(options?: compiler$StatsToStringOptions): string
    }

    declare interface compiler$StatsOptions {

        /**
         * context directory for request shortening 
         */
        context?: boolean,

            /**
             * add the hash of the compilation 
             */
            hash?: boolean,

            /**
             * add webpack version information 
             */
            version?: boolean,

            /**
             * add timing information 
             */
            timings?: boolean,

            /**
             * add assets information 
             */
            assets?: boolean,

            /**
             * add chunk information 
             */
            chunks?: boolean,

            /**
             * add built modules information to chunk information 
             */
            chunkModules?: boolean,

            /**
             * add built modules information 
             */
            modules?: boolean,

            /**
             * add children information 
             */
            children?: boolean,

            /**
             * add also information about cached (not built) modules 
             */
            cached?: boolean,

            /**
             * add information about the reasons why modules are included 
             */
            reasons?: boolean,

            /**
             * add the source code of modules 
             */
            source?: boolean,

            /**
             * add details to errors (like resolving log) 
             */
            errorDetails?: boolean,

            /**
             * add the origins of chunks and chunk merging info 
             */
            chunkOrigins?: boolean,

            /**
             * sort the modules by that field 
             */
            modulesSort?: string,

            /**
             * sort the chunks by that field 
             */
            chunksSort?: string,

            /**
             * sort the assets by that field 
             */
            assetsSort?: string
    }

    declare type compiler$StatsToStringOptions = {

        /**
         * With console colors 
         */
        colors?: boolean
    } & compiler$StatsOptions


    declare type compiler$CompilerCallback = (err: Error, stats: compiler$Stats) => void;
    declare     var webpack: webpack$Webpack;
    declare module.exports: typeof webpack
}