/**
 * Flowtype definitions for node
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Error {
    stack?: string
}
declare interface ErrorConstructor {
    captureStackTrace(targetObject: Object, constructorOpt?: Function): void,
        stackTraceLimit: number
}
declare interface MapConstructor {}
declare interface WeakMapConstructor {}
declare interface SetConstructor {}
declare interface WeakSetConstructor {}
declare
var process: NodeJS$Process;
declare
var global: NodeJS$Global;
declare
var ___filename: string;
declare
var ___dirname: string;
declare
function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timerdeclare
function clearTimeout(timeoutId: NodeJS$Timer): voiddeclare
function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timerdeclare
function clearInterval(intervalId: NodeJS$Timer): voiddeclare
function setImmediate(callback: (...args: any[]) => void, ...args: any[]): anydeclare
function clearImmediate(immediateId: any): voiddeclare interface NodeRequireFunction {
    (id: string): any
}
declare type NodeRequire = {
    resolve(id: string): string,
    cache: any,
    extensions: any,
    main: NodeModule
} & NodeRequireFunction
declare
var require: NodeRequire;
declare interface NodeModule {
    exports: any,
        require: NodeRequireFunction,
        id: string,
        filename: string,
        loaded: boolean,
        parent: NodeModule,
        children: NodeModule[]
}
declare
var module: NodeModule;
declare
var exports: any;
declare
var SlowBuffer: {
    new(str: string, encoding?: string): Buffer,
    new(size: number): Buffer,
    new(size: Uint8Array): Buffer,
    new(array: any[]): Buffer,
    prototype: Buffer,
    isBuffer(obj: any): boolean,
    byteLength(string: string, encoding?: string): number,
    concat(list: Buffer[], totalLength?: number): Buffer
};
declare type BufferEncoding = "ascii" |
    "utf8" |
    "utf16le" |
    "ucs2" |
    "binary" |
    "hex";
declare type Buffer = {} & NodeBuffer
declare
var Buffer: {

    /**
     * Allocates a new buffer containing the given {str}.
     * @param str String to store in buffer.
     * @param encoding encoding to use, optional.  Default is 'utf8'
     */
    new(str: string, encoding?: string): Buffer,

    /**
     * Allocates a new buffer of {size} octets.
     * @param size count of octets to allocate.
     */
    new(size: number): Buffer,

    /**
     * Allocates a new buffer containing the given {array} of octets.
     * @param array The octets to store.
     */
    new(array: Uint8Array): Buffer,

    /**
     * Produces a Buffer backed by the same allocated memory as
     * the given {ArrayBuffer}.
     * @param arrayBuffer The ArrayBuffer with which to share memory.
     */
    new(arrayBuffer: ArrayBuffer): Buffer,

    /**
     * Allocates a new buffer containing the given {array} of octets.
     * @param array The octets to store.
     */
    new(array: any[]): Buffer,

    /**
     * Copies the passed {buffer} data onto a new {Buffer} instance.
     * @param buffer The buffer to copy.
     */
    new(buffer: Buffer): Buffer,
    prototype: Buffer,

    /**
     * Allocates a new Buffer using an {array} of octets.
     * @param array 
     */
    from(array: any[]): Buffer,

    /**
     * When passed a reference to the .buffer property of a TypedArray instance,
     * the newly created Buffer will share the same allocated memory as the TypedArray.
    The optional {byteOffset} and {length} arguments specify a memory range
    within the {arrayBuffer} that will be shared by the Buffer.
     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()
     * @param byteOffset 
     * @param length 
    */
    from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer,

    /**
     * Copies the passed {buffer} data onto a new Buffer instance.
     * @param buffer 
     */
    from(buffer: Buffer): Buffer,

    /**
     * Creates a new Buffer containing the given JavaScript string {str}.
     * If provided, the {encoding} parameter identifies the character encoding.
    If not provided, {encoding} defaults to 'utf8'.
     * @param str 
    */
    from(str: string, encoding?: string): Buffer,

    /**
     * Returns true if {obj} is a Buffer
     * @param obj object to test.
     */
    isBuffer(obj: any): Buffer,

    /**
     * Returns true if {encoding} is a valid encoding argument.
     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
     * @param encoding string to test.
     */
    isEncoding(encoding: string): boolean,

    /**
     * Gives the actual byte length of a string. encoding defaults to 'utf8'.
     * This is not the same as String.prototype.length since that returns the number of characters in a string.
     * @param string string to test.
     * @param encoding encoding used to evaluate (defaults to 'utf8')
     */
    byteLength(string: string, encoding?: string): number,

    /**
     * Returns a buffer which is the result of concatenating all the buffers in the list together.
     * 
    If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
    If the list has exactly one item, then the first item of the list is returned.
    If the list has more than one item, then a new Buffer is created.
     * @param list An array of Buffer objects to concatenate
     * @param totalLength Total length of the buffers when concatenated.
    If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
    */
    concat(list: Buffer[], totalLength?: number): Buffer,

    /**
     * The same as buf1.compare(buf2).
     */
    compare(buf1: Buffer, buf2: Buffer): number,

    /**
     * Allocates a new buffer of {size} octets.
     * @param size count of octets to allocate.
     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).
    If parameter is omitted, buffer will be filled with zeros.
     * @param encoding encoding used for call to buf.fill while initalizing
    */
    alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer,

    /**
     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     * @param size count of octets to allocate
     */
    allocUnsafe(size: number): Buffer,

    /**
     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents
     * of the newly created Buffer are unknown and may contain sensitive data.
     * @param size count of octets to allocate
     */
    allocUnsafeSlow(size: number): Buffer
};
declare
export type NodeJS$ErrnoException = {
    errno?: number,
    code?: string,
    path?: string,
    syscall?: string,
    stack?: string
} & Error


declare
export class EventEmitter {
    addListener(event: string | , listener: Function): this;
    on(event: string | , listener: Function): this;
    once(event: string | , listener: Function): this;
    removeListener(event: string | , listener: Function): this;
    removeAllListeners(event?: string | ): this;
    setMaxListeners(n: number): this;
    getMaxListeners(): number;
    listeners(event: string | ): Function[];
    emit(event: string | , ...args: any[]): boolean;
    listenerCount(type: string | ): number;
    prependListener(event: string | , listener: Function): this;
    prependOnceListener(event: string | , listener: Function): this;
    eventNames(): (string | )[]
}

declare
export type NodeJS$ReadableStream = {
    readable: boolean,
    read(size?: number): string | Buffer,
    setEncoding(encoding: string): void,
    pause(): NodeJS$ReadableStream,
    resume(): NodeJS$ReadableStream,
    pipe<T>(destination: T, options?: {
        end?: boolean
    }): T,
    unpipe<T>(destination?: T): void,
    unshift(chunk: string): void,
    unshift(chunk: Buffer): void,
    wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream
} & NodeJS$EventEmitter


declare
export type NodeJS$WritableStream = {
    writable: boolean,
    write(buffer: Buffer | string, cb?: Function): boolean,
    write(str: string, encoding?: string, cb?: Function): boolean,
    end(): void,
    end(buffer: Buffer, cb?: Function): void,
    end(str: string, cb?: Function): void,
    end(str: string, encoding?: string, cb?: Function): void
} & NodeJS$EventEmitter


declare
export type NodeJS$ReadWriteStream = {
    pause(): NodeJS$ReadWriteStream,
    resume(): NodeJS$ReadWriteStream
} & NodeJS$ReadableStream & NodeJS$WritableStream


declare
export type NodeJS$Events = {} & NodeJS$EventEmitter


declare
export type NodeJS$Domain = {
    run(fn: Function): void,
    add(emitter: NodeJS$Events): void,
    remove(emitter: NodeJS$Events): void,
    bind(cb: (err: Error, data: any) => any): any,
    intercept(cb: (data: any) => any): any,
    dispose(): void,
    addListener(event: string, listener: Function): this,
    on(event: string, listener: Function): this,
    once(event: string, listener: Function): this,
    removeListener(event: string, listener: Function): this,
    removeAllListeners(event?: string): this
} & NodeJS$Events


declare
export interface NodeJS$MemoryUsage {
    rss: number,
        heapTotal: number,
        heapUsed: number
}

declare
export interface NodeJS$ProcessVersions {
    http_parser: string,
        node: string,
        v8: string,
        ares: string,
        uv: string,
        zlib: string,
        modules: string,
        openssl: string
}

declare
export type NodeJS$Process = {
    stdout: NodeJS$WritableStream,
    stderr: NodeJS$WritableStream,
    stdin: NodeJS$ReadableStream,
    argv: string[],
    argv0: string,
    execArgv: string[],
    execPath: string,
    abort(): void,
    chdir(directory: string): void,
    cwd(): string,
    env: any,
    exit(code?: number): void,
    exitCode: number,
    getgid(): number,
    setgid(id: number): void,
    setgid(id: string): void,
    getuid(): number,
    setuid(id: number): void,
    setuid(id: string): void,
    version: string,
    versions: NodeJS$ProcessVersions,
    config: {
        target_defaults: {
            cflags: any[],
            default_configuration: string,
            defines: string[],
            include_dirs: string[],
            libraries: string[]
        },
        variables: {
            clang: number,
            host_arch: string,
            node_install_npm: boolean,
            node_install_waf: boolean,
            node_prefix: string,
            node_shared_openssl: boolean,
            node_shared_v8: boolean,
            node_shared_zlib: boolean,
            node_use_dtrace: boolean,
            node_use_etw: boolean,
            node_use_openssl: boolean,
            target_arch: string,
            v8_no_strict_aliasing: number,
            v8_use_snapshot: boolean,
            visibility: string
        }
    },
    kill(pid: number, signal?: string | number): void,
    pid: number,
    title: string,
    arch: string,
    platform: string,
    mainModule?: NodeModule,
    memoryUsage(): NodeJS$MemoryUsage,
    nextTick(callback: Function, ...args: any[]): void,
    umask(mask?: number): number,
    uptime(): number,
    hrtime(time?: number[]): number[],
    domain: NodeJS$Domain,
    send(message: any, sendHandle?: any): void,
    disconnect(): void,
    connected: boolean
} & NodeJS$EventEmitter


declare
export interface NodeJS$Global {
    Array: typeof Array,
        ArrayBuffer: typeof ArrayBuffer,
        Boolean: typeof Boolean,
        Buffer: typeof Buffer,
        DataView: typeof DataView,
        Date: typeof Date,
        Error: typeof Error,
        EvalError: typeof EvalError,
        Float32Array: typeof Float32Array,
        Float64Array: typeof Float64Array,
        Function: typeof Function,
        GLOBAL: NodeJS$Global,
        Infinity: typeof Infinity,
        Int16Array: typeof Int16Array,
        Int32Array: typeof Int32Array,
        Int8Array: typeof Int8Array,
        Intl: typeof Intl,
        JSON: typeof JSON,
        Map: MapConstructor,
        Math: typeof Math,
        NaN: typeof NaN,
        Number: typeof Number,
        Object: typeof Object,
        Promise: Function,
        RangeError: typeof RangeError,
        ReferenceError: typeof ReferenceError,
        RegExp: typeof RegExp,
        Set: SetConstructor,
        String: typeof String,
        Symbol: Function,
        SyntaxError: typeof SyntaxError,
        TypeError: typeof TypeError,
        URIError: typeof URIError,
        Uint16Array: typeof Uint16Array,
        Uint32Array: typeof Uint32Array,
        Uint8Array: typeof Uint8Array,
        Uint8ClampedArray: Function,
        WeakMap: WeakMapConstructor,
        WeakSet: WeakSetConstructor,
        clearImmediate: (immediateId: any) => void,
        clearInterval: (intervalId: NodeJS$Timer) => void,
        clearTimeout: (timeoutId: NodeJS$Timer) => void,
        console: typeof console,
        decodeURI: typeof decodeURI,
        decodeURIComponent: typeof decodeURIComponent,
        encodeURI: typeof encodeURI,
        encodeURIComponent: typeof encodeURIComponent,
        escape: (str: string) => string,
        eval: typeof eval,
        global: NodeJS$Global,
        isFinite: typeof isFinite,
        isNaN: typeof isNaN,
        parseFloat: typeof parseFloat,
        parseInt: typeof parseInt,
        process: NodeJS$Process,
        root: NodeJS$Global,
        setImmediate: (callback: (...args: any[]) => void, ...args: any[]) => any,
        setInterval: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS$Timer,
        setTimeout: (callback: (...args: any[]) => void, ms: number, ...args: any[]) => NodeJS$Timer,
        undefined: typeof undefined,
        unescape: (str: string) => string,
        gc: () => void,
        v8debug?: any
}

declare
export interface NodeJS$Timer {
    ref(): void,
        unref(): void
}
declare interface IterableIterator<T>{}
    /**
     * 
     * @deprecated  
     */
declare type NodeBuffer = {
    write(string: string, offset?: number, length?: number, encoding?: string): number,
    toString(encoding?: string, start?: number, end?: number): string,
    toJSON(): {
        type: "Buffer",
        data: any[]
    },
    equals(otherBuffer: Buffer): boolean,
    compare(
        otherBuffer: Buffer,
        targetStart?: number,
        targetEnd?: number,
        sourceStart?: number,
        sourceEnd?: number): number,
    copy(
        targetBuffer: Buffer,
        targetStart?: number,
        sourceStart?: number,
        sourceEnd?: number): number,
    slice(start?: number, end?: number): Buffer,
    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number,
    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number,
    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number,
    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number,
    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number,
    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number,
    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number,
    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number,
    readUInt8(offset: number, noAssert?: boolean): number,
    readUInt16LE(offset: number, noAssert?: boolean): number,
    readUInt16BE(offset: number, noAssert?: boolean): number,
    readUInt32LE(offset: number, noAssert?: boolean): number,
    readUInt32BE(offset: number, noAssert?: boolean): number,
    readInt8(offset: number, noAssert?: boolean): number,
    readInt16LE(offset: number, noAssert?: boolean): number,
    readInt16BE(offset: number, noAssert?: boolean): number,
    readInt32LE(offset: number, noAssert?: boolean): number,
    readInt32BE(offset: number, noAssert?: boolean): number,
    readFloatLE(offset: number, noAssert?: boolean): number,
    readFloatBE(offset: number, noAssert?: boolean): number,
    readDoubleLE(offset: number, noAssert?: boolean): number,
    readDoubleBE(offset: number, noAssert?: boolean): number,
    swap16(): Buffer,
    swap32(): Buffer,
    swap64(): Buffer,
    writeUInt8(value: number, offset: number, noAssert?: boolean): number,
    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number,
    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number,
    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number,
    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number,
    writeInt8(value: number, offset: number, noAssert?: boolean): number,
    writeInt16LE(value: number, offset: number, noAssert?: boolean): number,
    writeInt16BE(value: number, offset: number, noAssert?: boolean): number,
    writeInt32LE(value: number, offset: number, noAssert?: boolean): number,
    writeInt32BE(value: number, offset: number, noAssert?: boolean): number,
    writeFloatLE(value: number, offset: number, noAssert?: boolean): number,
    writeFloatBE(value: number, offset: number, noAssert?: boolean): number,
    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number,
    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number,
    fill(value: any, offset?: number, end?: number): this,
    indexOf(
        value: string | number | Buffer,
        byteOffset?: number,
        encoding?: string): number,
    lastIndexOf(
        value: string | number | Buffer,
        byteOffset?: number,
        encoding?: string): number,
    entries(): IterableIterator<[number, number]>,
    includes(
        value: string | number | Buffer,
        byteOffset?: number,
        encoding?: string): boolean,
    keys(): IterableIterator<number>,
    values(): IterableIterator<number >
} & Uint8Array
declare module 'buffer' {
    declare export var INSPECT_MAX_BYTES: number;
    declare var BuffType: typeof Buffer;
    declare var SlowBuffType: typeof SlowBuffer;
}
declare module 'querystring' {
    declare export interface StringifyOptions {
        encodeURIComponent?: Function
    }
    declare export interface ParseOptions {
        maxKeys?: number,
            decodeURIComponent?: Function
    }
    declare export function stringify<T>(obj: T, sep?: string, eq?: string, options?: StringifyOptions): string
    declare export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any
    declare export function escape(str: string): string
    declare export function unescape(str: string): string
}
declare module 'events' {
    declare export class EventEmitter mixins NodeJS$EventEmitter {
        EventEmitter: NodeJS$EventEmitter;
        listenerCount(emitter: NodeJS$EventEmitter, event: string | ): number;
        defaultMaxListeners: number;
        addListener(event: string | , listener: Function): this;
        on(event: string | , listener: Function): this;
        once(event: string | , listener: Function): this;
        prependListener(event: string | , listener: Function): this;
        prependOnceListener(event: string | , listener: Function): this;
        removeListener(event: string | , listener: Function): this;
        removeAllListeners(event?: string | ): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(event: string | ): Function[];
        emit(event: string | , ...args: any[]): boolean;
        eventNames(): (string | )[];
        listenerCount(type: string | ): number
    }
}
declare module 'http' {



    declare export interface RequestOptions {
        protocol?: string,
            host?: string,
            hostname?: string,
            family?: number,
            port?: number,
            localAddress?: string,
            socketPath?: string,
            method?: string,
            path?: string,
            headers?: {
                [key: string]: any
            },
            auth?: string,
            agent?: Agent | boolean
    }
    declare export type Server = {
        setTimeout(msecs: number, callback: Function): void,
        maxHeadersCount: number,
        timeout: number,
        listening: boolean
    }

    /**
     * 
     * @deprecated  Use IncomingMessage
     */
    declare export type ServerRequest = {
        connection: net.Socket
    } & IncomingMessage

    declare export type ServerResponse = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        writeContinue(): void,
        writeHead(statusCode: number, reasonPhrase?: string, headers?: any): void,
        writeHead(statusCode: number, headers?: any): void,
        statusCode: number,
        statusMessage: string,
        headersSent: boolean,
        setHeader(name: string, value: string | string[]): void,
        setTimeout(msecs: number, callback: Function): ServerResponse,
        sendDate: boolean,
        getHeader(name: string): string,
        removeHeader(name: string): void,
        write(chunk: any, encoding?: string): any,
        addTrailers(headers: any): void,
        finished: boolean,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void
    }
    declare export type ClientRequest = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        write(chunk: any, encoding?: string): void,
        abort(): void,
        setTimeout(timeout: number, callback?: Function): void,
        setNoDelay(noDelay?: boolean): void,
        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void,
        setHeader(name: string, value: string | string[]): void,
        getHeader(name: string): string,
        removeHeader(name: string): void,
        addTrailers(headers: any): void,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void
    }
    declare export type IncomingMessage = {
        httpVersion: string,
        httpVersionMajor: number,
        httpVersionMinor: number,
        connection: net.Socket,
        headers: any,
        rawHeaders: string[],
        trailers: any,
        rawTrailers: any,
        setTimeout(msecs: number, callback: Function): NodeJS$Timer,

        /**
         * Only valid for request obtained from http.Server.
         */
        method?: string,

        /**
         * Only valid for request obtained from http.Server.
         */
        url?: string,

        /**
         * Only valid for response obtained from http.ClientRequest.
         */
        statusCode?: number,

        /**
         * Only valid for response obtained from http.ClientRequest.
         */
        statusMessage?: string,
        socket: net.Socket,
        destroy(error?: Error): void
    }

    /**
     * 
     * @deprecated  Use IncomingMessage
     */
    declare export type ClientResponse = {} & IncomingMessage

    declare export interface AgentOptions {

        /**
         * Keep sockets around in a pool to be used by other requests in the future. Default = false
         */
        keepAlive?: boolean,

            /**
             * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
             * Only relevant if keepAlive is set to true.
             */
            keepAliveMsecs?: number,

            /**
             * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity
             */
            maxSockets?: number,

            /**
             * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.
             */
            maxFreeSockets?: number
    }
    declare export class Agent {
        maxSockets: number;
        sockets: any;
        requests: any;
        constructor(opts?: AgentOptions): this;

        /**
         * Destroy any sockets that are currently in use by the agent.
         * It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,
        then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,
        sockets may hang open for quite a long time before the server terminates them.
        */
        destroy(): void
    }
    declare export var METHODS: string[];
    declare export var STATUS_CODES: {
        [errorCode: number]: string,
        [errorCode: string]: string
    };
    declare export function createServer(
        requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server
    declare export function createClient(port?: number, host?: string): any
    declare export function request(
        options: RequestOptions,
        callback?: (res: IncomingMessage) => void): ClientRequest
    declare export function get(options: any, callback?: (res: IncomingMessage) => void): ClientRequest
    declare export var globalAgent: Agent;
}
declare module 'cluster' {



    declare export interface ClusterSettings {
        execArgv?: string[],
            exec?: string,
            args?: string[],
            silent?: boolean,
            stdio?: any[],
            uid?: number,
            gid?: number
    }
    declare export interface ClusterSetupMasterSettings {
        exec?: string,
            args?: string[],
            silent?: boolean,
            stdio?: any[]
    }
    declare export interface Address {
        address: string,
            port: number,
            addressType: number | "udp4" | "udp6"
    }
    declare export class Worker mixins events.EventEmitter {
        id: string;
        process: child.ChildProcess;
        suicide: boolean;
        send(message: any, sendHandle?: any): boolean;
        kill(signal?: string): void;
        destroy(signal?: string): void;
        disconnect(): void;
        isConnected(): boolean;
        isDead(): boolean;
        exitedAfterDisconnect: boolean;

        /**
         * events.EventEmitter
         *    1. disconnect
           2. error
           3. exit
           4. listening
           5. message
           6. online
        */
        addListener(event: string, listener: Function): this;
        addListener(event: "disconnect", listener: () => void): this;
        addListener(event: "error", listener: (code: number, signal: string) => void): this;
        addListener(event: "exit", listener: (code: number, signal: string) => void): this;
        addListener(event: "listening", listener: (address: Address) => void): this;
        addListener(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): this;
        addListener(event: "online", listener: () => void): this;
        emit(event: string, listener: Function): boolean;
        emit(event: "disconnect", listener: () => void): boolean;
        emit(event: "error", listener: (code: number, signal: string) => void): boolean;
        emit(event: "exit", listener: (code: number, signal: string) => void): boolean;
        emit(event: "listening", listener: (address: Address) => void): boolean;
        emit(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): boolean;
        emit(event: "online", listener: () => void): boolean;
        on(event: string, listener: Function): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "error", listener: (code: number, signal: string) => void): this;
        on(event: "exit", listener: (code: number, signal: string) => void): this;
        on(event: "listening", listener: (address: Address) => void): this;
        on(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): this;
        on(event: "online", listener: () => void): this;
        once(event: string, listener: Function): this;
        once(event: "disconnect", listener: () => void): this;
        once(event: "error", listener: (code: number, signal: string) => void): this;
        once(event: "exit", listener: (code: number, signal: string) => void): this;
        once(event: "listening", listener: (address: Address) => void): this;
        once(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): this;
        once(event: "online", listener: () => void): this;
        prependListener(event: string, listener: Function): this;
        prependListener(event: "disconnect", listener: () => void): this;
        prependListener(event: "error", listener: (code: number, signal: string) => void): this;
        prependListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependListener(event: "listening", listener: (address: Address) => void): this;
        prependListener(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): this;
        prependListener(event: "online", listener: () => void): this;
        prependOnceListener(event: string, listener: Function): this;
        prependOnceListener(event: "disconnect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (code: number, signal: string) => void): this;
        prependOnceListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependOnceListener(event: "listening", listener: (address: Address) => void): this;
        prependOnceListener(
            event: "message",
            listener: (message: any, handle: net.Socket | net.Server) => void): this;
        prependOnceListener(event: "online", listener: () => void): this
    }
    declare export type Cluster = {
        Worker: Worker,
        disconnect(callback?: Function): void,
        fork(env?: any): Worker,
        isMaster: boolean,
        isWorker: boolean,
        settings: ClusterSettings,
        setupMaster(settings?: ClusterSetupMasterSettings): void,
        worker: Worker,
        workers: {
            [index: string]: Worker
        },

        /**
         * events.EventEmitter
         *    1. disconnect
           2. exit
           3. fork
           4. listening
           5. message
           6. online
           7. setup
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "disconnect", listener: (worker: Worker) => void): this,
        addListener(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): this,
        addListener(event: "fork", listener: (worker: Worker) => void): this,
        addListener(event: "listening", listener: (worker: Worker, address: Address) => void): this,
        addListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this,
        addListener(event: "online", listener: (worker: Worker) => void): this,
        addListener(event: "setup", listener: (settings: any) => void): this,
        emit(event: string, listener: Function): boolean,
        emit(event: "disconnect", listener: (worker: Worker) => void): boolean,
        emit(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): boolean,
        emit(event: "fork", listener: (worker: Worker) => void): boolean,
        emit(
            event: "listening",
            listener: (worker: Worker, address: Address) => void): boolean,
        emit(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): boolean,
        emit(event: "online", listener: (worker: Worker) => void): boolean,
        emit(event: "setup", listener: (settings: any) => void): boolean,
        on(event: string, listener: Function): this,
        on(event: "disconnect", listener: (worker: Worker) => void): this,
        on(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): this,
        on(event: "fork", listener: (worker: Worker) => void): this,
        on(event: "listening", listener: (worker: Worker, address: Address) => void): this,
        on(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this,
        on(event: "online", listener: (worker: Worker) => void): this,
        on(event: "setup", listener: (settings: any) => void): this,
        once(event: string, listener: Function): this,
        once(event: "disconnect", listener: (worker: Worker) => void): this,
        once(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): this,
        once(event: "fork", listener: (worker: Worker) => void): this,
        once(event: "listening", listener: (worker: Worker, address: Address) => void): this,
        once(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this,
        once(event: "online", listener: (worker: Worker) => void): this,
        once(event: "setup", listener: (settings: any) => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "disconnect", listener: (worker: Worker) => void): this,
        prependListener(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): this,
        prependListener(event: "fork", listener: (worker: Worker) => void): this,
        prependListener(event: "listening", listener: (worker: Worker, address: Address) => void): this,
        prependListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this,
        prependListener(event: "online", listener: (worker: Worker) => void): this,
        prependListener(event: "setup", listener: (settings: any) => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "disconnect", listener: (worker: Worker) => void): this,
        prependOnceListener(
            event: "exit",
            listener: (worker: Worker, code: number, signal: string) => void): this,
        prependOnceListener(event: "fork", listener: (worker: Worker) => void): this,
        prependOnceListener(event: "listening", listener: (worker: Worker, address: Address) => void): this,
        prependOnceListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this,
        prependOnceListener(event: "online", listener: (worker: Worker) => void): this,
        prependOnceListener(event: "setup", listener: (settings: any) => void): this
    }
    declare export function disconnect(callback?: Function): void
    declare export function fork(env?: any): Worker
    declare export var isMaster: boolean;
    declare export var isWorker: boolean;
    declare export var settings: ClusterSettings;
    declare export function setupMaster(settings?: ClusterSetupMasterSettings): void
    declare export var worker: Worker;
    declare export var workers: {
        [index: string]: Worker
    };

    /**
     * events.EventEmitter
     *    1. disconnect
       2. exit
       3. fork
       4. listening
       5. message
       6. online
       7. setup
    */
    declare export function addListener(event: string, listener: Function): Cluster
    declare export function emit(event: string, listener: Function): boolean
    declare export function on(event: string, listener: Function): Cluster
    declare export function once(event: string, listener: Function): Cluster
    declare export function removeListener(event: string, listener: Function): Cluster
    declare export function removeAllListeners(event?: string): Cluster
    declare export function setMaxListeners(n: number): Cluster
    declare export function getMaxListeners(): number
    declare export function listeners(event: string): Function[]
    declare export function listenerCount(type: string): number
    declare export function prependListener(event: string, listener: Function): Cluster
    declare export function prependOnceListener(event: string, listener: Function): Cluster
    declare export function eventNames(): string[]
}
declare module 'zlib' {

    declare export interface ZlibOptions {
        chunkSize?: number,
            windowBits?: number,
            level?: number,
            memLevel?: number,
            strategy?: number,
            dictionary?: any
    }
    declare export type Gzip = {}
    declare export type Gunzip = {}
    declare export type Deflate = {}
    declare export type Inflate = {}
    declare export type DeflateRaw = {}
    declare export type InflateRaw = {}
    declare export type Unzip = {}
    declare export function createGzip(options?: ZlibOptions): Gzip
    declare export function createGunzip(options?: ZlibOptions): Gunzip
    declare export function createDeflate(options?: ZlibOptions): Deflate
    declare export function createInflate(options?: ZlibOptions): Inflate
    declare export function createDeflateRaw(options?: ZlibOptions): DeflateRaw
    declare export function createInflateRaw(options?: ZlibOptions): InflateRaw
    declare export function createUnzip(options?: ZlibOptions): Unzip
    declare export function deflate(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function deflateSync(buf: Buffer, options?: ZlibOptions): any
    declare export function deflateRaw(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function deflateRawSync(buf: Buffer, options?: ZlibOptions): any
    declare export function gzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function gzipSync(buf: Buffer, options?: ZlibOptions): any
    declare export function gunzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function gunzipSync(buf: Buffer, options?: ZlibOptions): any
    declare export function inflate(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function inflateSync(buf: Buffer, options?: ZlibOptions): any
    declare export function inflateRaw(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function inflateRawSync(buf: Buffer, options?: ZlibOptions): any
    declare export function unzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function unzipSync(buf: Buffer, options?: ZlibOptions): any
    declare export var Z_NO_FLUSH: number;
    declare export var Z_PARTIAL_FLUSH: number;
    declare export var Z_SYNC_FLUSH: number;
    declare export var Z_FULL_FLUSH: number;
    declare export var Z_FINISH: number;
    declare export var Z_BLOCK: number;
    declare export var Z_TREES: number;
    declare export var Z_OK: number;
    declare export var Z_STREAM_END: number;
    declare export var Z_NEED_DICT: number;
    declare export var Z_ERRNO: number;
    declare export var Z_STREAM_ERROR: number;
    declare export var Z_DATA_ERROR: number;
    declare export var Z_MEM_ERROR: number;
    declare export var Z_BUF_ERROR: number;
    declare export var Z_VERSION_ERROR: number;
    declare export var Z_NO_COMPRESSION: number;
    declare export var Z_BEST_SPEED: number;
    declare export var Z_BEST_COMPRESSION: number;
    declare export var Z_DEFAULT_COMPRESSION: number;
    declare export var Z_FILTERED: number;
    declare export var Z_HUFFMAN_ONLY: number;
    declare export var Z_RLE: number;
    declare export var Z_FIXED: number;
    declare export var Z_DEFAULT_STRATEGY: number;
    declare export var Z_BINARY: number;
    declare export var Z_TEXT: number;
    declare export var Z_ASCII: number;
    declare export var Z_UNKNOWN: number;
    declare export var Z_DEFLATED: number;
    declare export var Z_NULL: number;
}
declare module 'os' {
    declare export interface CpuInfo {
        model: string,
            speed: number,
            times: {
                user: number,
                nice: number,
                sys: number,
                idle: number,
                irq: number
            }
    }
    declare export interface NetworkInterfaceInfo {
        address: string,
            netmask: string,
            family: string,
            mac: string,
            internal: boolean
    }
    declare export function hostname(): string
    declare export function loadavg(): number[]
    declare export function uptime(): number
    declare export function freemem(): number
    declare export function totalmem(): number
    declare export function cpus(): CpuInfo[]
    declare export function type(): string
    declare export function release(): string
    declare export function networkInterfaces(): {
        [index: string]: NetworkInterfaceInfo[]
    }
    declare export function homedir(): string
    declare export function userInfo(
        options?: {
            encoding: string
        }): {
        username: string,
        uid: number,
        gid: number,
        shell: any,
        homedir: string
    }
    declare export var constants: {
        UV_UDP_REUSEADDR: number,
        errno: {
            SIGHUP: number,
            SIGINT: number,
            SIGQUIT: number,
            SIGILL: number,
            SIGTRAP: number,
            SIGABRT: number,
            SIGIOT: number,
            SIGBUS: number,
            SIGFPE: number,
            SIGKILL: number,
            SIGUSR1: number,
            SIGSEGV: number,
            SIGUSR2: number,
            SIGPIPE: number,
            SIGALRM: number,
            SIGTERM: number,
            SIGCHLD: number,
            SIGSTKFLT: number,
            SIGCONT: number,
            SIGSTOP: number,
            SIGTSTP: number,
            SIGTTIN: number,
            SIGTTOU: number,
            SIGURG: number,
            SIGXCPU: number,
            SIGXFSZ: number,
            SIGVTALRM: number,
            SIGPROF: number,
            SIGWINCH: number,
            SIGIO: number,
            SIGPOLL: number,
            SIGPWR: number,
            SIGSYS: number,
            SIGUNUSED: number
        },
        signals: {
            E2BIG: number,
            EACCES: number,
            EADDRINUSE: number,
            EADDRNOTAVAIL: number,
            EAFNOSUPPORT: number,
            EAGAIN: number,
            EALREADY: number,
            EBADF: number,
            EBADMSG: number,
            EBUSY: number,
            ECANCELED: number,
            ECHILD: number,
            ECONNABORTED: number,
            ECONNREFUSED: number,
            ECONNRESET: number,
            EDEADLK: number,
            EDESTADDRREQ: number,
            EDOM: number,
            EDQUOT: number,
            EEXIST: number,
            EFAULT: number,
            EFBIG: number,
            EHOSTUNREACH: number,
            EIDRM: number,
            EILSEQ: number,
            EINPROGRESS: number,
            EINTR: number,
            EINVAL: number,
            EIO: number,
            EISCONN: number,
            EISDIR: number,
            ELOOP: number,
            EMFILE: number,
            EMLINK: number,
            EMSGSIZE: number,
            EMULTIHOP: number,
            ENAMETOOLONG: number,
            ENETDOWN: number,
            ENETRESET: number,
            ENETUNREACH: number,
            ENFILE: number,
            ENOBUFS: number,
            ENODATA: number,
            ENODEV: number,
            ENOENT: number,
            ENOEXEC: number,
            ENOLCK: number,
            ENOLINK: number,
            ENOMEM: number,
            ENOMSG: number,
            ENOPROTOOPT: number,
            ENOSPC: number,
            ENOSR: number,
            ENOSTR: number,
            ENOSYS: number,
            ENOTCONN: number,
            ENOTDIR: number,
            ENOTEMPTY: number,
            ENOTSOCK: number,
            ENOTSUP: number,
            ENOTTY: number,
            ENXIO: number,
            EOPNOTSUPP: number,
            EOVERFLOW: number,
            EPERM: number,
            EPIPE: number,
            EPROTO: number,
            EPROTONOSUPPORT: number,
            EPROTOTYPE: number,
            ERANGE: number,
            EROFS: number,
            ESPIPE: number,
            ESRCH: number,
            ESTALE: number,
            ETIME: number,
            ETIMEDOUT: number,
            ETXTBSY: number,
            EWOULDBLOCK: number,
            EXDEV: number
        }
    };
    declare export function arch(): string
    declare export function platform(): string
    declare export function tmpdir(): string
    declare export var EOL: string;
    declare export function endianness(): "BE" | "LE"
}
declare module 'https' {



    declare export interface ServerOptions {
        pfx?: any,
            key?: any,
            passphrase?: string,
            cert?: any,
            ca?: any,
            crl?: any,
            ciphers?: string,
            honorCipherOrder?: boolean,
            requestCert?: boolean,
            rejectUnauthorized?: boolean,
            NPNProtocols?: any,
            SNICallback?: (servername: string, cb: (err: Error, ctx: tls.SecureContext) => any) => any
    }
    declare export interface RequestOptions {
        protocol?: string,
            host?: string,
            hostname?: string,
            family?: number,
            port?: number,
            localAddress?: string,
            socketPath?: string,
            method?: string,
            path?: string,
            headers?: {
                [key: string]: any
            },
            auth?: string,
            agent?: Agent | boolean
    }
    declare export type Agent = {}
    declare export interface AgentOptions {

        /**
         * Keep sockets around in a pool to be used by other requests in the future. Default = false
         */
        keepAlive?: boolean,

            /**
             * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
             * Only relevant if keepAlive is set to true.
             */
            keepAliveMsecs?: number,

            /**
             * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity
             */
            maxSockets?: number,

            /**
             * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.
             */
            maxFreeSockets?: number
    }
    declare export var Agent: {
        new(options?: AgentOptions): Agent
    };
    declare export type Server = {
        setTimeout(msecs: number, callback: Function): void,
        maxHeadersCount: number,
        timeout: number,
        listening: boolean
    }
    declare export function createServer(
        requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server
    declare export function request(
        options: RequestOptions,
        callback?: (res: IncomingMessage) => void): ClientRequest
    declare export function get(options: any, callback?: (res: IncomingMessage) => void): ClientRequest
    declare export var globalAgent: Agent;
}
declare module 'punycode' {
    declare export function decode(string: string): string
    declare export function encode(string: string): string
    declare export function toUnicode(domain: string): string
    declare export function toASCII(domain: string): string
    declare export var ucs2: ucs2;
    declare interface ucs2 {
        decode(string: string): number[],
            encode(codePoints: number[]): string
    }
    declare export var version: any;
}
declare module 'repl' {


    declare export interface ReplOptions {
        prompt?: string,
            input?: NodeJS$ReadableStream,
            output?: NodeJS$WritableStream,
            terminal?: boolean,
            eval?: Function,
            useColors?: boolean,
            useGlobal?: boolean,
            ignoreUndefined?: boolean,
            writer?: Function,
            completer?: Function,
            replMode?: any,
            breakEvalOnSigint?: any
    }
    declare export type REPLServer = {
        defineCommand(keyword: string, cmd: Function | {
            help: string,
            action: Function
        }): void,
        displayPrompt(preserveCursor?: boolean): void,

        /**
         * events.EventEmitter
         * 1. exit
        2. reset
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "exit", listener: () => void): this,
        addListener(event: "reset", listener: Function): this,
        emit(event: string, ...args: any[]): boolean,
        emit(event: "exit"): boolean,
        emit(event: "reset", context: any): boolean,
        on(event: string, listener: Function): this,
        on(event: "exit", listener: () => void): this,
        on(event: "reset", listener: Function): this,
        once(event: string, listener: Function): this,
        once(event: "exit", listener: () => void): this,
        once(event: "reset", listener: Function): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "exit", listener: () => void): this,
        prependListener(event: "reset", listener: Function): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "exit", listener: () => void): this,
        prependOnceListener(event: "reset", listener: Function): this
    }
    declare export function start(options: ReplOptions): REPLServer
}
declare module 'readline' {


    declare export interface Key {
        sequence?: string,
            name?: string,
            ctrl?: boolean,
            meta?: boolean,
            shift?: boolean
    }
    declare export type ReadLine = {
        setPrompt(prompt: string): void,
        prompt(preserveCursor?: boolean): void,
        question(query: string, callback: (answer: string) => void): void,
        pause(): ReadLine,
        resume(): ReadLine,
        close(): void,
        write(data: string | Buffer, key?: Key): void,

        /**
         * events.EventEmitter
         * 1. close
        2. line
        3. pause
        4. resume
        5. SIGCONT
        6. SIGINT
        7. SIGTSTP
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "close", listener: () => void): this,
        addListener(event: "line", listener: (input: any) => void): this,
        addListener(event: "pause", listener: () => void): this,
        addListener(event: "resume", listener: () => void): this,
        addListener(event: "SIGCONT", listener: () => void): this,
        addListener(event: "SIGINT", listener: () => void): this,
        addListener(event: "SIGTSTP", listener: () => void): this,
        emit(event: string, ...args: any[]): boolean,
        emit(event: "close"): boolean,
        emit(event: "line", input: any): boolean,
        emit(event: "pause"): boolean,
        emit(event: "resume"): boolean,
        emit(event: "SIGCONT"): boolean,
        emit(event: "SIGINT"): boolean,
        emit(event: "SIGTSTP"): boolean,
        on(event: string, listener: Function): this,
        on(event: "close", listener: () => void): this,
        on(event: "line", listener: (input: any) => void): this,
        on(event: "pause", listener: () => void): this,
        on(event: "resume", listener: () => void): this,
        on(event: "SIGCONT", listener: () => void): this,
        on(event: "SIGINT", listener: () => void): this,
        on(event: "SIGTSTP", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "close", listener: () => void): this,
        once(event: "line", listener: (input: any) => void): this,
        once(event: "pause", listener: () => void): this,
        once(event: "resume", listener: () => void): this,
        once(event: "SIGCONT", listener: () => void): this,
        once(event: "SIGINT", listener: () => void): this,
        once(event: "SIGTSTP", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "close", listener: () => void): this,
        prependListener(event: "line", listener: (input: any) => void): this,
        prependListener(event: "pause", listener: () => void): this,
        prependListener(event: "resume", listener: () => void): this,
        prependListener(event: "SIGCONT", listener: () => void): this,
        prependListener(event: "SIGINT", listener: () => void): this,
        prependListener(event: "SIGTSTP", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "close", listener: () => void): this,
        prependOnceListener(event: "line", listener: (input: any) => void): this,
        prependOnceListener(event: "pause", listener: () => void): this,
        prependOnceListener(event: "resume", listener: () => void): this,
        prependOnceListener(event: "SIGCONT", listener: () => void): this,
        prependOnceListener(event: "SIGINT", listener: () => void): this,
        prependOnceListener(event: "SIGTSTP", listener: () => void): this
    }
    declare export interface Completer {
        (line: string): CompleterResult,
        (line: string, callback: (err: any, result: CompleterResult) => void): any
    }
    declare export interface CompleterResult {
        completions: string[],
            line: string
    }
    declare export interface ReadLineOptions {
        input: NodeJS$ReadableStream,
            output?: NodeJS$WritableStream,
            completer?: Completer,
            terminal?: boolean,
            historySize?: number
    }
    declare export function createInterface(
        input: NodeJS$ReadableStream,
        output?: NodeJS$WritableStream,
        completer?: Completer,
        terminal?: boolean): ReadLine
    declare export function cursorTo(stream: NodeJS$WritableStream, x: number, y: number): void
    declare export function moveCursor(stream: NodeJS$WritableStream, dx: number | string, dy: number | string): void
    declare export function clearLine(stream: NodeJS$WritableStream, dir: number): void
    declare export function clearScreenDown(stream: NodeJS$WritableStream): void
}
declare module 'vm' {
    declare export interface Context {}
    declare export interface ScriptOptions {
        filename?: string,
            lineOffset?: number,
            columnOffset?: number,
            displayErrors?: boolean,
            timeout?: number,
            cachedData?: Buffer,
            produceCachedData?: boolean
    }
    declare export interface RunningScriptOptions {
        filename?: string,
            lineOffset?: number,
            columnOffset?: number,
            displayErrors?: boolean,
            timeout?: number
    }
    declare export class Script {
        constructor(code: string, options?: ScriptOptions): this;
        runInContext(contextifiedSandbox: Context, options?: RunningScriptOptions): any;
        runInNewContext(sandbox?: Context, options?: RunningScriptOptions): any;
        runInThisContext(options?: RunningScriptOptions): any
    }
    declare export function createContext(sandbox?: Context): Context
    declare export function isContext(sandbox: Context): boolean
    declare export function runInContext(
        code: string,
        contextifiedSandbox: Context,
        options?: RunningScriptOptions): any
    declare export function runInDebugContext(code: string): any
    declare export function runInNewContext(code: string, sandbox?: Context, options?: RunningScriptOptions): any
    declare export function runInThisContext(code: string, options?: RunningScriptOptions): any
}
declare module 'child_process' {



    declare export type ChildProcess = {
        stdin: stream.Writable,
        stdout: stream.Readable,
        stderr: stream.Readable,
        stdio: [stream.Writable, stream.Readable, stream.Readable],
        pid: number,
        kill(signal?: string): void,
        send(message: any, sendHandle?: any): boolean,
        connected: boolean,
        disconnect(): void,
        unref(): void,
        ref(): void,

        /**
         * events.EventEmitter
         * 1. close
        2. disconnet
        3. error
        4. exit
        5. message
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "close", listener: (code: number, signal: string) => void): this,
        addListener(event: "disconnet", listener: () => void): this,
        addListener(event: "error", listener: (err: Error) => void): this,
        addListener(event: "exit", listener: (code: number, signal: string) => void): this,
        addListener(
            event: "message",
            listener: (message: any, sendHandle: net.Socket | net.Server) => void): this,
        emit(event: string, ...args: any[]): boolean,
        emit(event: "close", code: number, signal: string): boolean,
        emit(event: "disconnet"): boolean,
        emit(event: "error", err: Error): boolean,
        emit(event: "exit", code: number, signal: string): boolean,
        emit(event: "message", message: any, sendHandle: net.Socket | net.Server): boolean,
        on(event: string, listener: Function): this,
        on(event: "close", listener: (code: number, signal: string) => void): this,
        on(event: "disconnet", listener: () => void): this,
        on(event: "error", listener: (err: Error) => void): this,
        on(event: "exit", listener: (code: number, signal: string) => void): this,
        on(
            event: "message",
            listener: (message: any, sendHandle: net.Socket | net.Server) => void): this,
        once(event: string, listener: Function): this,
        once(event: "close", listener: (code: number, signal: string) => void): this,
        once(event: "disconnet", listener: () => void): this,
        once(event: "error", listener: (err: Error) => void): this,
        once(event: "exit", listener: (code: number, signal: string) => void): this,
        once(
            event: "message",
            listener: (message: any, sendHandle: net.Socket | net.Server) => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "close", listener: (code: number, signal: string) => void): this,
        prependListener(event: "disconnet", listener: () => void): this,
        prependListener(event: "error", listener: (err: Error) => void): this,
        prependListener(event: "exit", listener: (code: number, signal: string) => void): this,
        prependListener(
            event: "message",
            listener: (message: any, sendHandle: net.Socket | net.Server) => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "close", listener: (code: number, signal: string) => void): this,
        prependOnceListener(event: "disconnet", listener: () => void): this,
        prependOnceListener(event: "error", listener: (err: Error) => void): this,
        prependOnceListener(event: "exit", listener: (code: number, signal: string) => void): this,
        prependOnceListener(
            event: "message",
            listener: (message: any, sendHandle: net.Socket | net.Server) => void): this
    }
    declare export interface SpawnOptions {
        cwd?: string,
            env?: any,
            stdio?: any,
            detached?: boolean,
            uid?: number,
            gid?: number,
            shell?: boolean | string
    }
    declare export function spawn(command: string, args?: string[], options?: SpawnOptions): ChildProcess
    declare export interface ExecOptions {
        cwd?: string,
            env?: any,
            shell?: string,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string,
            uid?: number,
            gid?: number
    }
    declare export type ExecOptionsWithStringEncoding = {
        encoding: BufferEncoding
    } & ExecOptions

    declare export type ExecOptionsWithBufferEncoding = {
        encoding: string
    } & ExecOptions

    declare export function exec(
        command: string,
        callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess
    declare export interface ExecFileOptions {
        cwd?: string,
            env?: any,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string,
            uid?: number,
            gid?: number
    }
    declare export type ExecFileOptionsWithStringEncoding = {
        encoding: BufferEncoding
    } & ExecFileOptions

    declare export type ExecFileOptionsWithBufferEncoding = {
        encoding: string
    } & ExecFileOptions

    declare export function execFile(
        file: string,
        callback?: (error: Error, stdout: string, stderr: string) => void): ChildProcess
    declare export interface ForkOptions {
        cwd?: string,
            env?: any,
            execPath?: string,
            execArgv?: string[],
            silent?: boolean,
            uid?: number,
            gid?: number
    }
    declare export function fork(env?: any): Worker
    declare export interface SpawnSyncOptions {
        cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            uid?: number,
            gid?: number,
            timeout?: number,
            killSignal?: string,
            maxBuffer?: number,
            encoding?: string,
            shell?: boolean | string
    }
    declare export type SpawnSyncOptionsWithStringEncoding = {
        encoding: BufferEncoding
    } & SpawnSyncOptions

    declare export type SpawnSyncOptionsWithBufferEncoding = {
        encoding: string
    } & SpawnSyncOptions

    declare export interface SpawnSyncReturns<T>{
        pid: number,
        output: string[],
        stdout: T,
        stderr: T,
        status: number,
        signal: string,
        error: Error
    }
    declare export function spawnSync(command: string): SpawnSyncReturns<Buffer >
        declare export interface ExecSyncOptions {
        cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            shell?: string,
            uid?: number,
            gid?: number,
            timeout?: number,
            killSignal?: string,
            maxBuffer?: number,
            encoding?: string
    }
    declare export type ExecSyncOptionsWithStringEncoding = {
        encoding: BufferEncoding
    } & ExecSyncOptions

    declare export type ExecSyncOptionsWithBufferEncoding = {
        encoding: string
    } & ExecSyncOptions

    declare export function execSync(command: string): Buffer
    declare export interface ExecFileSyncOptions {
        cwd?: string,
            input?: string | Buffer,
            stdio?: any,
            env?: any,
            uid?: number,
            gid?: number,
            timeout?: number,
            killSignal?: string,
            maxBuffer?: number,
            encoding?: string
    }
    declare export type ExecFileSyncOptionsWithStringEncoding = {
        encoding: BufferEncoding
    } & ExecFileSyncOptions

    declare export type ExecFileSyncOptionsWithBufferEncoding = {
        encoding: string
    } & ExecFileSyncOptions

    declare export function execFileSync(command: string): Buffer
}
declare module 'url' {
    declare export interface Url {
        href?: string,
            protocol?: string,
            auth?: string,
            hostname?: string,
            port?: string,
            host?: string,
            pathname?: string,
            search?: string,
            query?: string | any,
            slashes?: boolean,
            hash?: string,
            path?: string
    }
    declare export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any
    declare export function format(url: Url): string
    declare export function resolve(from: string, to: string): string
}
declare module 'dns' {
    declare export interface MxRecord {
        exchange: string,
            priority: number
    }
    declare export function lookup(
        domain: string,
        family: number,
        callback: (err: Error, address: string, family: number) => void): string
    declare export function resolve(from: string, to: string): string
    declare export function resolve4(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolve6(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveMx(
        domain: string,
        callback: (err: Error, addresses: MxRecord[]) => void): string[]
    declare export function resolveTxt(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveSrv(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveNs(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveCname(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function reverse(ip: string, callback: (err: Error, domains: string[]) => void): string[]
    declare export function setServers(servers: string[]): void
    declare export var NODATA: string;
    declare export var FORMERR: string;
    declare export var SERVFAIL: string;
    declare export var NOTFOUND: string;
    declare export var NOTIMP: string;
    declare export var REFUSED: string;
    declare export var BADQUERY: string;
    declare export var BADNAME: string;
    declare export var BADFAMILY: string;
    declare export var BADRESP: string;
    declare export var CONNREFUSED: string;
    declare export var TIMEOUT: string;
    declare export var EOF: string;
    declare export var FILE: string;
    declare export var NOMEM: string;
    declare export var DESTRUCTION: string;
    declare export var BADSTR: string;
    declare export var BADFLAGS: string;
    declare export var NONAME: string;
    declare export var BADHINTS: string;
    declare export var NOTINITIALIZED: string;
    declare export var LOADIPHLPAPI: string;
    declare export var ADDRGETNETWORKPARAMS: string;
    declare export var CANCELLED: string;
}
declare module 'net' {


    declare export type Socket = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        connect(port: number, host?: string, connectionListener?: Function): void,
        connect(path: string, connectionListener?: Function): void,
        bufferSize: number,
        setEncoding(encoding?: string): void,
        write(data: any, encoding?: string, callback?: Function): void,
        destroy(): void,
        pause(): Socket,
        resume(): Socket,
        setTimeout(timeout: number, callback?: Function): void,
        setNoDelay(noDelay?: boolean): void,
        setKeepAlive(enable?: boolean, initialDelay?: number): void,
        address(): {
            port: number,
            family: string,
            address: string
        },
        unref(): void,
        ref(): void,
        remoteAddress: string,
        remoteFamily: string,
        remotePort: number,
        localAddress: string,
        localPort: number,
        bytesRead: number,
        bytesWritten: number,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void,

        /**
         * events.EventEmitter
         *    1. close
           2. connect
           3. data
           4. drain
           5. end
           6. error
           7. lookup
           8. timeout
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "close", listener: (had_error: boolean) => void): this,
        addListener(event: "connect", listener: () => void): this,
        addListener(event: "data", listener: (data: Buffer) => void): this,
        addListener(event: "drain", listener: () => void): this,
        addListener(event: "end", listener: () => void): this,
        addListener(event: "error", listener: (err: Error) => void): this,
        addListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        addListener(event: "timeout", listener: () => void): this,
        emit(event: string, ...args: any[]): boolean,
        emit(event: "close", had_error: boolean): boolean,
        emit(event: "connect"): boolean,
        emit(event: "data", data: Buffer): boolean,
        emit(event: "drain"): boolean,
        emit(event: "end"): boolean,
        emit(event: "error", err: Error): boolean,
        emit(
            event: "lookup",
            err: Error,
            address: string,
            family: string | number,
            host: string): boolean,
        emit(event: "timeout"): boolean,
        on(event: string, listener: Function): this,
        on(event: "close", listener: (had_error: boolean) => void): this,
        on(event: "connect", listener: () => void): this,
        on(event: "data", listener: (data: Buffer) => void): this,
        on(event: "drain", listener: () => void): this,
        on(event: "end", listener: () => void): this,
        on(event: "error", listener: (err: Error) => void): this,
        on(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        on(event: "timeout", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "close", listener: (had_error: boolean) => void): this,
        once(event: "connect", listener: () => void): this,
        once(event: "data", listener: (data: Buffer) => void): this,
        once(event: "drain", listener: () => void): this,
        once(event: "end", listener: () => void): this,
        once(event: "error", listener: (err: Error) => void): this,
        once(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        once(event: "timeout", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "close", listener: (had_error: boolean) => void): this,
        prependListener(event: "connect", listener: () => void): this,
        prependListener(event: "data", listener: (data: Buffer) => void): this,
        prependListener(event: "drain", listener: () => void): this,
        prependListener(event: "end", listener: () => void): this,
        prependListener(event: "error", listener: (err: Error) => void): this,
        prependListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        prependListener(event: "timeout", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "close", listener: (had_error: boolean) => void): this,
        prependOnceListener(event: "connect", listener: () => void): this,
        prependOnceListener(event: "data", listener: (data: Buffer) => void): this,
        prependOnceListener(event: "drain", listener: () => void): this,
        prependOnceListener(event: "end", listener: () => void): this,
        prependOnceListener(event: "error", listener: (err: Error) => void): this,
        prependOnceListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        prependOnceListener(event: "timeout", listener: () => void): this
    }
    declare export var Socket: {
        new(options?: {
            fd?: string,
            type?: string,
            allowHalfOpen?: boolean
        }): Socket
    };
    declare export interface ListenOptions {
        port?: number,
            host?: string,
            backlog?: number,
            path?: string,
            exclusive?: boolean
    }
    declare export type Server = {
        setTimeout(msecs: number, callback: Function): void,
        maxHeadersCount: number,
        timeout: number,
        listening: boolean
    }
    declare export function createServer(
        requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server
    declare export function connect(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            localPort?: string,
            family?: number,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function createConnection(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            localPort?: string,
            family?: number,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function isIP(input: string): number
    declare export function isIPv4(input: string): boolean
    declare export function isIPv6(input: string): boolean
}
declare module 'dgram' {

    declare interface RemoteInfo {
        address: string,
            family: string,
            port: number
    }
    declare interface AddressInfo {
        address: string,
            family: string,
            port: number
    }
    declare interface BindOptions {
        port: number,
            address?: string,
            exclusive?: boolean
    }
    declare interface SocketOptions {
        type: "udp4" | "udp6",
            reuseAddr?: boolean
    }
    declare export function createSocket(type: string, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket
    declare export type Socket = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        connect(port: number, host?: string, connectionListener?: Function): void,
        connect(path: string, connectionListener?: Function): void,
        bufferSize: number,
        setEncoding(encoding?: string): void,
        write(data: any, encoding?: string, callback?: Function): void,
        destroy(): void,
        pause(): Socket,
        resume(): Socket,
        setTimeout(timeout: number, callback?: Function): void,
        setNoDelay(noDelay?: boolean): void,
        setKeepAlive(enable?: boolean, initialDelay?: number): void,
        address(): {
            port: number,
            family: string,
            address: string
        },
        unref(): void,
        ref(): void,
        remoteAddress: string,
        remoteFamily: string,
        remotePort: number,
        localAddress: string,
        localPort: number,
        bytesRead: number,
        bytesWritten: number,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void,

        /**
         * events.EventEmitter
         *    1. close
           2. connect
           3. data
           4. drain
           5. end
           6. error
           7. lookup
           8. timeout
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "close", listener: (had_error: boolean) => void): this,
        addListener(event: "connect", listener: () => void): this,
        addListener(event: "data", listener: (data: Buffer) => void): this,
        addListener(event: "drain", listener: () => void): this,
        addListener(event: "end", listener: () => void): this,
        addListener(event: "error", listener: (err: Error) => void): this,
        addListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        addListener(event: "timeout", listener: () => void): this,
        emit(event: string, ...args: any[]): boolean,
        emit(event: "close", had_error: boolean): boolean,
        emit(event: "connect"): boolean,
        emit(event: "data", data: Buffer): boolean,
        emit(event: "drain"): boolean,
        emit(event: "end"): boolean,
        emit(event: "error", err: Error): boolean,
        emit(
            event: "lookup",
            err: Error,
            address: string,
            family: string | number,
            host: string): boolean,
        emit(event: "timeout"): boolean,
        on(event: string, listener: Function): this,
        on(event: "close", listener: (had_error: boolean) => void): this,
        on(event: "connect", listener: () => void): this,
        on(event: "data", listener: (data: Buffer) => void): this,
        on(event: "drain", listener: () => void): this,
        on(event: "end", listener: () => void): this,
        on(event: "error", listener: (err: Error) => void): this,
        on(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        on(event: "timeout", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "close", listener: (had_error: boolean) => void): this,
        once(event: "connect", listener: () => void): this,
        once(event: "data", listener: (data: Buffer) => void): this,
        once(event: "drain", listener: () => void): this,
        once(event: "end", listener: () => void): this,
        once(event: "error", listener: (err: Error) => void): this,
        once(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        once(event: "timeout", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "close", listener: (had_error: boolean) => void): this,
        prependListener(event: "connect", listener: () => void): this,
        prependListener(event: "data", listener: (data: Buffer) => void): this,
        prependListener(event: "drain", listener: () => void): this,
        prependListener(event: "end", listener: () => void): this,
        prependListener(event: "error", listener: (err: Error) => void): this,
        prependListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        prependListener(event: "timeout", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "close", listener: (had_error: boolean) => void): this,
        prependOnceListener(event: "connect", listener: () => void): this,
        prependOnceListener(event: "data", listener: (data: Buffer) => void): this,
        prependOnceListener(event: "drain", listener: () => void): this,
        prependOnceListener(event: "end", listener: () => void): this,
        prependOnceListener(event: "error", listener: (err: Error) => void): this,
        prependOnceListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void): this,
        prependOnceListener(event: "timeout", listener: () => void): this
    }
}
declare module 'fs' {


    declare interface Stats {
        isFile(): boolean,
            isDirectory(): boolean,
            isBlockDevice(): boolean,
            isCharacterDevice(): boolean,
            isSymbolicLink(): boolean,
            isFIFO(): boolean,
            isSocket(): boolean,
            dev: number,
            ino: number,
            mode: number,
            nlink: number,
            uid: number,
            gid: number,
            rdev: number,
            size: number,
            blksize: number,
            blocks: number,
            atime: Date,
            mtime: Date,
            ctime: Date,
            birthtime: Date
    }
    declare type FSWatcher = {
        close(): void,

        /**
         * events.EventEmitter
         *    1. change
           2. error
        */
        addListener(event: string, listener: Function): this,
        addListener(
            event: "change",
            listener: (eventType: string, filename: string | Buffer) => void): this,
        addListener(event: "error", listener: (code: number, signal: string) => void): this,
        on(event: string, listener: Function): this,
        on(
            event: "change",
            listener: (eventType: string, filename: string | Buffer) => void): this,
        on(event: "error", listener: (code: number, signal: string) => void): this,
        once(event: string, listener: Function): this,
        once(
            event: "change",
            listener: (eventType: string, filename: string | Buffer) => void): this,
        once(event: "error", listener: (code: number, signal: string) => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(
            event: "change",
            listener: (eventType: string, filename: string | Buffer) => void): this,
        prependListener(event: "error", listener: (code: number, signal: string) => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(
            event: "change",
            listener: (eventType: string, filename: string | Buffer) => void): this,
        prependOnceListener(event: "error", listener: (code: number, signal: string) => void): this
    }
    declare export type ReadStream = {
        close(): void,
        destroy(): void,
        bytesRead: number,
        path: string | Buffer,

        /**
         * events.EventEmitter
         *    1. open
           2. close
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "open", listener: (fd: number) => void): this,
        addListener(event: "close", listener: () => void): this,
        on(event: string, listener: Function): this,
        on(event: "open", listener: (fd: number) => void): this,
        on(event: "close", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "open", listener: (fd: number) => void): this,
        once(event: "close", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "open", listener: (fd: number) => void): this,
        prependListener(event: "close", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "open", listener: (fd: number) => void): this,
        prependOnceListener(event: "close", listener: () => void): this
    }
    declare export type WriteStream = {
        close(): void,
        bytesWritten: number,
        path: string | Buffer,

        /**
         * events.EventEmitter
         *    1. open
           2. close
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "open", listener: (fd: number) => void): this,
        addListener(event: "close", listener: () => void): this,
        on(event: string, listener: Function): this,
        on(event: "open", listener: (fd: number) => void): this,
        on(event: "close", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "open", listener: (fd: number) => void): this,
        once(event: "close", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "open", listener: (fd: number) => void): this,
        prependListener(event: "close", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "open", listener: (fd: number) => void): this,
        prependOnceListener(event: "close", listener: () => void): this
    }

    /**
     * Asynchronous rename.
     * @param oldPath 
     * @param newPath 
     * @param callback No arguments other than a possible exception are given to the completion callback.
     */
    declare export function rename(
        oldPath: string,
        newPath: string,
        callback?: (err?: NodeJS$ErrnoException) => void): void

    /**
     * Synchronous rename
     * @param oldPath 
     * @param newPath 
     */
    declare export function renameSync(oldPath: string, newPath: string): void
    declare export function truncate(path: string | Buffer, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function truncateSync(path: string | Buffer, len?: number): void
    declare export function ftruncate(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function ftruncateSync(fd: number, len?: number): void
    declare export function chown(
        path: string | Buffer,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function chownSync(path: string | Buffer, uid: number, gid: number): void
    declare export function fchown(
        fd: number,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fchownSync(fd: number, uid: number, gid: number): void
    declare export function lchown(
        path: string | Buffer,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function lchownSync(path: string | Buffer, uid: number, gid: number): void
    declare export function chmod(
        path: string | Buffer,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function chmodSync(path: string | Buffer, mode: number): void
    declare export function fchmod(
        fd: number,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fchmodSync(fd: number, mode: number): void
    declare export function lchmod(
        path: string | Buffer,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function lchmodSync(path: string | Buffer, mode: number): void
    declare export function stat(
        path: string | Buffer,
        callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function lstat(
        path: string | Buffer,
        callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function fstat(fd: number, callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function statSync(path: string | Buffer): Stats
    declare export function lstatSync(path: string | Buffer): Stats
    declare export function fstatSync(fd: number): Stats
    declare export function link(
        srcpath: string | Buffer,
        dstpath: string | Buffer,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function linkSync(srcpath: string | Buffer, dstpath: string | Buffer): void
    declare export function symlink(
        srcpath: string | Buffer,
        dstpath: string | Buffer,
        type?: string,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function symlinkSync(srcpath: string | Buffer, dstpath: string | Buffer, type?: string): void
    declare export function readlink(
        path: string | Buffer,
        callback?: (err: NodeJS$ErrnoException, linkString: string) => any): void
    declare export function readlinkSync(path: string | Buffer): string
    declare export function realpath(
        path: string | Buffer,
        callback?: (err: NodeJS$ErrnoException, resolvedPath: string) => any): void
    declare export function realpathSync(path: string | Buffer, cache?: {
        [path: string]: string
    }): string
    declare export function unlink(path: string | Buffer, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function unlinkSync(path: string | Buffer): void
    declare export function rmdir(path: string | Buffer, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function rmdirSync(path: string | Buffer): void
    declare export function mkdir(path: string | Buffer, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function mkdirSync(path: string | Buffer, mode?: number): void
    declare export function mkdtemp(
        prefix: string,
        callback?: (err: NodeJS$ErrnoException, folder: string) => void): void
    declare export function mkdtempSync(prefix: string): string
    declare export function readdir(
        path: string | Buffer,
        callback?: (err: NodeJS$ErrnoException, files: string[]) => void): void
    declare export function readdirSync(path: string | Buffer): string[]
    declare export function close(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function closeSync(fd: number): void
    declare export function open(
        path: string | Buffer,
        flags: string | number,
        callback: (err: NodeJS$ErrnoException, fd: number) => void): void
    declare export function openSync(path: string | Buffer, flags: string | number, mode?: number): number
    declare export function utimes(
        path: string | Buffer,
        atime: number,
        mtime: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function utimesSync(path: string | Buffer, atime: number, mtime: number): void
    declare export function futimes(
        fd: number,
        atime: number,
        mtime: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function futimesSync(fd: number, atime: number, mtime: number): void
    declare export function fsync(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fsyncSync(fd: number): void
    declare export function write(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number,
        callback?: (err: NodeJS$ErrnoException, written: number, buffer: Buffer) => void): void
    declare export function writeSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position?: number): number
    declare export function read(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number,
        callback?: (err: NodeJS$ErrnoException, bytesRead: number, buffer: Buffer) => void): void
    declare export function readSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): number
    declare export function readFile(
        filename: string,
        encoding: string,
        callback: (err: NodeJS$ErrnoException, data: string) => void): void
    declare export function readFileSync(filename: string, encoding: string): string
    declare export function writeFile(
        filename: string,
        data: any,
        callback?: (err: NodeJS$ErrnoException) => void): void
    declare export function writeFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare export function appendFile(
        filename: string,
        data: any,
        options: {
            encoding?: string,
            mode?: number,
            flag?: string
        },
        callback?: (err: NodeJS$ErrnoException) => void): void
    declare export function appendFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare export function watchFile(filename: string, listener: (curr: Stats, prev: Stats) => void): void
    declare export function unwatchFile(filename: string, listener?: (curr: Stats, prev: Stats) => void): void
    declare export function watch(
        filename: string,
        listener?: (event: string, filename: string) => any): FSWatcher
    declare export function exists(path: string | Buffer, callback?: (exists: boolean) => void): void
    declare export function existsSync(path: string | Buffer): boolean
    declare export var F_OK: number;

    declare export var R_OK: number;

    declare export var W_OK: number;

    declare export var X_OK: number;

    declare export var O_RDONLY: number;

    declare export var O_WRONLY: number;

    declare export var O_RDWR: number;

    declare export var O_CREAT: number;

    declare export var O_EXCL: number;

    declare export var O_NOCTTY: number;

    declare export var O_TRUNC: number;

    declare export var O_APPEND: number;

    declare export var O_DIRECTORY: number;

    declare export var O_NOATIME: number;

    declare export var O_NOFOLLOW: number;

    declare export var O_SYNC: number;

    declare export var O_SYMLINK: number;

    declare export var O_DIRECT: number;

    declare export var O_NONBLOCK: number;

    declare export var S_IFMT: number;

    declare export var S_IFREG: number;

    declare export var S_IFDIR: number;

    declare export var S_IFCHR: number;

    declare export var S_IFBLK: number;

    declare export var S_IFIFO: number;

    declare export var S_IFLNK: number;

    declare export var S_IFSOCK: number;

    declare export var S_IRWXU: number;

    declare export var S_IRUSR: number;

    declare export var S_IWUSR: number;

    declare export var S_IXUSR: number;

    declare export var S_IRWXG: number;

    declare export var S_IRGRP: number;

    declare export var S_IWGRP: number;

    declare export var S_IXGRP: number;

    declare export var S_IRWXO: number;

    declare export var S_IROTH: number;

    declare export var S_IWOTH: number;

    declare export var S_IXOTH: number;

    /**
     * Tests a user's permissions for the file specified by path. 
     */
    declare export function access(path: string | Buffer, callback: (err: NodeJS$ErrnoException) => void): void

    /**
     * Synchronous version of fs.access. This throws if any accessibility checks fail, and does nothing otherwise. 
     */
    declare export function accessSync(path: string | Buffer, mode?: number): void
    declare export function createReadStream(
        path: string | Buffer,
        options?: {
            flags?: string,
            encoding?: string,
            fd?: number,
            mode?: number,
            autoClose?: boolean,
            start?: number,
            end?: number
        }): ReadStream
    declare export function createWriteStream(
        path: string | Buffer,
        options?: {
            flags?: string,
            encoding?: string,
            fd?: number,
            mode?: number,
            autoClose?: boolean,
            start?: number
        }): WriteStream
    declare export function fdatasync(fd: number, callback: Function): void
    declare export function fdatasyncSync(fd: number): void
}
declare module 'path' {

    /**
     * A parsed path object generated by path.parse() or consumed by path.format().
     */
    declare export interface ParsedPath {

        /**
         * The root of the path such as '/' or 'c:\'
         */
        root: string,

            /**
             * The full directory path such as '/home/user/dir' or 'c:\path\dir'
             */
            dir: string,

            /**
             * The file name including extension (if any) such as 'index.html'
             */
            base: string,

            /**
             * The file extension (if any) such as '.html'
             */
            ext: string,

            /**
             * The file name without extension (if any) such as 'index'
             */
            name: string
    }

    /**
     * Normalize a string path, reducing '..' and '.' parts.
     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
     * @param p string path to normalize.
     */
    declare export function normalize(p: string): string

    /**
     * Join all arguments together and normalize the resulting path.
     * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
     * @param paths string paths to join.
     */
    declare export function join(...paths: any[]): string
    declare export function resolve(from: string, to: string): string

    /**
     * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
     * @param path path to test.
     */
    declare export function isAbsolute(path: string): boolean

    /**
     * Solve the relative path from {from} to {to}.
     * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
     * @param from 
     * @param to 
     */
    declare export function relative(from: string, to: string): string

    /**
     * Return the directory name of a path. Similar to the Unix dirname command.
     * @param p the path to evaluate.
     */
    declare export function dirname(p: string): string

    /**
     * Return the last portion of a path. Similar to the Unix basename command.
     * Often used to extract the file name from a fully qualified path.
     * @param p the path to evaluate.
     * @param ext optionally, an extension to remove from the result.
     */
    declare export function basename(p: string, ext?: string): string

    /**
     * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
     * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
     * @param p the path to evaluate.
     */
    declare export function extname(p: string): string
    declare export var sep: string;
    declare export var delimiter: string;
    declare export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any
    declare export function format(url: Url): string
    declare module 'posix' {

        /**
         * Normalize a string path, reducing '..' and '.' parts.
         * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
         * @param p string path to normalize.
         */
        declare     export function normalize(p: string): string

        /**
         * Join all arguments together and normalize the resulting path.
         * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
         * @param paths string paths to join.
         */
        declare     export function join(...paths: any[]): string
        declare     export function resolve(from: string, to: string): string

        /**
         * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
         * @param path path to test.
         */
        declare     export function isAbsolute(path: string): boolean

        /**
         * Solve the relative path from {from} to {to}.
         * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
         * @param from 
         * @param to 
         */
        declare     export function relative(from: string, to: string): string

        /**
         * Return the directory name of a path. Similar to the Unix dirname command.
         * @param p the path to evaluate.
         */
        declare     export function dirname(p: string): string

        /**
         * Return the last portion of a path. Similar to the Unix basename command.
         * Often used to extract the file name from a fully qualified path.
         * @param p the path to evaluate.
         * @param ext optionally, an extension to remove from the result.
         */
        declare     export function basename(p: string, ext?: string): string

        /**
         * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
         * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
         * @param p the path to evaluate.
         */
        declare     export function extname(p: string): string
        declare     export var sep: string;
        declare     export var delimiter: string;
        declare     export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any
        declare     export function format(url: Url): string
    }

    declare module 'win32' {

        /**
         * Normalize a string path, reducing '..' and '.' parts.
         * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
         * @param p string path to normalize.
         */
        declare     export function normalize(p: string): string

        /**
         * Join all arguments together and normalize the resulting path.
         * Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
         * @param paths string paths to join.
         */
        declare     export function join(...paths: any[]): string
        declare     export function resolve(from: string, to: string): string

        /**
         * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
         * @param path path to test.
         */
        declare     export function isAbsolute(path: string): boolean

        /**
         * Solve the relative path from {from} to {to}.
         * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
         * @param from 
         * @param to 
         */
        declare     export function relative(from: string, to: string): string

        /**
         * Return the directory name of a path. Similar to the Unix dirname command.
         * @param p the path to evaluate.
         */
        declare     export function dirname(p: string): string

        /**
         * Return the last portion of a path. Similar to the Unix basename command.
         * Often used to extract the file name from a fully qualified path.
         * @param p the path to evaluate.
         * @param ext optionally, an extension to remove from the result.
         */
        declare     export function basename(p: string, ext?: string): string

        /**
         * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
         * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
         * @param p the path to evaluate.
         */
        declare     export function extname(p: string): string
        declare     export var sep: string;
        declare     export var delimiter: string;
        declare     export function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): any
        declare     export function format(url: Url): string
    }

}
declare module 'string_decoder' {
    declare export interface NodeStringDecoder {
        write(buffer: Buffer): string,
            end(buffer?: Buffer): string
    }
    declare export var StringDecoder: {
        new(encoding?: string): NodeStringDecoder
    };
}
declare module 'tls' {



    declare var CLIENT_RENEG_LIMIT: number;
    declare var CLIENT_RENEG_WINDOW: number;
    declare export interface Certificate {

        /**
         * Country code.
         */
        C: string,

            /**
             * Street.
             */
            ST: string,

            /**
             * Locality.
             */
            L: string,

            /**
             * Organization.
             */
            O: string,

            /**
             * Organizational unit.
             */
            OU: string,

            /**
             * Common name.
             */
            CN: string
    }
    declare export interface CipherNameAndProtocol {

        /**
         * The cipher name.
         */
        name: string,

            /**
             * SSL/TLS protocol version.
             */
            version: string
    }
    declare export class TLSSocket mixins stream.Duplex {

        /**
         * Construct a new tls.TLSSocket object from an existing TCP socket.
         */
        constructor(socket: net.Socket, options?: {

            /**
             * An optional TLS context object from tls.createSecureContext()
             */
            secureContext?: SecureContext,

            /**
             * If true the TLS socket will be instantiated in server-mode.
             * Defaults to false.
             */
            isServer?: boolean,

            /**
             * An optional net.Server instance.
             */
            server?: net.Server,

            /**
             * If true the server will request a certificate from clients that
             * connect and attempt to verify that certificate. Defaults to
            false.
            */
            requestCert?: boolean,

            /**
             * If true the server will reject any connection which is not
             * authorized with the list of supplied CAs. This option only has an
            effect if requestCert is true. Defaults to false.
            */
            rejectUnauthorized?: boolean,

            /**
             * An array of strings or a Buffer naming possible NPN protocols.
             * (Protocols should be ordered by their priority.)
             */
            NPNProtocols?: string[] | Buffer,

            /**
             * An array of strings or a Buffer naming possible ALPN protocols.
             * (Protocols should be ordered by their priority.) When the server
            receives both NPN and ALPN extensions from the client, ALPN takes
            precedence over NPN and the server does not send an NPN extension
            to the client.
            */
            ALPNProtocols?: string[] | Buffer,

            /**
             * SNICallback(servername, cb) <Function> A function that will be
             * called if the client supports SNI TLS extension. Two arguments
            will be passed when called: servername and cb. SNICallback should
            invoke cb(null, ctx), where ctx is a SecureContext instance.
            (tls.createSecureContext(...) can be used to get a proper
            SecureContext.) If SNICallback wasn't provided the default callback
            with high-level API will be used (see below).
            */
            SNICallback?: Function,

            /**
             * An optional Buffer instance containing a TLS session.
             */
            session?: Buffer,

            /**
             * If true, specifies that the OCSP status request extension will be
             * added to the client hello and an 'OCSPResponse' event will be
            emitted on the socket before establishing a secure communication
            */
            requestOCSP?: boolean
        }): this;

        /**
         * Returns the bound address, the address family name and port of the underlying socket as reported by
         * the operating system.
         * @returns  - An object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }.
         */
        address(): {
            port: number,
            family: string,
            address: string
        };

        /**
         * A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false.
         */
        authorized: boolean;

        /**
         * The reason why the peer's certificate has not been verified.
         * This property becomes available only when tlsSocket.authorized === false.
         */
        authorizationError: Error;

        /**
         * Static boolean value, always true.
         * May be used to distinguish TLS sockets from regular ones.
         */
        encrypted: boolean;

        /**
         * Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.
         * @returns  - Returns an object representing the cipher name
        and the SSL/TLS protocol version of the current connection.
        */
        getCipher(): CipherNameAndProtocol;

        /**
         * Returns an object representing the peer's certificate.
         * The returned object has some properties corresponding to the field of the certificate.
        If detailed argument is true the full chain with issuer property will be returned,
        if false only the top certificate without issuer property.
        If the peer does not provide a certificate, it returns null or an empty object.
         * @param  - If true; the full chain with issuer property will be returned.
         * @returns  - An object representing the peer's certificate.
        */
        getPeerCertificate(
            detailed?: boolean): {
            subject: Certificate,
            issuerInfo: Certificate,
            issuer: Certificate,
            raw: any,
            valid_from: string,
            valid_to: string,
            fingerprint: string,
            serialNumber: string
        };

        /**
         * Could be used to speed up handshake establishment when reconnecting to the server.
         * @returns  - ASN.1 encoded TLS session or undefined if none was negotiated.
         */
        getSession(): any;

        /**
         * NOTE: Works only with client TLS sockets.
         * Useful only for debugging, for session reuse provide session option to tls.connect().
         * @returns  - TLS session ticket or undefined if none was negotiated.
         */
        getTLSTicket(): any;

        /**
         * The string representation of the local IP address.
         */
        localAddress: string;

        /**
         * The numeric representation of the local port.
         */
        localPort: string;

        /**
         * The string representation of the remote IP address.
         * For example, '74.125.127.100' or '2001:4860:a005::68'.
         */
        remoteAddress: string;

        /**
         * The string representation of the remote IP family. 'IPv4' or 'IPv6'.
         */
        remoteFamily: string;

        /**
         * The numeric representation of the remote port. For example, 443.
         */
        remotePort: number;

        /**
         * Initiate TLS renegotiation process.
         * 
        NOTE: Can be used to request peer's certificate after the secure connection has been established.
        ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.
         * @param  - The options may contain the following fields: rejectUnauthorized,
        requestCert (See tls.createServer() for details).
         * @param  - callback(err) will be executed with null as err, once the renegotiation
        is successfully completed.
        */
        renegotiate(options: TlsOptions, callback: (err: Error) => any): any;

        /**
         * Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).
         * Smaller fragment size decreases buffering latency on the client: large fragments are buffered by
        the TLS layer until the entire fragment is received and its integrity is verified;
        large fragments can span multiple roundtrips, and their processing can be delayed due to packet
        loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,
        which may decrease overall server throughput.
         * @param  - TLS fragment size (default and maximum value is: 16384, minimum is: 512).
         * @returns  - Returns true on success, false otherwise.
        */
        setMaxSendFragment(size: number): boolean;

        /**
         * events.EventEmitter
         * 1. OCSPResponse
        2. secureConnect
        */
        addListener(event: string, listener: Function): this;
        addListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;
        addListener(event: "secureConnect", listener: () => void): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "OCSPResponse", response: Buffer): boolean;
        emit(event: "secureConnect"): boolean;
        on(event: string, listener: Function): this;
        on(event: "OCSPResponse", listener: (response: Buffer) => void): this;
        on(event: "secureConnect", listener: () => void): this;
        once(event: string, listener: Function): this;
        once(event: "OCSPResponse", listener: (response: Buffer) => void): this;
        once(event: "secureConnect", listener: () => void): this;
        prependListener(event: string, listener: Function): this;
        prependListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;
        prependListener(event: "secureConnect", listener: () => void): this;
        prependOnceListener(event: string, listener: Function): this;
        prependOnceListener(event: "OCSPResponse", listener: (response: Buffer) => void): this;
        prependOnceListener(event: "secureConnect", listener: () => void): this
    }
    declare export interface TlsOptions {
        host?: string,
            port?: number,
            pfx?: string | Buffer[],
            key?: string | string[] | Buffer | any[],
            passphrase?: string,
            cert?: string | string[] | Buffer | Buffer[],
            ca?: string | string[] | Buffer | Buffer[],
            crl?: string | string[],
            ciphers?: string,
            honorCipherOrder?: boolean,
            requestCert?: boolean,
            rejectUnauthorized?: boolean,
            NPNProtocols?: string[] | Buffer,
            SNICallback?: (servername: string, cb: (err: Error, ctx: SecureContext) => any) => any,
            ecdhCurve?: string,
            dhparam?: string | Buffer,
            handshakeTimeout?: number,
            ALPNProtocols?: string[] | Buffer,
            sessionTimeout?: number,
            ticketKeys?: any,
            sessionIdContext?: string,
            secureProtocol?: string
    }
    declare export interface ConnectionOptions {
        host?: string,
            port?: number,
            socket?: net.Socket,
            pfx?: string | Buffer,
            key?: string | string[] | Buffer | Buffer[],
            passphrase?: string,
            cert?: string | string[] | Buffer | Buffer[],
            ca?: string | Buffer | (string | Buffer)[],
            rejectUnauthorized?: boolean,
            NPNProtocols?: (string | Buffer)[],
            servername?: string,
            path?: string,
            ALPNProtocols?: (string | Buffer)[],
            checkServerIdentity?: (servername: string, cert: string | Buffer | (string | Buffer)[]) => any,
            secureProtocol?: string,
            secureContext?: Object,
            session?: Buffer,
            minDHSize?: number
    }
    declare export type Server = {
        setTimeout(msecs: number, callback: Function): void,
        maxHeadersCount: number,
        timeout: number,
        listening: boolean
    }
    declare export type ClearTextStream = {
        authorized: boolean,
        authorizationError: Error,
        getPeerCertificate(): any,
        getCipher: {
            name: string,
            version: string
        },
        address: {
            port: number,
            family: string,
            address: string
        },
        remoteAddress: string,
        remotePort: number
    }
    declare export interface SecurePair {
        encrypted: any,
            cleartext: any
    }
    declare export interface SecureContextOptions {
        pfx?: string | Buffer,
            key?: string | Buffer,
            passphrase?: string,
            cert?: string | Buffer,
            ca?: string | Buffer,
            crl?: string | string[],
            ciphers?: string,
            honorCipherOrder?: boolean
    }
    declare export interface SecureContext {
        context: any
    }
    declare export function createServer(
        requestListener?: (request: IncomingMessage, response: ServerResponse) => void): Server
    declare export function connect(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            localPort?: string,
            family?: number,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function createSecurePair(
        credentials?: crypto.Credentials,
        isServer?: boolean,
        requestCert?: boolean,
        rejectUnauthorized?: boolean): SecurePair
    declare export function createSecureContext(details: SecureContextOptions): SecureContext
}
declare module 'crypto' {
    declare export interface Certificate {

        /**
         * Country code.
         */
        C: string,

            /**
             * Street.
             */
            ST: string,

            /**
             * Locality.
             */
            L: string,

            /**
             * Organization.
             */
            O: string,

            /**
             * Organizational unit.
             */
            OU: string,

            /**
             * Common name.
             */
            CN: string
    }
    declare export var Certificate: {
        new(): Certificate,
        (): Certificate
    };
    declare export var fips: boolean;
    declare export interface CredentialDetails {
        pfx: string,
            key: string,
            passphrase: string,
            cert: string,
            ca: string | string[],
            crl: string | string[],
            ciphers: string
    }
    declare export interface Credentials {
        context?: any
    }
    declare export function createCredentials(details: CredentialDetails): Credentials
    declare export function createHash(algorithm: string): Hash
    declare export function createHmac(algorithm: string, key: string | Buffer): Hmac
    declare type Utf8AsciiLatin1Encoding = "utf8" | "ascii" | "latin1";
    declare type HexBase64Latin1Encoding = "latin1" | "hex" | "base64";
    declare type Utf8AsciiBinaryEncoding = "utf8" | "ascii" | "binary";
    declare type HexBase64BinaryEncoding = "binary" | "base64" | "hex";
    declare type ECDHKeyFormat = "compressed" | "uncompressed" | "hybrid";
    declare export type Hash = {
        update(data: string | Buffer): Hash,
        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Hash,
        digest(): Buffer,
        digest(encoding: HexBase64Latin1Encoding): string
    }
    declare export type Hmac = {
        update(data: string | Buffer): Hmac,
        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Hmac,
        digest(): Buffer,
        digest(encoding: HexBase64Latin1Encoding): string
    }
    declare export function createCipher(algorithm: string, password: any): Cipher
    declare export function createCipheriv(algorithm: string, key: any, iv: any): Cipher
    declare export type Cipher = {
        update(data: Buffer): Buffer,
        update(data: string, input_encoding: Utf8AsciiBinaryEncoding): Buffer,
        update(
            data: Buffer,
            input_encoding: any,
            output_encoding: HexBase64BinaryEncoding): string,
        update(
            data: string,
            input_encoding: Utf8AsciiBinaryEncoding,
            output_encoding: HexBase64BinaryEncoding): string,
        final(): Buffer,
        final(output_encoding: string): string,
        setAutoPadding(auto_padding?: boolean): void,
        getAuthTag(): Buffer,
        setAAD(buffer: Buffer): void
    }
    declare export function createDecipher(algorithm: string, password: any): Decipher
    declare export function createDecipheriv(algorithm: string, key: any, iv: any): Decipher
    declare export type Decipher = {
        update(data: Buffer): Buffer,
        update(data: string, input_encoding: HexBase64BinaryEncoding): Buffer,
        update(
            data: Buffer,
            input_encoding: any,
            output_encoding: Utf8AsciiBinaryEncoding): string,
        update(
            data: string,
            input_encoding: HexBase64BinaryEncoding,
            output_encoding: Utf8AsciiBinaryEncoding): string,
        final(): Buffer,
        final(output_encoding: string): string,
        setAutoPadding(auto_padding?: boolean): void,
        setAuthTag(tag: Buffer): void,
        setAAD(buffer: Buffer): void
    }
    declare export function createSign(algorithm: string): Signer
    declare export type Signer = {
        update(data: string | Buffer): Signer,
        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Signer,
        sign(private_key: string | {
            key: string,
            passphrase: string
        }): Buffer,
        sign(
            private_key: string | {
                key: string,
                passphrase: string
            },
            output_format: HexBase64Latin1Encoding): string
    }
    declare export function createVerify(algorith: string): Verify
    declare export type Verify = {
        update(data: string | Buffer): Verify,
        update(data: string | Buffer, input_encoding: Utf8AsciiLatin1Encoding): Verify,
        verify(object: string, signature: Buffer): boolean,
        verify(
            object: string,
            signature: string,
            signature_format: HexBase64Latin1Encoding): boolean
    }
    declare export function createDiffieHellman(prime_length: number, generator?: number): DiffieHellman
    declare export interface DiffieHellman {
        generateKeys(): Buffer,
            generateKeys(encoding: HexBase64Latin1Encoding): string,
            computeSecret(other_public_key: Buffer): Buffer,
            computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer,
            computeSecret(
                other_public_key: string,
                input_encoding: HexBase64Latin1Encoding,
                output_encoding: HexBase64Latin1Encoding): string,
            getPrime(): Buffer,
            getPrime(encoding: HexBase64Latin1Encoding): string,
            getGenerator(): Buffer,
            getGenerator(encoding: HexBase64Latin1Encoding): string,
            getPublicKey(): Buffer,
            getPublicKey(encoding: HexBase64Latin1Encoding): string,
            getPrivateKey(): Buffer,
            getPrivateKey(encoding: HexBase64Latin1Encoding): string,
            setPublicKey(public_key: Buffer): void,
            setPublicKey(public_key: string, encoding: string): void,
            setPrivateKey(private_key: Buffer): void,
            setPrivateKey(private_key: string, encoding: string): void,
            verifyError: number
    }
    declare export function getDiffieHellman(group_name: string): DiffieHellman
    declare export function pbkdf2(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number,
        digest: string,
        callback: (err: Error, derivedKey: Buffer) => any): void
    declare export function pbkdf2Sync(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number,
        digest: string): Buffer
    declare export function randomBytes(size: number): Buffer
    declare export function pseudoRandomBytes(size: number): Buffer
    declare export interface RsaPublicKey {
        key: string,
            padding?: number
    }
    declare export interface RsaPrivateKey {
        key: string,
            passphrase?: string,
            padding?: number
    }
    declare export function publicEncrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer
    declare export function privateDecrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer
    declare export function privateEncrypt(private_key: string | RsaPrivateKey, buffer: Buffer): Buffer
    declare export function publicDecrypt(public_key: string | RsaPublicKey, buffer: Buffer): Buffer
    declare export function getCiphers(): string[]
    declare export function getCurves(): string[]
    declare export function getHashes(): string[]
    declare export interface ECDH {
        generateKeys(): Buffer,
            generateKeys(encoding: HexBase64Latin1Encoding): string,
            generateKeys(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string,
            computeSecret(other_public_key: Buffer): Buffer,
            computeSecret(other_public_key: string, input_encoding: HexBase64Latin1Encoding): Buffer,
            computeSecret(
                other_public_key: string,
                input_encoding: HexBase64Latin1Encoding,
                output_encoding: HexBase64Latin1Encoding): string,
            getPrivateKey(): Buffer,
            getPrivateKey(encoding: HexBase64Latin1Encoding): string,
            getPublicKey(): Buffer,
            getPublicKey(encoding: HexBase64Latin1Encoding): string,
            getPublicKey(encoding: HexBase64Latin1Encoding, format: ECDHKeyFormat): string,
            setPrivateKey(private_key: Buffer): void,
            setPrivateKey(private_key: string, encoding: HexBase64Latin1Encoding): void
    }
    declare export function createECDH(curve_name: string): ECDH
    declare export function timingSafeEqual(a: Buffer, b: Buffer): boolean
    declare export var DEFAULT_ENCODING: string;
}
declare module 'stream' {

    declare module.exports: typeof internal
    declare export class Stream mixins internal {}

    declare export interface internal$ReadableOptions {
        highWaterMark?: number,
            encoding?: string,
            objectMode?: boolean,
            read?: (size?: number) => any
    }

    declare export class Readable mixins events.EventEmitter, NodeJS$ReadableStream {
        readable: boolean;
        constructor(opts?: internal$ReadableOptions): this;
        _read(size: number): void;
        read(size?: number): any;
        setEncoding(encoding: string): void;
        pause(): internal$Readable;
        resume(): internal$Readable;
        pipe<T>(destination: T, options?: {
            end?: boolean
        }): T;
        unpipe<T>(destination?: T): void;
        unshift(chunk: any): void;
        wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream;
        push(chunk: any, encoding?: string): boolean;

        /**
         * Event emitter
         * The defined events on documents including:
           1. close
           2. data
           3. end
           4. readable
           5. error
        */
        addListener(event: string, listener: Function): this;
        addListener(event: string, listener: Function): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "readable", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "end"): boolean;
        emit(event: "readable"): boolean;
        emit(event: "error", err: Error): boolean;
        on(event: string, listener: Function): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "readable", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        once(event: string, listener: Function): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "readable", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        prependListener(event: string, listener: Function): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "readable", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: string, listener: Function): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "readable", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        removeListener(event: string, listener: Function): this;
        removeListener(event: "close", listener: () => void): this;
        removeListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        removeListener(event: "end", listener: () => void): this;
        removeListener(event: "readable", listener: () => void): this;
        removeListener(event: "error", listener: (err: Error) => void): this
    }

    declare export interface internal$WritableOptions {
        highWaterMark?: number,
            decodeStrings?: boolean,
            objectMode?: boolean,
            write?: (chunk: string | Buffer, encoding: string, callback: Function) => any,
            writev?: (
                chunks: {
                    chunk: string | Buffer,
                    encoding: string
                }[],
                callback: Function) => any
    }

    declare export class Writable mixins events.EventEmitter, NodeJS$WritableStream {
        writable: boolean;
        constructor(opts?: internal$WritableOptions): this;
        _write(chunk: any, encoding: string, callback: Function): void;
        write(chunk: any, cb?: Function): boolean;
        write(chunk: any, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(chunk: any, cb?: Function): void;
        end(chunk: any, encoding?: string, cb?: Function): void;

        /**
         * Event emitter
         * The defined events on documents including:
           1. close
           2. drain
           3. error
           4. finish
           5. pipe
           6. unpipe
        */
        addListener(event: string, listener: Function): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: internal$Readable) => void): this;
        addListener(event: "unpipe", listener: (src: internal$Readable) => void): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "drain", chunk: Buffer | string): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: internal$Readable): boolean;
        emit(event: "unpipe", src: internal$Readable): boolean;
        on(event: string, listener: Function): this;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: internal$Readable) => void): this;
        on(event: "unpipe", listener: (src: internal$Readable) => void): this;
        once(event: string, listener: Function): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: internal$Readable) => void): this;
        once(event: "unpipe", listener: (src: internal$Readable) => void): this;
        prependListener(event: string, listener: Function): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: internal$Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: internal$Readable) => void): this;
        prependOnceListener(event: string, listener: Function): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: internal$Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: internal$Readable) => void): this;
        removeListener(event: string, listener: Function): this;
        removeListener(event: "close", listener: () => void): this;
        removeListener(event: "drain", listener: () => void): this;
        removeListener(event: "error", listener: (err: Error) => void): this;
        removeListener(event: "finish", listener: () => void): this;
        removeListener(event: "pipe", listener: (src: internal$Readable) => void): this;
        removeListener(event: "unpipe", listener: (src: internal$Readable) => void): this
    }

    declare export type internal$DuplexOptions = {
        allowHalfOpen?: boolean,
        readableObjectMode?: boolean,
        writableObjectMode?: boolean
    } & internal$ReadableOptions & internal$WritableOptions


    declare export class Duplex mixins Readable, NodeJS$ReadWriteStream {
        pause(): internal$Duplex;
        resume(): internal$Duplex;
        writable: boolean;
        constructor(opts?: internal$DuplexOptions): this;
        _write(chunk: any, encoding: string, callback: Function): void;
        write(chunk: any, cb?: Function): boolean;
        write(chunk: any, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(chunk: any, cb?: Function): void;
        end(chunk: any, encoding?: string, cb?: Function): void
    }

    declare export type internal$TransformOptions = {
        transform?: (chunk: string | Buffer, encoding: string, callback: Function) => any,
        flush?: (callback: Function) => any
    } & internal$DuplexOptions


    declare export class Transform mixins events.EventEmitter, NodeJS$ReadWriteStream {
        readable: boolean;
        writable: boolean;
        constructor(opts?: internal$TransformOptions): this;
        _transform(chunk: any, encoding: string, callback: Function): void;
        _flush(callback: Function): void;
        read(size?: number): any;
        setEncoding(encoding: string): void;
        pause(): internal$Transform;
        resume(): internal$Transform;
        pipe<T>(destination: T, options?: {
            end?: boolean
        }): T;
        unpipe<T>(destination?: T): void;
        unshift(chunk: any): void;
        wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream;
        push(chunk: any, encoding?: string): boolean;
        write(chunk: any, cb?: Function): boolean;
        write(chunk: any, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(chunk: any, cb?: Function): void;
        end(chunk: any, encoding?: string, cb?: Function): void
    }

    declare export class PassThrough mixins Transform {}
}
declare module 'util' {
    declare export interface InspectOptions {
        showHidden?: boolean,
            depth?: number,
            colors?: boolean,
            customInspect?: boolean
    }
    declare export function format(url: Url): string
    declare export function debug(string: string): void
    declare export function error(...param: any[]): void
    declare export function puts(...param: any[]): void
    declare export function print(...param: any[]): void
    declare export function log(string: string): void
    declare export function inspect(object: any, showHidden?: boolean, depth?: number, color?: boolean): string
    declare export function isArray(object: any): boolean
    declare export function isRegExp(object: any): boolean
    declare export function isDate(object: any): boolean
    declare export function isError(object: any): boolean
    declare export function inherits(constructor: any, superConstructor: any): void
    declare export function debuglog(key: string): (msg: string, ...param: any[]) => void
    declare export function isBoolean(object: any): boolean
    declare export function isBuffer(object: any): boolean
    declare export function isFunction(object: any): boolean
    declare export function isNull(object: any): boolean
    declare export function isNullOrUndefined(object: any): boolean
    declare export function isNumber(object: any): boolean
    declare export function isObject(object: any): boolean
    declare export function isPrimitive(object: any): boolean
    declare export function isString(object: any): boolean
    declare export function isSymbol(object: any): boolean
    declare export function isUndefined(object: any): boolean
    declare export function deprecate(fn: Function, message: string): Function
}
declare module 'assert' {
    declare module.exports: typeof internal

    declare var npm$namespace$internal: {
        fail: typeof internal$fail,
        ok: typeof internal$ok,
        equal: typeof internal$equal,
        notEqual: typeof internal$notEqual,
        deepEqual: typeof internal$deepEqual,
        notDeepEqual: typeof internal$notDeepEqual,
        strictEqual: typeof internal$strictEqual,
        notStrictEqual: typeof internal$notStrictEqual,
        deepStrictEqual: typeof internal$deepStrictEqual,
        notDeepStrictEqual: typeof internal$notDeepStrictEqual,
        ifError: typeof internal$ifError,
    }
    declare export class AssertionError mixins Error {
        name: string;
        message: string;
        actual: any;
        expected: any;
        operator: string;
        generatedMessage: boolean;
        constructor(options?: {
            message?: string,
            actual?: any,
            expected?: any,
            operator?: string,
            stackStartFunction?: Function
        }): this
    }

    declare export function internal$fail(actual: any, expected: any, message: string, operator: string): void

    declare export function internal$ok(value: any, message?: string): void

    declare export function internal$equal(actual: any, expected: any, message?: string): void

    declare export function internal$notEqual(actual: any, expected: any, message?: string): void

    declare export function internal$deepEqual(actual: any, expected: any, message?: string): void

    declare export function internal$notDeepEqual(acutal: any, expected: any, message?: string): void

    declare export function internal$strictEqual(actual: any, expected: any, message?: string): void

    declare export function internal$notStrictEqual(actual: any, expected: any, message?: string): void

    declare export function internal$deepStrictEqual(actual: any, expected: any, message?: string): void

    declare export function internal$notDeepStrictEqual(actual: any, expected: any, message?: string): void

    declare export var throws: {
        (block: Function, message?: string): void,
        (block: Function, error: Function, message?: string): void,
        (block: Function, error: RegExp, message?: string): void,
        (block: Function, error: (err: any) => boolean, message?: string): void
    };

    declare export var doesNotThrow: {
        (block: Function, message?: string): void,
        (block: Function, error: Function, message?: string): void,
        (block: Function, error: RegExp, message?: string): void,
        (block: Function, error: (err: any) => boolean, message?: string): void
    };

    declare export function internal$ifError(value: any): void
}
declare module 'tty' {

    declare export function isatty(fd: number): boolean
    declare export type ReadStream = {
        close(): void,
        destroy(): void,
        bytesRead: number,
        path: string | Buffer,

        /**
         * events.EventEmitter
         *    1. open
           2. close
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "open", listener: (fd: number) => void): this,
        addListener(event: "close", listener: () => void): this,
        on(event: string, listener: Function): this,
        on(event: "open", listener: (fd: number) => void): this,
        on(event: "close", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "open", listener: (fd: number) => void): this,
        once(event: "close", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "open", listener: (fd: number) => void): this,
        prependListener(event: "close", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "open", listener: (fd: number) => void): this,
        prependOnceListener(event: "close", listener: () => void): this
    }
    declare export type WriteStream = {
        close(): void,
        bytesWritten: number,
        path: string | Buffer,

        /**
         * events.EventEmitter
         *    1. open
           2. close
        */
        addListener(event: string, listener: Function): this,
        addListener(event: "open", listener: (fd: number) => void): this,
        addListener(event: "close", listener: () => void): this,
        on(event: string, listener: Function): this,
        on(event: "open", listener: (fd: number) => void): this,
        on(event: "close", listener: () => void): this,
        once(event: string, listener: Function): this,
        once(event: "open", listener: (fd: number) => void): this,
        once(event: "close", listener: () => void): this,
        prependListener(event: string, listener: Function): this,
        prependListener(event: "open", listener: (fd: number) => void): this,
        prependListener(event: "close", listener: () => void): this,
        prependOnceListener(event: string, listener: Function): this,
        prependOnceListener(event: "open", listener: (fd: number) => void): this,
        prependOnceListener(event: "close", listener: () => void): this
    }
}
declare module 'domain' {

    declare export class Domain mixins events.EventEmitter, NodeJS$Domain {
        run(fn: Function): void;
        add(emitter: events.EventEmitter): void;
        remove(emitter: events.EventEmitter): void;
        bind(cb: (err: Error, data: any) => any): any;
        intercept(cb: (data: any) => any): any;
        dispose(): void;
        members: any[];
        enter(): void;
        exit(): void
    }
    declare export function create(): NodeJS$Domain
}
declare module 'constants' {
    declare export var E2BIG: number;
    declare export var EACCES: number;
    declare export var EADDRINUSE: number;
    declare export var EADDRNOTAVAIL: number;
    declare export var EAFNOSUPPORT: number;
    declare export var EAGAIN: number;
    declare export var EALREADY: number;
    declare export var EBADF: number;
    declare export var EBADMSG: number;
    declare export var EBUSY: number;
    declare export var ECANCELED: number;
    declare export var ECHILD: number;
    declare export var ECONNABORTED: number;
    declare export var ECONNREFUSED: number;
    declare export var ECONNRESET: number;
    declare export var EDEADLK: number;
    declare export var EDESTADDRREQ: number;
    declare export var EDOM: number;
    declare export var EEXIST: number;
    declare export var EFAULT: number;
    declare export var EFBIG: number;
    declare export var EHOSTUNREACH: number;
    declare export var EIDRM: number;
    declare export var EILSEQ: number;
    declare export var EINPROGRESS: number;
    declare export var EINTR: number;
    declare export var EINVAL: number;
    declare export var EIO: number;
    declare export var EISCONN: number;
    declare export var EISDIR: number;
    declare export var ELOOP: number;
    declare export var EMFILE: number;
    declare export var EMLINK: number;
    declare export var EMSGSIZE: number;
    declare export var ENAMETOOLONG: number;
    declare export var ENETDOWN: number;
    declare export var ENETRESET: number;
    declare export var ENETUNREACH: number;
    declare export var ENFILE: number;
    declare export var ENOBUFS: number;
    declare export var ENODATA: number;
    declare export var ENODEV: number;
    declare export var ENOENT: number;
    declare export var ENOEXEC: number;
    declare export var ENOLCK: number;
    declare export var ENOLINK: number;
    declare export var ENOMEM: number;
    declare export var ENOMSG: number;
    declare export var ENOPROTOOPT: number;
    declare export var ENOSPC: number;
    declare export var ENOSR: number;
    declare export var ENOSTR: number;
    declare export var ENOSYS: number;
    declare export var ENOTCONN: number;
    declare export var ENOTDIR: number;
    declare export var ENOTEMPTY: number;
    declare export var ENOTSOCK: number;
    declare export var ENOTSUP: number;
    declare export var ENOTTY: number;
    declare export var ENXIO: number;
    declare export var EOPNOTSUPP: number;
    declare export var EOVERFLOW: number;
    declare export var EPERM: number;
    declare export var EPIPE: number;
    declare export var EPROTO: number;
    declare export var EPROTONOSUPPORT: number;
    declare export var EPROTOTYPE: number;
    declare export var ERANGE: number;
    declare export var EROFS: number;
    declare export var ESPIPE: number;
    declare export var ESRCH: number;
    declare export var ETIME: number;
    declare export var ETIMEDOUT: number;
    declare export var ETXTBSY: number;
    declare export var EWOULDBLOCK: number;
    declare export var EXDEV: number;
    declare export var WSAEINTR: number;
    declare export var WSAEBADF: number;
    declare export var WSAEACCES: number;
    declare export var WSAEFAULT: number;
    declare export var WSAEINVAL: number;
    declare export var WSAEMFILE: number;
    declare export var WSAEWOULDBLOCK: number;
    declare export var WSAEINPROGRESS: number;
    declare export var WSAEALREADY: number;
    declare export var WSAENOTSOCK: number;
    declare export var WSAEDESTADDRREQ: number;
    declare export var WSAEMSGSIZE: number;
    declare export var WSAEPROTOTYPE: number;
    declare export var WSAENOPROTOOPT: number;
    declare export var WSAEPROTONOSUPPORT: number;
    declare export var WSAESOCKTNOSUPPORT: number;
    declare export var WSAEOPNOTSUPP: number;
    declare export var WSAEPFNOSUPPORT: number;
    declare export var WSAEAFNOSUPPORT: number;
    declare export var WSAEADDRINUSE: number;
    declare export var WSAEADDRNOTAVAIL: number;
    declare export var WSAENETDOWN: number;
    declare export var WSAENETUNREACH: number;
    declare export var WSAENETRESET: number;
    declare export var WSAECONNABORTED: number;
    declare export var WSAECONNRESET: number;
    declare export var WSAENOBUFS: number;
    declare export var WSAEISCONN: number;
    declare export var WSAENOTCONN: number;
    declare export var WSAESHUTDOWN: number;
    declare export var WSAETOOMANYREFS: number;
    declare export var WSAETIMEDOUT: number;
    declare export var WSAECONNREFUSED: number;
    declare export var WSAELOOP: number;
    declare export var WSAENAMETOOLONG: number;
    declare export var WSAEHOSTDOWN: number;
    declare export var WSAEHOSTUNREACH: number;
    declare export var WSAENOTEMPTY: number;
    declare export var WSAEPROCLIM: number;
    declare export var WSAEUSERS: number;
    declare export var WSAEDQUOT: number;
    declare export var WSAESTALE: number;
    declare export var WSAEREMOTE: number;
    declare export var WSASYSNOTREADY: number;
    declare export var WSAVERNOTSUPPORTED: number;
    declare export var WSANOTINITIALISED: number;
    declare export var WSAEDISCON: number;
    declare export var WSAENOMORE: number;
    declare export var WSAECANCELLED: number;
    declare export var WSAEINVALIDPROCTABLE: number;
    declare export var WSAEINVALIDPROVIDER: number;
    declare export var WSAEPROVIDERFAILEDINIT: number;
    declare export var WSASYSCALLFAILURE: number;
    declare export var WSASERVICE_NOT_FOUND: number;
    declare export var WSATYPE_NOT_FOUND: number;
    declare export var WSA_E_NO_MORE: number;
    declare export var WSA_E_CANCELLED: number;
    declare export var WSAEREFUSED: number;
    declare export var SIGHUP: number;
    declare export var SIGINT: number;
    declare export var SIGILL: number;
    declare export var SIGABRT: number;
    declare export var SIGFPE: number;
    declare export var SIGKILL: number;
    declare export var SIGSEGV: number;
    declare export var SIGTERM: number;
    declare export var SIGBREAK: number;
    declare export var SIGWINCH: number;
    declare export var SSL_OP_ALL: number;
    declare export var SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;
    declare export var SSL_OP_CIPHER_SERVER_PREFERENCE: number;
    declare export var SSL_OP_CISCO_ANYCONNECT: number;
    declare export var SSL_OP_COOKIE_EXCHANGE: number;
    declare export var SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;
    declare export var SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;
    declare export var SSL_OP_EPHEMERAL_RSA: number;
    declare export var SSL_OP_LEGACY_SERVER_CONNECT: number;
    declare export var SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: number;
    declare export var SSL_OP_MICROSOFT_SESS_ID_BUG: number;
    declare export var SSL_OP_MSIE_SSLV2_RSA_PADDING: number;
    declare export var SSL_OP_NETSCAPE_CA_DN_BUG: number;
    declare export var SSL_OP_NETSCAPE_CHALLENGE_BUG: number;
    declare export var SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: number;
    declare export var SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: number;
    declare export var SSL_OP_NO_COMPRESSION: number;
    declare export var SSL_OP_NO_QUERY_MTU: number;
    declare export var SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;
    declare export var SSL_OP_NO_SSLv2: number;
    declare export var SSL_OP_NO_SSLv3: number;
    declare export var SSL_OP_NO_TICKET: number;
    declare export var SSL_OP_NO_TLSv1: number;
    declare export var SSL_OP_NO_TLSv1_1: number;
    declare export var SSL_OP_NO_TLSv1_2: number;
    declare export var SSL_OP_PKCS1_CHECK_1: number;
    declare export var SSL_OP_PKCS1_CHECK_2: number;
    declare export var SSL_OP_SINGLE_DH_USE: number;
    declare export var SSL_OP_SINGLE_ECDH_USE: number;
    declare export var SSL_OP_SSLEAY_080_CLIENT_DH_BUG: number;
    declare export var SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: number;
    declare export var SSL_OP_TLS_BLOCK_PADDING_BUG: number;
    declare export var SSL_OP_TLS_D5_BUG: number;
    declare export var SSL_OP_TLS_ROLLBACK_BUG: number;
    declare export var ENGINE_METHOD_DSA: number;
    declare export var ENGINE_METHOD_DH: number;
    declare export var ENGINE_METHOD_RAND: number;
    declare export var ENGINE_METHOD_ECDH: number;
    declare export var ENGINE_METHOD_ECDSA: number;
    declare export var ENGINE_METHOD_CIPHERS: number;
    declare export var ENGINE_METHOD_DIGESTS: number;
    declare export var ENGINE_METHOD_STORE: number;
    declare export var ENGINE_METHOD_PKEY_METHS: number;
    declare export var ENGINE_METHOD_PKEY_ASN1_METHS: number;
    declare export var ENGINE_METHOD_ALL: number;
    declare export var ENGINE_METHOD_NONE: number;
    declare export var DH_CHECK_P_NOT_SAFE_PRIME: number;
    declare export var DH_CHECK_P_NOT_PRIME: number;
    declare export var DH_UNABLE_TO_CHECK_GENERATOR: number;
    declare export var DH_NOT_SUITABLE_GENERATOR: number;
    declare export var NPN_ENABLED: number;
    declare export var RSA_PKCS1_PADDING: number;
    declare export var RSA_SSLV23_PADDING: number;
    declare export var RSA_NO_PADDING: number;
    declare export var RSA_PKCS1_OAEP_PADDING: number;
    declare export var RSA_X931_PADDING: number;
    declare export var RSA_PKCS1_PSS_PADDING: number;
    declare export var POINT_CONVERSION_COMPRESSED: number;
    declare export var POINT_CONVERSION_UNCOMPRESSED: number;
    declare export var POINT_CONVERSION_HYBRID: number;
    declare export var O_RDONLY: number;
    declare export var O_WRONLY: number;
    declare export var O_RDWR: number;
    declare export var S_IFMT: number;
    declare export var S_IFREG: number;
    declare export var S_IFDIR: number;
    declare export var S_IFCHR: number;
    declare export var S_IFBLK: number;
    declare export var S_IFIFO: number;
    declare export var S_IFSOCK: number;
    declare export var S_IRWXU: number;
    declare export var S_IRUSR: number;
    declare export var S_IWUSR: number;
    declare export var S_IXUSR: number;
    declare export var S_IRWXG: number;
    declare export var S_IRGRP: number;
    declare export var S_IWGRP: number;
    declare export var S_IXGRP: number;
    declare export var S_IRWXO: number;
    declare export var S_IROTH: number;
    declare export var S_IWOTH: number;
    declare export var S_IXOTH: number;
    declare export var S_IFLNK: number;
    declare export var O_CREAT: number;
    declare export var O_EXCL: number;
    declare export var O_NOCTTY: number;
    declare export var O_DIRECTORY: number;
    declare export var O_NOATIME: number;
    declare export var O_NOFOLLOW: number;
    declare export var O_SYNC: number;
    declare export var O_SYMLINK: number;
    declare export var O_DIRECT: number;
    declare export var O_NONBLOCK: number;
    declare export var O_TRUNC: number;
    declare export var O_APPEND: number;
    declare export var F_OK: number;
    declare export var R_OK: number;
    declare export var W_OK: number;
    declare export var X_OK: number;
    declare export var UV_UDP_REUSEADDR: number;
    declare export var SIGQUIT: number;
    declare export var SIGTRAP: number;
    declare export var SIGIOT: number;
    declare export var SIGBUS: number;
    declare export var SIGUSR1: number;
    declare export var SIGUSR2: number;
    declare export var SIGPIPE: number;
    declare export var SIGALRM: number;
    declare export var SIGCHLD: number;
    declare export var SIGSTKFLT: number;
    declare export var SIGCONT: number;
    declare export var SIGSTOP: number;
    declare export var SIGTSTP: number;
    declare export var SIGTTIN: number;
    declare export var SIGTTOU: number;
    declare export var SIGURG: number;
    declare export var SIGXCPU: number;
    declare export var SIGXFSZ: number;
    declare export var SIGVTALRM: number;
    declare export var SIGPROF: number;
    declare export var SIGIO: number;
    declare export var SIGPOLL: number;
    declare export var SIGPWR: number;
    declare export var SIGSYS: number;
    declare export var SIGUNUSED: number;
    declare export var defaultCoreCipherList: string;
    declare export var defaultCipherList: string;
    declare export var ENGINE_METHOD_RSA: number;
    declare export var ALPN_ENABLED: number;
}
declare module 'process' {
    declare module.exports: typeof process
}
declare module 'v8' {
    declare interface HeapSpaceInfo {
        space_name: string,
            space_size: number,
            space_used_size: number,
            space_available_size: number,
            physical_space_size: number
    }
    declare export function getHeapStatistics(): {
        total_heap_size: number,
        total_heap_size_executable: number,
        total_physical_size: number,
        total_avaialble_size: number,
        used_heap_size: number,
        heap_size_limit: number
    }
    declare export function getHeapSpaceStatistics(): HeapSpaceInfo[]
    declare export function setFlagsFromString(flags: string): void
}
declare module 'timers' {
    declare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timer
    declare function clearTimeout(timeoutId: NodeJS$Timer): void
    declare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timer
    declare function clearInterval(intervalId: NodeJS$Timer): void
    declare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): any
    declare function clearImmediate(immediateId: any): void
}
declare module 'console' {
    declare module.exports: typeof console
}