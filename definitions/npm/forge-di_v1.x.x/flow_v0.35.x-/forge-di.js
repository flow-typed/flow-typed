// @flow
/**
 * Flowtype definitions for forge-di
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'forge-di' {
    declare module.exports: typeof Forge
    declare interface Forge$IContext {
        new(): Forge$IContext,
        bindings: Forge$IBinding[],
            has(binding: Forge$IBinding): boolean,
            push(binding: Forge$IBinding): void,
            pop(): Forge$IBinding,
            toString(indent: number): string
    }

    declare interface Forge$IType {
        new(...args: any[]): any
    }


    /**
     * Represents arguments to help with resolving a binding.
     */
    declare interface Forge$IBindingArguments {
        [name: string]: any
    }


    /**
     * Represents a binding between a name, type/instance/function and optional hint.
     */
    declare interface Forge$IBinding {

        /**
         * The forge that contains this binding. 
         */
        forge: Forge,

            /**
             * The binding name. 
             */
            name: string,

            /**
             * Alias mapping to this binding. 
             */
            to: Forge$IBinding,

            /**
             * Alias mapping to this binding. 
             */
            as: Forge$IBinding,

            /**
             * Whether or not this binding is currently resolving. 
             */
            isResolving: boolean,

            /**
             * The resolver for this binding. 
             */
            resolver: Forge$IResolver,

            /**
             * The lifecycle associated with this binding. Defaults to singleton. 
             */
            lifecycle: Forge$ILifecycle,

            /**
             * The predicate associated with this binding. Used to support hints. 
             */
            predicate: Forge$IPredicate,

            /**
             * The additional binding arguments to help resolve dependencies. 
             */
            arguments: Forge$IBindingArguments,

            /**
             * Checks whether or not this binding matches the hint by executing the predicate.
             * @param  The hint to check against.
             */
            matches(hint: string): boolean,

            /**
             * Registers a type to a binding. This type must have a constructor.
             * @param  The target type.
             */
            type<T>(target: T): Forge$IBinding,

            /**
             * Registers a type to a binding. This must be a callable function.
             * @param  The target function.
             */
            function<T>(target: T): Forge$IBinding,

            /**
             * Registeres an instance to a binding. This instance will always be returned.
             * @param  The target instance.
             */
            instance<T>(target: T): Forge$IBinding,

            /**
             * Configures this binding lifecycle as a singleton. This is the default lifecycle.
             */
            singleton(): Forge$IBinding,

            /**
             * Configures this binding lifecycle as transient.
             * New instances will be created, if this is a type based binding, on each get.
             */
            transient(): Forge$IBinding,

            /**
             * Registers a predicate for this binding.
             * @param  The predicate.
             */
            when(predicate: Forge$IPredicate): Forge$IBinding,

            /**
             * Registers a hint for this binding.
             * @param  The hint.
             */
            when(hint: string): Forge$IBinding,

            /**
             * Registers additional binding arguments to help with resolving.
             * @param  The additional binding arguments.
             */
            with(args: Forge$IBindingArguments): Forge$IBinding,

            /**
             * Returns a string representing this binding.
             */
            toString(): string
    }


    /**
     * Represents a binding map. 
     */
    declare interface Forge$IBindingMap {
        [name: string]: Forge$IBinding[]
    }


    /**
     * Represents a predicate. 
     */
    declare interface Forge$IPredicate {

        /**
         * Returns whether or not the hit satisfies this predicate.
         * @param  The hint to check against.
         */
        (hint: string): boolean
    }


    /**
     * Represents a resolver. 
     */
    declare interface Forge$IResolver {

        /**
         * Resolves a specific type.
         */
        resolve<T>(): T
    }


    /**
     * Represents a binding lifecycle. 
     */
    declare interface Forge$ILifecycle {

        /**
         * Returns the instance from a resolver based on the configured lifecycle.
         * @param  The type resolver.
         */
        getInstance<T>(resolver: Forge$IResolver): T
    }
}