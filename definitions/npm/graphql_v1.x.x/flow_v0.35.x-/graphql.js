/**
 * Flowtype definitions for graphql
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'graphql' {

}
declare module 'graphql/graphql' {



    /**
     * This is the primary entry point function for fulfilling GraphQL operations
     * by parsing, validating, and executing a GraphQL document along side a
    GraphQL schema.

    More sophisticated GraphQL servers, such as those which persist queries,
    may wish to separate the validation and execution phases to a static time
    tooling step, and a server runtime step.

    schema:
        The GraphQL type system to use when validating and executing a query.
    requestString:
        A GraphQL language formatted string representing the requested operation.
    rootValue:
        The value provided as the first argument to resolver functions on the top
        level type (e.g. the query object type).
    variableValues:
        A mapping of variable name to runtime value to use for all variables
        defined in the requestString.
    operationName:
        The name of the operation to use if requestString contains multiple
        possible operations. Can be omitted if requestString contains only
        one operation.
    */
    declare function graphql(
        schema: GraphQLSchema,
        requestString: string,
        rootValue?: any,
        contextValue?: any,
        variableValues?: {
            [key: string]: any
        },
        operationName?: string): Promise<GraphQLResult >

        /**
         * The result of a GraphQL parse, validation and execution.
         * 
        `data` is the result of a successful execution of the query.
        `errors` is included when any errors occurred as a non-empty array.
        */
        declare type GraphQLResult = {
            data?: Object,
            errors?: Array<GraphQLError >
        };
}
declare module 'graphql/language' {

}
declare module 'graphql/language/index' {

}
declare module 'graphql/language/ast' {


    /**
     * Contains a range of UTF-8 character offsets and token references that
     * identify the region of the source from which the AST derived.
     */
    declare export type Location = {

        /**
         * The character offset at which this Node begins.
         */
        start: number,

        /**
         * The character offset at which this Node ends.
         */
        end: number,

        /**
         * The Token at which this Node begins.
         */
        startToken: Token,

        /**
         * The Token at which this Node ends.
         */
        endToken: Token,

        /**
         * The Source document the AST represents.
         */
        source: Source
    };

    /**
     * Represents a range of characters represented by a lexical token
     * within a Source.
     */
    declare export type Token = {

        /**
         * The kind of Token.
         */
        kind: "<SOF>" |
            "<EOF>" |
            "!" |
            "$" |
            "(" |
            ")" |
            "..." |
            ":" |
            "=" |
            "@" |
            "[" |
            "]" |
            "{" |
            "|" |
            "}" |
            "Name" |
            "Int" |
            "Float" |
            "String" |
            "Comment",

        /**
         * The character offset at which this Node begins.
         */
        start: number,

        /**
         * The character offset at which this Node ends.
         */
        end: number,

        /**
         * The 1-indexed line number on which this Token appears.
         */
        line: number,

        /**
         * The 1-indexed column number at which this Token begins.
         */
        column: number,

        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         */
        value: string | void,

        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
        the last.
        */
        prev?: Token,
        next?: Token
    };

    /**
     * The list of all possible AST node types.
     */
    declare export type Node = Name |
        Document |
        OperationDefinition |
        VariableDefinition |
        Variable |
        SelectionSet |
        Field |
        Argument |
        FragmentSpread |
        InlineFragment |
        FragmentDefinition |
        IntValue |
        FloatValue |
        StringValue |
        BooleanValue |
        EnumValue |
        ListValue |
        ObjectValue |
        ObjectField |
        Directive |
        NamedType |
        ListType |
        NonNullType |
        SchemaDefinition |
        OperationTypeDefinition |
        ScalarTypeDefinition |
        ObjectTypeDefinition |
        FieldDefinition |
        InputValueDefinition |
        InterfaceTypeDefinition |
        UnionTypeDefinition |
        EnumTypeDefinition |
        EnumValueDefinition |
        InputObjectTypeDefinition |
        TypeExtensionDefinition |
        DirectiveDefinition;
    declare export type Name = {
        kind: "Name",
        loc?: Location,
        value: string
    };
    declare export type Document = {
        kind: "Document",
        loc?: Location,
        definitions: Array<Definition >
    };
    declare export type Definition = OperationDefinition | FragmentDefinition | TypeSystemDefinition;
    declare export type OperationDefinition = {
        kind: "OperationDefinition",
        loc?: Location,
        operation: OperationType,
        name?: Name,
        variableDefinitions?: Array<VariableDefinition>,
        directives?: Array<Directive>,
        selectionSet: SelectionSet
    };
    declare export type OperationType = "query" | "mutation" | "subscription";
    declare export type VariableDefinition = {
        kind: "VariableDefinition",
        loc?: Location,
        variable: Variable,
        type: Type,
        defaultValue?: Value
    };
    declare export type Variable = {
        kind: "Variable",
        loc?: Location,
        name: Name
    };
    declare export type SelectionSet = {
        kind: "SelectionSet",
        loc?: Location,
        selections: Array<Selection >
    };
    declare export type Selection = Field | FragmentSpread | InlineFragment;
    declare export type Field = {
        kind: "Field",
        loc?: Location,
        alias?: Name,
        name: Name,
        arguments?: Array<Argument>,
        directives?: Array<Directive>,
        selectionSet?: SelectionSet
    };
    declare export type Argument = {
        kind: "Argument",
        loc?: Location,
        name: Name,
        value: Value
    };
    declare export type FragmentSpread = {
        kind: "FragmentSpread",
        loc?: Location,
        name: Name,
        directives?: Array<Directive >
    };
    declare export type InlineFragment = {
        kind: "InlineFragment",
        loc?: Location,
        typeCondition?: NamedType,
        directives?: Array<Directive>,
        selectionSet: SelectionSet
    };
    declare export type FragmentDefinition = {
        kind: "FragmentDefinition",
        loc?: Location,
        name: Name,
        typeCondition: NamedType,
        directives?: Array<Directive>,
        selectionSet: SelectionSet
    };
    declare export type Value = Variable |
        IntValue |
        FloatValue |
        StringValue |
        BooleanValue |
        EnumValue |
        ListValue |
        ObjectValue;
    declare export type IntValue = {
        kind: "IntValue",
        loc?: Location,
        value: string
    };
    declare export type FloatValue = {
        kind: "FloatValue",
        loc?: Location,
        value: string
    };
    declare export type StringValue = {
        kind: "StringValue",
        loc?: Location,
        value: string
    };
    declare export type BooleanValue = {
        kind: "BooleanValue",
        loc?: Location,
        value: boolean
    };
    declare export type EnumValue = {
        kind: "EnumValue",
        loc?: Location,
        value: string
    };
    declare export type ListValue = {
        kind: "ListValue",
        loc?: Location,
        values: Array<Value >
    };
    declare export type ObjectValue = {
        kind: "ObjectValue",
        loc?: Location,
        fields: Array<ObjectField >
    };
    declare export type ObjectField = {
        kind: "ObjectField",
        loc?: Location,
        name: Name,
        value: Value
    };
    declare export type Directive = {
        kind: "Directive",
        loc?: Location,
        name: Name,
        arguments?: Array<Argument >
    };
    declare export type Type = NamedType | ListType | NonNullType;
    declare export type NamedType = {
        kind: "NamedType",
        loc?: Location,
        name: Name
    };
    declare export type ListType = {
        kind: "ListType",
        loc?: Location,
        type: Type
    };
    declare export type NonNullType = {
        kind: "NonNullType",
        loc?: Location,
        type: NamedType | ListType
    };
    declare export type TypeSystemDefinition = SchemaDefinition | TypeDefinition | TypeExtensionDefinition | DirectiveDefinition;
    declare export type SchemaDefinition = {
        kind: "SchemaDefinition",
        loc?: Location,
        directives: Array<Directive>,
        operationTypes: Array<OperationTypeDefinition >
    };
    declare export type OperationTypeDefinition = {
        kind: "OperationTypeDefinition",
        loc?: Location,
        operation: OperationType,
        type: NamedType
    };
    declare export type TypeDefinition = ScalarTypeDefinition |
        ObjectTypeDefinition |
        InterfaceTypeDefinition |
        UnionTypeDefinition |
        EnumTypeDefinition |
        InputObjectTypeDefinition;
    declare export type ScalarTypeDefinition = {
        kind: "ScalarTypeDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive >
    };
    declare export type ObjectTypeDefinition = {
        kind: "ObjectTypeDefinition",
        loc?: Location,
        name: Name,
        interfaces?: Array<NamedType>,
        directives?: Array<Directive>,
        fields: Array<FieldDefinition >
    };
    declare export type FieldDefinition = {
        kind: "FieldDefinition",
        loc?: Location,
        name: Name,
        arguments: Array<InputValueDefinition>,
        type: Type,
        directives?: Array<Directive >
    };
    declare export type InputValueDefinition = {
        kind: "InputValueDefinition",
        loc?: Location,
        name: Name,
        type: Type,
        defaultValue?: Value,
        directives?: Array<Directive >
    };
    declare export type InterfaceTypeDefinition = {
        kind: "InterfaceTypeDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive>,
        fields: Array<FieldDefinition >
    };
    declare export type UnionTypeDefinition = {
        kind: "UnionTypeDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive>,
        types: Array<NamedType >
    };
    declare export type EnumTypeDefinition = {
        kind: "EnumTypeDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive>,
        values: Array<EnumValueDefinition >
    };
    declare export type EnumValueDefinition = {
        kind: "EnumValueDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive >
    };
    declare export type InputObjectTypeDefinition = {
        kind: "InputObjectTypeDefinition",
        loc?: Location,
        name: Name,
        directives?: Array<Directive>,
        fields: Array<InputValueDefinition >
    };
    declare export type TypeExtensionDefinition = {
        kind: "TypeExtensionDefinition",
        loc?: Location,
        definition: ObjectTypeDefinition
    };
    declare export type DirectiveDefinition = {
        kind: "DirectiveDefinition",
        loc?: Location,
        name: Name,
        arguments?: Array<InputValueDefinition>,
        locations: Array<Name >
    };
}
declare module 'graphql/language/kinds' {
    declare var NAME: "Name";
    declare var DOCUMENT: "Document";
    declare var OPERATION_DEFINITION: "OperationDefinition";
    declare var VARIABLE_DEFINITION: "VariableDefinition";
    declare var VARIABLE: "Variable";
    declare var SELECTION_SET: "SelectionSet";
    declare var FIELD: "Field";
    declare var ARGUMENT: "Argument";
    declare var FRAGMENT_SPREAD: "FragmentSpread";
    declare var INLINE_FRAGMENT: "InlineFragment";
    declare var FRAGMENT_DEFINITION: "FragmentDefinition";
    declare var INT: "IntValue";
    declare var FLOAT: "FloatValue";
    declare var STRING: "StringValue";
    declare var BOOLEAN: "BooleanValue";
    declare var ENUM: "EnumValue";
    declare var LIST: "ListValue";
    declare var OBJECT: "ObjectValue";
    declare var OBJECT_FIELD: "ObjectField";
    declare var DIRECTIVE: "Directive";
    declare var NAMED_TYPE: "NamedType";
    declare var LIST_TYPE: "ListType";
    declare var NON_NULL_TYPE: "NonNullType";
    declare var SCHEMA_DEFINITION: "SchemaDefinition";
    declare var OPERATION_TYPE_DEFINITION: "OperationTypeDefinition";
    declare var SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition";
    declare var OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition";
    declare var FIELD_DEFINITION: "FieldDefinition";
    declare var INPUT_VALUE_DEFINITION: "InputValueDefinition";
    declare var INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition";
    declare var UNION_TYPE_DEFINITION: "UnionTypeDefinition";
    declare var ENUM_TYPE_DEFINITION: "EnumTypeDefinition";
    declare var ENUM_VALUE_DEFINITION: "EnumValueDefinition";
    declare var INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition";
    declare var TYPE_EXTENSION_DEFINITION: "TypeExtensionDefinition";
    declare var DIRECTIVE_DEFINITION: "DirectiveDefinition";
}
declare module 'graphql/language/lexer' {




    /**
     * Given a Source object, this returns a Lexer for that source.
     * A Lexer is a stateful stream generator in that every time
    it is advanced, it returns the next token in the Source. Assuming the
    source lexes, the final Token emitted by the lexer will be of kind
    EOF, after which the lexer will repeatedly return the same EOF token
    whenever called.
    */
    declare function createLexer<TOptions>(source: Source, options: TOptions): Lexer<TOptions >

        /**
         * The return type of createLexer.
         */
        declare type Lexer<TOptions>= {
            source: Source,
            options: TOptions,

            /**
             * The previously focused non-ignored token.
             */
            lastToken: Token,

            /**
             * The currently focused non-ignored token.
             */
            token: Token,

            /**
             * The (1-indexed) line containing the current token.
             */
            line: number,

            /**
             * The character offset at which the current line begins.
             */
            lineStart: number,

            /**
             * Advances the token stream to the next non-ignored token.
             */
            advance(): Token
        };
    declare var TokenKind: {
        SOF: "<SOF>",
        EOF: "<EOF>",
        BANG: "!",
        DOLLAR: "$",
        PAREN_L: "(",
        PAREN_R: ")",
        SPREAD: "...",
        COLON: ":",
        EQUALS: "=",
        AT: "@",
        BRACKET_L: "[",
        BRACKET_R: "]",
        BRACE_L: "{",
        PIPE: "|",
        BRACE_R: "}",
        NAME: "Name",
        INT: "Int",
        FLOAT: "Float",
        STRING: "String",
        COMMENT: "Comment"
    };

    /**
     * A helper function to describe a token as a string for debugging
     */
    declare function getTokenDesc(token: Token): string
}
declare module 'graphql/language/location' {

    declare interface SourceLocation {
        line: number,
            column: number
    }
    declare function getLocation(source: Source, position: number): SourceLocation
}
declare module 'graphql/language/parser' {




    /**
     * Configuration options to control parser behavior
     */
    declare type ParseOptions = {

        /**
         * By default, the parser creates AST nodes that know the location
         * in the source that they correspond to. This configuration flag
        disables that behavior for performance or testing.
        */
        noLocation?: boolean
    };

    /**
     * Given a GraphQL source, parses it into a Document.
     * Throws GraphQLError if a syntax error is encountered.
     */
    declare function parse(source: string | Source, options?: ParseOptions): Document

    /**
     * Given a string containing a GraphQL value, parse the AST for that value.
     * Throws GraphQLError if a syntax error is encountered.

    This is useful within tools that operate upon GraphQL Values directly and
    in isolation of complete GraphQL documents.
    */
    declare function parseValue(source: Source | string, options?: ParseOptions): Value
    declare function parseConstValue<TOptions>(lexer: Lexer<TOptions>): Value

    /**
     * Type :
     *    - NamedType
       - ListType
       - NonNullType
    */
    declare function parseType<TOptions>(lexer: Lexer<TOptions>): Type

    /**
     * NamedType : Name
     */
    declare function parseNamedType<TOptions>(lexer: Lexer<TOptions>): NamedType
}
declare module 'graphql/language/printer' {

    /**
     * Converts an AST into a string, using one set of reasonable
     * formatting rules.
     */
    declare function print(ast: any): string
}
declare module 'graphql/language/source' {
    declare class Source {
        body: string;
        name: string;
        constructor(body: string, name?: string): this
    }
}
declare module 'graphql/language/visitor' {
    declare var QueryDocumentKeys: {
        Name: any[],
        Document: string[],
        OperationDefinition: string[],
        VariableDefinition: string[],
        Variable: string[],
        SelectionSet: string[],
        Field: string[],
        Argument: string[],
        FragmentSpread: string[],
        InlineFragment: string[],
        FragmentDefinition: string[],
        IntValue: number[],
        FloatValue: number[],
        StringValue: string[],
        BooleanValue: boolean[],
        EnumValue: any[],
        ListValue: string[],
        ObjectValue: string[],
        ObjectField: string[],
        Directive: string[],
        NamedType: string[],
        ListType: string[],
        NonNullType: string[],
        ObjectTypeDefinition: string[],
        FieldDefinition: string[],
        InputValueDefinition: string[],
        InterfaceTypeDefinition: string[],
        UnionTypeDefinition: string[],
        ScalarTypeDefinition: string[],
        EnumTypeDefinition: string[],
        EnumValueDefinition: string[],
        InputObjectTypeDefinition: string[],
        TypeExtensionDefinition: string[]
    };
    declare var BREAK: any;
    declare function visit(root: any, visitor: any, keyMap: any): any
    declare function visitInParallel(visitors: any): any
    declare function visitWithTypeInfo(typeInfo: any, visitor: any): any
}
declare module 'graphql/type' {

}
declare module 'graphql/type/index' {

}
declare module 'graphql/type/definition' {



    /**
     * These are all of the possible kinds of types.
     */
    declare export type GraphQLType = GraphQLScalarType |
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLUnionType |
        GraphQLEnumType |
        GraphQLInputObjectType |
        GraphQLList<any >
        |
        GraphQLNonNull<any>;
    declare export function isType(type: any): GraphQLType

    /**
     * These types may be used as input types for arguments and directives.
     */
    declare export type GraphQLInputType = GraphQLScalarType |
        GraphQLEnumType |
        GraphQLInputObjectType |
        GraphQLList<any >
        |
        GraphQLNonNull<GraphQLScalarType | GraphQLEnumType | GraphQLInputObjectType | GraphQLList<any >> ;
    declare export function isInputType(type: GraphQLType): GraphQLInputType

    /**
     * These types may be used as output types as the result of fields.
     */
    declare export type GraphQLOutputType = GraphQLScalarType |
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLUnionType |
        GraphQLEnumType |
        GraphQLList<any >
        |
        GraphQLNonNull<GraphQLScalarType |
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLUnionType |
        GraphQLEnumType |
        GraphQLList<any >> ;
    declare export function isOutputType(type: GraphQLType): GraphQLOutputType

    /**
     * These types may describe types which may be leaf values.
     */
    declare export type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;
    declare export function isLeafType(type: GraphQLType): GraphQLLeafType

    /**
     * These types may describe the parent context of a selection set.
     */
    declare export type GraphQLCompositeType = GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType;
    declare export function isCompositeType(type: GraphQLType): GraphQLCompositeType

    /**
     * These types may describe the parent context of a selection set.
     */
    declare export type GraphQLAbstractType = GraphQLInterfaceType | GraphQLUnionType;
    declare export function isAbstractType(type: GraphQLType): GraphQLAbstractType

    /**
     * These types can all accept null as a value.
     */
    declare export type GraphQLNullableType = GraphQLScalarType |
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLUnionType |
        GraphQLEnumType |
        GraphQLInputObjectType |
        GraphQLList<any>;
    declare export function getNullableType<T>(type: T): (T & GraphQLNullableType)

    /**
     * These named types do not include modifiers like List or NonNull.
     */
    declare export type GraphQLNamedType = GraphQLScalarType |
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLUnionType |
        GraphQLEnumType |
        GraphQLInputObjectType;
    declare export function getNamedType(type: GraphQLType): GraphQLNamedType

    /**
     * Used while defining GraphQL types to allow for circular references in
     * otherwise immutable type definitions.
     */
    declare type Thunk<T>= (() => T) | T;

    /**
     * Scalar Type Definition
     * 
    The leaf values of any request and input values to arguments are
    Scalars (or Enums) and are defined with a name and a series of functions
    used to parse input from ast or variables and to ensure validity.

    Example:

         const OddType = new GraphQLScalarType({
           name: 'Odd',
           serialize(value) {
             return value % 2 === 1 ? value : null;
           }
         });
    */
    declare class GraphQLScalarType {
        name: string;
        description: string;
        constructor(config: GraphQLScalarTypeConfig<any, any>): this;
        serialize(value: any): any;
        parseValue(value: any): any;
        parseLiteral(valueAST: Value): any;
        toString(): string
    }
    declare export interface GraphQLScalarTypeConfig<TInternal, TExternal>{
        name: string,
        description?: string,
        serialize: (value: any) => TInternal,
        parseValue?: (value: any) => TExternal,
        parseLiteral?: (valueAST: Value) => TInternal
    }

    /**
     * Object Type Definition
     * 
    Almost all of the GraphQL types you define will be object types. Object types
    have a name, but most importantly describe their fields.

    Example:

         const AddressType = new GraphQLObjectType({
           name: 'Address',
           fields: {
             street: { type: GraphQLString },
             number: { type: GraphQLInt },
             formatted: {
               type: GraphQLString,
               resolve(obj) {
                 return obj.number + ' ' + obj.street
               }
             }
           }
         });

    When two types need to refer to each other, or a type needs to refer to
    itself in a field, you can use a function expression (aka a closure or a
    thunk) to supply the fields lazily.

    Example:

         const PersonType = new GraphQLObjectType({
           name: 'Person',
           fields: () => ({
             name: { type: GraphQLString },
             bestFriend: { type: PersonType },
           })
         });
    */
    declare class GraphQLObjectType {
        name: string;
        description: string;
        isTypeOf: GraphQLIsTypeOfFn;
        constructor(config: GraphQLObjectTypeConfig<any>): this;
        getFields(): GraphQLFieldDefinitionMap;
        getInterfaces(): Array<GraphQLInterfaceType>;
        toString(): string
    }
    declare export interface GraphQLObjectTypeConfig<TSource>{
        name: string,
        interfaces?: Thunk<Array<GraphQLInterfaceType >> ,
        fields: Thunk<GraphQLFieldConfigMap<TSource >> ,
        isTypeOf?: GraphQLIsTypeOfFn,
        description?: string
    }
    declare export type GraphQLTypeResolveFn = (value: any, context: any, info: GraphQLResolveInfo) => GraphQLObjectType;
    declare export type GraphQLIsTypeOfFn = (source: any, context: any, info: GraphQLResolveInfo) => boolean;
    declare export type GraphQLFieldResolveFn<TSource>= (
        source: TSource,
        args: {
            [argName: string]: any
        },
        context: any,
        info: GraphQLResolveInfo) => any;
    declare export interface GraphQLResolveInfo {
        fieldName: string,
            fieldASTs: Array<Field>,
            returnType: GraphQLOutputType,
            parentType: GraphQLCompositeType,
            path: Array<string | number>,
            schema: GraphQLSchema,
            fragments: {
                [fragmentName: string]: FragmentDefinition
            },
            rootValue: any,
            operation: OperationDefinition,
            variableValues: {
                [variableName: string]: any
            }
    }
    declare export interface GraphQLFieldConfig<TSource>{
        type: GraphQLOutputType,
        args?: GraphQLFieldConfigArgumentMap,
        resolve?: GraphQLFieldResolveFn<TSource>,
        deprecationReason?: string,
        description?: string
    }
    declare export interface GraphQLFieldConfigArgumentMap {
        [argName: string]: GraphQLArgumentConfig
    }
    declare export interface GraphQLArgumentConfig {
        type: GraphQLInputType,
            defaultValue?: any,
            description?: string
    }
    declare export interface GraphQLFieldConfigMap<TSource>{
        [fieldName: string]: GraphQLFieldConfig<TSource >
    }
    declare export interface GraphQLFieldDefinition {
        name: string,
            description: string,
            type: GraphQLOutputType,
            args: Array<GraphQLArgument>,
            resolve: GraphQLFieldResolveFn<any>,
            isDeprecated: boolean,
            deprecationReason: string
    }
    declare export interface GraphQLArgument {
        name: string,
            type: GraphQLInputType,
            defaultValue?: any,
            description?: string
    }
    declare export interface GraphQLFieldDefinitionMap {
        [fieldName: string]: GraphQLFieldDefinition
    }

    /**
     * Interface Type Definition
     * 
    When a field can return one of a heterogeneous set of types, a Interface type
    is used to describe what types are possible, what fields are in common across
    all types, as well as a function to determine which type is actually used
    when the field is resolved.

    Example:

         const EntityType = new GraphQLInterfaceType({
           name: 'Entity',
           fields: {
             name: { type: GraphQLString }
           }
         });
    */
    declare class GraphQLInterfaceType {
        name: string;
        description: string;
        resolveType: GraphQLTypeResolveFn;
        constructor(config: GraphQLInterfaceTypeConfig): this;
        getFields(): GraphQLFieldDefinitionMap;
        toString(): string
    }
    declare export interface GraphQLInterfaceTypeConfig {
        name: string,
            fields: Thunk<GraphQLFieldConfigMap<any >> ,

            /**
             * Optionally provide a custom type resolver function. If one is not provided,
             * the default implementation will call `isTypeOf` on each implementing
            Object type.
            */
            resolveType?: GraphQLTypeResolveFn,
            description?: string
    }

    /**
     * Union Type Definition
     * 
    When a field can return one of a heterogeneous set of types, a Union type
    is used to describe what types are possible as well as providing a function
    to determine which type is actually used when the field is resolved.

    Example:

         const PetType = new GraphQLUnionType({
           name: 'Pet',
           types: [ DogType, CatType ],
           resolveType(value) {
             if (value instanceof Dog) {
               return DogType;
             }
             if (value instanceof Cat) {
               return CatType;
             }
           }
         });
    */
    declare class GraphQLUnionType {
        name: string;
        description: string;
        resolveType: GraphQLTypeResolveFn;
        constructor(config: GraphQLUnionTypeConfig): this;
        getTypes(): Array<GraphQLObjectType>;
        toString(): string
    }
    declare export interface GraphQLUnionTypeConfig {
        name: string,
            types: Thunk<Array<GraphQLObjectType >> ,

            /**
             * Optionally provide a custom type resolver function. If one is not provided,
             * the default implementation will call `isTypeOf` on each implementing
            Object type.
            */
            resolveType?: GraphQLTypeResolveFn,
            description?: string
    }

    /**
     * Enum Type Definition
     * 
    Some leaf values of requests and input values are Enums. GraphQL serializes
    Enum values as strings, however internally Enums can be represented by any
    kind of type, often integers.

    Example:

         const RGBType = new GraphQLEnumType({
           name: 'RGB',
           values: {
             RED: { value: 0 },
             GREEN: { value: 1 },
             BLUE: { value: 2 }
           }
         });

    Note: If a value is not provided in a definition, the name of the enum value
    will be used as its internal value.
    */
    declare class GraphQLEnumType {
        name: string;
        description: string;
        constructor(config: GraphQLEnumTypeConfig): this;
        getValues(): Array<GraphQLEnumValueDefinition>;
        serialize(value: any): string;
        parseValue(value: any): any;
        parseLiteral(valueAST: Value): any;
        toString(): string
    }
    declare export interface GraphQLEnumTypeConfig {
        name: string,
            values: GraphQLEnumValueConfigMap,
            description?: string
    }
    declare export interface GraphQLEnumValueConfigMap {
        [valueName: string]: GraphQLEnumValueConfig
    }
    declare export interface GraphQLEnumValueConfig {
        value?: any,
            deprecationReason?: string,
            description?: string
    }
    declare export interface GraphQLEnumValueDefinition {
        name: string,
            description: string,
            deprecationReason: string,
            value: any
    }

    /**
     * Input Object Type Definition
     * 
    An input object defines a structured collection of fields which may be
    supplied to a field argument.

    Using `NonNull` will ensure that a value must be provided by the query

    Example:

         const GeoPoint = new GraphQLInputObjectType({
           name: 'GeoPoint',
           fields: {
             lat: { type: new GraphQLNonNull(GraphQLFloat) },
             lon: { type: new GraphQLNonNull(GraphQLFloat) },
             alt: { type: GraphQLFloat, defaultValue: 0 },
           }
         });
    */
    declare class GraphQLInputObjectType {
        name: string;
        description: string;
        constructor(config: GraphQLInputObjectTypeConfig): this;
        getFields(): GraphQLInputFieldDefinitionMap;
        toString(): string
    }
    declare export interface GraphQLInputObjectTypeConfig {
        name: string,
            fields: Thunk<GraphQLInputFieldConfigMap>,
            description?: string
    }
    declare export interface GraphQLInputFieldConfig {
        type: GraphQLInputType,
            defaultValue?: any,
            description?: string
    }
    declare export interface GraphQLInputFieldConfigMap {
        [fieldName: string]: GraphQLInputFieldConfig
    }
    declare export interface GraphQLInputFieldDefinition {
        name: string,
            type: GraphQLInputType,
            defaultValue?: any,
            description?: string
    }
    declare export interface GraphQLInputFieldDefinitionMap {
        [fieldName: string]: GraphQLInputFieldDefinition
    }

    /**
     * List Modifier
     * 
    A list is a kind of type marker, a wrapping type which points to another
    type. Lists are often created within the context of defining the fields of
    an object type.

    Example:

         const PersonType = new GraphQLObjectType({
           name: 'Person',
           fields: () => ({
             parents: { type: new GraphQLList(Person) },
             children: { type: new GraphQLList(Person) },
           })
         })
    */
    declare class GraphQLList<T>{
        ofType: T;
        constructor(type: T): this;
        toString(): string
    }

    /**
     * Non-Null Modifier
     * 
    A non-null is a kind of type marker, a wrapping type which points to another
    type. Non-null types enforce that their values are never null and can ensure
    an error is raised if this ever occurs during a request. It is useful for
    fields which you can make a strong guarantee on non-nullability, for example
    usually the id field of a database row will never be null.

    Example:

         const RowType = new GraphQLObjectType({
           name: 'Row',
           fields: () => ({
             id: { type: new GraphQLNonNull(GraphQLString) },
           })
         })

    Note: the enforcement of non-nullability occurs within the executor.
    */
    declare class GraphQLNonNull<T>{
        ofType: T;
        constructor(type: T): this;
        toString(): string
    }
}
declare module 'graphql/type/directives' {

    declare var DirectiveLocation: {
        QUERY: "QUERY",
        MUTATION: "MUTATION",
        SUBSCRIPTION: "SUBSCRIPTION",
        FIELD: "FIELD",
        FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
        FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
        INLINE_FRAGMENT: "INLINE_FRAGMENT",
        SCHEMA: "SCHEMA",
        SCALAR: "SCALAR",
        OBJECT: "OBJECT",
        FIELD_DEFINITION: "FIELD_DEFINITION",
        ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
        INTERFACE: "INTERFACE",
        UNION: "UNION",
        ENUM: "ENUM",
        ENUM_VALUE: "ENUM_VALUE",
        INPUT_OBJECT: "INPUT_OBJECT",
        INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    };
    declare type DirectiveLocationEnum = any;

    /**
     * Directives are used by the GraphQL runtime as a way of modifying execution
     * behavior. Type system creators will usually not create these directly.
     */
    declare class GraphQLDirective {
        name: string;
        description: string;
        locations: Array<DirectiveLocationEnum>;
        args: Array<GraphQLArgument>;
        constructor(config: GraphQLDirectiveConfig): this
    }
    declare interface GraphQLDirectiveConfig {
        name: string,
            description?: string,
            locations: Array<DirectiveLocationEnum>,
            args?: GraphQLFieldConfigArgumentMap
    }
    declare var GraphQLIncludeDirective: GraphQLDirective;
    declare var GraphQLSkipDirective: GraphQLDirective;
    declare var DEFAULT_DEPRECATION_REASON: "No longer supported";
    declare var GraphQLDeprecatedDirective: GraphQLDirective;
    declare export var specifiedDirectives: Array<GraphQLDirective>;
}
declare module 'graphql/type/introspection' {

    declare var ___Schema: GraphQLObjectType;
    declare var ___Directive: GraphQLObjectType;
    declare var ___DirectiveLocation: GraphQLEnumType;
    declare var ___Type: GraphQLObjectType;
    declare var ___Field: GraphQLObjectType;
    declare var ___InputValue: GraphQLObjectType;
    declare var ___EnumValue: GraphQLObjectType;
    declare var TypeKind: {
        SCALAR: "SCALAR",
        OBJECT: "OBJECT",
        INTERFACE: "INTERFACE",
        UNION: "UNION",
        ENUM: "ENUM",
        INPUT_OBJECT: "INPUT_OBJECT",
        LIST: "LIST",
        NON_NULL: "NON_NULL"
    };
    declare var ___TypeKind: GraphQLEnumType;
    declare var SchemaMetaFieldDef: GraphQLFieldDefinition;
    declare var TypeMetaFieldDef: GraphQLFieldDefinition;
    declare var TypeNameMetaFieldDef: GraphQLFieldDefinition;
}
declare module 'graphql/type/scalars' {

    declare var GraphQLInt: GraphQLScalarType;
    declare var GraphQLFloat: GraphQLScalarType;
    declare var GraphQLString: GraphQLScalarType;
    declare var GraphQLBoolean: GraphQLScalarType;
    declare var GraphQLID: GraphQLScalarType;
}
declare module 'graphql/type/schema' {



    /**
     * Schema Definition
     * 
    A Schema is created by supplying the root types of each type of operation,
    query and mutation (optional). A schema definition is then supplied to the
    validator and executor.

    Example:

         const MyAppSchema = new GraphQLSchema({
           query: MyAppQueryRootType,
           mutation: MyAppMutationRootType,
         })

    Note: If an array of `directives` are provided to GraphQLSchema, that will be
    the exact list of directives represented and allowed. If `directives` is not
    provided then a default set of the specified directives (e.g. @include and
     * @skip  ) will be used. If you wish to provide *additional* directives to these
    specified directives, you must explicitly declare them. Example:

    const MyAppSchema = new GraphQLSchema({
      ...
      directives: specifiedDirectives.concat([ myCustomDirective ]),
    })
    */
    declare class GraphQLSchema {
        constructor(config: GraphQLSchemaConfig): this;
        getQueryType(): GraphQLObjectType;
        getMutationType(): GraphQLObjectType;
        getSubscriptionType(): GraphQLObjectType;
        getTypeMap(): GraphQLNamedType;
        getType(name: string): GraphQLType;
        getPossibleTypes(abstractType: GraphQLAbstractType): Array<GraphQLObjectType>;
        isPossibleType(abstractType: GraphQLAbstractType, possibleType: GraphQLObjectType): boolean;
        getDirectives(): Array<GraphQLDirective>;
        getDirective(name: string): GraphQLDirective
    }
    declare interface GraphQLSchemaConfig {
        query: GraphQLObjectType,
            mutation?: GraphQLObjectType,
            subscription?: GraphQLObjectType,
            types?: Array<GraphQLNamedType>,
            directives?: Array<GraphQLDirective >
    }
}
declare module 'graphql/validation' {

}
declare module 'graphql/validation/index' {

}
declare module 'graphql/validation/specifiedRules' {

    declare var specifiedRules: Array<(context: ValidationContext) => any>;
}
declare module 'graphql/validation/validate' {








    /**
     * Implements the "Validation" section of the spec.
     * 
    Validation runs synchronously, returning an array of encountered errors, or
    an empty array if no errors were encountered and the document is valid.

    A list of specific validation rules may be provided. If not provided, the
    default list of rules defined by the GraphQL specification will be used.

    Each validation rules is a function which returns a visitor
    (see the language/visitor API). Visitor methods are expected to return
    GraphQLErrors, or Arrays of GraphQLErrors when invalid.
    */
    declare function validate(schema: GraphQLSchema, ast: Document, rules?: Array<any>): Array<GraphQLError >

        /**
         * This uses a specialized visitor which runs multiple visitors in parallel,
         * while maintaining the visitor skip and break API.
         * @internal  
         */
        declare function visitUsingRules(
        schema: GraphQLSchema,
        typeInfo: TypeInfo,
        documentAST: Document,
        rules: Array<any>): Array<GraphQLError >
        declare type HasSelectionSet = OperationDefinition | FragmentDefinition;
    declare interface VariableUsage {
        node: Variable,
            type: GraphQLInputType
    }

    /**
     * An instance of this class is passed as the "this" context to all validators,
     * allowing access to commonly useful contextual information from within a
    validation rule.
    */
    declare export class ValidationContext {
        constructor(schema: GraphQLSchema, ast: Document, typeInfo: TypeInfo): this;
        reportError(error: GraphQLError): void;
        getErrors(): Array<GraphQLError>;
        getSchema(): GraphQLSchema;
        getDocument(): Document;
        getFragment(name: string): FragmentDefinition;
        getFragmentSpreads(node: SelectionSet): Array<FragmentSpread>;
        getRecursivelyReferencedFragments(operation: OperationDefinition): Array<FragmentDefinition>;
        getVariableUsages(node: HasSelectionSet): Array<VariableUsage>;
        getRecursiveVariableUsages(operation: OperationDefinition): Array<VariableUsage>;
        getType(): GraphQLOutputType;
        getParentType(): GraphQLCompositeType;
        getInputType(): GraphQLInputType;
        getFieldDef(): GraphQLFieldDefinition;
        getDirective(): GraphQLDirective;
        getArgument(): GraphQLArgument
    }
}
declare module 'graphql/execution' {

}
declare module 'graphql/execution/index' {

}
declare module 'graphql/execution/execute' {




    /**
     * Data that must be available at all points during query execution.
     * 
    Namely, schema of the type system that is currently executing,
    and the fragments defined in the query document
    */
    declare interface ExecutionContext {
        schema: GraphQLSchema,
            fragments: {
                [key: string]: FragmentDefinition
            },
            rootValue: any,
            operation: OperationDefinition,
            variableValues: {
                [key: string]: any
            },
            errors: Array<GraphQLError >
    }

    /**
     * The result of execution. `data` is the result of executing the
     * query, `errors` is null if no errors occurred, and is a
    non-empty array if an error occurred.
    */
    declare interface ExecutionResult {
        data: Object,
            errors?: Array<GraphQLError >
    }

    /**
     * Implements the "Evaluating requests" section of the GraphQL specification.
     * 
    Returns a Promise that will eventually be resolved and never rejected.

    If the arguments to this function do not result in a legal execution context,
    a GraphQLError will be thrown immediately explaining the invalid input.
    */
    declare function execute(
        schema: GraphQLSchema,
        documentAST: Document,
        rootValue?: any,
        contextValue?: any,
        variableValues?: {
            [key: string]: any
        },
        operationName?: string): Promise<ExecutionResult >
}
declare module 'graphql/execution/values' {




    /**
     * Prepares an object map of variableValues of the correct type based on the
     * provided variable definitions and arbitrary input. If the input cannot be
    parsed to match the variable definitions, a GraphQLError will be thrown.
    */
    declare function getVariableValues(
        schema: GraphQLSchema,
        definitionASTs: Array<VariableDefinition>,
        inputs: {
            [key: string]: any
        }): {
        [key: string]: any
    }

    /**
     * Prepares an object map of argument values given a list of argument
     * definitions and list of argument AST nodes.
     */
    declare function getArgumentValues(
        argDefs: Array<GraphQLArgument>,
        argASTs: Array<Argument>,
        variableValues?: {
            [key: string]: any
        }): {
        [key: string]: any
    }
}
declare module 'graphql/error' {

}
declare module 'graphql/error/index' {

}
declare module 'graphql/error/formatError' {


    /**
     * Given a GraphQLError, format it according to the rules described by the
     * Response Format, Errors section of the GraphQL Specification.
     */
    declare function formatError(error: GraphQLError): GraphQLFormattedError
    declare type GraphQLFormattedError = {
        message: string,
        locations: Array<GraphQLErrorLocation >
    };
    declare type GraphQLErrorLocation = {
        line: number,
        column: number
    };
}
declare module 'graphql/error/GraphQLError' {




    /**
     * A GraphQLError describes an Error found during the parse, validate, or
     * execute phases of performing a GraphQL operation. In addition to a message
    and stack trace, it also includes information about the locations in a
    GraphQL document and/or execution result that correspond to the Error.
    */
    declare class GraphQLError mixins Error {

        /**
         * A message describing the Error for debugging purposes.
         * 
        Enumerable, and appears in the result of JSON.stringify().
        */
        message: string;

        /**
         * An array of { line, column } locations within the source GraphQL document
         * which correspond to this error.

        Errors during validation often contain multiple locations, for example to
        point out two things with the same name. Errors during execution include a
        single location, the field which produced the error.

        Enumerable, and appears in the result of JSON.stringify().
        */
        locations: Array<{
            line: number,
            column: number
        }>| void;

        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.

        Enumerable, and appears in the result of JSON.stringify().
        */
        path: Array<string | number>| void;

        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        nodes: Array<Node>| void;

        /**
         * The source GraphQL document corresponding to this error.
         */
        source: Source | void;

        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        positions: Array<number>| void;

        /**
         * The original error thrown from a field resolver during execution.
         */
        originalError: Error
    }
}
declare module 'graphql/error/locatedError' {


    /**
     * Given an arbitrary Error, presumably thrown while attempting to execute a
     * GraphQL operation, produce a new GraphQLError aware of the location in the
    document responsible for the original Error.
    */
    declare function locatedError<T>(
        originalError: Error,
        nodes: Array<T>,
        path: Array<string | number>): GraphQLError
}
declare module 'graphql/error/syntaxError' {



    /**
     * Produces a GraphQLError representing a syntax error, containing useful
     * descriptive information about the syntax error's position in the source.
     */
    declare function syntaxError(source: Source, position: number, description: string): GraphQLError
}
declare module 'graphql/utilities' {

}
declare module 'graphql/utilities/index' {

}
declare module 'graphql/utilities/assertValidName' {
    declare function assertValidName(name: string): void
}
declare module 'graphql/utilities/astFromValue' {



    /**
     * Produces a GraphQL Value AST given a JavaScript value.
     * 
    A GraphQL type must be provided, which will be used to interpret different
    JavaScript values.

    | JSON Value    | GraphQL Value        |
    | ------------- | -------------------- |
    | Object        | Input Object         |
    | Array        | List                 |
    | Boolean       | Boolean              |
    | String        | String / Enum Value  |
    | Number        | Int / Float          |
    | Mixed        | Enum Value           |
    */
    declare export function astFromValue(value: any, type: GraphQLInputType): Value
}
declare module 'graphql/utilities/buildASTSchema' {




    /**
     * This takes the ast of a schema document produced by the parse function in
     * src/language/parser.js.

    If no schema definition is provided, then it will look for types named Query
    and Mutation.

    Given that AST it constructs a GraphQLSchema. The resulting schema
    has no resolve methods, so execution will use default resolvers.
    */
    declare function buildASTSchema(ast: Document): GraphQLSchema

    /**
     * Given an ast node, returns its string description based on a contiguous
     * block full-line of comments preceding it.
     */
    declare function getDescription(node: {
        loc?: Location
    }): string

    /**
     * A helper function to build a GraphQLSchema directly from a source
     * document.
     */
    declare function buildSchema(source: string | Source): GraphQLSchema
}
declare module 'graphql/utilities/buildClientSchema' {



    /**
     * Build a GraphQLSchema for use by client tools.
     * 
    Given the result of a client running the introspection query, creates and
    returns a GraphQLSchema instance which can be then used with all graphql-js
    tools, but cannot be used to execute a query, as introspection does not
    represent the "resolver", "parse" or "serialize" functions or any other
    server-internal mechanisms.
    */
    declare function buildClientSchema(introspection: IntrospectionQuery): GraphQLSchema
}
declare module 'graphql/utilities/concatAST' {


    /**
     * Provided a collection of ASTs, presumably each from different files,
     * concatenate the ASTs together into batched AST, useful for validating many
    GraphQL source files which together represent one conceptual application.
    */
    declare function concatAST(asts: Array<Document>): Document
}
declare module 'graphql/utilities/extendSchema' {


    /**
     * Produces a new schema given an existing schema and a document which may
     * contain GraphQL type extensions and definitions. The original schema will
    remain unaltered.

    Because a schema represents a graph of references, a schema cannot be
    extended without effectively making an entire copy. We do not know until it's
    too late if subgraphs remain unchanged.

    This algorithm copies the provided schema, applying extensions while
    producing the copy. The original schema remains unaltered.
    */
    declare function extendSchema(schema: GraphQLSchema, documentAST: Document): GraphQLSchema
}
declare module 'graphql/utilities/getOperationAST' {


    /**
     * Returns an operation AST given a document AST and optionally an operation
     * name. If a name is not provided, an operation is only returned if only one is
    provided in the document.
    */
    declare export function getOperationAST(documentAST: Document, operationName: string): OperationDefinition
}
declare module 'graphql/utilities/introspectionQuery' {

    declare var introspectionQuery: string;
    declare interface IntrospectionQuery {
        ___schema: IntrospectionSchema
    }
    declare interface IntrospectionSchema {
        queryType: IntrospectionNamedTypeRef,
            mutationType?: IntrospectionNamedTypeRef,
            subscriptionType?: IntrospectionNamedTypeRef,
            types: Array<IntrospectionType>,
            directives: Array<IntrospectionDirective >
    }
    declare type IntrospectionType = IntrospectionScalarType |
        IntrospectionObjectType |
        IntrospectionInterfaceType |
        IntrospectionUnionType |
        IntrospectionEnumType |
        IntrospectionInputObjectType;
    declare interface IntrospectionScalarType {
        kind: "SCALAR",
            name: string,
            description?: string
    }
    declare interface IntrospectionObjectType {
        kind: "OBJECT",
            name: string,
            description?: string,
            fields: Array<IntrospectionField>,
            interfaces: Array<IntrospectionNamedTypeRef >
    }
    declare interface IntrospectionInterfaceType {
        kind: "INTERFACE",
            name: string,
            description?: string,
            fields: Array<IntrospectionField>,
            possibleTypes: Array<IntrospectionNamedTypeRef >
    }
    declare interface IntrospectionUnionType {
        kind: "UNION",
            name: string,
            description?: string,
            possibleTypes: Array<IntrospectionNamedTypeRef >
    }
    declare interface IntrospectionEnumType {
        kind: "ENUM",
            name: string,
            description?: string,
            enumValues: Array<IntrospectionEnumValue >
    }
    declare interface IntrospectionInputObjectType {
        kind: "INPUT_OBJECT",
            name: string,
            description?: string,
            inputFields: Array<IntrospectionInputValue >
    }
    declare type IntrospectionTypeRef = IntrospectionNamedTypeRef | IntrospectionListTypeRef | IntrospectionNonNullTypeRef;
    declare interface IntrospectionNamedTypeRef {
        kind: string,
            name: string
    }
    declare interface IntrospectionListTypeRef {
        kind: "LIST",
            ofType?: IntrospectionTypeRef
    }
    declare interface IntrospectionNonNullTypeRef {
        kind: "NON_NULL",
            ofType?: IntrospectionTypeRef
    }
    declare interface IntrospectionField {
        name: string,
            description?: string,
            args: Array<IntrospectionInputValue>,
            type: IntrospectionTypeRef,
            isDeprecated: boolean,
            deprecationReason?: string
    }
    declare interface IntrospectionInputValue {
        name: string,
            description?: string,
            type: IntrospectionTypeRef,
            defaultValue?: string
    }
    declare interface IntrospectionEnumValue {
        name: string,
            description?: string,
            isDeprecated: boolean,
            deprecationReason?: string
    }
    declare interface IntrospectionDirective {
        name: string,
            description?: string,
            locations: Array<DirectiveLocationEnum>,
            args: Array<IntrospectionInputValue >
    }
}
declare module 'graphql/utilities/isValidJSValue' {


    /**
     * Given a JavaScript value and a GraphQL type, determine if the value will be
     * accepted for that type. This is primarily useful for validating the
    runtime values of query variables.
    */
    declare function isValidJSValue(value: any, type: GraphQLInputType): Array<string >
}
declare module 'graphql/utilities/isValidLiteralValue' {



    /**
     * Utility for validators which determines if a value literal AST is valid given
     * an input type.

    Note that this only validates literal values, variables are assumed to
    provide values of the correct type.
    */
    declare function isValidLiteralValue(type: GraphQLInputType, valueAST: Value): Array<string >
}
declare module 'graphql/utilities/schemaPrinter' {

    declare function printSchema(schema: GraphQLSchema): string
    declare function printIntrospectionSchema(schema: GraphQLSchema): string
}
declare module 'graphql/utilities/separateOperations' {

    declare function separateOperations(documentAST: Document): {
        [operationName: string]: Document
    }
}
declare module 'graphql/utilities/typeComparators' {



    /**
     * Provided two types, return true if the types are equal (invariant).
     */
    declare function isEqualType(typeA: GraphQLType, typeB: GraphQLType): boolean

    /**
     * Provided a type and a super type, return true if the first type is either
     * equal or a subset of the second super type (covariant).
     */
    declare function isTypeSubTypeOf(
        schema: GraphQLSchema,
        maybeSubType: GraphQLType,
        superType: GraphQLType): boolean

    /**
     * Provided two composite types, determine if they "overlap". Two composite
     * types overlap when the Sets of possible concrete types for each intersect.

    This is often used to determine if a fragment of a given type could possibly
    be visited in a context of another type.

    This function is commutative.
    */
    declare function doTypesOverlap(
        schema: GraphQLSchema,
        typeA: GraphQLCompositeType,
        typeB: GraphQLCompositeType): boolean
}
declare module 'graphql/utilities/typeFromAST' {



    declare function typeFromAST(schema: GraphQLSchema, inputTypeAST: Type): GraphQLType
}
declare module 'graphql/utilities/TypeInfo' {
    declare class TypeInfo {}
}
declare module 'graphql/utilities/valueFromAST' {


    declare function valueFromAST(
        valueAST: Value,
        type: GraphQLInputType,
        variables?: {
            [key: string]: any
        }): any
}