// @flow
/**
 * Flowtype definitions for gl-matrix
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export class vec2 mixins Float32Array {

    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
    create(): vec2;

    /**
     * Creates a new vec2 initialized with values from an existing vector
     * @param a a vector to clone
     * @returns  a new 2D vector
     */
    clone(a: vec2 | number[]): vec2;

    /**
     * Creates a new vec2 initialized with the given values
     * @param x X component
     * @param y Y component
     * @returns  a new 2D vector
     */
    fromValues(x: number, y: number): vec2;

    /**
     * Copy the values from one vec2 to another
     * @param out the receiving vector
     * @param a the source vector
     * @returns  out
     */
    copy(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Set the components of a vec2 to the given values
     * @param out the receiving vector
     * @param x X component
     * @param y Y component
     * @returns  out
     */
    set(out: vec2, x: number, y: number): vec2;

    /**
     * Adds two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    add(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    subtract(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    sub(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Multiplies two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Multiplies two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Divides two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    divide(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Divides two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    div(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Math.ceil the components of a vec2
     * @param  the receiving vector
     * @param  vector to ceil
     * @returns  out
     */
    ceil(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Math.floor the components of a vec2
     * @param  the receiving vector
     * @param  vector to floor
     * @returns  out
     */
    floor(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Returns the minimum of two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    min(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Returns the maximum of two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    max(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Math.round the components of a vec2
     * @param  the receiving vector
     * @param  vector to round
     * @returns  out
     */
    round(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Scales a vec2 by a scalar number
     * @param out the receiving vector
     * @param a the vector to scale
     * @param b amount to scale the vector by
     * @returns  out
     */
    scale(out: vec2, a: vec2 | number[], b: number): vec2;

    /**
     * Adds two vec2's after scaling the second operand by a scalar value
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param scale the amount to scale b by before adding
     * @returns  out
     */
    scaleAndAdd(out: vec2, a: vec2 | number[], b: vec2 | number[], scale: number): vec2;

    /**
     * Calculates the euclidian distance between two vec2's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    distance(a: vec2 | number[], b: vec2 | number[]): number;

    /**
     * Calculates the euclidian distance between two vec2's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    dist(a: vec2 | number[], b: vec2 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec2's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    squaredDistance(a: vec2 | number[], b: vec2 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec2's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    sqrDist(a: vec2 | number[], b: vec2 | number[]): number;

    /**
     * Calculates the length of a vec2
     * @param a vector to calculate length of
     * @returns  length of a
     */
    length(a: vec2 | number[]): number;

    /**
     * Calculates the length of a vec2
     * @param a vector to calculate length of
     * @returns  length of a
     */
    len(a: vec2 | number[]): number;

    /**
     * Calculates the squared length of a vec2
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    squaredLength(a: vec2 | number[]): number;

    /**
     * Calculates the squared length of a vec2
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    sqrLen(a: vec2 | number[]): number;

    /**
     * Negates the components of a vec2
     * @param out the receiving vector
     * @param a vector to negate
     * @returns  out
     */
    negate(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Returns the inverse of the components of a vec2
     * @param out the receiving vector
     * @param a vector to invert
     * @returns  out
     */
    inverse(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Normalize a vec2
     * @param out the receiving vector
     * @param a vector to normalize
     * @returns  out
     */
    normalize(out: vec2, a: vec2 | number[]): vec2;

    /**
     * Calculates the dot product of two vec2's
     * @param a the first operand
     * @param b the second operand
     * @returns  dot product of a and b
     */
    dot(a: vec2 | number[], b: vec2 | number[]): number;

    /**
     * Computes the cross product of two vec2's
     * Note that the cross product must by definition produce a 3D vector
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    cross(out: vec2, a: vec2 | number[], b: vec2 | number[]): vec2;

    /**
     * Performs a linear interpolation between two vec2's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param t interpolation amount between the two inputs
     * @returns  out
     */
    lerp(out: vec2, a: vec2 | number[], b: vec2 | number[], t: number): vec2;

    /**
     * Generates a random unit vector
     * @param out the receiving vector
     * @returns  out
     */
    random(out: vec2): vec2;

    /**
     * Generates a random vector with the given scale
     * @param out the receiving vector
     * @param scale Length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns  out
     */
    random(out: vec2, scale: number): vec2;

    /**
     * Transforms the vec2 with a mat2
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
     */
    transformMat2(out: vec2, a: vec2 | number[], m: mat2): vec2;

    /**
     * Transforms the vec2 with a mat2d
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
     */
    transformMat2d(out: vec2, a: vec2 | number[], m: mat2d): vec2;

    /**
     * Transforms the vec2 with a mat3
     * 3rd vector component is implicitly '1'
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
     */
    transformMat3(out: vec2, a: vec2 | number[], m: mat3): vec2;

    /**
     * Transforms the vec2 with a mat4
     * 3rd vector component is implicitly '0'
    4th vector component is implicitly '1'
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
    */
    transformMat4(out: vec2, a: vec2 | number[], m: mat4): vec2;

    /**
     * Perform some operation over an array of vec2s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @param arg additional argument to pass to fn
     * @returns  a
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec2 | number[], b: vec2 | number[], arg: any) => void,
        arg: any): Float32Array;

    /**
     * Perform some operation over an array of vec2s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @returns  a
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec2 | number[], b: vec2 | number[]) => void): Float32Array;

    /**
     * Returns a string representation of a vector
     * @param a vector to represent as a string
     * @returns  string representation of the vector
     */
    str(a: vec2 | number[]): string;

    /**
     * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    exactEquals(a: vec2 | number[], b: vec2 | number[]): boolean;

    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    equals(a: vec2 | number[], b: vec2 | number[]): boolean
}
declare export class vec3 mixins Float32Array {

    /**
     * Creates a new, empty vec3
     * @returns  a new 3D vector
     */
    create(): vec3;

    /**
     * Creates a new vec3 initialized with values from an existing vector
     * @param a vector to clone
     * @returns  a new 3D vector
     */
    clone(a: vec3 | number[]): vec3;

    /**
     * Creates a new vec3 initialized with the given values
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @returns  a new 3D vector
     */
    fromValues(x: number, y: number, z: number): vec3;

    /**
     * Copy the values from one vec3 to another
     * @param out the receiving vector
     * @param a the source vector
     * @returns  out
     */
    copy(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Set the components of a vec3 to the given values
     * @param out the receiving vector
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @returns  out
     */
    set(out: vec3, x: number, y: number, z: number): vec3;

    /**
     * Adds two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    add(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    subtract(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    sub(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Multiplies two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Multiplies two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Divides two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    divide(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Divides two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    div(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Math.ceil the components of a vec3
     * @param  the receiving vector
     * @param  vector to ceil
     * @returns  out
     */
    ceil(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Math.floor the components of a vec3
     * @param  the receiving vector
     * @param  vector to floor
     * @returns  out
     */
    floor(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Returns the minimum of two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    min(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Returns the maximum of two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    max(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Math.round the components of a vec3
     * @param  the receiving vector
     * @param  vector to round
     * @returns  out
     */
    round(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Scales a vec3 by a scalar number
     * @param out the receiving vector
     * @param a the vector to scale
     * @param b amount to scale the vector by
     * @returns  out
     */
    scale(out: vec3, a: vec3 | number[], b: number): vec3;

    /**
     * Adds two vec3's after scaling the second operand by a scalar value
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param scale the amount to scale b by before adding
     * @returns  out
     */
    scaleAndAdd(out: vec3, a: vec3 | number[], b: vec3 | number[], scale: number): vec3;

    /**
     * Calculates the euclidian distance between two vec3's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    distance(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Calculates the euclidian distance between two vec3's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    dist(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec3's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    squaredDistance(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec3's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    sqrDist(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Calculates the length of a vec3
     * @param a vector to calculate length of
     * @returns  length of a
     */
    length(a: vec3 | number[]): number;

    /**
     * Calculates the length of a vec3
     * @param a vector to calculate length of
     * @returns  length of a
     */
    len(a: vec3 | number[]): number;

    /**
     * Calculates the squared length of a vec3
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    squaredLength(a: vec3 | number[]): number;

    /**
     * Calculates the squared length of a vec3
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    sqrLen(a: vec3 | number[]): number;

    /**
     * Negates the components of a vec3
     * @param out the receiving vector
     * @param a vector to negate
     * @returns  out
     */
    negate(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Returns the inverse of the components of a vec3
     * @param out the receiving vector
     * @param a vector to invert
     * @returns  out
     */
    inverse(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Normalize a vec3
     * @param out the receiving vector
     * @param a vector to normalize
     * @returns  out
     */
    normalize(out: vec3, a: vec3 | number[]): vec3;

    /**
     * Calculates the dot product of two vec3's
     * @param a the first operand
     * @param b the second operand
     * @returns  dot product of a and b
     */
    dot(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Computes the cross product of two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    cross(out: vec3, a: vec3 | number[], b: vec3 | number[]): vec3;

    /**
     * Performs a linear interpolation between two vec3's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param t interpolation amount between the two inputs
     * @returns  out
     */
    lerp(out: vec3, a: vec3 | number[], b: vec3 | number[], t: number): vec3;

    /**
     * Performs a hermite interpolation with two control points
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the third operand
     * @param  the fourth operand
     * @param  interpolation amount between the two inputs
     * @returns  out
     */
    hermite(
        out: vec3,
        a: vec3 | number[],
        b: vec3 | number[],
        c: vec3 | number[],
        d: vec3 | number[],
        t: number): vec3;

    /**
     * Performs a bezier interpolation with two control points
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the third operand
     * @param  the fourth operand
     * @param  interpolation amount between the two inputs
     * @returns  out
     */
    bezier(
        out: vec3,
        a: vec3 | number[],
        b: vec3 | number[],
        c: vec3 | number[],
        d: vec3 | number[],
        t: number): vec3;

    /**
     * Generates a random unit vector
     * @param out the receiving vector
     * @returns  out
     */
    random(out: vec3): vec3;

    /**
     * Generates a random vector with the given scale
     * @param out the receiving vector
     * @param scale Length of the resulting vector. If omitted, a unit vector will be returned
     * @returns  out
     */
    random(out: vec3, scale: number): vec3;

    /**
     * Transforms the vec3 with a mat3.
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m the 3x3 matrix to transform with
     * @returns  out
     */
    transformMat3(out: vec3, a: vec3 | number[], m: mat3): vec3;

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
     */
    transformMat4(out: vec3, a: vec3 | number[], m: mat4): vec3;

    /**
     * Transforms the vec3 with a quat
     * @param out the receiving vector
     * @param a the vector to transform
     * @param q quaternion to transform with
     * @returns  out
     */
    transformQuat(out: vec3, a: vec3 | number[], q: quat): vec3;

    /**
     * Rotate a 3D vector around the x-axis
     * @param out The receiving vec3
     * @param a The vec3 point to rotate
     * @param b The origin of the rotation
     * @param c The angle of rotation
     * @returns  out
     */
    rotateX(out: vec3, a: vec3 | number[], b: vec3 | number[], c: number): vec3;

    /**
     * Rotate a 3D vector around the y-axis
     * @param out The receiving vec3
     * @param a The vec3 point to rotate
     * @param b The origin of the rotation
     * @param c The angle of rotation
     * @returns  out
     */
    rotateY(out: vec3, a: vec3 | number[], b: vec3 | number[], c: number): vec3;

    /**
     * Rotate a 3D vector around the z-axis
     * @param out The receiving vec3
     * @param a The vec3 point to rotate
     * @param b The origin of the rotation
     * @param c The angle of rotation
     * @returns  out
     */
    rotateZ(out: vec3, a: vec3 | number[], b: vec3 | number[], c: number): vec3;

    /**
     * Perform some operation over an array of vec3s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @param arg additional argument to pass to fn
     * @returns  a
     * @function  
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec3 | number[], b: vec3 | number[], arg: any) => void,
        arg: any): Float32Array;

    /**
     * Perform some operation over an array of vec3s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec3. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec3s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @returns  a
     * @function  
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec3 | number[], b: vec3 | number[]) => void): Float32Array;

    /**
     * Get the angle between two 3D vectors
     * @param a The first operand
     * @param b The second operand
     * @returns  The angle in radians
     */
    angle(a: vec3 | number[], b: vec3 | number[]): number;

    /**
     * Returns a string representation of a vector
     * @param a vector to represent as a string
     * @returns  string representation of the vector
     */
    str(a: vec3 | number[]): string;

    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    exactEquals(a: vec3 | number[], b: vec3 | number[]): boolean;

    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    equals(a: vec3 | number[], b: vec3 | number[]): boolean
}
declare export class vec4 mixins Float32Array {

    /**
     * Creates a new, empty vec4
     * @returns  a new 4D vector
     */
    create(): vec4;

    /**
     * Creates a new vec4 initialized with values from an existing vector
     * @param a vector to clone
     * @returns  a new 4D vector
     */
    clone(a: vec4 | number[]): vec4;

    /**
     * Creates a new vec4 initialized with the given values
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @param w W component
     * @returns  a new 4D vector
     */
    fromValues(x: number, y: number, z: number, w: number): vec4;

    /**
     * Copy the values from one vec4 to another
     * @param out the receiving vector
     * @param a the source vector
     * @returns  out
     */
    copy(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Set the components of a vec4 to the given values
     * @param out the receiving vector
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @param w W component
     * @returns  out
     */
    set(out: vec4, x: number, y: number, z: number, w: number): vec4;

    /**
     * Adds two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    add(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    subtract(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Subtracts vector b from vector a
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    sub(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Multiplies two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Multiplies two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Divides two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    divide(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Divides two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    div(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Math.ceil the components of a vec4
     * @param  the receiving vector
     * @param  vector to ceil
     * @returns  out
     */
    ceil(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Math.floor the components of a vec4
     * @param  the receiving vector
     * @param  vector to floor
     * @returns  out
     */
    floor(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Returns the minimum of two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    min(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Returns the maximum of two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    max(out: vec4, a: vec4 | number[], b: vec4 | number[]): vec4;

    /**
     * Math.round the components of a vec4
     * @param  the receiving vector
     * @param  vector to round
     * @returns  out
     */
    round(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Scales a vec4 by a scalar number
     * @param out the receiving vector
     * @param a the vector to scale
     * @param b amount to scale the vector by
     * @returns  out
     */
    scale(out: vec4, a: vec4 | number[], b: number): vec4;

    /**
     * Adds two vec4's after scaling the second operand by a scalar value
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param scale the amount to scale b by before adding
     * @returns  out
     */
    scaleAndAdd(out: vec4, a: vec4 | number[], b: vec4 | number[], scale: number): vec4;

    /**
     * Calculates the euclidian distance between two vec4's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    distance(a: vec4 | number[], b: vec4 | number[]): number;

    /**
     * Calculates the euclidian distance between two vec4's
     * @param a the first operand
     * @param b the second operand
     * @returns  distance between a and b
     */
    dist(a: vec4 | number[], b: vec4 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec4's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    squaredDistance(a: vec4 | number[], b: vec4 | number[]): number;

    /**
     * Calculates the squared euclidian distance between two vec4's
     * @param a the first operand
     * @param b the second operand
     * @returns  squared distance between a and b
     */
    sqrDist(a: vec4 | number[], b: vec4 | number[]): number;

    /**
     * Calculates the length of a vec4
     * @param a vector to calculate length of
     * @returns  length of a
     */
    length(a: vec4 | number[]): number;

    /**
     * Calculates the length of a vec4
     * @param a vector to calculate length of
     * @returns  length of a
     */
    len(a: vec4 | number[]): number;

    /**
     * Calculates the squared length of a vec4
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    squaredLength(a: vec4 | number[]): number;

    /**
     * Calculates the squared length of a vec4
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     */
    sqrLen(a: vec4 | number[]): number;

    /**
     * Negates the components of a vec4
     * @param out the receiving vector
     * @param a vector to negate
     * @returns  out
     */
    negate(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Returns the inverse of the components of a vec4
     * @param out the receiving vector
     * @param a vector to invert
     * @returns  out
     */
    inverse(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Normalize a vec4
     * @param out the receiving vector
     * @param a vector to normalize
     * @returns  out
     */
    normalize(out: vec4, a: vec4 | number[]): vec4;

    /**
     * Calculates the dot product of two vec4's
     * @param a the first operand
     * @param b the second operand
     * @returns  dot product of a and b
     */
    dot(a: vec4 | number[], b: vec4 | number[]): number;

    /**
     * Performs a linear interpolation between two vec4's
     * @param out the receiving vector
     * @param a the first operand
     * @param b the second operand
     * @param t interpolation amount between the two inputs
     * @returns  out
     */
    lerp(out: vec4, a: vec4 | number[], b: vec4 | number[], t: number): vec4;

    /**
     * Generates a random unit vector
     * @param out the receiving vector
     * @returns  out
     */
    random(out: vec4): vec4;

    /**
     * Generates a random vector with the given scale
     * @param out the receiving vector
     * @param scale length of the resulting vector. If ommitted, a unit vector will be returned
     * @returns  out
     */
    random(out: vec4, scale: number): vec4;

    /**
     * Transforms the vec4 with a mat4.
     * @param out the receiving vector
     * @param a the vector to transform
     * @param m matrix to transform with
     * @returns  out
     */
    transformMat4(out: vec4, a: vec4 | number[], m: mat4): vec4;

    /**
     * Transforms the vec4 with a quat
     * @param out the receiving vector
     * @param a the vector to transform
     * @param q quaternion to transform with
     * @returns  out
     */
    transformQuat(out: vec4, a: vec4 | number[], q: quat): vec4;

    /**
     * Perform some operation over an array of vec4s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @param arg additional argument to pass to fn
     * @returns  a
     * @function  
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec4 | number[], b: vec4 | number[], arg: any) => void,
        arg: any): Float32Array;

    /**
     * Perform some operation over an array of vec4s.
     * @param a the array of vectors to iterate over
     * @param stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param offset Number of elements to skip at the beginning of the array
     * @param count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param fn Function to call for each vector in the array
     * @returns  a
     * @function  
     */
    forEach(
        a: Float32Array,
        stride: number,
        offset: number,
        count: number,
        fn: (a: vec4 | number[], b: vec4 | number[]) => void): Float32Array;

    /**
     * Returns a string representation of a vector
     * @param a vector to represent as a string
     * @returns  string representation of the vector
     */
    str(a: vec4 | number[]): string;

    /**
     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    exactEquals(a: vec4 | number[], b: vec4 | number[]): boolean;

    /**
     * Returns whether or not the vectors have approximately the same elements in the same position.
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the vectors are equal, false otherwise.
     */
    equals(a: vec4 | number[], b: vec4 | number[]): boolean
}
declare export class mat2 mixins Float32Array {

    /**
     * Creates a new identity mat2
     * @returns  a new 2x2 matrix
     */
    create(): mat2;

    /**
     * Creates a new mat2 initialized with values from an existing matrix
     * @param a matrix to clone
     * @returns  a new 2x2 matrix
     */
    clone(a: mat2): mat2;

    /**
     * Copy the values from one mat2 to another
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    copy(out: mat2, a: mat2): mat2;

    /**
     * Set a mat2 to the identity matrix
     * @param out the receiving matrix
     * @returns  out
     */
    identity(out: mat2): mat2;

    /**
     * Create a new mat2 with the given values
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 1, row 0 position (index 2)
     * @param  Component in column 1, row 1 position (index 3)
     * @returns  out A new 2x2 matrix
     */
    fromValues(m00: number, m01: number, m10: number, m11: number): mat2;

    /**
     * Set the components of a mat2 to the given values
     * @param  the receiving matrix
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 1, row 0 position (index 2)
     * @param  Component in column 1, row 1 position (index 3)
     * @returns  out
     */
    set(out: mat2, m00: number, m01: number, m10: number, m11: number): mat2;

    /**
     * Transpose the values of a mat2
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    transpose(out: mat2, a: mat2): mat2;

    /**
     * Inverts a mat2
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    invert(out: mat2, a: mat2): mat2;

    /**
     * Calculates the adjugate of a mat2
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    adjoint(out: mat2, a: mat2): mat2;

    /**
     * Calculates the determinant of a mat2
     * @param a the source matrix
     * @returns  determinant of a
     */
    determinant(a: mat2): number;

    /**
     * Multiplies two mat2's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: mat2, a: mat2, b: mat2): mat2;

    /**
     * Multiplies two mat2's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: mat2, a: mat2, b: mat2): mat2;

    /**
     * Rotates a mat2 by the given angle
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotate(out: mat2, a: mat2, rad: number): mat2;

    /**
     * Scales the mat2 by the dimensions in the given vec2
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param v the vec2 to scale the matrix by
     * @returns  out
     */
    scale(out: mat2, a: mat2, v: vec2 | number[]): mat2;

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):

         mat2.identity(dest);
         mat2.rotate(dest, dest, rad);
     * @param  mat2 receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromRotation(out: mat2, rad: number): mat2;

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):

         mat2.identity(dest);
         mat2.scale(dest, dest, vec);
     * @param  mat2 receiving operation result
     * @param  Scaling vector
     * @returns  out
    */
    fromScaling(out: mat2, v: vec2 | number[]): mat2;

    /**
     * Returns a string representation of a mat2
     * @param a matrix to represent as a string
     * @returns  string representation of the matrix
     */
    str(a: mat2): string;

    /**
     * Returns Frobenius norm of a mat2
     * @param a the matrix to calculate Frobenius norm of
     * @returns  Frobenius norm
     */
    frob(a: mat2): number;

    /**
     * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
     * @param L the lower triangular matrix
     * @param D the diagonal matrix
     * @param U the upper triangular matrix
     * @param a the input matrix to factorize
     */
    LDU(L: mat2, D: mat2, U: mat2, a: mat2): mat2;

    /**
     * Adds two mat2's
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    add(out: mat2, a: mat2, b: mat2): mat2;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    subtract(out: mat2, a: mat2, b: mat2): mat2;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    sub(out: mat2, a: mat2, b: mat2): mat2;

    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    exactEquals(a: mat2, b: mat2): boolean;

    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    equals(a: mat2, b: mat2): boolean;

    /**
     * Multiply each element of the matrix by a scalar.
     * @param  the receiving matrix
     * @param  the matrix to scale
     * @param  amount to scale the matrix's elements by
     * @returns  out
     */
    multiplyScalar(out: mat2, a: mat2, b: number): mat2;

    /**
     * Adds two mat2's after multiplying each element of the second operand by a scalar value.
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the amount to scale b's elements by before adding
     * @returns  out
     */
    multiplyScalarAndAdd(out: mat2, a: mat2, b: mat2, scale: number): mat2
}
declare export class mat2d mixins Float32Array {

    /**
     * Creates a new identity mat2d
     * @returns  a new 2x3 matrix
     */
    create(): mat2d;

    /**
     * Creates a new mat2d initialized with values from an existing matrix
     * @param a matrix to clone
     * @returns  a new 2x3 matrix
     */
    clone(a: mat2d): mat2d;

    /**
     * Copy the values from one mat2d to another
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    copy(out: mat2d, a: mat2d): mat2d;

    /**
     * Set a mat2d to the identity matrix
     * @param out the receiving matrix
     * @returns  out
     */
    identity(out: mat2d): mat2d;

    /**
     * Create a new mat2d with the given values
     * @param  Component A (index 0)
     * @param  Component B (index 1)
     * @param  Component C (index 2)
     * @param  Component D (index 3)
     * @param  Component TX (index 4)
     * @param  Component TY (index 5)
     * @returns  A new mat2d
     */
    fromValues(a: number, b: number, c: number, d: number, tx: number, ty: number): mat2d;

    /**
     * Set the components of a mat2d to the given values
     * @param  the receiving matrix
     * @param  Component A (index 0)
     * @param  Component B (index 1)
     * @param  Component C (index 2)
     * @param  Component D (index 3)
     * @param  Component TX (index 4)
     * @param  Component TY (index 5)
     * @returns  out
     */
    set(
        out: mat2d,
        a: number,
        b: number,
        c: number,
        d: number,
        tx: number,
        ty: number): mat2d;

    /**
     * Inverts a mat2d
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    invert(out: mat2d, a: mat2d): mat2d;

    /**
     * Calculates the determinant of a mat2d
     * @param a the source matrix
     * @returns  determinant of a
     */
    determinant(a: mat2d): number;

    /**
     * Multiplies two mat2d's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: mat2d, a: mat2d, b: mat2d): mat2d;

    /**
     * Multiplies two mat2d's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: mat2d, a: mat2d, b: mat2d): mat2d;

    /**
     * Rotates a mat2d by the given angle
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotate(out: mat2d, a: mat2d, rad: number): mat2d;

    /**
     * Scales the mat2d by the dimensions in the given vec2
     * @param out the receiving matrix
     * @param a the matrix to translate
     * @param v the vec2 to scale the matrix by
     * @returns  out
     */
    scale(out: mat2d, a: mat2d, v: vec2 | number[]): mat2d;

    /**
     * Translates the mat2d by the dimensions in the given vec2
     * @param out the receiving matrix
     * @param a the matrix to translate
     * @param v the vec2 to translate the matrix by
     * @returns  out
     */
    translate(out: mat2d, a: mat2d, v: vec2 | number[]): mat2d;

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):

         mat2d.identity(dest);
         mat2d.rotate(dest, dest, rad);
     * @param  mat2d receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromRotation(out: mat2d, rad: number): mat2d;

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):

         mat2d.identity(dest);
         mat2d.scale(dest, dest, vec);
     * @param  mat2d receiving operation result
     * @param  Scaling vector
     * @returns  out
    */
    fromScaling(out: mat2d, v: vec2 | number[]): mat2d;

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):

         mat2d.identity(dest);
         mat2d.translate(dest, dest, vec);
     * @param  mat2d receiving operation result
     * @param  Translation vector
     * @returns  out
    */
    fromTranslation(out: mat2d, v: vec2 | number[]): mat2d;

    /**
     * Returns a string representation of a mat2d
     * @param a matrix to represent as a string
     * @returns  string representation of the matrix
     */
    str(a: mat2d): string;

    /**
     * Returns Frobenius norm of a mat2d
     * @param a the matrix to calculate Frobenius norm of
     * @returns  Frobenius norm
     */
    frob(a: mat2d): number;

    /**
     * Adds two mat2d's
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    add(out: mat2d, a: mat2d, b: mat2d): mat2d;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    subtract(out: mat2d, a: mat2d, b: mat2d): mat2d;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    sub(out: mat2d, a: mat2d, b: mat2d): mat2d;

    /**
     * Multiply each element of the matrix by a scalar.
     * @param  the receiving matrix
     * @param  the matrix to scale
     * @param  amount to scale the matrix's elements by
     * @returns  out
     */
    multiplyScalar(out: mat2d, a: mat2d, b: number): mat2d;

    /**
     * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the amount to scale b's elements by before adding
     * @returns  out
     */
    multiplyScalarAndAdd(out: mat2d, a: mat2d, b: mat2d, scale: number): mat2d;

    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    exactEquals(a: mat2d, b: mat2d): boolean;

    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    equals(a: mat2d, b: mat2d): boolean
}
declare export class mat3 mixins Float32Array {

    /**
     * Creates a new identity mat3
     * @returns  a new 3x3 matrix
     */
    create(): mat3;

    /**
     * Copies the upper-left 3x3 values into the given mat3.
     * @param  the receiving 3x3 matrix
     * @param  the source 4x4 matrix
     * @returns  out
     */
    fromMat4(out: mat3, a: mat4): mat3;

    /**
     * Creates a new mat3 initialized with values from an existing matrix
     * @param a matrix to clone
     * @returns  a new 3x3 matrix
     */
    clone(a: mat3): mat3;

    /**
     * Copy the values from one mat3 to another
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    copy(out: mat3, a: mat3): mat3;

    /**
     * Create a new mat3 with the given values
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 0, row 2 position (index 2)
     * @param  Component in column 1, row 0 position (index 3)
     * @param  Component in column 1, row 1 position (index 4)
     * @param  Component in column 1, row 2 position (index 5)
     * @param  Component in column 2, row 0 position (index 6)
     * @param  Component in column 2, row 1 position (index 7)
     * @param  Component in column 2, row 2 position (index 8)
     * @returns  A new mat3
     */
    fromValues(
        m00: number,
        m01: number,
        m02: number,
        m10: number,
        m11: number,
        m12: number,
        m20: number,
        m21: number,
        m22: number): mat3;

    /**
     * Set the components of a mat3 to the given values
     * @param  the receiving matrix
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 0, row 2 position (index 2)
     * @param  Component in column 1, row 0 position (index 3)
     * @param  Component in column 1, row 1 position (index 4)
     * @param  Component in column 1, row 2 position (index 5)
     * @param  Component in column 2, row 0 position (index 6)
     * @param  Component in column 2, row 1 position (index 7)
     * @param  Component in column 2, row 2 position (index 8)
     * @returns  out
     */
    set(
        out: mat3,
        m00: number,
        m01: number,
        m02: number,
        m10: number,
        m11: number,
        m12: number,
        m20: number,
        m21: number,
        m22: number): mat3;

    /**
     * Set a mat3 to the identity matrix
     * @param out the receiving matrix
     * @returns  out
     */
    identity(out: mat3): mat3;

    /**
     * Transpose the values of a mat3
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    transpose(out: mat3, a: mat3): mat3;

    /**
     * Inverts a mat3
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    invert(out: mat3, a: mat3): mat3;

    /**
     * Calculates the adjugate of a mat3
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    adjoint(out: mat3, a: mat3): mat3;

    /**
     * Calculates the determinant of a mat3
     * @param a the source matrix
     * @returns  determinant of a
     */
    determinant(a: mat3): number;

    /**
     * Multiplies two mat3's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: mat3, a: mat3, b: mat3): mat3;

    /**
     * Multiplies two mat3's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: mat3, a: mat3, b: mat3): mat3;

    /**
     * Translate a mat3 by the given vector
     * @param out the receiving matrix
     * @param a the matrix to translate
     * @param v vector to translate by
     * @returns  out
     */
    translate(out: mat3, a: mat3, v: vec3 | number[]): mat3;

    /**
     * Rotates a mat3 by the given angle
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotate(out: mat3, a: mat3, rad: number): mat3;

    /**
     * Scales the mat3 by the dimensions in the given vec2
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param v the vec2 to scale the matrix by
     * @returns  out
     */
    scale(out: mat3, a: mat3, v: vec2 | number[]): mat3;

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):

         mat3.identity(dest);
         mat3.translate(dest, dest, vec);
     * @param  mat3 receiving operation result
     * @param  Translation vector
     * @returns  out
    */
    fromTranslation(out: mat3, v: vec2 | number[]): mat3;

    /**
     * Creates a matrix from a given angle
     * This is equivalent to (but much faster than):

         mat3.identity(dest);
         mat3.rotate(dest, dest, rad);
     * @param  mat3 receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromRotation(out: mat3, rad: number): mat3;

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):

         mat3.identity(dest);
         mat3.scale(dest, dest, vec);
     * @param  mat3 receiving operation result
     * @param  Scaling vector
     * @returns  out
    */
    fromScaling(out: mat3, v: vec2 | number[]): mat3;

    /**
     * Copies the values from a mat2d into a mat3
     * @param out the receiving matrix
     * @param  the matrix to copy
     * @returns  out
     */
    fromMat2d(out: mat3, a: mat2d): mat3;

    /**
     * Calculates a 3x3 matrix from the given quaternion
     * @param out mat3 receiving operation result
     * @param q Quaternion to create matrix from
     * @returns  out
     */
    fromQuat(out: mat3, q: quat): mat3;

    /**
     * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
     * @param out mat3 receiving operation result
     * @param a Mat4 to derive the normal matrix from
     * @returns  out
     */
    normalFromMat4(out: mat3, a: mat4): mat3;

    /**
     * Returns a string representation of a mat3
     * @param mat matrix to represent as a string
     * @returns  string representation of the matrix
     */
    str(mat: mat3): string;

    /**
     * Returns Frobenius norm of a mat3
     * @param a the matrix to calculate Frobenius norm of
     * @returns  Frobenius norm
     */
    frob(a: mat3): number;

    /**
     * Adds two mat3's
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    add(out: mat3, a: mat3, b: mat3): mat3;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    subtract(out: mat3, a: mat3, b: mat3): mat3;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    sub(out: mat3, a: mat3, b: mat3): mat3;

    /**
     * Multiply each element of the matrix by a scalar.
     * @param  the receiving matrix
     * @param  the matrix to scale
     * @param  amount to scale the matrix's elements by
     * @returns  out
     */
    multiplyScalar(out: mat3, a: mat3, b: number): mat3;

    /**
     * Adds two mat3's after multiplying each element of the second operand by a scalar value.
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the amount to scale b's elements by before adding
     * @returns  out
     */
    multiplyScalarAndAdd(out: mat3, a: mat3, b: mat3, scale: number): mat3;

    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    exactEquals(a: mat3, b: mat3): boolean;

    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    equals(a: mat3, b: mat3): boolean
}
declare export class mat4 mixins Float32Array {

    /**
     * Creates a new identity mat4
     * @returns  a new 4x4 matrix
     */
    create(): mat4;

    /**
     * Creates a new mat4 initialized with values from an existing matrix
     * @param a matrix to clone
     * @returns  a new 4x4 matrix
     */
    clone(a: mat4): mat4;

    /**
     * Copy the values from one mat4 to another
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    copy(out: mat4, a: mat4): mat4;

    /**
     * Create a new mat4 with the given values
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 0, row 2 position (index 2)
     * @param  Component in column 0, row 3 position (index 3)
     * @param  Component in column 1, row 0 position (index 4)
     * @param  Component in column 1, row 1 position (index 5)
     * @param  Component in column 1, row 2 position (index 6)
     * @param  Component in column 1, row 3 position (index 7)
     * @param  Component in column 2, row 0 position (index 8)
     * @param  Component in column 2, row 1 position (index 9)
     * @param  Component in column 2, row 2 position (index 10)
     * @param  Component in column 2, row 3 position (index 11)
     * @param  Component in column 3, row 0 position (index 12)
     * @param  Component in column 3, row 1 position (index 13)
     * @param  Component in column 3, row 2 position (index 14)
     * @param  Component in column 3, row 3 position (index 15)
     * @returns  A new mat4
     */
    fromValues(
        m00: number,
        m01: number,
        m02: number,
        m03: number,
        m10: number,
        m11: number,
        m12: number,
        m13: number,
        m20: number,
        m21: number,
        m22: number,
        m23: number,
        m30: number,
        m31: number,
        m32: number,
        m33: number): mat4;

    /**
     * Set the components of a mat4 to the given values
     * @param  the receiving matrix
     * @param  Component in column 0, row 0 position (index 0)
     * @param  Component in column 0, row 1 position (index 1)
     * @param  Component in column 0, row 2 position (index 2)
     * @param  Component in column 0, row 3 position (index 3)
     * @param  Component in column 1, row 0 position (index 4)
     * @param  Component in column 1, row 1 position (index 5)
     * @param  Component in column 1, row 2 position (index 6)
     * @param  Component in column 1, row 3 position (index 7)
     * @param  Component in column 2, row 0 position (index 8)
     * @param  Component in column 2, row 1 position (index 9)
     * @param  Component in column 2, row 2 position (index 10)
     * @param  Component in column 2, row 3 position (index 11)
     * @param  Component in column 3, row 0 position (index 12)
     * @param  Component in column 3, row 1 position (index 13)
     * @param  Component in column 3, row 2 position (index 14)
     * @param  Component in column 3, row 3 position (index 15)
     * @returns  out
     */
    set(
        out: mat4,
        m00: number,
        m01: number,
        m02: number,
        m03: number,
        m10: number,
        m11: number,
        m12: number,
        m13: number,
        m20: number,
        m21: number,
        m22: number,
        m23: number,
        m30: number,
        m31: number,
        m32: number,
        m33: number): mat4;

    /**
     * Set a mat4 to the identity matrix
     * @param out the receiving matrix
     * @returns  out
     */
    identity(out: mat4): mat4;

    /**
     * Transpose the values of a mat4
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    transpose(out: mat4, a: mat4): mat4;

    /**
     * Inverts a mat4
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    invert(out: mat4, a: mat4): mat4;

    /**
     * Calculates the adjugate of a mat4
     * @param out the receiving matrix
     * @param a the source matrix
     * @returns  out
     */
    adjoint(out: mat4, a: mat4): mat4;

    /**
     * Calculates the determinant of a mat4
     * @param a the source matrix
     * @returns  determinant of a
     */
    determinant(a: mat4): number;

    /**
     * Multiplies two mat4's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: mat4, a: mat4, b: mat4): mat4;

    /**
     * Multiplies two mat4's
     * @param out the receiving matrix
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: mat4, a: mat4, b: mat4): mat4;

    /**
     * Translate a mat4 by the given vector
     * @param out the receiving matrix
     * @param a the matrix to translate
     * @param v vector to translate by
     * @returns  out
     */
    translate(out: mat4, a: mat4, v: vec3 | number[]): mat4;

    /**
     * Scales the mat4 by the dimensions in the given vec3
     * @param out the receiving matrix
     * @param a the matrix to scale
     * @param v the vec3 to scale the matrix by
     * @returns  out
     */
    scale(out: mat4, a: mat4, v: vec3 | number[]): mat4;

    /**
     * Rotates a mat4 by the given angle
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @param axis the axis to rotate around
     * @returns  out
     */
    rotate(out: mat4, a: mat4, rad: number, axis: vec3 | number[]): mat4;

    /**
     * Rotates a matrix by the given angle around the X axis
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotateX(out: mat4, a: mat4, rad: number): mat4;

    /**
     * Rotates a matrix by the given angle around the Y axis
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotateY(out: mat4, a: mat4, rad: number): mat4;

    /**
     * Rotates a matrix by the given angle around the Z axis
     * @param out the receiving matrix
     * @param a the matrix to rotate
     * @param rad the angle to rotate the matrix by
     * @returns  out
     */
    rotateZ(out: mat4, a: mat4, rad: number): mat4;

    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.translate(dest, dest, vec);
     * @param  mat4 receiving operation result
     * @param  Translation vector
     * @returns  out
    */
    fromTranslation(out: mat4, v: vec3 | number[]): mat4;

    /**
     * Creates a matrix from a vector scaling
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.scale(dest, dest, vec);
     * @param  mat4 receiving operation result
     * @param  Scaling vector
     * @returns  out
    */
    fromScaling(out: mat4, v: vec3 | number[]): mat4;

    /**
     * Creates a matrix from a given angle around a given axis
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.rotate(dest, dest, rad, axis);
     * @param  mat4 receiving operation result
     * @param  the angle to rotate the matrix by
     * @param  the axis to rotate around
     * @returns  out
    */
    fromRotation(out: mat4, rad: number, axis: vec3 | number[]): mat4;

    /**
     * Creates a matrix from the given angle around the X axis
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.rotateX(dest, dest, rad);
     * @param  mat4 receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromXRotation(out: mat4, rad: number): mat4;

    /**
     * Creates a matrix from the given angle around the Y axis
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.rotateY(dest, dest, rad);
     * @param  mat4 receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromYRotation(out: mat4, rad: number): mat4;

    /**
     * Creates a matrix from the given angle around the Z axis
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.rotateZ(dest, dest, rad);
     * @param  mat4 receiving operation result
     * @param  the angle to rotate the matrix by
     * @returns  out
    */
    fromZRotation(out: mat4, rad: number): mat4;

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.translate(dest, vec);
         var quatMat = mat4.create();
         quat4.toMat4(quat, quatMat);
         mat4.multiply(dest, quatMat);
     * @param out mat4 receiving operation result
     * @param q Rotation quaternion
     * @param v Translation vector
     * @returns  out
    */
    fromRotationTranslation(out: mat4, q: quat, v: vec3 | number[]): mat4;

    /**
     * Returns the translation vector component of a transformation
     *   matrix. If a matrix is built with fromRotationTranslation,
      the returned vector will be the same as the translation vector
      originally supplied.
     * @param  Vector to receive translation component
     * @param  Matrix to be decomposed (input)
     * @return  out
    */
    getTranslation(out: vec3, mat: mat4): vec3;

    /**
     * Returns a quaternion representing the rotational component
     *   of a transformation matrix. If a matrix is built with
      fromRotationTranslation, the returned quaternion will be the
      same as the quaternion originally supplied.
     * @param  Quaternion to receive the rotation component
     * @param  Matrix to be decomposed (input)
     * @return  out
    */
    getRotation(out: quat, mat: mat4): quat;

    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.translate(dest, vec);
         var quatMat = mat4.create();
         quat4.toMat4(quat, quatMat);
         mat4.multiply(dest, quatMat);
         mat4.scale(dest, scale)
     * @param out mat4 receiving operation result
     * @param q Rotation quaternion
     * @param v Translation vector
     * @param s Scaling vector
     * @returns  out
    */
    fromRotationTranslationScale(out: mat4, q: quat, v: vec3 | number[], s: vec3 | number[]): mat4;

    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
     * This is equivalent to (but much faster than):

         mat4.identity(dest);
         mat4.translate(dest, vec);
         mat4.translate(dest, origin);
         var quatMat = mat4.create();
         quat4.toMat4(quat, quatMat);
         mat4.multiply(dest, quatMat);
         mat4.scale(dest, scale)
         mat4.translate(dest, negativeOrigin);
     * @param  mat4 receiving operation result
     * @param  Rotation quaternion
     * @param  Translation vector
     * @param  Scaling vector
     * @param  The origin vector around which to scale and rotate
     * @returns  out
    */
    fromRotationTranslationScaleOrigin(
        out: mat4,
        q: quat,
        v: vec3 | number[],
        s: vec3 | number[],
        o: vec3 | number[]): mat4;

    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param  mat4 receiving operation result
     * @param  Quaternion to create matrix from
     * @returns  out
     */
    fromQuat(out: mat4, q: quat): mat4;

    /**
     * Generates a frustum matrix with the given bounds
     * @param out mat4 frustum matrix will be written into
     * @param left Left bound of the frustum
     * @param right Right bound of the frustum
     * @param bottom Bottom bound of the frustum
     * @param top Top bound of the frustum
     * @param near Near bound of the frustum
     * @param far Far bound of the frustum
     * @returns  out
     */
    frustum(
        out: mat4,
        left: number,
        right: number,
        bottom: number,
        top: number,
        near: number,
        far: number): mat4;

    /**
     * Generates a perspective projection matrix with the given bounds
     * @param out mat4 frustum matrix will be written into
     * @param fovy Vertical field of view in radians
     * @param aspect Aspect ratio. typically viewport width/height
     * @param near Near bound of the frustum
     * @param far Far bound of the frustum
     * @returns  out
     */
    perspective(out: mat4, fovy: number, aspect: number, near: number, far: number): mat4;

    /**
     * Generates a perspective projection matrix with the given field of view.
     * This is primarily useful for generating projection matrices to be used
    with the still experimental WebVR API.
     * @param  mat4 frustum matrix will be written into
     * @param  Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
     * @param  Near bound of the frustum
     * @param  Far bound of the frustum
     * @returns  out
    */
    perspectiveFromFieldOfView(
        out: mat4,
        fov: {
            upDegrees: number,
            downDegrees: number,
            leftDegrees: number,
            rightDegrees: number
        },
        near: number,
        far: number): mat4;

    /**
     * Generates a orthogonal projection matrix with the given bounds
     * @param out mat4 frustum matrix will be written into
     * @param left Left bound of the frustum
     * @param right Right bound of the frustum
     * @param bottom Bottom bound of the frustum
     * @param top Top bound of the frustum
     * @param near Near bound of the frustum
     * @param far Far bound of the frustum
     * @returns  out
     */
    ortho(
        out: mat4,
        left: number,
        right: number,
        bottom: number,
        top: number,
        near: number,
        far: number): mat4;

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     * @param out mat4 frustum matrix will be written into
     * @param eye Position of the viewer
     * @param center Point the viewer is looking at
     * @param up vec3 pointing up
     * @returns  out
     */
    lookAt(
        out: mat4,
        eye: vec3 | number[],
        center: vec3 | number[],
        up: vec3 | number[]): mat4;

    /**
     * Returns a string representation of a mat4
     * @param mat matrix to represent as a string
     * @returns  string representation of the matrix
     */
    str(mat: mat4): string;

    /**
     * Returns Frobenius norm of a mat4
     * @param a the matrix to calculate Frobenius norm of
     * @returns  Frobenius norm
     */
    frob(a: mat4): number;

    /**
     * Adds two mat4's
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    add(out: mat4, a: mat4, b: mat4): mat4;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    subtract(out: mat4, a: mat4, b: mat4): mat4;

    /**
     * Subtracts matrix b from matrix a
     * @param  the receiving matrix
     * @param  the first operand
     * @param  the second operand
     * @returns  out
     */
    sub(out: mat4, a: mat4, b: mat4): mat4;

    /**
     * Multiply each element of the matrix by a scalar.
     * @param  the receiving matrix
     * @param  the matrix to scale
     * @param  amount to scale the matrix's elements by
     * @returns  out
     */
    multiplyScalar(out: mat4, a: mat4, b: number): mat4;

    /**
     * Adds two mat4's after multiplying each element of the second operand by a scalar value.
     * @param  the receiving vector
     * @param  the first operand
     * @param  the second operand
     * @param  the amount to scale b's elements by before adding
     * @returns  out
     */
    multiplyScalarAndAdd(out: mat4, a: mat4, b: mat4, scale: number): mat4;

    /**
     * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    exactEquals(a: mat4, b: mat4): boolean;

    /**
     * Returns whether or not the matrices have approximately the same elements in the same position.
     * @param  The first matrix.
     * @param  The second matrix.
     * @returns  True if the matrices are equal, false otherwise.
     */
    equals(a: mat4, b: mat4): boolean
}
declare export class quat mixins Float32Array {

    /**
     * Creates a new identity quat
     * @returns  a new quaternion
     */
    create(): quat;

    /**
     * Creates a new quat initialized with values from an existing quaternion
     * @param a quaternion to clone
     * @returns  a new quaternion
     * @function  
     */
    clone(a: quat): quat;

    /**
     * Creates a new quat initialized with the given values
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @param w W component
     * @returns  a new quaternion
     * @function  
     */
    fromValues(x: number, y: number, z: number, w: number): quat;

    /**
     * Copy the values from one quat to another
     * @param out the receiving quaternion
     * @param a the source quaternion
     * @returns  out
     * @function  
     */
    copy(out: quat, a: quat): quat;

    /**
     * Set the components of a quat to the given values
     * @param out the receiving quaternion
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @param w W component
     * @returns  out
     * @function  
     */
    set(out: quat, x: number, y: number, z: number, w: number): quat;

    /**
     * Set a quat to the identity quaternion
     * @param out the receiving quaternion
     * @returns  out
     */
    identity(out: quat): quat;

    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.

    Both vectors are assumed to be unit length.
     * @param  the receiving quaternion.
     * @param  the initial vector
     * @param  the destination vector
     * @returns  out
    */
    rotationTo(out: quat, a: vec3 | number[], b: vec3 | number[]): quat;

    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
    perpendicular to all other specified axes.
     * @param  the vector representing the viewing direction
     * @param  the vector representing the local "right" direction
     * @param  the vector representing the local "up" direction
     * @returns  out
    */
    setAxes(
        out: quat,
        view: vec3 | number[],
        right: vec3 | number[],
        up: vec3 | number[]): quat;

    /**
     * Sets a quat from the given angle and rotation axis,
     * then returns it.
     * @param out the receiving quaternion
     * @param axis the axis around which to rotate
     * @param rad the angle in radians
     * @returns  out
     */
    setAxisAngle(out: quat, axis: vec3 | number[], rad: number): quat;

    /**
     * Gets the rotation axis and angle for a given
     *   quaternion. If a quaternion is created with
      setAxisAngle, this method will return the same
      values as providied in the original parameter list
      OR functionally equivalent values.
    Example: The quaternion formed by axis [0, 0, 1] and
      angle -90 is the same as the quaternion formed by
      [0, 0, 1] and 270. This method favors the latter.
     * @param  Vector receiving the axis of rotation
     * @param  Quaternion to be decomposed
     * @return  Angle, in radians, of the rotation
    */
    getAxisAngle(out_axis: vec3 | number[], q: quat): number;

    /**
     * Adds two quat's
     * @param out the receiving quaternion
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     * @function  
     */
    add(out: quat, a: quat, b: quat): quat;

    /**
     * Multiplies two quat's
     * @param out the receiving quaternion
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    multiply(out: quat, a: quat, b: quat): quat;

    /**
     * Multiplies two quat's
     * @param out the receiving quaternion
     * @param a the first operand
     * @param b the second operand
     * @returns  out
     */
    mul(out: quat, a: quat, b: quat): quat;

    /**
     * Scales a quat by a scalar number
     * @param out the receiving vector
     * @param a the vector to scale
     * @param b amount to scale the vector by
     * @returns  out
     * @function  
     */
    scale(out: quat, a: quat, b: number): quat;

    /**
     * Calculates the length of a quat
     * @param a vector to calculate length of
     * @returns  length of a
     * @function  
     */
    length(a: quat): number;

    /**
     * Calculates the length of a quat
     * @param a vector to calculate length of
     * @returns  length of a
     * @function  
     */
    len(a: quat): number;

    /**
     * Calculates the squared length of a quat
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     * @function  
     */
    squaredLength(a: quat): number;

    /**
     * Calculates the squared length of a quat
     * @param a vector to calculate squared length of
     * @returns  squared length of a
     * @function  
     */
    sqrLen(a: quat): number;

    /**
     * Normalize a quat
     * @param out the receiving quaternion
     * @param a quaternion to normalize
     * @returns  out
     * @function  
     */
    normalize(out: quat, a: quat): quat;

    /**
     * Calculates the dot product of two quat's
     * @param a the first operand
     * @param b the second operand
     * @returns  dot product of a and b
     * @function  
     */
    dot(a: quat, b: quat): number;

    /**
     * Performs a linear interpolation between two quat's
     * @param out the receiving quaternion
     * @param a the first operand
     * @param b the second operand
     * @param t interpolation amount between the two inputs
     * @returns  out
     * @function  
     */
    lerp(out: quat, a: quat, b: quat, t: number): quat;

    /**
     * Performs a spherical linear interpolation between two quat
     * @param out the receiving quaternion
     * @param a the first operand
     * @param b the second operand
     * @param t interpolation amount between the two inputs
     * @returns  out
     */
    slerp(out: quat, a: quat, b: quat, t: number): quat;

    /**
     * Performs a spherical linear interpolation with two control points
     * @param  the receiving quaternion
     * @param  the first operand
     * @param  the second operand
     * @param  the third operand
     * @param  the fourth operand
     * @param  interpolation amount
     * @returns  out
     */
    sqlerp(out: quat, a: quat, b: quat, c: quat, d: quat, t: number): quat;

    /**
     * Calculates the inverse of a quat
     * @param out the receiving quaternion
     * @param a quat to calculate inverse of
     * @returns  out
     */
    invert(out: quat, a: quat): quat;

    /**
     * Calculates the conjugate of a quat
     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
     * @param out the receiving quaternion
     * @param a quat to calculate conjugate of
     * @returns  out
     */
    conjugate(out: quat, a: quat): quat;

    /**
     * Returns a string representation of a quaternion
     * @param a quat to represent as a string
     * @returns  string representation of the quat
     */
    str(a: quat): string;

    /**
     * Rotates a quaternion by the given angle about the X axis
     * @param out quat receiving operation result
     * @param a quat to rotate
     * @param rad angle (in radians) to rotate
     * @returns  out
     */
    rotateX(out: quat, a: quat, rad: number): quat;

    /**
     * Rotates a quaternion by the given angle about the Y axis
     * @param out quat receiving operation result
     * @param a quat to rotate
     * @param rad angle (in radians) to rotate
     * @returns  out
     */
    rotateY(out: quat, a: quat, rad: number): quat;

    /**
     * Rotates a quaternion by the given angle about the Z axis
     * @param out quat receiving operation result
     * @param a quat to rotate
     * @param rad angle (in radians) to rotate
     * @returns  out
     */
    rotateZ(out: quat, a: quat, rad: number): quat;

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * 
    NOTE: The resultant quaternion is not normalized, so you should be sure
    to renormalize the quaternion yourself where necessary.
     * @param out the receiving quaternion
     * @param m rotation matrix
     * @returns  out
     * @function  
    */
    fromMat3(out: quat, m: mat3): quat;

    /**
     * Sets the specified quaternion with values corresponding to the given
     * axes. Each axis is a vec3 and is expected to be unit length and
    perpendicular to all other specified axes.
     * @param out the receiving quat
     * @param view the vector representing the viewing direction
     * @param right the vector representing the local "right" direction
     * @param up the vector representing the local "up" direction
     * @returns  out
    */
    setAxes(
        out: quat,
        view: vec3 | number[],
        right: vec3 | number[],
        up: vec3 | number[]): quat;

    /**
     * Sets a quaternion to represent the shortest rotation from one
     * vector to another.

    Both vectors are assumed to be unit length.
     * @param out the receiving quaternion.
     * @param a the initial vector
     * @param b the destination vector
     * @returns  out
    */
    rotationTo(out: quat, a: vec3 | number[], b: vec3 | number[]): quat;

    /**
     * Calculates the W component of a quat from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
    Any existing W component will be ignored.
     * @param out the receiving quaternion
     * @param a quat to calculate W component of
     * @returns  out
    */
    calculateW(out: quat, a: quat): quat;

    /**
     * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the quaternions are equal, false otherwise.
     */
    exactEquals(a: quat, b: quat): boolean;

    /**
     * Returns whether or not the quaternions have approximately the same elements in the same position.
     * @param  The first vector.
     * @param  The second vector.
     * @returns  True if the quaternions are equal, false otherwise.
     */
    equals(a: quat, b: quat): boolean
}