/**
 * Flowtype definitions for normalizr
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'normalizr' {
    declare module.exports: typeof Normalizr
}

declare var npm$namespace$Normalizr: {
    arrayOf: typeof Normalizr$arrayOf,
    valuesOf: typeof Normalizr$valuesOf,
    unionOf: typeof Normalizr$unionOf,
    normalize: typeof Normalizr$normalize,
}
declare type Normalizr$AttributeSetting = string | ((entity: any) => any);

declare type Normalizr$SchemaClass = Normalizr$Schema | Normalizr$ArraySchema | Normalizr$UnionSchema;

declare type Normalizr$SchemaObject = {
    [property: string]: Normalizr$SchemaClass | Normalizr$SchemaObject
};

declare type Normalizr$SchemaType = Normalizr$SchemaClass | Normalizr$SchemaObject | Object;

declare export class Schema {

    /**
     * Schema lets you define a type of entity returned by your API.
     * This should correspond to model in your server code.
     * @param key The key parameter lets you specify the name of the dictionary for this kind of entity.
     * @param options 
     */
    constructor(key: string, options?: {
        idAttribute: Normalizr$AttributeSetting
    }): this;

    /**
     * Lets you specify relationships between different entities.
     * @param nestedSchema 
     */
    define(nestedSchema: Normalizr$SchemaObject): void;

    /**
     * Returns the key of the schema.
     */
    getKey(): string;

    /**
     * Returns the idAttribute of the schema.
     */
    getIdAttribute(): Normalizr$AttributeSetting
}

declare interface Normalizr$UnionSchema {
    getItemSchema(): Normalizr$SchemaType,
        getSchemaKey(item: any): string
}

declare interface Normalizr$ArraySchema {
    getItemSchema(): Normalizr$SchemaType
}


/**
 * Describes an array of the schema passed as argument.
 * @param schema 
 * @param options 
 */
declare export function Normalizr$arrayOf(
    schema: Normalizr$SchemaType,
    options?: {

        /**
         * If the array contains entities with different schemas, you can use the schemaAttribute option to specify which schema to use for each entity.
         */
        schemaAttribute: Normalizr$AttributeSetting
    }): Normalizr$ArraySchema


/**
 * Describes a map whose values follow the schema passed as argument.
 * @param schema 
 * @param options 
 */
declare export function Normalizr$valuesOf(
    schema: Normalizr$SchemaType,
    options?: {

        /**
         * If the map contains entities with different schemas, you can use the schemaAttribute option to specify which schema to use for each entity.
         */
        schemaAttribute: Normalizr$AttributeSetting
    }): Normalizr$ArraySchema


/**
 * Describe a schema which is a union of multiple schemas. This is useful if you need the polymorphic behavior provided by arrayOf or valuesOf but for non-collection fields.
 * @param schemaMap 
 * @param options 
 */
declare export function Normalizr$unionOf(
    schemaMap: Normalizr$SchemaType,
    options?: {

        /**
         * Use the required schemaAttribute option to specify which schema to use for each entity.
         */
        schemaAttribute: Normalizr$AttributeSetting
    }): Normalizr$UnionSchema


/**
 * Normalizes object according to schema.
 * Passed schema should be a nested object reflecting the structure of API response.
 * @param obj 
 * @param schema 
 * @param options 
 */
declare export function Normalizr$normalize(
    obj: any | Array<any>,
    schema: Normalizr$SchemaType,
    options?: {

        /**
         * This is useful if your backend emits additional fields, such as separate ID fields, you'd like to delete in the normalized entity.
         */
        assignEntity?: (normalized: any, key: string, entity: any) => any,

        /**
         * You can use this to resolve conflicts when merging entities with the same key.
         */
        mergeIntoEntity?: (stored: any, normalized: any, entityKey: string) => any
    }): {
    entities: any,
    result: any
}