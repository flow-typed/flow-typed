/**
 * Flowtype definitions for mocha
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface MochaSetupOptions {
    slow?: number,
        timeout?: number,
        ui?: string,
        globals?: any[],
        reporter?: any,
        bail?: boolean,
        ignoreLeaks?: boolean,
        grep?: any
}
declare var mocha: Mocha;
declare var describe: Mocha$IContextDefinition;
declare var xdescribe: Mocha$IContextDefinition;
declare var context: Mocha$IContextDefinition;
declare var suite: Mocha$IContextDefinition;
declare var it: Mocha$ITestDefinition;
declare var xit: Mocha$ITestDefinition;
declare var test: Mocha$ITestDefinition;
declare var specify: Mocha$ITestDefinition;
declare function run(): voiddeclare interface MochaDone {
    (error?: any): any
}
declare interface ActionFunction {
    (done: MochaDone): any | PromiseLike<any >
}
declare function setup(action: ActionFunction): voiddeclare function teardown(action: ActionFunction): voiddeclare function suiteSetup(action: ActionFunction): voiddeclare function suiteTeardown(action: ActionFunction): voiddeclare function before(action: ActionFunction): voiddeclare function after(action: ActionFunction): voiddeclare function beforeEach(action: ActionFunction): voiddeclare function afterEach(action: ActionFunction): voiddeclare class Mocha {
    currentTest: Mocha$ITestDefinition;
    constructor(options?: {
        grep?: RegExp,
        ui?: string,
        reporter?: string,
        timeout?: number,
        bail?: boolean
    }): this;

    /**
     * Setup mocha with the given options. 
     */
    setup(options: MochaSetupOptions): Mocha;
    bail(value?: boolean): Mocha;
    addFile(file: string): Mocha;

    /**
     * Sets reporter by name, defaults to "spec". 
     */
    reporter(name: string): Mocha;

    /**
     * Sets reporter constructor, defaults to mocha.reporters.Spec. 
     */
    reporter(reporter: (runner: Mocha$IRunner, options: any) => any): Mocha;
    ui(value: string): Mocha;
    grep(value: string): Mocha;
    grep(value: RegExp): Mocha;
    invert(): Mocha;
    ignoreLeaks(value: boolean): Mocha;
    checkLeaks(): Mocha;

    /**
     * Function to allow assertion libraries to throw errors directly into mocha.
     * This is useful when running tests in a browser because window.onerror will
    only receive the 'message' attribute of the Error.
    */
    throwError(error: Error): void;

    /**
     * Enables growl support. 
     */
    growl(): Mocha;
    globals(value: string): Mocha;
    globals(values: string[]): Mocha;
    useColors(value: boolean): Mocha;
    useInlineDiffs(value: boolean): Mocha;
    timeout(value: number): Mocha;
    slow(value: number): Mocha;
    enableTimeouts(value: boolean): Mocha;
    asyncOnly(value: boolean): Mocha;
    noHighlighting(value: boolean): Mocha;

    /**
     * Runs tests and invokes `onComplete()` when finished. 
     */
    run(onComplete?: (failures: number) => void): Mocha$IRunner
}
/**
 * Partial interface for Mocha's `Runnable` class. 
 */
declare interface Mocha$IRunnable {
    title: string,
        fn: Function,
        async: boolean,
        sync: boolean,
        timedOut: boolean
}


/**
 * Partial interface for Mocha's `Suite` class. 
 */
declare interface Mocha$ISuite {
    parent: Mocha$ISuite,
        title: string,
        fullTitle(): string
}


/**
 * Partial interface for Mocha's `Test` class. 
 */
declare type Mocha$ITest = {
    parent: Mocha$ISuite,
    pending: boolean,
    fullTitle(): string
} & Mocha$IRunnable



/**
 * Partial interface for Mocha's `Runner` class. 
 */
declare interface Mocha$IRunner {}

declare interface Mocha$IContextDefinition {
    (description: string, spec: () => void): Mocha$ISuite,
    only(description: string, spec: () => void): Mocha$ISuite,
        skip(description: string, spec: () => void): void,
        timeout(ms: number): void
}

declare interface Mocha$ITestDefinition {
    (expectation: string, assertion?: ActionFunction): Mocha$ITest,
    only(expectation: string, assertion?: ActionFunction): Mocha$ITest,
        skip(expectation: string, assertion?: ActionFunction): void,
        timeout(ms: number): void,
        state: "failed" | "passed"
}

declare module 'reporters' {
    declare export class Base {
        stats: {
            suites: number,
            tests: number,
            passes: number,
            pending: number,
            failures: number
        };
        constructor(runner: Mocha$IRunner): this
    }
    declare export class Doc mixins Base {}
    declare export class Dot mixins Base {}
    declare export class HTML mixins Base {}
    declare export class HTMLCov mixins Base {}
    declare export class JSON mixins Base {}
    declare export class JSONCov mixins Base {}
    declare export class JSONStream mixins Base {}
    declare export class Landing mixins Base {}
    declare export class List mixins Base {}
    declare export class Markdown mixins Base {}
    declare export class Min mixins Base {}
    declare export class Nyan mixins Base {}
    declare export class Progress mixins Base {

        /**
         * 
         * @param options .open String used to indicate the start of the progress bar.
         * @param options .complete String used to indicate a complete test on the progress bar.
         * @param options .incomplete String used to indicate an incomplete test on the progress bar.
         * @param options .close String used to indicate the end of the progress bar.
         */
        constructor(runner: Mocha$IRunner, options?: {
            open?: string,
            complete?: string,
            incomplete?: string,
            close?: string
        }): this
    }
    declare export class Spec mixins Base {}
    declare export class TAP mixins Base {}
    declare export class XUnit mixins Base {
        constructor(runner: Mocha$IRunner, options?: any): this
    }
}
declare module 'mocha' {
    declare module.exports: typeof Mocha
}