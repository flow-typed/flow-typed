/**
 * Flowtype definitions for when
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
function When<T>(value: When$Promise<T>): When$Promise<T >
    declare
var npm$namespace$When: {
    attempt: typeof When$attempt,
    lift: typeof When$lift,
    promise: typeof When$promise,
    reject: typeof When$reject,
    all: typeof When$all,
    map: typeof When$map,
    reduce: typeof When$reduce,
    reduceRight: typeof When$reduceRight,
    settle: typeof When$settle,
    iterate: typeof When$iterate,
    unfold: typeof When$unfold,
    defer: typeof When$defer,
    join: typeof When$join,
    resolve: typeof When$resolve,
}
declare module '_' {
    declare interface Fn0<T>{
        (): T
    }
    declare interface Fn1<A1, T>{
        (a1: A1): T
    }
    declare interface Fn2<A1, A2, T>{
        (a1: A1, a2: A2): T
    }
    declare interface Fn3<A1, A2, A3, T>{
        (a1: A1, a2: A2, a3: A3): T
    }
    declare interface Fn4<A1, A2, A3, A4, T>{
        (a1: A1, a2: A2, a3: A3, a4: A4): T
    }
    declare interface Fn5<A1, A2, A3, A4, A5, T>{
        (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T
    }
    declare interface Fn6<A1, A2, A3, A4, A5, A6, T>{
        (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T
    }
    declare type LiftedFn0<T>= {} & Fn0

    declare type LiftedFn1<A1, T>= {} & Fn1

    declare type LiftedFn2<A1, A2, T>= {} & Fn2

    declare type LiftedFn3<A1, A2, A3, T>= {} & Fn3

    declare type LiftedFn4<A1, A2, A3, A4, T>= {} & Fn4

    declare type LiftedFn5<A1, A2, A3, A4, A5, T>= {} & Fn5

    declare interface NodeCallback<T>{
        (err: any, result: T): void
    }
    declare type NodeFn0<T>= {}
    declare type NodeFn1<A1, T>= {}
    declare type NodeFn2<A1, A2, T>= {}
    declare type NodeFn3<A1, A2, A3, T>= {}
    declare type NodeFn4<A1, A2, A3, A4, T>= {}
    declare type NodeFn5<A1, A2, A3, A4, A5, T>= {}
}


declare
function When$attempt<T>(f: _.Fn0<T>): When$Promise<T >

    declare
function When$lift<T>(f: _.Fn0<T>): _.LiftedFn0<T >

    declare
function When$promise<T>(
        resolver: (resolve: (value: T) => void, reject: (reason: any) => void) => void): When$Promise<T >

    declare
function When$reject<T>(reason: any): When$Promise<T >


    /**
     * Return a promise that will resolve only once all the supplied promisesOrValues
     * have resolved. The resolution value of the returned promise will be an array
    containing the resolution values of each of the promisesOrValues.
     * @memberOf  when
     * @param promisesOrValues array of anything, may contain a mix
    of {
     * @link  Promise}s and values
    */
    declare
function When$all<T>(promisesOrValues: any[]): When$Promise<T >


    /**
     * Promise-aware array map function, similar to `Array.prototype.map()`,
     * but input array may contain promises or values.
     * @param promisesOrValues array of anything, may contain a mix of {
     * @link  Promise}s and values
     * @param mapFunc map function which may return a promise or value
     * @returns  a promise that will fulfill with an array of mapped values
    or reject if any input promise rejects.
    */
    declare
function When$map<T>(
        promisesOrValues: any[],
        mapFunc: (value: any, index?: Number) => any): When$Promise<T >


    /**
     * Traditional reduce function, similar to `Array.prototype.reduce()`, but
     * input may contain promises and/or values, and reduceFunc
    may return either a value or a promise, and initialValue may
    be a promise for the starting value.
     * @param promisesOrValues array or promise for an array of anything,
    may contain a mix of promises and values.
     * @param reduceFunc function(accumulated:*, x:*, index:Number):*} f reduce function
     * @returns  a promise that will resolve to the final reduced value
    */
    declare
function When$reduce<T>(
        promisesOrValues: any[],
        reduceFunc: (reduction: T, value: any, index?: Number) => T | When$Promise<T>,
        initialValue: T): When$Promise<T >


    /**
     * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
     * input may contain promises and/or values, and reduceFunc
    may return either a value or a promise, and initialValue may
    be a promise for the starting value.
     * @param promisesOrValues array or promise for an array of anything,
    may contain a mix of promises and values.
     * @param reduceFunc function(accumulated:*, x:*, index:Number):*} f reduce function
     * @returns  a promise that will resolve to the final reduced value
    */
    declare
function When$reduceRight<T>(
        promisesOrValues: any[],
        reduceFunc: (reduction: T, value: any, index?: Number) => T | When$Promise<T>,
        initialValue: T): When$Promise<T >


    /**
     * Describes the status of a promise.
     * state may be one of:
    "fulfilled" - the promise has resolved
    "pending" - the promise is still pending to resolve/reject
    "rejected" - the promise has rejected
    */
    declare interface When$Descriptor<T>{
        state: string,
        value?: T,
        reason?: any
    }


/**
 * Returns a promise for an array containing the same number of elements as the input array.
 * Each element is a descriptor object describing of the outcome of the corresponding element in the input.
The returned promise will only reject if array itself is a rejected promise. Otherwise,
it will always fulfill with an array of descriptors. This is in contrast to when.all,
which will reject if any element of array rejects.
 * @memberOf  when
 * @param promisesOrValues array of anything, may contain a mix
of {
 * @link  Promise}s and values
*/
declare
function When$settle<T>(promisesOrValues: any[]): When$Promise<When$Descriptor<T>[] >


    /**
     * Generates a potentially infinite stream of promises by repeatedly calling f until predicate becomes true.
     * @memberOf  when
     * @param f function that, given a seed, returns the next value or a promise for it.
     * @param predicate function that receives the current iteration value, and should return truthy when the iterating should stop
     * @param handler function that receives each value as it is produced by f. It may return a promise to delay the next iteration.
     * @param seed initial value provided to the handler, and first f invocation. May be a promise.
     */
    declare
function When$iterate<U>(
        f: (seed: U) => U | When$Promise<U>,
        predicate: (value: U) => boolean,
        handler: (value: U) => When$Promise<any>| void,
        seed: U | When$Promise<U>): When$Promise<U >


    /**
     * Similar to when/iterate, when.unfold generates a potentially infinite stream of promises by repeatedly calling
     * unspool until predicate becomes true. when.unfold allows you to thread additional state information through the iteration.
     * @memberOf  when
     * @param unspool function that, given a seed, returns a [valueToSendToHandler, newSeed] pair.
    May return an array, array of promises, promise for an array, or promise for an array of promises.
     * @param predicate function that receives the current seed, and should return truthy when the unfold should stop
     * @param handler function that receives the valueToSendToHandler of the current iteration.
    This function can process valueToSendToHandler in whatever way you need.
    It may return a promise to delay the next iteration of the unfold.
     * @param seed initial value provided to the first unspool invocation. May be a promise.
    */
    declare
function When$unfold<T, U>(
        unspool: (
            seed: U) => [T | When$Promise<T>, U | When$Promise<U>] | When$Promise<[T | When$Promise<T>, U | When$Promise<U>]>,
        predicate: (value: U) => boolean | When$Promise<boolean>,
        handler: (value: T) => When$Promise<any>| void,
        seed: U | When$Promise<U>): When$Promise<void >


    /**
     * Creates a {promise, resolver} pair, either or both of which
     * may be given out safely to consumers.
    The resolver has resolve, reject, and progress.  The promise
    has then plus extended promise API.
    */
    declare
function When$defer<T>(): When$Deferred<T >


    /**
     * Joins multiple promises into a single returned promise.
     * @return  a promise that will fulfill when *all* the input promises
    have fulfilled, or will reject when *any one* of the input promises rejects.
    */
    declare
function When$join<T>(...promises: When$Promise<T>[]): When$Promise<T[] >


    /**
     * Returns a resolved promise. The returned promise will be
     *   - fulfilled with promiseOrValue if it is a value, or
      - if promiseOrValue is a promise
        - fulfilled with promiseOrValue's value after it is fulfilled
        - rejected with promiseOrValue's reason after it is rejected
    */
    declare
function When$resolve<T>(promise: When$Promise<T>): When$Promise<T >

    declare interface When$Deferred<T>{
        notify(update: any): void,
        promise: When$Promise<T>,
        reject(reason: any): void,
        resolve(value?: T): void,
        resolve(value?: When$Promise<T>): void
    }

declare interface When$Promise<T>{
    catch<U>(onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    catch<U>(
        filter: (reason: any) => boolean,
        onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    catch<U>(
        exceptionType: any,
        onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    finally(onFulfilledOrRejected: Function): When$Promise<T>,
    ensure(onFulfilledOrRejected: Function): When$Promise<T>,
    inspect(): When$Snapshot<T>,
    yield<U>(value: U | When$Promise<U>): When$Promise<U>,
    else(value: T): When$Promise<T>,
    orElse(value: T): When$Promise<T>,
    tap(onFulfilledSideEffect: (value: T) => void): When$Promise<T>,
    delay(milliseconds: number): When$Promise<T>,
    timeout(milliseconds: number, reason?: any): When$Promise<T>,
    with(thisArg: any): When$Promise<T>,
    withThis(thisArg: any): When$Promise<T>,
    otherwise<U>(onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    otherwise<U>(
        predicate: (reason: any) => boolean,
        onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    otherwise<U>(
        exceptionType: any,
        onRejected?: (reason: any) => U | When$Promise<U>): When$Promise<U>,
    then<U>(
        onFulfilled: (value: T) => U | When$Promise<U>,
        onRejected?: (reason: any) => U | When$Promise<U>,
        onProgress?: (update: any) => void): When$Promise<U>,
    spread<T>(onFulfilled: _.Fn0<When$Promise<T>| T>): When$Promise<T>,
    spread<A1,
    T>(onFulfilled: _.Fn1<A1, When$Promise<T>| T>): When$Promise<T>,
    spread<A1,
    A2,
    T>(onFulfilled: _.Fn2<A1, A2, When$Promise<T>| T>): When$Promise<T>,
    spread<A1,
    A2,
    A3,
    T>(
        onFulfilled: _.Fn3<A1, A2, A3, When$Promise<T>| T>): When$Promise<T>,
    spread<A1,
    A2,
    A3,
    A4,
    T>(
        onFulfilled: _.Fn4<A1, A2, A3, A4, When$Promise<T>| T>): When$Promise<T>,
    spread<A1,
    A2,
    A3,
    A4,
    A5,
    T>(
        onFulfilled: _.Fn5<A1, A2, A3, A4, A5, When$Promise<T>| T>): When$Promise<T>,
    done<U>(onFulfilled: (value: T) => void, onRejected?: (reason: any) => void): void,
    fold<U,
    V>(
        combine: (value1: T, value2: V) => U | When$Promise<U>,
        value2: V | When$Promise<V>): When$Promise<U >
}

declare interface When$Thenable<T>{
    then<U>(
        onFulfilled: (value: T) => U,
        onRejected?: (reason: any) => U): When$Thenable<U >
}

declare interface When$Snapshot<T>{
    state: string,
    value?: T,
    reason?: any
}
declare module 'when' {
    declare module.exports: typeof When
}
declare module 'when/node' {
    declare function lift<T>(f: _.Fn0<T>): _.LiftedFn0<T >
        declare function call<T>(fn: _.NodeFn0<T>): when.Promise<T >
        declare function apply<T>(fn: _.NodeFn0<T>, args: any[] | IArguments): when.Promise<T >
        declare function liftAll(
        srcApi: any,
        transform?: (destApi: any, liftedFunc: Function, name: string) => any,
        destApi?: any): any
    declare function liftCallback<TArg>(
            callback: (err: any, arg: TArg) => void): (value: when.Promise<TArg>) => when.Promise<TArg >
        declare function bindCallback<TArg>(
            arg: when.Promise<TArg>,
            callback: (err: any, arg: TArg) => void): when.Promise<TArg >
        declare interface Resolver<T>{
            reject(reason: any): void,
            resolve(value?: T): void,
            resolve(value?: when.Promise<T>): void
        }
    declare function createCallback<TArg>(resolver: Resolver<TArg>): (err: any, arg: TArg) => void
}