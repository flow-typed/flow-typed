// @flow
/**
 * Flowtype definitions for later
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export interface Later$IScheduleData {

    /**
     * A list of recurrence information as a composite schedule.
     */
    schedules: Later$IRecurrence[],

        /**
         * A list of exceptions to the composite recurrence information.
         */
        exceptions: Later$IRecurrence[],

        /**
         * A code to identify any errors in the composite schedule and exceptions.
         * The number tells you the position of the error within the schedule.
         */
        error: number
}

declare export interface Later$IRecurrence {

    /**
     * Time in seconds from midnight.
     */
    t?: number[],

        /**
         * Seconds in minute.
         */
        s?: number[],

        /**
         * Minutes in hour.
         */
        m?: number[],

        /**
         * Hour in day.
         */
        h?: number[],

        /**
         * Day of the month.
         */
        D?: number[],

        /**
         * Day in week.
         */
        dw?: number[],

        /**
         * Nth day of the week in month.
         */
        dc?: number[],

        /**
         * Day in year.
         */
        dy?: number[],

        /**
         * Week in month.
         */
        wm?: number[],

        /**
         * ISO week in year.
         */
        wy?: number[],

        /**
         * Month in year.
         */
        M?: number[],

        /**
         * Year.
         */
        Y?: number[],

        /**
         * After modifiers.
         */
        t_a?: number[],

        /**
         * After modifiers.
         */
        s_a?: number[],

        /**
         * After modifiers.
         */
        m_a?: number[],

        /**
         * After modifiers.
         */
        h_a?: number[],

        /**
         * After modifiers.
         */
        D_a?: number[],

        /**
         * After modifiers.
         */
        dw_a?: number[],

        /**
         * After modifiers.
         */
        dc_a?: number[],

        /**
         * After modifiers.
         */
        dy_a?: number[],

        /**
         * After modifiers.
         */
        wm_a?: number[],

        /**
         * After modifiers.
         */
        wy_a?: number[],

        /**
         * After modifiers.
         */
        M_a?: number[],

        /**
         * After modifiers.
         */
        Y_a?: number[],

        /**
         * Before modifiers.
         */
        t_b?: number[],

        /**
         * Before modifiers.
         */
        s_b?: number[],

        /**
         * Before modifiers.
         */
        m_b?: number[],

        /**
         * Before modifiers.
         */
        h_b?: number[],

        /**
         * Before modifiers.
         */
        D_b?: number[],

        /**
         * Before modifiers.
         */
        dw_b?: number[],

        /**
         * Before modifiers.
         */
        dc_b?: number[],

        /**
         * Before modifiers.
         */
        dy_b?: number[],

        /**
         * Before modifiers.
         */
        wm_b?: number[],

        /**
         * Before modifiers.
         */
        wy_b?: number[],

        /**
         * Before modifiers.
         */
        M_b?: number[],

        /**
         * Before modifiers.
         */
        Y_b?: number[], [timeperiodAndModifierName: string]: number[]
}

declare export interface Later$IParseStatic {

    /**
     * Create a recurrence builder for building schedule data.
     */
    recur(): Later$IRecurrenceBuilder,

        /**
         * Create schedule data by parsing a cron string
         * @param  - A string value to parse.
         */
        cron(input?: string): Later$IScheduleData,

        /**
         * Create schedule data by paring a human readable string.
         * @param  - A string value to parse.
         */
        text(input?: string): Later$IScheduleData
}

declare export interface Later$ITimer {

    /**
     * Clear the timer and end execution.
     */
    clear(): void
}

declare export interface Later$ISchedule {

    /**
     * Finds the next valid instance or instances of the current schedule,
     * optionally between a specified start and end date. Start date is
    Date.now() by default, end date is unspecified. Start date must be
    smaller than end date.
     * @param  : The number of instances to return
     * @param  : The earliest a valid instance can occur
     * @param  : The latest a valid instance can occur
    */
    next(numberOfInst: number, dateFrom?: Date, dateTo?: Date): Date[],

        /**
         * Finds the next valid range or ranges of the current schedule,
         * optionally between a specified start and end date. Start date is
        Date.now() by default, end date is unspecified. Start date must be
        greater than end date.
         * @param  : The number of ranges to return
         * @param  : The earliest a valid range can occur
         * @param  : The latest a valid range can occur
        */
        nextRange(numberOfInst: number, dateFrom?: Date, dateTo?: Date): Date[],

        /**
         * Finds the previous valid instance or instances of the current schedule,
         * optionally between a specified start and end date. Start date is
        Date.now() by default, end date is unspecified. Start date must be
        greater than end date.
         * @param  : The number of instances to return
         * @param  : The earliest a valid instance can occur
         * @param  : The latest a valid instance can occur
        */
        prev(numberOfInst: number, dateFrom?: Date, dateTo?: Date): Date[],

        /**
         * Finds the previous valid range or ranges of the current schedule,
         * optionally between a specified start and end date. Start date is
        Date.now() by default, end date is unspecified. Start date must be
        greater than end date.
         * @param  : The number of ranges to return
         * @param  : The earliest a valid range can occur
         * @param  : The latest a valid range can occur
        */
        prevRange(numberOfInst: number, dateFrom?: Date, dateTo?: Date): Date[]
}

declare export type Later$IRecurrenceBuilder = {

    /**
     * a time period
     */
    second(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    minute(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    hour(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    time(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    dayOfWeek(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    dayOfWeekCount(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    dayOfMonth(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    dayOfYear(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    weekOfMonth(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    weekOfYear(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    month(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    year(): Later$IRecurrenceBuilder,

    /**
     * a time period
     */
    fullDate(): Later$IRecurrenceBuilder,

    /**
     * Specifies one or more specific vals of a time period information provider.
     * When used to specify a time, a string indicating the 24-hour time may be used.
     * @param  - A list of values.
     */
    on(...values: number[]): Later$IRecurrenceBuilder,

    /**
     * Specifies one or more specific vals of a time period information provider.
     * When used to specify a time, a string indicating the 24-hour time may be used.
     * @param  - A string representing your value.
     */
    on(value: string): Later$IRecurrenceBuilder,

    /**
     * Specifies one or more specific vals of a time period information provider.
     * When used to specify a time, a string indicating the 24-hour time may be used.
     * @param  - A Date representing your value.
     */
    on(date: Date): Later$IRecurrenceBuilder,

    /**
     * Preceed a time period.
     * @param  - A number representing your value.
     */
    every(value?: number): Later$IRecurrenceBuilder,

    /**
     * Preceed a time period.
     * @param  - A string representing your value.
     */
    every(value?: string): Later$IRecurrenceBuilder,

    /**
     * Preceed a time period.
     * @param  - A number representing your start value.
     * @param  - A number representing your end value.
     */
    between(start: number, end: number): Later$IRecurrenceBuilder,

    /**
     * Preceed a time period.
     * @param  - A string representing your start value.
     * @param  - A string representing your end value.
     */
    between(start: string, end: string): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A number representing your value.
     */
    after(value: number): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A string representing your value.
     */
    after(value: string): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A number representing your value.
     */
    before(value: number): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A string representing your value.
     */
    before(value: string): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A number representing your value.
     */
    startingOn(value: number): Later$IRecurrenceBuilder,

    /**
     * After a time period.
     * @param  - A string representing your value.
     */
    startingOn(value: string): Later$IRecurrenceBuilder,

    /**
     * Equivalent to .on(min)
     */
    first(): Later$IRecurrenceBuilder,

    /**
     * Equivalent to .on(max)
     */
    last(): Later$IRecurrenceBuilder,

    /**
     * Equivalent to .on(1,7).dayOfWeek()
     */
    onWeekend(): Later$IRecurrenceBuilder,

    /**
     * Equivalent to .on(2,3,4,5,6).dayOfWeek()
     */
    onWeekday(): Later$IRecurrenceBuilder,

    /**
     * Add a new schedule value to schedules, composite schedule.
     */
    and(): Later$IRecurrenceBuilder,

    /**
     * Add exceptions.
     */
    except(): Later$IRecurrenceBuilder,

    /**
     * Custom Timeperiod Recurrences.
     * Using a key as defined by the custom period in any extension to Later.IStatic.
     */
    customPeriod(key: string): Later$IRecurrenceBuilder,

    /**
     * Customise Recurrences.
     * Using a key as defined by the custom modifier in any extension to Later.IModifierStatic.
     */
    customModifier(key: string, values: number): Later$IRecurrenceBuilder
} & Later$IScheduleData


declare export interface Later$IDateProvider {

    /**
     * Set later to use UTC time.
     */
    UTC(): void,

        /**
         * Set later to use local time.
         */
        localTime(): void,

        /**
         * Builds and returns a new Date using the specified values.  Date
         * returned is either using Local time or UTC based on isLocal.
         * @param  : Four digit year
         * @param  : Month between 1 and 12, defaults to 1
         * @param  : Date between 1 and 31, defaults to 1
         * @param  : Hour between 0 and 23, defaults to 0
         * @param  : Minute between 0 and 59, defaults to 0
         * @param  : Second between 0 and 59, defaults to 0
         */
        next(Y?: number, M?: number, D?: number, h?: number, m?: number, s?: number): Date,

        /**
         * Builds and returns a new Date using the specified values.  Date
         * returned is either using Local time or UTC based on isLocal.
         * @param  : Four digit year
         * @param  : Month between 0 and 11, defaults to 11
         * @param  : Date between 1 and 31, defaults to last day of month
         * @param  : Hour between 0 and 23, defaults to 23
         * @param  : Minute between 0 and 59, defaults to 59
         * @param  : Second between 0 and 59, defaults to 59
         */
        prev(Y?: number, M?: number, D?: number, h?: number, m?: number, s?: number): Date,

        /**
         * Determines if a value will cause a particular constraint to rollover to the
         * next largest time period. Used primarily when a constraint has a
        variable extent.
         * @param  : Date
         * @param  : Value
         * @param  : A modifier
         * @param  : A time period
        */
        nextRollover(
            d: Date,
            val: number,
            constraint: Later$IModifier,
            period: Later$ITimePeriod): Date,

        /**
         * Determines if a value will cause a particular constraint to rollover to the
         * previous largest time period. Used primarily when a constraint has a
        variable extent.
         * @param  : Date
         * @param  : Value
         * @param  : A modifier
         * @param  : A time period
        */
        prevRollover(
            d: Date,
            val: number,
            constraint: Later$IModifier,
            period: Later$ITimePeriod): Date
}

declare export interface Later$ITimePeriod {

    /**
     * The name of the time period information provider.
     */
    name: string,

        /**
         * The rough number of seconds that are covered when moving from one instance of this time period to the next instance.
         */
        range: number,

        /**
         * The value of this time period for the date specified.
         * @param  - The given date.
         */
        val(date: Date): number,

        /**
         * True if the specified value is valid for the specified date, false otherwise.
         * @param  - The given date.
         * @param  - The value to test for the date.
         */
        isValid(date: Date, value: any): boolean,

        /**
         * The minimum and maximum valid values for the time period for the specified date.
         * If the minimum value is not 0, 0 can be specified in schedules to indicate the maximum value.
        This makes working with non - constant extents(like days in a month) easier.
         * @param  - The given date.
        */
        extent(date?: Date): number[],

        /**
         * The first second in which the value is the same as the value of the specified date.
         *   For example, the start of an hour would be the hour with 0 minutes and 0 seconds.
         * @param  - The given date.
         */
        start(date: Date): Date,

        /**
         * The last second in which the value is the same as the value of the specified date.
         * For example, the end of an hour would be the hour with 59 minutes and 59 seconds.
         * @param  - The given date.
         */
        end(date: Date): Date,

        /**
         * Returns the next date where the value is the value specified.
         * Sets the value to 1 if value specified is greater than the max allowed value.
         * @param  - The given date.
         * @param  - The value to test for the date.
         */
        next(date: Date, value: any): Date,

        /**
         * Returns the previous date where the value is the value specified.
         * Sets the value to the max allowed value if the value specified is greater than the max allowed value.
         * @param  - The given date.
         * @param  - The value to test for the date.
         */
        prev(date: Date, value: any): Date
}

declare export type Later$IModifier = {

    /**
     * Creates a new modified constraint.
     * @param  : The constraint to be modified
     * @param  : The starting value of the after constraint
     */
    (constraint: Later$ITimePeriod, value: number): Later$ITimePeriod
} & Later$ITimePeriod


declare export interface Later$IModifierStatic {

    /**
     * After Modifier
     */
    after: Later$IModifier,

        /**
         * Before Modifier
         */
        before: Later$IModifier
}

declare export interface Later$IStatic {

    /**
     * Schedule
     * Generates instances from schedule data.
     */
    schedule(input: any): Later$ISchedule,

        /**
         * Parse
         * For generating schedule data.
         */
        parse: Later$IParseStatic,

        /**
         * Date Provider
         */
        date: Later$IDateProvider,

        /**
         * Set timeout on window using given recurrence next.- A recurrence instance.
         * @param  - A callback called after first instance of recurrence pattern.
         */
        setTimeout(callback: () => void, time: Later$IScheduleData): Later$ITimer,

        /**
         * Set interval on window using given recurrence- A recurrence instance.
         * @param  - A callback called after each instance of recurrence pattern.
         */
        setInterval(callback: () => void, time: Later$IScheduleData): Later$ITimer,

        /**
         * time period information provider.
         */
        time: Later$ITimePeriod,

        /**
         * Second time period information provider.
         */
        second: Later$ITimePeriod,

        /**
         * Minute time period information provider.
         */
        minute: Later$ITimePeriod,

        /**
         * Hour time period information provider.
         */
        hour: Later$ITimePeriod,

        /**
         * Day time period information provider.
         */
        day: Later$ITimePeriod,

        /**
         * Day of week time period information provider.
         */
        dayOfWeek: Later$ITimePeriod,

        /**
         * Day of week in month time period information provider.
         */
        dayOfWeekCount: Later$ITimePeriod,

        /**
         * Day in year time period information provider.
         */
        dayOfYear: Later$ITimePeriod,

        /**
         * Week of mobth time period information provider.
         */
        weekOfMonth: Later$ITimePeriod,

        /**
         * Week of yearfrom ISO 8601 time period information provider.
         */
        weekOfYear: Later$ITimePeriod,

        /**
         * Month time period information provider.
         */
        month: Later$ITimePeriod,

        /**
         * Year time period information provider.
         */
        year: Later$ITimePeriod,

        /**
         * Later Modifiers:
         * 
        This type can be easily extended to include any custom IModifiers that you desire.
        These can then be used to create schedules of your own custom type.

        interface IGandalfsLaterModifier extends Later.IModifierStatic {
             duringTheThirdAge: IModifier
        }

        Be sure to use this interface when dealing with Later.modifier
        */
        modifier: Later$IModifierStatic
}
declare var later: Later$IStatic;