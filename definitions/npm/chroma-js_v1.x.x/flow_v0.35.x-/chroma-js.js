// @flow
/**
 * Flowtype definitions for chroma-js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export interface Chroma$ChromaStatic {

    /**
     * Creates a color from a string representation (as supported in CSS).
     * @param color The string to convert to a color.
     * @return  the color object.
     */
    (color: string): Chroma$Color,

    /**
     * Creates a color from a number representation [0; 16777215]
     * @param color The number to convert to a color.
     * @return  the color object.
     */
    (number: number): Chroma$Color,

    /**
     * Create a color in the specified color space using a, b and c as values.
     * @param a 
     * @param b 
     * @param c 
     * @param colorSpace The color space to use (one of "rgb", "hsl", "hsv", "lab", "lch", "gl"). Defaults to "rgb".
     * @return  the color object.
     */
    (a: number, b: number, c: number, colorSpace?: string): Chroma$Color,
    (a: number, b: number, c: number, d: number, colorSpace?: string): Chroma$Color,

    /**
     * Create a color in the specified color space using values.
     * @param values An array of values (e.g. [r, g, b, a?]).
     * @param colorSpace The color space to use (one of "rgb", "hsl", "hsv", "lab", "lch", "gl"). Defaults to "rgb".
     * @return  the color object.
     */
    (values: number[], colorSpace?: string): Chroma$Color,

    /**
     * Create a color from a hex or string representation (as supported in CSS).
     * 
    This is an alias of chroma.css().
     * @param color The string to convert to a color.
     * @return  the color object.
    */
    hex(color: string): Chroma$Color,
        hsl(h: number, s: number, l: number): Chroma$Color,
        hsv(h: number, s: number, v: number): Chroma$Color,
        lab(lightness: number, a: number, b: number, alpha?: number): Chroma$Color,
        lch(l: number, c: number, h: number): Chroma$Color,
        rgb(r: number, g: number, b: number): Chroma$Color,

        /**
         * GL is a variant of RGB(A), with the only difference that the components are normalized to the range of 0..1.
         */
        gl(red: number, green: number, blue: number, alpha?: number): Chroma$Color,

        /**
         * light 2000K, bright sunlight 6000K. Based on Neil Bartlett's implementation. 
         * https://github.com/neilbartlett/color-temperature
         */
        temperature(t: number): Chroma$Color,
        mix(
            col1: string | Chroma$Color,
            col2: string | Chroma$Color,
            f?: number,
            colorSpace?: string): Chroma$Color,
        interpolate(
            col1: string | Chroma$Color,
            col2: string | Chroma$Color,
            f?: number,
            colorSpace?: string): Chroma$Color,

        /**
         * Blends two colors using RGB channel-wise blend functions. Valid blend modes are multiply, darken, lighten, screen, overlay, burn, and dogde.
         */
        blend(col1: string, col2: string, blendMode: string): Chroma$Color,

        /**
         * Returns a random color.
         */
        random(): Chroma$Color,

        /**
         * Computes the WCAG contrast ratio between two colors. 
         * A minimum contrast of 4.5:1 is recommended to ensure that text is still readable against a background color.
         * @param color1 The first color.
         * @param color2 The second color.
         * @return  the contrast ratio.
         */
        contrast(col1: string | Chroma$Color, col2: string | Chroma$Color): number,
        bezier(colors: string[]): Chroma$Scale,

        /**
         * chroma.brewer is an map of ColorBrewer scales that are included in chroma.js for convenience. 
         * chroma.scale uses the colors to construct.
         */
        brewer: {
            OrRd: string[],
            PuBu: string[],
            BuPu: string[],
            Oranges: string[],
            BuGn: string[],
            YlOrBr: string[],
            YlGn: string[],
            Reds: string[],
            RdPu: string[],
            Greens: string[],
            YlGnBu: string[],
            Purples: string[],
            GnBu: string[],
            Greys: string[],
            YlOrRd: string[],
            PuRd: string[],
            Blues: string[],
            PuBuGn: string[],
            Spectral: string[],
            RdYlGn: string[],
            RdBu: string[],
            PiYG: string[],
            PRGn: string[],
            RdYlBu: string[],
            BrBG: string[],
            RdGy: string[],
            PuOr: string[],
            Set2: string[],
            Accent: string[],
            Set1: string[],
            Set3: string[],
            Dark2: string[],
            Paired: string[],
            Pastel2: string[],
            Pastel1: string[]
        },

        /**
         * Helper function that computes class breaks for you, based on actual data. 
         * Supports three different modes: equidistant breaks, quantiles breaks and breaks based on k-means clusting.
         */
        limits(data: number[], mode: string, c: number): number[],
        scale(name: string): Chroma$Scale,
        scale(colors?: string[]): Chroma$Scale,
        cubehelix(): Chroma$Cubehelix,
        cmyk(c: number, m: number, y: number, k: number): Chroma$Color,

        /**
         * Create a color from a hex or string representation (as supported in CSS).
         * 
        This is an alias of chroma.hex().
         * @param color The string to convert to a color.
         * @return  the color object.
        */
        css(col: string, mode?: string): string
}

declare export interface Chroma$Color {
    alpha(a?: number): Chroma$Color,
        darken(f?: number): Chroma$Color,
        brighten(f?: number): Chroma$Color,
        saturate(s?: number): Chroma$Color,
        desaturate(s?: number): Chroma$Color,
        set(modechan: string, v: number | string): Chroma$Color,
        get(modechan: string): number,
        luminance(): number,
        luminance(l: number, mode?: string): Chroma$Color,
        hex(): string,
        name(): string,

        /**
         * Create a color from a hex or string representation (as supported in CSS).
         * 
        This is an alias of chroma.hex().
         * @param color The string to convert to a color.
         * @return  the color object.
        */
        css(mode?: string): string,
        rgb(): number[],
        rgba(): number[],
        hsl(): number[],
        hsv(): number[],
        hsi(): number[],
        lab(): number[],
        lch(): number[],
        hcl(): number[],
        temperature(): number,
        gl(): number[]
}

declare export interface Chroma$Scale {
    (c: string[]): Chroma$Scale,
    (value: number): any,
    domain(d?: number[], n?: number, mode?: string): Chroma$Scale,
        mode(mode: string): Chroma$Scale,
        correctLightness(enable?: boolean): Chroma$Scale,
        bezier(colors: string[]): Chroma$Scale,
        padding(p: number | number[]): Chroma$Scale,
        colors(c?: number): string[],
        classes(c: number | number[]): (t: number) => Chroma$Color,
        range(arg: string[]): Chroma$Scale,
        scale(): Chroma$Scale,
        out(mode: string): Chroma$Scale
}

declare export type Chroma$Cubehelix = {
    start(s: number): Chroma$Cubehelix,
    rotations(r: number): Chroma$Cubehelix,
    gamma(g: number): Chroma$Cubehelix,
    lightness(l: number[]): Chroma$Cubehelix
} & Chroma$Scale
declare var chroma: Chroma$ChromaStatic;
declare module 'chroma-js' {
    declare module.exports: typeof chroma
}