// @flow
/**
 * Flowtype definitions for aws-sdk
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module '3d-bin-packing' {
    declare module.exports: typeof bws$packer
}
declare var ReactDataGrid: typeof undefined;
/**
 * <p> Cumulated lengths of current layer. </p>
 * 
<p> {@link Scrapped} represents an edge of the current layer under construction. </p>
 * @author  Bill Knechtel, <br>
Migrated and Refactored by Jeongho Nam <http://samchon.org>
*/
declare class Scrap {

    /**
     * Cumulated length on the X-axis in 3D.
     */
    cumx: number;

    /**
     * Cumulated length on the Z-axis in 3D.
     */
    cumz: number;

    /**
     * Default Constructor.
     */
    constructor(): this;

    /**
     * Initialization Constructor.
     * @param cumx Cumulated length on the x-axis.
     * @param cumz Cumulated length on the z-axis.
     */
    constructor(cumx: number, cumz: number): this
}
declare module 'packer' {

    /**
     * 
     * @brief  Packer, a solver of 3d bin packing with multiple wrappers.
     * @details  * <p> Packer is a facade class supporting packing operations in user side. You can solve a packing problem
    by constructing Packer class with {
     * @link  WrapperArray wrappers} and {
     * @link  InstanceArray instances} to
    pack and executing {
     * @link  optimize Packer.optimize()} method. </p>

    <p> In background side, deducting packing solution, those algorithms are used. </p>
    <ul>
    <li> <a href="http://betterwaysystems.github.io/packer/reference/AirForceBinPacking.pdf" target="_blank">
    Airforce Bin Packing; 3D pallet packing problem: A human intelligence-based heuristic approach </a>
    </li>
    <li> Genetic Algorithm </li>
    <li> Greedy and Back-tracking algorithm </li>
    </ul>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Packer mixins undefined.Entity {

        /**
         * Candidate wrappers who can contain instances.
         */
        wrapperArray: WrapperArray;

        /**
         * Instances trying to pack into the wrapper.
         */
        instanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param wrapperArray Candidate wrappers who can contain instances.
         * @param instanceArray Instances to be packed into some wrappers.
         */
        constructor(wrapperArray: WrapperArray, instanceArray: InstanceArray): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Get wrapperArray.
         */
        getWrapperArray(): WrapperArray;

        /**
         * Get instanceArray.
         */
        getInstanceArray(): InstanceArray;

        /**
         * <p> Deduct
         */
        optimize(): WrapperArray;

        /**
         * 
         * @brief  Initialize sequence list (gene_array).
         * @details  * <p> Deducts initial sequence list by such assumption: </p>

        <ul>
        <li> Cost of larger wrapper is less than smaller one, within framework of price per volume unit. </li>
        <ul>
        <li> Wrapper Larger: (price: $1,000, volume: 100cm^3 -> price per volume unit: $10 / cm^3) </li>
        <li> Wrapper Smaller: (price: $700, volume: 50cm^3 -> price per volume unit: $14 / cm^3) </li>
        <li> Larger's <u>cost</u> is less than Smaller, within framework of price per volume unit </li>
        </ul>
        </ul>

        <p> Method {
         * @link  initGenes initGenes()} constructs {
         * @link  WrapperGroup WrapperGroups} corresponding
        with the {
         * @link  wrapperArray} and allocates {
         * @link  instanceArray instances} to a {
         * @link  WrapperGroup},
        has the smallest <u>cost</u> between containbles. </p>

        <p> After executing packing solution by {
         * @link  WrapperGroup.optimize WrapperGroup.optimize()}, trying to
        {
         * @link  repack re-pack} each {
         * @link  WrapperGroup} to another type of {
         * @link  Wrapper}, deducts the best
        solution between them. It's the initial sequence list of genetic algorithm. </p>
         * @return  Initial sequence list.
        */
        initGenes(): GAWrapperArray;

        /**
         * Try to repack each wrappers to another type.
         * @param $wrappers Wrappers to repack.
         * @return  Re-packed wrappers.
         */
        repack($wrappers: WrapperArray): WrapperArray;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * Bridge of {@link Packer} for {@link InstanceForm repeated instances}.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class PackerForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Initializer Constructor.
         * @param instanceFormArray Form of Instances to pack.
         * @param wrapperArray Type of Wrappers to be used.
         */
        constructor(instanceFormArray: InstanceFormArray, wrapperArray: WrapperArray): this;
        construct(xml: undefined.XML): void;
        optimize(): WrapperArray;
        getInstanceFormArray(): InstanceFormArray;
        getWrapperArray(): WrapperArray;
        TAG(): string;
        toXML(): undefined.XML;
        toPacker(): Packer
    }

    /**
     * An array of {@link InstanceForm} objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceFormArray mixins undefined.EntityArrayCollection<InstanceForm>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createChild(xml: undefined.XML): InstanceForm;
        TAG(): string;
        CHILD_TAG(): string;

        /**
         * Convert {@link InstanceForm} objects to {@link InstanceArray}.
         * @return  An array of instance containing repeated instances in {
         * @link  InstanceForm} objects.
         */
        toInstanceArray(): InstanceArray
    }

    /**
     * <p> A repeated Instance. </p>
     * 
    <p> InstanceForm is an utility class for repeated {@link Instance}. It is designed for shrinking
    volume of network message I/O by storing {@link count repeated count}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class InstanceForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(instance?: boxologic$Instance, count?: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;
        key(): any;
        getInstance(): boxologic$Instance;
        getCount(): number;
        setCount(val: number): void;
        $name: string;
        $width: string;
        $height: string;
        $length: string;
        $count: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Repeated {@link instance} to {@link InstanceArray}.
         * @details  * <p> Contains the {
         * @link  instance repeated instance} to an {
         * @link  InstanceArray} to make
        {
         * @link  instance} to participate in the packing process. The returned {
         * @link  InstanceArray} will be
        registered on {
         * @link  Packer.instanceArray}.
         * @return  An array of instance containing repeated {
         * @link  instance}.
        */
        toInstanceArray(): InstanceArray
    }
    declare class WrapperArray mixins undefined.EntityArrayCollection<Wrapper>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrapper;

        /**
         * Get (calculate) price.
         */
        getPrice(): number;

        /**
         * Get (calculate) utilization rate.
         */
        getUtilization(): number;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }
    declare class GAWrapperArray mixins WrapperArray {
        instanceArray: InstanceArray;
        result: std.HashMap<string,
        WrapperGroup>;

        /**
         * Construct from instances.
         * @param instanceArray Instances to be wrapped.
         */
        constructor(instanceArray: InstanceArray): this;

        /**
         * 
         * @brief  Copy Constructor.
         */
        constructor(genes: GAWrapperArray): this;

        /**
         * 
         * @brief  Get optimization result.
         * @return  result map.
         */
        getResult(): std.HashMap<string,
        WrapperGroup>;
        less(obj: GAWrapperArray): boolean
    }

    /**
     * An interface of physical 3D-instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare type Instance = {

        /**
         * Get name.
         */
        getName(): string,

        /**
         * Get width, length on the X-axis in 3D.
         */
        getWidth(): number,

        /**
         * Get height, length on the Y-axis in 3D.
         */
        getHeight(): number,

        /**
         * Get length, length on the Z-axis in 3D.
         */
        getLength(): number,

        /**
         * Get (calculate) volume.
         * @return  width x height x length
         */
        getVolume(): number,

        /**
         * Set name.
         */
        setName(val: string): void,

        /**
         * Set width, length on the X-axis in 3D.
         */
        setWidth(val: number): void,

        /**
         * Set height, length on the Y-axis in 3D.
         */
        setHeight(val: number): void,

        /**
         * Set length, length on the Z-axis in 3D.
         */
        setLength(val: number): void,

        /**
         * <p> A type, identifier of derived class. </p>
         * 
        <h4> Derived types </h4>
        <ul>
        <li> {@link Product product} </li>
        <li> {@link Wrapper wrapper} </li>
        <ul>
        */
        TYPE(): string
    }

    /**
     * An array of Instance objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceArray mixins undefined.EntityArray<boxologic$Instance>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): boxologic$Instance;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }

    /**
     * A product.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Product mixins undefined.Entity, Instance {

        /**
         * <p> Name, key of the Product. </p>
         * 
        <p> The name must be unique because a name identifies a {@link Product}. </p>
        */
        name: string;

        /**
         * Width of the Product, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Product, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Product, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param name Name, identifier of the Product.
         * @param width Width, length on the X-axis in 3D.
         * @param height Height, length on the Y-axis in 3D.
         * @param length Length, length on the Z-axis in 3D.
         */
        constructor(name: string, width: number, height: number, length: number): this;

        /**
         * Key of a Product is its name.
         */
        key(): any;

        /**
         * 
         * @inheritdoc  
         */
        getName(): string;

        /**
         * 
         * @inheritdoc  
         */
        getWidth(): number;

        /**
         * 
         * @inheritdoc  
         */
        getHeight(): number;

        /**
         * 
         * @inheritdoc  
         */
        getLength(): number;

        /**
         * 
         * @inheritdoc  
         */
        getVolume(): number;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * <p> Wrap represents an act wrap(ping). </p>
     * 
    <p> {@link Wrap} is a class represents an act wrapping an {@link Instance} to an {@link Wrapper}.
    To represent the relationship, Wrap uses Bridge and Capsular patterns to links and intermediates
    relationship between Wrapper and Instance. </p>

    <p> Wrap also helps packing optimization and 3d-visualization with its own members
    {
     * @link  orientation} and position variables {
     * @link  x}, {
     * @link  y} and {
     * @link  z}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Wrap mixins undefined.Entity {

        /**
         * A wrapper wrapping the {@link instance}.
         */
        wrapper: Wrapper;

        /**
         * An instance wrapped into the {@link wrapper}.
         */
        instance: boxologic$Instance;

        /**
         * Coordinate-X of the instance placement in the wrapper.
         */
        x: number;

        /**
         * Coordinate-Y of the instance placement in the wrapper.
         */
        y: number;

        /**
         * Coordinate-Z of the instance placement in the wrapper.
         */
        z: number;

        /**
         * Placement orientation of wrapped {@link instance}.
         */
        orientation: number;

        /**
         * 
         */
        color: number;

        /**
         * Construct from a Wrapper.
         * @param wrapper A wrapper who will contain an instance.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from a Wrapper and Instance with its position and default orientation 1.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number): this;

        /**
         * Construct from a Wrapper and Instance with its position and orientation.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param orientation Placement orientation of wrapped {
         * @link  instance}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number, orientation: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Factory method of wrapped Instance.
         * @param type Type of contained Instance's type.
         */
        createInstance(type: string): boxologic$Instance;

        /**
         * Set orientation.
         * @param orientation Orientation code (1 to 6).
         */
        setOrientation(orientation: number): void;

        /**
         * Set position.
         * @param x Coordinate-X of the instance placement in the wrapper.
         * @param y Coordinate-Y of the instance placement in the wrapper.
         * @param z Coordinate-Z of the instance placement in the wrapper.
         */
        setPosition(x: number, y: number, z: number): void;

        /**
         * 
         * @brief  Estimate orientation by given size.
         * @param width Width by placement.
         * @param height Height by placement.
         * @param length Length by placement.
         */
        estimateOrientation(width: number, height: number, length: number): void;

        /**
         * 
         * @brief  Orientation change is occured in level of the packer.
         * @details  orientation Packer's new orientation.
         */
        changeWrapperOrientation(orientation: number): void;

        /**
         * Get wrapper.
         */
        getWrapper(): Wrapper;

        /**
         * Get instance.
         */
        getInstance(): boxologic$Instance;

        /**
         * Get x.
         */
        getX(): number;

        /**
         * Get y.
         */
        getY(): number;

        /**
         * Get z.
         */
        getZ(): number;

        /**
         * Get orientation.
         */
        getOrientation(): number;

        /**
         * Get width.
         */
        getWidth(): number;

        /**
         * Get height.
         */
        getHeight(): number;

        /**
         * Get length.
         */
        getLength(): number;

        /**
         * Get volume.
         */
        getVolume(): number;
        $instanceName: string;
        $layoutScale: string;
        $position: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * 
         * @param geometry 
         * @return  A shape and its boundary lines as 3D-objects.
         */
        toDisplayObjects(geometry: THREE$Geometry): std.Vector<THREE$Object3D >
    }

    /**
     * A wrapper wrapping instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Wrapper mixins undefined.EntityDeque<Wrap>, Instance {

        /**
         * <p> Name, key of the Wrapper. </p>
         * 
        <p> The name represents a type of Wrapper and identifies the Wrapper. </p>
        */
        name: string;

        /**
         * Price, cost of using an Wrapper.
         */
        price: number;

        /**
         * Width of the Wrapper, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Wrapper, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Wrapper, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * <p> Thickness, margin of a Wrapper causes shrinkness of containable volume. </p>
         * 
        <p> The thickness reduces each dimension's containable size (dimension - 2thickness),
        so finally, it reduces total containable volume (-8  thickness^3). </p>
        */
        thickness: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from members.
         * @param name Name, identifier of a Wrapper.
         * @param price Price, issued cost for a type of the Wrapper.
         * @param width Width, dimensional length on the X-axis in 3D.
         * @param height Height, dimensional length on the Y-axis in 3D.
         * @param length Length, dimensional length on the Z-axis in 3D.
         * @param thickness A thickness causes shrinkness on containable volume.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;
        construct(xml: undefined.XML): void;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrap;

        /**
         * Key of a Wrapper is its name.
         */
        key(): any;

        /**
         * Get name.
         */
        getName(): string;

        /**
         * Get price.
         */
        getPrice(): number;

        /**
         * Get width, length on X-axis in 3D.
         */
        getWidth(): number;

        /**
         * Get height, length on Y-axis in 3D.
         */
        getHeight(): number;

        /**
         * Get length, length on Z-axis in 3D.
         */
        getLength(): number;

        /**
         * Get thickness.
         */
        getThickness(): number;

        /**
         * <p> Get (calculate) containable width, length on the X-axis in 3D. </p>
         * 
        <p> Calculates containable width considering the {@link thickness}. </p>
         * @return  width - (2 x thickness)
        */
        getContainableWidth(): number;

        /**
         * <p> Get (calculate) containable height, length on the Y-axis in 3D. </p>
         * 
        <p> Calculates containable height considering the {@link thickness}. </p>
         * @return  height - (2 x thickness)
        */
        getContainableHeight(): number;

        /**
         * <p> Get (calculate) containable length, length on the Z-axis in 3D. </p>
         * 
        <p> Calculates containable length considering the {@link thickness}. </p>
         * @return  length - (2 x thickness)
        */
        getContainableLength(): number;

        /**
         * <p> Get (calculate) volume. </p>
         * 
        <h4> Notice </h4>
        <p> If {@link thickness} of the Wrapper is not 0, the volume does not mean containable volume.
        In that case, use {@link containableVolume} instead. </p>
         * @return  width x height x length
        */
        getVolume(): number;

        /**
         * <p> Get (calculate) containable volume. </p>
         * 
        <p> Calculates containable volume considering the {@link thickness}. </p>
         * @return  volume - {(2 x thickness) ^ 3}
        */
        getContainableVolume(): number;

        /**
         * Get utilization ratio of containable volume.
         * @return  utilization ratio.
         */
        getUtilization(): number;
        equal_to(obj: Wrapper): boolean;

        /**
         * <p> Wrapper is enough greater? </p>
         * 
        <p> Test whether the Wrapper is enough greater than an Instance to contain. </p>
         * @param instance An Instance to test.
         * @return  Enough greater or not.
        */
        containable(instance: boxologic$Instance): boolean;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * Set price.
         */
        setPrice(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * Set thickness.
         */
        setThickness(val: number): void;
        $name: string;
        $price: string;
        $width: string;
        $height: string;
        $length: string;
        $thickness: string;
        $scale: string;
        $spaceUtilization: string;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Convert to a canvas containing 3D elements. </p>
         * @param endIndex 
         * @return  A 3D-canvans printing the Wrapper and its children {
         * @link  Wrap wrapped}
        {
         * @link  Instance instances} with those boundary lines.
        */
        toCanvas(endIndex?: number): HTMLCanvasElement
    }

    /**
     * A group of {@link Wrapper Wrappers} with same type.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class WrapperGroup mixins WrapperArray {

        /**
         * <p> A sample, standard of the WrapperGroup. </p>
         * 
        <p> The sample represents what type of Wrappers are grouped into the WrapperGroup. </p>
        */
        sample: Wrapper;

        /**
         * Allocated instances.
         */
        allocatedInstanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapperGroup: WrapperGroup): this;

        /**
         * Construct from a sample.
         * @param sample A sample, standard of the WrapperGroup.
         */
        constructor(sample: Wrapper): this;

        /**
         * Construct from members of the {@link sample}.
         * @param name Name, identifier of the sample.
         * @param price Price, issued cost for a type of the sample.
         * @param width Width, dimensional length on the X-axis in 3D, of the sample.
         * @param height Height, dimensional length on the Y-axis in 3D, of the sample.
         * @param length Length, dimensional length on the Z-axis in 3D, of the sample.
         * @param thickness A thickness, causes shrinkness on containable volume, of the sample.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;

        /**
         * Key of a WrapperGroup is dependent on its sample.
         */
        key(): any;

        /**
         * Get sample.
         */
        getSample(): Wrapper;

        /**
         * Get allocated instances.
         */
        getAllocatedInstanceArray(): InstanceArray;

        /**
         * Get (calculate) price.
         * @return  (Price of the sample) x (numbers of children Wrappers)
         */
        getPrice(): number;

        /**
         * 
         * @inheritdoc  
         */
        getUtilization(): number;

        /**
         * <p> Allocate instance(s) to the WrapperGroup. </p>
         * 
        <p> Inspect the instance is enough small to be wrapped into an empty wrapper. If the instance
        is enough small, registers the instance (or repeated instances) to the {@link reserveds} and
        returns <code>true</code>. If the instance is too large to be capsuled, returns <code>false</code>. </p>

        <h4>Note</h4>
        <p> The word <u>the instance is enough small to be wrapped into the empty wrapper</u> means
        the instance can be contained into an empty, a new wrapper contaning nothing literally. </p>

        <p> In the method allocate(), it doesn't consider how many instances are wrapped into ordinary
        wrapper and how much volumes are consumed.  </p>
         * @param instance An Instance to allocate.
         * @param n Repeating number of the <i>instance</i>.
         * @return  Whether the instance is enough small to be wrapped into a (new) wrapper
        of same type with the sample.
        */
        allocate(instance: boxologic$Instance, n?: number): boolean;

        /**
         * <p> Run optimization in level of the group. </p>
         * 
        <p> The optimization routine begins by creating a {@link Wrapper} like the {@link sample}. Then
        try to pack {@link allocatedInstanceArray allocated instances} to the {@link Wrapper} as a lot as
        possible. If there're some {@link Wrappers} can't be packed by overloading, then create a new
        {
         * @link  Wrapper} again and try to pack {
         * @link  allocatedInstanceArray instances} again, too. </p>

        <p> Repeats those steps until all {
         * @link  alloctedInstanceArray instances} are {
         * @link  Wrap packed}
        so that there's not any {
         * @link  Instance instance} left. </p>

        <h4> Warning </h4>
        <p> When call this {
         * @link  optimize optimize()} method, ordinary children {
         * @link  Wrapper} objects
        in the {
         * @link  WrapperGroup} will be substituted with the newly optimized {
         * @link  Wrapper} objects. </p>
        */
        optimize(): void;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string
    }
    declare class Editor<T>mixins React.Component<{
        dataProvider: undefined.EntityArrayCollection<T >
    }, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createColumns(): AdazzleReactDataGrid.Column[];
        render(): JSX.Element
    }
    declare type ItemEditorProps = {
        application: PackerApplication,
        instances: InstanceFormArray,
        wrappers: WrapperArray
    }
    declare class ItemEditor mixins React.Component<ItemEditorProps, {}>{
        render(): JSX.Element
    }
    declare class InstanceEditor mixins Editor<InstanceForm>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class WrapperEditor mixins Editor<Wrapper>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class PackerApplication mixins React.Component<{}, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        pack(): void;
        drawWrapper(wrapper: Wrapper, index?: number): void;
        render(): JSX.Element;
        main(): void
    }
    declare class ResultViewer mixins React.Component<WrapperViewerProps, {}>{
        drawWrapper(wrapper: Wrapper, index?: number): void;
        refresh(): void;
        render(): JSX.Element
    }
    declare type WrapperViewerProps = {
        application: PackerApplication,
        wrappers: WrapperArray
    }
}
declare class TabNavigator mixins React.Component<flex$TabNavigatorProps, flex$TabNavigatorProps>{
    render(): JSX.Element
}

declare class NavigatorContent mixins React.Component<flex$NavigatorContentProps, flex$NavigatorContentProps>{
    render(): JSX.Element
}

declare type flex$TabNavigatorProps = {
    selectedIndex?: number,
    style?: React.CSSProperties
}

declare type flex$NavigatorContentProps = {
    label: string
}
declare module 'MD5' {
    declare     var VERSION: string;
    declare     var BY_ASCII: number;
    declare     var BY_UTF16: number;
    declare     function calc(str: string, option?: number): string
}

/**
 * 
 * @summary  Interface for "saveAs" function.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface FileSaver {
    (data: Blob, filename: string, disableAutoBOM?: boolean): void
}
declare var saveAs: FileSaver;
declare module 'file-saver' {
    declare     var fileSaver: {
        saveAs: typeof saveAs
    };
    declare module.exports: typeof fileSaver
}
declare interface FinchCallback {
    (bindings?: any, childCallback?: () => void): any
}
declare interface ExpandedCallback {
    setup?: FinchCallback,
        load?: FinchCallback,
        unload?: FinchCallback,
        teardown?: FinchCallback
}
declare interface ObserveCallback {
    (...args: any[]): string
}
declare interface FinchOptions {
    CoerceParameterTypes?: boolean
}
declare interface FinchStatic {
    route(route: string, callback: FinchCallback): void,
        route(route: string, callbacks: ExpandedCallback): void,
        call(uri: string): void,
        observe(argN: string[], callback: (params: ObserveCallback) => void): void,
        observe(callback: (params: ObserveCallback) => void): void,
        observe(...args: any[]): void,
        navigate(uri: string, queryParams?: any, doUpdate?: boolean): void,
        navigate(uri: string, doUpdate: boolean): void,
        navigate(queryParams: any, doUpdate?: boolean): void,
        listen(): boolean,
        ignore(): boolean,
        abort(): void,
        options(options: FinchOptions): void
}
declare var Finch: FinchStatic;
declare module 'finch' {
    declare module.exports: typeof Finch
}
declare interface HeadroomOptions {
    offset?: number,
        tolerance?: any,
        classes?: {
            initial?: string,
            notBottom?: string,
            notTop?: string,
            pinned?: string,
            top?: string,
            unpinned?: string
        },
        scroller?: angularScenario$Element,
        onPin?: () => void,
        onUnPin?: () => void,
        onTop?: () => void,
        onNotTop?: () => void
}
declare class Headroom {
    constructor(element: CSG$Node, options?: HeadroomOptions): this;
    constructor(element: angularScenario$Element, options?: HeadroomOptions): this;
    init: () => void
}
declare interface HubSpotPaceInterfaces$PaceOptions {

    /**
     * How long should it take for the bar to animate to a new point after receiving it
     */
    catchupTime?: number,

        /**
         * How quickly should the bar be moving before it has any progress info from a new source in %/ms
         */
        initialRate?: number,

        /**
         * What is the minimum amount of time the bar should be on the screen. Irrespective of this number, the bar will always be on screen for 33  (100 / maxProgressPerFrame) + ghostTime ms.
         */
        minTime?: number,

        /**
         * What is the minimum amount of time the bar should sit after the last update before disappearing
         */
        ghostTime?: number,

        /**
         * Its easy for a bunch of the bar to be eaten in the first few frames before we know how much there is to load. This limits how much of the bar can be used per frame
         */
        maxProgressPerFrame?: number,

        /**
         * This tweaks the animation easing
         */
        easeFactor?: number,

        /**
         * Should pace automatically start when the page is loaded, or should it wait for `start` to be called? Always false if pace is loaded with AMD or CommonJS.
         */
        startOnPageLoad?: boolean,

        /**
         * Should we restart the browser when pushState or replaceState is called?  (Generally means ajax navigation has occured)
         */
        restartOnPushState?: boolean,

        /**
         * Should we show the progress bar for every ajax request (not just regular or ajax-y page navigation)? Set to false to disable. If so, how many ms does the request have to be running for before we show the progress?
         */
        restartOnRequestAfter?: boolean | number,

        /**
         * What element should the pace element be appended to on the page?
         */
        target?: string,
        document?: boolean | string,
        elements?: boolean | HubSpotPaceInterfaces$PaceElementsOptions,
        eventLag?: boolean | HubSpotPaceInterfaces$PaceEventLagOptions,
        ajax?: boolean | HubSpotPaceInterfaces$PaceAjaxOptions
}

declare interface HubSpotPaceInterfaces$PaceElementsOptions {

    /**
     * How frequently in ms should we check for the elements being tested for using the element monitor?
     */
    checkInterval?: number,

        /**
         * What elements should we wait for before deciding the page is fully loaded (not required)
         */
        selectors?: string[]
}

declare interface HubSpotPaceInterfaces$PaceEventLagOptions {

    /**
     * When we first start measuring event lag, not much is going on in the browser yet, so it's not uncommon for the numbers to be abnormally low for the first few samples. This configures how many samples we need before we consider a low number to mean completion.
     */
    minSamples?: number,

        /**
         * How many samples should we average to decide what the current lag is?
         */
        sampleCount?: number,

        /**
         * Above how many ms of lag is the CPU considered busy?
         */
        lagThreshold?: number
}

declare interface HubSpotPaceInterfaces$PaceAjaxOptions {

    /**
     * Which HTTP methods should we track?
     */
    trackMethods?: string[],

        /**
         * Should we track web socket connections?
         */
        trackWebSockets?: boolean,

        /**
         * A list of regular expressions or substrings of URLS we should ignore (for both tracking and restarting)
         */
        ignoreURLs?: (string | RegExp)[]
}

declare interface HubSpotPaceInterfaces$Pace {
    options: HubSpotPaceInterfaces$PaceOptions,
        start(options?: HubSpotPaceInterfaces$PaceOptions): void,
        restart(): void,
        stop(): void,
        track(fn: () => void, ...args: any[]): void,
        ignore(fn: () => void, ...args: any[]): void,
        on(event: string, handler: (...args: any[]) => void, context?: any): void,
        off(event: string, handler?: (...args: any[]) => void): void,
        once(event: string, handler: (...args: any[]) => void, context?: any): void
}
declare var pace: HubSpotPaceInterfaces$Pace;
declare module 'HubSpot-pace' {
    declare module.exports: typeof pace
}
declare module 'JSONStream' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export function parse(pattern: any): NodeJS$ReadWriteStream
    declare     export function stringify(): NodeJS$ReadWriteStream
    declare     export function stringifyObject(): NodeJS$ReadWriteStream
}

declare var npm$namespace$THREE: {
    OrbitControls: typeof THREE$OrbitControls,
    SpriteCanvasMaterial: typeof THREE$SpriteCanvasMaterial,
    RenderableObject: typeof THREE$RenderableObject,
    RenderableFace: typeof THREE$RenderableFace,
    RenderableVertex: typeof THREE$RenderableVertex,
    RenderableLine: typeof THREE$RenderableLine,
    RenderableSprite: typeof THREE$RenderableSprite,
    Projector: typeof THREE$Projector,
}
declare var CSG: {
    fromCSG: (
        csg: CSG,
        defaultColor: any) => {
        colorMesh: Mesh,
        wireframe: Mesh,
        boundLen: number
    },
    getGeometryVertex: (geometry: any, vertex_position: any) => number
};

declare function THREE$OrbitControls(object: any, domElement: any): void

declare function THREE$SpriteCanvasMaterial(parameters?: any): void

declare interface THREE$ICanvasRendererOptions {
    canvas?: HTMLCanvasElement,
        alpha?: boolean
}

declare class CanvasRenderer mixins Renderer {
    domElement: HTMLCanvasElement;
    constructor(parameters: THREE$ICanvasRendererOptions): this;
    supportsVertexTextures(): void;
    setFaceCulling: () => void;
    getPixelRatio(): number;
    setPixelRatio(value: any): void;
    setSize(width: any, height: any, updateStyle: any): void;
    setViewport(x: any, y: any, width: any, height: any): void;
    setScissor(): void;
    enableScissorTest(): void;
    setClearColor(color: any, alpha: any): void;
    setClearColorHex(hex: any, alpha: any): void;
    getClearColor(): Color;
    getClearAlpha(): number;
    getMaxAnisotropy(): number;
    clear(): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    render(
        scene: Scene,
        camera: Camera,
        renderTarget?: RenderTarget,
        forceClear?: boolean): void;
    calculateLights(): void;
    calculateLight(position: any, normal: any, color: any): void;
    renderSprite(v1: any, element: any, material: any): void;
    renderLine(v1: any, v2: any, element: any, material: any): void;
    renderFace3(
        v1: any,
        v2: any,
        v3: any,
        uv1: any,
        uv2: any,
        uv3: any,
        element: any,
        material: any): void;
    drawTriangle(x0: any, y0: any, x1: any, y1: any, x2: any, y2: any): void;
    strokePath(color: any, linewidth: any, linecap: any, linejoin: any): void;
    fillPath(color: any): void;
    onTextureUpdate(event: any): void;
    textureToPattern(texture: any): void;
    patternPath(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        texture: any): void;
    clipImage(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        image: any): void;
    expand(v1: any, v2: any, pixels: any): void;
    setOpacity(value: any): void;
    setBlending(value: any): void;
    setLineWidth(value: any): void;
    setLineCap(value: any): void;
    setLineJoin(value: any): void;
    setStrokeStyle(value: any): void;
    setFillStyle(value: any): void;
    setLineDash(value: any): void
}

declare function THREE$RenderableObject(): void

declare function THREE$RenderableFace(): void

declare function THREE$RenderableVertex(): void

declare function THREE$RenderableLine(): void

declare function THREE$RenderableSprite(): void

declare function THREE$Projector(): void
declare var npm$namespace$OpenJsCad: {
    makeAbsoluteUrl: typeof OpenJsCad$makeAbsoluteUrl,
    isChrome: typeof OpenJsCad$isChrome,
    runMainInWorker: typeof OpenJsCad$runMainInWorker,
    expandResultObjectArray: typeof OpenJsCad$expandResultObjectArray,
    checkResult: typeof OpenJsCad$checkResult,
    resultToCompactBinary: typeof OpenJsCad$resultToCompactBinary,
    resultFromCompactBinary: typeof OpenJsCad$resultFromCompactBinary,
    parseJsCadScriptSync: typeof OpenJsCad$parseJsCadScriptSync,
    parseJsCadScriptASync: typeof OpenJsCad$parseJsCadScriptASync,
    getWindowURL: typeof OpenJsCad$getWindowURL,
    textToBlobUrl: typeof OpenJsCad$textToBlobUrl,
    revokeBlobUrl: typeof OpenJsCad$revokeBlobUrl,
    FileSystemApiErrorHandler: typeof OpenJsCad$FileSystemApiErrorHandler,
    AlertUserOfUncaughtExceptions: typeof OpenJsCad$AlertUserOfUncaughtExceptions,
    getParamDefinitions: typeof OpenJsCad$getParamDefinitions,
}
declare interface OpenJsCad$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare var log: OpenJsCad$ILog;

declare interface OpenJsCad$IViewerOptions {
    drawLines?: boolean,
        drawFaces?: boolean,
        color?: number[],
        bgColor?: number,
        noWebGL?: boolean
}

declare type OpenJsCad$ProcessorOptions = {
    verbose?: boolean,
    viewerwidth?: number,
    viewerheight?: number,
    viewerheightratio?: number
} & OpenJsCad$IViewerOptions


declare class Viewer {
    constructor(containerElm: any, size: any, options: OpenJsCad$IViewerOptions): this;
    createScene(drawAxes: any, axLen: any): void;
    createCamera(): void;
    createControls(canvas: any): void;
    webGLAvailable(): boolean;
    createRenderer(bool_noWebGL: any): void;
    render(): void;
    animate(): void;
    cancelAnimate(): void;
    refreshRenderer(bool_noWebGL: any): void;
    drawAxes(axLen: any): void;
    setCsg(csg: any, resetZoom: any): void;
    applyDrawOptions(): void;
    clear(): void;
    getUserMeshes(str?: any): THREE$Object3D[];
    resetZoom(r: any): void;
    parseSizeParams(): void;
    handleResize(): void
}

declare function OpenJsCad$makeAbsoluteUrl(url: any, baseurl: any): any

declare function OpenJsCad$isChrome(): boolean

declare function OpenJsCad$runMainInWorker(mainParameters: any): void

declare function OpenJsCad$expandResultObjectArray(result: any): any

declare function OpenJsCad$checkResult(result: any): void

declare function OpenJsCad$resultToCompactBinary(resultin: any): any

declare function OpenJsCad$resultFromCompactBinary(resultin: any): any

declare function OpenJsCad$parseJsCadScriptSync(script: any, mainParameters: any, debugging: any): any

declare function OpenJsCad$parseJsCadScriptASync(script: any, mainParameters: any, options: any, callback: any): Worker

declare function OpenJsCad$getWindowURL(): URL

declare function OpenJsCad$textToBlobUrl(txt: any): string

declare function OpenJsCad$revokeBlobUrl(url: any): void

declare function OpenJsCad$FileSystemApiErrorHandler(fileError: any, operation: any): void

declare function OpenJsCad$AlertUserOfUncaughtExceptions(): void

declare function OpenJsCad$getParamDefinitions(script: any): any[]

declare interface OpenJsCad$EventHandler {
    (ev?: autobahn$Event): any
}


/**
 * options parameter:
 * - drawLines: display wireframe lines
- drawFaces: display surfaces
- bgColor: canvas background color
- color: object color
- viewerwidth, viewerheight: set rendering size. Works with any css unit.
     viewerheight can also be specified as a ratio to width, ie number e (0, 1]
- noWebGL: force render without webGL
- verbose: show additional info (currently only time used for rendering)
*/
declare interface OpenJsCad$ViewerSize {
    widthDefault: string,
        heightDefault: string,
        width: number,
        height: number,
        heightratio: number
}

declare class Processor {
    constructor(containerdiv: HTMLDivElement, options?: OpenJsCad$ProcessorOptions, onchange?: OpenJsCad$EventHandler): this;
    convertToSolid(obj: any): any;
    cleanOption(option: any, deflt: any): any;
    toggleDrawOption(str: any): boolean;
    setDrawOption(str: any, bool: any): void;
    handleResize(): void;
    createElements(): void;
    getFilenameForRenderedObject(): string;
    setRenderedObjects(obj: any): void;
    setSelectedObjectIndex(index: number): void;
    selectedFormat(): any;
    selectedFormatInfo(): any;
    updateDownloadLink(): void;
    clearViewer(): void;
    abort(): void;
    enableItems(): void;
    setOpenJsCadPath(path: string): void;
    addLibrary(lib: any): void;
    setError(txt: string): void;
    setDebugging(debugging: boolean): void;
    setJsCad(script: string, filename?: string): void;
    getParamValues(): {};
    rebuildSolid(): void;
    hasSolid(): boolean;
    isProcessing(): boolean;
    clearOutputFile(): void;
    generateOutputFile(): void;
    currentObjectToBlob(): any;
    supportedFormatsForCurrentObject(): string[];
    formatInfo(format: any): any;
    downloadLinkTextForCurrentObject(): string;
    generateOutputFileBlobUrl(): void;
    generateOutputFileFileSystem(): void;
    createParamControls(): void
}
declare interface Window {
    Worker: Worker,
        webkitURL: URL,
        requestFileSystem: any,
        webkitRequestFileSystem: any
}
declare interface IAMFStringOptions {
    unit: string
}
declare class CxG {
    toStlString(): string;
    toStlBinary(): void;
    toAMFString(AMFStringOptions?: IAMFStringOptions): void;
    getBounds(): CxG[];
    transform(matrix4x4: CSG$Matrix4x4): CxG;
    mirrored(plane: CSG$Plane): CxG;
    mirroredX(): CxG;
    mirroredY(): CxG;
    mirroredZ(): CxG;
    translate(v: number[]): CxG;
    translate(v: CSG$Vector3D): CxG;
    scale(f: CSG$Vector3D): CxG;
    rotateX(deg: number): CxG;
    rotateY(deg: number): CxG;
    rotateZ(deg: number): CxG;
    rotate(rotationCenter: CSG$Vector3D, rotationAxis: CSG$Vector3D, degrees: number): CxG;
    rotateEulerAngles(alpha: number, beta: number, gamma: number, position: number[]): CxG
}
declare interface ICenter {
    center(cAxes: string[]): CxG
}
declare class CSG mixins CxG, ICenter {
    polygons: CSG$Polygon[];
    properties: CSG$Properties;
    isCanonicalized: boolean;
    isRetesselated: boolean;
    cachedBoundingBox: CSG$Vector3D[];
    defaultResolution2D: number;
    defaultResolution3D: number;
    fromPolygons(polygons: CSG$Polygon[]): CSG;
    fromSlices(options: any): CSG;
    fromObject(obj: any): CSG;
    fromCompactBinary(bin: any): CSG;
    toPolygons(): CSG$Polygon[];
    union(csg: CSG[]): CSG;
    union(csg: CSG): CSG;
    unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    unionForNonIntersecting(csg: CSG): CSG;
    subtract(csg: CSG[]): CSG;
    subtract(csg: CSG): CSG;
    subtractSub(csg: CSG, retesselate: boolean, canonicalize: boolean): CSG;
    intersect(csg: CSG[]): CSG;
    intersect(csg: CSG): CSG;
    intersectSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    invert(): CSG;
    transform1(matrix4x4: CSG$Matrix4x4): CSG;
    transform(matrix4x4: CSG$Matrix4x4): CSG;
    toString(): string;
    expand(radius: number, resolution: number): CSG;
    contract(radius: number, resolution: number): CSG;
    stretchAtPlane(normal: number[], point: number[], length: number): CSG;
    expandedShell(radius: number, resolution: number, unionWithThis: boolean): CSG;
    canonicalized(): CSG;
    reTesselated(): CSG;
    getBounds(): CSG$Vector3D[];
    mayOverlap(csg: CSG): boolean;
    cutByPlane(plane: CSG$Plane): CSG;
    connectTo(
        myConnector: CSG$Connector,
        otherConnector: CSG$Connector,
        mirror: boolean,
        normalrotation: number): CSG;
    setShared(shared: undefined.Shared): CSG;
    setColor(args: any): CSG;
    toCompactBinary(): {
        class: string,
        numPolygons: number,
        numVerticesPerPolygon: Uint32Array,
        polygonPlaneIndexes: Uint32Array,
        polygonSharedIndexes: Uint32Array,
        polygonVertices: Uint32Array,
        vertexData: Float64Array,
        planeData: Float64Array,
        shared: undefined.Shared[]
    };
    toPointCloud(cuberadius: any): CSG;
    getTransformationAndInverseTransformationToFlatLying(): any;
    getTransformationToFlatLying(): any;
    lieFlat(): CSG;
    projectToOrthoNormalBasis(orthobasis: CSG$OrthoNormalBasis): CAG;
    sectionCut(orthobasis: CSG$OrthoNormalBasis): CAG;
    fixTJunctions(): CSG;
    toTriangles(): any[];
    getFeatures(features: any): any;
    center(cAxes: string[]): CxG;
    toX3D(): Blob;
    toStlBinary(): Blob;
    toStlString(): string;
    toAMFString(m: IAMFStringOptions): Blob
}
declare class Polygon2D mixins CAG {
    constructor(points: CSG$Vector2D[]): this
}
declare class CAG mixins CxG, ICenter {
    sides: CAG$Side[];
    isCanonicalized: boolean;
    constructor(): this;
    fromSides(sides: CAG$Side[]): CAG;
    fromPoints(points: CSG$Vector2D[]): CAG;
    fromPointsNoCheck(points: CSG$Vector2D[]): CAG;
    fromFakeCSG(csg: CSG): CAG;
    linesIntersect(
        p0start: CSG$Vector2D,
        p0end: CSG$Vector2D,
        p1start: CSG$Vector2D,
        p1end: CSG$Vector2D): boolean;
    circle(options: CSG$ICircleOptions): CAG;
    rectangle(options: CSG$IRectangleOptions): CAG;
    roundedRectangle(options: any): CAG;
    fromCompactBinary(bin: any): CAG;
    toString(): string;
    _toCSGWall(z0: any, z1: any): CSG;
    _toVector3DPairs(m: CSG$Matrix4x4): CSG$Vector3D[][];
    _toPlanePolygons(options: any): CSG$Polygon[];
    _toWallPolygons(options: any): any[];
    union(cag: CAG[]): CAG;
    union(cag: CAG): CAG;
    subtract(cag: CAG[]): CAG;
    subtract(cag: CAG): CAG;
    intersect(cag: CAG[]): CAG;
    intersect(cag: CAG): CAG;
    transform(matrix4x4: CSG$Matrix4x4): CAG;
    area(): number;
    flipped(): CAG;
    getBounds(): CSG$Vector2D[];
    isSelfIntersecting(): boolean;
    expandedShell(radius: number, resolution: number): CAG;
    expand(radius: number, resolution: number): CAG;
    contract(radius: number, resolution: number): CAG;
    extrudeInOrthonormalBasis(orthonormalbasis: CSG$OrthoNormalBasis, depth: number, options?: any): CSG;
    extrudeInPlane(axis1: any, axis2: any, depth: any, options: any): CSG;
    extrude(options: CAG_extrude_options): CSG;
    rotateExtrude(options: any): CSG;
    check(): void;
    canonicalized(): CAG;
    toCompactBinary(): {
        class: string,
        sideVertexIndices: Uint32Array,
        vertexData: Float64Array
    };
    getOutlinePaths(): CSG$Path2D[];
    overCutInsideCorners(cutterradius: any): CAG;
    center(cAxes: string[]): CxG;
    toDxf(): Blob;
    PathsToDxf(paths: CSG$Path2D[]): Blob
}
declare class Vertex {
    pos: CSG$Vector2D;
    tag: number;
    constructor(pos: CSG$Vector2D): this;
    toString(): string;
    getTag(): number
}

declare class Side mixins CxG {
    vertex0: CAG$Vertex;
    vertex1: CAG$Vertex;
    tag: number;
    constructor(vertex0: CAG$Vertex, vertex1: CAG$Vertex): this;
    _fromFakePolygon(polygon: CSG$Polygon): CAG$Side;
    toString(): string;
    toPolygon3D(z0: any, z1: any): CSG$Polygon;
    transform(matrix4x4: CSG$Matrix4x4): CAG$Side;
    flipped(): CAG$Side;
    direction(): CSG$Vector2D;
    getTag(): number;
    lengthSquared(): number;
    length(): number
}

declare class fuzzyCAGFactory {
    vertexfactory: CSG$fuzzyFactory;
    constructor(): this;
    getVertex(sourcevertex: CAG$Vertex): CAG$Vertex;
    getSide(sourceside: CAG$Side): CAG$Side;
    getCAG(sourcecag: CAG): CAG
}
declare interface CAG_extrude_options {
    offset?: number[],
        twistangle?: number,
        twiststeps?: number
}
/**
 * The PayPalItem class defines an optional itemization for a payment.
 * @see  https://developer.paypal.com/docs/api/#item-object for more details.
 */
declare class PayPalItem {

    /**
     * 
     * @param name Name of the item. 127 characters max.
     * @param quantity Number of units. 10 characters max.
     * @param price Unit price for this item 10 characters max.
    May be negative for "coupon" etc.
     * @param currency ISO standard currency code.
     * @param sku The stock keeping unit for this item. 50 characters max (optional).
    */
    constructor(name: string, quantity: number, price: string, currency: string, sku?: string): this;

    /**
     * Name of the item. 127 characters max.
     */
    name: string;

    /**
     * Number of units. 10 characters max.
     */
    quantity: number;

    /**
     * Unit price for this item 10 characters max.
     * May be negative for "coupon" etc.
     */
    price: string;

    /**
     * ISO standard currency code.
     */
    currency: string;

    /**
     * The stock keeping unit for this item. 50 characters max (optional).
     */
    sku: string
}
/**
 * The PayPalPaymentDetails class defines optional amount details.
 * @see  https://developer.paypal.com/webapps/developer/docs/api/#details-object for more details.
 */
declare class PayPalPaymentDetails {

    /**
     * 
     * @param subtotal Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     * @param shipping Amount charged for shipping. 10 characters max with support for 2 decimal places.
     * @param tax Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    constructor(subtotal: string, shipping: string, tax: string): this;

    /**
     * Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     */
    subtotal: string;

    /**
     * Amount charged for shipping. 10 characters max with support for 2 decimal places.
     */
    shipping: string;

    /**
     * Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    tax: string
}
/**
 * Convenience constructor. Returns a PayPalPayment with the specified amount, currency code, and short description.
 */
declare class PayPalPayment {

    /**
     * 
     * @param amount The amount of the payment.
     * @param currencyCode The ISO 4217 currency for the payment.
     * @param shortDescription A short descripton of the payment.
     * @param intent • "Sale" for an immediate payment.
    • "Auth" for payment authorization only, to be captured separately at a later time.
    • "Order" for taking an order, with authorization and capture to be done separately at a later time.
     * @param details PayPalPaymentDetails object (optional).
    */
    constructor(amount: string, currency: string, shortDescription: string, intent: string, details?: PayPalPaymentDetails): this;

    /**
     * The amount of the payment.
     */
    amount: string;

    /**
     * The ISO 4217 currency for the payment.
     */
    currency: string;

    /**
     * A short descripton of the payment.
     */
    shortDescription: string;

    /**
     * • "Sale" for an immediate payment.
     * • "Auth" for payment authorization only, to be captured separately at a later time.
    • "Order" for taking an order, with authorization and capture to be done separately at a later time.
    */
    intent: string;

    /**
     * PayPalPaymentDetails object (optional).
     */
    details: PayPalPaymentDetails;

    /**
     * Optional invoice number, for your tracking purposes. (up to 256 characters).
     */
    invoiceNumber: string;

    /**
     * Optional text, for your tracking purposes. (up to 256 characters).
     */
    custom: string;

    /**
     * Optional text which will appear on the customer's credit card statement. (up to 22 characters).
     */
    softDescriptor: string;

    /**
     * Optional Build Notation code ("BN code"), obtained from partnerprogram@paypal.com, for your tracking purposes.
     */
    bnCode: string;

    /**
     * Optional array of PayPalItem objects.
     * @see  PayPalItem
     * @note  If you provide one or more items, be sure that the various prices correctly sum to the payment `amount` or to `paymentDetails.subtotal`.
     */
    items: PayPalItem[];

    /**
     * Optional customer shipping address, if your app wishes to provide this to the SDK.
     * @note  make sure to set `payPalShippingAddressOption` in PayPalConfiguration to 1 or 3.
     */
    shippingAddress: PayPalShippingAddress
}
declare class PayPalShippingAddress {

    /**
     * 
     * @param recipientName Name of the recipient at this address. 50 characters max.
     * @param line1 Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     * @param line2 Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     * @param city City name. 50 characters max.
     * @param state 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     * @param postalCode ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     * @param countryCode 2-letter country code. 2 characters max.
     */
    constructor(recipientName: string, line1: string, line2: string, city: string, state: string, postalCode: string, countryCode: string): this;

    /**
     * Name of the recipient at this address. 50 characters max.
     */
    recipientName: string;

    /**
     * Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     */
    line1: string;

    /**
     * Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     */
    line2: string;

    /**
     * City name. 50 characters max.
     */
    city: string;

    /**
     * 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     */
    state: string;

    /**
     * ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     */
    postalCode: string;

    /**
     * 2-letter country code. 2 characters max.
     */
    countryCode: string
}
declare class PayPalConfiguration {

    /**
     * 
     * @param options A set of options to use. Any options not specified will assume default values.
     */
    constructor(options?: PayPalConfigurationOptions): this;

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail: string;

    /**
     * Will be overridden by phone country code used in most recent PayPal login
     */
    defaultUserPhoneCountryCode: string;

    /**
     * Will be overridden by phone number used in most recent PayPal login.
     * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
     */
    defaultUserPhoneNumber: string;

    /**
     * Your company name, as it should be displayed to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantName: string;

    /**
     * URL of your company's privacy policy, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantPrivacyPolicyURL: string;

    /**
     * URL of your company's user agreement, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantUserAgreementURL: string;

    /**
     * If set to false, the SDK will only support paying with PayPal, not with credit cards.
     * This applies only to single payments (via PayPalPaymentViewController).
    Future payments (via PayPalFuturePaymentViewController) always use PayPal.
    Defaults to true.
    */
    acceptCreditCards: boolean;

    /**
     * For single payments, options for the shipping address.
     * 
    - 0 - PayPalShippingAddressOptionNone: no shipping address applies.

    - 1 - PayPalShippingAddressOptionProvided: shipping address will be provided by your app,
       in the shippingAddress property of PayPalPayment.

    - 2 - PayPalShippingAddressOptionPayPal: user will choose from shipping addresses on file
       for their PayPal account.

    - 3 - PayPalShippingAddressOptionBoth: user will choose from the shipping address provided by your app,
       in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

    Defaults to 0 (PayPalShippingAddressOptionNone).
    */
    payPalShippingAddressOption: number;

    /**
     * If set to true, then if the user pays via their PayPal account,
     * the SDK will remember the user's PayPal username or phone number;
    if the user pays via their credit card, then the SDK will remember
    the PayPal Vault token representing the user's credit card.

    If set to false, then any previously-remembered username, phone number, or
    credit card token will be erased, and subsequent payment information will
    not be remembered.

    Defaults to true.
    */
    rememberUser: boolean;

    /**
     * If not set, or if set to nil, defaults to the device's current language setting.
     * 
    Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
    If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
    If the library does not contain localized strings for a specified language, then will fall back to American English.

    If you specify only a language code, and that code matches the device's currently preferred language,
    then the library will attempt to use the device's current region as well.
    E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

    These localizations are currently included:
    da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
    */
    languageOrLocale: string;

    /**
     * Normally, the SDK blurs the screen when the app is backgrounded,
     * to obscure credit card or PayPal account details in the iOS-saved screenshot.
    If your app already does its own blurring upon backgrounding, you might choose to disable this.
    Defaults to false.
    */
    disableBlurWhenBackgrounding: boolean;

    /**
     * If you will present the SDK's view controller within a popover, then set this property to true.
     * Defaults to false. (iOS only)
     */
    presentingInPopover: boolean;

    /**
     * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
     * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

    This setting will have no effect if the operation mode is production.
    Defaults to false.
    */
    forceDefaultsInSandbox: boolean;

    /**
     * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPassword: string;

    /**
     * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPin: string
}
/**
 * Describes the options that can be passed into the PayPalConfiguration class constructor.
 */
declare interface PayPalConfigurationOptions {

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail?: string,

        /**
         * Will be overridden by phone country code used in most recent PayPal login
         */
        defaultUserPhoneCountryCode?: string,

        /**
         * Will be overridden by phone number used in most recent PayPal login.
         * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
         */
        defaultUserPhoneNumber?: string,

        /**
         * Your company name, as it should be displayed to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantName?: string,

        /**
         * URL of your company's privacy policy, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantPrivacyPolicyURL?: string,

        /**
         * URL of your company's user agreement, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantUserAgreementURL?: string,

        /**
         * If set to false, the SDK will only support paying with PayPal, not with credit cards.
         * This applies only to single payments (via PayPalPaymentViewController).
        Future payments (via PayPalFuturePaymentViewController) always use PayPal.
        Defaults to true.
        */
        acceptCreditCards?: boolean,

        /**
         * For single payments, options for the shipping address.
         * 
        - 0 - PayPalShippingAddressOptionNone?: no shipping address applies.

        - 1 - PayPalShippingAddressOptionProvided?: shipping address will be provided by your app,
           in the shippingAddress property of PayPalPayment.

        - 2 - PayPalShippingAddressOptionPayPal?: user will choose from shipping addresses on file
           for their PayPal account.

        - 3 - PayPalShippingAddressOptionBoth?: user will choose from the shipping address provided by your app,
           in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

        Defaults to 0 (PayPalShippingAddressOptionNone).
        */
        payPalShippingAddressOption?: number,

        /**
         * If set to true, then if the user pays via their PayPal account,
         * the SDK will remember the user's PayPal username or phone number;
        if the user pays via their credit card, then the SDK will remember
        the PayPal Vault token representing the user's credit card.

        If set to false, then any previously-remembered username, phone number, or
        credit card token will be erased, and subsequent payment information will
        not be remembered.

        Defaults to true.
        */
        rememberUser?: boolean,

        /**
         * If not set, or if set to nil, defaults to the device's current language setting.
         * 
        Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
        If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
        If the library does not contain localized strings for a specified language, then will fall back to American English.

        If you specify only a language code, and that code matches the device's currently preferred language,
        then the library will attempt to use the device's current region as well.
        E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

        These localizations are currently included:
        da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
        */
        languageOrLocale?: string,

        /**
         * Normally, the SDK blurs the screen when the app is backgrounded,
         * to obscure credit card or PayPal account details in the iOS-saved screenshot.
        If your app already does its own blurring upon backgrounding, you might choose to disable this.
        Defaults to false.
        */
        disableBlurWhenBackgrounding?: boolean,

        /**
         * If you will present the SDK's view controller within a popover, then set this property to true.
         * Defaults to false. (iOS only)
         */
        presentingInPopover?: boolean,

        /**
         * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
         * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

        This setting will have no effect if the operation mode is production.
        Defaults to false.
        */
        forceDefaultsInSandbox?: boolean,

        /**
         * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPassword?: string,

        /**
         * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPin?: string
}
declare export interface PayPalCordovaPlugin$PayPalClientIds {
    PayPalEnvironmentProduction: string,
        PayPalEnvironmentSandbox: string
}


/**
 * Represents the portion of an object that is common to all responses.
 */
declare export interface PayPalCordovaPlugin$BaseResult {
    client: asana$Client,
        response_type: string
}


/**
 * Represents the client portion of the response.
 */
declare export interface PayPalCordovaPlugin$Client {
    paypal_sdk_version: string,
        environment: string,
        platform: string,
        product_name: string
}


/**
 * Represents the response for a successful callback from renderSinglePaymentUI().
 */
declare export type PayPalCordovaPlugin$SinglePaymentResult = {
    response: {
        intent: string,
        id: string,
        state: string,
        authorization_id: string,
        create_time: string
    }
} & PayPalCordovaPlugin$BaseResult



/**
 * Represents the response for a successful callback from renderFuturePaymentUI().
 */
declare export type PayPalCordovaPlugin$FuturePaymentResult = {
    response: {
        code: string
    }
} & PayPalCordovaPlugin$BaseResult


declare export interface PayPalCordovaPlugin$PayPalMobileStatic {

    /**
     * Retrieve the version of the PayPal iOS SDK library. Useful when contacting support.
     * @param completionCallback a callback function accepting a string
     */
    version(completionCallback: (result: string) => void): void,

        /**
         * You MUST call this method to initialize the PayPal Mobile SDK.
         * 
        The PayPal Mobile SDK can operate in different environments to facilitate development and testing."my-client-id-for-Production",
        PayPalEnvironmentSandbox : @"my-client-id-for-Sandbox"
        }
         * @param clientIdsForEnvironments set of client ids for environments
        Example: var clientIdsForEnvironments = {
        PayPalEnvironmentProduction : 
         * @param completionCallback a callback function on success
        */
        init(
            clientIdsForEnvironments: PayPalCordovaPlugin$PayPalClientIds,
            completionCallback: () => void): void,

        /**
         * You must preconnect to PayPal to prepare the device for processing payments.
         * This improves the user experience, by making the presentation of the
        UI faster. The preconnect is valid for a limited time, so
        the recommended time to preconnect is on page load.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param configuration PayPalConfiguration object, for Future Payments merchantName, merchantPrivacyPolicyURL
        and merchantUserAgreementURL must be set be set
         * @param completionCallback a callback function on success
        */
        prepareToRender(
            environment: string,
            configuration: PayPalConfiguration,
            completionCallback: () => void): void,

        /**
         * Start PayPal UI to collect payment from the user.
         * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/ios-integration-guide/
        for more documentation of the params.
         * @param payment PayPalPayment object
         * @param completionCallback a callback function accepting a js object, called when the user has completed payment
         * @param cancelCallback a callback function accepting a reason string, called when the user cancels the payment
        */
        renderSinglePaymentUI(
            payment: PayPalPayment,
            completionCallback: (result: PayPalCordovaPlugin$SinglePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * 
         * @deprecated  * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
        from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param callback applicationCorrelationID Your server will send this to PayPal in a 'Paypal-Application-Correlation-Id' header.
        */
        applicationCorrelationIDForEnvironment(
            environment: string,
            completionCallback: (applicationCorrelationId: string) => void): void,

        /**
         * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
         * from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param callback clientMetadataID Your server will send this to PayPal in a 'PayPal-Client-Metadata-Id' header.
        */
        clientMetadataID(completionCallback: (clientMetadataId: string) => void): void,

        /**
         * Please Read Docs on Future Payments at https://github.com/paypal/PayPal-iOS-SDK#future-payments
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
         */
        renderFuturePaymentUI(
            completionCallback: (result: PayPalCordovaPlugin$FuturePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * Please Read Docs on Profile Sharing at https://github.com/paypal/PayPal-iOS-SDK#profile-sharing
         * @param scopes scopes Set of requested scope-values. Accepted scopes are: openid, profile, address, email, phone, futurepayments and paypalattributes
        See https://developer.paypal.com/docs/integration/direct/identity/attributes/ for more details
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
        */
        renderProfileSharingUI(
            scopes: string[],
            completionCallback: (result: any) => void,
            cancelCallback: (cancelReason: string) => void): void
}
declare var PayPalMobile: PayPalCordovaPlugin$PayPalMobileStatic;
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Atmosphere$Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Atmosphere$Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & protractor$EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Atmosphere$Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Atmosphere$Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & protractor$EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module 'abs' {
    declare module.exports: typeof Abs
}
declare module 'absolute' {
    declare module.exports: typeof absolute
}
declare interface AccWizardOptions {

    /**
     * 
     * @summary  Add next/prev buttons to panels.
     * @type  
     */
    addButtons: boolean,

        /**
         * 
         * @summary  Selector for task sidebar.
         * @type  
         */
        sidebar: string,

        /**
         * 
         * @summary  Class to indicate the active task in sidebar.
         * @type  
         */
        activeClass: string,

        /**
         * 
         * @summary  Class to indicate task is complete.
         * @type  
         */
        completedClass: string,

        /**
         * 
         * @summary  Class to indicate task is still pending.
         * @type  
         */
        todoClass: string,

        /**
         * 
         * @summary  Class for step buttons within panels.
         * @type  
         */
        stepClass: string,

        /**
         * 
         * @summary  Text for next button.
         * @type  
         */
        nextText: string,

        /**
         * 
         * @summary  Text for back button.
         * @type  
         */
        backText: string,

        /**
         * 
         * @summary  HTML input type for next button. (default: "submit")
         * @type  
         */
        nextType: string,

        /**
         * 
         * @summary  HTML input type for back button. (default: "reset")
         * @type  
         */
        backType: string,

        /**
         * 
         * @summary  Class(es) for next button.
         * @type  
         */
        nextClasses: string,

        /**
         * 
         * @summary  Class(es) for back button.
         * @type  
         */
        backClasses: string,

        /**
         * 
         * @summary  Auto-scrolling.
         * @type  
         */
        autoScrolling: boolean,

        /**
         * 
         * @summary  Function to call on next step.
         */
        onNext: Function,

        /**
         * 
         * @summary  Function to call on back up.
         */
        onBack: Function,

        /**
         * 
         * @summary  A chance to hook initialization.
         */
        onInit: Function,

        /**
         * 
         * @summary  A chance to hook destruction.
         */
        onDestroy: Function
}
/**
 * 
 * @summary  Interface for "acc-wizard" JQuery plugin.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface JQuery {
    accwizard(options?: AccWizardOptions): void
}
declare interface IAccountingCurrencyFormat {
    pos: string,
        neg?: string,
        zero?: string
}
declare interface IAccountingCurrencySettings<TFormat>{
    symbol?: string,
    format?: TFormat,
    decimal?: string,
    thousand?: string,
    precision?: number
}
declare interface IAccountingNumberSettings {
    precision?: number,
        thousand?: string,
        decimal?: string
}
declare interface IAccountingSettings {
    currency: IAccountingCurrencySettings<any>,
        number: IAccountingNumberSettings
}
declare interface IAccountingStatic {
    formatMoney(
            number: number,
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string,
        formatMoney(number: number, options: IAccountingCurrencySettings<string>): string,
        formatMoney(
            number: number,
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string,
        formatMoney(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatMoney(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatMoney(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatMoney(
            numbers: any[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): any[],
        formatMoney(numbers: any[], options: IAccountingCurrencySettings<string>): any[],
        formatMoney(
            numbers: any[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): any[],
        formatColumn(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatColumn(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatColumn(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatColumn(
            numbers: number[][],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[][],
        formatColumn(numbers: number[][], options: IAccountingCurrencySettings<string>): string[][],
        formatColumn(
            numbers: number[][],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[][],
        formatNumber(
            number: number,
            precision?: number,
            thousand?: string,
            decimal?: string): string,
        formatNumber(number: number, options: IAccountingNumberSettings): string,
        formatNumber(
            number: number[],
            precision?: number,
            thousand?: string,
            decimal?: string): string[],
        formatNumber(number: number[], options: IAccountingNumberSettings): string[],
        formatNumber(number: any[], precision?: number, thousand?: string, decimal?: string): any[],
        formatNumber(number: any[], options: IAccountingNumberSettings): any[],
        toFixed(number: number, precision?: number): string,
        unformat(string: string, decimal?: string): number,
        settings: IAccountingSettings
}
declare var accounting: IAccountingStatic;
declare module 'accounting' {
    declare module.exports: typeof accounting
}
declare export interface AceAjax$Delta {
    action: string,
        range: AceAjax$Range,
        text: string,
        lines: string[]
}

declare export interface AceAjax$EditorCommand {
    name: string,
        bindKey: any,
        exec: Function,
        readOnly?: boolean
}

declare export interface AceAjax$CommandManager {
    byName: any,
        commands: any,
        platform: string,
        addCommands(commands: AceAjax$EditorCommand[]): void,
        addCommand(command: AceAjax$EditorCommand): void,
        exec(name: string, editor: AceAjax$Editor, args: any): void
}

declare export interface AceAjax$Annotation {
    row: number,
        column: number,
        text: string,
        type: string
}

declare export interface AceAjax$TokenInfo {
    value: string
}

declare export interface AceAjax$Position {
    row: number,
        column: number
}

declare export interface AceAjax$KeyBinding {
    setDefaultHandler(kb: any): void,
        setKeyboardHandler(kb: any): void,
        addKeyboardHandler(kb: any, pos: any): void,
        removeKeyboardHandler(kb: any): boolean,
        getKeyboardHandler(): any,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        onTextInput(text: any): void
}

declare export interface AceAjax$TextMode {
    getTokenizer(): any,
        toggleCommentLines(state: any, doc: any, startRow: any, endRow: any): void,
        getNextLineIndent(state: any, line: any, tab: any): string,
        checkOutdent(state: any, line: any, input: any): boolean,
        autoOutdent(state: any, doc: any, row: any): void,
        createWorker(session: any): any,
        createModeDelegates(mapping: any): void,
        transformAction(state: any, action: any, editor: any, session: any, param: any): any
}


/**
 * The main class required to set up an Ace instance in the browser.
 */
declare export interface AceAjax$Ace {

    /**
     * Provides access to require in packed noconflict mode
     * @param moduleName 
     */
    require(moduleName: string): any,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: string): AceAjax$Editor,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: HTMLElement): AceAjax$Editor,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: AceAjax$Document, mode: AceAjax$TextMode): AceAjax$IEditSession,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: string, mode: AceAjax$TextMode): AceAjax$IEditSession
}


/**
 * Defines the floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the cursor is updated.
 */
declare export interface AceAjax$Anchor {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Returns an object identifying the `row` and `column` position of the current anchor.
         */
        getPosition(): AceAjax$Position,

        /**
         * Returns the current document.
         */
        getDocument(): AceAjax$Document,

        /**
         * Fires whenever the anchor position changes.
         * Both of these objects have a `row` and `column` property corresponding to the position.
        Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
         * @param e An object containing information about the anchor position. It has two properties:
        - `old`: An object describing the old Anchor position
        - `value`: An object describing the new Anchor position
        */
        onChange(e: any): void,

        /**
         * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
         * @param row The row index to move the anchor to
         * @param column The column index to move the anchor to
         * @param noClip Identifies if you want the position to be clipped
         */
        setPosition(row: number, column: number, noClip: boolean): void,

        /**
         * When called, the `'change'` event listener is removed.
         */
        detach(): void
}

declare var Anchor: {

    /**
     * Creates a new `Anchor` and associates it with a document.
     * @param doc The document to associate with the anchor
     * @param row The starting row position
     * @param column The starting column position
     */
    new(doc: AceAjax$Document, row: number, column: number): AceAjax$Anchor
};


/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use.
 * If a certain row is changed, everything below that row is re-tokenized.
 */
declare export interface AceAjax$BackgroundTokenizer {
    states: any[],

        /**
         * Sets a new tokenizer for this object.
         * @param tokenizer The new tokenizer to use
         */
        setTokenizer(tokenizer: AceAjax$Tokenizer): void,

        /**
         * Sets a new document to associate with this object.
         * @param doc The new document to associate with
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
         * @param firstRow The starting row region
         * @param lastRow The final row region
         */
        fireUpdateEvent(firstRow: number, lastRow: number): void,

        /**
         * Starts tokenizing at the row indicated.
         * @param startRow The row to start at
         */
        start(startRow: number): void,

        /**
         * Stops tokenizing.
         */
        stop(): void,

        /**
         * Gives list of tokens of the row. (tokens are cached)
         * @param row The row to get tokens at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}
         * @param row The row to get state at
         */
        getState(row: number): string
}

declare var BackgroundTokenizer: {

    /**
     * Creates a new `BackgroundTokenizer` object.
     * @param tokenizer The tokenizer to use
     * @param editor The editor to associate with
     */
    new(
        tokenizer: AceAjax$Tokenizer,
        editor: AceAjax$Editor): AceAjax$BackgroundTokenizer
};


/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s.
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 */
declare export interface AceAjax$Document {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Replaces all the lines in the current `Document` with the value of `text`.
         * @param text The text to use
         */
        setValue(text: string): void,

        /**
         * Returns all the lines in the document as a single string, split by the new line character.
         */
        getValue(): string,

        /**
         * Creates a new `Anchor` to define a floating point in the document.
         * @param row The row number to use
         * @param column The column number to use
         */
        createAnchor(row: number, column: number): void,

        /**
         * Returns the newline character that's being used, depending on the value of `newLineMode`.
         */
        getNewLineCharacter(): string,

        /**
         * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
         * @param newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
         */
        getNewLineMode(): string,

        /**
         * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
         * @param text The text to check
         */
        isNewLine(text: string): boolean,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row index to retrieve
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns all lines in the document as string array. Warning: The caller should not modify this array!
         */
        getAllLines(): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * [Given a range within the document, this function returns all the text within that range as a single string.]{: #Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Inserts the elements in `lines` into the document, starting at the row index given by `row`. This method also triggers the `'change'` event.
         * @param row The index of the row to insert at
         * @param lines An array of strings
         */
        insertLines(row: number, lines: string[]): any,

        /**
         * Inserts a new line into the document at the current row's `position`. This method also triggers the `'change'` event.
         * @param position The position to insert at
         */
        insertNewLine(position: AceAjax$Position): any,

        /**
         * Inserts `text` into the `position` at the current row. This method also triggers the `'change'` event.
         * @param position The position to insert at
         * @param text A chunk of text
         */
        insertInLine(position: any, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Removes the specified columns from the `row`. This method also triggers the `'change'` event.
         * @param row The row to remove from
         * @param startColumn The column to start removing at
         * @param endColumn The column to stop removing at
         */
        removeInLine(row: number, startColumn: number, endColumn: number): any,

        /**
         * Removes a range of full lines. This method also triggers the `'change'` event.
         * @param firstRow The first row to be removed
         * @param lastRow The last row to be removed
         */
        removeLines(firstRow: number, lastRow: number): string[],

        /**
         * Removes the new line between `row` and the row immediately following it. This method also triggers the `'change'` event.
         * @param row The row to check
         */
        removeNewLine(row: number): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Applies all the changes previously accumulated. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        applyDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Reverts any changes previously applied. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        revertDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Converts an index position in a document to a `{row, column}` object.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param index An index to convert
         * @param startRow =0 The row from which to start the conversion
        */
        indexToPosition(index: number, startRow: number): AceAjax$Position,

        /**
         * Converts the `{row, column}` position in a document to the character's index.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param pos The `{row, column}` to convert
         * @param startRow =0 The row from which to start the conversion
        */
        positionToIndex(pos: AceAjax$Position, startRow: number): number
}

declare var Document: {

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string): AceAjax$Document,

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string[]): AceAjax$Document
};


/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 */
declare export interface AceAjax$IEditSession {
    selection: AceAjax$Selection,
        bgTokenizer: AceAjax$BackgroundTokenizer,
        doc: AceAjax$Document,
        on(event: string, fn: (e: any) => any): void,
        findMatchingBracket(position: AceAjax$Position): void,
        addFold(text: string, range: AceAjax$Range): void,
        getFoldAt(row: number, column: number): any,
        removeFold(arg: any): void,
        expandFold(arg: any): void,
        unfold(arg1: any, arg2: boolean): void,
        screenToDocumentColumn(row: number, column: number): void,
        getFoldDisplayLine(foldLine: any, docRow: number, docColumn: number): any,
        getFoldsInRange(range: AceAjax$Range): any,
        highlight(text: string): void,

        /**
         * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
         * @param doc The new `Document` to use
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Returns the `Document` associated with this session.
         */
        getDocument(): AceAjax$Document,

        /**
         * undefined
         * @param row The row to work with
         */
        $resetRowCache(row: number): void,

        /**
         * Sets the session text.
         * @param text The new text to place
         */
        setValue(text: string): void,
        setMode(mode: string): void,

        /**
         * Returns the current [[Document `Document`]] as a string.
         */
        getValue(): string,

        /**
         * Returns the string of the current selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:BackgroundTokenizer.getState}
         * @param row The row to start at
         */
        getState(row: number): string,

        /**
         * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
         * @param row The row to start at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
         * @param row The row number to retrieve from
         * @param column The column number to retrieve from
         */
        getTokenAt(row: number, column: number): AceAjax$TokenInfo,

        /**
         * Sets the undo manager.
         * @param undoManager The new undo manager
         */
        setUndoManager(undoManager: AceAjax$UndoManager): void,

        /**
         * Returns the current undo manager.
         */
        getUndoManager(): AceAjax$UndoManager,

        /**
         * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]): void; otherwise it's simply `'\t'`.
         */
        getTabString(): string,

        /**
         * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
         * @param useSoftTabs Value indicating whether or not to use soft tabs
         */
        setUseSoftTabs(useSoftTabs: boolean): void,

        /**
         * Returns `true` if soft tabs are being used, `false` otherwise.
         */
        getUseSoftTabs(): boolean,

        /**
         * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
         * @param tabSize The new tab size
         */
        setTabSize(tabSize: number): void,

        /**
         * Returns the current tab size.
         */
        getTabSize(): number,

        /**
         * Returns `true` if the character at the position is a soft tab.
         * @param position The position to check
         */
        isTabStop(position: any): boolean,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable.
         * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
         * @param row The row number
         * @param className The class to add
         */
        addGutterDecoration(row: number, className: string): void,

        /**
         * Removes `className` from the `row`.
         * @param row The row number
         * @param className The class to add
         */
        removeGutterDecoration(row: number, className: string): void,

        /**
         * Returns an array of numbers, indicating which rows have breakpoints.
         */
        getBreakpoints(): number[],

        /**
         * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param rows An array of row indices
         */
        setBreakpoints(rows: any[]): void,

        /**
         * Removes all breakpoints on the rows. This function also emites the `'changeBreakpoint'` event.
         */
        clearBreakpoints(): void,

        /**
         * Sets a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         * @param className Class of the breakpoint
         */
        setBreakpoint(row: number, className: string): void,

        /**
         * Removes a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         */
        clearBreakpoint(row: number): void,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: Function, inFront: boolean): number,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: string, inFront: boolean): number,

        /**
         * Adds a dynamic marker to the session.
         * @param marker object with update method
         * @param inFront Set to `true` to establish a front marker
         */
        addDynamicMarker(marker: any, inFront: boolean): void,

        /**
         * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
         * @param markerId A number representing a marker
         */
        removeMarker(markerId: number): void,

        /**
         * Returns an array containing the IDs of all the markers, either front or back.
         * @param inFront If `true`, indicates you only want front markers; `false` indicates only back markers
         */
        getMarkers(inFront: boolean): any[],

        /**
         * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
         * @param annotations A list of annotations
         */
        setAnnotations(annotations: AceAjax$Annotation[]): void,

        /**
         * Returns the annotations for the `EditSession`.
         */
        getAnnotations(): any,

        /**
         * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
         */
        clearAnnotations(): void,

        /**
         * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
         * @param text A block of text
         */
        $detectNewLine(text: string): void,

        /**
         * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
         * @param row The row to start at
         * @param column The column to start at
         */
        getWordRange(row: number, column: number): AceAjax$Range,

        /**
         * Gets the range of a word, including its right whitespace.
         * @param row The row number to start from
         * @param column The column number to start from
         */
        getAWordRange(row: number, column: number): any,

        /**
         * {:Document.setNewLineMode.desc}
         * @param newLineMode :Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * Returns the current new line mode.
         */
        getNewLineMode(): string,

        /**
         * Identifies if you want to use a worker for the `EditSession`.
         * @param useWorker Set to `true` to use a worker
         */
        setUseWorker(useWorker: boolean): void,

        /**
         * Returns `true` if workers are being used.
         */
        getUseWorker(): boolean,

        /**
         * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
         */
        onReloadTokenizer(): void,

        /**
         * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
         * @param mode Set a new text mode
         */
        $mode(mode: AceAjax$TextMode): void,

        /**
         * Returns the current text mode.
         */
        getMode(): AceAjax$TextMode,

        /**
         * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
         * @param scrollTop The new scroll top value
         */
        setScrollTop(scrollTop: number): void,

        /**
         * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
         */
        setScrollLeft(): void,

        /**
         * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the width of the screen.
         */
        getScreenWidth(): number,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row to retrieve from
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * {:Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position {row, column} to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Reverts previous changes to your document.
         * @param deltas An array of previous changes
         * @param dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
         */
        undoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Re-implements a previously undone change to your document.
         * @param deltas An array of previous changes
         * @param dontSelect :dontSelect}
         */
        redoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Enables or disables highlighting of the range where an undo occured.
         * @param enable If `true`, selects the range of the reinserted change
         */
        setUndoSelect(enable: boolean): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
         * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
         * @param startRow Starting row
         * @param endRow Ending row
         * @param indentString The indent token
         */
        indentRows(startRow: number, endRow: number, indentString: string): void,

        /**
         * Outdents all the rows defined by the `start` and `end` properties of `range`.
         * @param range A range of rows
         */
        outdentRows(range: AceAjax$Range): void,

        /**
         * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move up
         * @param lastRow The final row to move up
         */
        moveLinesUp(firstRow: number, lastRow: number): number,

        /**
         * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move down
         * @param lastRow The final row to move down
         */
        moveLinesDown(firstRow: number, lastRow: number): number,

        /**
         * Duplicates all the text between `firstRow` and `lastRow`.
         * @param firstRow The starting row to duplicate
         * @param lastRow The final row to duplicate
         */
        duplicateLines(firstRow: number, lastRow: number): number,

        /**
         * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
         * @param useWrapMode Enable (or disable) wrap mode
         */
        setUseWrapMode(useWrapMode: boolean): void,

        /**
         * Returns `true` if wrap mode is being used; `false` otherwise.
         */
        getUseWrapMode(): boolean,

        /**
         * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
         * @param min The minimum wrap value (the left side wrap)
         * @param max The maximum wrap value (the right side wrap)
         */
        setWrapLimitRange(min: number, max: number): void,

        /**
         * This should generally only be called by the renderer when a resize is detected.
         * @param desiredLimit The new wrap limit
         */
        adjustWrapLimit(desiredLimit: number): boolean,

        /**
         * Returns the value of wrap limit.
         */
        getWrapLimit(): number,

        /**
         * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
         * { min: wrapLimitRange_min, max: wrapLimitRange_max }
         */
        getWrapLimitRange(): any,

        /**
         * Given a string, returns an array of the display characters, including tabs and spaces.
         * @param str The string to check
         * @param offset The value to start at
         */
        $getDisplayTokens(str: string, offset: number): void,

        /**
         * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
         * @param str The string to calculate the screen width of
         * @param maxScreenColumn 
         * @param screenColumn 
         */
        $getStringScreenWidth(str: string, maxScreenColumn: number, screenColumn: number): number[],

        /**
         * Returns number of screenrows in a wrapped line.
         * @param row The row number to check
         */
        getRowLength(row: number): number,

        /**
         * Returns the position (on screen) for the last character in the provided screen row.
         * @param screenRow The screen row to check
         */
        getScreenLastRowColumn(screenRow: number): number,

        /**
         * For the given document row and column, this returns the column position of the last screen row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumn(docRow: number, docColumn: number): number,

        /**
         * For the given document row and column, this returns the document position of the last row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumnPosition(docRow: number, docColumn: number): number,

        /**
         * For the given row, this returns the split data.
         */
        getRowSplitData(): string,

        /**
         * The distance to the next tab stop at the specified screen column.
         * @param screenColumn The screen column to check
         */
        getScreenTabSize(screenColumn: number): number,

        /**
         * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
         * @param screenRow The screen row to check
         * @param screenColumn The screen column to check
         */
        screenToDocumentPosition(screenRow: number, screenColumn: number): any,

        /**
         * Converts document coordinates to screen coordinates. {:conversionConsiderations}
         * @param docRow The document row to check
         * @param docColumn The document column to check
         */
        documentToScreenPosition(docRow: number, docColumn: number): any,

        /**
         * For the given document row and column, returns the screen column.
         * @param row 
         * @param docColumn 
         */
        documentToScreenColumn(row: number, docColumn: number): number,

        /**
         * For the given document row and column, returns the screen row.
         * @param docRow 
         * @param docColumn 
         */
        documentToScreenRow(docRow: number, docColumn: number): void,

        /**
         * Returns the length of the screen.
         */
        getScreenLength(): number
}

declare var EditSession: {

    /**
     * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.
     * @param text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
     * @param mode [The inital language mode to use for the document]{: #modeParam}
     */
    new(text: string, mode?: AceAjax$TextMode): AceAjax$IEditSession,
    new(content: string, mode?: string): AceAjax$IEditSession,
    new(text: string[], mode?: string): AceAjax$IEditSession
};


/**
 * The main entry point into the Ace functionality.
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
*/
declare export interface AceAjax$Editor {
    on(ev: string, callback: (e: any) => any): void,
        addEventListener(ev: "change", callback: (ev: AceAjax$EditorChangeEvent) => any): void,
        addEventListener(ev: string, callback: Function): void,
        inMultiSelectMode: boolean,
        selectMoreLines(n: number): void,
        onTextInput(text: string): void,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        commands: AceAjax$CommandManager,
        session: AceAjax$IEditSession,
        selection: AceAjax$Selection,
        renderer: AceAjax$VirtualRenderer,
        keyBinding: AceAjax$KeyBinding,
        container: HTMLElement,
        onSelectionChange(e: any): void,
        onChangeMode(e?: any): void,
        execCommand(command: string, args?: any): void,

        /**
         * Sets a Configuration Option
         */
        setOption(optionName: any, optionValue: any): void,

        /**
         * Sets Configuration Options
         */
        setOptions(keyValueTuples: any): void,

        /**
         * Get a Configuration Option
         */
        getOption(name: any): any,

        /**
         * Get Configuration Options
         */
        getOptions(): any,

        /**
         * Get rid of console warning by setting this to Infinity
         */
        $blockScrolling: number,

        /**
         * Sets a new key handler, such as "vim" or "windows".
         * @param keyboardHandler The new key handler
         */
        setKeyboardHandler(keyboardHandler: string): void,

        /**
         * Returns the keyboard handler, such as "vim" or "windows".
         */
        getKeyboardHandler(): string,

        /**
         * Sets a new editsession to use. This method also emits the `'changeSession'` event.
         * @param session The new session to use
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Returns the current session being used.
         */
        getSession(): AceAjax$IEditSession,

        /**
         * Sets the current document to `val`.
         * @param val The new value to set for the document
         * @param cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
         */
        setValue(val: string, cursorPos?: number): string,

        /**
         * Returns the current session's content.
         */
        getValue(): string,

        /**
         * Returns the currently highlighted selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         */
        resize(force?: boolean): void,

        /**
         * {:VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * {:VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * {:VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * {:VirtualRenderer.unsetStyle}
         */
        unsetStyle(): void,

        /**
         * Set a new font size (in pixels) for the editor text.
         * @param size A font size ( _e.g._ "12px")
         */
        setFontSize(size: string): void,

        /**
         * Brings the current `textInput` into focus.
         */
        focus(): void,

        /**
         * Returns `true` if the current `textInput` is in focus.
         */
        isFocused(): void,

        /**
         * Blurs the current `textInput`.
         */
        blur(): void,

        /**
         * Emitted once the editor comes into focus.
         */
        onFocus(): void,

        /**
         * Emitted once the editor has been blurred.
         */
        onBlur(): void,

        /**
         * Emitted whenever the document is changed.
         * @param e Contains a single property, `data`, which has the delta of changes
         */
        onDocumentChange(e: any): void,

        /**
         * Emitted when the selection changes.
         */
        onCursorChange(): void,

        /**
         * Returns the string of text currently highlighted.
         */
        getCopyText(): string,

        /**
         * Called whenever a text "copy" happens.
         */
        onCopy(): void,

        /**
         * Called whenever a text "cut" happens.
         */
        onCut(): void,

        /**
         * Called whenever a text "paste" happens.
         * @param text The pasted text
         */
        onPaste(text: string): void,

        /**
         * Inserts `text` into wherever the cursor is pointing.
         * @param text The new text to add
         */
        insert(text: string): void,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Sets how fast the mouse scrolling should do.
         * @param speed A value indicating the new speed (in milliseconds)
         */
        setScrollSpeed(speed: number): void,

        /**
         * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
         */
        getScrollSpeed(): number,

        /**
         * Sets the delay (in milliseconds) of the mouse drag.
         * @param dragDelay A value indicating the new delay
         */
        setDragDelay(dragDelay: number): void,

        /**
         * Returns the current mouse drag delay.
         */
        getDragDelay(): number,

        /**
         * Indicates how selections should occur.
         * By default, selections are set to "line". There are no other styles at the moment,
        although this code change in the future.
        This function also emits the `'changeSelectionStyle'` event.
         * @param style The new selection style
        */
        setSelectionStyle(style: string): void,

        /**
         * Returns the current selection style.
         */
        getSelectionStyle(): string,

        /**
         * Determines whether or not the current line should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the current line
         */
        setHighlightActiveLine(shouldHighlight: boolean): void,

        /**
         * Returns `true` if current lines are always highlighted.
         */
        getHighlightActiveLine(): void,

        /**
         * Determines if the currently selected word should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the currently selected word
         */
        setHighlightSelectedWord(shouldHighlight: boolean): void,

        /**
         * Returns `true` if currently highlighted words are to be highlighted.
         */
        getHighlightSelectedWord(): boolean,

        /**
         * If `showInvisibiles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
         * @param showInvisibles Specifies whether or not to show invisible characters
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns `true` if invisible characters are being shown.
         */
        getShowInvisibles(): boolean,

        /**
         * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
         * @param showPrintMargin Specifies whether or not to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns `true` if the print margin is being shown.
         */
        getShowPrintMargin(): boolean,

        /**
         * Sets the column defining where the print margin should be.
         * @param showPrintMargin Specifies the new print margin
         */
        setPrintMarginColumn(showPrintMargin: number): void,

        /**
         * Returns the column number of where the print margin is.
         */
        getPrintMarginColumn(): number,

        /**
         * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
         * @param readOnly Specifies whether the editor can be modified or not
         */
        setReadOnly(readOnly: boolean): void,

        /**
         * Returns `true` if the editor is set to read-only mode.
         */
        getReadOnly(): boolean,

        /**
         * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
         * @param enabled Enables or disables behaviors
         */
        setBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
         */
        getBehavioursEnabled(): boolean,

        /**
         * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
         * when such a character is typed in.
         * @param enabled Enables or disables wrapping behaviors
         */
        setWrapBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the wrapping behaviors are currently enabled.
         */
        getWrapBehavioursEnabled(): void,

        /**
         * Indicates whether the fold widgets are shown or not.
         * @param show Specifies whether the fold widgets are shown
         */
        setShowFoldWidgets(show: boolean): void,

        /**
         * Returns `true` if the fold widgets are shown.
         */
        getShowFoldWidgets(): void,

        /**
         * Removes words of text from the editor. A "word" is defined as a string of characters bookended by whitespace.
         * @param dir The direction of the deletion to occur, either "left" or "right"
         */
        remove(dir: string): void,

        /**
         * Removes the word directly to the right of the current selection.
         */
        removeWordRight(): void,

        /**
         * Removes the word directly to the left of the current selection.
         */
        removeWordLeft(): void,

        /**
         * Removes all the words to the left of the current selection, until the start of the line.
         */
        removeToLineStart(): void,

        /**
         * Removes all the words to the right of the current selection, until the end of the line.
         */
        removeToLineEnd(): void,

        /**
         * Splits the line at the current selection (by inserting an `'\n'`).
         */
        splitLine(): void,

        /**
         * Transposes current line.
         */
        transposeLetters(): void,

        /**
         * Converts the current selection entirely into lowercase.
         */
        toLowerCase(): void,

        /**
         * Converts the current selection entirely into uppercase.
         */
        toUpperCase(): void,

        /**
         * Inserts an indentation into the current cursor position or indents the selected lines.
         */
        indent(): void,

        /**
         * Indents the current line.
         */
        blockIndent(): void,

        /**
         * Outdents the current line.
         */
        blockOutdent(arg?: string): void,

        /**
         * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
         */
        toggleCommentLines(): void,

        /**
         * Works like [[EditSession.getTokenAt]], except it returns a number.
         */
        getNumberAt(): number,

        /**
         * If the character before the cursor is a number, this functions changes its value by `amount`.
         * @param amount The value to change the numeral by (can be negative to decrease value)
         */
        modifyNumber(amount: number): void,

        /**
         * Removes all the lines in the current selection
         */
        removeLines(): void,

        /**
         * Shifts all the selected lines down one row.
         */
        moveLinesDown(): number,

        /**
         * Shifts all the selected lines up one row.
         */
        moveLinesUp(): number,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Copies all the selected lines up one row.
         */
        copyLinesUp(): number,

        /**
         * Copies all the selected lines down one row.
         */
        copyLinesDown(): number,

        /**
         * {:VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * {:VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Indicates if the row is currently visible on the screen.
         * @param row The row to check
         */
        isRowVisible(row: number): boolean,

        /**
         * Indicates if the entire row is currently visible on the screen.
         * @param row The row to check
         */
        isRowFullyVisible(row: number): boolean,

        /**
         * Selects the text from the current position of the document until where a "page down" finishes.
         */
        selectPageDown(): void,

        /**
         * Selects the text from the current position of the document until where a "page up" finishes.
         */
        selectPageUp(): void,

        /**
         * Shifts the document to wherever "page down" is, as well as moving the cursor position.
         */
        gotoPageDown(): void,

        /**
         * Shifts the document to wherever "page up" is, as well as moving the cursor position.
         */
        gotoPageUp(): void,

        /**
         * Scrolls the document to wherever "page down" is, without changing the cursor position.
         */
        scrollPageDown(): void,

        /**
         * Scrolls the document to wherever "page up" is, without changing the cursor position.
         */
        scrollPageUp(): void,

        /**
         * Moves the editor to the specified row.
         */
        scrollToRow(): void,

        /**
         * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
         * @param line The line to scroll to
         * @param center If `true`
         * @param animate If `true` animates scrolling
         * @param callback Function to be called when the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Attempts to center the current selection on the screen.
         */
        centerSelection(): void,

        /**
         * Gets the current position of the cursor.
         */
        getCursorPosition(): AceAjax$Position,

        /**
         * Returns the screen position of the cursor.
         */
        getCursorPositionScreen(): number,

        /**
         * {:Selection.getRange}
         */
        getSelectionRange(): AceAjax$Range,

        /**
         * Selects all the text in editor.
         */
        selectAll(): void,

        /**
         * {:Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        moveCursorTo(row: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
         * @param position An object with two properties, row and column
         */
        moveCursorToPosition(position: AceAjax$Position): void,

        /**
         * Moves the cursor's row and column to the next matching bracket.
         */
        jumpToMatching(): void,

        /**
         * Moves the cursor to the specified line number, and also into the indiciated column.
         * @param lineNumber The line number to go to
         * @param column A column number to go to
         * @param animate If `true` animates scolling
         */
        gotoLine(lineNumber: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        navigateTo(row: number, column: number): void,

        /**
         * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateUp(times?: number): void,

        /**
         * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateDown(times?: number): void,

        /**
         * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateLeft(times?: number): void,

        /**
         * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateRight(times: number): void,

        /**
         * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
         */
        navigateLineStart(): void,

        /**
         * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
         */
        navigateLineEnd(): void,

        /**
         * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
         */
        navigateFileEnd(): void,

        /**
         * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
         */
        navigateFileStart(): void,

        /**
         * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
         */
        navigateWordRight(): void,

        /**
         * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
         */
        navigateWordLeft(): void,

        /**
         * Replaces the first occurance of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replace(replacement: string, options?: any): void,

        /**
         * Replaces all occurances of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replaceAll(replacement: string, options?: any): void,

        /**
         * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
         */
        getLastSearchOptions(): any,

        /**
         * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
         * @param needle The text to search for (optional)
         * @param options An object defining various search properties
         * @param animate If `true` animate scrolling
         */
        find(needle: string, options?: any, animate?: boolean): void,

        /**
         * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findNext(options?: any, animate?: boolean): void,

        /**
         * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findPrevious(options?: any, animate?: boolean): void,

        /**
         * {:UndoManager.undo}
         */
        undo(): void,

        /**
         * {:UndoManager.redo}
         */
        redo(): void,

        /**
         * Cleans up the entire editor.
         */
        destroy(): void
}

declare var Editor: {

    /**
     * Creates a new `Editor` object.
     * @param renderer Associated `VirtualRenderer` that draws everything
     * @param session The `EditSession` to refer to
     */
    new(
        renderer: AceAjax$VirtualRenderer,
        session?: AceAjax$IEditSession): AceAjax$Editor
};

declare interface AceAjax$EditorChangeEvent {
    start: AceAjax$Position,
        end: AceAjax$Position,
        action: string,
        lines: any[]
}

declare export interface AceAjax$PlaceHolder {
    on(event: string, fn: (e: any) => any): void,

        /**
         * PlaceHolder.setup()
         * TODO
         */
        setup(): void,

        /**
         * PlaceHolder.showOtherMarkers()
         * TODO
         */
        showOtherMarkers(): void,

        /**
         * PlaceHolder.hideOtherMarkers()
         * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
         */
        hideOtherMarkers(): void,

        /**
         * PlaceHolder@onUpdate(e)
         * Emitted when the place holder updates.
         */
        onUpdate(): void,

        /**
         * PlaceHolder@onCursorChange(e)
         * Emitted when the cursor changes.
         */
        onCursorChange(): void,

        /**
         * PlaceHolder.detach()
         * TODO
         */
        detach(): void,

        /**
         * PlaceHolder.cancel()
         * TODO
         */
        cancel(): void
}

declare var PlaceHolder: {

    /**
     * - 
     * @param session (Document): The document to associate with the anchor
    - 
     * @param length (Number): The starting row position
    - 
     * @param pos (Number): The starting column position
    - 
     * @param others (String):
    - 
     * @param mainClass (String):
    - 
     * @param othersClass (String):
    */
    new(
        session: AceAjax$Document,
        length: number,
        pos: number,
        others: string,
        mainClass: string,
        othersClass: string): AceAjax$PlaceHolder,
    new(
        session: AceAjax$IEditSession,
        length: number,
        pos: AceAjax$Position,
        positions: AceAjax$Position[]): AceAjax$PlaceHolder
};

declare export interface AceAjax$IRangeList {
    ranges: AceAjax$Range[],
        pointIndex(pos: AceAjax$Position, startIndex?: number): void,
        addList(ranges: AceAjax$Range[]): void,
        add(ranges: AceAjax$Range): void,
        merge(): AceAjax$Range[],
        substractPoint(pos: AceAjax$Position): void
}

declare export var RangeList: {
    new(): AceAjax$IRangeList
};


/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogus to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 */
declare export interface AceAjax$Range {
    startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number,
        start: AceAjax$Position,
        end: AceAjax$Position,
        isEmpty(): boolean,

        /**
         * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
         * @param range A range to check against
         */
        isEqual(range: AceAjax$Range): void,

        /**
         * Returns a string containing the range's row and column information, given like this:
         * ```
        [start.row/start.column] -> [end.row/end.column]
        ```
        */
        toString(): void,

        /**
         * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
         * ```javascript
        this.start.row <= row <= this.end.row &&
        this.start.column <= column <= this.end.column
        ```
         * @param row A row to check for
         * @param column A column to check for
        */
        contains(row: number, column: number): boolean,

        /**
         * Compares `this` range (A) with another range (B).
         * @param range A range to compare with
         */
        compareRange(range: AceAjax$Range): number,

        /**
         * Checks the row and column points of `p` with the row and column points of the calling range.
         * @param p A point to compare with
         */
        comparePoint(p: AceAjax$Range): number,

        /**
         * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
         * @param range A range to compare with
         */
        containsRange(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if passed in `range` intersects with the one calling this method.
         * @param range A range to compare with
         */
        intersects(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isEnd(row: number, column: number): boolean,

        /**
         * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isStart(row: number, column: number): boolean,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setStart(row: number, column: number): void,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setEnd(row: number, column: number): void,

        /**
         * Returns `true` if the `row` and `column` are within the given range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        inside(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's starting points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideStart(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's ending points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideEnd(row: number, column: number): boolean,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compare(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareStart(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareEnd(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareInside(row: number, column: number): number,

        /**
         * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
         * @param firstRow The starting row
         * @param lastRow The ending row
         */
        clipRows(firstRow: number, lastRow: number): AceAjax$Range,

        /**
         * Changes the row and column points for the calling range for both the starting and ending points.
         * @param row A new row to extend to
         * @param column A new column to extend to
         */
        extend(row: number, column: number): AceAjax$Range,

        /**
         * Returns `true` if the range spans across multiple lines.
         */
        isMultiLine(): boolean,

        /**
         * Returns a duplicate of the calling range.
         */
        clone(): AceAjax$Range,

        /**
         * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
         */
        collapseRows(): AceAjax$Range,

        /**
         * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.
         * @param session The `EditSession` to retrieve coordinates from
         */
        toScreenRange(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Creates and returns a new `Range` based on the row and column of the given parameters.
         * @param start A starting point to use
         * @param end An ending point to use
         */
        fromPoints(start: AceAjax$Range, end: AceAjax$Range): AceAjax$Range
}

declare var Range: {
    fromPoints(pos1: AceAjax$Position, pos2: AceAjax$Position): AceAjax$Range,
    new(
        startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number): AceAjax$Range
};

declare export interface AceAjax$RenderLoop {}

declare var RenderLoop: {
    new(): AceAjax$RenderLoop
};


/**
 * A set of methods for setting and retrieving the editor's scrollbar.
 */
declare export interface AceAjax$ScrollBar {

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @param e Contains one property, `"data"`, which indicates the current scroll top position
     */
    onScroll(e: any): void,

        /**
         * Returns the width of the scroll bar.
         */
        getWidth(): number,

        /**
         * Sets the height of the scroll bar, in pixels.
         * @param height The new height
         */
        setHeight(height: number): void,

        /**
         * Sets the inner height of the scroll bar, in pixels.
         * @param height The new inner height
         */
        setInnerHeight(height: number): void,

        /**
         * Sets the scroll top of the scroll bar.
         * @param scrollTop The new scroll top
         */
        setScrollTop(scrollTop: number): void
}

declare var ScrollBar: {

    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param parent A DOM element
     */
    new(parent: HTMLElement): AceAjax$ScrollBar
};


/**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 */
declare export interface AceAjax$Search {

    /**
     * Sets the search options via the `options` parameter.
     * @param options An object containing all the new search properties
     */
    set(options: any): AceAjax$Search,

        /**
         * [Returns an object containing all the search options.]{: #Search.getOptions}
         */
        getOptions(): any,

        /**
         * Sets the search options via the `options` parameter.
         * @param An object containing all the search propertie
         */
        setOptions(An: any): void,

        /**
         * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        find(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Searches for all occurances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        findAll(session: AceAjax$IEditSession): AceAjax$Range[],

        /**
         * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
         * @param input The text to search in
         * @param replacement The replacing text
        + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
        If `options.needle` was not found, this function returns `null`.
        */
        replace(input: string, replacement: string): string
}

declare var Search: {

    /**
     * Creates a new `Search` object. The following search options are avaliable:
     * - `needle`: The string or regular expression you're looking for
    - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.
    - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.
    - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.
    - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.
    - `range`: The [[Range]] to search within. Set this to `null` for the whole document
    - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.
    - `start`: The starting [[Range]] or cursor position to begin the search
    - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.
    */
    new(): AceAjax$Search
};


/**
 * Contains the cursor position and the text selection of an edit session.
 * The row/columns used in the selection are in document coordinates representing ths coordinates as thez appear in the document before applying soft wrap and folding.
 */
declare export interface AceAjax$Selection {
    addEventListener(ev: string, callback: Function): void,
        moveCursorWordLeft(): void,
        moveCursorWordRight(): void,
        fromOrientedRange(range: AceAjax$Range): void,
        setSelectionRange(match: any): void,
        getAllRanges(): AceAjax$Range[],
        on(event: string, fn: (e: any) => any): void,
        addRange(range: AceAjax$Range): void,

        /**
         * Returns `true` if the selection is empty.
         */
        isEmpty(): boolean,

        /**
         * Returns `true` if the selection is a multi-line.
         */
        isMultiLine(): boolean,

        /**
         * Gets the current position of the cursor.
         */
        getCursor(): AceAjax$Position,

        /**
         * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
         * @param row The new row
         * @param column The new column
         */
        setSelectionAnchor(row: number, column: number): void,

        /**
         * Returns an object containing the `row` and `column` of the calling selection anchor.
         */
        getSelectionAnchor(): any,

        /**
         * Returns an object containing the `row` and `column` of the calling selection lead.
         */
        getSelectionLead(): any,

        /**
         * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
         * @param columns The number of columns to shift by
         */
        shiftSelection(columns: number): void,

        /**
         * Returns `true` if the selection is going backwards in the document.
         */
        isBackwards(): boolean,

        /**
         * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
         */
        getRange(): AceAjax$Range,

        /**
         * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Selects all the text in the document.
         */
        selectAll(): void,

        /**
         * Sets the selection to the provided range.
         * @param range The range of text to select
         * @param reverse Indicates if the range should go backwards (`true`) or not
         */
        setRange(range: AceAjax$Range, reverse: boolean): void,

        /**
         * Moves the selection cursor to the indicated row and column.
         * @param row The row to select to
         * @param column The column to select to
         */
        selectTo(row: number, column: number): void,

        /**
         * Moves the selection cursor to the row and column indicated by `pos`.
         * @param pos An object containing the row and column
         */
        selectToPosition(pos: any): void,

        /**
         * Moves the selection up one row.
         */
        selectUp(): void,

        /**
         * Moves the selection down one row.
         */
        selectDown(): void,

        /**
         * Moves the selection right one column.
         */
        selectRight(): void,

        /**
         * Moves the selection left one column.
         */
        selectLeft(): void,

        /**
         * Moves the selection to the beginning of the current line.
         */
        selectLineStart(): void,

        /**
         * Moves the selection to the end of the current line.
         */
        selectLineEnd(): void,

        /**
         * Moves the selection to the end of the file.
         */
        selectFileEnd(): void,

        /**
         * Moves the selection to the start of the file.
         */
        selectFileStart(): void,

        /**
         * Moves the selection to the first word on the right.
         */
        selectWordRight(): void,

        /**
         * Moves the selection to the first word on the left.
         */
        selectWordLeft(): void,

        /**
         * Moves the selection to highlight the entire word.
         */
        getWordRange(): void,

        /**
         * Selects an entire word boundary.
         */
        selectWord(): void,

        /**
         * Selects a word, including its right whitespace.
         */
        selectAWord(): void,

        /**
         * Selects the entire line.
         */
        selectLine(): void,

        /**
         * Moves the cursor up one row.
         */
        moveCursorUp(): void,

        /**
         * Moves the cursor down one row.
         */
        moveCursorDown(): void,

        /**
         * Moves the cursor left one column.
         */
        moveCursorLeft(): void,

        /**
         * Moves the cursor right one column.
         */
        moveCursorRight(): void,

        /**
         * Moves the cursor to the start of the line.
         */
        moveCursorLineStart(): void,

        /**
         * Moves the cursor to the end of the line.
         */
        moveCursorLineEnd(): void,

        /**
         * Moves the cursor to the end of the file.
         */
        moveCursorFileEnd(): void,

        /**
         * Moves the cursor to the start of the file.
         */
        moveCursorFileStart(): void,

        /**
         * Moves the cursor to the word on the right.
         */
        moveCursorLongWordRight(): void,

        /**
         * Moves the cursor to the word on the left.
         */
        moveCursorLongWordLeft(): void,

        /**
         * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
         * @param rows The number of rows to move by
         * @param chars The number of characters to move by
         */
        moveCursorBy(rows: number, chars: number): void,

        /**
         * Moves the selection to the position indicated by its `row` and `column`.
         * @param position The position to move to
         */
        moveCursorToPosition(position: any): void,

        /**
         * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
         */
        moveCursorTo(row: number, column: number, keepDesiredColumn?: boolean): void,

        /**
         * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn :preventUpdateBool}
         */
        moveCursorToScreen(row: number, column: number, keepDesiredColumn: boolean): void
}

declare var Selection: {

    /**
     * Creates a new `Selection` object.
     * @param session The session to use
     */
    new(session: AceAjax$IEditSession): AceAjax$Selection
};

declare export interface AceAjax$Split {

    /**
     * Returns the number of splits.
     */
    getSplits(): number,

        /**
         * Returns the editor identified by the index `idx`.
         * @param idx The index of the editor you want
         */
        getEditor(idx: number): void,

        /**
         * Returns the current editor.
         */
        getCurrentEditor(): AceAjax$Editor,

        /**
         * Focuses the current editor.
         */
        focus(): void,

        /**
         * Blurs the current editor.
         */
        blur(): void,

        /**
         * Sets a theme for each of the available editors.
         * @param theme The name of the theme to set
         */
        setTheme(theme: string): void,

        /**
         * Sets the keyboard handler for the editor.
         * @param keybinding 
         */
        setKeyboardHandler(keybinding: string): void,

        /**
         * Executes `callback` on all of the available editors.
         * @param callback A callback function to execute
         * @param scope The default scope for the callback
         */
        forEach(callback: Function, scope: string): void,

        /**
         * Sets the font size, in pixels, for all the available editors.
         * @param size The new font size
         */
        setFontSize(size: number): void,

        /**
         * Sets a new [[EditSession `EditSession`]] for the indicated editor.
         * @param session The new edit session
         * @param idx The editor's index you're interested in
         */
        setSession(session: AceAjax$IEditSession, idx: number): void,

        /**
         * Returns the orientation.
         */
        getOrientation(): number,

        /**
         * Sets the orientation.
         * @param orientation The new orientation value
         */
        setOrientation(orientation: number): void,

        /**
         * Resizes the editor.
         */
        resize(): void
}

declare var Split: {
    new(): AceAjax$Split
};


/**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 */
declare export interface AceAjax$TokenIterator {

    /**
     * Tokenizes all the items from the current point to the row prior in the document.
     */
    stepBackward(): string[],

        /**
         * Tokenizes all the items from the current point until the next row in the document. If the current point is at the end of the file, this function returns `null`. Otherwise, it returns the tokenized string.
         */
        stepForward(): string,

        /**
         * Returns the current tokenized string.
         */
        getCurrentToken(): AceAjax$TokenInfo,

        /**
         * Returns the current row.
         */
        getCurrentTokenRow(): number,

        /**
         * Returns the current column.
         */
        getCurrentTokenColumn(): number
}

declare var TokenIterator: {

    /**
     * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
     * @param session The session to associate with
     * @param initialRow The row to start the tokenizing at
     * @param initialColumn The column to start the tokenizing at
     */
    new(
        session: AceAjax$IEditSession,
        initialRow: number,
        initialColumn: number): AceAjax$TokenIterator
};


/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 */
declare export interface AceAjax$Tokenizer {

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     */
    getLineTokens(): any
}

declare var Tokenizer: {

    /**
     * Constructs a new tokenizer based on the given rules and flags.
     * @param rules The highlighting rules
     * @param flag Any additional regular expression flags to pass (like "i" for case insensitive)
     */
    new(rules: any, flag: string): AceAjax$Tokenizer
};


/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 */
declare export interface AceAjax$UndoManager {

    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     * - `args[0]` is an array of deltas
    - `args[1]` is the document to associate with
     * @param options Contains additional properties
    */
    execute(options: any): void,

        /**
         * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
         * @param dontSelect :dontSelect}
         */
        undo(dontSelect?: boolean): AceAjax$Range,

        /**
         * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
         * @param dontSelect :dontSelect}
         */
        redo(dontSelect: boolean): void,

        /**
         * Destroys the stack of undo and redo redo operations.
         */
        reset(): void,

        /**
         * Returns `true` if there are undo operations left to perform.
         */
        hasUndo(): boolean,

        /**
         * Returns `true` if there are redo operations left to perform.
         */
        hasRedo(): boolean,

        /**
         * Returns `true` if the dirty counter is 0
         */
        isClean(): boolean,

        /**
         * Sets dirty counter to 0
         */
        markClean(): void
}

declare var UndoManager: {

    /**
     * Resets the current undo state and creates a new `UndoManager`.
     */
    new(): AceAjax$UndoManager
};


/**
 * The class that is responsible for drawing everything you see on the screen!
 */
declare export interface AceAjax$VirtualRenderer {
    scroller: any,
        characterWidth: number,
        lineHeight: number,
        screenToTextCoordinates(left: number, top: number): void,

        /**
         * Associates the renderer with an [[EditSession `EditSession`]].
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Triggers a partial update of the text, from the range given by the two parameters.
         * @param firstRow The first row to update
         * @param lastRow The last row to update
         */
        updateLines(firstRow: number, lastRow: number): void,

        /**
         * Triggers a full update of the text, for all the rows.
         */
        updateText(): void,

        /**
         * Triggers a full update of all the layers, for all the rows.
         * @param force If `true`, forces the changes through
         */
        updateFull(force: boolean): void,

        /**
         * Updates the font size.
         */
        updateFontSize(): void,

        /**
         * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         * @param gutterWidth The width of the gutter in pixels
         * @param width The width of the editor in pixels
         * @param height The hiehgt of the editor, in pixels
         */
        onResize(force: boolean, gutterWidth: number, width: number, height: number): void,

        /**
         * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
         */
        adjustWrapLimit(): void,

        /**
         * Identifies whether you want to have an animated scroll or not.
         * @param shouldAnimate Set to `true` to show animated scrolls
         */
        setAnimatedScroll(shouldAnimate: boolean): void,

        /**
         * Returns whether an animated scroll happens or not.
         */
        getAnimatedScroll(): boolean,

        /**
         * Identifies whether you want to show invisible characters or not.
         * @param showInvisibles Set to `true` to show invisibles
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns whether invisible characters are being shown or not.
         */
        getShowInvisibles(): boolean,

        /**
         * Identifies whether you want to show the print margin or not.
         * @param showPrintMargin Set to `true` to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin is being shown or not.
         */
        getShowPrintMargin(): boolean,

        /**
         * Identifies whether you want to show the print margin column or not.
         * @param showPrintMargin Set to `true` to show the print margin column
         */
        setPrintMarginColumn(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin column is being shown or not.
         */
        getPrintMarginColumn(): boolean,

        /**
         * Returns `true` if the gutter is being shown.
         */
        getShowGutter(): boolean,

        /**
         * Identifies whether you want to show the gutter or not.
         * @param show Set to `true` to show the gutter
         */
        setShowGutter(show: boolean): void,

        /**
         * Returns the root element containing this renderer.
         */
        getContainerElement(): HTMLElement,

        /**
         * Returns the element that the mouse events are attached to
         */
        getMouseEventTarget(): HTMLElement,

        /**
         * Returns the element to which the hidden text area is added.
         */
        getTextAreaContainer(): HTMLElement,

        /**
         * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getFirstFullyVisibleRow(): number,

        /**
         * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getLastFullyVisibleRow(): number,

        /**
         * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Sets the padding for all the layers.
         * @param padding A new padding value (in pixels)
         */
        setPadding(padding: number): void,

        /**
         * Returns whether the horizontal scrollbar is set to be always visible.
         */
        getHScrollBarAlwaysVisible(): boolean,

        /**
         * Identifies whether you want to show the horizontal scrollbar or not.
         * @param alwaysVisible Set to `true` to make the horizontal scroll bar visible
         */
        setHScrollBarAlwaysVisible(alwaysVisible: boolean): void,

        /**
         * Schedules an update to all the front markers in the document.
         */
        updateFrontMarkers(): void,

        /**
         * Schedules an update to all the back markers in the document.
         */
        updateBackMarkers(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        addGutterDecoration(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        removeGutterDecoration(): void,

        /**
         * Redraw breakpoints.
         */
        updateBreakpoints(): void,

        /**
         * Sets annotations for the gutter.
         * @param annotations An array containing annotations
         */
        setAnnotations(annotations: any[]): void,

        /**
         * Updates the cursor icon.
         */
        updateCursor(): void,

        /**
         * Hides the cursor icon.
         */
        hideCursor(): void,

        /**
         * Shows the cursor icon.
         */
        showCursor(): void,

        /**
         * Scrolls the cursor into the first visibile area of the editor
         */
        scrollCursorIntoView(): void,

        /**
         * {:EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * {:EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the first visible row, regardless of whether it's fully visible or not.
         */
        getScrollTopRow(): number,

        /**
         * Returns the last visible row, regardless of whether it's fully visible or not.
         */
        getScrollBottomRow(): number,

        /**
         * Gracefully scrolls from the top of the editor to the row indicated.
         * @param row A row id
         */
        scrollToRow(row: number): void,

        /**
         * Gracefully scrolls the editor to the row indicated.
         * @param line A line number
         * @param center If `true`, centers the editor the to indicated line
         * @param animate If `true` animates scrolling
         * @param callback Function to be called after the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Scrolls the editor to the y pixel indicated.
         * @param scrollTop The position to scroll to
         */
        scrollToY(scrollTop: number): number,

        /**
         * Scrolls the editor across the x-axis to the pixel indicated.
         * @param scrollLeft The position to scroll to
         */
        scrollToX(scrollLeft: number): number,

        /**
         * Scrolls the editor across both x- and y-axes.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        scrollBy(deltaX: number, deltaY: number): void,

        /**
         * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        isScrollableBy(deltaX: number, deltaY: number): boolean,

        /**
         * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
         * @param row The document row position
         * @param column The document column position
         */
        textToScreenCoordinates(row: number, column: number): any,

        /**
         * Focuses the current container.
         */
        visualizeFocus(): void,

        /**
         * Blurs the current container.
         */
        visualizeBlur(): void,

        /**
         * undefined
         * @param position 
         */
        showComposition(position: number): void,

        /**
         * Sets the inner text of the current composition to `text`.
         * @param text A string of text to use
         */
        setCompositionText(text: string): void,

        /**
         * Hides the current composition.
         */
        hideComposition(): void,

        /**
         * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
         * @param style A class name
         */
        unsetStyle(style: string): void,

        /**
         * Destroys the text and cursor layers for this renderer.
         */
        destroy(): void
}

declare var VirtualRenderer: {

    /**
     * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
     * @param container The root element of the editor
     * @param theme The starting theme
     */
    new(container: HTMLElement, theme?: string): AceAjax$VirtualRenderer
};
declare var ace: AceAjax$Ace;
declare module 'acl' {
    declare type strings = string | string[];
    declare type Value = string | number;
    declare type Values = OData$Value | OData$Value[];
    declare type Action = () => any;
    declare type Callback = (err: AV$Error) => any;
    declare type AnyCallback = (err: AV$Error, obj: any) => any;
    declare type AllowedCallback = (err: AV$Error, allowed: boolean) => any;
    declare type GetUserId = (req: http.IncomingMessage, res: http.ServerResponse) => OData$Value;
    declare interface AclStatic {
        new(backend: Backend<any>, logger: Logger, options: Option): Acl,
        new(backend: Backend<any>, logger: Logger): Acl,
        new(backend: Backend<any>): Acl,
        memoryBackend: MemoryBackendStatic
    }
    declare interface Logger {
        debug: (msg: string) => any
    }
    declare interface Acl {
        addUserRoles: (userId: OData$Value, roles: strings, cb?: Callback) => AV$Promise<void>,
            removeUserRoles: (userId: OData$Value, roles: strings, cb?: Callback) => AV$Promise<void>,
            userRoles: (
                userId: OData$Value,
                cb?: (err: AV$Error, roles: string[]) => any) => AV$Promise<string[]>,
            roleUsers: (
                role: OData$Value,
                cb?: (err: AV$Error, users: Values) => any) => AV$Promise<any>,
            hasRole: (
                userId: OData$Value,
                role: string,
                cb?: (err: AV$Error, isInRole: boolean) => any) => AV$Promise<boolean>,
            addRoleParents: (role: string, parents: Values, cb?: Callback) => AV$Promise<void>,
            removeRole: (role: string, cb?: Callback) => AV$Promise<void>,
            removeResource: (resource: string, cb?: Callback) => AV$Promise<void>,
            allow: {
                (roles: Values, resources: strings, permissions: strings, cb?: Callback): AV$Promise<void>,
                (aclSets: AclSet | AclSet[]): AV$Promise<void >
            },
            removeAllow: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Callback) => AV$Promise<void>,
            removePermissions: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Function) => AV$Promise<void>,
            allowedPermissions: (userId: OData$Value, resources: strings, cb?: AnyCallback) => AV$Promise<void>,
            isAllowed: (
                userId: OData$Value,
                resources: strings,
                permissions: strings,
                cb?: AllowedCallback) => AV$Promise<boolean>,
            areAnyRolesAllowed: (
                roles: strings,
                resource: strings,
                permissions: strings,
                cb?: AllowedCallback) => AV$Promise<any>,
            whatResources: (roles: strings, permissions: strings, cb?: AnyCallback) => AV$Promise<any>,
            permittedResources: (roles: strings, permissions: strings, cb?: Function) => AV$Promise<void>,
            middleware: (
                numPathComponents: number,
                userId: OData$Value | GetUserId,
                actions: strings) => AV$Promise<any >
    }
    declare interface Option {
        buckets?: BucketsOption
    }
    declare interface BucketsOption {
        meta?: string,
            parents?: string,
            permissions?: string,
            resources?: string,
            roles?: string,
            users?: string
    }
    declare interface AclSet {
        roles: strings,
            allows: AclAllow[]
    }
    declare interface AclAllow {
        resources: strings,
            permissions: strings
    }
    declare type MemoryBackend = {} & Backend

    declare interface MemoryBackendStatic {
        new(): MemoryBackend
    }
    declare interface Backend<T>{
        begin: () => T,
        end: (transaction: T, cb?: AltJS$Action) => void,
        clean: (cb?: AltJS$Action) => void,
        get: (bucket: string, key: OData$Value, cb?: AltJS$Action) => void,
        union: (bucket: string, keys: OData$Value[], cb?: AltJS$Action) => void,
        add: (transaction: T, bucket: string, key: OData$Value, values: Values) => void,
        del: (transaction: T, bucket: string, keys: OData$Value[]) => void,
        remove: (transaction: T, bucket: string, key: OData$Value, values: Values) => void,
        endAsync: Function,
        getAsync: Function,
        cleanAsync: Function,
        unionAsync: Function
    }
    declare interface Contract {
        (args: IArguments): Contract | NoOp,
            debug: boolean,
            fulfilled: boolean,
            args: any[],
            checkedParams: string[],
            params: (...types: string[]) => Contract | NoOp,
            end: () => void
    }
    declare interface NoOp {
        params: (...types: string[]) => NoOp,
            end: () => void
    }
    declare type RedisBackend = {} & Backend

    declare interface RedisBackendStatic {
        new(redis: redis.RedisClient, prefix: string): RedisBackend,
        new(redis: redis.RedisClient): RedisBackend
    }
    declare type MongodbBackend = {} & Backend

    declare interface MongodbBackendStatic {
        new(db: mongo.Db, prefix: string, useSingle: boolean): MongodbBackend,
        new(db: mongo.Db, prefix: string): MongodbBackend,
        new(db: mongo.Db): MongodbBackend
    }
    declare     var _: AclStatic;
    declare module.exports: typeof _
}

declare var npm$namespace$acorn: {
    parse: typeof acorn$parse,
    parseExpressionAt: typeof acorn$parseExpressionAt,
    getLineInfo: typeof acorn$getLineInfo,
}
declare var version: string;

declare export function acorn$parse(pattern: any): NodeJS$ReadWriteStream

declare function acorn$parseExpressionAt(input: string, pos: number, options?: Collection$Options): ESTree.Expression

declare function acorn$getLineInfo(input: string, offset: number): ESTree.Position

declare var defaultOptions: Collection$Options;

declare interface acorn$TokenType {
    label: string,
        keyword: string,
        beforeExpr: boolean,
        startsExpr: boolean,
        isLoop: boolean,
        isAssign: boolean,
        prefix: boolean,
        postfix: boolean,
        binop: number,
        updateContext: (prevType: acorn$TokenType) => any
}

declare interface acorn$AbstractToken {
    start: number,
        end: number,
        loc: ESTree.SourceLocation,
        range: [number, number]
}

declare type acorn$Token = {
    type: acorn$TokenType,
    value: any
} & acorn$AbstractToken


declare type acorn$Comment = {
    type: string,
    value: string
} & acorn$AbstractToken


declare export interface acorn$Options {
    recurse: boolean
}
declare module 'acorn' {
    declare module.exports: typeof acorn
}
declare interface adal$Config {
    tenant?: string,
        clientId: string,
        redirectUri?: string,
        cacheLocation?: string,
        displayCall?: (urlNavigate: string) => any,
        correlationId?: string,
        loginResource?: string,
        resource?: string,
        endpoints?: any,
        extraQueryParameter?: string,
        postLogoutRedirectUri?: string
}

declare interface adal$User {
    userName: string,
        profile: any
}

declare export interface adal$RequestInfo {
    command: string,
        arguments: any
}

declare interface adal$Logging {
    log: (message: string) => void,
        level: LoggingLevel
}

declare interface adal$AuthenticationContextStatic {
    new(config: adal$Config): adal$AuthenticationContext
}

declare interface adal$AuthenticationContext {
    instance: string,
        config: adal$Config,

        /**
         * Gets initial Idtoken for the app backend
         * Saves the resulting Idtoken in localStorage.
         */
        login(): void,

        /**
         * Indicates whether login is in progress now or not.
         */
        loginInProgress(): boolean,

        /**
         * Gets token for the specified resource from local storage cache
         * @param  A URI that identifies the resource for which the token is valid.
         * @returns  token if exists and not expired or null
         */
        getCachedToken(resource: string): string,

        /**
         * Retrieves and parse idToken from localstorage
         * @returns  user object
         */
        getCachedUser(): adal$User,
        registerCallback(
            expectedState: string,
            resource: string,
            callback: (message: string, token: string) => any): void,

        /**
         * Acquire token from cache if not expired and available. Acquires token from iframe if expired.
         * @param  ResourceUri identifying the target resource
         * @param  
         */
        acquireToken(resource: string, callback: (message: string, token: string) => any): void,

        /**
         * Redirect the Browser to Azure AD Authorization endpoint
         * @param  The authorization request url
         */
        promptUser(urlNavigate: string): void,

        /**
         * Clear cache items.
         */
        clearCache(): void,

        /**
         * Clear cache items for a resource.
         */
        clearCacheForResource(resource: string): void,

        /**
         * Logout user will redirect page to logout endpoint.
         * After logout, it will redirect to post_logout page if provided.
         */
        logOut(): void,

        /**
         * Gets a user profile
         * @param  - The callback that handles the response.
         */
        getUser(callback: (message: string, user?: adal$User) => any): void,

        /**
         * Checks if hash contains access token or id token or error_description
         * @param  -  Hash passed from redirect page
         * @returns  
         */
        isCallback(hash: string): boolean,

        /**
         * Gets login error
         * @returns  error message related to login
         */
        getLoginError(): string,

        /**
         * Gets requestInfo from given hash.
         * @returns  for appropriate hash.
         */
        getRequestInfo(hash: string): adal$RequestInfo,

        /**
         * Saves token from hash that is received from redirect.
         */
        saveTokenFromHash(requestInfo: adal$RequestInfo): void,

        /**
         * Gets resource for given endpoint if mapping is provided with config.
         * @param  -  API endpoint
         * @returns  resource for this API endpoint
         */
        getResourceForEndpoint(endpoint: string): string,

        /**
         * Handles redirection after login operation. 
         * Gets access token from url and saves token to the (local/session) storage
        or saves error in case unsuccessful login.
        */
        handleWindowCallback(): void,
        log(level: number, message: string, error: any): void,
        error(message: string, error: any): void,
        warn(message: string): void,
        info(message: string): void,
        verbose(message: string): void
}
declare var AuthenticationContext: adal$AuthenticationContextStatic;
declare var Logging: adal$Logging;
declare module 'adal' {
    declare module.exports: typeof NO PRINT IMPLEMENTED: ObjectLiteralExpression
}
declare var addToHome: {

    /**
     * Shows the popup.
     * @param  Override all the compatibility checks and always show the popup.
     */
    show: (overrideChecks: boolean) => void,

    /**
     * Closes the popup. 
     */
    close: () => void,

    /**
     * Reset the local and session storages so the popup will show again (for automatic mode - has no affect if manually opening the popup). 
     */
    reset: () => void
};
declare module 'adm-zip' {
    declare module.exports: typeof AdmZip

    /**
     * The ZipEntry is more than a structure representing the entry inside the
     * zip file. Beside the normal attributes and headers a entry can have, the
    class contains a reference to the part of the file where the compressed
    data resides and decompresses it when requested. It also compresses the
    data and creates the headers required to write in the zip file.
    */
    declare interface AdmZip$IZipEntry {

        /**
         * Represents the full name and path of the file
         */
        entryName: string,
            rawEntryName: Buffer,

            /**
             * Extra data associated with this entry.
             */
            extra: Buffer,

            /**
             * Entry comment.
             */
            comment: string,
            name: string,

            /**
             * Read-Only property that indicates the type of the entry.
             */
            isDirectory: boolean,

            /**
             * Get the header associated with this ZipEntry.
             */
            header: Buffer,

            /**
             * Retrieve the compressed data for this entry. Note that this may trigger
             * compression if any properties were modified.
             */
            getCompressedData(): Buffer,

            /**
             * Asynchronously retrieve the compressed data for this entry. Note that
             * this may trigger compression if any properties were modified.
             */
            getCompressedDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: string): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: Buffer): void,

            /**
             * Get the decompressed data associated with this entry.
             */
            getData(): Buffer,

            /**
             * Asynchronously get the decompressed data associated with this entry.
             */
            getDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Returns the CEN Entry Header to be written to the output zip file, plus
             * the extra data and the entry comment.
             */
            packHeader(): Buffer,

            /**
             * Returns a nicely formatted string with the most important properties of
             * the ZipEntry.
             */
            toString(): string
    }
}
declare module 'grid' {
    declare class ColumnChangeEvent {
        constructor(type: string): this;
        toString(): string;
        withColumn(column: anydbSQL$Column): ColumnChangeEvent;
        withColumnGroup(columnGroup: ColumnGroup): ColumnChangeEvent;
        withFromIndex(fromIndex: number): ColumnChangeEvent;
        withPinnedColumnCount(pinnedColumnCount: number): ColumnChangeEvent;
        withToIndex(toIndex: number): ColumnChangeEvent;
        getFromIndex(): number;
        getToIndex(): number;
        getPinnedColumnCount(): number;
        getType(): string;
        getColumn(): anydbSQL$Column;
        getColumnGroup(): ColumnGroup;
        isPivotChanged(): boolean;
        isValueChanged(): boolean;
        isIndividualColumnResized(): boolean
    }
    declare class Utils {
        iterateObject(object: any, callback: (key: string, value: any) => void): void;
        cloneObject(object: any): any;
        map<TItem, TResult>(array: TItem[], callback: (item: TItem) => TResult): TResult[];
        forEach<T>(array: T[], callback: (item: T, index: number) => void): void;
        filter<T>(array: T[], callback: (item: T) => boolean): T[];
        assign(object: any, source: any): void;
        getFunctionParameters(func: any): any;
        find(collection: any, predicate: any, value: any): any;
        toStrings<T>(array: T[]): string[];
        iterateArray<T>(array: T[], callback: (item: T, index: number) => void): void;
        isNode(o: any): boolean;
        isElement(o: any): boolean;
        isNodeOrElement(o: any): boolean;
        addChangeListener(element: HTMLElement, listener: EventListener): void;
        makeNull(value: any): any;
        removeAllChildren(node: HTMLElement): void;
        removeElement(parent: HTMLElement, cssSelector: string): void;
        removeFromParent(node: angularScenario$Element): void;
        isVisible(element: HTMLElement): boolean;

        /**
         * loads the template and returns it as an element. makes up for no simple way in
         * the dom api to load html directly, eg we cannot do this: document.createElement(template)
         */
        loadTemplate(template: string): CSG$Node;
        querySelectorAll_addCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_removeCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_replaceCssClass(
            eParent: any,
            selector: string,
            cssClassToRemove: string,
            cssClassToAdd: string): void;
        addOrRemoveCssClass(element: HTMLElement, className: string, addOrRemove: boolean): void;
        addCssClass(element: HTMLElement, className: string): void;
        offsetHeight(element: HTMLElement): number;
        offsetWidth(element: HTMLElement): number;
        removeCssClass(element: HTMLElement, className: string): void;
        removeFromArray<T>(array: T[], object: T): void;
        defaultComparator(valueA: any, valueB: any): number;
        formatWidth(width: number | string): string;

        /**
         * Tries to use the provided renderer.
         */
        useRenderer<TParams>(
            eParent: angularScenario$Element,
            eRenderer: (params: TParams) => CSG$Node | string,
            params: TParams): void;

        /**
         * If icon provided, use this (either a string, or a function callback).
         * if not, then use the second parameter, which is the svgFactory function
         */
        createIcon(
            iconName: any,
            gridOptionsWrapper: any,
            colDefWrapper: any,
            svgFactoryFunc: () => CSG$Node): HTMLSpanElement;
        addStylesToElement(eElement: any, styles: any): void;
        getScrollbarWidth(): number;
        isKeyPressed(event: KeyboardEvent, keyToCheck: number): boolean;
        setVisible(element: HTMLElement, visible: boolean): void;
        isBrowserIE(): boolean;
        isBrowserSafari(): boolean
    }
    declare class Constants {
        STEP_EVERYTHING: number;
        STEP_FILTER: number;
        STEP_SORT: number;
        STEP_MAP: number;
        ASC: string;
        DESC: string;
        ROW_BUFFER_SIZE: number;
        MIN_COL_WIDTH: number;
        SUM: string;
        MIN: string;
        MAX: string;
        KEY_TAB: number;
        KEY_ENTER: number;
        KEY_BACKSPACE: number;
        KEY_DELETE: number;
        KEY_ESCAPE: number;
        KEY_SPACE: number;
        KEY_DOWN: number;
        KEY_UP: number;
        KEY_LEFT: number;
        KEY_RIGHT: number
    }
    declare class Column {
        colIdSequence: number;
        colDef: ColDef;
        actualWidth: any;
        visible: any;
        colId: any;
        pinned: boolean;
        index: number;
        aggFunc: string;
        pivotIndex: number;
        sort: string;
        sortedAt: number;
        constructor(colDef: ColDef, actualWidth: any): this;
        isGreaterThanMax(width: number): boolean;
        getMinimumWidth(): number;
        setMinimum(): void
    }
    declare class ColumnGroup {
        pinned: any;
        name: any;
        allColumns: anydbSQL$Column[];
        displayedColumns: anydbSQL$Column[];
        expandable: boolean;
        expanded: boolean;
        actualWidth: number;
        constructor(pinned: any, name: any): this;
        getMinimumWidth(): number;
        addColumn(column: any): void;
        calculateExpandable(): void;
        calculateActualWidth(): void;
        calculateDisplayedColumns(): void;
        addToVisibleColumns(colsToAdd: any): void
    }
    declare class GridOptionsWrapper {
        init(gridOptions: GridOptions, eventService: EventService): void;
        isRowSelection(): boolean;
        isRowDeselection(): boolean;
        isRowSelectionMulti(): boolean;
        getContext(): any;
        isVirtualPaging(): boolean;
        isShowToolPanel(): boolean;
        isToolPanelSuppressPivot(): boolean;
        isToolPanelSuppressValues(): boolean;
        isRowsAlreadyGrouped(): boolean;
        isGroupSelectsChildren(): boolean;
        isGroupHidePivotColumns(): boolean;
        isGroupIncludeFooter(): boolean;
        isGroupSuppressBlankHeader(): boolean;
        isSuppressRowClickSelection(): boolean;
        isSuppressCellSelection(): boolean;
        isSuppressMultiSort(): boolean;
        isGroupSuppressAutoColumn(): boolean;
        isForPrint(): boolean;
        isSuppressHorizontalScroll(): boolean;
        isUnSortIcon(): boolean;
        isSuppressMenuHide(): boolean;
        getRowStyle(): any;
        getRowClass(): any;
        getRowStyleFunc(): any;
        getRowClassFunc(): any;
        getHeaderCellRenderer(): any;
        getApi(): GridApi;
        isEnableColResize(): boolean;
        isSingleClickEdit(): boolean;
        getGroupDefaultExpanded(): any;
        getGroupKeys(): string[];
        getGroupAggFunction(): (nodes: any[]) => any;
        getGroupAggFields(): string[];
        getRowData(): any[];
        isGroupUseEntireRow(): boolean;
        getGroupColumnDef(): any;
        isGroupSuppressRow(): boolean;
        isAngularCompileRows(): boolean;
        isAngularCompileFilters(): boolean;
        isAngularCompileHeaders(): boolean;
        isDebug(): boolean;
        getColumnDefs(): any[];
        getDatasource(): any;
        getRowBuffer(): number;
        isEnableSorting(): boolean;
        isEnableCellExpressions(): boolean;
        isEnableServerSideSorting(): boolean;
        isEnableFilter(): boolean;
        isEnableServerSideFilter(): boolean;
        isSuppressScrollLag(): boolean;
        getIcons(): any;
        getIsScrollLag(): () => boolean;
        getSortingOrder(): string[];
        getSlaveGrids(): GridOptions[];
        getGroupRowRenderer(): AV$Object | Function;
        getRowHeight(): number;
        getHeaderHeight(): number;
        setHeaderHeight(headerHeight: number): void;
        isGroupHeaders(): boolean;
        setGroupHeaders(groupHeaders: boolean): void;
        getFloatingTopRowData(): any[];
        setFloatingTopRowData(rows: any[]): void;
        getFloatingBottomRowData(): any[];
        setFloatingBottomRowData(rows: any[]): void;
        isExternalFilterPresent(): boolean;
        doesExternalFilterPass(node: RowNode): boolean;
        getGroupRowInnerRenderer(): (params: any) => void;
        getColWidth(): number;
        getPinnedColCount(): number;
        getLocaleTextFunc(): Function;
        globalEventHandler(eventName: string, event?: any): void
    }
    declare class LoggerFactory {
        init(gridOptionsWrapper: GridOptionsWrapper): void;
        create(name: string): Logger
    }
    declare class Logger {
        constructor(name: string, logging: boolean): this;
        log(message: string): void
    }
    declare class Events {

        /**
         * A new set of columns has been entered, everything has potentially changed. 
         */
        EVENT_COLUMN_EVERYTHING_CHANGED: string;

        /**
         * A pivot column was added, removed or order changed. 
         */
        EVENT_COLUMN_PIVOT_CHANGE: string;

        /**
         * A value column was added, removed or agg function was changed. 
         */
        EVENT_COLUMN_VALUE_CHANGE: string;

        /**
         * A column was moved 
         */
        EVENT_COLUMN_MOVED: string;

        /**
         * One or more columns was shown / hidden 
         */
        EVENT_COLUMN_VISIBLE: string;

        /**
         * A column group was opened / closed 
         */
        EVENT_COLUMN_GROUP_OPENED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_RESIZED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_PINNED_COUNT_CHANGED: string;
        EVENT_MODEL_UPDATED: string;
        EVENT_CELL_CLICKED: string;
        EVENT_CELL_DOUBLE_CLICKED: string;
        EVENT_CELL_CONTEXT_MENU: string;
        EVENT_CELL_VALUE_CHANGED: string;
        EVENT_CELL_FOCUSED: string;
        EVENT_ROW_SELECTED: string;
        EVENT_SELECTION_CHANGED: string;
        EVENT_BEFORE_FILTER_CHANGED: string;
        EVENT_AFTER_FILTER_CHANGED: string;
        EVENT_FILTER_MODIFIED: string;
        EVENT_BEFORE_SORT_CHANGED: string;
        EVENT_AFTER_SORT_CHANGED: string;
        EVENT_VIRTUAL_ROW_REMOVED: string;
        EVENT_ROW_CLICKED: string;
        EVENT_READY: string
    }
    declare class EventService {
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        dispatchEvent(eventType: string, event?: any): void
    }
    declare class MasterSlaveService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            loggerFactory: LoggerFactory,
            eventService: EventService): void;
        fireHorizontalScrollEvent(horizontalScroll: number): void;
        onScrollEvent(horizontalScroll: number): void;
        onColumnEvent(event: ColumnChangeEvent): void
    }
    declare class ColumnApi {
        constructor(_columnController: ColumnController): this;
        sizeColumnsToFit(gridWidth: any): void;
        hideColumns(colIds: any, hide: any): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        getColumnGroup(name: string): ColumnGroup;
        getDisplayNameForCol(column: any): string;
        getColumn(key: any): anydbSQL$Column;
        setState(columnState: any): void;
        getState(): [any];
        isPinning(): boolean;
        getVisibleColAfter(col: anydbSQL$Column): anydbSQL$Column;
        getVisibleColBefore(col: anydbSQL$Column): anydbSQL$Column;
        setColumnVisible(column: anydbSQL$Column, visible: boolean): void;
        getAllColumns(): anydbSQL$Column[];
        getDisplayedColumns(): anydbSQL$Column[];
        getPivotedColumns(): anydbSQL$Column[];
        getValueColumns(): anydbSQL$Column[];
        moveColumn(fromIndex: number, toIndex: number): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        setColumnAggFunction(column: anydbSQL$Column, aggFunc: string): void;
        setColumnWidth(column: anydbSQL$Column, newWidth: number): void;
        removeValueColumn(column: anydbSQL$Column): void;
        addValueColumn(column: anydbSQL$Column): void;
        removePivotColumn(column: anydbSQL$Column): void;
        setPinnedColumnCount(count: number): void;
        addPivotColumn(column: anydbSQL$Column): void;
        getHeaderGroups(): ColumnGroup[];
        hideColumn(colId: any, hide: any): void
    }
    declare class ColumnController {
        constructor(): this;
        init(
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            valueService: ValueService,
            masterSlaveController: MasterSlaveService,
            eventService: EventService): void;
        getColumnApi(): ColumnApi;
        isSetupComplete(): boolean;
        getHeaderGroups(): ColumnGroup[];
        getPinnedContainerWidth(): number;
        addPivotColumn(column: anydbSQL$Column): void;
        setPinnedColumnCount(count: number): void;
        removePivotColumn(column: anydbSQL$Column): void;
        addValueColumn(column: anydbSQL$Column): void;
        removeValueColumn(column: anydbSQL$Column): void;
        setColumnWidth(column: anydbSQL$Column, newWidth: number): void;
        setColumnAggFunction(column: anydbSQL$Column, aggFunc: string): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        moveColumn(fromIndex: number, toIndex: number): void;
        getBodyContainerWidth(): number;
        getValueColumns(): anydbSQL$Column[];
        getPivotedColumns(): anydbSQL$Column[];
        getDisplayedColumns(): anydbSQL$Column[];
        getAllColumns(): anydbSQL$Column[];
        setColumnVisible(column: anydbSQL$Column, visible: boolean): void;
        getVisibleColBefore(col: any): anydbSQL$Column;
        getVisibleColAfter(col: anydbSQL$Column): anydbSQL$Column;
        isPinning(): boolean;
        getState(): [any];
        setState(columnState: any): void;
        getColumns(keys: any[]): anydbSQL$Column[];
        getColumn(key: any): anydbSQL$Column;
        getDisplayNameForCol(column: any): string;
        getColumnGroup(name: string): ColumnGroup;
        onColumnsChanged(): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        hideColumns(colIds: any, hide: any): void;
        sizeColumnsToFit(gridWidth: any): void
    }
    declare interface CsvExportParams {
        skipHeader?: boolean,
            skipFooters?: boolean,
            skipGroups?: boolean,
            fileName?: string
    }
    declare class CsvCreator {
        constructor(rowController: InMemoryRowController, columnController: ColumnController, grid: Grid, valueService: ValueService): this;
        exportDataAsCsv(params?: CsvExportParams): void;
        getDataAsCsv(params?: CsvExportParams): string
    }
    declare class ExpressionService {
        init(loggerFactory: LoggerFactory): void;
        evaluate(expression: string, params: any): any
    }
    declare interface TextAndNumberFilterParameters {

        /**
         * What to do when new rows are loaded. The default is to reset the filter, to keep it in line with 'set' filters. If you want to keep the selection, then set this value to 'keep'. 
         */
        newRowsAction?: string
    }
    declare class TextFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare class NumberFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare interface ColDef {

        /**
         * If sorting by default, set it here. Set to 'asc' or 'desc' 
         */
        sort?: string,

            /**
             * If sorting more than one column by default, the milliseconds when this column was sorted, so we know what order to sort the columns in. 
             */
            sortedAt?: number,

            /**
             * The sort order, provide an array with any of the following in any order ['asc','desc',null] 
             */
            sortingOrder?: string[],

            /**
             * The name to render in the column header 
             */
            headerName: string,

            /**
             * The field of the row to get the cells data from 
             */
            field: string,

            /**
             * Expression or function to get the cells value. 
             */
            headerValueGetter?: string | Function,

            /**
             * The unique ID to give the column. This is optional. If missing, the ID will default to the field. If both field and colId are missing, a unique ID will be generated.
             * This ID is used to identify the column in the API for sorting, filtering etc. 
             */
            colId?: string,

            /**
             * Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,
             * however we want all default values to be false and we want columns to be visible by default. 
             */
            hide?: boolean,

            /**
             * Tooltip for the column header 
             */
            headerTooltip?: string,

            /**
             * Expression or function to get the cells value. 
             */
            valueGetter?: string | Function,

            /**
             * To provide custom rendering to the header. 
             */
            headerCellRenderer?: Function | AV$Object,

            /**
             * CSS class for the header 
             */
            headerClass?: string | string[] | ((params: any) => string | string[]),

            /**
             * Initial width, in pixels, of the cell 
             */
            width?: number,

            /**
             * Min width, in pixels, of the cell 
             */
            minWidth?: number,

            /**
             * Max width, in pixels, of the cell 
             */
            maxWidth?: number,

            /**
             * Class to use for the cell. Can be string, array of strings, or function. 
             */
            cellClass?: string | string[] | ((cellClassParams: any) => string | string[]),

            /**
             * An object of css values. Or a function returning an object of css values. 
             */
            cellStyle?: {} | ((params: any) => {}),

            /**
             * A function for rendering a cell. 
             */
            cellRenderer?: Function | {},

            /**
             * A function for rendering a floating cell. 
             */
            floatingCellRenderer?: Function | {},

            /**
             * Name of function to use for aggregation. One of [sum,min,max]. 
             */
            aggFunc?: string,

            /**
             * Comparator function for custom sorting. 
             */
            comparator?: Function,

            /**
             * Set to true to render a selection checkbox in the column. 
             */
            checkboxSelection?: boolean,

            /**
             * Set to true if no menu should be shown for this column header. 
             */
            suppressMenu?: boolean,

            /**
             * Set to true if no sorting should be done for this column. 
             */
            suppressSorting?: boolean,

            /**
             * Set to true if you want the unsorted icon to be shown when no sort is applied to this column. 
             */
            unSortIcon?: boolean,

            /**
             * Set to true if you want this columns width to be fixed during 'size to fit' operation. 
             */
            suppressSizeToFit?: boolean,

            /**
             * Set to true if you do not want this column to be resizable by dragging it's edge. 
             */
            suppressResize?: boolean,

            /**
             * If grouping columns, the group this column belongs to. 
             */
            headerGroup?: string,

            /**
             * Whether to show the column when the group is open / closed. 
             */
            headerGroupShow?: string,

            /**
             * Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable. 
             */
            editable?: boolean | (Function),

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            newValueHandler?: Function,

            /**
             * If true, this cell gets refreshed when api.softRefreshView() gets called. 
             */
            volatile?: boolean,

            /**
             * Cell template to use for cell. Useful for AngularJS cells. 
             */
            template?: string,

            /**
             * Cell template URL to load template from to use for cell. Useful for AngularJS cells. 
             */
            templateUrl?: string,

            /**
             * one of the built in filter names: [set, number, text], or a filter function
             */
            filter?: string | Function,

            /**
             * The filter params are specific to each filter! 
             */
            filterParams?: SetFilterParameters | TextAndNumberFilterParameters,

            /**
             * Rules for applying css classes 
             */
            cellClassRules?: {
                [cssClassName: string]: (Function | string)
            },

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            onCellValueChanged?: Function,

            /**
             * Function callback, gets called when a cell is clicked. 
             */
            onCellClicked?: Function,

            /**
             * Function callback, gets called when a cell is double clicked. 
             */
            onCellDoubleClicked?: Function,

            /**
             * Function callback, gets called when a cell is right clicked. 
             */
            onCellContextMenu?: Function
    }
    declare class SetFilterModel {
        constructor(colDef: ColDef, rowModel: any, valueGetter: any, doesRowPassOtherFilters: any): this;
        refreshAfterNewRowsLoaded(keepSelection: any, isSelectAll: boolean): void;
        refreshAfterAnyFilterChanged(): void;
        setMiniFilter(newMiniFilter: any): boolean;
        getMiniFilter(): any;
        getDisplayedValueCount(): any;
        getDisplayedValue(index: any): any;
        selectEverything(): void;
        isFilterActive(): boolean;
        selectNothing(): void;
        getUniqueValueCount(): any;
        getUniqueValue(index: any): any;
        unselectValue(value: any): void;
        selectValue(value: any): void;
        isValueSelected(value: any): boolean;
        isEverythingSelected(): boolean;
        isNothingSelected(): boolean;
        getModel(): any;
        setModel(model: any, isSelectAll: boolean): void
    }
    declare interface SetFilterParameters {

        /**
         * Same as cell renderer for grid (you can use the same one in both locations). Setting it separatly here allows for the value to be rendered differently in the filter. 
         */
        cellRenderer?: Function,

            /**
             * The height of the cell. 
             */
            cellHeight?: number,

            /**
             * The values to display in the filter. 
             */
            values?: any,

            /**
             * What to do when new rows are loaded. The default is to reset the filter, as the set of values to select from can have changed. If you want to keep the selection, then set this value to 'keep'. 
             */
            newRowsAction?: string,

            /**
             * If true, the filter will not remove items that are no longer availabe due to other filters. 
             */
            suppressRemoveEntries?: boolean
    }
    declare class SetFilter mixins Filter {
        init(params: any): void;
        afterGuiAttached(): void;
        isFilterActive(): boolean;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        onNewRowsLoaded(): void;
        onAnyFilterChanged(): void;
        getApi(): any
    }
    declare class PopupService {
        init(ePopupParent: any): void;
        positionPopup(eventSource: any, ePopup: any, minWidth: any): void;
        addAsModalPopup(eChild: any, closeOnEsc: boolean): (event: any) => void
    }
    declare interface RowNode {

        /**
         * Unique ID for the node. Can be though of as the index of the row in the original list,
         * however exceptions apply so don't depend on uniqueness. 
         */
        id?: number,

            /**
             * The user provided data 
             */
            data?: any,

            /**
             * The parent node to this node, or empty if top level 
             */
            parent?: RowNode,

            /**
             * How many levels this node is from the top 
             */
            level?: number,

            /**
             * True if this node is a group node (ie has children) 
             */
            group?: boolean,

            /**
             * True if this is the first child in this group 
             */
            firstChild?: boolean,

            /**
             * True if this is the last child in this group 
             */
            lastChild?: boolean,

            /**
             * The index of this node in the group 
             */
            childIndex?: number,

            /**
             * True if this row is a floating row 
             */
            floating?: boolean,

            /**
             * True if this row is a floating top row 
             */
            floatingTop?: boolean,

            /**
             * True if this row is a floating bottom row 
             */
            floatingBottom?: boolean,

            /**
             * If using quick filter, stores a string representation of the row for searching against 
             */
            quickFilterAggregateText?: string,

            /**
             * Groups only - True if row is a footer. Footers  have group = true and footer = true 
             */
            footer?: boolean,

            /**
             * Groups only - Children of this group 
             */
            children?: RowNode[],

            /**
             * Groups only - The field we are pivoting on eg Country
             */
            field?: string,

            /**
             * Groups only - The key for the pivot eg Ireland, UK, USA 
             */
            key?: any,

            /**
             * Groups only - Filtered children of this group 
             */
            childrenAfterFilter?: RowNode[],

            /**
             * Groups only - Sorted children of this group 
             */
            childrenAfterSort?: RowNode[],

            /**
             * Groups only - Number of children and grand children 
             */
            allChildrenCount?: number,

            /**
             * Groups only - True if group is expanded, otherwise false 
             */
            expanded?: boolean,

            /**
             * Groups only - If doing footers, reference to the footer node for this group 
             */
            sibling?: RowNode,

            /**
             * Not to be used, internal temporary map used by the grid when creating groups 
             */
            _childrenMap?: {}
    }
    declare class FilterManager {
        init(
            grid: Grid,
            gridOptionsWrapper: GridOptionsWrapper,
            $compile: any,
            $scope: any,
            columnController: ColumnController,
            popupService: PopupService,
            valueService: ValueService): void;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        setRowModel(rowModel: any): void;
        isAdvancedFilterPresent(): boolean;
        isAnyFilterPresent(): boolean;
        isFilterPresentForCol(colId: any): any;
        setQuickFilter(newFilter: any): boolean;
        onFilterChanged(): void;
        isQuickFilterPresent(): boolean;
        doesRowPassOtherFilters(filterToSkip: any, node: any): boolean;
        doesRowPassFilter(node: any, filterToSkip?: any): boolean;
        refreshDisplayedValues(): void;
        onNewRowsLoaded(): void;
        getFilterApi(column: anydbSQL$Column): any;
        showFilter(column: anydbSQL$Column, eventSource: any): void
    }
    declare class TemplateService {
        templateCache: any;
        waitingCallbacks: any;
        $scope: any;
        init($scope: any): void;
        getTemplate(url: any, callback: any): any;
        handleHttpResult(httpResult: any, url: any): void
    }
    declare class SelectionRendererFactory {
        init(angularGrid: any, selectionController: any): void;
        createSelectionCheckbox(node: any, rowIndex: any): HTMLInputElement
    }
    declare class RenderedCell {
        constructor(isFirstColumn: any, column: any, $compile: any, rowRenderer: RowRenderer, gridOptionsWrapper: GridOptionsWrapper, expressionService: ExpressionService, selectionRendererFactory: SelectionRendererFactory, selectionController: SelectionController, templateService: TemplateService, cellRendererMap: {
            [key: string]: any
        }, node: any, rowIndex: number, scope: any, columnController: ColumnController, valueService: ValueService, eventService: EventService): this;
        getColumn(): anydbSQL$Column;
        getVGridCell(): undefined.VHtmlElement;
        startEditing(key?: number): void;
        focusCell(forceBrowserFocus: boolean): void;
        createParams(): any;
        createEvent(event: any, eventSource: any): any;
        isCellEditable(): any;
        createSelectionCheckbox(): void;
        setSelected(state: boolean): void;
        isVolatile(): boolean;
        refreshCell(): void
    }
    declare class RenderedRow {
        vPinnedRow: any;
        vBodyRow: any;
        constructor(gridOptionsWrapper: GridOptionsWrapper, valueService: ValueService, parentScope: any, angularGrid: Grid, columnController: ColumnController, expressionService: ExpressionService, cellRendererMap: {
            [key: string]: any
        }, selectionRendererFactory: SelectionRendererFactory, $compile: any, templateService: TemplateService, selectionController: SelectionController, rowRenderer: RowRenderer, eBodyContainer: HTMLElement, ePinnedContainer: HTMLElement, node: any, rowIndex: number, eventService: EventService): this;
        onRowSelected(selected: boolean): void;
        softRefresh(): void;
        getRenderedCellForColumn(column: anydbSQL$Column): RenderedCell;
        getCellForCol(column: anydbSQL$Column): any;
        destroy(): void;
        isDataInList(rows: any[]): boolean;
        isNodeInList(nodes: RowNode[]): boolean;
        isGroup(): boolean;
        setMainRowWidth(width: number): void;
        getRowNode(): any;
        getRowIndex(): any;
        refreshCells(colIds: string[]): void
    }
    declare class SvgFactory {
        theInstance: SvgFactory;
        getInstance(): SvgFactory;
        createFilterSvg(): angularScenario$Element;
        createColumnShowingSvg(): angularScenario$Element;
        createColumnHiddenSvg(): angularScenario$Element;
        createMenuSvg(): angularScenario$Element;
        createArrowUpSvg(): angularScenario$Element;
        createArrowLeftSvg(): angularScenario$Element;
        createArrowDownSvg(): angularScenario$Element;
        createArrowRightSvg(): angularScenario$Element;
        createSmallArrowDownSvg(): angularScenario$Element;
        createArrowUpDownSvg(): angularScenario$Element
    }
    declare     function groupCellRendererFactory(
        gridOptionsWrapper: GridOptionsWrapper,
        selectionRendererFactory: SelectionRendererFactory,
        expressionService: ExpressionService): (params: any) => HTMLSpanElement
    declare class RowRenderer {
        init(
            columnModel: any,
            gridOptionsWrapper: GridOptionsWrapper,
            gridPanel: GridPanel,
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            $compile: any,
            $scope: any,
            selectionController: SelectionController,
            expressionService: ExpressionService,
            templateService: TemplateService,
            valueService: ValueService,
            eventService: EventService): void;
        setRowModel(rowModel: any): void;
        onIndividualColumnResized(column: anydbSQL$Column): void;
        setMainRowWidths(): void;
        refreshAllFloatingRows(): void;
        refreshView(refreshFromIndex?: any): void;
        softRefreshView(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshGroupRows(): void;
        drawVirtualRows(): void;
        getFirstVirtualRenderedRow(): number;
        getLastVirtualRenderedRow(): number;
        getRenderedNodes(): any[];
        getIndexOfRenderedNode(node: any): number;
        navigateToNextCell(key: any, rowIndex: number, column: anydbSQL$Column): void;
        onRowSelected(rowIndex: number, selected: boolean): void;
        focusCell(
            eCell: any,
            rowIndex: number,
            colIndex: number,
            colDef: ColDef,
            forceBrowserFocus: any): void;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        startEditingNextCell(rowIndex: any, column: any, shiftKey: any): void
    }
    declare class SelectionController {
        init(
            angularGrid: Grid,
            gridPanel: GridPanel,
            gridOptionsWrapper: GridOptionsWrapper,
            $scope: any,
            rowRenderer: RowRenderer,
            eventService: EventService): void;
        getSelectedNodesById(): any;
        getSelectedRows(): any;
        getSelectedNodes(): any;
        getBestCostNodeSelection(): any;
        setRowModel(rowModel: any): void;
        deselectAll(): void;
        selectAll(): void;
        selectNode(node: any, tryMulti: any, suppressEvents?: any): void;
        deselectIndex(rowIndex: any): void;
        deselectNode(node: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents?: any): void;
        isNodeSelected(node: any): boolean
    }
    declare class RenderedHeaderElement {
        constructor(eRoot: HTMLElement): this;
        getERoot(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: anydbSQL$Column): void;
        addDragHandler(eDraggableElement: any): void;
        stopDragging(listenersToRemove: any): void
    }
    declare class RenderedHeaderCell mixins RenderedHeaderElement {
        constructor(column: anydbSQL$Column, parentGroup: RenderedHeaderGroupCell, gridOptionsWrapper: GridOptionsWrapper, parentScope: any, filterManager: FilterManager, columnController: ColumnController, $compile: any, angularGrid: Grid, eRoot: HTMLElement): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: anydbSQL$Column): void
    }
    declare class RenderedHeaderGroupCell mixins RenderedHeaderElement {
        constructor(columnGroup: ColumnGroup, gridOptionsWrapper: GridOptionsWrapper, columnController: ColumnController, eRoot: HTMLElement, angularGrid: Grid, parentScope: any, filterManager: FilterManager, $compile: any): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onIndividualColumnResized(column: anydbSQL$Column): void;
        onDragStart(): void;
        onDragging(dragChange: any): void
    }
    declare class HeaderRenderer {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            angularGrid: Grid,
            filterManager: FilterManager,
            $scope: any,
            $compile: any): void;
        refreshHeader(): void;
        updateSortIcons(): void;
        updateFilterIcons(): void;
        onIndividualColumnResized(column: anydbSQL$Column): void
    }
    declare class GroupCreator {
        init(valueService: ValueService): void;
        group(
            rowNodes: RowNode[],
            groupedCols: anydbSQL$Column[],
            expandByDefault: any): RowNode[];
        isExpanded(expandByDefault: any, level: any): boolean
    }
    declare class InMemoryRowController {
        constructor(): this;
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            angularGrid: any,
            filterManager: FilterManager,
            $scope: any,
            groupCreator: GroupCreator,
            valueService: ValueService,
            eventService: EventService): void;
        getModel(): any;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        updateModel(step: any): void;
        doAggregate(): void;
        expandOrCollapseAll(expand: boolean, rowNodes: RowNode[]): void;
        onPivotChanged(): void;
        setAllRows(rows: RowNode[], firstId?: number): void
    }
    declare class VirtualPageRowController {
        rowRenderer: any;
        datasourceVersion: any;
        gridOptionsWrapper: any;
        angularGrid: any;
        datasource: any;
        virtualRowCount: any;
        foundMaxRow: any;
        pageCache: any;
        pageCacheSize: any;
        pageLoadsInProgress: any;
        pageLoadsQueued: any;
        pageAccessTimes: any;
        accessTime: any;
        maxConcurrentDatasourceRequests: any;
        maxPagesInCache: any;
        pageSize: any;
        overflowSize: any;
        init(rowRenderer: any, gridOptionsWrapper: any, angularGrid: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        createNodesFromRows(pageNumber: any, rows: any): any;
        removeFromLoading(pageNumber: any): void;
        pageLoadFailed(pageNumber: any): void;
        pageLoaded(pageNumber: any, rows: any, lastRow: any): void;
        putPageIntoCacheAndPurge(pageNumber: any, rows: any): void;
        checkMaxRowAndInformRowRenderer(pageNumber: any, lastRow: any): void;
        isPageAlreadyLoading(pageNumber: any): boolean;
        doLoadOrQueue(pageNumber: any): void;
        addToQueueAndPurgeQueue(pageNumber: any): void;
        findLeastRecentlyAccessedPage(pageIndexes: any): number;
        checkQueueForNextLoad(): void;
        loadPage(pageNumber: any): void;
        requestIsDaemon(datasourceVersionCopy: any): boolean;
        getVirtualRow(rowIndex: any): any;
        forEachNode(callback: any): void;
        getModel(): {
            getVirtualRow: (index: any) => any,
            getVirtualRowCount: () => any,
            forEachInMemory: (callback: any) => void,
            forEachNode: (callback: any) => void,
            forEachNodeAfterFilter: (callback: any) => void,
            forEachNodeAfterFilterAndSort: (callback: any) => void
        }
    }
    declare class PaginationController {
        eGui: any;
        btNext: any;
        btPrevious: any;
        btFirst: any;
        btLast: any;
        lbCurrent: any;
        lbTotal: any;
        lbRecordCount: any;
        lbFirstRowOnPage: any;
        lbLastRowOnPage: any;
        ePageRowSummaryPanel: any;
        angularGrid: any;
        callVersion: any;
        gridOptionsWrapper: any;
        datasource: any;
        pageSize: any;
        rowCount: any;
        foundMaxRow: any;
        totalPages: any;
        currentPage: any;
        init(angularGrid: any, gridOptionsWrapper: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        setTotalLabels(): void;
        calculateTotalPages(): void;
        pageLoaded(rows: any, lastRowIndex: any): void;
        updateRowLabels(): void;
        loadPage(): void;
        isCallDaemon(versionCopy: any): boolean;
        onBtNext(): void;
        onBtPrevious(): void;
        onBtFirst(): void;
        onBtLast(): void;
        isZeroPagesToDisplay(): boolean;
        enableOrDisableButtons(): void;
        createTemplate(): string;
        getGui(): any;
        setupComponents(): void
    }
    declare class BorderLayout {
        constructor(params: any): this;
        addSizeChangeListener(listener: Function): void;
        fireSizeChanged(): void;
        getGui(): any;
        doLayout(): boolean;
        getCentreHeight(): number;
        setEastVisible(visible: any): void;
        setOverlayVisible(visible: any): void;
        setSouthVisible(visible: any): void
    }
    declare class GridPanel {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnModel: ColumnController,
            rowRenderer: RowRenderer,
            masterSlaveService: MasterSlaveService): void;
        getLayout(): BorderLayout;
        getPinnedFloatingTop(): HTMLElement;
        getFloatingTopContainer(): HTMLElement;
        getPinnedFloatingBottom(): HTMLElement;
        getFloatingBottomContainer(): HTMLElement;
        ensureIndexVisible(index: any): void;
        ensureColIndexVisible(index: any): void;
        showLoading(loading: any): void;
        getWidthForSizeColsToFit(): number;
        setRowModel(rowModel: any): void;
        getBodyContainer(): HTMLElement;
        getBodyViewport(): HTMLElement;
        getPinnedColsContainer(): HTMLElement;
        getHeaderContainer(): HTMLElement;
        getRoot(): HTMLElement;
        getPinnedHeader(): HTMLElement;
        getRowsParent(): HTMLElement[];
        setBodyContainerWidth(): void;
        setPinnedColContainerWidth(): void;
        showPinnedColContainersIfNeeded(): void;
        onBodyHeightChange(): void;
        setHorizontalScrollPosition(hScrollPosition: number): void
    }
    declare class DragAndDropService {
        theInstance: DragAndDropService;
        getInstance(): DragAndDropService;
        dragItem: any;
        constructor(): this;
        stopDragging(): void;
        setDragCssClasses(eListItem: any, dragging: any): void;
        addDragSource(eDragSource: any, dragSourceCallback: any): void;
        onMouseDownDragSource(eDragSource: any, dragSourceCallback: any): void;
        addDropTarget(eDropTarget: any, dropTargetCallback: any): void
    }
    declare class AgList {
        constructor(): this;
        setReadOnly(readOnly: boolean): void;
        setEmptyMessage(emptyMessage: any): void;
        getUniqueId(): any;
        addStyles(styles: any): void;
        addCssClass(cssClass: any): void;
        addDragSource(dragSource: any): void;
        addModelChangedListener(listener: Function): void;
        addItemSelectedListener(listener: any): void;
        addItemMovedListener(listener: any): void;
        addBeforeDropListener(listener: any): void;
        setModel(model: any): void;
        getModel(): any;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        getGui(): any
    }
    declare class ColumnSelectionPanel {
        layout: any;
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        getDragSource(): any;
        getGui(): any
    }
    declare class GroupSelectionPanel {
        gridOptionsWrapper: any;
        columnController: ColumnController;
        inMemoryRowController: any;
        cColumnList: any;
        layout: any;
        constructor(columnController: ColumnController, inMemoryRowController: any, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        addDragSource(dragSource: any): void
    }
    declare class AgDropdownList {
        constructor(popupService: PopupService): this;
        setWidth(width: any): void;
        addItemSelectedListener(listener: any): void;
        fireItemSelected(item: any): void;
        setupComponents(): void;
        itemSelected(item: any): void;
        onClick(): void;
        getGui(): any;
        setSelected(item: any): void;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        setModel(model: any): void
    }
    declare class ValuesSelectionPanel {
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, popupService: PopupService, eventService: EventService): this;
        getLayout(): any;
        addDragSource(dragSource: any): void
    }
    declare class VerticalStack {
        isLayoutPanel: any;
        childPanels: any;
        eGui: any;
        constructor(): this;
        addPanel(panel: any, height: any): void;
        getGui(): any;
        doLayout(): void
    }
    declare class ToolPanel {
        layout: any;
        constructor(): this;
        init(
            columnController: any,
            inMemoryRowController: any,
            gridOptionsWrapper: GridOptionsWrapper,
            popupService: PopupService,
            eventService: EventService): void
    }
    declare interface GridOptions {
        virtualPaging?: boolean,
            toolPanelSuppressPivot?: boolean,
            toolPanelSuppressValues?: boolean,
            rowsAlreadyGrouped?: boolean,
            suppressRowClickSelection?: boolean,
            suppressCellSelection?: boolean,
            sortingOrder?: string[],
            suppressMultiSort?: boolean,
            suppressHorizontalScroll?: boolean,
            unSortIcon?: boolean,
            rowHeight?: number,
            rowBuffer?: number,
            enableColResize?: boolean,
            enableCellExpressions?: boolean,
            enableSorting?: boolean,
            enableServerSideSorting?: boolean,
            enableFilter?: boolean,
            enableServerSideFilter?: boolean,
            colWidth?: number,
            suppressMenuHide?: boolean,
            singleClickEdit?: boolean,
            debug?: boolean,
            icons?: any,
            angularCompileRows?: boolean,
            angularCompileFilters?: boolean,
            angularCompileHeaders?: boolean,
            localeText?: any,
            localeTextFunc?: Function,
            suppressScrollLag?: boolean,
            groupSuppressAutoColumn?: boolean,
            groupSelectsChildren?: boolean,
            groupHidePivotColumns?: boolean,
            groupIncludeFooter?: boolean,
            groupUseEntireRow?: boolean,
            groupSuppressRow?: boolean,
            groupSuppressBlankHeader?: boolean,
            forPrint?: boolean,
            groupColumnDef?: any,
            context?: any,
            rowStyle?: any,
            rowClass?: any,
            groupDefaultExpanded?: any,
            slaveGrids?: GridOptions[],
            rowSelection?: string,
            rowDeselection?: boolean,
            rowData?: any[],
            floatingTopRowData?: any[],
            floatingBottomRowData?: any[],
            showToolPanel?: boolean,
            groupKeys?: string[],
            groupAggFields?: string[],
            columnDefs?: any[],
            datasource?: any,
            pinnedColumnCount?: number,
            groupHeaders?: boolean,
            headerHeight?: number,
            groupRowInnerRenderer(params: any): void,
            groupRowRenderer?: Function | AV$Object,
            isScrollLag(): boolean,
            isExternalFilterPresent(): boolean,
            doesExternalFilterPass(node: RowNode): boolean,
            getRowStyle?: any,
            getRowClass?: any,
            headerCellRenderer?: any,
            groupAggFunction(nodes: any[]): any,
            onReady(api: any): void,
            onModelUpdated(): void,
            onCellClicked(params: any): void,
            onCellDoubleClicked(params: any): void,
            onCellContextMenu(params: any): void,
            onCellValueChanged(params: any): void,
            onCellFocused(params: any): void,
            onRowSelected(params: any): void,
            onSelectionChanged(): void,
            onBeforeFilterChanged(): void,
            onAfterFilterChanged(): void,
            onFilterModified(): void,
            onBeforeSortChanged(): void,
            onAfterSortChanged(): void,
            onVirtualRowRemoved(params: any): void,
            onRowClicked(params: any): void,
            api?: GridApi,
            columnApi?: ColumnApi
    }
    declare class GridApi {
        constructor(grid: Grid, rowRenderer: RowRenderer, headerRenderer: HeaderRenderer, filterManager: FilterManager, columnController: ColumnController, inMemoryRowController: InMemoryRowController, selectionController: SelectionController, gridOptionsWrapper: GridOptionsWrapper, gridPanel: GridPanel, valueService: ValueService, masterSlaveService: MasterSlaveService, eventService: EventService): this;

        /**
         * Used internally by grid. Not intended to be used by the client. Interface may change between releases. 
         */
        ___getMasterSlaveService(): MasterSlaveService;
        getDataAsCsv(params?: CsvExportParams): string;
        exportDataAsCsv(params?: CsvExportParams): void;
        setDatasource(datasource: any): void;
        onNewDatasource(): void;
        setRowData(rowData: any): void;
        setRows(rows: any): void;
        onNewRows(): void;
        setFloatingTopRowData(rows: any[]): void;
        setFloatingBottomRowData(rows: any[]): void;
        onNewCols(): void;
        setColumnDefs(colDefs: ColDef[]): void;
        unselectAll(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshView(): void;
        softRefreshView(): void;
        refreshGroupRows(): void;
        refreshHeader(): void;
        isAnyFilterPresent(): boolean;
        isAdvancedFilterPresent(): boolean;
        isQuickFilterPresent(): boolean;
        getModel(): any;
        onGroupExpandedOrCollapsed(refreshFromIndex: any): void;
        expandAll(): void;
        collapseAll(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        setQuickFilter(newFilter: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents: any): void;
        deselectIndex(index: any): void;
        selectNode(node: any, tryMulti: any, suppressEvents: any): void;
        deselectNode(node: any): void;
        selectAll(): void;
        deselectAll(): void;
        recomputeAggregates(): void;
        sizeColumnsToFit(): void;
        showLoading(show: any): void;
        isNodeSelected(node: any): boolean;
        getSelectedNodesById(): {
            [nodeId: number]: RowNode
        };
        getSelectedNodes(): RowNode[];
        getSelectedRows(): any[];
        getBestCostNodeSelection(): any;
        getRenderedNodes(): any[];
        ensureColIndexVisible(index: any): void;
        ensureIndexVisible(index: any): void;
        ensureNodeVisible(comparator: any): void;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        getFilterApiForColDef(colDef: any): any;
        getFilterApi(key: any): any;
        getColumnDef(key: any): ColDef;
        onFilterChanged(): void;
        setSortModel(sortModel: any): void;
        getSortModel(): any;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        setHeaderHeight(headerHeight: number): void;
        setGroupHeaders(groupHeaders: boolean): void;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        hideColumn(colId: any, hide: any): void;
        hideColumns(colIds: any, hide: any): void;
        getColumnState(): [any];
        setColumnState(state: any): void;
        doLayout(): void;
        getValue(colDef: ColDef, data: any, node: any): any;
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        refreshPivot(): void
    }
    declare class ValueService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            columnController: ColumnController): void;
        getValue(colDef: ColDef, data: any, node: any): any
    }
    declare class Grid {
        constructor(eGridDiv: any, gridOptions: any, globalEventListener?: Function, $scope?: any, $compile?: any, quickFilterOnScope?: any): this;
        getRowModel(): any;
        refreshPivot(): void;
        getEventService(): EventService;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        isUsingInMemoryModel(): boolean;
        setDatasource(datasource?: any): void;
        setFinished(): void;
        onQuickFilterChanged(newFilter: any): void;
        onFilterModified(): void;
        onFilterChanged(): void;
        onRowClicked(event: any, rowIndex: any, node: any): void;
        showLoadingPanel(show: any): void;
        updateModelAndRefresh(step: any, refreshFromIndex?: any): void;
        setRows(rows?: any, firstId?: any): void;
        ensureNodeVisible(comparator: any): void;
        getFilterModel(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        getSortModel(): any;
        setSortModel(sortModel: any): void;
        onSortingChanged(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        onVirtualRowSelected(rowIndex: any, selected: any): void;
        onVirtualRowRemoved(rowIndex: any): void;
        setColumnDefs(colDefs?: ColDef[]): void;
        updateBodyContainerWidthAfterColResize(): void;
        updatePinnedColContainerWidthAfterColResize(): void;
        doLayout(): void
    }
    declare class ComponentUtil {
        SIMPLE_PROPERTIES: string[];
        SIMPLE_NUMBER_PROPERTIES: string[];
        SIMPLE_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_NUMBER_PROPERTIES: string[];
        WITH_IMPACT_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_OTHER_PROPERTIES: string[];
        CALLBACKS: string[];
        ALL_PROPERTIES: string[];
        copyAttributesToGridOptions(gridOptions: GridOptions, component: any): GridOptions;
        processOnChange(changes: any, gridOptions: GridOptions, component: any): void;
        toBoolean(value: any): boolean;
        toNumber(value: any): number
    }
    declare class AgGridNg2 {
        modelUpdated: any;
        cellClicked: any;
        cellDoubleClicked: any;
        cellContextMenu: any;
        cellValueChanged: any;
        cellFocused: any;
        rowSelected: any;
        selectionChanged: any;
        beforeFilterChanged: any;
        afterFilterChanged: any;
        filterModified: any;
        beforeSortChanged: any;
        afterSortChanged: any;
        virtualRowRemoved: any;
        rowClicked: any;
        ready: any;
        columnEverythingChanged: any;
        columnPivotChanged: any;
        columnValueChanged: any;
        columnMoved: any;
        columnVisible: any;
        columnGroupOpened: any;
        columnResized: any;
        columnPinnedCountChanged: any;
        virtualPaging: boolean;
        toolPanelSuppressPivot: boolean;
        toolPanelSuppressValues: boolean;
        rowsAlreadyGrouped: boolean;
        suppressRowClickSelection: boolean;
        suppressCellSelection: boolean;
        sortingOrder: string[];
        suppressMultiSort: boolean;
        suppressHorizontalScroll: boolean;
        unSortIcon: boolean;
        rowHeight: number;
        rowBuffer: number;
        enableColResize: boolean;
        enableCellExpressions: boolean;
        enableSorting: boolean;
        enableServerSideSorting: boolean;
        enableFilter: boolean;
        enableServerSideFilter: boolean;
        colWidth: number;
        suppressMenuHide: boolean;
        debug: boolean;
        icons: any;
        angularCompileRows: boolean;
        angularCompileFilters: boolean;
        angularCompileHeaders: boolean;
        localeText: any;
        localeTextFunc: Function;
        groupSuppressAutoColumn: boolean;
        groupSelectsChildren: boolean;
        groupHidePivotColumns: boolean;
        groupIncludeFooter: boolean;
        groupUseEntireRow: boolean;
        groupSuppressRow: boolean;
        groupSuppressBlankHeader: boolean;
        groupColumnDef: any;
        forPrint: boolean;
        context: any;
        rowStyle: any;
        rowClass: any;
        headerCellRenderer: any;
        groupDefaultExpanded: any;
        slaveGrids: GridOptions[];
        rowSelection: string;
        rowDeselection: boolean;
        rowData: any[];
        floatingTopRowData: any[];
        floatingBottomRowData: any[];
        showToolPanel: boolean;
        groupKeys: string[];
        groupAggFunction: (nodes: any[]) => void;
        groupAggFields: string[];
        columnDefs: any[];
        datasource: any;
        pinnedColumnCount: number;
        quickFilterText: string;
        groupHeaders: boolean;
        headerHeight: number;
        constructor(elementDef: any): this;
        onInit(): void;
        onChange(changes: any): void
    }
    declare interface Filter {
        getGui(): any,
            isFilterActive(): boolean,
            doesFilterPass(params: any): boolean,
            afterGuiAttached(params?: {
                hidePopup?: Function
            }): void,
            onNewRowsLoaded(): void
    }
}
declare var exports: any;
declare var module: any;
declare module 'agenda' {


    declare type Callback = (err: AV$Error) => any;
    declare interface ResultCallback<T>{
        (err?: AV$Error, result?: T): void
    }
    declare module.exports: typeof Agenda

    /**
     * Agenda Configuration.
     */
    declare interface Agenda$AgendaConfiguration {

        /**
         * Sets the interval with which the queue is checked. A number in milliseconds or a frequency string.
         */
        processEvery?: string | number,

            /**
             * Takes a number which specifies the default number of a specific job that can be running at any given moment.
             * By default it is 5.
             */
            defaultConcurrency?: number,

            /**
             * Takes a number which specifies the max number of jobs that can be running at any given moment. By default it
             * is 20.
             */
            maxConcurrency?: number,

            /**
             * Takes a number which specifies the default number of a specific job that can be locked at any given moment.
             * By default it is 0 for no max.
             */
            defaultLockLimit?: number,

            /**
             * Takes a number shich specifies the max number jobs that can be locked at any given moment. By default it is
             * 0 for no max.
             */
            lockLimit?: number,

            /**
             * Takes a number which specifies the default lock lifetime in milliseconds. By default it is 10 minutes. This
             * can be overridden by specifying the lockLifetime option to a defined job.
             */
            defaultLockLifetime?: number,

            /**
             * Specifies that Agenda should be initialized using and existing MongoDB connection.
             */
            mongo?: {

                /**
                 * The MongoDB database connection to use.
                 */
                db: Db,

                /**
                 * The name of the collection to use.
                 */
                collection?: string
            },

            /**
             * Specifies that Agenda should connect to MongoDB.
             */
            db?: {

                /**
                 * The connection URL.
                 */
                address: string,

                /**
                 * The name of the collection to use.
                 */
                collection?: string,

                /**
                 * Connection options to pass to MongoDB.
                 */
                options?: any
            }
    }


    /**
     * The database record associated with a job.
     */
    declare interface Agenda$JobAttributes {

        /**
         * The record identity.
         */
        _id: ObjectID,

            /**
             * The name of the job.
             */
            name: string,

            /**
             * The type of the job (single|normal).
             */
            type: string,

            /**
             * The job details.
             */
            data: {
                [name: string]: any
            },

            /**
             * The priority of the job.
             */
            priority: number,

            /**
             * How often the job is repeated using a human-readable or cron format.
             */
            repeatInterval: string | number,

            /**
             * The timezone that conforms to [moment-timezone](http://momentjs.com/timezone/).
             */
            repeatTimezone: string,

            /**
             * Date/time the job was las modified.
             */
            lastModifiedBy: string,

            /**
             * Date/time the job will run next.
             */
            nextRunAt: Date,

            /**
             * Date/time the job was locked.
             */
            lockedAt: Date,

            /**
             * Date/time the job was last run.
             */
            lastRunAt: Date,

            /**
             * Date/time the job last finished running.
             */
            lastFinishedAt: Date,

            /**
             * The reason the job failed.
             */
            failReason: string,

            /**
             * The number of times the job has failed.
             */
            failCount: number,

            /**
             * The date/time the job last failed.
             */
            failedAt: Date,

            /**
             * Job's state
             */
            disabled: boolean
    }


    /**
     * A scheduled job.
     */
    declare interface Agenda$Job {

        /**
         * The database record associated with the job.
         */
        attrs: Agenda$JobAttributes,

            /**
             * Specifies an interval on which the job should repeat.
             * @param interval A human-readable format String, a cron format String, or a Number.
             * @param options An optional argument that can include a timezone field. The timezone should be a string as
            accepted by moment-timezone and is considered when using an interval in the cron string format.
            */
            repeatEvery(interval: string | number, options?: {
                timezone?: string
            }): Agenda$Job,

            /**
             * Specifies a time when the job should repeat. [Possible values](https://github.com/matthewmueller/date#examples).
             * @param time 
             */
            repeatAt(time: string): Agenda$Job,

            /**
             * Disables the job.
             */
            disable(): Agenda$Job,

            /**
             * Enables the job.
             */
            enable(): Agenda$Job,

            /**
             * Ensure that only one instance of this job exists with the specified properties
             * @param value The properties associated with the job that must be unqiue.
             * @param opts 
             */
            unique(value: any, opts?: {
                insertOnly?: boolean
            }): Agenda$Job,

            /**
             * Specifies the next time at which the job should run.
             * @param time The next time at which the job should run.
             */
            schedule(time: string | Date): Agenda$Job,

            /**
             * Specifies the priority weighting of the job.
             * @param value The priority of the job (lowest|low|normal|high|highest|number).
             */
            priority(value: string | number): Agenda$Job,

            /**
             * Sets job.attrs.failedAt to now, and sets job.attrs.failReason to reason.
             * @param reason A message or Error object that indicates why the job failed.
             */
            fail(reason: string | AV$Error): Agenda$Job,

            /**
             * Runs the given job and calls callback(err, job) upon completion. Normally you never need to call this manually
             * @param cb Called when the job is completed.
             */
            run(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Returns true if the job is running; otherwise, returns false.
             */
            isRunning(): boolean,

            /**
             * Saves the job into the database.
             * @param cb Called when the job is saved.
             */
            save(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Removes the job from the database and cancels the job.
             * @param cb Called after the job has beeb removed from the database.
             */
            remove(cb?: Callback): void,

            /**
             * Resets the lock on the job. Useful to indicate that the job hasn't timed out when you have very long running
             * jobs.
             * @param cb Called after the job has been saved to the database.
             */
            touch(cb?: Callback): void,

            /**
             * Calculates next time the job should run
             */
            computeNextRunAt(): Agenda$Job
    }

    declare interface Agenda$JobOptions {

        /**
         * Maximum number of that job that can be running at once (per instance of agenda)
         */
        concurrency?: number,

            /**
             * Maximum number of that job that can be locked at once (per instance of agenda)
             */
            lockLimit?: number,

            /**
             * Interval in ms of how long the job stays locked for (see multiple job processors for more info). A job will
             * automatically unlock if done() is called.
             */
            lockLifetime?: number,

            /**
             * (lowest|low|normal|high|highest|number) specifies the priority of the job. Higher priority jobs will run
             * first.
             */
            priority?: string | number
    }
}
declare module 'ajv' {
    declare module.exports: typeof Ajv
    declare type Ajv$AjvOptions = {
        v5?: boolean,
        allErrors?: boolean,
        verbose?: boolean,
        jsonPointers?: boolean,
        uniqueItems?: boolean,
        unicode?: boolean,
        format?: string,
        formats?: any,
        schemas?: any,
        missingRefs?: boolean,
        loadSchema(uri: string, callback: (error: AV$Error, body: any) => void): void,
        removeAdditional?: boolean,
        useDefaults?: boolean,
        coerceTypes?: boolean,
        async?: any,
        transpile?: string,
        meta?: boolean,
        validateSchema?: boolean,
        addUsedSchema?: boolean,
        inlineRefs?: boolean,
        passContext?: boolean,
        loopRequired?: number,
        ownProperties?: boolean,
        multipleOfPrecision?: boolean | number,
        errorDataPath?: string,
        messages?: boolean,
        beautify?: boolean,
        cache?: any
    };

    declare type Ajv$AjvValidate = ((data: any) => boolean | PromiseLike<boolean>) & {
        errors: Ajv$ValidationError[]
    };

    declare type Ajv$AjxKeywordDefinition = {
        async?: boolean,
        type: string,
        compile?: (
            schema: any,
            parentsSchema: any) => ((data: any) => boolean | PromiseLike<boolean>),
        validate?: (schema: any, data: any) => boolean
    };

    declare type Ajv$ValidationError = {
        keyword: string,
        dataPath: string,
        schemaPath: string,
        params: any,
        message: string,
        schema: any,
        parentSchema: any,
        data: any
    };
}
declare var alertify: alertify$IAlertifyStatic;
declare interface alertify$IAlertifyStatic {

    /**
     * Create an alert dialog box
     * @param message The message passed from the callee
     * @param fn Callback function
     * @param cssClass Class(es) to append to dialog box
     * @return  alertify (ie this)
     * @since  0.0.1
     */
    alert(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Create a confirm dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param cssClass Class(es) to append to dialog box
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        confirm(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Extend the log method to create custom methods
         * @param type Custom method name
         * @return  function for logging
         * @since  0.0.1
         */
        extend(type: string): (message: string, wait?: number) => alertify$IAlertifyStatic,

        /**
         * Initialize Alertify and create the 2 main elements.
         * Initialization will happen automatically on the first
        use of alert, confirm, prompt or log.
         * @since  0.0.1
        */
        init(): void,

        /**
         * Show a new log message box
         * @param message The message passed from the callee
         * @param type Optional type of log message
         * @param wait Optional time (in ms) to wait before auto-hiding
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        log(message: string, type?: string, wait?: number): alertify$IAlertifyStatic,

        /**
         * Create a prompt dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param placeholder Default value for prompt input
         * @param cssClass Class(es) to append to dialog
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        prompt(
            message: string,
            fn?: Function,
            placeholder?: string,
            cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        success(message: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        error(message: string): alertify$IAlertifyStatic,

        /**
         * Used to set alertify properties
         * @param Properties 
         * @since  0.2.11
         */
        set(args: alertify$IProperties): void,

        /**
         * The labels used for dialog buttons
         */
        labels: alertify$ILabels,

        /**
         * Attaches alertify.error to window.onerror method
         * @since  0.3.8
         */
        debug(): void
}


/**
 * Properties for alertify.set function
 */
declare interface alertify$IProperties {

    /**
     * Default value for milliseconds display of log messages 
     */
    delay?: number,

        /**
         * Default values for display of labels 
         */
        labels?: alertify$ILabels,

        /**
         * Default button for focus 
         */
        buttonFocus?: string,

        /**
         * Should buttons be displayed in reverse order 
         */
        buttonReverse?: boolean
}


/**
 * Labels for altertify.set function 
 */
declare interface alertify$ILabels {
    ok?: string,
        cancel?: string
}
declare module 'alexa-sdk' {
    declare     export function handler(event: RequestBody, context: Context, callback?: Function): AlexaObject
    declare     export function CreateStateHandler(state: string, obj: any): any
    declare     export var StateString: string;
    declare interface AlexaObject {
        _event: any,
            _context: any,
            _callback: any,
            state: any,
            appId: any,
            response: any,
            dynamoDBTableName: any,
            saveBeforeResponse: boolean,
            registerHandlers: (...handlers: Handlers[]) => any,
            execute: () => void
    }
    declare interface Handlers {
        [intent: string]: () => void
    }
    declare interface Handler {
        on: any,
            emit(event: string, ...args: any[]): boolean,
            emitWithState: any,
            state: any,
            handler: any,
            event: RequestBody,
            attributes: any,
            context: any,
            name: any,
            isOverriden: any
    }
    declare interface Context {
        callbackWaitsForEmptyEventLoop: boolean,
            logGroupName: string,
            logStreamName: string,
            functionName: string,
            memoryLimitInMB: string,
            functionVersion: string,
            invokeid: string,
            awsRequestId: string
    }
    declare interface RequestBody {
        version: string,
            session: autobahn$Session,
            request: LaunchRequest | IntentRequest | SessionEndedRequest
    }
    declare interface Session {
        new: boolean,
        sessionId: string,
            attributes: any,
            application: SessionApplication,
            user: SessionUser
    }
    declare interface SessionApplication {
        applicationId: string
    }
    declare interface SessionUser {
        userId: string,
            accessToken: string
    }
    declare type LaunchRequest = {} & IRequest

    declare type IntentRequest = {
        intent: Intent
    } & IRequest

    declare interface Intent {
        name: string,
            slots: any
    }
    declare type SessionEndedRequest = {
        reason: string
    } & IRequest

    declare interface IRequest {
        type: "LaunchRequest" | "IntentRequest" | "SessionEndedRequest",
            requestId: string,
            timeStamp: string
    }
    declare interface ResponseBody {
        version: string,
            sessionAttributes?: any,
            response: Atmosphere$Response
    }
    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare interface OutputSpeech {
        type: "PlainText" | "SSML",
            text?: string,
            ssml?: string
    }
    declare interface Card {
        type: "Simple" | "Standard" | "LinkAccount",
            title?: string,
            content?: string,
            text?: string,
            image?: Image
    }
    declare interface Image {
        smallImageUrl: string,
            largeImageUrl: string
    }
    declare interface Reprompt {
        outputSpeech: OutputSpeech
    }
}
declare interface AlgoliaResponse {

    /**
     * Contains all the hits matching the query
     * https://github.com/algolia/algoliasearch-client-js#response-format
     */
    hits: any[],

        /**
         * Current page
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        page: number,

        /**
         * Number of total hits matching the query
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        nbHits: number,

        /**
         * Number of pages
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        nbPage: number,

        /**
         * Number of hits per pages
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        hitsPerPage: number,

        /**
         * Engine processing time (excluding network transfer)
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        processingTimeMS: number,

        /**
         * Query used to perform the search
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        query: string,

        /**
         * GET parameters used to perform the search
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        params: string
}
declare interface AlgoliaClient {

    /**
     * Initialization of the index
     * @param name : index name
    return algolia index object
    https://github.com/algolia/algoliasearch-client-js#init-index---initindex
    */
    initIndex(name: string): AlgoliaIndex,

        /**
         * Query on multiple index
         * @param queries index name, query and query parameters
         * @param cb callback(err, res)
        https://github.com/algolia/algoliasearch-client-js#multiple-queries---multiplequeries
        */
        search(
            queries: {
                indexName: string,
                query: string,
                options: AlgoliaQueryParameters
            },
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Query on multiple index
         * @param queries index name, query and query parameters
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#multiple-queries---multiplequeries
        */
        search(
            queries: {
                indexName: string,
                query: string,
                options: AlgoliaQueryParameters
            }): AV$Promise<AlgoliaResponse>,

        /**
         * clear browser cache
         * https://github.com/algolia/algoliasearch-client-js#cache
         */
        clearCache(): void,

        /**
         * kill alive connections
         * https://github.com/algolia/algoliasearch-client-js#keep-alive
         */
        destroy(): void,

        /**
         * List all your indices along with their associated information (number of entries, disk size, etc.)
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#list-indices---listindexes
        */
        listIndexes(cb: (err: AV$Error, res: any) => void): void,

        /**
         * List all your indices along with their associated information (number of entries, disk size, etc.)
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#list-indices---listindexes
        */
        listIndexes(): AV$Promise<any>,

        /**
         * Delete a specific index
         * @param name 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-index---deleteindex
        */
        deleteIndex(name: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete a specific index
         * @param name return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-index---deleteindex
        */
        deleteIndex(name: string): AV$Promise<any>,

        /**
         * Copy an  index from a specific index to a new one
         * @param from origin index
         * @param to destination index
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#copy-index---copyindex
        */
        copyIndex(from: string, to: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Copy an  index from a specific index to a new one
         * @param from origin index
         * @param to destination index
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#copy-index---copyindex
        */
        copyIndex(from: string, to: string): AV$Promise<any>,

        /**
         * Move index to a new one (and will overwrite the original one)
         * @param from origin index
         * @param to destination index
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#move-index---moveindex
        */
        moveIndex(from: string, to: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Move index to a new one (and will overwrite the original one)
         * @param from origin index
         * @param to destination index
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#move-index---moveindex
        */
        moveIndex(from: string, to: string): AV$Promise<any>,

        /**
         * Generate a public API key
         * @param key api key
         * @param filters https://github.com/algolia/algoliasearch-client-js#generate-key---generatesecuredapikey
         */
        generateSecuredApiKey(key: string, filters: AlgoliaSecuredApiOptions): void,

        /**
         * Perform multiple operations with one API call to reduce latency
         * @param action 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
        */
        batch(action: AlgoliaAction, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Perform multiple operations with one API call to reduce latency
         * @param action return {Promise}
        https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
        */
        batch(action: AlgoliaAction): AV$Promise<any>,

        /**
         * Lists global API Keys
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        listUserKeys(cb: (err: AV$Error, res: any) => void): void,

        /**
         * Lists global API Keys
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        listUserKeys(): AV$Promise<any>,

        /**
         * Add global API Keys
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add global API Keys
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[]): AV$Promise<any>,

        /**
         * Add global API Key
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add global API Key
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], options: AlgoliaUserKeyOptions): AV$Promise<any>,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update global API key
         * @param key 
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[]): AV$Promise<any>,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(
            key: string,
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], options: AlgoliaUserKeyOptions): AV$Promise<any>,

        /**
         * Gets the rights of a global key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        getUserKeyACL(key: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Gets the rights of a global key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        getUserKeyACL(key: string): AV$Promise<any>,

        /**
         * Deletes a global key
         * @param key 
         * @param cb (err,res)
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Deletes a global key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string): AV$Promise<any>,

        /**
         * Get 1000 last events
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        getLogs(options: LogsOptions, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Get 1000 last events
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        getLogs(options: LogsOptions): AV$Promise<any >
}
/**
 * Interface for the index algolia object
 */
declare interface AlgoliaIndex {

    /**
     * Gets a specific object
     * @param objectID 
     * @param cb (err, res)
    https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
    */
    getObject(objectID: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Gets specific attributes from an object
         * @param objectID 
         * @param attributes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(
            objectID: string,
            attributes: string[],
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Gets a list of objects
         * @param objectIDs 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObjects(objectIDs: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add a specific object
         * @param object without objectID
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add a list of objects
         * @param object with objectID
         * @param objectID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, objectID: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add list of objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObjects(objects: [{}], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add or replace a specific object
         * @param object 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObject(object: {}, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add or replace several objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObjects(objects: [{}], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update parameters of a specific object
         * @param object 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObject(object: {}, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update parameters of a list of objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObjects(objects: [{}], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete a specific object
         * @param objectID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObject(objectID: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete a list of objects
         * @param objectIDs 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObjects(objectIDs: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param params of the object
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, params: {}, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Wait for an indexing task to be compete
         * @param taskID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#wait-for-operations---waittask
        */
        waitTask(taskID: number, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Get an index settings
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-settings---getsettings
        */
        getSettings(cb: (err: AV$Error, res: any) => void): void,

        /**
         * Set an index settings
         * @param settings 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#set-settings---setsettings
        */
        setSettings(settings: AlgoliaIndexSettings, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Clear cache of an index
         * https://github.com/algolia/algoliasearch-client-js#cache
         */
        clearCache(): void,

        /**
         * Clear an index content
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#clear-index---clearindex
        */
        clearIndex(cb: (err: AV$Error, res: any) => void): void,

        /**
         * Save a synonym object
         * @param synonym 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        saveSynonym(
            synonym: AlgoliaSynonym,
            option: SynonymOption,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Save a synonym object
         * @param synonyms 
         * @param options 
         * @param cb (err, res)
         */
        batchSynonyms(
            synonyms: AlgoliaSynonym[],
            options: SynonymOption,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Delete a specific synonym
         * @param identifier 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
        */
        deleteSynonym(
            identifier: string,
            options: SynonymOption,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Clear all synonyms of an index
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#clear-all-synonyms---clearsynonyms
        */
        clearSynonyms(options: SynonymOption, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Get a specific synonym
         * @param identifier 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-synonym---getsynonym
        */
        getSynonym(identifier: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Search a synonyms
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        searchSynonyms(options: SearchSynonymOptions, cb: (err: AV$Error, res: any) => void): void,

        /**
         * List index user keys
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#list-api-keys---listapikeys
        */
        listUserKeys(cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add key for this index
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Add key for this index
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], cb: (err: AV$Error, res: any) => void): void,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(
            key: string,
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: AV$Error, res: any) => void): void,

        /**
         * Gets the rights of an index specific key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-key-permissions---getuserkeyacl
        */
        getUserKeyACL(key: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Deletes an index specific key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Gets a specific object
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(objectID: string): AV$Promise<any>,

        /**
         * Gets specific attributes from an object
         * @param objectID 
         * @param attributes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(objectID: string, attributes: string[]): AV$Promise<any>,

        /**
         * Gets a list of objects
         * @param objectIDs return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObjects(objectIDs: string[]): AV$Promise<any>,

        /**
         * Add a specific object
         * @param object without objectID
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}): AV$Promise<any>,

        /**
         * Add a list of objects
         * @param object with objectID
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, objectID: string): AV$Promise<any>,

        /**
         * Add list of objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObjects(objects: [{}]): AV$Promise<any>,

        /**
         * Add or replace a specific object
         * @param object return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObject(object: {}): AV$Promise<any>,

        /**
         * Add or replace several objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObjects(objects: [{}]): AV$Promise<any>,

        /**
         * Update parameters of a specific object
         * @param object return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObject(object: {}): AV$Promise<any>,

        /**
         * Update parameters of a list of objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObjects(objects: [{}]): AV$Promise<any>,

        /**
         * Delete a specific object
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObject(objectID: string): AV$Promise<any>,

        /**
         * Delete a list of objects
         * @param objectIDs return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObjects(objectIDs: string[]): AV$Promise<any>,

        /**
         * Delete objects that matches the query
         * @param query return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string): AV$Promise<any>,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param params of the object
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, params: {}): AV$Promise<any>,

        /**
         * Wait for an indexing task to be compete
         * @param taskID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#wait-for-operations---waittask
        */
        waitTask(taskID: number): AV$Promise<any>,

        /**
         * Get an index settings
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-settings---getsettings
        */
        getSettings(): AV$Promise<any>,

        /**
         * Set an index settings
         * @param settings return {Promise}
        https://github.com/algolia/algoliasearch-client-js#set-settings---setsettings
        */
        setSettings(settings: AlgoliaIndexSettings): AV$Promise<any>,

        /**
         * Search in an index
         * @param params query parameter
        return {Promise}
         * @param err () error callback
        https://github.com/algolia/algoliasearch-client-js#search-in-an-index---search
        */
        search(params: AlgoliaQueryParameters): AV$Promise<any>,

        /**
         * Search in an index
         * @param params query parameter
         * @param cb (err, res)
         * @param err () error callback
        https://github.com/algolia/algoliasearch-client-js#search-in-an-index---search
        */
        search(params: AlgoliaQueryParameters, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Browse an index
         * @param query 
         * @param cb (err, content)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browse(query: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Browse an index
         * @param query return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browse(query: string): AV$Promise<AlgoliaBrowseResponse>,

        /**
         * Browse an index from a cursor
         * @param cursor 
         * @param cb (err, content)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseFrom(cursor: string, cb: (err: AV$Error, res: any) => void): void,

        /**
         * Browse an index from a cursor
         * @param cursor return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseFrom(cursor: string): AV$Promise<AlgoliaBrowseResponse>,

        /**
         * Browse an entire index
         * return Promise
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseAll(): AV$Promise<AlgoliaResponse>,

        /**
         * Clear an index content
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#clear-index---clearindex
        */
        clearIndex(): AV$Promise<any>,

        /**
         * Save a synonym object
         * @param synonym 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        saveSynonym(synonym: AlgoliaSynonym, option: SynonymOption): AV$Promise<any>,

        /**
         * Save a synonym object
         * @param synonyms 
         * @param options return {Promise}
         */
        batchSynonyms(synonyms: AlgoliaSynonym[], options: SynonymOption): AV$Promise<any>,

        /**
         * Delete a specific synonym
         * @param identifier 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
        */
        deleteSynonym(identifier: string, options: SynonymOption): AV$Promise<any>,

        /**
         * Clear all synonyms of an index
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#clear-all-synonyms---clearsynonyms
        */
        clearSynonyms(options: SynonymOption): AV$Promise<any>,

        /**
         * Get a specific synonym
         * @param identifier return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-synonym---getsynonym
        */
        getSynonym(identifier: string): AV$Promise<any>,

        /**
         * Search a synonyms
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        searchSynonyms(options: SearchSynonymOptions): AV$Promise<any>,

        /**
         * List index user keys
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#list-api-keys---listapikeys
        */
        listUserKeys(): AV$Promise<any>,

        /**
         * Add key for this index
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[]): AV$Promise<any>,

        /**
         * Add key for this index
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], options: AlgoliaUserKeyOptions): AV$Promise<any>,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[]): AV$Promise<any>,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], options: AlgoliaUserKeyOptions): AV$Promise<any>,

        /**
         * Gets the rights of an index specific key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-key-permissions---getuserkeyacl
        */
        getUserKeyACL(key: string): AV$Promise<any>,

        /**
         * Deletes an index specific key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string): AV$Promise<any >
}
declare interface ClientOptions {

    /**
     * Timeout for requests to our servers, in milliseconds
     * default: 15s (node), 2s (browser)
    https://github.com/algolia/algoliasearch-client-js#client-options
    */
    timeout?: number,

        /**
         * Protocol to use when communicating with algolia
         * default: current protocol(browser), https(node)
        https://github.com/algolia/algoliasearch-client-js#client-options
        */
        protocol?: string,

        /**
         * (node only) httpAgent instance to use when communicating with Algolia servers.
         * https://github.com/algolia/algoliasearch-client-js#client-options
         */
        httpAgent?: any,

        /**
         * read: array of read hosts to use to call Algolia servers, computed automatically
         * write: array of read hosts to use to call Algolia servers, computed automatically
        https://github.com/algolia/algoliasearch-client-js#client-options
        */
        hosts?: {
            read?: string[],
            write?: string[]
        }
}
declare interface LogsOptions {

    /**
     * Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
     * default: 0
    https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
    */
    offset?: number,

        /**
         * Specify the maximum number of entries to retrieve starting at the offset.
         * default: 10
        maximum: 1000
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        length?: number,

        /**
         * 
         * @deprecated  * Retrieve only logs with an HTTP code different than 200 or 201
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        onlyErrors?: boolean,

        /**
         * Specify the type of logs to retrieve
         * 'query' Retrieve only the queries
        'build' Retrieve only the build operations
        'error' Retrieve only the errors (same as onlyErrors parameters)
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        type?: string
}
/**
 * Describe the action object used for batch operation
 */
declare interface AlgoliaAction {

    /**
     * Type of the batch action
     * values: addObject, updateObject, partialUpdateObject, partialUpdateObjectNoCreate, deleteObject
    https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
    */
    action: string,

        /**
         * Name of the index where the bact will be performed
         * https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
         */
        indexName: string,

        /**
         * Object
         * https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
         */
        body: {}
}
/**
 * Describes the option used when creating user key
 */
declare interface AlgoliaUserKeyOptions {

    /**
     * Add a validity period. The key will be valid for a specific period of time (in seconds).
     * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
     */
    validity?: number,

        /**
         * Specify the maximum number of API calls allowed from an IP address per hour
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        maxQueriesPerIPPerHour?: number,

        /**
         * Specify the maximum number of hits this API key can retrieve in one call
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        maxHitsPerQuery?: boolean,

        /**
         * Specify the list of targeted indices
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        indexes?: string[],

        /**
         * Specify the list of referers
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        referers?: string[],

        /**
         * Specify the list of query parameters
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        queryParameters?: AlgoliaQueryParameters,

        /**
         * Specify a description to describe where the key is used.
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        description?: string
}
/**
 * Describes option used when making operation on synonyms
 */
declare interface SynonymOption {

    /**
     * You can forward all settings updates to the slaves of an index
     * https://github.com/algolia/algoliasearch-client-js#slave-settings
     */
    forwardToSlaves?: boolean,

        /**
         * Replace all existing synonyms on the index with the content of the batch
         * https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
         */
        replaceExistingSynonyms?: boolean
}
/**
 * Describes options used when searching for synonyms
 */
declare interface SearchSynonymOptions {

    /**
     * The actual search query to find synonyms
     * https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
     */
    query?: string,

        /**
         * The page to fetch when browsing through several pages of results
         * default: 100
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        page?: number,

        /**
         * Restrict the search to a specific type of synonym
         * Use an empty string to search all types (default behavior)
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        type?: string,

        /**
         * Number of hits per page
         * default: 100
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        hitsPerPage?: number
}
declare interface AlgoliaBrowseResponse {
    cursor?: string,
        hits: any[],
        params: string,
        query: string,
        processingTimeMS: number
}
/**
 * Describes a synonym object
 */
declare interface AlgoliaSynonym {

    /**
     * ObjectID of the synonym
     * https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
     */
    objectID: string,

        /**
         * Type of synonym
         * values: synonym,oneWaySynonym
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        type: string,

        /**
         * Values used for the synonym
         * https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
         */
        synonyms: string[]
}
/**
 * Describes the options used when generating new api keys
 */
declare interface AlgoliaSecuredApiOptions {

    /**
     * Filter the query with numeric, facet or/and tag filters
     * default: ""
    https://github.com/algolia/algoliasearch-client-js#filters-1
    */
    filters?: string,

        /**
         * Defines the expiration date of the API key
         * https://github.com/algolia/algoliasearch-client-js#valid-until
         */
        validUntil?: number,

        /**
         * Restricts the key to a list of index names allowed for the secured API key
         * https://github.com/algolia/algoliasearch-client-js#index-restriction
         */
        restrictIndices?: string,

        /**
         * Allows you to restrict a single user to performing a maximum of N API calls per hour
         * https://github.com/algolia/algoliasearch-client-js#user-rate-limiting
         */
        userToken?: string
}
/**
 * Describes the settings available for configure your index
 */
declare interface AlgoliaIndexSettings {

    /**
     * The list of attributes you want index
     * default: 
    https://github.com/algolia/algoliasearch-client-js#attributestoindex
    */
    attributesToIndex?: string[],

        /**
         * The list of attributes you want to use for faceting
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributesforfaceting
        */
        attributesforFaceting?: string[],

        /**
         * The list of attributes that cannot be retrieved at query time
         * default: null
        https://github.com/algolia/algoliasearch-client-js#unretrievableattributes
        */
        unretrievableAttributes?: string[],

        /**
         * A string that contains the list of attributes you want to retrieve in order to minimize the size of the JSON answer
         * default: 
        https://github.com/algolia/algoliasearch-client-js#attributestoretrieve
        */
        attributesToRetrieve?: string[],

        /**
         * Controls the way results are sorted
         * default: ['typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom']
        https://github.com/algolia/algoliasearch-client-js#ranking
        */
        ranking?: string[],

        /**
         * Lets you specify part of the ranking
         * default: []
        https://github.com/algolia/algoliasearch-client-js#customranking
        */
        customRanking?: string[],

        /**
         * The list of indices on which you want to replicate all write operations
         * default: []
        https://github.com/algolia/algoliasearch-client-js#slaves
        */
        slaves?: string[],

        /**
         * Limit the number of facet values returned for each facet
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#maxvaluesperfacet
        */
        maxValuesPerFacet?: string,

        /**
         * Default list of attributes to highlight. If set to null, all indexed attributes are highlighted.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestohighlight
        */
        attributesToHighlight?: string[],

        /**
         * Default list of attributes to snippet alongside the number of words to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestosnippet
        */
        attributesToSnippet?: string[],

        /**
         * Specify the string that is inserted before the highlighted parts in the query result
         * default: <em>
        https://github.com/algolia/algoliasearch-client-js#highlightpretag
        */
        highlightPreTag?: string,

        /**
         * Specify the string that is inserted after the highlighted parts in the query result
         * default: </em>
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        highlightPostTag?: string,

        /**
         * String used as an ellipsis indicator when a snippet is truncated.
         * default: …
        https://github.com/algolia/algoliasearch-client-js#snippetellipsistext
        */
        snippetEllipsisText?: string,

        /**
         * If set to true, restrict arrays in highlights and snippets to items that matched the query at least partially else return all array items in highlights and snippets
         * default: false
        https://github.com/algolia/algoliasearch-client-js#restricthighlightandsnippetarrays
        */
        restrictHighlightAndSnippetArrays?: boolean,

        /**
         * Pagination parameter used to select the number of hits per page
         * default: 20
        https://github.com/algolia/algoliasearch-client-js#hitsperpage
        */
        hitsPerPage?: number,

        /**
         * The minimum number of characters needed to accept one typo
         * default: 4
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor1typo
        */
        minWordSizefor1Typo?: number,

        /**
         * The minimum number of characters needed to accept two typos.
         * default: 8
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        minWordSizefor2Typos?: number,

        /**
         * This option allows you to control the number of typos allowed in the result set
         * default: true
        'true' The typo tolerance is enabled and all matching hits are retrieved (default behavior).
        'false' The typo tolerance is disabled. All results with typos will be hidden.
        'min' Only keep results with the minimum number of typos. For example, if one result matches without typos, then all results with typos will be hidden.
        'strict' Hits matching with 2 typos are not retrieved if there are some matching without typos.
        https://github.com/algolia/algoliasearch-client-js#typotolerance
        */
        typoTolerance?: any,

        /**
         * If set to false, disables typo tolerance on numeric tokens (numbers).
         * default: true
        https://github.com/algolia/algoliasearch-client-js#allowtyposonnumerictokens
        */
        allowTyposOnNumericTokens?: boolean,

        /**
         * If set to true, plural won't be considered as a typo
         * default: false
        https://github.com/algolia/algoliasearch-client-js#ignoreplurals
        */
        ignorePlurals?: boolean,

        /**
         * List of attributes on which you want to disable typo tolerance
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#disabletypotoleranceonattributes
        */
        disableTypoToleranceOnAttributes?: string,

        /**
         * Specify the separators (punctuation characters) to index.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#separatorstoindex
        */
        separatorsToIndex?: string,

        /**
         * Selects how the query words are interpreted
         * default: 'prefixLast'
        'prefixAll' All query words are interpreted as prefixes. This option is not recommended.
        'prefixLast' Only the last word is interpreted as a prefix (default behavior).
        'prefixNone' No query word is interpreted as a prefix. This option is not recommended.
        https://github.com/algolia/algoliasearch-client-js#querytype
        */
        queryType?: any,

        /**
         * This option is used to select a strategy in order to avoid having an empty result page
         * default: 'none'
        'lastWords' When a query does not return any results, the last word will be added as optional
        'firstWords' When a query does not return any results, the first word will be added as optional
        'allOptional' When a query does not return any results, a second trial will be made with all words as optional
        'none' No specific processing is done when a query does not return any results
        https://github.com/algolia/algoliasearch-client-js#removewordsifnoresults
        */
        removeWordsIfNoResults?: string,

        /**
         * Enables the advanced query syntax
         * default: false
        https://github.com/algolia/algoliasearch-client-js#advancedsyntax
        */
        advancedSyntax?: boolean,

        /**
         * A string that contains the comma separated list of words that should be considered as optional when found in the query
         * default: []
        https://github.com/algolia/algoliasearch-client-js#optionalwords
        */
        optionalWords?: string[],

        /**
         * Remove stop words from the query before executing it
         * default: false
        true|false: enable or disable stop words for all 41 supported languages; or
        a list of language ISO codes (as a comma-separated string) for which stop words should be enable
        https://github.com/algolia/algoliasearch-client-js#removestopwords
        */
        removeStopWords?: string[],

        /**
         * List of attributes on which you want to disable prefix matching
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableprefixonattributes
        */
        disablePrefixOnAttributes?: string[],

        /**
         * List of attributes on which you want to disable the computation of exact criteria
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableexactonattributes
        */
        disableExactOnAttributes?: string[],

        /**
         * This parameter control how the exact ranking criterion is computed when the query contains one word
         * default: attribute
        'none': no exact on single word query
        'word': exact set to 1 if the query word is found in the record
        'attribute': exact set to 1 if there is an attribute containing a string equals to the query
        https://github.com/algolia/algoliasearch-client-js#exactonsinglewordquery
        */
        exactOnSingleWordQuery?: string,

        /**
         * Specify the list of approximation that should be considered as an exact match in the ranking formula
         * default: ['ignorePlurals', 'singleWordSynonym']
        'ignorePlurals': alternative words added by the ignorePlurals feature
        'singleWordSynonym': single-word synonym (For example "NY" = "NYC")
        'multiWordsSynonym': multiple-words synonym
        https://github.com/algolia/algoliasearch-client-js#alternativesasexact
        */
        alternativesAsExact?: any,

        /**
         * The name of the attribute used for the Distinct feature
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributefordistinct
        */
        attributeForDistinct?: string,

        /**
         * If set to 1, enables the distinct feature, disabled by default, if the attributeForDistinct index setting is set.
         * https://github.com/algolia/algoliasearch-client-js#distinct
         */
        distinct?: any,

        /**
         * All numerical attributes are automatically indexed as numerical filters
         * default ''
        https://github.com/algolia/algoliasearch-client-js#numericattributestoindex
        */
        numericAttributesToIndex?: string[],

        /**
         * Allows compression of big integer arrays.
         * default: false
        https://github.com/algolia/algoliasearch-client-js#allowcompressionofintegerarray
        */
        allowCompressionOfIntegerArray?: boolean,

        /**
         * Specify alternative corrections that you want to consider.
         * default: []
        https://github.com/algolia/algoliasearch-client-js#altcorrections
        */
        altCorrections?: [{}],

        /**
         * Configure the precision of the proximity ranking criterion
         * default: 1
        https://github.com/algolia/algoliasearch-client-js#minproximity
        */
        minProximity?: number,

        /**
         * This is an advanced use-case to define a token substitutable by a list of words without having the original token searchable
         * default: ''
        https://github.com/algolia/algoliasearch-client-js#placeholders
        */
        placeholders?: any
}
declare interface AlgoliaQueryParameters {

    /**
     * Query string used to perform the search
     * default: ''
    https://github.com/algolia/algoliasearch-client-js#query
    */
    query?: string,

        /**
         * Filter the query with numeric, facet or/and tag filters
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#filters
        */
        filters?: string,

        /**
         * A string that contains the list of attributes you want to retrieve in order to minimize the size of the JSON answer.
         * default: 
        https://github.com/algolia/algoliasearch-client-js#attributestoretrieve
        */
        attributesToRetrieve?: string[],

        /**
         * List of attributes you want to use for textual search
         * default: attributeToIndex
        https://github.com/algolia/algoliasearch-client-js#restrictsearchableattributes
        */
        restrictSearchableAttributes?: string[],

        /**
         * You can use facets to retrieve only a part of your attributes declared in attributesForFaceting attributes
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#facets
        */
        facets?: string,

        /**
         * Limit the number of facet values returned for each facet.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#maxvaluesperfacet
        */
        maxValuesPerFacet?: string,

        /**
         * Default list of attributes to highlight. If set to null, all indexed attributes are highlighted.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestohighlight
        */
        attributesToHighlight?: string[],

        /**
         * Default list of attributes to snippet alongside the number of words to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestosnippet
        */
        attributesToSnippet?: string[],

        /**
         * Specify the string that is inserted before the highlighted parts in the query result
         * default: <em>
        https://github.com/algolia/algoliasearch-client-js#highlightpretag
        */
        highlightPreTag?: string,

        /**
         * Specify the string that is inserted after the highlighted parts in the query result
         * default: </em>
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        highlightPostTag?: string,

        /**
         * String used as an ellipsis indicator when a snippet is truncated.
         * default: …
        https://github.com/algolia/algoliasearch-client-js#snippetellipsistext
        */
        snippetEllipsisText?: string,

        /**
         * If set to true, restrict arrays in highlights and snippets to items that matched the query at least partially else return all array items in highlights and snippets
         * default: false
        https://github.com/algolia/algoliasearch-client-js#restricthighlightandsnippetarrays
        */
        restrictHighlightAndSnippetArrays?: boolean,

        /**
         * Pagination parameter used to select the number of hits per page
         * default: 20
        https://github.com/algolia/algoliasearch-client-js#hitsperpage
        */
        hitsPerPage?: number,

        /**
         * Pagination parameter used to select the page to retrieve.
         * default: 0
        https://github.com/algolia/algoliasearch-client-js#page
        */
        page?: number,

        /**
         * Offset of the first hit to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#offset
        */
        offset?: number,

        /**
         * Number of hits to return.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#length
        */
        length?: number,

        /**
         * The minimum number of characters needed to accept one typo.
         * default: 4
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor1typo
        */
        minWordSizefor1Typo?: number,

        /**
         * The minimum number of characters needed to accept two typo.
         * fault: 8
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor2typos
        */
        minWordSizefor2Typos?: number,

        /**
         * This option allows you to control the number of typos allowed in the result set:
         * default: true
        'true' The typo tolerance is enabled and all matching hits are retrieved
        'false' The typo tolerance is disabled. All results with typos will be hidden.
        'min' Only keep results with the minimum number of typos
        'strict' Hits matching with 2 typos are not retrieved if there are some matching without typos.
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor2typos
        */
        typoTolerance?: boolean,

        /**
         * If set to false, disables typo tolerance on numeric tokens (numbers).
         * default:
        https://github.com/algolia/algoliasearch-client-js#allowtyposonnumerictokens
        */
        allowTyposOnNumericTokens?: boolean,

        /**
         * If set to true, plural won't be considered as a typo
         * default: false
        https://github.com/algolia/algoliasearch-client-js#ignoreplurals
        */
        ignorePlurals?: boolean,

        /**
         * List of attributes on which you want to disable typo tolerance
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#disabletypotoleranceonattributes
        */
        disableTypoToleranceOnAttributes?: string,

        /**
         * Search for entries around a given location
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#aroundlatlng
        */
        aroundLatLng?: string,

        /**
         * Search for entries around a given latitude/longitude automatically computed from user IP address.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#aroundlatlngviaip
        */
        aroundLatLngViaIP?: string,

        /**
         * Control the radius associated with a geo search. Defined in meters.
         * default: null
        You can specify aroundRadius=all if you want to compute the geo distance without filtering in a geo area
        https://github.com/algolia/algoliasearch-client-js#aroundradius
        */
        aroundRadius?: any,

        /**
         * Control the precision of a geo search
         * default: null
        https://github.com/algolia/algoliasearch-client-js#aroundprecision
        */
        aroundPrecision?: number,

        /**
         * Define the minimum radius used for a geo search when aroundRadius is not set.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#minimumaroundradius
        */
        minimumAroundRadius?: number,

        /**
         * Search entries inside a given area defined by the two extreme points of a rectangle
         * default: null
        https://github.com/algolia/algoliasearch-client-js#insideboundingbox
        */
        insideBoundingBox?: string,

        /**
         * Selects how the query words are interpreted
         * default: 'prefixLast'
        'prefixAll' All query words are interpreted as prefixes. This option is not recommended.
        'prefixLast' Only the last word is interpreted as a prefix (default behavior).
        'prefixNone' No query word is interpreted as a prefix. This option is not recommended.
        https://github.com/algolia/algoliasearch-client-js#querytype
        */
        queryType?: any,

        /**
         * Search entries inside a given area defined by a set of points
         * defauly: ''
        https://github.com/algolia/algoliasearch-client-js#insidepolygon
        */
        insidePolygon?: string,

        /**
         * This option is used to select a strategy in order to avoid having an empty result page
         * default: 'none'
        'lastWords' When a query does not return any results, the last word will be added as optional
        'firstWords' When a query does not return any results, the first word will be added as optional
        'allOptional' When a query does not return any results, a second trial will be made with all words as optional
        'none' No specific processing is done when a query does not return any results
        https://github.com/algolia/algoliasearch-client-js#removewordsifnoresults
        */
        removeWordsIfNoResults?: string,

        /**
         * Enables the advanced query syntax
         * default: false
        https://github.com/algolia/algoliasearch-client-js#advancedsyntax
        */
        advancedSyntax?: boolean,

        /**
         * A string that contains the comma separated list of words that should be considered as optional when found in the query
         * default: []
        https://github.com/algolia/algoliasearch-client-js#optionalwords
        */
        optionalWords?: string[],

        /**
         * Remove stop words from the query before executing it
         * default: false
        true|false: enable or disable stop words for all 41 supported languages; or
        a list of language ISO codes (as a comma-separated string) for which stop words should be enable
        https://github.com/algolia/algoliasearch-client-js#removestopwords
        */
        removeStopWords?: string[],

        /**
         * List of attributes on which you want to disable the computation of exact criteria
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableexactonattributes
        */
        disableExactOnAttributes?: string[],

        /**
         * This parameter control how the exact ranking criterion is computed when the query contains one word
         * default: attribute
        'none': no exact on single word query
        'word': exact set to 1 if the query word is found in the record
        'attribute': exact set to 1 if there is an attribute containing a string equals to the query
        https://github.com/algolia/algoliasearch-client-js#exactonsinglewordquery
        */
        exactOnSingleWordQuery?: string,

        /**
         * Specify the list of approximation that should be considered as an exact match in the ranking formula
         * default: ['ignorePlurals', 'singleWordSynonym']
        'ignorePlurals': alternative words added by the ignorePlurals feature
        'singleWordSynonym': single-word synonym (For example "NY" = "NYC")
        'multiWordsSynonym': multiple-words synonym
        https://github.com/algolia/algoliasearch-client-js#alternativesasexact
        */
        alternativesAsExact?: any,

        /**
         * If set to 1, enables the distinct feature, disabled by default, if the attributeForDistinct index setting is set.
         * https://github.com/algolia/algoliasearch-client-js#distinct
         */
        distinct?: any,

        /**
         * If set to true, the result hits will contain ranking information in the _rankingInfo attribute.
         * default: false
        https://github.com/algolia/algoliasearch-client-js#getrankinginfo
        */
        getRankingInfo?: boolean,

        /**
         * All numerical attributes are automatically indexed as numerical filters
         * default: ''
        https://github.com/algolia/algoliasearch-client-js#numericattributestoindex
        */
        numericAttributesToIndex?: string[],

        /**
         * 
         * @deprecated  please use filters instead
        A string that contains the comma separated list of numeric filters you want to apply.
        https://github.com/algolia/algoliasearch-client-js#numericfilters-deprecated
        */
        numericFilters?: string[],

        /**
         * 
         * @deprecated  * Filter the query by a set of tags.
        https://github.com/algolia/algoliasearch-client-js#tagfilters-deprecated
        */
        tagFilters?: string,

        /**
         * 
         * @deprecated  * Filter the query by a set of facets.
        https://github.com/algolia/algoliasearch-client-js#facetfilters-deprecated
        */
        facetFilters?: string,

        /**
         * If set to false, this query will not be taken into account in the analytics feature.
         * default true
        https://github.com/algolia/algoliasearch-client-js#analytics
        */
        analytics?: boolean,

        /**
         * If set, tag your query with the specified identifiers
         * default: null
        https://github.com/algolia/algoliasearch-client-js#analyticstags
        */
        analyticsTags?: string[],

        /**
         * If set to false, the search will not use the synonyms defined for the targeted index.
         * default: true
        https://github.com/algolia/algoliasearch-client-js#synonyms
        */
        synonyms?: boolean,

        /**
         * If set to false, words matched via synonym expansion will not be replaced by the matched synonym in the highlighted result.
         * default: true
        https://github.com/algolia/algoliasearch-client-js#replacesynonymsinhighlight
        */
        replaceSynonymsInHighlight?: boolean,

        /**
         * Configure the precision of the proximity ranking criterion
         * default: 1
        https://github.com/algolia/algoliasearch-client-js#minproximity
        */
        minProximity?: number
}
declare module 'algoliasearch' {
    declare module.exports: typeof algoliasearch
}
declare interface AltJS$StoreReduce {
    action: any,
        data: any
}

declare export interface AltJS$StoreModel<S>{
    bindAction(action: AltJS$Action<any>, handler: AltJS$ActionHandler): void,
    bindActions(actions: AltJS$ActionsClass): void,
    exportPublicMethods(exportConfig: any): void,
    bindListeners(config: {
        [methodName: string]: AltJS$Action<any>| AltJS$Actions
    }): void,
    exportAsync(source: AltJS$Source): void,
    registerAsync(datasource: AltJS$Source): void,
    setState(state: S): void,
    setState(stateFn: (currentState: S, nextState: S) => S): void,
    getState(): S,
    waitFor(store: AltJS$AltStore<any>): void,
    onSerialize(fn: (data: any) => any): void,
    onDeserialize(fn: (data: any) => any): void,
    on(event: AltJS$lifeCycleEvents, callback: () => any): void,
    emitChange(): void,
    waitFor(storeOrStores: AltJS$AltStore<any>| Array<AltJS$AltStore<any >> ): void,
    otherwise(data: any, action: AltJS$Action<any>): void,
    observe(alt: AltJS$Alt): any,
    reduce(state: any, config: AltJS$StoreReduce): AV$Object,
    preventDefault(): void,
    afterEach(payload: AV$Object, state: AV$Object): void,
    beforeEach(payload: AV$Object, state: AV$Object): void,
    dispatcher?: any,
    getInstance(): AltJS$AltStore<S>,
    alt?: AltJS$Alt,
    displayName?: string
}

declare export type AltJS$Source = {
    [name: string]: () => AltJS$SourceModel<any >
};

declare export interface AltJS$SourceModel<S>{
    local(state: any, ...args: any[]): any,
    remote(state: any, ...args: any[]): AV$Promise<S>,
    shouldFetch(fetchFn: (...args: Array<any>) => boolean): void,
    loading?: (args: any) => void,
    success?: (state: S) => void,
    error?: (args: any) => void,
    interceptResponse(response: any, action: AltJS$Action<any>, ...args: Array<any>): any
}

declare export interface AltJS$AltStore<S>{
    getState(): S,
    listen(handler: (state: S) => any): () => void,
    unlisten(handler: (state: S) => any): void,
    emitChange(): void
}

declare export type AltJS$Actions = {
    [action: string]: AltJS$Action<any >
};

declare type AltJS$Action = () => any;

declare export interface AltJS$ActionsClass {
    generateActions(...action: Array<string>): void,
        dispatch(...payload: Array<any>): void,
        actions?: AltJS$Actions
}

declare type AltJS$StateTransform = (store: AltJS$StoreModel<any>) => AltJS$AltStore<any>;

declare interface AltJS$AltConfig {
    dispatcher?: any,
        serialize?: (serializeFn: (data: AV$Object) => string) => void,
        deserialize?: (deserializeFn: (serialData: string) => AV$Object) => void,
        storeTransforms?: Array<AltJS$StateTransform>,
        batchingFunction?: (callback: (...data: Array<any>) => any) => void
}

declare class Alt {
    constructor(config?: AltJS$AltConfig): this;
    actions: AltJS$Actions;
    bootstrap(jsonData: string): void;
    takeSnapshot(...storeNames: Array<string>): string;
    flush(): AV$Object;
    recycle(...stores: Array<AltJS$AltStore<any >> ): void;
    rollback(): void;
    dispatch(action?: AltJS$Action<any>, data?: AV$Object, details?: any): void;
    addActions(actionsName: string, ActionsClass: AltJS$ActionsClassConstructor): void;
    createActions<T>(ActionsClass: AltJS$ActionsClassConstructor, exportObj?: AV$Object): T;
    createActions<T>(
        ActionsClass: AltJS$ActionsClassConstructor,
        exportObj?: AV$Object,
        ...constructorArgs: Array<any>): T;
    generateActions<T>(...actions: Array<string>): T;
    getActions(actionsName: string): AltJS$Actions;
    addStore(name: string, store: AltJS$StoreModel<any>, saveStore?: boolean): void;
    createStore<S>(store: AltJS$StoreModel<S>, name?: string): AltJS$AltStore<S>;
    getStore(name: string): AltJS$AltStore<any >
}

declare export interface AltJS$AltFactory {
    new(config?: AltJS$AltConfig): AltJS$Alt
}

declare type AltJS$ActionsClassConstructor = (alt: AltJS$Alt) => AltJS$ActionsClass;

declare type AltJS$ActionHandler = (...data: Array<any>) => any;

declare type AltJS$ExportConfig = {
    [key: string]: (...args: Array<any>) => any
};
declare module 'alt/utils/chromeDebug' {
    declare module.exports: typeof chromeDebug
}
declare module 'alt/AltContainer' {
    declare interface ContainerProps {
        store?: AltJS$AltStore<any>,
            stores?: Array<AltJS$AltStore<any >> ,
            inject?: {
                [key: string]: any
            },
            actions?: {
                [key: string]: AV$Object
            },
            render?: (...props: Array<any>) => React.ReactElement<any>,
            flux?: AltJS$Alt,
            transform?: (store: AltJS$AltStore<any>, actions: any) => any,
            shouldComponentUpdate?: (props: any) => boolean,
            component?: React.Component<any, any >
    }
    declare module.exports: typeof AltContainer
    declare     var AltContainer: React.ComponentClass<ContainerProps>;
}
declare module 'alt' {
    declare     var alt: AltJS$AltFactory;
    declare module.exports: typeof alt
}
declare module 'amazon-product-api' {
    declare interface ICredentials {
        awsId: string,
            awsSecret: string,
            awsTag: string
    }
    declare interface IAmazonProductQueryCallback {
        (err: string, results: AV$Object[]): void
    }
    declare interface IAmazonProductClient {
        itemSearch(query: any, callback?: IAmazonProductQueryCallback): AV$Promise<AV$Object[]>,
            itemLookup(query: any, callback?: IAmazonProductQueryCallback): AV$Promise<AV$Object[]>,
            browseNodeLookup(query: any, callback?: IAmazonProductQueryCallback): AV$Promise<AV$Object[] >
    }
    declare     export function createClient(credentials: ICredentials): IAmazonProductClient
}

declare var npm$namespace$AmCharts: {
    clear: typeof AmCharts$clear,
    ready: typeof AmCharts$ready,
    makeChart: typeof AmCharts$makeChart,
    addInitHandler: typeof AmCharts$addInitHandler,
}
declare var baseHref: boolean;

declare var dayNames: string[];

declare var monthNames: string[];

declare var shortDayNames: string[];

declare var shortMonthNames: string[];

declare var useUTC: boolean;

declare var themes: any;


/**
 * Clears all the charts on page, removes listeners and intervals. 
 */
declare function AmCharts$clear(): void


/**
 * Handle ready event 
 */
declare function AmCharts$ready(Function: << UNKNOWN PARAM FORMAT >> ): void


/**
 * Create chart by params. 
 */
declare function AmCharts$makeChart(selector: string, params: any, delay?: number): AmCharts$AmChart


/**
 * Set a method to be called before initializing the chart.
 * When the method is called, the chart instance is passed as an attribute.
You can use this feature to preprocess chart data or do some other things you need
before initializing the chart.
 * @param  - The method to be called.
 * @param  - Which chart types should call this method. Defaults to all
if none is passed.
*/
declare function AmCharts$addInitHandler(handler: Function, types: string[]): void


/**
 * AmPieChart class creates pie/donut chart. In order to display pie chart you need to set at least three properties - dataProvider, titleField and valueField.
 * @example  var chartData = [{title:"Pie I have eaten",value:70},{title:"Pie I haven\'t eaten",value:30}];
var chart = new AmCharts.AmPieChart();
chart.valueField = "value";
chart.titleField = "title";
chart.dataProvider = chartData;
chart.write("chartdiv");
*/
declare class AmPieChart mixins AmChart {

    /**
     * Name of the field in chart's dataProvider which holds slice's alpha. 
     */
    alphaField: string;

    /**
     * Pie lean angle (for 3D effect). Valid range is 0 - 90. 
     */
    angle: number;

    /**
     * Balloon text. The following tags can be used: [[value]], [[title]], [[percents]], [[description]]. [[title]]: [[percents]]% ([[value]])\n[[description]] 
     */
    balloonText: string;

    /**
     * Read-only. Array of Slice objects. 
     */
    chartData: any[];

    /**
     * Name of the field in chart's dataProvider which holds slice's color. 
     */
    colorField: string;

    /**
     * Specifies the colors of the slices, if the slice color is not set. If there are more slices than colors in this array, the chart picks random color. ["#FF0F00", "#FF6600", "#FF9E01", "#FCD202", "#F8FF01", "#B0DE09", "#04D215", "#0D8ECF", "#0D52D1", "#2A0CD0", "#8A0CCF", "#CD0D74", "#754DEB", "#DDDDDD", "#999999", "#333333", "#000000", "#57032A", "#CA9726", "#990000", "#4B0C25"] 
     */
    colors: any[];

    /**
     * Depth of the pie (for 3D effect). 
     */
    depth3D: number;

    /**
     * Name of the field in chart's dataProvider which holds a string with description. 
     */
    descriptionField: string;

    /**
     * Example: [-0.2,0.2]. Will make slices to be filled with color gradients. 
     */
    gradientRatio: number[];

    /**
     * Opacity of the group slice. Value range is 0 - 1.
     * @default  1
     */
    groupedAlpha: number;

    /**
     * Color of the group slice. The default value is not set - this means the next available color from "colors" array will be used. 
     */
    groupedColor: string;

    /**
     * Description of the group slice. 
     */
    groupedDescription: string;

    /**
     * If this is set to true, the group slice will be pulled out when the chart loads. 
     */
    groupedPulled: boolean;

    /**
     * Title of the group slice. Other 
     */
    groupedTitle: string;

    /**
     * If there is more than one slice whose percentage of the pie is less than this number, those slices will be grouped together into one slice. This is the "other" slice. It will always be the last slice in a pie. 
     */
    groupPercent: number;

    /**
     * Slices with percent less then hideLabelsPercent won't display labels This is useful to avoid cluttering up the chart, if you have a lot of small slices. 0 means all labels will be shown. 
     */
    hideLabelsPercent: number;

    /**
     * Opacity of a hovered slice. Value range is 0 - 1.
     * @default  1
     */
    hoverAlpha: number;

    /**
     * Inner radius of the pie, in pixels or percents. 
     */
    innerRadius: any;

    /**
     * The distance between the label and the slice, in pixels. You can use negative values to put the label on the slice.
     * @default  30
     */
    labelRadius: number;

    /**
     * Name of the field in dataProvider which specifies the length of a tick. Note, the chart will not try to arrange labels automatically if this property is set. 
     */
    labelRadiusField: string;

    /**
     * Specifies whether data labels are visible.
     * @default  true
     */
    labelsEnabled: boolean;

    /**
     * Label text. The following tags can be used: [[value]], [[title]], [[percents]], [[description]]. [[title]]: [[percents]]% 
     */
    labelText: string;

    /**
     * Label tick opacity. Value range is 0 - 1. 0.2 
     */
    labelTickAlpha: number;

    /**
     * Label tick color. #000000 
     */
    labelTickColor: string;

    /**
     * Bottom margin of the chart.
     * @default  5
     */
    marginBottom: number;

    /**
     * Left margin of the chart. 
     */
    marginLeft: number;

    /**
     * Right margin of the chart. 
     */
    marginRight: number;

    /**
     * Top margin of the chart.
     * @default  5
     */
    marginTop: number;

    /**
     * Minimum radius of the pie, in pixels.
     * @default  10
     */
    minRadius: number;

    /**
     * Pie outline opacity. Value range is 0 - 1. 
     */
    outlineAlpha: number;

    /**
     * Pie outline color. #FFFFFF 
     */
    outlineColor: string;

    /**
     * Pie outline thickness.
     * @default  1
     */
    outlineThickness: number;

    /**
     * Opacity of the slices. You can set the opacity of individual slice too.
     * @default  1
     */
    pieAlpha: number;

    /**
     * Color of the first slice. All the other will be colored with darker or brighter colors. 
     */
    pieBaseColor: string;

    /**
     * Lightness increase of each subsequent slice. This is only useful if pieBaseColor is set. Use negative values for darker colors. Value range is from -255 to 255.
     * @default  30
     */
    pieBrightnessStep: number;

    /**
     * You can set fixed position of a pie center, in pixels or in percents. 
     */
    pieX: any;

    /**
     * You can set fixed position of a pie center, in pixels or in percents. 
     */
    pieY: any;

    /**
     * Name of the field in chart's dataProvider which holds a boolean value telling the chart whether this slice must be pulled or not. 
     */
    pulledField: string;

    /**
     * Pull out duration, in seconds.
     * @default  1
     */
    pullOutDuration: number;

    /**
     * Pull out effect. Possible values are ">", "<", elastic" and "bounce". bounce 
     */
    pullOutEffect: string;

    /**
     * If this is set to true, only one slice can be pulled out at a time. If the viewer clicks on a slice, any other pulled-out slice will be pulled in. 
     */
    pullOutOnlyOne: boolean;

    /**
     * Pull out radius, in pixels or percents 0.2 
     */
    pullOutRadius: any;

    /**
     * Radius of a pie, in pixels or percents. By default, radius is calculated automatically. 
     */
    radius: any;

    /**
     * Specifies whether the animation should be sequenced or all slices should appear at once. 
     */
    sequencedAnimation: boolean;

    /**
     * Initial opacity of all slices. If you set startDuration higher than 0, slices will fade in from startAlpha.
     * @default  1
     */
    startAlpha: number;

    /**
     * Angle of the first slice, in degrees. This will work properly only if "depth3D" is set to 0. If "depth3D" is greater than 0, then there can be two angles only: 90 and 270. Value range is 0-360.
     * @default  90
     */
    startAngle: number;

    /**
     * Duration of the animation, in seconds.
     * @default  1
     */
    startDuration: number;

    /**
     * Animation effect. Possible values are ">", "<", "elastic" and "bounce". bounce 
     */
    startEffect: string;

    /**
     * Radius of the positions from which the slices will fly in.
     * default 5
     */
    startRadius: any;

    /**
     * Name of the field in chart's dataProvider which holds slice's title. 
     */
    titleField: string;

    /**
     * Name of the field in chart's dataProvider which holds url which would be accessed if the user clicks on a slice. 
     */
    urlField: string;

    /**
     * If url is specified for a slice, it will be opened when user clicks on it. urlTarget specifies target of this url. Use _blank if you want url to be opened in a new window. _self 
     */
    urlTarget: string;

    /**
     * Name of the field in chart's dataProvider which holds slice's value. 
     */
    valueField: string;

    /**
     * Name of the field in chart's dataProvider which holds boolean variable defining whether this data item should have an entry in the legend. 
     */
    visibleInLegendField: string;

    /**
     * You can trigger the animation of the pie chart. 
     */
    animateAgain(): void;

    /**
     * You can trigger the click on a slice from outside. index - the number of a slice or Slice object. 
     */
    clickSlice(index: number): void;

    /**
     * Hides slice. index - the number of a slice or Slice object. 
     */
    hideSlice(index: number): void;

    /**
     * You can simulate roll-out of a slice from outside. index - the number of a slice or Slice object. 
     */
    rollOutSlice(index: number): void;

    /**
     * You can simulate roll-over a slice from outside. index - the number of a slice or Slice object. 
     */
    rollOverSlice(index: number): void;

    /**
     * Shows slice. index - the number of a slice or Slice object. 
     */
    showSlice(index: number): void
}


/**
 * AmRadarChart is the class you have to use for radar and polar chart types.
 * @example  var chart;
var chartData = [
{country:"Czech Republic",litres:156.90},
{country:"Ireland",litres:131.10},
{country:"Germany",litres:115.80},
{country:"Australia",litres:109.90},
{country:"Austria",litres:108.30},
{country:"UK",litres:99.00}
];
window.onload = function() {
chart = new AmCharts.AmRadarChart();
chart.dataProvider = chartData;
chart.categoryField = "country";
chart.startDuration = 2;
var valueAxis = new AmCharts.ValueAxis();
valueAxis.axisAlpha = 0.15;
valueAxis.minimum = 0;
valueAxis.dashLength = 3;
valueAxis.axisTitleOffset = 20;
valueAxis.gridCount = 5;
chart.addValueAxis(valueAxis);
var graph = new AmCharts.AmGraph();
graph.valueField = "litres";
graph.bullet = "round";
graph.balloonText = "[[value]] litres of beer per year"
chart.addGraph(graph);
chart.write("chartdiv");
}
*/
declare class AmRadarChart mixins AmCoordinateChart {

    /**
     * Bottom margin of the chart. 
     */
    marginBottom: number;

    /**
     * Left margin of the chart. 
     */
    marginLeft: number;

    /**
     * Right margin of the chart. 
     */
    marginRight: number;

    /**
     * Top margin of the chart. 
     */
    marginTop: number;

    /**
     * Radius of a radar. 0.35 
     */
    radius: any
}


/**
 * AmXYChart is the class you have to use for XY/Bubble/Scatter chart types. The chart supports simple and logarithmic scales, it can have multiple value axes.
 * @example  var chartData = [
{x:10, y:14, value:59},
{x:5, y:3, value:50},
{x:-10, y:-3, value:19},
{x:-6, y:5, value:65},
{x:15, y:-4, value:92},
{x:13, y:1, value:8},
{x:1, y:6, value:35}
];
var chart = new AmCharts.AmXYChart();
chart.pathToImages = "../../amcharts/javascript/images/";
chart.dataProvider = chartData;
chart.marginLeft = 35;
chart.startDuration = 1.5;
var xAxis = new AmCharts.ValueAxis();
xAxis.position = "left";
xAxis.autoGridCount = true;
chart.addValueAxis(xAxis);
var yAxis = new AmCharts.ValueAxis();
yAxis.position = "bottom";
yAxis.autoGridCount = true;
chart.addValueAxis(yAxis);
var graph = new AmCharts.AmGraph();
graph.valueField = "value";
graph.xField = "x";
graph.yField = "y";
graph.lineAlpha = 0;
graph.bullet = "round";
chart.addGraph(graph);
var chartCursor = new AmCharts.ChartCursor();
chart.addChartCursor(chartCursor);
var chartScrollbar = new AmCharts.ChartScrollbar();
chartScrollbar.hideResizeGrips = false;
chart.addChartScrollbar(chartScrollbar);
chart.write("chartdiv);
*/
declare class AmXYChart mixins AmRectangularChart {

    /**
     * Specifies if Scrollbar of X axis (horizontal) should be hidden. 
     */
    hideXScrollbar: boolean;

    /**
     * Specifies if Scrollbar of Y axis (vertical) should be hidden. 
     */
    hideYScrollbar: boolean;

    /**
     * Maximum zoom factor of the chart.
     * @default  20
     */
    maxZoomFactor: number;

    /**
     * Zooms out, charts shows all available data.
     */
    zoomOut(): void
}


/**
 * Guides are straight vertical or horizontal lines or areas supported by AmSerialChart, AmXYChart and AmRadarChart. You can have guides both on value and category axes. To add/remove a guide to an axis, use axis.addGuide(guide)/axis.removeGuide(guide) methods.
 * 
Ifyoudo not set properties such as dashLength, lineAlpha, lineColor, etc - values of the axis are used.
*/
declare class Guide {

    /**
     * If you set it to true, the guide will be displayed above the graphs. 
     */
    above: boolean;

    /**
     * Radar chart only. Specifies angle at which guide should start. Affects only fills, not lines. 
     */
    angle: number;

    /**
     * Baloon fill color. 
     */
    balloonColor: string;

    /**
     * The text which will be displayed if the user rolls-over the guide. 
     */
    balloonText: string;

    /**
     * Specifies if label should be bold or not. 
     */
    boldLabel: boolean;

    /**
     * Category of the guide (in case the guide is for category axis). 
     */
    category: string;

    /**
     * Dash length. 
     */
    dashLength: number;

    /**
     * Date of the guide (in case the guide is for category axis and parseDates is set to true). 
     */
    date: Date;

    /**
     * Works if a guide is added to CategoryAxis and this axis is non-date-based. If you set it to true, the guide will start (or be placed, if it's not a fill) on the beginning of the category cell and will end at the end of toCategory cell. 
     */
    expand: boolean;

    /**
     * Fill opacity. Value range is 0 - 1. 
     */
    fillAlpha: number;

    /**
     * Fill color. 
     */
    fillColor: string;

    /**
     * Font size of guide label. 
     */
    fontSize: string;

    /**
     * Unique id of a Guide. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Specifies whether label should be placed inside or outside plot area. 
     */
    inside: boolean;

    /**
     * The label which will be displayed near the guide. 
     */
    label: string;

    /**
     * Rotation angle of a guide label. 
     */
    labelRotation: number;

    /**
     * Line opacity. 
     */
    lineAlpha: number;

    /**
     * Line color. 
     */
    lineColor: string;

    /**
     * Line thickness. 
     */
    lineThickness: number;

    /**
     * Position of guide label. Possible values are "left" or "right" for horizontal axis and "top" or "bottom" for vertical axis.  
     */
    position: string;

    /**
     * Tick length. 
     */
    tickLength: number;

    /**
     * Radar chart only. Specifies angle at which guide should end. Affects only fills, not lines. 
     */
    toAngle: number;

    /**
     * To category of the guide (in case the guide is for category axis). 
     */
    toCategory: string;

    /**
     * To date of the guide (in case the guide is for category axis and parseDates is set to true) If you have both date and toDate, the space between these two dates can be filled with color. 
     */
    toDate: Date;

    /**
     * To value of the guide (in case the guide is for value axis). 
     */
    toValue: number;

    /**
     * Value of the guide (in case the guide is for value axis). 
     */
    value: number;

    /**
     * Value axis of a guide. As you can add guides directly to the chart, you might need to specify which which value axis should be used. 
     */
    valueAxis: AmCharts$ValueAxis
}


/**
 * ImagesSettings is a class which holds common settings of all MapImage objects. 
 */
declare class ImagesSettings {

    /**
     * Opacity of the image.
     * @default  1
     */
    alpha: number;

    /**
     * Text which is displayed in a roll-over balloon. You can use the following tags: [[title]], [[description]], [[value]] and [[percent]]. [[title]] 
     */
    balloonText: string;

    /**
     * Specifies if the image's center should be placed in the provided coordinates. If false, top-left corner will be at provided coordinates.
     * @default  true
     */
    centered: boolean;

    /**
     * Color of image. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. #000000 
     */
    color: string;

    /**
     * Height of a description window. 
     */
    descriptionWindowHeight: number;

    /**
     * Width of a description window.
     * @default  250
     */
    descriptionWindowWidth: number;

    /**
     * X position of a description window. 
     */
    descriptionWindowX: number;

    /**
     * Y position of a description window. 
     */
    descriptionWindowY: number;

    /**
     * Label color. #000000 
     */
    labelColor: string;

    /**
     * Font size of a label.
     * @default  11
     */
    labelfontSize: string;

    /**
     * Position of the label. Allowed values are: left, right, top, bottom and middle. right 
     */
    labelPosition: string;

    /**
     * Label roll-over color. #00CC00 
     */
    labelRollOverColor: string;

    /**
     * Opacity of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    outlineAlpha: number;

    /**
     * Color of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    outlineColor: string;

    /**
     * Thickness of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images.
     * @default  1
     */
    outlineThickness: number;

    /**
     * Color of image when hovered. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    rollOverColor: string;

    /**
     * Scale of the image when hovered. Use value like 1.5 - 2 to enlarge image when user rolls-over it.
     * @default  1
     */
    rollOverScale: number;

    /**
     * Scale of the image if it is selected. Use value like 1.5 - 2 to enlarge selected image.
     * @default  1
     */
    selectedScale: number
}


/**
 * AreasSettings is a class which holds common settings of all MapArea objects. 
 */
declare class AreasSettings {

    /**
     * Opacity of areas.
     * @default  1
     */
    alpha: number;

    /**
     * Specifies if the areas should be zoomed-in when user clicks on them, event if zoom properties are not set. 
     */
    autoZoom: boolean;

    /**
     * Text which is displayed in a roll-over balloon. You can use the following tags: [[title]], [[description]], [[value]] and [[percent]] [[title]] 
     */
    balloonText: string;

    /**
     * Color of the areas. #FFCC00 
     */
    color: string;

    /**
     * Color of area with highest value. Colors for areas with values less then highest will be colored with intermediate colors between color and colorSolid. Use colorSteps property of AmMap to change the number of intermediate colors. #990000 
     */
    colorSolid: string;

    /**
     * Height of a description window. 
     */
    descriptionWindowHeight: number;

    /**
     * Width of a description window.
     * @default  250
     */
    descriptionWindowWidth: number;

    /**
     * X position of a description window. 
     */
    descriptionWindowX: number;

    /**
     * Y position of a description window. 
     */
    descriptionWindowY: number;

    /**
     * Opacity of area's outline.
     * @default  1
     */
    outlineAlpha: number;

    /**
     * Color of area's outline. #FFFFFF 
     */
    outlineColor: string;

    /**
     * Thickness of area's outline. 0.5 
     */
    outlineThickness: number;

    /**
     * Color of area when user rolls-over it. undefined 
     */
    rollOverColor: string;

    /**
     * Color of area's outline when user rolls-over it. #CC0000 
     */
    rollOverOutlineColor: string;

    /**
     * Color of area which is currently selected. #CC0000 
     */
    selectedColor: string;

    /**
     * Opacity of all areas which are in the map svg file, but not listed as areas in DataSet.
     * @default  1
     */
    unlistedAreasAlpha: number;

    /**
     * Color of all areas which are in the map svg file, but not listed as areas in DataSet. #DDDDDD 
     */
    unlistedAreasColor: string;

    /**
     * Opacity of all areas' outline which are in the map svg file, but not listed as areas in DataSet.
     * @default  1
     */
    unlistedAreasOutlineAlpha: number;

    /**
     * Color of all areas' outline which are in the map svg file, but not listed as areas in DataSet. #FFFFFF 
     */
    unlistedAreasOutlineColor: string
}


/**
 * Slice is an item of AmPieChart's chartData Array and holds all the information about the slice. When working with a pie chart, you do not create slices or change it's properties directly, instead you set array of data using dataProvider property. Consider properties of a Slice read-only - change values in chart's data provider if you need to. 
 */
declare class Slice {

    /**
     * Opacity of a slice. 
     */
    alpha: number;

    /**
     * Color of a slice. 
     */
    color: string;

    /**
     * Original object from data provider. 
     */
    dataContext: AV$Object;

    /**
     * Slice description. 
     */
    description: string;

    /**
     * Specifies whether the slice is hidden 
     */
    hidden: boolean;

    /**
     * Percent value of a slice. 
     */
    percents: number;

    /**
     * Specifies whether the slice is pulled or not. 
     */
    pulled: boolean;

    /**
     * Slice title 
     */
    title: string;

    /**
     * Url of a slice 
     */
    url: string;

    /**
     * Value of a slice 
     */
    value: number;

    /**
     * specifies whether this slice has a legend entry 
     */
    visibleInLegend: boolean
}


/**
 * AmStockChart is a main class Stock chart. 
 */
declare class AmStockChart {

    /**
     * Specifies if animation was already played. Animation is only played once, when chart is rendered for the first time. If you want the animation to be repeated, set this property to false. 
     */
    animationPlayed: boolean;

    /**
     * Balloon object. 
     */
    balloon: AmCharts$AmBalloon;

    /**
     * Settings for category axes. 
     */
    categoryAxesSettings: AmCharts$CategoryAxesSettings;

    /**
     * Indicates if the chart is created. 
     */
    chartCreated: boolean;

    /**
     * Chart cursor settings. 
     */
    chartCursorSettings: AmCharts$ChartCursorSettings;

    /**
     * Chart scrollbar settings. 
     */
    chartScrollbarSettings: AmCharts$ChartScrollbarSettings;

    /**
     * Array of colors used by data sets if no color was set explicitly on data set itself. #FF6600, "#FCD202", "#B0DE09", "#0D8ECF", "#2A0CD0", "#CD0D74", "#CC0000", "#00CC00", "#0000CC", "#DDDDDD", "#999999", "#333333", "#990000" 
     */
    colors: any[];

    /**
     * Array of data sets selected for comparing. 
     */
    comparedDataSets: any[];

    /**
     * Array of DataSets. 
     */
    dataSets: any[];

    /**
     * DataSetSelector object. You can add it if you have more than one data set and want users to be able to select/compare them. 
     */
    dataSetSelector: AmCharts$DataSetSelector;

    /**
     * Current end date of the selected period, get only. To set start/end dates, use stockChart.zoom(startDate, endDate) method. 
     */
    endDate: Date;

    /**
     * Defines on which day week starts. 0 - Sunday, 1 - Monday..
     * @default  1 
     */
    firstDayOfWeek: number;

    /**
     * If set to true the scope of the data view will be set to the end after data update. 
     */
    glueToTheEnd: boolean;

    /**
     * Legend settings. 
     */
    legendSettings: AmCharts$LegendSettings;

    /**
     * Data set selected as main. 
     */
    mainDataSet: AmCharts$DataSet;

    /**
     * Array of StockPanels (charts). 
     */
    panels: any[];

    /**
     * Settings for stock panels. 
     */
    panelsSettings: AmCharts$PanelsSettings;

    /**
     * Period selector object. You can add it if you want user's to be able to enter date ranges or zoom chart with predefined period buttons. 
     */
    periodSelector: AmCharts$PeriodSelector;

    /**
     * Scrollbar's chart object, get only. 
     */
    scrollbarChart: AmCharts$AmSerialChart;

    /**
     * Current start date of the selected period, get only. To set start/end dates, use stockChart.zoom(startDate, endDate) method. 
     */
    startDate: Date;

    /**
     * Settings for stock events. 
     */
    stockEventsSettings: any;

    /**
     * Settings for value axes. 
     */
    valueAxesSettings: AmCharts$ValueAxesSettings;

    /**
     * read-only. Indicates current version of a script. 
     */
    version: string;

    /**
     * Specifies whether the chart should zoom-out when main data set is changed. 
     */
    zoomOutOnDataSetChange: boolean;

    /**
     * Adds panel to the stock chart. Requires stockChart.validateNow() method to be called after this action. 
     */
    addPanel(panel: AmCharts$StockPanel): void;

    /**
     * Adds panel to the stock chart at a specified index. Requires stockChart.validateNow() method to be called after this action. 
     */
    addPanelAt(panel: AmCharts$StockPanel, index: number): void;

    /**
     * Destroys chart, all timeouts and listeners. 
     */
    clear(): void;

    /**
     * Hides event bullets. 
     */
    hideStockEvents(): void;

    /**
     * Removes event listener from the object. 
     */
    removeListener(obj: any, type: string, handler: any): void;

    /**
     * Removes panel from the stock chart. Requires stockChart.validateNow() method to be called after this action. 
     */
    removePanel(panel: AmCharts$StockPanel): void;

    /**
     * Shows event bullets. 
     */
    showStockEvents(): void;

    /**
     * Method which should be called after data was changed. 
     */
    validateData(): void;

    /**
     * Method which forces the stock chart to rebuild. Should be called after properties are changed. 
     */
    validateNow(): void;

    /**
     * Zooms chart to specified dates. startDate, endDate - Date objects. 
     */
    zoom(startDate: Date, endDate: Date): void;

    /**
     * Zooms out the chart. 
     */
    zoomOut(): void;

    /**
     * Adds event listener of the type "dataUpdated" or "init" or "rendered" to the object.
     * @param type Always "dataUpdated" or "init" or "rendered".
     * @param handler If the type is "dataUpdated", dispatched when the chart was updated with new data.
    If the type is "init", dispatched when the chart is initialized for the first time. In case you want it to fire again after validateNow() method is called, set chart.chartCreated = false.
    If the type is "rendered", dispatched each when chart is rendered.
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "dataUpdated" or "init". 
                 */
                type: string,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "rollOutStockEvent" or "rollOverStockEvent" or "clickStockEvent" to the object.
     * @param type // Either "rollOutStockEvent" or "rollOverStockEvent" or "clickStockEvent".
     * @param handler If the type is "rollOutStockEvent", dispatched when the user rolls-out of the Stock event (bullet).
    If the type is "rollOverStockEvent", dispatched when the user rolls-over of the Stock event (bullet).
    If the type is "clickStockEvent", dispatched when the user clicks on the Stock event (bullet).
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "rollOverStockEvent". 
                 */
                type: string,
                eventObject: any,
                graph: AmCharts$AmGraph,
                date: Date,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "zoomed" to the object.
     * @param type Always "zoomed".
     * @param handler Dispatched when the chart is zoomed (even for the first time, when chart is initialized).
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "zoomed". 
                 */
                type: string,
                startDate: Date,
                endDate: Date,
                period: string,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "panelRemoved" to the object.
     * @param type Always "panelRemoved".
     * @param handler Dispatched when the StockPanel is removed.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "panelRemoved". 
                 */
                type: string,
                panel: AmCharts$StockPanel,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * ValueAxesSettings settings set 's settings for all ValueAxes. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of ValueAxis class will be used. 
 */
declare class ValueAxesSettings {

    /**
     * Specifies whether number for gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. 
     */
    axisAlpha: number;

    /**
     * Axis color.  
     */
    axisColor: string;

    /**
     * Thickness of the axis. 
     */
    axisThickness: number;

    /**
     * Label color. 
     */
    color: string;

    /**
     * Length of a dash. By default, the grid line is not dashed. 
     */
    dashLength: number;

    /**
     * Fill opacity. Every second space between grid lines can be filled with color. 
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. 
     */
    fillColor: string;

    /**
     * Opacity of grid lines. 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. 
     */
    gridColor: string;

    /**
     * Approximate number of grid lines. autoGridCount should be set to false, otherwise this property will be ignored. 
     */
    gridCount: number;

    /**
     * Thickness of grid lines. 
     */
    gridThickness: number;

    /**
     * Specifies whether guide values should be included when calculating min and max of the axis. 
     */
    includeGuidesInMinMax: boolean;

    /**
     * If true, the axis will include hidden graphs when calculating min and max values. 
     */
    includeHidden: boolean;

    /**
     * Specifies whether values should be placed inside or outside plot area. In case you set this to false, you'll have to adjust marginLeft or marginRight in [[PanelsSettings]] in order labels to be visible.
     * @default  true
     */
    inside: boolean;

    /**
     * Specifies whether values on axis can only be integers or both integers and doubles. 
     */
    integersOnly: boolean;

    /**
     * Frequency at which labels should be placed.  
     */
    labelFrequency: number;

    /**
     * Specifies whether value labels are displayed. 
     */
    labelsEnabled: boolean;

    /**
     * Set to true if value axis is logarithmic, false otherwise. 
     */
    logarithmic: boolean;

    /**
     * The distance of the axis to the plot area, in pixels. Useful if you have more then one axis on the same side.  
     */
    offset: number;

    /**
     * Position of the value axis. Possible values are "left" and "right". 
     */
    position: string;

    /**
     * Set to true if value axis is reversed (smaller values on top), false otherwise. 
     */
    reversed: boolean;

    /**
     * Specifies if first label of value axis should be displayed. 
     */
    showFirstLabel: boolean;

    /**
     * Specifies if last label of value axis should be displayed. 
     */
    showLastLabel: boolean;

    /**
     * Stacking mode of the axis. Possible values are: "none", "regular", "100%", "3d". 
     */
    stackType: string;

    /**
     * Tick length. 
     */
    tickLength: number;

    /**
     * Unit which will be added to the value label.  
     */
    unit: string;

    /**
     * Position of the unit. Possible values are "left" or "right". 
     */
    unitPosition: string
}


/**
 * AmLegend is the class that displays legend of the chart. Legend to the chart should be added using chart.addLegend(legend) method.
 * @example  var chart = new AmCharts.AmSerialChart();
var legend = new AmCharts.AmLegend();
chart.addLegend(legend);
*/
declare class AmLegend {

    /**
     * Alignment of legend entries. Possible values are: "left", "center", "right". left 
     */
    align: string;

    /**
     * Used if chart is Serial or XY. In case true, margins of the legend are adjusted and made equal to chart's margins.
     * @default  true
     */
    autoMargins: boolean;

    /**
     * Opacity of legend's background. Value range is 0 - 1 
     */
    backgroundAlpha: number;

    /**
     * Background color. You should set backgroundAlpha to >0 vallue in order background to be visible. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * Opacity of chart's border. Value range is 0 - 1. 
     */
    borderAlpha: number;

    /**
     * Color of legend's border. You should set borderAlpha >0 in order border to be visible. #000000 
     */
    borderColor: string;

    /**
     * In case legend position is set to "absolute", you can set distance from bottom of the chart, in pixels.  
     */
    bottom: number;

    /**
     * Text color. Will use chart's color if not set. 
     */
    color: string;

    /**
     * This can be used by AmMap only. You can pass array of objects with title, color, markerType values, for example: [{title: "One", color: "#3366CC"},{title: "Two", color: "#FFCC33"}] 
     */
    data: any[];

    /**
     * Specifies if each of legend entry should be equal to the most wide entry. Won't look good if legend has more than one line.
     * @default  true
     */
    equalWidths: boolean;

    /**
     * Font size. Will use chart's font size if not set. 
     */
    fontSize: string;

    /**
     * Horizontal space between legend item and left/right border. 
     */
    horizontalGap: number;

    /**
     * The text which will be displayed in the legend. Tag [[title]] will be replaced with the title of the graph. [[title]] 
     */
    labelText: string;

    /**
     * In case legend position is set to "absolute", you can set distance from left side of the chart, in pixels. 
     */
    left: number;

    /**
     * Bottom margin.  
     */
    marginBottom: number;

    /**
     * Left margin. This property will be ignored if chart is Serial or XY and autoMargins property of the legend is true (default).
     * @default  20
     */
    marginLeft: number;

    /**
     * Right margin. This property will be ignored if chart is Serial or XY and autoMargins property of the legend is true (default).
     * @default  20
     */
    marginRight: number;

    /**
     * Top margin. 
     */
    marginTop: number;

    /**
     * Marker border opacity 1. 
     */
    markerBorderAlpha: number;

    /**
     * Marker border color. If not set, will use the same color as marker. 
     */
    markerBorderColor: string;

    /**
     * Thickness of the legend border. The default value (0) means the line will be a "hairline" (1 px). In case marker type is line, this style will be used for line thickness.
     * @default  1
     */
    markerBorderThickness: number;

    /**
     * The color of the disabled marker (when the graph is hidden). #AAB3B3 
     */
    markerDisabledColor: string;

    /**
     * Space between legend marker and legend text, in pixels.
     * @default  5
     */
    markerLabelGap: number;

    /**
     * Size of the legend marker (key).
     * @default  16
     */
    markerSize: number;

    /**
     * Shape of the legend marker (key). Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble", "none". square 
     */
    markerType: string;

    /**
     * Maximum number of columns in the legend. If Legend's position is set to "right" or "left", maxColumns is automatically set to 1. 
     */
    maxColumns: number;

    /**
     * Position of a legend. Possible values are: "bottom", "top", "left", "right" and "absolute". In case "absolute", you should set left and top properties too. (this setting is ignored in Stock charts). In case legend is used with AmMap, position is set to "absolute" automatically.  bottom 
     */
    position: string;

    /**
     * Specifies whether legend entries should be placed in reversed order. 
     */
    reversedOrder: boolean;

    /**
     * In case legend position is set to "absolute", you can set distance from right side of the chart, in pixels. 
     */
    right: number;

    /**
     * Legend item text color on roll-over.  #CC0000 
     */
    rollOverColor: string;

    /**
     * When you roll-over the legend entry, all other graphs can reduce their opacity, so that the graph you rolled-over would be distinguished. This style specifies the opacity of the graphs.
     * @default  1
     */
    rollOverGraphAlpha: number;

    /**
     * You can use this property to turn all the legend entries off.
     * @default  true
     */
    showEntries: boolean;

    /**
     * Horizontal space between legend items, in pixels.
     * @default  10
     */
    spacing: number;

    /**
     * Whether showing/hiding of graphs by clicking on the legend marker is enabled or not. In case legend is used with AmMap, this is set to false automatically.
     * @default  true
     */
    switchable: boolean;

    /**
     * Legend switch color. #FFFFFF 
     */
    switchColor: string;

    /**
     * Legend switch type (in case the legend is switchable). Possible values are "x" and "v". x 
     */
    switchType: string;

    /**
     * If true, clicking on the text will show/hide balloon of the graph. Otherwise it will show/hide graph/slice, if switchable is set to true.  
     */
    textClickEnabled: boolean;

    /**
     * In case legend position is set to "absolute", you can set distance from top of the chart, in pixels. 
     */
    top: number;

    /**
     * Legend markers can mirror graph’s settings, displaying a line and a real bullet as in the graph itself.
     * Setthis property to true if you want to enable this feature. Note, if you set graph colors in dataProvider, they will not be reflected in the marker.
     * @default  false
     */
    useGraphSettings: boolean;

    /**
     * Specifies if legend labels should be use same color as corresponding markers. 
     */
    useMarkerColorForLabels: boolean;

    /**
     * Alignment of the value text. Possible values are "left" and "right". right 
     */
    valueAlign: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. [[value]] 
     */
    valueText: string;

    /**
     * Width of the value text.
     * @default  80
     */
    valueWidth: number;

    /**
     * Vertical space between legend items also between legend border and first and last legend row.  10 
     */
    verticalGap: number;

    /**
     * Adds event listener of the type "clickLabel" or "clickMarker" or "hideItem" to the object.
     * @param type Either "clickLabel" or "clickMarker" or "hideItem".
     * @param handler If the type is "clickLabel", dispatched when legend label is clicked.
    If the type is "clickMarker", dispatched when legend marker is clicked.
    If the type is "hideItem", dispatched when user clicks on a legend item marker and hides corresponding object.
    If the type is "rollOutItem", dispatched when user rolls-out of the legend item label (or whole item, if switchable is set to false).
    If the type if "rollOverItem", dispatched when user rolls-over the legend item label (or whole item, if switchable is set to false).
    If the type is "rollOutMarker", dispatched when user clicks out of a legend item marker and shows corresponding object.
    If the type if "rollOverMarker", dispatched when user clicks on a legend item marker and shows corresponding object.Adds event listener of the type "showItem" to the object.
     * @param type Always "showItem".
     * @param handler 
    */
    addListener(
        type: string,
        handler: (e: {
            type: string,
            dataItem: AV$Object,
            chart: AmCharts$AmChart
        }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * StockLegend is a legend of StockPanel. 
 */
declare class StockLegend mixins AmLegend {

    /**
     * The text which will be displayed in the value portion of the legend when graph is comparable and at least one dataSet is selected for comparing. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents.value/open/close/low/high]], [[description]]. [[percents.value]]% 
     */
    valueTextComparing: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]].  [[value]] 
     */
    valueTextRegular: string
}


/**
 * StockPanel class creates stock panels (charts). AmStockChart can have multiple Stock panels. 
 */
declare class StockPanel mixins AmSerialChart {

    /**
     * Specifies whether x button will be displayed near the panel. This button allows turning panel off. 
     */
    allowTurningOff: boolean;

    /**
     * If true, drawing icons will be displayed in top-right corner. 
     */
    drawingIconsEnabled: boolean;

    /**
     * Specifies on which value axis user can draw trend lines. Set drawingIconsEnabled to true if you want drawing icons to be visible. First value axis will be used if not set here. 
     */
    drawOnAxis: AmCharts$ValueAxis;

    /**
     * Specifies if all trend lines should be erased when erase button is clicked. If false, trend lines can be erased one by one. 
     */
    eraseAll: boolean;

    /**
     * Size of trend line drawing icons. If you change this size, you should update icon images if you want them to look properly.
     * @default  18
     */
    iconSize: number;

    /**
     * Relative height of panel. Possible values 0 - 100. 
     */
    percentHeight: number;

    /**
     * Specifies when values should be recalculated to percents. Possible values are: "never", "always", "whenComparing".  whenComparing 
     */
    recalculateToPercents: string;

    /**
     * Specifies whether this panel will show category axis.
     * @default  true
     */
    showCategoryAxis: boolean;

    /**
     * 
     */
    stockGraphs: AmCharts$StockGraph[];

    /**
     * Stock chart legend. 
     */
    stockLegend: AmCharts$StockLegend;

    /**
     * Title of a panel. Note, StockLegend should be added in order title to be displayed. 
     */
    title: string;

    /**
     * Trend line opacity.
     * @default  1
     */
    trendLineAlpha: number;

    /**
     * Trend line color. #00CC00 
     */
    trendLineColor: string;

    /**
     * Trend line dash length. 
     */
    trendLineDashLength: number;

    /**
     * Trend line thickness.
     * @default  2
     */
    trendLineThickness: number;

    /**
     * Adds a graph to the panel. 
     */
    addStockGraph(graph: AmCharts$StockGraph): void;

    /**
     * Removes graph from the panel. 
     */
    removeStockGraph(graph: AmCharts$StockGraph): void
}


/**
 * AmChart is a base class of all charts. It can not be instantiated explicitly. AmCoordinateChart, AmPieChart and AmMap extend AmChart class. 
 */
declare class AmChart {

    /**
     * used when constructing a chart with a theme 
     */
    constructor(theme?: any): this;

    /**
     * Specifies, if class names should be added to chart elements. 
     */
    addClassNames: boolean;

    /**
     * Array of Labels. Example of label object, with all possible properties:
     * {"x":20,"y": 20, "text": "this is label", "align": "left", "size": 12, "color": "#CC0000", "alpha": 1, "rotation": 0, "bold": true, "url": "http://www.amcharts.com"} 
     */
    allLabels: AmCharts$Label[];

    /**
     * Set this to false if you don't want chart to resize itself whenever its parent container size changes. 
     */
    autoResize: boolean;

    /**
     * Opacity of background. Set it to >0 value if you want backgroundColor to work. However we recommend changing div's background-color style for changing background color. 
     */
    backgroundAlpha: number;

    /**
     * Background color. You should set backgroundAlpha to >0 value in order background to be visible. We recommend setting background color directly on a chart's DIV instead of using this property. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * The chart creates AmBalloon class itself. If you want to customize balloon, get balloon instance using this property, and then change balloon's properties.  AmBalloon 
     */
    balloon: AmCharts$AmBalloon;

    /**
     * Opacity of chart's border. Value range is 0 - 1. 
     */
    borderAlpha: number;

    /**
     * Color of chart's border. You should set borderAlpha >0 in order border to be visible. We recommend setting border color directly on a chart's DIV instead of using this property. #000000 
     */
    borderColor: string;

    /**
     * This prefix is added to all class names which are added to all visual elements of a chart in case addClassNames is set to true. 
     */
    classNamePrefix: string;

    /**
     * Text color. #000000 
     */
    color: string;

    /**
     * Non-commercial version only. Specifies position of link to amCharts site. Allowed values are: top-left, top-right, bottom-left and bottom-right.
     * @default  'top-left'
     */
    creditsPosition: string;

    /**
     * Array of data objects, for example: [{country:"US", value:524},{country:"UK", value:624},{country:"Lithuania", value:824}]. You can have any number of fields and use any field names. In case of AmMap, data provider should be MapData object. 
     */
    dataProvider: any[];

    /**
     * Decimal separator.
     * @Default  . 
     */
    decimalSeparator: string;

    /**
     * Using this property you can add any additional information to SVG, like SVG filters or clip paths. The structure of this object should be identical to XML structure of a object you are adding, only in JSON format. 
     */
    defs: any;

    /**
     * Export config. Specifies how export to image/data export/print/annotate menu will look and behave. You can find a lot of examples in amcharts/plugins/export folder. 
     */
    export: AmCharts$ExportSettings;

    /**
     * Font family. Verdana 
     */
    fontFamily: string;

    /**
     * Font size.
     * @default  11
     */
    fontSize: string;

    /**
     * If you set this to true, the lines of the chart will be distorted and will produce hand-drawn effect. Try to adjust chart.handDrawScatter and chart.handDrawThickness properties for a more scattered result.
     * @Default  false
     */
    handDrawn: boolean;

    /**
     * Defines by how many pixels hand-drawn line (when handDrawn is set to true) will fluctuate.
     * @Default  2
     */
    handDrawScatter: number;

    /**
     * Defines by how many pixels line thickness will fluctuate (when handDrawn is set to true).
     * @Default  1
     */
    handDrawThickness: number;

    /**
     * Time, in milliseconds after which balloon is hidden if the user rolls-out of the object. Might be useful for AmMap to avoid balloon flickering while moving mouse over the areas. Note, this is not duration of fade-out. Duration of fade-out is set in AmBalloon class.
     * @Default  150
     */
    hideBalloonTime: number;

    /**
     * Allows changing language easily.
     * Note, you should include the language.js file from amcharts/lang or ammap/lang folder and then use variable name used in this file, like chart.language = "de";
    Note, for maps this works differently - you use language only for country names, as there are no other strings in the maps application. 
    */
    language: string;

    /**
     * Legend of a chart. 
     */
    legend: AmCharts$AmLegend;

    /**
     * Reference to the div of the legend. 
     */
    legendDiv: HTMLElement;

    /**
     * You can add listeners of events using this property. Example: listeners = [{"event":"dataUpdated", "method":handleEvent}]; 
     */
    listerns: AV$Object[];

    /**
     * This setting affects touch-screen devices only. If a chart is on a page, and panEventsEnabled are set to true, the page won't move if the user touches the chart first. If a chart is big enough and occupies all the screen of your touch device, the user won’t be able to move the page at all. That's why the default value is "false". If you think that selecting/panning the chart or moving/pinching the map is a primary purpose of your users, you should set panEventsEnabled to true. 
     */
    panEventsEnabled: boolean;

    /**
     * Specifies absolute or relative path to amCharts files, i.e. "amcharts/". (where all .js files are located)
     * If relative URLs are used, they will be relative to the current web page, displaying the chart.
    You can also set path globally, using global JavaScript variable AmCharts_path. If this variable is set, and "path" is not set in chart config, the chart will assume the path from the global variable. This allows setting amCharts path globally. I.e.:
    var AmCharts_path = "/libs/amcharts/";
    "path" parameter will be used by the charts to locate it's files, like images, plugins or patterns.
    */
    path: string;

    /**
     * Specifies path to the folder where images like resize grips, lens and similar are.
     * IMPORTANT: Since V3.14.12, you should use "path" to point to amCharts directory instead. The "pathToImages" will be automatically set and does not need to be in the chart config, unless you keep your images separately from other amCharts files. 
     */
    pathToImages: string;

    /**
     * Precision of percent values. -1 means percent values won't be rounded at all and show as they are.
     * @default  2
     */
    percentPrecision: number;

    /**
     * Precision of values. -1 means values won't be rounded at all and show as they are.
     * @Default  1
     */
    precision: number;

    /**
     * Prefixes which are used to make big numbers shorter: 2M instead of 2000000, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e+3,prefix:"k"},{number:1e+6,prefix:"M"},{number:1e+9,prefix:"G"},{number:1e+12,prefix:"T"},{number:1e+15,prefix:"P"},{number:1e+18,prefix:"E"},{number:1e+21,prefix:"Z"},{number:1e+24,prefix:"Y"}] 
     */
    prefixesOfBigNumbers: any[];

    /**
     * Prefixes which are used to make small numbers shorter: 2μ instead of 0.000002, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e-24, prefix:"y"},{number:1e-21, prefix:"z"},{number:1e-18, prefix:"a"},{number:1e-15, prefix:"f"},{number:1e-12, prefix:"p"},{number:1e-9, prefix:"n"},{number:1e-6, prefix:"μ"},{number:1e-3, prefix:"m"}] 
     */
    prefixesOfSmallNumbers: any[];

    /**
     * A config object for Responsive plugin. 
     */
    responsive: any;

    /**
     * Theme of a chart. Config files of themes can be found in amcharts/themes/ folder. More info about using themes. 
     */
    theme: string;

    /**
     * Thousands separator.
     * @default  .
     */
    thousandsSeparator: string;

    /**
     * Array of Title objects. 
     */
    titles: AmCharts$Title[];

    /**
     * Type of a chart. Required when creating chart using JSON. Possible types are: serial, pie, xy, radar, funnel, gauge, map, stock. 
     */
    type: string;

    /**
     * If true, prefixes will be used for big and small numbers. You can set arrays of prefixes via prefixesOfSmallNumbers and prefixesOfBigNumbers properties. 
     */
    usePrefixes: boolean;

    /**
     * Read-only. Indicates current version of a script. 
     */
    version: string;

    /**
     * Adds a label on a chart.
     * You can use it for labeling axes, adding chart title, etc. x and y coordinates can be set in number, percent, or a number with ! in front of it - coordinate will be calculated from right or bottom instead of left or top.
    x - horizontal coordinate
    y - vertical coordinate
    text - label's text
    align - alignment (left/right/center)
    size - text size
    color - text color
    rotation - angle of rotation
    alpha - label alpha
    bold - specifies if text is bold (true/false),
    url - url
    */
    addLabel(
        x: number | string,
        y: number | string,
        text: string,
        align: string,
        size?: number,
        color?: string,
        rotation?: number,
        alpha?: number,
        bold?: boolean,
        url?: string): void;

    /**
     * Adds a legend to the chart.
     * By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter.
    (NOTE: This method will not work on StockPanel.)
     * @param legend 
     * @param legendDivId - Id of the legend div (optional).
    */
    addLegend(legend: AmCharts$AmLegend, legendDivId?: string): void;

    /**
     * Adds a legend to the chart.
     * By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter.
    (NOTE: This method will not work on StockPanel.)
     * @param legend 
     * @param legendDiv - Legend div (optional).
    */
    addLegend(legend: AmCharts$AmLegend, legendDiv: HTMLElement): void;

    /**
     * Adds title to the top of the chart. Pie, Radar positions are updated so that they won't overlap. Plot area of Serial/XY chart is also updated unless autoMargins property is set to false. You can add any number of titles - each of them will be placed in a new line. To remove titles, simply clear titles array: chart.titles = []; and call chart.validateNow() method. text - text of a title size - font size color - title color alpha - title opacity bold - boolean value indicating if title should be bold. 
     */
    addTitle(text: string, size: number, color: string, alpha: number, bold: boolean): void;

    /**
     * Clears the chart area, intervals, etc. 
     */
    clear(): void;

    /**
     * Removes all labels added to the chart. 
     */
    clearLabels(): void;

    /**
     * Use this method to force the chart to resize to it's current container size. 
     */
    invalidateSize(): void;

    /**
     * Removes chart's legend. 
     */
    removeLegend(): void;

    /**
     * This method should be called after data in your data provider changed or a new array was set to dataProvider. After calling this method the chart will parse data and redraw. 
     */
    validateData(): void;

    /**
     * This method should be called after you changed one or more properties of any class. The chart will redraw after this method is called. 
     */
    validateNow(): void;

    /**
     * Adds chart to the specified DIV.
     * @param container DIV object which will hold the chart. 
     */
    write(container: HTMLElement): void;

    /**
     * Adds chart to the specified DIV.
     * @param container Id of a DIV which will hold the chart. 
     */
    write(container: string): void;

    /**
     * Adds event listener of the type "dataUpdated" or "init" to the object.
     * @param type "dataUpdated" or "init".
     * @param handler If the type is "dataUpdated".
         Dispatched when chart is build for the first time or after validateData() method was called.
    If the type is "init".
         Dispatched when chart is build for the first time.
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "dataUpdated" or "init". 
                 */
                type: string,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * AmCoordinateChart is a base class of AmRectangularChart. It can not be instantiated explicitly. 
 */
declare class AmCoordinateChart mixins AmChart {

    /**
     * Read-only. Array, holding processed chart's data. 
     */
    chartData: AV$Object[];

    /**
     * Specifies the colors of the graphs if the lineColor of a graph is not set.
     * It there are more graphs then colors in this array, the chart picks random color.
     * @default  ['#FF6600', '#FCD202', '#B0DE09', '#0D8ECF', '#2A0CD0', '#CD0D74', '#CC0000', '#00CC00', '#0000CC', '#DDDDDD', '#999999', '#333333', '#990000'] 
     */
    colors: string[];

    /**
     * The array of graphs belonging to this chart.
     * To add/remove graph use addGraph/removeGraph methods instead of adding/removing graphs directly to array.
     */
    graphs: AmCharts$AmGraph[];

    /**
     * Specifies if grid should be drawn above the graphs or below. Will not work properly with 3D charts.
     * @default  false
     */
    gridAboveGraphs: boolean;

    /**
     * Instead of adding guides to the axes, you can push all of them to this array. In case guide has category or date defined, it will automatically will be assigned to the category axis. Otherwise to first value axis, unless you specify a different valueAxis for the guide. 
     */
    guides: AmCharts$Guide[];

    /**
     * Specifies whether the animation should be sequenced or all objects should appear at once.
     * @default  true
     */
    sequencedAnimation: boolean;

    /**
     * The initial opacity of the column/line.
     * If you set startDuration to a value higher than 0, the columns/lines will fade in from startAlpha.
    Value range is 0 - 1.
     * @default  1
    */
    startAlpha: number;

    /**
     * Duration of the animation, in seconds. 
     */
    startDuration: number;

    /**
     * Animation effect.
     * Possible values are ">", "<", elastic" and "bounce".
     * @default  "elastic"
     */
    startEffect: string;

    /**
     * Target of url.
     * @default  this
     */
    urlTarget: any;

    /**
     * The array of value axes.
     * To add/remove value axis use addValueAxis/removeValueAxis methods instead of adding/removing axes directly to array.
    Chart creates one value axis automatically, so if you need only one value axis, you don't need to create it.
    */
    valueAxes: any[];

    /**
     * Adds a graph to the chart.
     */
    addGraph(graph: AmCharts$AmGraph): void;

    /**
     * Adds a legend to the chart. By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter. (NOTE: This method will not work on StockPanel.) Adds value axis to the chart.
     * One value axis is created automatically, so if you don't want to change anything or add more value axes, you don't need to add it.
     */
    addValueAxis(axis: AmCharts$ValueAxis): void;

    /**
     * You can trigger the animation of the chart. 
     */
    animateAgain(): void;

    /**
     * AmGraph Returns graph by id. 
     */
    getGraphById(graphId: string): AmCharts$AmGraph;

    /**
     * Returns value axis by id.
     */
    getValueAxisById(axisId: string): AmCharts$ValueAxis;

    /**
     * Hide the graph (if it is visible). Usually this method is called from the Legend, when you click on the legend marker.
     */
    hideGraph(graph: AmCharts$AmGraph): void;

    /**
     * Hide value balloon of a graph. Usually this method is called from the Legend, when you click on the legend text.
     */
    hideGraphsBalloon(graph: AmCharts$AmGraph): void;

    /**
     * Highlight the graph. Usually this method is called from the Legend, when you roll-over the legend entry.
     */
    highlightGraph(graph: AmCharts$AmGraph): void;

    /**
     * Removes graph from the chart.
     */
    removeGraph(graph: AmCharts$AmGraph): void;

    /**
     * Removes value axis from the chart. When you remove value axis, all graphs assigned to this axis are also removed. 
     */
    removeValueAxis(axis: AmCharts$ValueAxis): void;

    /**
     * Show the graph (if it is hidden). Usually this method is called from the Legend, when you click on the legend marker.
     */
    showGraph(graph: AmCharts$AmGraph): void;

    /**
     * Show value balloon of a graph. Usually this method is called from the Legend, when you click on the legend text.
     */
    showGraphsBalloon(graph: AmCharts$AmGraph): void;

    /**
     * UnhighlightGraph the graph. Usually this method is called from the Legend, when you roll-out the legend entry.
     */
    unhighlightGraph(graph: AmCharts$AmGraph): void;

    /**
     * Adds event listener of the type "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem" to the object.
     * @param type Either "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem".
     * @param handler Dispatched when user clicks on the data item (column/bullet)
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem". 
                 */
                type: string,
                graph: AmCharts$AmGraph,
                item: AmCharts$GraphDataItem,
                index: number,
                chart: AmCharts$AmChart
            }) => void): void
}


/**
 * GraphDataItem holds all the information about the graph's data item. When working with a chart, you do not create GraphDataItem objects or change it's properties directly. GraphDataItem is passed to you by events when user interacts with data item on the chart. The list of properties below will help you to extract data item's value/coordinate/etc. 
 */
declare class GraphDataItem {

    /**
     * Opacity of the data item. 
     */
    alpha: number;

    /**
     * Bullet type. 
     */
    bullet: string;

    /**
     * Bullet size.  
     */
    bulletSize: number;

    /**
     * Category value. 
     */
    category: string;

    /**
     * Color of the data item. 
     */
    color: string;

    /**
     * Custom bullet (path to file name). 
     */
    customBullet: string;

    /**
     * Original object from data provider. 
     */
    dataContext: AV$Object;

    /**
     * Description. 
     */
    description: string;

    /**
     * Array of colors of the data item, used by column and candlestick chart only. 
     */
    fillColors: any[];

    /**
     * Object which holds percents when recalculateToPercents is set to true. 
     */
    percents: AV$Object;

    /**
     * SerialDataItem of this graphDataItem 
     */
    serialDataItem: AmCharts$SerialDataItem;

    /**
     * url 
     */
    url: string;

    /**
     * Object which holds values of the data item (value, open, close, low, high). 
     */
    values: AV$Object;

    /**
     * x coordinate of the data item. 
     */
    x: number;

    /**
     * y coordinate of the data item. 
     */
    y: number
}


/**
 * SerialDataItem holds all the information about each series. When working with a chart, you do not create SerialDataItem objects or change it's properties directly. Consider properties of a SerialDataItem read-only - change values in chart's data provider if you need to. When serial chart parses dataProvider, it generates "chartData" array. Objects of this array are SerialDataItem objects. 
 */
declare class SerialDataItem {

    /**
     * You can access each GraphDataItem using this object. The data structure is: graphDataItem = serialDataItem.axes[axisId].graphs[graphId]. 
     */
    axes: AV$Object;

    /**
     * category value. String if parseDates is false, Date if true. 
     */
    category: any;

    /**
     * Timestamp of a series date. Avalable only if parseDates property of CategoryAxis is set to true. 
     */
    time: number;

    /**
     * Coordinate (horizontal or vertical, depends on chart's rotate property) of the series. 
     */
    x: number
}

declare class CategoryAxis mixins AxisBase {

    /**
     * When parse dates is on for the category axis, the chart will try to highlight the beginning of the periods, like month, in bold. Set this to false to disable the functionality.
     * @default  true
     */
    boldPeriodBeginning: boolean;

    /**
     * Date formats of different periods. Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, WW - weeks, YYYY - years. Check this page for date formatting strings. [{period:'fff',format:'JJ:NN:SS'},{period:'ss',format:'JJ:NN:SS'},{period:'mm',format:'JJ:NN'},{period:'hh',format:'JJ:NN'},{period:'DD',format:'MMM DD'},{period:'WW',format:'MMM DD'},{period:'MM',format:'MMM'},{period:'YYYY',format:'YYYY'}] 
     */
    dateFormats: any[];

    /**
     * In case your category axis values are Date objects and parseDates is set to true, the chart will parse dates and will place your data points at irregular intervals. However if you want dates to be parsed (displayed on the axis, baloons, etc), but data points to be placed at equal intervals (omiting dates with no data), set equalSpacing to true. 
     */
    equalSpacing: boolean;

    /**
     * Field in data provider which specifies if the category value should always be shown. For example: categoryAxis.forceShowField = "forceShow"; Field in data provider which specifies if the category value should always be shown. For example: categoryAxis.forceShowField = "forceShow";
     * Andin data:
    {category:"one", forceShow:true, value:100}
    Note, this works only when parseDates is set to false.
    */
    forceShowField: string;

    /**
     * Specifies if a grid line is placed on the center of a cell or on the beginning of a cell. Possible values are: "start" and "middle" This setting doesn't work if parseDates is set to true. middle 
     */
    gridPosition: string;

    /**
     * Specifies if minor grid should be displayed.
     * NOTE: If equalSpacing is set to true, this setting will be ignored.
     * @default  false
     */
    minorGridEnabled: boolean;

    /**
     * Specifies the shortest period of your data. This should be set only if parseDates is set to "true". Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, YYYY - years. DD 
     */
    minPeriod: string;

    /**
     * In case your category axis values are Date objects, set this to true. In this case the chart will parse dates and will place your data points at irregular intervals. If you want dates to be parsed, but data points to be placed at equal intervals, set both parseDates and equalSpacing to true. 
     */
    parseDates: boolean;

    /**
     * Specifies whether the graph should start on axis or not. In case you display columns, it is recommended to set this to false. If parseDates is set to true, startOnAxis will allways be false, unless equalSpacing is set to true. 
     */
    startOnAxis: boolean;

    /**
     * Works only when parseDates is set to true and equalSpacing is false. If you set it to true, at the position where bigger period changes,
     * category axis will display date strings of bot small and big period, in two rows.
     * @default  false
     */
    twoLineMode: boolean;

    /**
     * Use line color for bullet
     * @default  false
     */
    useLineColorForBulletBorder: boolean;

    /**
     * Number returns coordinate of a category. Works only if parseDates is false. If parseDates is true, use dateToCoordinate method. category - String 
     */
    categoryToCoordinate(category: string): void;

    /**
     * date - Date object Returns Date of the coordinate, in case parseDates is set to true and equalSpacing is set to false.  coordinate - Number 
     */
    coordinateToDate(coordinate: number): void;

    /**
     * Number Returns coordinate of the date, in case parseDates is set to true. if parseDates is false, use categoryToCoordinate method. date - Date object 
     */
    dateToCoordinate(date: Date): void;

    /**
     * Number Returns index of the category which is most close to specified coordinate. x - coordinate 
     */
    xToIndex(x: number): void
}


/**
 * ChartScrollbar class displays chart scrollbar. Supported by AmSerialChart and AmXYChart.
 * @example  var chart = new AmCharts.AmSerialChart();
var chartScrollbar = new AmCharts.ChartScrollbar();
chart.addChartScrollbar(chartScrollbar);
*/
declare class ChartScrollbar {

    /**
     * Specifies whether number of gridCount is specified automatically, acoarding to the axis size. 
     */
    autoGridCount: boolean;

    /**
     * Background opacity.
     * @default  1
     */
    backgroundAlpha: number;

    /**
     * Background color of the scrollbar.
     * @default  #D4D4D4
     */
    backgroundColor: string;

    /**
     * Read-only. Category axis of the scrollbar. 
     */
    categoryAxis: AmCharts$CategoryAxis;

    /**
     * Text color. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Specifies which graph will be displayed in the scrollbar. Only Serial chart's scrollbar can display a graph. 
     */
    graph: AmCharts$AmGraph;

    /**
     * Graph fill opacity. Value range is 0 - 1.  0.1 
     */
    graphFillAlpha: number;

    /**
     * Graph fill color. #000000 
     */
    graphFillColor: string;

    /**
     * Graph line opacity. Value range is 0 - 1. 
     */
    graphLineAlpha: number;

    /**
     * Graph line color. #000000 
     */
    graphLineColor: string;

    /**
     * by default the graph type is the same as the original graph's type, however in case of candlestick or ohlc you might want to show line graph in the scrollbar. Possible values are: "line", "column", "step", "smoothedLine", "candlestick", "ohlc". 
     */
    graphType: string;

    /**
     * Grid opacity. Value range is 0 - 1. 0.7 
     */
    gridAlpha: number;

    /**
     * Grid color. #FFFFFF 
     */
    gridColor: string;

    /**
     * The number of grid lines. 
     */
    gridCount: number;

    /**
     * Specifies whether resize grips are hidden when mouse is away from the scrollbar. 
     */
    hideResizeGrips: boolean;

    /**
     * Specifies whether scrollbar has a resize feature.
     * @default  true
     */
    resizeEnabled: boolean;

    /**
     * Height (width, if chart is rotated) of a scrollbar.  20 
     */
    scrollbarHeight: number;

    /**
     * Duration of scrolling, when the user clicks on scrollbar's background, in seconds.
     * @default  2
    3
    */
    scrollDuration: number;

    /**
     * Selected backround opacity.
     * @default  1
     */
    selectedBackgroundAlpha: number;

    /**
     * Selected background color. #EFEFEF 
     */
    selectedBackgroundColor: string;

    /**
     * Selected graph's fill opacity. Value range is 0 - 1. 0.5 
     */
    selectedGraphFillAlpha: number;

    /**
     * Selected graph's fill color. #000000 
     */
    selectedGraphFillColor: string;

    /**
     * Selected graph's line opacity. Value range is 0 - 1. 
     */
    selectedGraphLineAlpha: number;

    /**
     * Selected graph's line color. #000000 
     */
    selectedGraphLineColor: string;

    /**
     * Specifies if the chart should be updated while dragging/resizing the scrollbar or only at the moment when user releases mouse button. 
     */
    updateOnReleaseOnly: boolean
}


/**
 * AmRectangularChart is a base class of AmSerialChart and AmXYChart. It can not be instantiated explicitly.
 */
declare class AmRectangularChart mixins AmCoordinateChart {

    /**
     * The angle of the 3D part of plot area. This creates a 3D effect (if the "depth3D" is>0).
     * @default  0
     */
    angle: number;

    /**
     * Space left from axis labels/title to the chart's outside border, if autoMargins set to true.
     * @default  10
     */
    autoMarginOffset: number;

    /**
     * Specifies if margins of a chart should be calculated automatically so that labels of axes would fit. The chart will adjust only margins with axes. Other margins will use values set with marginRight, marginTop, marginLeft and marginBottom properties.
     * @default  true
     */
    autoMargins: boolean;

    /**
     * Cursor of a chart. 
     */
    chartCursor: AmCharts$ChartCursor;

    /**
     * Chart scrollbar. 
     */
    chartScrollbar: AmCharts$ChartScrollbar;

    /**
     * The depth of the 3D part of plot area. This creates a 3D effect (if the "angle" is>0).
     * @default  0
     */
    depth3D: number;

    /**
     * Number of pixels between the container's bottom border and plot area. This space can be used for bottom axis' values. If autoMargin is true and bottom side has axis, this property is ignored.
     * @default  20
     */
    marginBottom: number;

    /**
     * Number of pixels between the container's left border and plot area. This space can be used for left axis' values. If autoMargin is true and left side has axis, this property is ignored.
     * @default  20
     */
    marginLeft: number;

    /**
     * Number of pixels between the container's right border and plot area. This space can be used for Right axis' values. If autoMargin is true and right side has axis, this property is ignored.
     * @default  20
     */
    marginRight: number;

    /**
     * Flag which should be set to false if you need margins to be recalculated on next chart.validateNow() call.
     * @default  false
     */
    marginsUpdated: boolean;

    /**
     * Number of pixels between the container's top border and plot area. This space can be used for top axis' values. If autoMargin is true and top side has axis, this property is ignored.
     * @default  20
     */
    marginTop: number;

    /**
     * The opacity of plot area's border. Value range is 0 - 1.
     * @default  0
     */
    plotAreaBorderAlpha: number;

    /**
     * The color of the plot area's border. Note, the it is invisible by default, as plotAreaBorderAlpha default value is 0. Set it to a value higher than 0 to make it visible.
     * @default  '#000000'
     */
    plotAreaBorderColor: string;

    /**
     * Opacity of plot area. Plural form is used to keep the same property names as our Flex charts'. Flex charts can accept array of numbers to generate gradients. Although you can set array here, only first value of this array will be used.
     * @default  0
     */
    plotAreaFillAlphas: number;

    /**
     * You can set both one color if you need a solid color or array of colors to generate gradients, for example: ["#000000", "#0000CC"]
     * @default  '#FFFFFF'
     */
    plotAreaFillColors: any;

    /**
     * If you are using gradients to fill the plot area, you can use this property to set gradient angle. The only allowed values are horizontal and vertical: 0, 90, 180, 270.
     * @default  0
     */
    plotAreaGradientAngle: number;

    /**
     * Array of trend lines added to a chart. You can add trend lines to a chart using this array or access already existing trend lines 
     */
    trendLines: AmCharts$TrendLine[];

    /**
     * Opacity of zoom-out button background.
     * @default  0
     */
    zoomOutButtonAlpha: number;

    /**
     * Zoom-out button background color.
     * @default  '#e5e5e5'
     */
    zoomOutButtonColor: string;

    /**
     * Name of zoom-out button image. In the images folder there is another lens image, called lensWhite.png. You might want to have white lens when background is dark. Or you can simply use your own image.
     * @default  lens.png
     */
    zoomOutButtonImage: string;

    /**
     * Size of zoom-out button image
     * @default  : 17
     */
    zoomOutButtonImageSize: number;

    /**
     * Padding around the text and image.
     * @default  : 8
     */
    zoomOutButtonPadding: number;

    /**
     * Opacity of zoom-out button background when mouse is over it.
     * @default  : 1
     */
    zoomOutButtonRollOverAlpha: number;

    /**
     * Text in the zoom-out button. Show all 
     */
    zoomOutText: string;

    /**
     * Adds a ChartCursor object to a chart 
     */
    addChartCursor(cursor: AmCharts$ChartCursor): void;

    /**
     * Adds a ChartScrollbar to a chart 
     */
    addChartScrollbar(scrollbar: AmCharts$ChartScrollbar): void;

    /**
     * Adds a TrendLine to a chart.
     * You should call chart.validateNow() after this method is called in order the trend line to be visible. 
     */
    addTrendLine(trendLine: AmCharts$TrendLine): void;

    /**
     * Removes cursor from the chart 
     */
    removeChartCursor(): void;

    /**
     * Removes scrollbar from the chart 
     */
    removeChartScrollbar(): void;

    /**
     * Removes a trend line from a chart.
     * You should call chart.validateNow() in order the changes to be visible. 
     */
    removeTrendLine(trendLine: AmCharts$TrendLine): void
}

declare class TrendLine {}


/**
 * ChartCursor is a class which displays a cursor which follows the mouse. In case of Serial chart it also shows value and category balloons.
 * @example  var chart = new AmCharts.AmSerialChart();
var chartCursor = new AmCharts.ChartCursor();
chart.addChartCursor(chartCursor);
*/
declare class ChartCursor {

    /**
     * Specifies if bullet for each graph will follow the cursor. 
     */
    bulletsEnabled: boolean;

    /**
     * Size of bullets, following the cursor.
     * @default  8
     */
    bulletSize: number;

    /**
     * Opacity of the category balloon.
     * @default  1
     */
    categoryBalloonAlpha: number;

    /**
     * Color of the category balloon. cursorColor is used if not set. 
     */
    categoryBalloonColor: string;

    /**
     * Category balloon date format (used only if category axis parses dates). Check this page for instructions on how to format dates. MMM DD, YYYY 
     */
    categoryBalloonDateFormat: string;

    /**
     * Specifies whether category balloon is enabled.
     * @default  true
     */
    categoryBalloonEnabled: boolean;

    /**
     * Text color. #FFFFFF 
     */
    color: string;

    /**
     * Opacity of the cursor line.  1 
     */
    cursorAlpha: number;

    /**
     * Color of the cursor line. #CC0000 
     */
    cursorColor: string;

    /**
     * Specifies where the cursor line should be placed - on the beginning of the period (day, hour, etc) or in the middle (only when parseDates property of categoryAxis is set to true). If you want the cursor to follow mouse and not to glue to the nearest data point, set "mouse" here. Possible values are: "start", "middle", "mouse". 
     */
    cursorPosition: string;

    /**
     * Specifies whether cursor is enabled.
     * @default  true
     */
    enabled: boolean;

    /**
     * If set to true, instead of a cursor line user will see a fill which width will always be equal to the width of one data item.
     * Recommend setting cursorAlpha to 0.1 or some other small number if using this feature.
     * @default  false
     */
    fullWidth: boolean;

    /**
     * If this is set to true, only one balloon at a time will be displayed. Note, this is quite CPU consuming. 
     */
    oneBalloonOnly: boolean;

    /**
     * If this is set to true, the user will be able to pan the chart (Serial only) instead of zooming. 
     */
    pan: boolean;

    /**
     * Opacity of the selection. 
     */
    selectionAlpha: number;

    /**
     * Specifies if cursor should only mark selected area but not zoom-in after user releases mouse button. 
     */
    selectWithoutZooming: boolean;

    /**
     * Specifies whether value balloons are enabled. In case they are not, the balloons might be displayed anyway, when the user rolls-over the column or bullet.
     * @default  true
     */
    valueBalloonsEnabled: boolean;

    /**
     * Specifies if the user can zoom-in the chart. If pan is set to true, zoomable is switched to false automatically.
     * @default  true
     */
    zoomable: boolean;

    /**
     * Indicates if currently user is selecting some chart area to zoom-in. 
     */
    zooming: boolean;

    /**
     * Hides cursor. 
     */
    hideCursor(): void;

    /**
     * You can force cursor to appear at specified cateogry or date. 
     */
    showCursorAt(category: string): void;

    /**
     * Adds event listener of the type "changed" to the object.
     * @param type Always "changed".
     * @param handler Dispatched when cursor position is changed. "index" is a series index over which chart cursors currently is. "zooming" specifies if user is currently zooming (is selecting) the chart. mostCloseGraph property is set only when oneBalloonOnly is set to true.
     */
    addListener(
        type: string,
        handler: (
            e: {
                type: string,
                index: number,
                zooming: boolean,
                mostCloseGraph: AmCharts$AmGraph,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Adds event listener of the type "onHideCursor" to the object.
     * @param type Always "onHideCursor".
     * @param handler Dispatched when cursor is hidden.
     */
    addListener(
        type: string,
        handler: (e: {
            type: string,
            chart: AmCharts$AmChart
        }) => void): void;

    /**
     * Adds event listener of the type "selected" or "zoomed" to the object.
     * @param type "selected" or "zoomed".
     * @param handler If the type is "selected". Dispatched if selectWithoutZooming is set to true and when user selects some period. start and end are indices or timestamp (when categoryAxis.parseDates is true) of selection start/end.
    If the type is "zoomed". Dispatched when user zooms to some period. start and end are indices or timestamp (when categoryAxis.parseDates is true) of selection start/end.
    */
    addListener(
        type: string,
        handler: (
            e: {
                type: string,
                index: number,
                zooming: boolean,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * AmSerialChart is the class you have to use for majority of chart types. The supported chart types are: line, area, column, bar, step line, smoothed line, candlestick and OHLC. The chart can be rotated by 90 degrees so the column chart becomes bar chart. The chart supports simple and logarithmic scales, it can have multiple value axes. The chart can place data points at equal intervals or can parse dates and place data points at irregular intervals.
 * @example  var chartData = [{title:"sample 1",value:130},{title:"sample 2",value:26}];
var chart = new AmCharts.AmSerialChart();
chart.categoryField = "title";
chart.dataProvider = chartData;
var graph = new AmCharts.AmGraph();
graph.valueField = "value";
graph.type = "column";
graph.fillAlphas = 1;
chart.addGraph(graph);
chart.write("chartdiv");
*/
declare class AmSerialChart mixins AmRectangularChart {

    /**
     * Date format of the graph balloon (if chart parses dates and you don't use chartCursor).
     *    
     * @default  'MMM DD, YYYY'
     */
    balloonDateFormat: string;

    /**
     * Read-only. Chart creates category axis itself. If you want to change some properties, you should get this axis from the chart and set properties to this object. 
     */
    categoryAxis: AmCharts$CategoryAxis;

    /**
     * Category field name tells the chart the name of the field in your dataProvider object which will be used for category axis values. 
     */
    categoryField: string;

    /**
     * The gap in pixels between two columns of the same category.
     * @default  5
     */
    columnSpacing: number;

    /**
     * Space between 3D stacked columns.
     * @default  0
     */
    columnSpacing3D: number;

    /**
     * Relative width of columns. Value range is 0 - 1.
     * @default  0.8
     */
    columnWidth: number;

    /**
     * Read-only. If category axis parses dates endDate indicates date to which the chart is currently displayed. 
     */
    endDate: Date;

    /**
     * Read-only. Category index to which the chart is currently displayed. 
     */
    endIndex: number;

    /**
     * Maximum number of series allowed to select. 
     */
    maxSelectedSeries: number;

    /**
     * The longest time span allowed to select (in milliseconds) for example, 259200000 will limit selection to 3 days. 
     */
    maxSelectedTime: number;

    /**
     * The shortest time span allowed to select (in milliseconds) for example, 1000 will limit selection to 1 second.
     * @default  0
     */
    minSelectedTime: number;

    /**
     * Specifies if scrolling of a chart with mouse wheel is enabled. If you press shift while rotating mouse wheel, the chart will zoom-in/out. 
     */
    mouseWheelScrollEnabled: boolean;

    /**
     * Specifies if zooming of a chart with mouse wheel is enabled. If you press shift while rotating mouse wheel, the chart will scroll. 
     */
    mouseWheelZoomEnabled: boolean;

    /**
     * If you set this to true, the chart will be rotated by 90 degrees (the columns will become bars). 
     */
    rotate: boolean;

    /**
     * Read-only. If category axis parses dates startDate indicates date from which the chart is currently displayed. 
     */
    startDate: Date;

    /**
     * Read-only. Category index from which the chart is currently displayed. 
     */
    startIndex: number;

    /**
     * Specifies if chart should zoom-out when data is updated.
     * @default  true
     */
    zoomOutOnDataUpdate: boolean;

    /**
     * Number Returns index of the specified category value. value - series (category value) which index you want to find. 
     */
    getCategoryIndexByValue(value: number): void;

    /**
     * Zooms out, charts shows all available data. 
     */
    zoomOut(): void;

    /**
     * Zooms the chart by the value of the category axis. start - category value, String \\ end - category value, String 
     */
    zoomToCategoryValues(start: Date, end: Date): void;

    /**
     * Zooms the chart from one date to another. start - start date, Date object \\ end - end date, Date object 
     */
    zoomToDates(start: Date, end: Date): void;

    /**
     * Zooms the chart by the index of the category. start - start index, Number \\ end - end index, Number 
     */
    zoomToIndexes(start: Date, end: Date): void
}

declare class PeriodSelector {

    /**
     * Date format of date input fields. Check [[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/mx/formatters/DateFormatter.html DD-MM-YYYY 
     */
    dateFormat: string;

    /**
     * Text displayed next to "from" date input field. From: 
     */
    fromText: string;

    /**
     * Specifies if period buttons with date range bigger than available data should be hidden.
     * @default  true
     */
    hideOutOfScopePeriods: boolean;

    /**
     * Specifies whether period selector displays "from" and "to" date input fields.
     * @default  true
     */
    inputFieldsEnabled: boolean;

    /**
     * Width of date input fields, in pixels. Works only if period selector is horizontal.
     * @default  100
     */
    inputFieldWidth: number;

    /**
     * Array of predefined period objects. Period object has 4 properties - period, count, label and selected. Possible period values are: "ss" - seconds, "mm" - minutes, "hh" - hours, "DD" - days, "MM" - months and "YYYY" - years. property "count" specifies how many periods this button will select. "label" will be displayed on a button and "selected" is a boolean which specifies if this button is selected when chart is initialized or not. Example: {period:"DD", count:10, label:"10 days", selected:false}. 
     */
    periods: any[];

    /**
     * Text displayed next to predefined period buttons. Zoom: 
     */
    periodsText: string;

    /**
     * Possible values: "right", "left", "top", "bottom". bottom 
     */
    position: string;

    /**
     * Specifies whether predefined period buttons should select a period from the beginning or the end of the data. 
     */
    selectFromStart: boolean;

    /**
     * Text displayed next to "to" date input field. To: 
     */
    toText: string;

    /**
     * Width of a period selector, when position is "left" or "right".
     * @default  180
     */
    width: number;

    /**
     * Adds event listener to the object.
     * .
     * @param handler - Dispatched when dates in period selector input fields are changed or user clicks on one of the predefined period buttons. 
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always: "changed" 
                 */
                type: string,
                startDate: Date,
                endDate: Date,
                predefinedPeriod: string,
                count: number
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * PanelsSettings settings set's settings for all StockPanels. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of StockPanel class will be used. 
 */
declare class PanelsSettings {

    /**
     * The angle of the 3D part of plot area. This creates a 3D effect (if the "depth3D" is>0). 
     */
    angle: number;

    /**
     * Opacity of panel background. Possible values are 1 and 0. Values like 0.5 will not make it half-transparent. 
     */
    backgroundAlpha: number;

    /**
     * Background color of panels. Set backgroundAlpha to>0 value in order to make background visible. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * The gap in pixels between two columns of the same category. 
     */
    columnSpacing: number;

    /**
     * Relative width of columns. Valid values 0 - 1. 
     */
    columnWidth: number;

    /**
     * The depth of the 3D part of plot area. This creates a 3D effect (if the "angle" is>0). 
     */
    depth3D: number;

    /**
     * Font family. 
     */
    fontFamily: string;

    /**
     * Font size. 
     */
    fontSize: string;

    /**
     * Number of pixels between the container's bottom border and plot area.
     * @default  1
     */
    marginBottom: number;

    /**
     * Number of pixels between the container's left border and plot area. If your left valueAxis values ar not placed inside the plot area, you should set marginLeft to 80 or some close value. 
     */
    marginLeft: number;

    /**
     * Number of pixels between the container's left border and plot area. If your right valueAxis values ar not placed inside the plot area, you should set marginRight to 80 or some close value. 
     */
    marginRight: number;

    /**
     * Number of pixels between the container's top border and plot area. 
     */
    marginTop: number;

    /**
     * Gap between panels.
     * @default  8
     */
    panelSpacing: number;

    /**
     * This setting affects touch-screen devices only. If a chart is on a page, and panEventsEnabled are set to true, the page won't move if the user touches the chart first. If a chart is big enough and occupies all the screen of your touch device, the user won’t be able to move the page at all. That's why the default value is "false". If you think that selecting or or panning the chart is a primary purpose of your chart users, you should set panEventsEnabled to true. 
     */
    panEventsEnabled: boolean;

    /**
     * The opacity of plot area's border. 
     */
    plotAreaBorderAlpha: number;

    /**
     * The color of the plot area's border. 
     */
    plotAreaBorderColor: string;

    /**
     * Opacity of plot area fill. 
     */
    plotAreaFillAlphas: number;

    /**
     * Specifies the colors used to tint the background gradient fill of the plot area. String or Array of Strings 
     */
    plotAreaFillColors: any;

    /**
     * Prefixes which are used to make big numbers shorter: 2M instead of 2000000, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e+3,prefix:"k"},{number:1e+6,prefix:"M"},{number:1e+9,prefix:"G"},{number:1e+12,prefix:"T"},{number:1e+15,prefix:"P"},{number:1e+18,prefix:"E"},{number:1e+21,prefix:"Z"},{number:1e+24,prefix:"Y"}] 
     */
    prefixesOfBigNumbers: any[];

    /**
     * Prefixes which are used to make small numbers shorter: 2μ instead of 0.000002, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e-24, prefix:"y"},{number:1e-21, prefix:"z"},{number:1e-18, prefix:"a"},{number:1e-15, prefix:"f"},{number:1e-12, prefix:"p"},{number:1e-9, prefix:"n"},{number:1e-6, prefix:"μ"},{number:1e-3, prefix:"m"}] 
     */
    prefixesOfSmallNumbers: any[];

    /**
     * Specifies whether the animation should be sequenced or all objects should appear at once. 
     */
    sequencedAnimation: boolean;

    /**
     * The initial opacity of the column/line. If you set startDuration to a value higher than 0, the columns/lines will fade in from startAlpha. 
     */
    startAlpha: number;

    /**
     * Duration of the animation, in seconds. 
     */
    startDuration: number;

    /**
     * Possible values are: "linear", "<", ">" "<>", "elastic", "bounce". 
     */
    startEffect: string;

    /**
     * If true, prefixes will be used for big and small numbers. 
     */
    usePrefixes: boolean
}


/**
 * DataSet is objects which holds all information about data. 
 */
declare class DataSet {

    /**
     * Category field name in your dataProvider. 
     */
    categoryField: string;

    /**
     * Color of the data set. One of colors from AmStockChart.colors array will be used if not set. 
     */
    color: string;

    /**
     * Whether this data set is selected for comparing. If you change this property, you should call stockChart.validateData() method in order the changes to be applied. 
     */
    compared: boolean;

    /**
     * Data provider of the data set. 
     */
    dataProvider: any[];

    /**
     * Array of field mappings. Field mapping is an object with fromField and toField properties. fromField is a name of your value field in dataProvider. toField might be chosen freely, it will be used to set value/open/close/high/low fields for the StockGraph. Example: {fromField:"val1", toField:"value"}. 
     */
    fieldMappings: any[];

    /**
     * Specifies whether this data set should be visible in "compare to" list.
     * @default  true
     */
    showInCompare: boolean;

    /**
     * Specifies whether this data set should be visible in "select" dropdown.
     * @default  true
     */
    showInSelect: boolean;

    /**
     * Array of StockEvent objects. 
     */
    stockEvents: AmCharts$StockEvent[];

    /**
     * DataSet title. 
     */
    title: string
}

declare class StockGraph mixins AmGraph {

    /**
     * Specifies whether this graph will be compared if some data set is selected for comparing. 
     */
    comparable: boolean;

    /**
     * Specifies a field to be used to generate comparing graph. Note, this field is not the one used in your dataProvider, but toField from FieldMapping object. 
     */
    compareField: string;

    /**
     * Balloon color of comparing graph. 
     */
    compareGraphBalloonColor: string;

    /**
     * Balloon text of comparing graph. 
     */
    compareGraphBalloonText: string;

    /**
     * Bullet of comparing graph. Possible values are: "square", "round", "line", "triangleUp", "triangleDown", "dashedLine", "bubble". 
     */
    compareGraphBullet: string;

    /**
     * Bullet size of comparing graph. 
     */
    compareGraphBulletSize: number;

    /**
     * Corner radius of comparing graph (if type is "column"). 
     */
    compareGraphCornerRadiusTop: number;

    /**
     * Dash length of compare graph. 
     */
    compareGraphDashLength: number;

    /**
     * Fill alpha of comparing graph. 
     */
    compareGraphFillAlphas: number;

    /**
     * Fill color of comparing graph. 
     */
    compareGraphFillColors: string;

    /**
     * Opacity of comparing graph line. 
     */
    compareGraphLineAlpha: number;

    /**
     * Thickness of compare graph. 
     */
    compareGraphLineThickness: number;

    /**
     * Type of comparing graph. Possible values are: "line", "column", "step", "smoothedLine." line 
     */
    compareGraphType: string;

    /**
     * Specifies if compare graph is visible in legend.
     * @default  true
     */
    compareGraphVisibleInLegend: boolean;

    /**
     * When data is grouped to periods, the graph must know which period value should be used. Possible values are: "Open", "Low", "High", "Close", "Average" and "Sum". Close 
     */
    periodValue: string;

    /**
     * Specifies whether data set color should be used as this graph's lineColor.
     * @default  true
     */
    useDataSetColors: boolean
}


/**
 * StockEvent is object which holds information about event(bullet).Values from StockEventsSettings will be used if not set.Stock event bullet's size depends on it's graphs fontSize.When user rolls - over, clicks or rolls - out of the event bullet, AmStockChart dispatches events.
 */
declare class StockEvent {

    /**
     * Opacity of bullet background.
     * @default  1
     */
    backgroundAlpha: number;

    /**
     * Color of bullet background. #DADADA 
     */
    backgroundColor: string;

    /**
     * Opacity of bullet border.
     * @default  1
     */
    borderAlpha: number;

    /**
     * Bullet border color. #888888 
     */
    borderColor: string;

    /**
     * The color of the event text. #000000 
     */
    color: string;

    /**
     * Date of an event. Must be Date object, not a string. 
     */
    date: Date;

    /**
     * graph on which event will be displayed. 
     */
    graph: AmCharts$StockGraph;

    /**
     * Roll-over background color. #CC0000 
     */
    rollOverColor: string;

    /**
     * Specifies if the event should be displayed on category axis 
     */
    showOnAxis: boolean;

    /**
     * Letter which will be displayed on the event. Not all types can display letters. "text" type can display longer texts. 
     */
    text: string;

    /**
     * Type of bullet. Possible values are: "flag", "sign", "pin", "triangleUp", "triangleDown", "triangleLeft", "triangleRight", "text", "arrowUp", "arrowDown". sign 
     */
    type: string;

    /**
     * A URL to go to when user clicks the event. 
     */
    url: string;

    /**
     * target of url, "_blank" for example. 
     */
    urlTarget: string
}


/**
 * Creates a label on the chart which can be placed anywhere, multiple can be assigned. 
 */
declare class Label {

    /**
     * 
     * @Default  'left' 
     */
    align: string;

    /**
     * 
     * @Default  1 
     */
    alpha: number;

    /**
     * Specifies if label is bold or not. 
     */
    bold: boolean;

    /**
     * Color of a label 
     */
    color: string;

    /**
     * Unique id of a Label. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Rotation angle. 
     */
    rotation: number;

    /**
     * Text size 
     */
    size: number;

    /**
     * Text of a label 
     */
    text: string;

    /**
     * URL which will be access if user clicks on a label. 
     */
    url: string;

    /**
     * X position of a label. 
     */
    x: number | string;

    /**
     * y position of a label. 
     */
    y: number | string
}


/**
 * Common settings of legends. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of StockLegend class will be used. 
 */
declare class LegendSettings {

    /**
     * Alignment of legend entries. Possible values are: "left", "right" and "center". 
     */
    align: string;

    /**
     * Specifies if each legend entry should take the same space as the longest legend entry. 
     */
    equalWidths: boolean;

    /**
     * Horizontal space between legend item and left/right border. 
     */
    horizontalGap: number;

    /**
     * The text which will be displayed in the legend. Tag [[title]] will be replaced with the title of the graph. 
     */
    labelText: string;

    /**
     * Space below the last row of the legend, in pixels. 
     */
    marginBottom: number;

    /**
     * Space above the first row of the legend, in pixels. 
     */
    marginTop: number;

    /**
     * Opacity of marker border. 
     */
    markerBorderAlpha: number;

    /**
     * Marker border color. 
     */
    markerBorderColor: string;

    /**
     * Thickness of the legend border. 
     */
    markerBorderThickness: number;

    /**
     * The color of the disabled marker (when the graph is hidden). 
     */
    markerDisabledColor: string;

    /**
     * Space between legend marker and legend text, in pixels. 
     */
    markerLabelGap: number;

    /**
     * Size of the legend marker (key). 
     */
    markerSize: number;

    /**
     * Shape of the legend marker (key). Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble", "none". 
     */
    markerType: string;

    /**
     * Specifies whether legend entries should be placed in reversed order. 
     */
    reversedOrder: boolean;

    /**
     * Legend item text color on roll-over. 
     */
    rollOverColor: string;

    /**
     * When you roll-over the legend entry, all other graphs can reduce their opacity, so that the graph you rolled-over would be distinguished. This property specifies the opacity of the graphs. 
     */
    rollOverGraphAlpha: number;

    /**
     * Whether showing/hiding of graphs by clicking on the legend marker is enabled or not. 
     */
    switchable: boolean;

    /**
     * Legend switch color. 
     */
    switchColor: string;

    /**
     * Legend switch type (in case the legend is switchable). Possible values are: "x" and "v". 
     */
    switchType: string;

    /**
     * Specifies whether the legend text is clickable or not. Clicking on legend text can show/hide value balloons if they are enabled. 
     */
    textClickEnabled: boolean;

    /**
     * Specifies if legend labels should be use same color as corresponding markers. 
     */
    useMarkerColorForLabels: boolean;

    /**
     * The text which will be displayed in the value portion of the legend when graph is comparable and at least one dataSet is selected for comparing. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. 
     */
    valueTextComparing: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. 
     */
    valueTextRegular: string;

    /**
     * Width of the value text. Increase this value if your values do not fit in the allocated space. 
     */
    valueWidth: number;

    /**
     * Vertical space between legend items, in pixels. 
     */
    verticalGap: number
}


/**
 * DataSetSelector is a tool for selecting data set's as main and for comparing with main data set. 
 */
declare class DataSetSelector {

    /**
     * Text displayed in the "compare to" combobox (when position is "top" or "bottom"). Select... 
     */
    comboBoxSelectText: string;

    /**
     * Text displayed near "compare to" list. Compare to: 
     */
    compareText: string;

    /**
     * The maximum height of the Compare to field in pixels.
     * @default  150
     */
    listHeight: number;

    /**
     * Possible values: "right", "left", "top", "bottom". "top" and "bottom" positions has a limitation - only one data set can be selected for comparing. left 
     */
    position: string;

    /**
     * Text displayed near "Select" dropDown. Select: 
     */
    selectText: string;

    /**
     * Width of a Data set selector, when position is "left" or "right".
     * @default  180
     */
    width: number
}


/**
 * AmBalloon is the class which generates balloons (datatips). Balloon follows the mouse when you roll-over the pie slice/line bullet/column/etc, chart indicator of serial charts displays value balloons and category balloon. Balloon instance is created by the chart automatically and can be accessed via "balloon" property of AmChart. Chart shows/hides and sets position for every balloon automatically, so all you need to do is to change balloon appearance, if you want to.
 * @example  var chart = new AmCharts.AmSerialChart();
// get balloon intance
var balloon = chart.balloon;
// set properties
balloon.adjustBorderColor = true;
balloon.color = "#000000";
balloon.cornerRadius = 5;
balloon.fillColor = "#FFFFFF";
*/
declare class AmBalloon {

    /**
     * If this is set to true, border color instead of background color will be changed when user rolls-over the slice, graph, etc. 
     */
    adjustBorderColor: boolean;

    /**
     * Balloon border opacity. Value range is 0 - 1.
     * @default  1
     */
    borderAlpha: number;

    /**
     * Balloon border color. #FFFFFF 
     */
    borderColor: string;

    /**
     * Balloon border thickness.
     * @default  2
     */
    borderThickness: number;

    /**
     * Color of text in the balloon. #FFFFFF 
     */
    color: string;

    /**
     * Balloon corner radius.
     * @default  6
     */
    cornerRadius: number;

    /**
     * Balloon background opacity.
     * @default  1
     */
    fillAlpha: number;

    /**
     * Balloon background color. Usually balloon background color is set by the chart. Only if "adjustBorderColor" is "true" this color will be used. #CC0000 
     */
    fillColor: string;

    /**
     * Size of text in the balloon. Chart's fontSize is used by default. 
     */
    fontSize: string;

    /**
     * Horizontal padding of the balloon.
     * @default  8
    3
    */
    horizontalPadding: number;

    /**
     * The width of the pointer (arrow) "root". Only used if cornerRadius is 0.
     * @default  10
     */
    pointerWidth: number;

    /**
     * If cornerRadius of a balloon is >0, showBullet is set to true for value balloons when ChartCursor is used. If you don't want the bullet near the balloon, set it to false: chart.balloon.showBullet = false 
     */
    showBullet: boolean;

    /**
     * Text alignment, possible values "left", "middle" and "right" middle 
     */
    textAlign: string;

    /**
     * Color of the text shadow. #000000 
     */
    textShadowColor: string;

    /**
     * Vertical padding of the balloon.
     * @default  5
     */
    verticalPadding: number;

    /**
     * Hides balloon. 
     */
    hide(): void;

    /**
     * Defines a square within which the balloon should appear. Bounds are set by chart class, you don't need to call this method yourself. 
     */
    setBounds(left: number, top: number, right: number, bottom: number): void;

    /**
     * Sets coordinates the balloon should point to. 
     */
    setPosition(x: number, y: number): void;

    /**
     * Specifies the text which should be displayed. 
     */
    show(value: string): void
}


/**
 * CategoryAxesSettings settings set's settings common for all CategoryAxes of StockPanels. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of CategoryAxis class will be used. 
 */
declare class CategoryAxesSettings {

    /**
     * Specifies whether number of gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. 
     */
    axisAlpha: number;

    /**
     * Axis color. 
     */
    axisColor: string;

    /**
     * Height of category axes. Set it to 0 if you set inside property to true.
     * @default  28
     */
    axisHeight: number;

    /**
     * Thickness of the axis. 
     */
    axisThickness: number;

    /**
     * Text color. 
     */
    color: string;

    /**
     * Length of a dash. 
     */
    dashLength: number;

    /**
     * Date formats of different periods. Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, WW - weeks, YYYY - years. Check this page for date formatting strings. 
     */
    dateFormats: any[];

    /**
     * If you want data points to be placed at equal intervals (omiting dates with no data), set equalSpacing to true. 
     */
    equalSpacing: boolean;

    /**
     * Fill opacity. Every second space between grid lines can be filled with fillColor. 
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. 
     */
    fillColor: string;

    /**
     * Text size. 
     */
    fontSize: string;

    /**
     * Opacity of grid lines. 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. 
     */
    gridColor: string;

    /**
     * Approximate number of grid lines. You should set autoGridCount to false in order this property not to be ignored.
     * @default  10
     */
    gridCount: number;

    /**
     * Thickness of grid lines. 
     */
    gridThickness: number;

    /**
     * Periods to which data will be gruoped in case there are more data items in the selected period than specified in maxSeries property. ["ss", "10ss", "30ss", "mm", "10mm", "30mm", "hh", "DD", "WW", "MM", "YYYY"] 
     */
    groupToPeriods: any[];

    /**
     * Specifies whether values should be placed inside or outside of plot area. 
     */
    inside: boolean;

    /**
     * Rotation angle of a label. 
     */
    labelRotation: number;

    /**
     * Maximum series shown at a time. In case there are more data points in the selection than maxSeries, the chart will group data to longer periods, for example - you have 250 days in the selection, and maxSeries is 150 - the chart will group data to weeks.
     * @default  150
     */
    maxSeries: number;

    /**
     * Specifies the shortest period of your data. fff - millisecond, ss - second, mm - minute, hh - hour, DD - day, MM - month, YYYY - year. DD 
     */
    minPeriod: string;

    /**
     * top or "bottom". 
     */
    position: string;

    /**
     * Specifies whether the graph should start on axis or not. In case you display columns, it is recommended to set this to false. startOnAxis can be set to true only if equalSpacing is set to true. 
     */
    startOnAxis: boolean;

    /**
     * Tick length. 
     */
    tickLength: number
}


/**
 * ChartCursorSettings settings set's settings for chart cursor. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of ChartCursor class will be used. 
 */
declare class ChartCursorSettings {

    /**
     * Specifies if bullet for each graph will follow the cursor. 
     */
    bulletsEnabled: boolean;

    /**
     * Size of bullets, following the cursor. 
     */
    bulletSize: number;

    /**
     * Opacity of the category balloon. 
     */
    categoryBalloonAlpha: number;

    /**
     * Color of the category balloon. 
     */
    categoryBalloonColor: string;

    /**
     * Array of date format objects. Date format object must have "period" and "format" items. Available periods are: fff - millisecond, ss - second, mm - minute, hh - hour, DD - date, WW - week, MM - month, YYYY - year. [{period:"YYYY", format:"YYYY"}, {period:"MM", format:"MMM, YYYY"}, {period:"WW", format:"MMM DD, YYYY"}, {period:"DD", format:"MMM DD, YYYY"}, {period:"hh", format:"JJ:NN"}, {period:"mm", format:"JJ:NN"}, {period:"ss", format:"JJ:NN:SS"}, {period:"fff", format:"JJ:NN:SS"}] 
     */
    categoryBalloonDateFormats: any[];

    /**
     * Specifies whether category balloon is enabled. 
     */
    categoryBalloonEnabled: boolean;

    /**
     * Opacity of the cursor line. 
     */
    cursorAlpha: number;

    /**
     * Color of the cursor line. 
     */
    cursorColor: string;

    /**
     * Possible values: "start", "middle" and "mouse". 
     */
    cursorPosition: string;

    /**
     * Set this to "false" if you don't want chart cursor to appear in your charts.
     * @default  true
     */
    enabled: boolean;

    /**
     * If this is set to true, the user will be able to pan the chart instead of zooming. 
     */
    pan: boolean;

    /**
     * Specifies whether value balloons are enabled. In case they are not, the balloons might be displayed anyway, when the user rolls-over the column or bullet. 
     */
    valueBalloonsEnabled: boolean;

    /**
     * Specifies if the user can zoom-in the chart. If pan is set to true, zoomable is switched to false automatically. 
     */
    zoomable: boolean
}

declare class ChartScrollbarSettings {

    /**
     * Specifies whether number of gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Background opacity. 
     */
    backgroundAlpha: number;

    /**
     * Background color of the scrollbar. 
     */
    backgroundColor: string;

    /**
     * Text color. 
     */
    color: string;

    /**
     * Set false if you don't need scrollbar.
     * @default  true
     */
    enabled: boolean;

    /**
     * Font size. 
     */
    fontSize: string;

    /**
     * Specifies which graph will be displayed in the scrollbar. 
     */
    graph: AmCharts$AmGraph;

    /**
     * Graph fill opacity. 
     */
    graphFillAlpha: number;

    /**
     * Graph fill color. 
     */
    graphFillColor: string;

    /**
     * Graph line opacity. 
     */
    graphLineAlpha: number;

    /**
     * Graph line color. 
     */
    graphLineColor: string;

    /**
     * Type of chart scrollbar's graph. By default the graph type is the same as the original graph's type, however in case of candlestick or ohlc you might want to show line graph in the scrollbar. Possible values are: line, column, step, smoothedLine, candlestick, ohlc. 
     */
    graphType: string;

    /**
     * Grid opacity. 
     */
    gridAlpha: number;

    /**
     * Grid color. 
     */
    gridColor: string;

    /**
     * Grid count. You should set autoGridCount to false in order this property to work. 
     */
    gridCount: number;

    /**
     * Height of scrollbar, in pixels.
     * @default  40
     */
    height: number;

    /**
     * Specifies whether resize grips are hidden when mouse is away from the scrollbar. 
     */
    hideResizeGrips: boolean;

    /**
     * Duration of scrolling, when the user clicks on scrollbar's background, in seconds. 
     */
    scrollDuration: number;

    /**
     * Selected background opacity. 
     */
    selectedBackgroundAlpha: number;

    /**
     * Selected background color. 
     */
    selectedBackgroundColor: string;

    /**
     * Selected graph'sfill opacity. 
     */
    selectedGraphFillAlpha: number;

    /**
     * Selected graph'sfill color. 
     */
    selectedGraphFillColor: string;

    /**
     * Selected graph'sline opacity. 
     */
    selectedGraphLineAlpha: number;

    /**
     * Selected graph's line color. 
     */
    selectedGraphLineColor: string;

    /**
     * Specifies if the chart should be updated while dragging/resizing the scrollbar or only at the moment when user releases mouse button. Usefull when working with large data sets.
     * @default  true
     */
    updateOnReleaseOnly: boolean
}


/**
 * AmGraph class displays all types of graphs - line, column, step line, smoothed line, ohlc and candlestick.
 * @example  var chart = new AmCharts.AmSerialChart();
var graph = new AmCharts.AmGraph();
graph.valueField = 'value';
graph.type = 'column';
graph.fillAlphas = 1;
chart.addGraph(graph);
*/
declare class AmGraph {

    /**
     * Name of the alpha field in your dataProvider. 
     */
    alphaField: string;

    /**
     * Value balloon color. Will use graph or data item color if not set. 
     */
    balloonColor: string;

    /**
     * If you set some function, the graph will call it and pass GraphDataItem and AmGraph object to it. This function should return a string which will be displayed in a balloon.  
     */
    balloonFunction(graphDataItem: AmCharts$GraphDataItem, amGraph: AmCharts$AmGraph): string;

    /**
     * Balloon text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]] [[value]] 
     */
    balloonText: string;

    /**
     * Specifies if the line graph should be placed behind column graphs 
     */
    behindColumns: boolean;

    /**
     * Type of the bullets. Possible values are: "none", "round", "square", "triangleUp", "triangleDown", "bubble", "custom". none 
     */
    bullet: string;

    /**
     * Opacity of bullets. Value range is 0 - 1.
     * @default  1
     */
    bulletAlpha: number;

    /**
     * Bullet border opacity.
     * @default  1
     */
    bulletBorderAlpha: number;

    /**
     * Bullet border color. Will use lineColor if not set.   
     */
    bulletBorderColor: string;

    /**
     * Bullet border thickness.
     * @default  2
     */
    bulletBorderThickness: number;

    /**
     * Bullet color. Will use lineColor if not set. 
     */
    bulletColor: string;

    /**
     * Name of the bullet field in your dataProvider. 
     */
    bulletField: string;

    /**
     * Bullet offset. Distance from the actual data point to the bullet. Can be used to place custom bullets above the columns. 
     */
    bulletOffset: number;

    /**
     * Bullet size.
     * @default  8
     */
    bulletSize: number;

    /**
     * Name of the bullet size field in your dataProvider. 
     */
    bulletSizeField: string;

    /**
     * Name of the close field (used by candlesticks and ohlc) in your dataProvider. 
     */
    closeField: string;

    /**
     * Color of value labels. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Name of the color field in your dataProvider. 
     */
    colorField: string;

    /**
     * Specifies whether to connect data points if data is missing. The default value is true.
     * @default  true
     */
    connect: boolean;

    /**
     * Corner radius of column. It can be set both in pixels or in percents. The chart's depth and angle styles must be set to 0. The default value is 0. Note, cornerRadiusTop will be applied for all corners of the column, JavaScript charts do not have a possibility to set separate corner radius for top and bottom. As we want all the property names to be the same both on JS and Flex, we didn't change this too. 
     */
    cornerRadiusTop: number;

    /**
     * If bulletsEnabled of ChartCurosor is true, a bullet on each graph follows the cursor. You can set opacity of each graphs bullet. In case you want to disable these bullets for a certain graph, set opacity to 0.
     * @default  1
     */
    cursorBulletAlpha: number;

    /**
     * Path to the image of custom bullet. 
     */
    customBullet: string;

    /**
     * Name of the custom bullet field in your dataProvider. 
     */
    customBulletField: string;

    /**
     * Dash length. If you set it to a value greater than 0, the graph line will be dashed. 
     */
    dashLength: number;

    /**
     * Name of the description field in your dataProvider. 
     */
    descriptionField: string;

    /**
     * Opacity of fill. Plural form is used to keep the same property names as our Flex charts'. Flex charts can accept array of numbers to generate gradients. Although you can set array here, only first value of this array will be used. 
     */
    fillAlphas: number;

    /**
     * Fill color. Will use lineColor if not set. 
     */
    fillColors: any;

    /**
     * Name of the fill colors field in your dataProvider. 
     */
    fillColorsField: string;

    /**
     * You can set another graph here and if fillAlpha is >0, the area from this graph to fillToGraph will be filled (instead of filling the area to the X axis). 
     */
    fillToGraph: AmCharts$AmGraph;

    /**
     * Size of value labels text. Will use chart's fontSize if not set. 
     */
    fontSize: string;

    /**
     * Orientation of the gradient fills (only for "column" graph type). Possible values are "vertical" and "horizontal". vertical 
     */
    gradientOrientation: string;

    /**
     * Specifies whether the graph is hidden. Do not use this to show/hide the graph, use hideGraph(graph) and showGraph(graph) methods instead. 
     */
    hidden: boolean;

    /**
     * If there are more data points than hideBulletsCount, the bullets will not be shown. 0 means the bullets will always be visible. 
     */
    hideBulletsCount: number;

    /**
     * Name of the high field (used by candlesticks and ohlc) in your dataProvider. 
     */
    highField: string;

    /**
     * Whether to include this graph when calculating min and max value of the axis.
     * @default  true
     */
    includeInMinMax: boolean;

    /**
     * Name of label color field in data provider. 
     */
    labelColorField: string;

    /**
     * Position of value label. Possible values are: "bottom", "top", "right", "left", "inside", "middle". Sometimes position is changed by the chart, depending on a graph type, rotation, etc. top 
     */
    labelPosition: string;

    /**
     * Value label text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]]. 
     */
    labelText: string;

    /**
     * Legend marker opacity. Will use lineAlpha if not set. Value range is 0 - 1. 
     */
    legendAlpha: number;

    /**
     * Legend marker color. Will use lineColor if not set. 
     */
    legendColor: string;

    /**
     * Legend value text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]] You can also use custom fields from your dataProvider. If not set, uses Legend's valueText. 
     */
    legendValueText: string;

    /**
     * Opacity of the line (or column border). Value range is 0 - 1.
     * @default  1
     */
    lineAlpha: number;

    /**
     * Color of the line (or column border). If you do not set any, the color from [[AmCoordinateChart 
     */
    lineColor: string;

    /**
     * Name of the line color field (used by columns and candlesticks only) in your dataProvider. 
     */
    lineColorField: string;

    /**
     * Specifies thickness of the graph line (or column border).
     * @default  1
     */
    lineThickness: number;

    /**
     * Name of the low field (used by candlesticks and ohlc) in your dataProvider. 
     */
    lowField: string;

    /**
     * Legend marker type. You can set legend marker (key) type for individual graphs. Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble". 
     */
    markerType: string;

    /**
     * Specifies size of the bullet which value is the biggest (XY chart).
     * @default  50
     */
    maxBulletSize: number;

    /**
     * Specifies minimum size of the bullet (XY chart). 
     */
    minBulletSize: number;

    /**
     * If you use different colors for your negative values, a graph below zero line is filled with negativeColor. With this property you can define a different base value at which colors should be changed to negative colors. 
     */
    negativeBase: number;

    /**
     * Fill opacity of negative part of the graph. Will use fillAlphas if not set. 
     */
    negativeFillAlphas: number;

    /**
     * Fill color of negative part of the graph. Will use fillColors if not set. 
     */
    negativeFillColors: any;

    /**
     * Color of the line (or column) when the values are negative. In case the graph type is candlestick or ohlc, negativeLineColor is used when close value is less then open value. 
     */
    negativeLineColor: string;

    /**
     * Example: {precision:-1, decimalSeparator:'.', thousandsSeparator:','}. The graph uses this object's values to format the numbers. Uses chart's numberFormatter if not defined. 
     */
    numberFormatter: AV$Object;

    /**
     * Name of the open field (used by floating columns, candlesticks and ohlc) in your dataProvider. 
     */
    openField: string;

    /**
     * Specifies where data points should be placed - on the beginning of the period (day, hour, etc) or in the middle (only when parseDates property of categoryAxis is set to true). This setting affects Serial chart only. Possible values are "start" and "middle". middle 
     */
    pointPosition: string;

    /**
     * If graph's type is column and labelText is set, graph hides labels which do not fit into the column's space. If you don't want these labels to be hidden, set this to true. 
     */
    showAllValueLabels: boolean;

    /**
     * Specifies whether the value balloon of this graph is shown when mouse is over data item or chart's indicator is over some series.
     * @default  true
     */
    showBalloon: boolean;

    /**
     * Specifies graphs value at which cursor is showed. This is only important for candlestick and ohlc charts, also if column chart has "open" value. Possible values are: "open", "close", "high", "low". close 
     */
    showBalloonAt: string;

    /**
     * If the value axis of this graph has stack types like "regular" or "100%" You can exclude this graph from stacking.
     * @default  true
     */
    stackable: boolean;

    /**
     * Graph title. 
     */
    title: string;

    /**
     * Type of the graph. Possible values are: "line", "column", "step", "smoothedLine", "candlestick", "ohlc". XY and Radar charts can only display "line" type graphs. line 
     */
    type: string;

    /**
     * Name of the url field in your dataProvider. 
     */
    urlField: string;

    /**
     * Target to open URLs in, i.e. _blank, _top, etc. 
     */
    urlTarget: string;

    /**
     * Specifies which value axis the graph will use. Will use the first value axis if not set. 
     */
    valueAxis: AmCharts$ValueAxis;

    /**
     * Name of the value field in your dataProvider. 
     */
    valueField: string;

    /**
     * Specifies whether this graph should be shown in the Legend.
     * @default  true
     */
    visibleInLegend: boolean;

    /**
     * XY chart only. A horizontal value axis object to attach graph to. 
     */
    xAxis: AmCharts$ValueAxis;

    /**
     * XY chart only. Name of the x field in your dataProvider. 
     */
    xField: string;

    /**
     * XY chart only. A vertical value axis object to attach graph to. 
     */
    yAxis: AmCharts$ValueAxis;

    /**
     * XY chart only. Name of the y field in your dataProvider. 
     */
    yField: string
}


/**
 * AxisBase is the base class for ValueAxis and CategoryAxis. It can not be instantiated explicitly. 
 */
declare class AxisBase {

    /**
     * Specifies whether number of gridCount is specified automatically, acoarding to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. Value range is 0 - 1.
     * @default  1
     */
    axisAlpha: number;

    /**
     * Axis color.  #000000 
     */
    axisColor: string;

    /**
     * Thickness of the axis.
     * @default  1
     */
    axisThickness: number;

    /**
     * Color of axis value labels. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Length of a dash. 0 means line is not dashed. 
     */
    dashLength: number;

    /**
     * Fill opacity. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills.  
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. #FFFFFF 
     */
    fillColor: string;

    /**
     * Size of value labels text. Will use chart's fontSize if not set. 
     */
    fontSize: string;

    /**
     * Opacity of grid lines. 0.2 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. #000000 
     */
    gridColor: string;

    /**
     * Number of grid lines. In case this is value axis, or your categoryAxis parses dates, the number is approximate. The default value is 5. If you set autoGridCount to true, this property is ignored.
     * @default  5
     */
    gridCount: number;

    /**
     * Thickness of grid lines.
     * @default  1
     */
    gridThickness: number;

    /**
     * The array of guides belonging to this axis. 
     */
    guides: any[];

    /**
     * If autoMargins of a chart is set to true, but you want this axis not to be measured when calculating margin, set ignoreAxisWidth to true.  
     */
    ignoreAxisWidth: boolean;

    /**
     * Specifies whether values should be placed inside or outside plot area. 
     */
    inside: boolean;

    /**
     * Frequency at which labels should be placed. Doesn't work for CategoryAxis if parseDates is set to true.
     * @default  1
     */
    labelFrequency: number;

    /**
     * Rotation angle of a label. Only horizontal axis' values can be rotated. If you set this for vertical axis, the setting will be ignored. 
     */
    labelRotation: number;

    /**
     * Specifies whether axis displays category axis' labels and value axis' values.
     * @default  true
     */
    labelsEnabled: boolean;

    /**
     * The distance of the axis to the plot area, in pixels. Negative values can also be used.  
     */
    offset: number;

    /**
     * Possible values are: "top", "bottom", "left", "right". If axis is vertical, default position is "left". If axis is horizontal, default position is "bottom".  
     */
    position: string;

    /**
     * Whether to show first axis label or not.
     * @default  true
     */
    showFirstLabel: boolean;

    /**
     * Whether to show last axis label or not.
     * @default  true
     */
    showLastLabel: boolean;

    /**
     * Length of the tick marks.
     * @default  5
     */
    tickLength: number;

    /**
     * Title of the axis. 
     */
    title: string;

    /**
     * Specifies if title should be bold or not.
     * @default  true
     */
    titleBold: boolean;

    /**
     * Color of axis title. Will use text color of chart if not set any. 
     */
    titleColor: string;

    /**
     * Font size of axis title. Will use font size of chart plus two pixels if not set any. 
     */
    titlefontSize: string;

    /**
     * Adds guide to the axis. 
     */
    addGuide(guide: AmCharts$Guide): void;

    /**
     * Removes guide from the axis. 
     */
    removeGuide(guide: AmCharts$Guide): void
}


/**
 * ValueAxis is the class which displays value axis for the chart. The chart can have any number of value axes. For Serial chart one value axis is created automatically. For XY Chart two value axes (horizontal and vertical) are created automatically. 
 */
declare class ValueAxis mixins AxisBase {

    /**
     * Radar chart only. Specifies distance from axis to the axis title (category)  10 
     */
    axisTitleOffset: number;

    /**
     * Read-only. Coordinate of the base value. 
     */
    baseCoord: number;

    /**
     * Specifies base value of the axis. 
     */
    baseValue: number;

    /**
     * If your values represents time units, and you want value axis labels to be formatted as duration, you have to set the duration unit. Possible values are: "ss", "mm", "hh" and "DD". 
     */
    duration: string;

    /**
     * If duration property is set, you can specify what string should be displayed next to day, hour, minute and second. {DD:"d. ", hh:":", mm:":",ss:""} 
     */
    durationUnits: AV$Object;

    /**
     * Radar chart only. Possible values are: "polygons" and "circles". Set "circles" for polar charts. polygons 
     */
    gridType: string;

    /**
     * Unique id of value axis. It is not required to set it, unless you need to tell the graph which exact value axis it should use. 
     */
    id: string;

    /**
     * Specifies whether guide values should be included when calculating min and max of the axis. 
     */
    includeGuidesInMinMax: boolean;

    /**
     * If true, the axis will include hidden graphs when calculating min and max values. 
     */
    includeHidden: boolean;

    /**
     * Specifies whether values on axis can only be integers or both integers and doubles. 
     */
    integersOnly: boolean;

    /**
     * You can use this function to format Value axis labels. This function is called and these parameters are passed: labelFunction(value, valueText, valueAxis);
     * Wherevalueis numeric value, valueText is formatted string and valueAxis is a reference to valueAxis object.

    Ifaxistype is "date", labelFunction will pass different arguments:
    labelFunction(valueText, date, valueAxis)

    Yourfunction should return string.
    */
    labelFunction(value: number, valueText: string, valueAxis: AmCharts$ValueAxis): string;
    labelFunction(valueText: string, data: Date, valueAxis: AmCharts$ValueAxis): string;

    /**
     * Specifies if this value axis' scale should be logarithmic. 
     */
    logarithmic: boolean;

    /**
     * Read-only. Maximum value of the axis. 
     */
    max: number;

    /**
     * If you don't want max value to be calculated by the chart, set it using this property. This value might still be adjusted so that it would be possible to draw grid at rounded intervals. 
     */
    maximum: number;

    /**
     * If your value axis is date-based, you can specify maximum date of the axis. Can be set as date object, timestamp number or string if dataDateFormat is set. 
     */
    maximumData: Date;

    /**
     * Read-only. Minimum value of the axis. 
     */
    min: number;

    /**
     * If you don't want min value to be calculated by the chart, set it using this property. This value might still be adjusted so that it would be possible to draw grid at rounded intervals. 
     */
    minimum: number;

    /**
     * If your value axis is date-based, you can specify minimum date of the axis. Can be set as date object, timestamp number or string if dataDateFormat is set. 
     */
    minimumDate: Date;

    /**
     * If set value axis scale (min and max numbers) will be multiplied by it. I.e. if set to 1.2 the scope of values will increase by 20%. 
     */
    minMaxMultiplier: number;

    /**
     * Works with radar charts only. If you set it to “middle”, labels and data points will be placed in the middle between axes. 
     */
    pointPosition: string;

    /**
     * Possible values are: "top", "bottom", "left", "right". If axis is vertical, default position is "left". If axis is horizontal, default position is "bottom". 
     */
    position: string;

    /**
     * Precision (number of decimals) of values. 
     */
    precision: number;

    /**
     * Radar chart only. Specifies if categories (axes' titles) should be displayed near axes)
     * @default  true
     */
    radarCategoriesEnabled: boolean;

    /**
     * pecifies if graphs's values should be recalculated to percents. 
     */
    recalculateToPercents: boolean;

    /**
     * Specifies if value axis should be reversed (smaller values on top).  
     */
    reversed: boolean;

    /**
     * Stacking mode of the axis. Possible values are: "none", "regular", "100%", "3d". none Note, only graphs of one type will be stacked. 
     */
    stackType: string;

    /**
     * Read-only. Value difference between two grid lines. 
     */
    step: number;

    /**
     * If you set minimum and maximum for your axis, chart adjusts them so that grid would start and end on the beginning and end of plot area and grid would be at equal intervals. If you set strictMinMax to true, the chart will not adjust minimum and maximum of value axis. 
     */
    strictMinMax: boolean;

    /**
     * In case you synchronize one value axis with another, you need to set the synchronization multiplier. Use synchronizeWithAxis method to set with which axis it should be synced. 
     */
    synchronizationMultiplier: number;

    /**
     * One value axis can be synchronized with another value axis. You can use both reference to your axis or id of the axis here. You should set synchronizationMultiplyer in order for this to work. 
     */
    synchronizeWith: AmCharts$ValueAxis;

    /**
     * If this value axis is stacked and has columns, setting valueAxis.totalText = "[[total]]" will make it to display total value above the most-top column. 
     */
    totalText: string;

    /**
     * Color of total text. 
     */
    totalTextColor: string;

    /**
     * Distance from data point to total text. 
     */
    totalTextOffset: number;

    /**
     * This allows you to have logarithmic value axis and have zero values in the data. You must set it to >0 value in order to work. 
     */
    treatZeroAs: number;

    /**
     * Type of value axis. If your values in data provider are dates and you want this axis to show dates instead of numbers, set it to "date". 
     */
    type: string;

    /**
     * Unit which will be added to the value label. 
     */
    unit: string;

    /**
     * Position of the unit. Possible values are "left" and "right". right 
     */
    unitPosition: string;

    /**
     * If true, prefixes will be used for big and small numbers. You can set arrays of prefixes directly to the chart object via prefixesOfSmallNumbers and prefixesOfBigNumbers. 
     */
    usePrefixes: boolean;

    /**
     * If true, values will always be formatted using scientific notation (5e+8, 5e-8...) Otherwise only values bigger then 1e+21 and smaller then 1e-7 will be displayed in scientific notation. 
     */
    useScientificNotation: boolean;

    /**
     * Adds guide to the axis. 
     */
    addGuide(guide: AmCharts$Guide): void;

    /**
     * Adds event listener to the object.  type - string like 'axisChanged' (should be listed in 'events' section of this class or classes which extend this class). handler - function which is called when event happens 
     */
    addListener(type: string, handler: any): void;

    /**
     * Number, - value of coordinate. Returns value of the coordinate.  coordinate - y or x coordinate, in pixels. 
     */
    coordinateToValue(coordinate: number): void;

    /**
     * Number - coordinate Returns coordinate of the value in pixels. value - Number 
     */
    getCoordinate(value: number): void;

    /**
     * Removes guide from the axis.
     */
    removeGuide(guide: AmCharts$Guide): void;

    /**
     * Removes event listener from the object. 
     */
    removeListener(obj: any, type: string, handler: any): void;

    /**
     * One value axis can be synchronized with another value axis. You should set synchronizationMultiplyer in order for this to work. 
     */
    synchronizeWithAxis(axis: AmCharts$ValueAxis): void;

    /**
     * XY Chart only. Zooms-in the axis to the provided values. 
     */
    zoomToValues(startValue: number, endValue: number): void;

    /**
     * Adds event listener of the type "axisZoomed" to the object.
     * @param type Always "axisZoomed".
     * @param handler XY chart only. Dispatched when axis is zoomed.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "axisZoomed". 
                 */
                type: string,
                startValue: Date,
                endValue: Date,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Adds event listener of the type "logarithmicAxisFailed" to the object.
     * @param type Always "logarithmicAxisFailed".
     * @param handler Dispatched when valueAxis is logarithmic and values equal or less then zero were found in data.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "logarithmicAxisFailed". 
                 */
                type: string,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}

declare class Title {

    /**
     * 
     * @default  1 
     */
    alpha: number;

    /**
     * Specifies if the tile is bold or not.
     * @default  false
     */
    bold: boolean;

    /**
     * Text color of a title. 
     */
    color: string;

    /**
     * Unique id of a Title. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Text size 
     */
    size: number;

    /**
     * Text of a label 
     */
    text: string
}

declare class ExportSettings {
    enabled: boolean;
    libs: AV$Object;
    menu: AV$Object
}
declare interface amplifyRequestSettings {
    resourceId: string,
        data?: any,
        success?: (...args: any[]) => void,
        error?: (...args: any[]) => void
}
declare interface amplifyDecoder {
    (data?: any, status?: string, xhr?: JQueryXHR, success?: (...args: any[]) => void, error?: (...args: any[]) => void): void
}
declare interface amplifyDecoders {
    [decoderName: string]: amplifyDecoder,
    jsSend: amplifyDecoder
}
declare type amplifyAjaxSettings = {
    cache?: any,
    dataMap?: {} | ((data: any) => {}),
    decoder?: any
} & JQueryAjaxSettings
declare interface amplifyRequest {
    (resourceId: string, hash?: any, callback?: Function): JQueryPromise<any>,
        (settings: amplifyRequestSettings): JQueryPromise<any>,
        define(resourceId: string, requestType: string, settings?: amplifyAjaxSettings): void,
        define(resourceId: string, resource: (settings: amplifyRequestSettings) => void): void,
        decoders: amplifyDecoders,
        cache: any
}
declare interface amplifySubscribe {
    (topic: string, callback: Function): void,
    (topic: string, context: any, callback: Function, priority?: number): void,
    (topic: string, callback: Function, priority?: number): void
}
declare interface amplifyStorageTypeStore {
    (key: string, value: any, options?: any): void,
    (key: string): any,
    (): any
}
declare type amplifyStore = {
    localStorage: amplifyStorageTypeStore,
    sessionStorage: amplifyStorageTypeStore,
    globalStorage: amplifyStorageTypeStore,
    userData: amplifyStorageTypeStore,
    memory: amplifyStorageTypeStore
} & amplifyStorageTypeStore
declare interface amplifyStatic {
    subscribe: amplifySubscribe,
        unsubscribe(topic: string, callback: Function): void,
        publish(topic: string, ...args: any[]): boolean,
        store: amplifyStore,
        request: amplifyRequest
}
declare var amplify: amplifyStatic;
declare module 'amplify' {
    declare module.exports: typeof amplify
}
declare module 'amplitude' {
    declare interface Config {
        tenant?: string,
            clientId: string,
            redirectUri?: string,
            cacheLocation?: string,
            displayCall?: (urlNavigate: string) => any,
            correlationId?: string,
            loginResource?: string,
            resource?: string,
            endpoints?: any,
            extraQueryParameter?: string,
            postLogoutRedirectUri?: string
    }
    declare     export class Identify {
        set(key: string, value: any): Identify;
        setOnce(key: string, value: any): Identify;
        add(key: string, value: number): Identify;
        append(key: string, value: any): Identify;
        prepend(key: string, value: any): Identify;
        unset(key: string): Identify
    }
    declare     export function init(apiKey: string): void
    declare     export function setVersionName(version: string): void
    declare     export function setUserId(userId: string): void
    declare     export function setDeviceId(id: string): void
    declare     export function regenerateDeviceId(): void
    declare     export function identify(identify: Identify): void
    declare     export function setUserProperties(properties: AV$Object): void
    declare     export function clearUserProperties(): void
    declare     export function setOptOut(optOut: boolean): void
    declare     export function setGroup(groupType: string, groupName: string | string[]): void
    declare     export function logEvent(event: string): void
    declare     export var options: adal$Config;
}
declare module 'amqp-rpc' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export interface CallOptions {
        correlationId?: string,
            autoDeleteCallback?: any
    }
    declare     export interface HandlerOptions {
        queueName?: string,
            durable?: boolean,
            exclusive?: boolean,
            autoDelete?: boolean
    }
    declare     export interface BroadcastOptions {
        ttl?: number,
            onResponse?: any,
            context?: any,
            onComplete?: any
    }
    declare     export interface CommandInfo {
        cmd?: string,
            exchange?: string,
            contentType?: string,
            size?: number
    }
    declare type Callback = (err: AV$Error) => any;
    declare     export interface CallbackWithError {
        (err: any, ...args: any[]): void
    }
    declare     export function factory(opt?: acorn$Options): amqpRPC
    declare     export class amqpRPC {
        constructor(opt?: acorn$Options): this;
        generateQueueName(type: string): string;
        disconnect(): void;
        call<T>(
            cmd: string,
            params: T,
            cb?: Callback,
            context?: any,
            options?: CallOptions): string;
        on<T>(
            cmd: string,
            cb: (param?: T, cb?: Callback, info?: CommandInfo) => void,
            context?: any,
            options?: HandlerOptions): boolean;
        off(cmd: string): boolean;
        callBroadcast<T>(cmd: string, params: T, options?: BroadcastOptions): void;
        onBroadcast<T>(
            cmd: string,
            cb?: (params?: T, cb?: CallbackWithError) => void,
            context?: any,
            options?: any): boolean;
        offBroadcast(cmd: string): boolean
    }
}
declare module 'amqplib/properties' {
    declare interface Replies$Empty {}

    declare interface Replies$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Replies$PurgeQueue {
        messageCount: number
    }

    declare interface Replies$DeleteQueue {
        messageCount: number
    }

    declare interface Replies$AssertExchange {
        exchange: string
    }

    declare interface Replies$Consume {
        consumerTag: string
    }
    declare interface Options$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Options$DeleteQueue {
        messageCount: number
    }

    declare interface Options$AssertExchange {
        exchange: string
    }

    declare interface Options$DeleteExchange {
        ifUnused?: boolean
    }

    declare interface Options$Publish {
        expiration?: string,
            userId?: string,
            CC?: string | string[],
            mandatory?: boolean,
            persistent?: boolean,
            deliveryMode?: boolean | number,
            BCC?: string | string[],
            contentType?: string,
            contentEncoding?: string,
            headers?: any,
            priority?: number,
            correlationId?: string,
            replyTo?: string,
            messageId?: string,
            timestamp?: number,
            type?: string,
            appId?: string
    }

    declare interface Options$Consume {
        consumerTag: string
    }

    declare interface Options$Get {
        noAck?: boolean
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
}
declare module 'amqplib' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare     function connect(url: string, socketOptions?: any): when.Promise<autobahn$Connection >
}
declare module 'amqplib/callback_api' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare type ConfirmChannel = {
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        sendToQueue(
            queue: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        waitForConfirms(callback?: (err: any) => void): void
    } & Channel

    declare     function connect(url: string, socketOptions?: any): when.Promise<autobahn$Connection >
}
declare interface AnalyticsNode$Integrations {
    [index: string]: boolean
}

declare export class Analytics {
    constructor(writeKey: string, opts?: {
        flushAt?: number,
        flushAfter?: number
    }): this;
    identify(
        message: {
            userId: string | number,
            traits?: AV$Object,
            timestamp?: Date,
            context?: AV$Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    track(
        message: {
            userId: string | number,
            event: string,
            properties?: AV$Object,
            timestamp?: Date,
            context?: AV$Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    page(
        message: {
            userId: string | number,
            category?: string,
            name?: string,
            properties?: AV$Object,
            timestamp?: Date,
            context?: AV$Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    alias(
        message: {
            previousId: string | number,
            userId: string | number,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    group(
        message: {
            userId: string | number,
            groupId: string | number,
            traits?: AV$Object,
            context?: AV$Object,
            timestamp?: Date,
            anonymous_id?: string | number,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    flush(
        fn?: (
            err: AV$Error,
            batch: {
                batch: Array<{
                    type: string
                }>,
                messageId: string,
                sentAt: Date,
                timestamp: Date
            }) => void): AnalyticsNode$Analytics
}
declare module 'analytics-node' {
    declare module.exports: typeof AnalyticsNode$Analytics
}
declare export interface aa$ILabelStrategies {
    [strategyName: string]: (
        element: ng$IAugmentedJQueryStatic,
        labelText: string,
        isRequired: boolean) => void
}

declare export interface aa$IFieldGroupStrategies {
    [strategyName: string]: (element: ng$IAugmentedJQueryStatic) => void
}

declare export interface aa$IValMsgPlacementStrategies {
    [strategyName: string]: (
        formFieldElement: ng$IAugmentedJQueryStatic,
        formName: string,
        formFieldName: string) => void
}

declare export interface aa$IValidIconStrategy {
    validIcon: string,
        invalidIcon: string,
        getContainer(element: ng$IAugmentedJQueryStatic): void
}

declare export interface aa$ISpinnerClickStrategies {
    [strategyName: string]: (element: ng$IAugmentedJQueryStatic) => void
}

declare export interface aa$IOnNavigateAwayStrategies {
    [strategyName: string]: (
        rootFormScope: ng$IScope,
        rootForm: ng$IAugmentedJQueryStatic,
        $injector: undefined.IInjectorService) => void
}

declare export interface aa$IValidationMessages {
    [validationKey: string]: string
}

declare export interface aa$IGlobalSettings {
    [settingName: string]: any
}

declare export type aa$IFormExtensionsProvider = {
    defaultLabelStrategy: string,
    defaultFieldGroupStrategy: string,
    defaultValMsgPlacementStrategy: string,
    validIconStrategy: aa$IValidIconStrategy,
    defaultSpinnerClickStrategy: string,
    defaultNotifyTarget: string,
    defaultOnNavigateAwayStrategy: string,
    validationMessages: aa$IValidationMessages,
    valMsgForTemplate: string,
    confirmResetStrategy: () => boolean,
    globalSettings: aa$IGlobalSettings,
    labelStrategies: aa$ILabelStrategies,
    fieldGroupStrategies: aa$IFieldGroupStrategies,
    valMsgPlacementStrategies: aa$IValMsgPlacementStrategies,
    spinnerClickStrategies: aa$ISpinnerClickStrategies,
    onNavigateAwayStrategies: aa$IOnNavigateAwayStrategies
}

declare export interface aa$INotifyPredicate {
    (message: string, options: any, notifier: any): any
}

declare export interface aa$INotifyDefaults {
    success: aa$INotifyPredicate,
        info: aa$INotifyPredicate,
        warning: aa$INotifyPredicate,
        danger: aa$INotifyPredicate,
        error: aa$INotifyPredicate
}

declare export interface aa$INotifyConfig {
    name: string,
        template?: string,
        templateName?: string,
        options: aa$INotifyOptions,
        namedDefaults: aa$INotifyDefaults
}

declare export interface aa$INotifyOptions {
    cssClasses?: string,
        messageType: string,
        allowHtml: boolean,
        message: string
}

declare export type aa$INotifyConfigProvider = {
    notifyConfigs: any,
    defaultTargetContainerName: string,
    defaultNotifyConfig: string,
    addOrUpdateNotifyConfig(name: string, opts: aa$INotifyConfig): void,
    optionsTransformer(options: aa$INotifyOptions, $sce: ng$ISCEService): void
}

declare export interface aa$IExternalFormValidationConfig {
    validations: any,
        ignore?: any,
        globals?: any,
        resolve?: any,
        resolveFn?: (modelValue: string) => string
}
declare interface angular$IModule {
    animation(name: string, animationFactory: undefined.IAnimateFactory): angular$IModule,
        animation(name: string, inlineAnnotatedFunction: any[]): angular$IModule,
        animation(object: AV$Object): angular$IModule
}
/**
 * Provider that returns an instance of $breadcrumb service. It contains the global configuration of the module.
 */
declare export interface ncy$$breadcrumbProvider {

    /**
     * Setter for options defined in a module.config block
     */
    setOptions(options: ncy$breadcrumbProviderOptions): void
}


/**
 * Global configuration options for angular-breadcrumb
 */
declare export interface ncy$breadcrumbProviderOptions {

    /**
     * An existing state's name to be the state is the first step of the breadcrumb
     */
    prefixStateName?: string,

        /**
         * Contains a predefined template's name; 'bootstrap3' (default), 'bootstrap2' or HTML for a custom template. This property is ignored if templateUrl is defined.
         */
        template?: string,

        /**
         * Contains the path to a template file. This property takes precedence over the template property.
         */
        templateUrl?: string,

        /**
         * If true, abstract states are included in the breadcrumb. This option has a lower priority than the state-specific option skip
         */
        includeAbstract?: boolean
}


/**
 * Service responsible for access to $state and for directive configuration.
 */
declare export interface ncy$$breadcrumbService {

    /**
     * Returns the state chain to the current state (i.e. all the steps of the breadcrumb). It's an array of state object enriched with the module-specific property ncyBreadcrumbLink (the href for the breadcrumb step).
     */
    getStatesChain(): undefined.IState[],

        /**
         * Return the last step of the breadcrumb, generally the one relative to the current state, expect if it is configured as skipped (the method returns its parent). As getStatesChain, the state object is enriched with ncyBreadcrumbLink.
         */
        getLastStep(): undefined.IState
}
declare var deferredBootstrapper: angular$IDeferredBootstrapperStatic;
declare module 'angular' {
    declare interface IDeferredBootstrapperStatic {
        bootstrap(configParam: IConfigParam): ng$IPromise<boolean >
    }
    declare interface IConfigParam {
        element?: CSG$Node,
            module?: string,
            resolve: any
    }
    declare interface IPromise<T>{

        /**
         * This method can be used as a replacement for then. Similarly, it takes two parameters, a callback when all promises are resolved and a callback for failure. The resolve callback is going to be called with the result of the list of promises passed to $q.all as separate parameters instead of one parameters which is an array.
         *  
         * @param successCallback Callback for resolved promise, similar to then's one, but takes multiple parameters instead of single array parameter
         * @param errorCallback Callback for error, the same as for then
         */
        spread<TResult>(
            successCallback: (...promiseValues: any[]) => AV$IPromise<TResult>| TResult,
            errorCallback?: (reason: any) => any): AV$IPromise<TResult >
    }
    declare interface IModule {
        animation(name: string, animationFactory: undefined.IAnimateFactory): angular$IModule,
            animation(name: string, inlineAnnotatedFunction: any[]): angular$IModule,
            animation(object: AV$Object): angular$IModule
    }
    declare module.exports: typeof angular
    declare     export interface IAngularStatic {
        scenario: any
    }
    declare interface IInjectStatic {
        (...fns: Function[]): any,
        (...inlineAnnotatedConstructor: any[]): any,
        strictDi(val?: boolean): void
    }
    declare interface IMockStatic {
        dump(obj: any): string,
            inject: angular$IInjectStatic,
            module: {
                (...modules: any[]): any,
                sharedInjector(): void
            },
            TzDate(offset: number, timestamp: number): Date,
            TzDate(offset: number, timestamp: string): Date
    }
    declare type IExceptionHandlerProvider = {
        mode(mode: string): void
    } & angular$IServiceProvider

    declare interface ITimeoutService {
        flush(delay?: number): void,
            flushNext(expectedDelay?: number): void,
            verifyNoPendingTasks(): void
    }
    declare interface IIntervalService {
        flush(millis?: number): number
    }
    declare interface ILogService {
        assertEmpty(): void,
            reset(): void
    }
    declare interface ILogCall {
        logs: string[]
    }
    declare interface IHttpBackendService {

        /**
         * Flushes all pending requests using the trained responses.
         * @param count Number of responses to flush (in the order they arrived). If undefined, all pending requests will be flushed.
         */
        flush(count?: number): void,

            /**
             * Resets all request expectations, but preserves all backend definitions.
             */
            resetExpectations(): void,

            /**
             * Verifies that all of the requests defined via the expect api were made. If any of the requests were not made, verifyNoOutstandingExpectation throws an exception.
             */
            verifyNoOutstandingExpectation(): void,

            /**
             * Verifies that there are no outstanding requests that need to be flushed.
             */
            verifyNoOutstandingRequest(): void,

            /**
             * Creates a new request expectation.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param method HTTP method.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expect(
                method: string,
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for DELETE requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url is as expected.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectDELETE(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for GET requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectGET(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for HEAD requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectHEAD(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for JSONP requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectJSONP(
                url: string | RegExp | ((url: string) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for PATCH requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPATCH(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for POST requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPOST(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for PUT requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPUT(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param method HTTP method.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            when(
                method: string,
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for DELETE requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenDELETE(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for GET requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in request url described above
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenGET(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for HEAD requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenHEAD(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for JSONP requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenJSONP(
                url: string | RegExp | ((url: string) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for PATCH requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPATCH(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for POST requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPOST(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for PUT requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPUT(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler
    }
    declare module 'mock' {
        declare interface IRequestHandler {

            /**
             * Controls the response for a matched request using a function to construct the response.
             * Returns the RequestHandler object for possible overrides.
             * @param func Function that receives the request HTTP method, url, data, headers, and an array of keys to regex matches in the request url and returns an array containing response status (number), data, headers, and status text.
             */
            respond(
                    func: ((
                        method: string,
                        url: string,
                        data: string | AV$Object,
                        headers: AV$Object,
                        params?: any) => [number, string | AV$Object, AV$Object, string])): IRequestHandler,

                /**
                 * Controls the response for a matched request using supplied static data to construct the response.
                 * Returns the RequestHandler object for possible overrides.
                 * @param status HTTP status code to add to the response.
                 * @param data Data to add to the response.
                 * @param headers Headers object to add to the response.
                 * @param responseText Response text to add to the response.
                 */
                respond(
                    status: number,
                    data: string | AV$Object,
                    headers?: AV$Object,
                    responseText?: string): IRequestHandler,

                /**
                 * Controls the response for a matched request using the HTTP status code 200 and supplied static data to construct the response.
                 * Returns the RequestHandler object for possible overrides.
                 * @param data Data to add to the response.
                 * @param headers Headers object to add to the response.
                 * @param responseText Response text to add to the response.
                 */
                respond(
                    data: string | AV$Object,
                    headers?: AV$Object,
                    responseText?: string): IRequestHandler,

                /**
                 * Any request matching a backend definition or expectation with passThrough handler will be passed through to the real backend (an XHR request will be made to the server.)
                 */
                passThrough(): IRequestHandler
        }
    }

    declare interface IAuth0ClientOptions {

        /**
         * Login url if you're using ngRoute
         */
        loginUrl?: string,

            /**
             * Login state if you're using ui-router
             */
            loginState?: string,

            /**
             * Client identifier of your Auth0 application
             */
            clientID: string,

            /**
             * Domain of your Auth0 account
             */
            domain: string,

            /**
             * Use single signon
             */
            sso?: boolean
    }
    declare interface ITokenOptions {
        targetClientId?: string,
            api?: string
    }
    declare interface IAuth0Options {

        /**
         * Connection name
         */
        connection?: string,

            /**
             * Username
             */
            username?: string,

            /**
             * Email address
             */
            email?: string
    }
    declare interface ISuccessCallback {
        (profile?: string, idToken?: string, accessToken?: string, state?: string, refreshToken?: string): void
    }
    declare interface IErrorCallback {
        (error: any): void
    }
    declare interface IAuth0Service {

        /**
         * Hooks to internal Angular events so that a user will be redirected to the login page if trying to visit a restricted resource
         */
        hookEvents(): void,

            /**
             * Performs a token delegation request exchanging th ecurrent token for another one.
             * @param options Token options
             */
            getToken(options?: ITokenOptions): ng$IPromise<any>,

            /**
             * Refreshes the Id token
             * @param refreshToken Refresh token to use when renewing
             */
            refreshIdToken(refreshToken: string): ng$IPromise<any>,

            /**
             * Renews the Id Token with the same scopes as the original token
             * @param id_token Id Token
             */
            renewIdToken(id_token: string): ng$IPromise<any>,

            /**
             * Logs in a user, returning tokens and profile information
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful login
             * @param errorCallback Callback on failed login
             */
            signin(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Displays Lock in signup mode, and logs the user in immediately after a successful signup.
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful signup
             * @param errorCallback Callback on failed signup
             */
            signup(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Performs the "forgot your password" flow.
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful reset
             * @param errorCallback Callback on failed reset
             */
            reset(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Validates the user
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful validation
             * @param errorCallback Callback on failed validation
             */
            validateUser(
                options: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Logs the user out locally by deleting their token from local storage.
             */
            signout(): void,

            /**
             * Reauthenticates the user by using a stored profile and token without going through the login flow.
             * @param profile Profile of the user
             * @param idToken Id token
             * @param accessToken Access token
             * @param state State
             * @param refreshToken Flag to indicate refreshing the token
             */
            authenticate(
                profile?: any,
                idToken?: string,
                accessToken?: string,
                state?: any,
                refreshToken?: boolean): ng$IPromise<any>,

            /**
             * Gets the user's profile
             * @param idToken Id token
             */
            getProfile(idToken?: string): ng$IPromise<any>,
            accessToken: string,
            idToken: string,
            profile: any,
            isAuthenticated: boolean,
            config: any
    }
    declare interface IAuth0ServiceProvider {

        /**
         * Configures the auth service
         * @param options Client options passed into Auth0
         */
        init(options: IAuth0ClientOptions): void,

            /**
             * 
             * @param event Name of the event to handle.
             * @param handler Event handler
             */
            on(event: string, handler: (...args: any[]) => any): void
    }
}
declare module 'angular-dynamic-locale' {
    declare module.exports: typeof ng
}
declare module 'angular-es' {
    declare interface ClassDecorator {
        (target: TFunction): TFunction | void
    }
    declare interface MethodDecorator {
        (target: AV$Object, propertyKey: string | , descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T>| void
    }

    /**
     * Decorated target
     */
    declare type ngESDecorator = {
        (target: AV$Object | Function, ngName?: string, ngArguments?: Array<any>, ngType?: string, injectAsProperty?: Array<string>): void
    } & ClassDecorator & MethodDecorator


    /**
     * Component interface
     * @see  https://docs.angularjs.org/guide/component
     */
    declare interface iComponent {
        template: string,
            selector: string,
            controllerAs?: string,
            require?: string,
            templateUrl?: string,
            transclude?: string,
            bindings?: AV$Object
    }

    /**
     * Register component
     * @param  - component config
     * @returns  - decorated class
     */
    declare     function Component(component: iComponent): ngESDecorator
    declare interface Config {
        tenant?: string,
            clientId: string,
            redirectUri?: string,
            cacheLocation?: string,
            displayCall?: (urlNavigate: string) => any,
            correlationId?: string,
            loginResource?: string,
            resource?: string,
            endpoints?: any,
            extraQueryParameter?: string,
            postLogoutRedirectUri?: string
    }

    /**
     * Register constant
     * @param  - constant name
     * @returns  - decorated class
     */
    declare     function Constant(name: string): ngESDecorator

    /**
     * Register controller
     * @param  - controller name
     * @returns  - decorated class
     */
    declare     function Controller(name: string): ngESDecorator

    /**
     * Register decorator
     * @param  - provider name to decorate
     * @returns  - decorated class
     */
    declare     function Decorator(name: string): ngESDecorator

    /**
     * Register directive
     * @param  - directive selector, can be in hyphen-case
     * @returns  - decorated class
     */
    declare     function Directive(name: string): ngESDecorator

    /**
     * Register factory
     * @param  - factory name
     * @returns  - decorated class
     */
    declare     function Factory(name: string): ngESDecorator
    declare interface Filter {
        getGui(): any,
            isFilterActive(): boolean,
            doesFilterPass(params: any): boolean,
            afterGuiAttached(params?: {
                hidePopup?: Function
            }): void,
            onNewRowsLoaded(): void
    }

    /**
     * Add $inject property to target
     * @param  - dependencies to inject
     * @returns  - decorated class
     */
    declare     function Inject(...dependencies: Array<string>): ngESDecorator

    /**
     * Inject dependencies as properties to target
     * @param  - dependencies to inject
     * @returns  - decorated class
     */
    declare     function InjectAsProperty(...dependencies: Array<string>): ngESDecorator

    /**
     * Attach target to the specified module
     * @param  - module name
     * @returns  - decorated class
     */
    declare     function Module(name: string): ngESDecorator

    /**
     * Register provider
     * @param  - provider name
     * @returns  - decorated class
     */
    declare     function Provider(name: string): ngESDecorator

    /**
     * Register run block
     * @returns  - decorated class
     */
    declare     function Run(): ngESDecorator
    declare interface Service {

        /**
         * Retrieve the current environment
         */
        get: () => string,

            /**
             * Force sets the current environment
             */
            set: (environment: string) => void,

            /**
             * Evaluates current environment against
             * environment parameter.
             */
            is: (environment: string) => boolean,

            /**
             * Retrieves the correct version of a
             * variable for the current environment.
             */
            read: (key: string) => any
    }
    declare type Value = string | number;
}
declare module 'AngularFormly' {
    declare module.exports: typeof AngularFormly
}
declare module 'angular-formly' {
    declare     var angularFormlyDefaultExport: string;
    declare module.exports: typeof angularFormlyDefaultExport
}
declare type AngularFormly$IFieldArray = {} & Array


declare interface AngularFormly$IFieldGroup {
    data?: {
            [key: string]: any
        },
        className?: string,
        elementAttributes?: string,
        fieldGroup?: AngularFormly$IFieldArray,
        form?: AV$Object,
        hide?: boolean,
        hideExpression?: string | AngularFormly$IExpressionFunction,
        key?: string | number,
        model?: string | {
            [key: string]: any
        },
        options?: AngularFormly$IFormOptionsAPI,
        templateOptions?: AngularFormly$ITemplateOptions,
        wrapper?: string | string[]
}

declare interface AngularFormly$IFormOptionsAPI {
    data?: {
            [key: string]: any
        },
        fieldTransform?: Function,
        formState?: AV$Object,
        removeChromeAutoComplete?: boolean,
        resetModel?: Function,
        templateManipulators?: AngularFormly$ITemplateManipulators,
        updateInitialValue?: Function,
        wrapper?: string | string[]
}


/**
 * see http://docs.angular-formly.com/docs/formly-expressions#expressionproperties-validators--messages
 */
declare interface AngularFormly$IExpressionFunction {
    ($viewValue: any, $modelValue: any, scope: AngularFormly$ITemplateScope): any
}

declare interface AngularFormly$IModelOptions {
    updateOn?: string,
        debounce?: number,
        allowInvalid?: boolean,
        getterSetter?: string,
        timezone?: string
}

declare interface AngularFormly$ITemplateManipulator {
    (template: string | HTMLElement, options: AV$Object, scope: AngularFormly$ITemplateScope): string | HTMLElement
}

declare interface AngularFormly$ITemplateManipulators {
    preWrapper?: AngularFormly$ITemplateManipulator[],
        postWrapper?: AngularFormly$ITemplateManipulator[]
}

declare interface AngularFormly$ISelectOption {
    name: string,
        value?: string,
        group?: string
}


/**
 * see http://docs.angular-formly.com/docs/ngmodelattrstemplatemanipulator
 */
declare interface AngularFormly$ITemplateOptions {
    disabled?: boolean,
        maxlength?: number,
        minlength?: number,
        pattern?: string,
        required?: boolean,
        max?: number,
        min?: number,
        placeholder?: number | string,
        tabindex?: number,
        type?: string,
        onBlur?: string | AngularFormly$IExpressionFunction,
        onChange?: string | AngularFormly$IExpressionFunction,
        onClick?: string | AngularFormly$IExpressionFunction,
        onFocus?: string | AngularFormly$IExpressionFunction,
        onKeydown?: string | AngularFormly$IExpressionFunction,
        onKeypress?: string | AngularFormly$IExpressionFunction,
        onKeyup?: string | AngularFormly$IExpressionFunction,
        label?: string,
        description?: string, [key: string]: any,
        options?: Array<AngularFormly$ISelectOption>,
        groupProp?: string,
        valueProp?: string,
        labelProp?: string
}


/**
 * see http://docs.angular-formly.com/docs/field-configuration-object#validators-object
 */
declare interface AngularFormly$IValidator {
    expression: string | AngularFormly$IExpressionFunction,
        message?: string | AngularFormly$IExpressionFunction
}


/**
 * An object which has at least two properties called expression and listener. The watch.expression
 * is added to the formly-form directive's scope (to allow it to run even when hide is true). You
can specify a type ($watchCollection or $watchGroup) via the watcher.type property (defaults to
$watch) and whether you want it to be a deep watch via the watcher.deep property (defaults to false).

see http://docs.angular-formly.com/docs/field-configuration-object#watcher-objectarray-of-watches
*/
declare interface AngularFormly$IWatcher {
    deep?: boolean,
        expression?: string | {
            (field: string, scope: AngularFormly$ITemplateScope): boolean
        },
        listener: (
            field: string,
            newValue: any,
            oldValue: any,
            scope: AngularFormly$ITemplateScope,
            stopWatching: Function) => void,
        type?: string
}

declare interface AngularFormly$IFieldConfigurationObject {

    /**
     * Added in 6.18.0
     * 
    Demo
    see http://angular-formly.com/#/example/other/unique-value-async-validation
    */
    asyncValidators?: {
            [key: string]: string | AngularFormly$IExpressionFunction | AngularFormly$IValidator
        },

        /**
         * This is a great way to add custom behavior to a specific field. It is injectable with the $scope of the
         * field, and anything else you have in your injector.

        see http://docs.angular-formly.com/docs/field-configuration-object#controller-controller-name-as-string--controller-f
        */
        controller?: string | Function,

        /**
         * This is reserved for the developer. You have our guarantee to be able to use this and not worry about
         * future versions of formly overriding your usage and preventing you from upgrading :-)

        see http://docs.angular-formly.com/docs/field-configuration-object#data-object
        */
        data?: {
            [key: string]: any
        },

        /**
         * Use defaultValue to initialize it the model. If this is provided and the value of the
         * model at compile-time is undefined, then the value of the model will be assigned to defaultValue.

        see http://docs.angular-formly.com/docs/field-configuration-object#defaultvalue-any
        */
        defaultValue?: any,

        /**
         * You can specify your own class that will be applied to the formly-field directive (or ng-form of
         * a fieldGroup).

        see http://docs.angular-formly.com/docs/field-configuration-object#classname-string
        */
        className?: string,
        elementAttributes?: {
            [key: string]: string
        },

        /**
         * An object where the key is a property to be set on the main field config and the value is an
         * expression used to assign that property. The value is a formly expressions. The returned value is
        wrapped in $q.when so you can return a promise from your function :-)

        see http://docs.angular-formly.com/docs/field-configuration-object#expressionproperties-object
        */
        expressionProperties?: {
            [key: string]: string | AngularFormly$IExpressionFunction | AngularFormly$IValidator
        },

        /**
         * Uses ng-if. Whether to hide the field. Defaults to false. If you wish this to be conditional, use
         * hideExpression. See below.

        see http://docs.angular-formly.com/docs/field-configuration-object#hide-boolean
        */
        hide?: boolean,

        /**
         * This is similar to expressionProperties with a slight difference. You should (hopefully) never
         * notice the difference with the most common use case. This is available due to limitations with
        expressionProperties and ng-if not working together very nicely.

        see http://docs.angular-formly.com/docs/field-configuration-object#hideexpression-string--function
        */
        hideExpression?: string | AngularFormly$IExpressionFunction,

        /**
         * This allows you to specify the id of your field (which will be used for its name as well unless
         * a name is provided). Note, you can also override the id generation code using the formlyConfig
        extra called getFieldId.

        AVOID THIS
        If you don't have to do this, don't. Specifying IDs makes it harder to re-use things and it's
        just extra work. Part of the beauty that angular-formly provides is the fact that you don't need
        to concern yourself with making sure that this is unique.

        see http://docs.angular-formly.com/docs/field-configuration-object#id-string
        */
        id?: string,
        initialValue?: any,

        /**
         * Can be set instead of type or template to use a custom html template form field. Works
         * just like a directive templateUrl and uses the $templateCache

        see http://docs.angular-formly.com/docs/field-configuration-object#key-string
        */
        key?: string | number,

        /**
         * This allows you to specify a link function. It is invoked after your template has finished compiling.
         * You are passed the normal arguments for a normal link function.

        see http://docs.angular-formly.com/docs/field-configuration-object#link-link-function
        */
        link?: ng$IDirectiveLinkFn,

        /**
         * By default, the model passed to the formly-field directive is the same as the model passed to the
         * formly-form. However, if the field has a model specified, then it is used for that field (and that
        field only). In addition, a deep watch is added to the formly-field directive's scope to run the
        expressionProperties when the specified model changes.

        Note, the formly-form directive will allow you to specify a string which is an (almost) formly
        expression which allows you to define the model as relative to the scope of the form.

        see http://docs.angular-formly.com/docs/field-configuration-object#model-object--string
        */
        model?: string | {
            [key: string]: any
        },

        /**
         * Allows you to take advantage of ng-model-options directive. Formly's built-in templateManipulator (see
         * below) will add this attribute to your ng-model element automatically if this property exists. Note,
        if you use the getter/setter option, formly's templateManipulator will change the value of ng-model
        to options.value which is a getterSetter that formly adds to field options.

        see http://docs.angular-formly.com/docs/field-configuration-object#modeloptions
        */
        modelOptions?: AngularFormly$IModelOptions,

        /**
         * If you wish to, you can specify a specific name for your ng-model. This is useful if you're posting
         * the form to a server using techniques of yester-year.

        AVOID THIS
        If you don't have to do this, don't. It's just extra work. Part of the beauty that angular-formly
        provides is the fact that you don't need to concern yourself with stuff like this.

        see http://docs.angular-formly.com/docs/field-configuration-object#name-string
        */
        name?: string,

        /**
         * This is used by ngModelAttrsTemplateManipulator to automatically add attributes to the ng-model element
         * of field templates. You will likely not use this often. This object is a little complex, but extremely
        powerful. It's best to explain this api via an example. For more information, see the guide on ngModelAttrs.

        see http://docs.angular-formly.com/docs/field-configuration-object#ngmodelattrs-object
        */
        ngModelAttrs?: {
            attribute?: any,
            bound?: any,
            expression?: any,
            value?: any,
            [key: string]: any
        },

        /**
         * This allows you to place attributes with string values on the ng-model element.
         * Easy to use alternative to ngModelAttrs option.

        see http://docs.angular-formly.com/docs/field-configuration-object#ngmodelelattrs-object
        */
        ngModelElAttrs?: {
            [key: string]: string
        },

        /**
         * Used to tell angular-formly to not attempt to add the formControl property to your object. This is useful
         * for things like validation, but not necessary if your "field" doesn't use ng-model (if it's just a horizontal
        line for example). Defaults to undefined.

        see http://docs.angular-formly.com/docs/field-configuration-object#noformcontrol-boolean
        */
        noFormControl?: boolean,

        /**
         * Allows you to specify extra types to get options from. Duplicate options are overridden in later priority
         * (index 1 will override index 0 properties). Also, these are applied after the type's defaultOptions and
        hence will override any duplicates of those properties as well.

        see http://docs.angular-formly.com/docs/field-configuration-object#optionstypes-string--array-of-strings
        */
        optionsTypes?: string | string[],

        /**
         * Can be set instead of type or templateUrl to use a custom html
         * template form field. Recommended to be used with one-liners mostly
        (like a directive), or if you're using webpack with the ability to require templates :-)

        If a function is passed, it is invoked with the field configuration object and can return
        either a string for the template or a promise that resolves to a string.

        see http://docs.angular-formly.com/docs/field-configuration-object#template-string--function
        */
        template?: string | {
            (fieldConfiguration: AngularFormly$IFieldConfigurationObject): string | ng$IPromise<string >
        },

        /**
         * Allows you to specify custom template manipulators for this specific field. (use defaultOptions in a
         * type configuration if you want it to apply to all fields of a certain type).

        see http://docs.angular-formly.com/docs/field-configuration-object#templatemanipulator-object-of-arrays-of-functions
        */
        templateManipulators?: AngularFormly$ITemplateManipulators,

        /**
         * This is reserved for the templates. Any template-specific options go in here. Look at your specific
         * template implementation to know the options required for this.

        see http://docs.angular-formly.com/docs/field-configuration-object#templateoptions-object
        */
        templateOptions?: AngularFormly$ITemplateOptions,

        /**
         * Can be set instead of type or template to use a custom html template form field. Works
         * just like a directive templateUrl and uses the $templateCache

        see http://docs.angular-formly.com/docs/field-configuration-object#templateurl-string--function
        */
        templateUrl?: string | {
            (fieldConfiguration: AngularFormly$IFieldConfigurationObject): string | ng$IPromise<string >
        },

        /**
         * The type of field to be rendered. This is the recommended method
         * for defining fields. Types must be pre-defined using formlyConfig.

        see http://docs.angular-formly.com/docs/field-configuration-object#type-string
        */
        type?: string,

        /**
         * An object with a few useful properties mostly handy when used in combination with ng-messages
         */
        validation?: {

            /**
             * This is set by angular-formly. This is a boolean indicating whether an error message should be shown. Because
             * you generally only want to show error messages when the user has interacted with a specific field, this value
            is set to true based on this rule: field invalid && (field touched || validation.show) (with slight difference
            for pre-angular 1.3 because it doesn't have touched support).
            */
            errorExistsAndShouldBeVisible?: boolean,

            /**
             * A map of Formly Expressions mapped to message names. This is really useful when you're using ng-messages
             * like in this example.
             */
            messages?: {
                [key: string]: AngularFormly$IExpressionFunction | string
            },

            /**
             * A boolean you as the developer can set to specify to force options.validation.errorExistsAndShouldBeVisible
             * to be set to true when there are $errors. This is useful when you're trying to call the user's attention to
            some fields for some reason.
            */
            show?: boolean
        },

        /**
         * An object where the keys are the name of the validator and the values are Formly Expressions;
         * 
        Async Validation
        All function validators can return true/false/Promise. A validator passes if it returns true or a promise
        that is resolved. A validator fails if it returns false or a promise that is rejected.

        see http://docs.angular-formly.com/docs/field-configuration-object#validators-object
        */
        validators?: {
            [key: string]: string | AngularFormly$IExpressionFunction | AngularFormly$IValidator
        },

        /**
         * This is a getter/setter function for the value that your field is representing. Useful when using getterSetter: true
         * in the modelOptions (in fact, if you don't disable the ngModelAttrsTemplateManipulator that comes built-in with formly,
        it will automagically change your field's ng-model attribute to use options.value.

        see http://docs.angular-formly.com/docs/field-configuration-object#value-gettersetter-function
        */
        value(): any,
        value(val: any): void,

        /**
         * An object which has at least two properties called expression and listener. The watch.expression is added
         * to the formly-form directive's scope (to allow it to run even when hide is true). You can specify a type
        ($watchCollection or $watchGroup) via the watcher.type property (defaults to $watch) and whether you want
        it to be a deep watch via the watcher.deep property (defaults to false).

        see http://docs.angular-formly.com/docs/field-configuration-object#watcher-objectarray-of-watches
        */
        watcher?: AngularFormly$IWatcher | AngularFormly$IWatcher[],

        /**
         * This makes reference to setWrapper in formlyConfig. It is expected to be the name of the wrapper. If
         * given an array, the formly field template will be wrapped by the first wrapper, then the second, then
        the third, etc. You can also specify these as part of a type (which is the recommended approach).
        Specifying this property will override the wrappers for the type for this field.

        http://docs.angular-formly.com/docs/field-configuration-object#wrapper-string--array-of-strings
        */
        wrapper?: string | string[],

        /**
         * This is the NgModelController for the field. It provides you with awesome stuff like $errors :-)
         * 
        see http://docs.angular-formly.com/docs/field-configuration-object#formcontrol-ngmodelcontroller
        */
        formControl?: ng$IFormController | ng$IFormController[],

        /**
         * Will reset the field's model and the field control to the last initialValue. This is used by the
         * formly-form's options.resetModel function.

        see http://docs.angular-formly.com/docs/field-configuration-object#resetmodel-function
        */
        resetModel?: () => void,

        /**
         * It is not likely that you'll ever want to invoke this function. It simply runs the expressionProperties expressions.
         * It is used internally and you shouldn't have to use it, but you can if you want to, and any breaking changes to the
        way it works will result in a major version change, so you can rely on its api.

        see http://docs.angular-formly.com/docs/field-configuration-object#runexpressions-function
        */
        runExpressions?: () => void,

        /**
         * Will reset the field's initialValue to the current state of the model. Useful if you load the model asynchronously.
         * Invoke this when the model gets set. This is used by the formly-form's options.updateInitialValue function.

        see http://docs.angular-formly.com/docs/field-configuration-object#updateinitialvalue-function
        */
        updateInitialValue?: () => void
}


/**
 * see http://docs.angular-formly.com/docs/custom-templates#section-formlyconfig-settype-options
 */
declare interface AngularFormly$ITypeOptions {
    apiCheck?: {
            [key: string]: Function
        },
        apiCheckFunction?: string,
        apiCheckInstance?: any,
        apiCheckOptions?: AV$Object,
        defaultOptions?: AngularFormly$IFieldConfigurationObject | Function,
        controller?: Function | string | any[],
        data?: {
            [key: string]: any
        },
        extends?: string,
        link?: ng$IDirectiveLinkFn,
        overwriteOk?: boolean,
        name: string,
        template?: Function | string,
        templateUrl?: Function | string,
        validateOptions?: Function,
        wrapper?: string | string[]
}

declare interface AngularFormly$IWrapperOptions {
    apiCheck?: {
            [key: string]: Function
        },
        apiCheckFunction?: string,
        apiCheckInstance?: any,
        apiCheckOptions?: AV$Object,
        overwriteOk?: boolean,
        name?: string,
        template?: string,
        templateUrl?: string,
        types?: string[],
        validateOptions?: Function
}

declare interface AngularFormly$IFormlyConfigExtras {
    disableNgModelAttrsManipulator: boolean,
        apiCheckInstance: any,
        ngModelAttrsManipulatorPreferUnbound: boolean,
        removeChromeAutoComplete: boolean,
        defaultHideDirective: string,
        errorExistsAndShouldBeVisibleExpression: any,
        getFieldId: Function,
        fieldTransform: Function,
        explicitAsync: boolean
}

declare interface AngularFormly$IFormlyConfig {
    disableWarnings: boolean,
        extras: AngularFormly$IFormlyConfigExtras,
        setType(typeOptions: AngularFormly$ITypeOptions): void,
        setWrapper(wrapperOptions: AngularFormly$IWrapperOptions): void,
        templateManipulators: AngularFormly$ITemplateManipulators
}

declare interface AngularFormly$ITemplateScopeOptions {
    formControl: ng$IFormController | ng$IFormController[],
        templateOptions: AngularFormly$ITemplateOptions,
        validation: AV$Object
}


/**
 * see http://docs.angular-formly.com/docs/custom-templates#templates-scope
 */
declare interface AngularFormly$ITemplateScope {
    options: AngularFormly$ITemplateScopeOptions,
        fc: ng$IFormController | ng$IFormController[],
        fields: AngularFormly$IFieldArray,
        form: any,
        formState: AV$Object,
        id: string,
        index: number,
        model?: string | {
            [key: string]: any
        },
        showError: boolean,
        to: AngularFormly$ITemplateOptions
}

declare export interface AngularFormly$IValidationMessages {
    [validationKey: string]: string
}
declare export type Httpi$HttpiPayload = {
    method?: string,
    url?: string,
    params?: {},
    data?: {},
    keepTrailingSlash?: boolean
}

declare export interface Httpi$HttpiFactory {
    (config: Httpi$HttpiPayload): ng$IHttpPromise<{}>,
        resource(url: string): Httpi$HttpiResource
}

declare export class HttpiResource {
    constructor(http: ng$IHttpService, url: string): this;
    delete<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    get<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    head<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    jsonp<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    post<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    put<T>(config: Httpi$HttpiPayload): ng$IHttpPromise<T>;
    setKeepTrailingSlash(newKeepTrailingSlash: boolean): Httpi$HttpiResource
}
declare module 'angular-locker' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-material' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare type angularModal$AngularModalControllerDefinition = ((...args: any[]) => any) | Function | string;

declare type angularModal$AngularModalJQuerySelector = string |
    angularScenario$Element |
    angularScenario$Element[] |
    JQuery |
    Function |
    any[] |
    {};

declare interface angularModal$AngularModalSettings {
    controller?: angularModal$AngularModalControllerDefinition,
        controllerAs?: string,
        container?: angularModal$AngularModalJQuerySelector
}

declare export type angularModal$AngularModalSettingsWithTemplate = {
    template: any
} & angularModal$AngularModalSettings


declare export type angularModal$AngularModalSettingsWithTemplateUrl = {
    templateUrl: string
} & angularModal$AngularModalSettings


declare export interface angularModal$AngularModal {
    activate(): angular$IPromise<void>,
        deactivate(): angular$IPromise<void>,
        active(): boolean
}

declare export interface angularModal$AngularModalFactory {
    (settings: angularModal$AngularModalSettingsWithTemplate | angularModal$AngularModalSettingsWithTemplateUrl): angularModal$AngularModal
}
/**
 * Currently supported options for the $resource factory options argument.
 */
declare interface OData$IResourceOptions {

    /**
     * If true then the trailing slashes from any calculated URL will be stripped (defaults to true)
     */
    stripTrailingSlashes?: boolean,
        odata?: {
            url?: string,
            method?: string
        },
        isodatav4?: boolean
}

declare interface OData$IResourceService {
    (url: string, paramDefaults?: any, actions?: any, options?: OData$IResourceOptions): OData$IResourceClass<OData$IResource<any >> ,
        (url: string, paramDefaults?: any, actions?: any, options?: OData$IResourceOptions): U,
        (url: string, paramDefaults?: any, actions?: any, options?: OData$IResourceOptions): OData$IResourceClass<T >
}

declare interface OData$IActionDescriptor {
    url?: string,
        method: string,
        isArray?: boolean,
        params?: any,
        headers?: any
}

declare interface OData$IResourceClass<T>{
    new(dataOrParams?: any): OData$IResource<T>,
    get(): OData$IResource<T>,
    get(params: AV$Object): OData$IResource<T>,
    get(success: Function, error?: Function): OData$IResource<T>,
    get(params: AV$Object, success: Function, error?: Function): OData$IResource<T>,
    get(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResource<T>,
    query(): OData$IResourceArray<T>,
    query(params: AV$Object): OData$IResourceArray<T>,
    query(success: Function, error?: Function): OData$IResourceArray<T>,
    query(
        params: AV$Object,
        success: Function,
        error?: Function): OData$IResourceArray<T>,
    query(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResourceArray<T>,
    save(): OData$IResource<T>,
    save(data: AV$Object): OData$IResource<T>,
    save(success: Function, error?: Function): OData$IResource<T>,
    save(data: AV$Object, success: Function, error?: Function): OData$IResource<T>,
    save(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResource<T>,
    update(): OData$IResource<T>,
    update(data: AV$Object): OData$IResource<T>,
    update(success: Function, error?: Function): OData$IResource<T>,
    update(data: AV$Object, success: Function, error?: Function): OData$IResource<T>,
    update(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResource<T>,
    remove(): OData$IResource<T>,
    remove(params: AV$Object): OData$IResource<T>,
    remove(success: Function, error?: Function): OData$IResource<T>,
    remove(params: AV$Object, success: Function, error?: Function): OData$IResource<T>,
    remove(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResource<T>,
    delete(): OData$IResource<T>,
    delete(params: AV$Object): OData$IResource<T>,
    delete(success: Function, error?: Function): OData$IResource<T>,
    delete(params: AV$Object, success: Function, error?: Function): OData$IResource<T>,
    delete(
        params: AV$Object,
        data: AV$Object,
        success?: Function,
        error?: Function): OData$IResource<T>,
    odata(): OData$Provider<T >
}

declare interface OData$IResource<T>{
    $get(): angular$IPromise<T>,
    $get(params?: AV$Object, success?: Function, error?: Function): angular$IPromise<T>,
    $get(success: Function, error?: Function): angular$IPromise<T>,
    $query(): angular$IPromise<OData$IResourceArray<T >> ,
    $query(
        params?: AV$Object,
        success?: Function,
        error?: Function): angular$IPromise<OData$IResourceArray<T >> ,
    $query(success: Function, error?: Function): angular$IPromise<OData$IResourceArray<T >> ,
    $save(): angular$IPromise<T>,
    $save(params?: AV$Object, success?: Function, error?: Function): angular$IPromise<T>,
    $save(success: Function, error?: Function): angular$IPromise<T>,
    $update(): angular$IPromise<T>,
    $update(params?: AV$Object, success?: Function, error?: Function): angular$IPromise<T>,
    $update(success: Function, error?: Function): angular$IPromise<T>,
    $remove(): angular$IPromise<T>,
    $remove(params?: AV$Object, success?: Function, error?: Function): angular$IPromise<T>,
    $remove(success: Function, error?: Function): angular$IPromise<T>,
    $delete(): angular$IPromise<T>,
    $delete(params?: AV$Object, success?: Function, error?: Function): angular$IPromise<T>,
    $delete(success: Function, error?: Function): angular$IPromise<T>,

    /**
     * the promise of the original server interaction that created this instance. 
     */
    $promise: angular$IPromise<T>,
    $resolved: boolean
}


/**
 * Really just a regular Array object with $promise and $resolve attached to it
 */
declare type OData$IResourceArray<T>= {

    /**
     * the promise of the original server interaction that created this collection. 
     */
    $promise: angular$IPromise<OData$IResourceArray<T >> ,
    $resolved: boolean
} & Array



/**
 * when creating a resource factory via IModule.factory 
 */
declare interface OData$IResourceServiceFactoryFunction<T>{
    ($resource: OData$IResourceService): OData$IResourceClass<T>,
    ($resource: OData$IResourceService): U
}

declare type OData$IResourceServiceProvider = {
    defaults: OData$IResourceOptions
}

declare interface OData$IExecutable {
    execute(noParenthesis?: any): string
}

declare class Global {
    $inject: string[];
    constructor(ODataBinaryOperation: any, ODataProvider: any, ODataValue: any, ODataProperty: any, ODataMethodCall: any, ODataPredicate: any, ODataOrderByStatement: any): this;
    Provider: OData$Provider<any>;
    BinaryOperation: typeof BinaryOperation;
    Value: typeof Value;
    Property: typeof Property;
    Func: typeof MethodCall;
    Predicate: typeof Predicate;
    OrderBy: typeof OrderByStatement
}

declare interface OData$BinaryOperationFactory {
    new(
        propertyOrPredicate: any,
        valueOrOperator?: any,
        value?: any): OData$BinaryOperation
}

declare class BinaryOperation mixins IExecutable {
    constructor(propertyOrPredicate: any, valueOrOperator?: any, value?: any): this;
    execute(noParenthesis?: any): string;
    or(
        propertyOrPredicate: any,
        operatorOrValue?: any,
        value?: any): OData$BinaryOperation;
    and(
        propertyOrPredicate: any,
        operatorOrValue?: any,
        value?: any): OData$BinaryOperation
}

declare interface OData$MethodCallFactory {
    new(methodName: string, ...args: any[]): OData$MethodCall
}

declare class MethodCall mixins IExecutable {
    execute(): string;
    constructor(methodName: string, ...args: any[]): this
}

declare class Operators {
    operators: {
        eq: string[],
        ne: string[],
        gt: string[],
        ge: string[],
        lt: string[],
        le: string[],
        and: string[],
        or: string[],
        not: string[],
        add: string[],
        sub: string[],
        mul: string[],
        div: string[],
        mod: string[]
    };
    convert(from: string): any
}

declare interface OData$OrderByStatementFactory {
    new(propertyName: string, sortOrder?: string): OData$OrderByStatement
}

declare class OrderByStatement mixins IExecutable {
    execute(): string;
    constructor(propertyName: string, sortOrder?: string): this
}

declare interface OData$PredicateFactory {
    new(
        propertyOrValueOrPredicate: any,
        valueOrOperator?: any,
        value?: any): OData$Predicate,
    or(orStatements: any[]): OData$IExecutable,
        create(
            propertyOrPredicate: any,
            operatorOrValue?: any,
            value?: any): OData$IExecutable,
        and(andStatements: any): OData$IExecutable
}

declare class Predicate mixins BinaryOperation {
    constructor(propertyOrValueOrPredicate: any, valueOrOperator?: any, value?: any): this;
    or(orStatements: any[]): OData$IExecutable;
    create(
        propertyOrPredicate: any,
        operatorOrValue?: any,
        value?: any): OData$IExecutable;
    and(andStatements: any): OData$IExecutable
}

declare interface OData$PropertyFactory {
    new(value: string): OData$Property
}

declare class Property mixins IExecutable {
    constructor(value: string): this;
    execute(): string
}

declare interface OData$ProviderFactory {
    new<T>(callback: OData$ProviderCallback<T>): OData$Provider<T >
}

declare interface OData$ProviderCallback<T>{
    (queryString: string, success: () => any, error: () => any): T[],
    (queryString: string, success: () => any, error: () => any, isSingleElement?: boolean, forceSingleElement?: boolean): T
}

declare interface OData$ICountResult {
    result: number,
        $promise: angular$IPromise<any >
}

declare class Provider<T>{
    constructor(callback: OData$ProviderCallback<T>): this;
    filter(operand1: any, operand2?: any, operand3?: any): OData$Provider<T>;
    orderBy(arg1: string, arg2?: string): OData$Provider<T>;
    transformUrl(transformMethod: (url: string) => string): OData$Provider<T>;
    take(amount: number): OData$Provider<T>;
    skip(amount: number): OData$Provider<T>;
    query(success?: ((p: T[]) => void), error?: (() => void)): T[];
    single(success?: ((p: T) => void), error?: (() => void)): T;
    get(key: any, success?: ((p: T) => void), error?: (() => void)): T;
    expand(...params: string[]): OData$Provider<T>;
    expand(params: string[]): OData$Provider<T>;
    select(...params: string[]): OData$Provider<T>;
    select(params: string[]): OData$Provider<T>;
    count(
        success?: (result: OData$ICountResult) => any,
        error?: () => any): OData$ICountResult;
    withInlineCount(): OData$Provider<T >
}

declare interface OData$ValueFactory {
    new(value: any, type?: string): OData$Value
}

declare class ValueTypes {
    Boolean: string;
    Byte: string;
    DateTime: string;
    Decimal: string;
    Double: string;
    Single: string;
    Guid: string;
    Int32: string;
    String: string
}

declare class Value {
    executeWithUndefinedType(): any;
    executeWithType(): any;
    execute(): string;
    constructor(value: any, type?: string): this
}
declare module 'angular-permission' {
    declare     export var permission: string;
    declare     export var ngPermission: string;
    declare     export var uiPermission: string;
}

declare var npm$namespace$protractor: {
    wrapDriver: typeof protractor$wrapDriver,
}
declare class ActionSequence mixins webdriver.ActionSequence {}

declare class Builder mixins webdriver.Builder {}

declare class Capabilities mixins webdriver.Capabilities {}

declare class Command mixins webdriver.Command {}

declare class EventEmitter mixins webdriver.EventEmitter {}

declare class Session mixins webdriver.Session {}

declare class WebDriver mixins webdriver.WebDriver {}

declare class WebElement mixins webdriver.WebElement {}

declare class WebElementPromise mixins webdriver.WebElementPromise {}

declare var Browser: webdriver.IBrowser;

declare var Button: webdriver.IButton;

declare var Capability: webdriver.ICapability;

declare var CommandName: webdriver.ICommandName;

declare var Key: webdriver.IKey;

declare class Error mixins undefined.Error {}

declare var ErrorCode: undefined.IErrorCode;


declare var npm$namespace$logging: {
    getLevel: typeof logging$getLevel,
}
declare class Preferences mixins undefined.Preferences {}

declare class Entry mixins undefined.Entry {}

declare var Type: undefined.IType;

declare var Level: undefined.ILevelValues;

declare function logging$getLevel(nameOrValue: string): undefined.ILevel


declare var npm$namespace$promise: {
    all: typeof promise$all,
    asap: typeof promise$asap,
    controlFlow: typeof promise$controlFlow,
    createFlow: typeof promise$createFlow,
    isPromise: typeof promise$isPromise,
    isGenerator: typeof promise$isGenerator,
    delayed: typeof promise$delayed,
    filter: typeof promise$filter,
    defer: typeof promise$defer,
    fulfilled: typeof promise$fulfilled,
    map: typeof promise$map,
    rejected: typeof promise$rejected,
    checkedNodeCall: typeof promise$checkedNodeCall,
    consume: typeof promise$consume,
    when: typeof promise$when,
    fullyResolved: typeof promise$fullyResolved,
    setDefaultFlow: typeof promise$setDefaultFlow,
}
declare class Thenable<T>mixins undefined.Thenable<T>{}

declare class Promise<T>mixins undefined.Promise<T>{}

declare class Deferred<T>mixins undefined.Deferred<T>{}

declare class ControlFlow mixins undefined.ControlFlow {}

declare class CancellationError mixins undefined.CancellationError {}


/**
 * Given an array of promises, will return a promise that will be fulfilled
 * with the fulfillment values of the input array's values. If any of the
input array's promises are rejected, the returned promise will be rejected
with the same reason.
 * @param  An array of
promises to wait on.
 * @return  A promise that is
fulfilled with an array containing the fulfilled values of the
input array, or rejected with the same reason as the first
rejected value.
 * @template  
*/
declare function promise$all(arr: undefined.Promise<any>[]): undefined.Promise<any[] >


    /**
     * Invokes the appropriate callback function as soon as a promised
     * {
     * @code  value} is resolved. This function is similar to
    {
     * @link  webdriver.promise.when}, except it does not return a new promise.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
    */
    declare function promise$asap(value: any, callback: Function, opt_errback?: Function): void


/**
 * 
 * @return  The currently active control flow.
 */
declare function promise$controlFlow(): undefined.ControlFlow


/**
 * Creates a new control flow. The provided callback will be invoked as the
 * first task within the new flow, with the flow as its sole argument. Returns
a promise that resolves to the callback result.
 * @param  The entry point
to the newly created flow.
 * @return  A promise that resolves to the callback
result.
*/
declare function promise$createFlow<R>(callback: (flow: undefined.ControlFlow) => R): undefined.Promise<R >


    /**
     * Determines whether a {@code value} should be treated as a promise.
     * Any object whose "then" property is a function will be considered a promise.
     * @param  The value to test.
     * @return  Whether the value is a promise.
     */
    declare function promise$isPromise(value: any): boolean


/**
 * Tests is a function is a generator.
 * @param  The function to test.
 * @return  Whether the function is a generator.
 */
declare function promise$isGenerator(fn: Function): boolean


/**
 * Creates a promise that will be resolved at a set time in the future.
 * @param  The amount of time, in milliseconds, to wait before
resolving the promise.
 * @return  The promise.
*/
declare function promise$delayed(ms: number): undefined.Promise<void >


    /**
     * Calls a function for each element in an array, and if the function returns
     * true adds the element to a new array.

    <p>If the return value of the filter function is a promise, this function
    will wait for it to be fulfilled before determining whether to insert the
    element into the new array.

    <p>If the filter function throws or returns a rejected promise, the promise
    returned by this function will be rejected with the same reason. Only the
    first failure will be reported; all subsequent errors will be silently
    ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  |webdriver.promise.Promise.<boolean>)} fn The function
    to call for each element in the array.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$filter<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): undefined.Promise<T[] >


    /**
     * Creates a new deferred object.
     * @return  The new deferred object.
     */
    declare function promise$defer<T>(): undefined.Deferred<T >


    /**
     * Creates a promise that has been resolved with the given value.*=} opt_value The resolved value.
     * @return  The resolved promise.
     */
    declare function promise$fulfilled<T>(opt_value?: T): undefined.Promise<T >


    /**
     * Calls a function for each element in an array and inserts the result into a
     * new array, which is used as the fulfillment value of the promise returned
    by this function.

    <p>If the return value of the mapping function is a promise, this function
    will wait for it to be fulfilled before inserting it into the new array.

    <p>If the mapping function throws or returns a rejected promise, the
    promise returned by this function will be rejected with the same reason.
    Only the first failure will be reported; all subsequent errors will be
    silently ignored.
     * @param  The
    array to iterator over, or a promise that will resolve to said array.
     * @param  The
    function to call for each element in the array. This function should
    expect three arguments (the element, the index, and the array itself.
     * @param  The object to be used as the value of 'this' within
    {
     * @code  fn}.
     * @template  
    */
    declare function promise$map<T>(
        arr: T[],
        fn: (element: T, index: number, array: T[]) => any,
        opt_self?: any): undefined.Promise<T[] >


    /**
     * Creates a promise that has been rejected with the given reason.*=} opt_reason The rejection reason; may be any value, but is
     *     usually an Error or a string.
     * @return  The rejected promise.
     */
    declare function promise$rejected(opt_reason?: any): undefined.Promise<void >


    /**
     * Wraps a function that is assumed to be a node-style callback as its final
     * argument. This callback takes two arguments: an error value (which will be
    null if the call succeeded), and the success value as the second argument.
    If the call fails, the returned promise will be rejected, otherwise it will
    be resolved with the result.
     * @param  The function to wrap.
     * @return  A promise that will be resolved with the
    result of the provided function's callback.
    */
    declare function promise$checkedNodeCall<T>(fn: Function, ...var_args: any[]): undefined.Promise<T >


    /**
     * Consumes a {@code GeneratorFunction}. Each time the generator yields a
     * promise, this function will wait for it to be fulfilled before feeding the
    fulfilled value back into {@code next}. Likewise, if a yielded promise is
    rejected, the rejection error will be passed to {@code throw}.

    <p>Example 1: the Fibonacci Sequence.
    <pre><code>
    webdriver.promise.consume(function fibonacci() {
       var n1 = 1, n2 = 1;
       for (var i = 0; i<4; ++i) {
         var tmp = yield n1 + n2;
         n1 = n2;
         n2 = tmp;
       }
       return n1 + n2;
    }).then(function(result) {
       console.log(result);  // 13
    });
    </code></pre>

    <p>Example 2: a generator that throws.
    <pre><code>
    webdriver.promise.consume(function () {
       yield webdriver.promise.delayed(250).then(function() {
         throw Error('boom');
       });
    }).thenCatch(function(e) {
       console.log(e.toString());  // Error: boom
    });
    </code></pre>
     * @param  The generator function to execute.
     * @param  The object to use as "this" when invoking the
    initial generator.
     * @param  Any arguments to pass to the initial generator.
     * @return  A promise that will resolve to the
    generator's final result.
     * @throws  {TypeError} If the given function is not a generator.
    */
    declare function promise$consume<T>(
        generatorFn: Function,
        opt_self?: any,
        ...var_args: any[]): undefined.Promise<T >


    /**
     * Registers an observer on a promised {@code value}, returning a new promise
     * that will be resolved when the value is. If {@code value} is not a promise,
    then the return promise will be immediately resolved.
     * @param  The value to observe.
     * @param  The function to call when the value is
    resolved successfully.
     * @param  The function to call when the value is
    rejected.
     * @return  A new promise.
    */
    declare function promise$when<T, R>(
        value: T,
        opt_callback?: (value: T) => any,
        opt_errback?: (error: any) => any): undefined.Promise<R >


    /**
     * Returns a promise that will be resolved with the input value in a
     * fully-resolved state. If the value is an array, each element will be fully
    resolved. Likewise, if the value is an object, all keys will be fully
    resolved. In both cases, all nested arrays and objects will also be
    fully resolved.  All fields are resolved in place; the returned promise will
    resolve on {@code value} and not a copy.

    Warning: This function makes no checks against objects that contain
    cyclical references:

       var value = {};
       value['self'] = value;
       webdriver.promise.fullyResolved(value);  // Stack overflow.
     * @param  The value to fully resolve.
     * @return  A promise for a fully resolved version
    of the input value.
    */
    declare function promise$fullyResolved<T>(value: any): undefined.Promise<T >


    /**
     * Changes the default flow to use when no others are active.
     * @param  The new default flow.
     * @throws  {Error} If the default flow is not currently active.
     */
    declare function promise$setDefaultFlow(flow: undefined.ControlFlow): void


declare var npm$namespace$stacktrace: {
    format: typeof stacktrace$format,
    get: typeof stacktrace$get,
}
declare class Frame mixins undefined.Frame {}

declare class Snapshot mixins undefined.Snapshot {}


/**
 * Formats an error's stack trace.
 * @param  The error to format.
 * @return  The formatted error.
 */
declare function stacktrace$format(error: any): any


/**
 * Gets the native stack trace if available otherwise follows the call chain.
 * The generated trace will exclude all frames up to and including the call to
this function.
 * @return  The frames of the stack trace.
*/
declare function stacktrace$get(): undefined.Frame[]

declare var BROWSER_SUPPORTED: boolean;


declare var npm$namespace$until: {
    ableToSwitchToFrame: typeof until$ableToSwitchToFrame,
    alertIsPresent: typeof until$alertIsPresent,
    elementIsDisabled: typeof until$elementIsDisabled,
    elementIsEnabled: typeof until$elementIsEnabled,
    elementIsNotSelected: typeof until$elementIsNotSelected,
    elementIsNotVisible: typeof until$elementIsNotVisible,
    elementIsSelected: typeof until$elementIsSelected,
    elementIsVisible: typeof until$elementIsVisible,
    elementLocated: typeof until$elementLocated,
    elementTextContains: typeof until$elementTextContains,
    elementTextIs: typeof until$elementTextIs,
    elementTextMatches: typeof until$elementTextMatches,
    elementsLocated: typeof until$elementsLocated,
    stalenessOf: typeof until$stalenessOf,
    titleContains: typeof until$titleContains,
    titleIs: typeof until$titleIs,
    titleMatches: typeof until$titleMatches,
}
declare class Condition<T>mixins undefined.Condition<T>{}


/**
 * Creates a condition that will wait until the input driver is able to switch
 * to the designated frame. The target frame may be specified as:
<ol>
   <li>A numeric index into {@code window.frames} for the currently selected
       frame.
   <li>A {@link webdriver.WebElement}, which must reference a FRAME or IFRAME
       element on the current page.
   <li>A locator which may be used to first locate a FRAME or IFRAME on the
       current page before attempting to switch to it.
</ol>

<p>Upon successful resolution of this condition, the driver will be left
focused on the new frame.
 * @param  .Locator|webdriver.By.Hash|
function(!webdriver.WebDriver): !webdriver.WebElement)} frame
The frame identifier.
 * @return  A new condition.
*/
declare function until$ableToSwitchToFrame(frame: number): undefined.Condition<boolean >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  The new condition.
     */
    declare function until$alertIsPresent(): undefined.Condition<webdriver.Alert >


    /**
     * Creates a condition that will wait for the given element to be disabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsDisabled(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be enabled.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isEnabled
     */
    declare function until$elementIsEnabled(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be deselected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsNotSelected(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be in the DOM,
     * yet not visible to the user.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsNotVisible(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to be selected.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isSelected
     */
    declare function until$elementIsSelected(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element to become visible.
     * @param  The element to test.
     * @return  The new condition.
     * @see  webdriver.WebDriver#isDisplayed
     */
    declare function until$elementIsVisible(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will loop until an element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new condition.
    */
    declare function until$elementLocated(locator: webdriver.Locator): undefined.Condition<webdriver.IWebElement >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to contain the given
    substring.
     * @param  The element to test.
     * @param  The substring to search for.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextContains(element: webdriver.IWebElement, substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match the given
    {
     * @code  text} exactly.
     * @param  The element to test.
     * @param  The expected text.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextIs(element: webdriver.IWebElement, text: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the given element's
     * {
     * @link  webdriver.WebDriver#getText visible text} to match a regular
    expression.
     * @param  The element to test.
     * @param  The regular expression to test against.
     * @return  The new condition.
     * @see  webdriver.WebDriver#getText
    */
    declare function until$elementTextMatches(element: webdriver.IWebElement, regex: RegExp): undefined.Condition<boolean >


    /**
     * Creates a condition that will loop until at least one element is
     * {
     * @link  webdriver.WebDriver#findElement found} with the given locator.
     * @param  The locator
    to use.
     * @return  The new
    condition.
    */
    declare function until$elementsLocated(locator: webdriver.Locator): undefined.Condition<webdriver.IWebElement[] >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  The new condition.
    */
    declare function until$stalenessOf(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare function until$titleContains(substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  The new condition.
     */
    declare function until$titleIs(title: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given regular expression.
     * @param  The regular expression to test against.
     * @return  The new condition.
     */
    declare function until$titleMatches(regex: RegExp): undefined.Condition<boolean >


    declare var npm$namespace$ExpectedConditions: {
        not: typeof ExpectedConditions$not,
        and: typeof ExpectedConditions$and,
        or: typeof ExpectedConditions$or,
        alertIsPresent: typeof ExpectedConditions$alertIsPresent,
        elementToBeClickable: typeof ExpectedConditions$elementToBeClickable,
        textToBePresentInElement: typeof ExpectedConditions$textToBePresentInElement,
        textToBePresentInElementValue: typeof ExpectedConditions$textToBePresentInElementValue,
        titleContains: typeof ExpectedConditions$titleContains,
        titleIs: typeof ExpectedConditions$titleIs,
        presenceOf: typeof ExpectedConditions$presenceOf,
        stalenessOf: typeof ExpectedConditions$stalenessOf,
        visibilityOf: typeof ExpectedConditions$visibilityOf,
        invisibilityOf: typeof ExpectedConditions$invisibilityOf,
        elementToBeSelected: typeof ExpectedConditions$elementToBeSelected,
    }
    /**
     * Negates the result of a promise.<boolean>} expectedCondition
     * @return  <boolean>} An expected condition that returns the negated value.
     */
declare function ExpectedConditions$not<T>(expectedCondition: undefined.Condition<T>): undefined.Condition<T >


    /**
     * Chain a number of expected conditions using logical_and, short circuiting at the
     * first expected condition that evaluates to false.<boolean>[]} fns An array of expected conditions to 'and' together.
     * @return  <boolean>} An expected condition that returns a promise which evaluates
    to the result of the logical and.
    */
    declare function ExpectedConditions$and<T>(...fns: undefined.Condition<T>[]): undefined.Condition<T >


    /**
     * Chain a number of expected conditions using logical_or, short circuiting at the
     * first expected condition that evaluates to true.<boolean>[]} fns An array of expected conditions to 'or' together.
     * @return  <boolean>} An expected condition that returns a promise which
    evaluates to the result of the logical or.
    */
    declare function ExpectedConditions$or<T>(...fns: undefined.Condition<T>[]): undefined.Condition<T >


    /**
     * Creates a condition that waits for an alert to be opened. Upon success, the
     * returned promise will be fulfilled with the handle for the opened alert.
     * @return  The new condition.
     */
    declare function ExpectedConditions$alertIsPresent(): undefined.Condition<webdriver.Alert >


    /**
     * An Expectation for checking an element is visible and enabled such that you can click it.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is clickable.
    */
    declare function ExpectedConditions$elementToBeClickable<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking if the given text is present in the element.
     * Returns false if the elementFinder does not find an element.
     * @param  The element to check
     * @param  The text to verify against
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the text is present in the element.
    */
    declare function ExpectedConditions$textToBePresentInElement<T>(element: protractor$ElementFinder, text: string): undefined.Condition<T >


    /**
     * An expectation for checking if the given text is present in the element’s value.
     * Returns false if the elementFinder does not find an element.
     * @param  The element to check
     * @param  The text to verify against
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the text is present in the element's value.
    */
    declare function ExpectedConditions$textToBePresentInElementValue<T>(element: protractor$ElementFinder, text: string): undefined.Condition<T >


    /**
     * Creates a condition that will wait for the current page's title to contain
     * the given substring.
     * @param  The substring that should be present in the page
    title.
     * @return  The new condition.
    */
    declare function ExpectedConditions$titleContains(substr: string): undefined.Condition<boolean >


    /**
     * Creates a condition that will wait for the current page's title to match the
     * given value.
     * @param  The expected page title.
     * @return  The new condition.
     */
    declare function ExpectedConditions$titleIs(title: string): undefined.Condition<boolean >


    /**
     * An expectation for checking that an element is present on the DOM of a page. This does not necessarily
     * mean that the element is visible. This is the opposite of 'stalenessOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise
    representing whether the element is present.
    */
    declare function ExpectedConditions$presenceOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * Creates a condition that will wait for the given element to become stale. An
     * element is considered stale once it is removed from the DOM, or a new page
    has loaded.
     * @param  The element that should become stale.
     * @return  The new condition.
    */
    declare function ExpectedConditions$stalenessOf(element: webdriver.IWebElement): undefined.Condition<boolean >


    /**
     * An expectation for checking that an element is present on the DOM of a page and visible.
     * Visibility means that the element is not only displayed but also has a height and width that is
    greater than 0. This is the opposite of 'invisibilityOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is visible.
    */
    declare function ExpectedConditions$visibilityOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking that an element is present on the DOM of a page. This does not necessarily
     * mean that the element is visible. This is the opposite of 'stalenessOf'.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is invisible.
    */
    declare function ExpectedConditions$invisibilityOf<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * An expectation for checking the selection is selected.
     * @param  The element to check
     * @return  <boolean>} An expected condition that returns a promise representing
    whether the element is selected.
    */
    declare function ExpectedConditions$elementToBeSelected<T>(element: protractor$ElementFinder): undefined.Condition<T >


    /**
     * Use as: element(locator)
     * 
    The ElementFinder can be treated as a WebElement for most purposes, in
    particular, you may perform actions (i.e. click, getText) on them as you
    would a WebElement. ElementFinders extend Promise, and once an action
    is performed on an ElementFinder, the latest result from the chain can be
    accessed using then. Unlike a WebElement, an ElementFinder will wait for
    angular to settle before performing finds or actions.

    ElementFinder can be used to build a chain of locators that is used to find
    an element. An ElementFinder does not actually attempt to find the element
    until an action is called, which means they can be set up in helper files
    before the page is available.
     * @param  An element locator.
     * @return  
    */
    declare interface protractor$Element {
        (locator: webdriver.Locator): protractor$ElementFinder,

        /**
         * ElementArrayFinder is used for operations on an array of elements (as opposed
         * to a single element).
         * @param  An element locator.
         * @return  
         */
        all(locator: webdriver.Locator): protractor$ElementArrayFinder
    }

declare type protractor$ElementFinder = {

        /**
         * Calls to element may be chained to find elements within a parent.
         * @alias  element(locator).element(locator)
         * @view  * <div class="parent">
        <div class="child">
        Child text
        <div>{{person.phone}}</div>
        </div>
        </div>
         * @example  * // Chain 2 element calls.
        var child = element(by.css('.parent')).
        element(by.css('.child'));
        expect(child.getText()).toBe('Child text\n555-123-4567');

        // Chain 3 element calls.
        var triple = element(by.css('.parent')).
        element(by.css('.child')).
        element(by.binding('person.phone'));
        expect(triple.getText()).toBe('555-123-4567');
         * @param  
         * @return  
        */
        element(subLocator: webdriver.Locator): protractor$ElementFinder,

        /**
         * Calls to element may be chained to find an array of elements within a parent.
         * @alias  element(locator).all(locator)
         * @view  * <div class="parent">
        <ul>
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
        </div>
         * @example  * var items = element(by.css('.parent')).all(by.tagName('li'))
         * @param  
         * @return  
        */
        all(subLocator: webdriver.Locator): protractor$ElementArrayFinder,

        /**
         * Shortcut for querying the document directly with css.
         * @alias  $(cssSelector)
         * @view  * <div class="count">
        <span class="one">First</span>
        <span class="two">Second</span>
        </div>
         * @example  * var item = $('.count .two');
        expect(item.getText()).toBe('Second');
         * @param  A css selector
         * @return  which identifies the located
        {
         * @link  webdriver.WebElement}
        */
        $(selector: string): protractor$ElementFinder,

        /**
         * Shortcut for querying the document directly with css.
         * @alias  $$(cssSelector)
         * @view  * <div class="count">
        <span class="one">First</span>
        <span class="two">Second</span>
        </div>
         * @example  * // The following protractor expressions are equivalent.
        var list = element.all(by.css('.count span'));
        expect(list.count()).toBe(2);

        list = $$('.count span');
        expect(list.count()).toBe(2);
        expect(list.get(0).getText()).toBe('First');
        expect(list.get(1).getText()).toBe('Second');
         * @param  a css selector
         * @return  which identifies the
        array of the located {
         * @link  webdriver.WebElement}s.
        */
        $$(selector: string): protractor$ElementArrayFinder,

        /**
         * Determine whether the element is present on the page.
         * @view  * <span>{{person.name}}</span>
         * @example  * // Element exists.
        expect(element(by.binding('person.name')).isPresent()).toBe(true);

        // Element not present.
        expect(element(by.binding('notPresent')).isPresent()).toBe(false);
         * @return  which resolves to whether
        the element is present on the page.
        */
        isPresent(): undefined.Promise<boolean>,

        /**
         * Override for WebElement.prototype.isElementPresent so that protractor waits
         * for Angular to settle before making the check.
         * @see  ElementFinder.isPresent
         * @param  Locator for element to look for.
         * @return  which resolves to whether
        the element is present on the page.
        */
        isElementPresent(subLocator: webdriver.Locator): undefined.Promise<boolean>,

        /**
         * 
         * @see  ElementArrayFinder.prototype.locator
         * @return  
         */
        locator(): webdriver.Locator,

        /**
         * Returns the WebElement represented by this ElementFinder.
         * Throws the WebDriver error if the element doesn't exist.
         * @example  *  The following three expressions are equivalent.
        element(by.css('.parent')).getWebElement();
        browser.waitForAngular(); browser.driver.findElement(by.css('.parent'));
        browser.findElement(by.css('.parent'));
         * @alias  element(locator).getWebElement()
         * @return  
        */
        getWebElement(): webdriver.WebElement,

        /**
         * Evaluates the input as if it were on the scope of the current element.
         * @see  ElementArrayFinder.evaluate
         * @param  
         * @return  which resolves to the evaluated expression.
         */
        evaluate(expression: string): protractor$ElementFinder,

        /**
         * 
         * @see  ElementArrayFinder.prototype.allowAnimations.
         * @param  
         * @return  which resolves to whether animation is allowed.
         */
        allowAnimations(value: string): protractor$ElementFinder,

        /**
         * Create a shallow copy of ElementFinder.
         * @return  A shallow copy of this.
         */
        clone(): protractor$ElementFinder
    } & &


    declare type protractor$ElementArrayFinder = {

        /**
         * Returns the elements as an array of WebElements.
         */
        getWebElements(): webdriver.WebElement[],

        /**
         * Get an element within the ElementArrayFinder by index. The index starts at 0.
         * Negative indices are wrapped (i.e. -i means ith element from last)
        This does not actually retrieve the underlying element.
         * @alias  element.all(locator).get(index)
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var list = element.all(by.css('.items li'));
        expect(list.get(0).getText()).toBe('First');
        expect(list.get(1).getText()).toBe('Second');
         * @param  Element index.
         * @return  finder representing element at the given index.
        */
        get(index: number): protractor$ElementFinder,

        /**
         * Get the first matching element for the ElementArrayFinder. This does not
         * actually retrieve the underlying element.
         * @alias  element.all(locator).first()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var first = element.all(by.css('.items li')).first();
        expect(first.getText()).toBe('First');
         * @return  finder representing the first matching element
        */
        first(): protractor$ElementFinder,

        /**
         * Get the last matching element for the ElementArrayFinder. This does not
         * actually retrieve the underlying element.
         * @alias  element.all(locator).last()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var last = element.all(by.css('.items li')).last();
        expect(last.getText()).toBe('Third');
         * @return  finder representing the last matching element
        */
        last(): protractor$ElementFinder,

        /**
         * Count the number of elements represented by the ElementArrayFinder.
         * @alias  element.all(locator).count()
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * var list = element.all(by.css('.items li'));
        expect(list.count()).toBe(3);
         * @return  A promise which resolves to the
        number of elements matching the locator.
        */
        count(): undefined.Promise<number>,

        /**
         * Calls the input function on each ElementFinder represented by the ElementArrayFinder.
         * @alias  element.all(locator).each(eachFunction)
         * @view  * <ul class="items">
        <li>First</li>
        <li>Second</li>
        <li>Third</li>
        </ul>
         * @example  * element.all(by.css('.items li')).each(function(element) {
        // Will print First, Second, Third.
        element.getText().then(console.log);
        });
         * @param  Input function
        */
        each(fn: (element: protractor$ElementFinder, index: number) => void): void,

        /**
         * Apply a map function to each element within the ElementArrayFinder. The
         * callback receives the ElementFinder as the first argument and the index as
        a second arg.
         * @alias  element.all(locator).map(mapFunction)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * var items = element.all(by.css('.items li')).map(function(elm, index) {
        return {
        index: index,
        text: elm.getText(),
        class: elm.getAttribute('class')
        };
        });
        expect(items).toEqual([
        {index: 0, text: 'First', class: 'one'},
        {index: 1, text: 'Second', class: 'two'},
        {index: 2, text: 'Third', class: 'three'}
        ]);
         * @param  Map function that
        will be applied to each element.
         * @return  A promise that resolves to an array
        of values returned by the map function.
        */
        map<T>(
            mapFn: (element: protractor$ElementFinder, index: number) => T): undefined.Promise<T[]>,
        map<T,
        T2>(
            mapFn: (element: protractor$ElementFinder, index: number) => T2): undefined.Promise<T[]>,

        /**
         * Apply a filter function to each element within the ElementArrayFinder. Returns
         * a new ElementArrayFinder with all elements that pass the filter function. The
        filter function receives the ElementFinder as the first argument
        and the index as a second arg.
        This does not actually retrieve the underlying list of elements, so it can
        be used in page objects.
         * @alias  element.all(locator).filter(filterFn)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * element.all(by.css('.items li')).filter(function(elem, index) {
        return elem.getText().then(function(text) {
        return text === 'Third';
        });
        }).then(function(filteredElements) {
        filteredElements[0].click();
        });
         * @param  Filter function that will test if an element should be returned.
        filterFn can either return a boolean or a promise that resolves to a boolean.
         * @return  A ElementArrayFinder that represents an array
        of element that satisfy the filter function.
        */
        filter(
            filterFn: (element: protractor$ElementFinder, index: number) => any): protractor$ElementArrayFinder,

        /**
         * Apply a reduce function against an accumulator and every element found
         * using the locator (from left-to-right). The reduce function has to reduce
        every element into a single value (the accumulator). Returns promise of
        the accumulator. The reduce function receives the accumulator, current
        ElementFinder, the index, and the entire array of ElementFinders,
        respectively.reduceFn Reduce function that reduces every element into a single value.
         * @alias  element.all(locator).reduce(reduceFn)
         * @view  * <ul class="items">
        <li class="one">First</li>
        <li class="two">Second</li>
        <li class="three">Third</li>
        </ul>
         * @example  * var value = element.all(by.css('.items li')).reduce(function(acc, elem) {
        return elem.getText().then(function(text) {
        return acc + text + ' ';
        });
        });

        expect(value).toEqual('First Second Third ');
         * @param  Initial value of the accumulator.
         * @return  A promise that resolves to the final
        value of the accumulator.
        */
        reduce<T>(
            reduceFn: (
                acc: T,
                element: protractor$ElementFinder,
                index: number,
                arr: protractor$ElementFinder[]) => undefined.Promise<T>,
            initialValue: T): undefined.Promise<T>,
        reduce<T>(
            reduceFn: (
                acc: T,
                element: protractor$ElementFinder,
                index: number,
                arr: protractor$ElementFinder[]) => T,
            initialValue: T): undefined.Promise<T>,

        /**
         * Represents the ElementArrayFinder as an array of ElementFinders.
         * @return  Return a promise, which resolves to a list
        of ElementFinders specified by the locator.
        */
        asElementFinders_(): undefined.Promise<protractor$ElementFinder[]>,

        /**
         * Create a shallow copy of ElementArrayFinder.
         * @return  A shallow copy of this.
         */
        clone(): protractor$ElementArrayFinder,

        /**
         * Calls to ElementArrayFinder may be chained to find an array of elements
         * using the current elements in this ElementArrayFinder as the starting point.
        This function returns a new ElementArrayFinder which would contain the
        children elements found (and could also be empty).
         * @alias  element.all(locator).all(locator)
         * @view  * <div id='id1' class="parent">
        <ul>
        <li class="foo">1a</li>
        <li class="baz">1b</li>
        </ul>
        </div>
        <div id='id2' class="parent">
        <ul>
        <li class="foo">2a</li>
        <li class="bar">2b</li>
        </ul>
        </div>
         * @example  * var foo = element.all(by.css('.parent')).all(by.css('.foo'))
        expect(foo.getText()).toEqual(['1a', '2a'])
        var baz = element.all(by.css('.parent')).all(by.css('.baz'))
        expect(baz.getText()).toEqual(['1b'])
        var nonexistent = element.all(by.css('.parent')).all(by.css('.NONEXISTENT'))
        expect(nonexistent.getText()).toEqual([''])
         * @param  
         * @return  
        */
        all(locator: webdriver.Locator): protractor$ElementArrayFinder,

        /**
         * Shorthand function for finding arrays of elements by css.
         * @type  
         */
        $$(selector: string): protractor$ElementArrayFinder,

        /**
         * Returns an ElementFinder representation of ElementArrayFinder. It ensures
         * that the ElementArrayFinder resolves to one and only one underlying element.
         * @return  An ElementFinder representation
         * @private  
         */
        toElementFinder_(): protractor$ElementFinder,

        /**
         * Returns the most relevant locator.
         * @example  * $('#ID1').locator() // returns by.css('#ID1')
        $('#ID1').$('#ID2').locator() // returns by.css('#ID2')
        $$('#ID1').filter(filterFn).get(0).click().locator() // returns by.css('#ID1')
         * @return  
        */
        locator(): webdriver.Locator,

        /**
         * Evaluates the input as if it were on the scope of the current underlying
         * elements.
         * @view  * <span id="foo">{{variableInScope}}</span>
         * @example  * var value = element(by.id('foo')).evaluate('variableInScope');
         * @param  
         * @return  which resolves to the
        evaluated expression for each underlying element.
        The result will be resolved as in
        {
         * @link  webdriver.WebDriver.executeScript}. In summary - primitives will
        be resolved as is, functions will be converted to string, and elements
        will be returned as a WebElement.
        */
        evaluate(expression: string): protractor$ElementArrayFinder,

        /**
         * Determine if animation is allowed on the current underlying elements.
         * @param  
         * @example  * // Turns off ng-animate animations for all elements in the <body>
        element(by.css('body')).allowAnimations(false);
         * @return  which resolves to whether animation is allowed.
        */
        allowAnimations(value: boolean): protractor$ElementArrayFinder,

        /**
         * Schedules a command to click on this element.
         * @return  A promise that will be resolved when
        the click command has completed.
        */
        click(): undefined.Promise<void>,

        /**
         * Schedules a command to type a sequence on the DOM element represented by this
         * instance.
        <p/>
        Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is
        processed in the keysequence, that key state is toggled until one of the
        following occurs:
        <ul>
        <li>The modifier key is encountered again in the sequence. At this point the
        state of the key is toggled (along with the appropriate keyup/down events).
        </li>
        <li>The {@code webdriver.Key.NULL} key is encountered in the sequence. When
        this key is encountered, all modifier keys current in the down state are
        released (with accompanying keyup events). The NULL key can be used to
        simulate common keyboard shortcuts:
        <code>
             element.sendKeys("text was",
                              webdriver.Key.CONTROL, "a", webdriver.Key.NULL,
                              "now text is");
             // Alternatively:
             element.sendKeys("text was",
                              webdriver.Key.chord(webdriver.Key.CONTROL, "a"),
                              "now text is");
        </code></li>
        <li>The end of the keysequence is encountered. When there are no more keys
        to type, all depressed modifier keys are released (with accompanying keyup
        events).
        </li>
        </ul>
        <strong>Note:</strong> On browsers where native keyboard events are not yet
        supported (e.g. Firefox on OS X), key events will be synthesized. Special
        punctionation keys will be synthesized according to a standard QWERTY en-us
        keyboard layout.
         * @param  The sequence of keys to
        type. All arguments will be joined into a single sequence (var_args is
        permitted for convenience).
         * @return  A promise that will be resolved when all
        keys have been typed.
        */
        sendKeys(...var_args: string[]): undefined.Promise<void>,

        /**
         * Schedules a command to query for the tag/node name of this element.
         * @return  A promise that will be resolved with the
        element's tag name.
        */
        getTagName(): undefined.Promise<string[]>,

        /**
         * Schedules a command to query for the computed style of the element
         * represented by this instance. If the element inherits the named style from
        its parent, the parent will be queried for its value.  Where possible, color
        values will be converted to their hex representation (e.g. #00ff00 instead of
        rgb(0, 255, 0)).
        <p/>
        <em>Warning:</em> the value returned will be as the browser interprets it, so
        it may be tricky to form a proper assertion.
         * @param  The name of the CSS style property to look
        up.
         * @return  A promise that will be resolved with the
        requested CSS value.
        */
        getCssValue(cssStyleProperty: string): undefined.Promise<string[]>,

        /**
         * Schedules a command to query for the value of the given attribute of the
         * element. Will return the current value even if it has been modified after the
        page has been loaded. More exactly, this method will return the value of the
        given attribute, unless that attribute is not present, in which case the
        value of the property with the same name is returned. If neither value is
        set, null is returned. The "style" attribute is converted as best can be to a
        text representation with a trailing semi-colon. The following are deemed to
        be "boolean" attributes and will be returned as thus:

        <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,
        defaultchecked, defaultselected, defer, disabled, draggable, ended,
        formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,
        loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,
        paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,
        selected, spellcheck, truespeed, willvalidate

        <p>Finally, the following commonly mis-capitalized attribute/property names
        are evaluated as expected:
        <ul>
           <li>"class"
           <li>"readonly"
        </ul>
         * @param  The name of the attribute to query.
         * @return  A promise that will be resolved with the
        attribute's value.
        */
        getAttribute(attributeName: string): undefined.Promise<string[]>,

        /**
         * Get the visible (i.e. not hidden by CSS) innerText of this element, including
         * sub-elements, without any leading or trailing whitespace.
         * @return  A promise that will be resolved with the
        element's visible text.
        */
        getText(): undefined.Promise<string[]>,

        /**
         * Schedules a command to compute the size of this element's bounding box, in
         * pixels.
         * @return  A promise that will be resolved with the
        element's size as a {
         * @code  {width:number, height:number}} object.
        */
        getSize(): undefined.Promise<webdriver.ISize[]>,

        /**
         * Schedules a command to compute the location of this element in page space.
         * @return  A promise that will be resolved to the
        element's location as a {
         * @code  {x:number, y:number}} object.
        */
        getLocation(): undefined.Promise<webdriver.ILocation[]>,

        /**
         * Schedules a command to query whether the DOM element represented by this
         * instance is enabled, as dicted by the {@code disabled} attribute.
         * @return  A promise that will be resolved with
        whether this element is currently enabled.
        */
        isEnabled(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to query whether this element is selected.
         * @return  A promise that will be resolved with
        whether this element is currently selected.
        */
        isSelected(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to submit the form containing this element (or this
         * element if it is a FORM element). This command is a no-op if the element is
        not contained in a form.
         * @return  A promise that will be resolved when
        the form has been submitted.
        */
        submit(): undefined.Promise<void>,

        /**
         * Schedules a command to clear the {@code value} of this element. This command
         * has no effect if the underlying DOM element is neither a text INPUT element
        nor a TEXTAREA element.
         * @return  A promise that will be resolved when
        the element has been cleared.
        */
        clear(): undefined.Promise<void>,

        /**
         * Schedules a command to test whether this element is currently displayed.
         * @return  A promise that will be resolved with
        whether this element is currently visible on the page.
        */
        isDisplayed(): undefined.Promise<boolean[]>,

        /**
         * Schedules a command to retrieve the outer HTML of this element.
         * @return  A promise that will be resolved with
        the element's outer HTML.
        */
        getOuterHtml(): undefined.Promise<string[]>,

        /**
         * 
         * @return  A promise
        that resolves to this element's JSON representation as defined by the
        WebDriver wire protocol.
         * @see  http://code.google.com/p/selenium/wiki/JsonWireProtocol
        */
        getId(): undefined.Promise<webdriver.IWebElementId[]>,

        /**
         * Schedules a command to retrieve the inner HTML of this element.
         * @return  A promise that will be resolved with the
        element's inner HTML.
        */
        getInnerHtml(): undefined.Promise<string[] >
    }

declare type protractor$LocatorWithColumn = {
    column(index: number): webdriver.Locator,
    column(name: string): webdriver.Locator
}

declare type protractor$RepeaterLocator = {
    row(index: number): protractor$LocatorWithColumn
} & protractor$LocatorWithColumn


declare interface protractor$IProtractorLocatorStrategy {

    /**
     * webdriver's By is an enum of locator functions, so we must set it to
     * a prototype before inheriting from it.
     */
    className: typeof undefined,
        css: typeof undefined,
        id: typeof undefined,
        linkText: typeof undefined,
        js: typeof undefined,
        name: typeof undefined,
        partialLinkText: typeof undefined,
        tagName: typeof undefined,
        xpath: typeof undefined,

        /**
         * Add a locator to this instance of ProtractorBy. This locator can then be
         * used with element(by.locatorName(args)).
         * @view  * <button ng-click="doAddition()">Go!</button>
         * @example  * // Add the custom locator.
        by.addLocator('buttonTextSimple',
        function(buttonText, opt_parentElement, opt_rootSelector) {
        // This function will be serialized as a string and will execute in the
        // browser. The first argument is the text for the button. The second
        // argument is the parent element, if any.
        var using = opt_parentElement,
        buttons = using.querySelectorAll('button');

        // Return an array of buttons with the text.
        return Array.prototype.filter.call(buttons, function(button) {
        return button.textContent === buttonText;
        });
        });

        // Use the custom locator.
        element(by.buttonTextSimple('Go!')).click();
         * @alias  by.addLocator(locatorName, functionOrScript)
         * @param  The name of the new locator.
         * @param  A script to be run in the context of
        the browser. This script will be passed an array of arguments
        that contains any args passed into the locator followed by the
        element scoping the search and the css selector for the root angular
        element. It should return an array of elements.
        */
        addLocator(name: string, script: string): void,
        addLocator(name: string, script: Function): void,

        /**
         * Find an element by binding.
         * @view  * <span>{{person.name}}</span>
        <span ng-bind="person.email"></span>
         * @example  * var span1 = element(by.binding('person.name'));
        expect(span1.getText()).toBe('Foo');

        var span2 = element(by.binding('person.email'));
        expect(span2.getText()).toBe('foo
         * @bar  .com');
         * @param  
         * @return  
        */
        binding(bindingDescriptor: string): webdriver.Locator,

        /**
         * Find an element by exact binding.
         * @view  * <span>{{ person.name }}</span>
        <span ng-bind="person-email"></span>
        <span>{{person_phone|uppercase}}</span>
         * @example  * expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person-email')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person')).isPresent()).toBe(false);
        expect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);
        expect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);
        expect(element(by.exactBinding('phone')).isPresent()).toBe(false);
         * @param  
         * @return  
        */
        exactBinding(bindingDescriptor: string): webdriver.Locator,

        /**
         * Find an element by ng-model expression.
         * @alias  by.model(modelName)
         * @view  * <input type="text" ng-model="person.name"/>
         * @example  * var input = element(by.model('person.name'));
        input.sendKeys('123');
        expect(input.getAttribute('value')).toBe('Foo123');
         * @param  ng-model expression.
        */
        model(model: string): webdriver.Locator,

        /**
         * Find a button by text.
         * @view  * <button>Save</button>
         * @example  * element(by.buttonText('Save'));
         * @param  
         * @return  
         */
        buttonText(searchText: string): webdriver.Locator,

        /**
         * Find a button by partial text.
         * @view  * <button>Save my file</button>
         * @example  * element(by.partialButtonText('Save'));
         * @param  
         * @return  
         */
        partialButtonText(searchText: string): webdriver.Locator,

        /**
         * Find elements inside an ng-repeat.
         * @view  * <div ng-repeat="cat in pets">
        <span>{{cat.name}}</span>
        <span>{{cat.age}}</span>
        </div>

        <div class="book-img" ng-repeat-start="book in library">
        <span>{{$index}}</span>
        </div>
        <div class="book-info" ng-repeat-end>
        <h4>{{book.name}}</h4>
        <p>{{book.blurb}}</p>
        </div>
         * @example  * // Returns the DIV for the second cat.
        var secondCat = element(by.repeater('cat in pets').row(1));

        // Returns the SPAN for the first cat's name.
        var firstCatName = element(by.repeater('cat in pets').
        row(0).column('{{cat.name}}'));

        // Returns a promise that resolves to an array of WebElements from a column
        var ages = element.all(
        by.repeater('cat in pets').column('{{cat.age}}'));

        // Returns a promise that resolves to an array of WebElements containing
        // all top level elements repeated by the repeater. For 2 pets rows resolves
        // to an array of 2 elements.
        var rows = element.all(by.repeater('cat in pets'));

        // Returns a promise that resolves to an array of WebElements containing all
        // the elements with a binding to the book's name.
        var divs = element.all(by.repeater('book in library').column('book.name'));

        // Returns a promise that resolves to an array of WebElements containing
        // the DIVs for the second book.
        var bookInfo = element.all(by.repeater('book in library').row(1));

        // Returns the H4 for the first book's name.
        var firstBookName = element(by.repeater('book in library').
        row(0).column('{{book.name}}'));

        // Returns a promise that resolves to an array of WebElements containing
        // all top level elements repeated by the repeater. For 2 books divs
        // resolves to an array of 4 elements.
        var divs = element.all(by.repeater('book in library'));
        */
        repeater(repeatDescriptor: string): protractor$RepeaterLocator,

        /**
         * Find elements by CSS which contain a certain string.
         * @view  * <ul>
        <li class="pet">Dog</li>
        <li class="pet">Cat</li>
        </ul>
         * @example  * // Returns the DIV for the dog, but not cat.
        var dog = element(by.cssContainingText('.pet', 'Dog'));
        */
        cssContainingText(cssSelector: string, searchText: string): webdriver.Locator,

        /**
         * Find an element by ng-options expression.
         * @alias  by.options(optionsDescriptor)
         * @view  * <select ng-model="color" ng-options="c for c in colors">
        <option value="0" selected="selected">red</option>
        <option value="1">green</option>
        </select>
         * @example  * var allOptions = element.all(by.options('c for c in colors'));
        expect(allOptions.count()).toEqual(2);
        var firstOption = allOptions.first();
        expect(firstOption.getText()).toEqual('red');
         * @param  ng-options expression.
        */
        options(optionsDescriptor: string): webdriver.Locator
}

declare var By: protractor$IProtractorLocatorStrategy;

declare type protractor$Protractor = {

    /**
     * The wrapped webdriver instance. Use this to interact with pages that do
     * not contain Angular (such as a log-in screen).
     * @type  
     */
    driver: webdriver.WebDriver,

    /**
     * Helper function for finding elements.
     * @type  
     */
    element(locator: webdriver.Locator): protractor$ElementFinder,

    /**
     * Shorthand function for finding elements by css.
     * @type  
     */
    $(selector: string): protractor$ElementFinder,

    /**
     * Shorthand function for finding arrays of elements by css.
     * @type  
     */
    $$(selector: string): protractor$ElementArrayFinder,

    /**
     * All get methods will be resolved against this base URL. Relative URLs are =
     * resolved the way anchor tags resolve.
     * @type  
     */
    baseUrl: string,

    /**
     * The css selector for an element on which to find Angular. This is usually
     * 'body' but if your ng-app is on a subsection of the page it may be
    a subelement.
     * @type  
    */
    rootEl: string,

    /**
     * If true, Protractor will not attempt to synchronize with the page before
     * performing actions. This can be harmful because Protractor will not wait
    until $timeouts and $http calls have been processed, which can cause
    tests to become flaky. This should be used only when necessary, such as
    when a page continuously polls an API using $timeout.
     * @type  
    */
    ignoreSynchronization: boolean,

    /**
     * Timeout in milliseconds to wait for pages to load when calling `get`.
     * @type  
     */
    getPageTimeout: number,

    /**
     * An object that holds custom test parameters.
     * @type  
     */
    params: any,

    /**
     * The reset URL to use between page loads.
     * @type  
     */
    resetUrl: string,

    /**
     * Instruct webdriver to wait until Angular has finished rendering and has
     * no outstanding $http calls before continuing.
     * @return  A promise that will resolve to the
    scripts return value.
    */
    waitForAngular(): undefined.Promise<any>,

    /**
     * Add a module to load before Angular whenever Protractor.get is called.
     * Modules will be registered after existing modules already on the page,
    so any module registered here will override preexisting modules with the same
    name.
     * @example  * browser.addMockModule('modName', function() {
    angular.module('modName', []).value('foo', 'bar');
    });
     * @param  The name of the module to load or override.
     * @param  The JavaScript to load the module.
     * @param  Any additional arguments will be provided to
    the script and may be referenced using the `arguments` object.
    */
    addMockModule(name: string, script: string, ...varArgs: any[]): void,
    addMockModule(name: string, script: Function, ...varArgs: any[]): void,

    /**
     * Clear the list of registered mock modules.
     */
    clearMockModules(): void,

    /**
     * Remove a registered mock module.
     * @example  * browser.removeMockModule('modName');
     * @param  The name of the module to remove.
     */
    removeMockModule(name: string): void,

    /**
     * 
     * @see  webdriver.WebDriver.get

    Navigate to the given destination and loads mock modules before
    Angular. Assumes that the page being loaded uses Angular.
    If you need to access a page which does not have Angular on load, use
    the wrapped webdriver directly.
     * @param  Destination URL.
     * @param  Number of milliseconds to wait for Angular to
    start.
    */
    get(destination: string, opt_timeout?: number): undefined.Promise<void>,

    /**
     * See webdriver.WebDriver.refresh
     * 
    Makes a full reload of the current page and loads mock modules before
    Angular. Assumes that the page being loaded uses Angular.
    If you need to access a page which does not have Angular on load, use
    the wrapped webdriver directly.
     * @param  Number of seconds to wait for Angular to start.
    */
    refresh(opt_timeout?: number): undefined.Promise<void>,

    /**
     * Browse to another page using in-page navigation.
     * @param  In page URL using the same syntax as $location.url()
     * @returns  A promise that will resolve once
    page has been changed.
    */
    setLocation(url: string): undefined.Promise<void>,

    /**
     * Returns the current absolute url from AngularJS.
     */
    getLocationAbsUrl(): undefined.Promise<string>,

    /**
     * Pauses the test and injects some helper functions into the browser, so that
     * debugging may be done in the browser console.

    This should be used under node in debug mode, i.e. with
    protractor debug <configuration.js>
     * @example  * While in the debugger, commands can be scheduled through webdriver by
    entering the repl:
    debug> repl
    Press Ctrl + C to leave rdebug repl
   >ptor.findElement(protractor.By.input('user').sendKeys('Laura'));
   >ptor.debugger();
    debug> c

    This will run the sendKeys command as the next task, then re-enter the
    debugger.
    */
    debugger(): void,

    /**
     * Beta (unstable) pause function for debugging webdriver tests. Use
     * browser.pause() in your test to enter the protractor debugger from that
    point in the control flow.
    Does not require changes to the command line (no need to add 'debug').
     * @example  * element(by.id('foo')).click();
    browser.pause();
    // Execution will stop before the next click action.
    element(by.id('bar')).click();
     * @param  Optional port to use for the debugging process
    */
    pause(opt_debugPort?: number): void
}

declare type protractor$IBrowser = {

    /**
     * Fork another instance of protractor for use in interactive tests.
     * @param  Whether to navigate to current url on creation
     * @param  Whether to apply same mock modules on creation
     * @return  a protractor instance.
     */
    forkNewDriverInstance(opt_useSameUrl?: boolean, opt_copyMockModules?: boolean): protractor$Protractor,

    /**
     * Get the processed configuration object that is currently being run. This will contain
     * the specs and capabilities properties of the current runner instance.

    Set by the runner.
     * @return  <any>} A promise which resolves to the capabilities object.
    */
    getProcessedConfig(): undefined.Promise<any >
} & protractor$Protractor



/**
 * Create a new instance of Protractor by wrapping a webdriver instance.
 * @param  The configured webdriver instance.
 * @param  A URL to prepend to relative gets.
 * @return  
 */
declare function protractor$wrapDriver(
    webdriver: webdriver.WebDriver,
    opt_baseUrl?: string,
    opt_rootElement?: string): protractor$Protractordeclare interface selectorHelper {
    (cssLocator: string |
        Function |
        HTMLElement |
        AceAjax$Document |
        Array<any>): protractor$ElementFinder
}
declare interface cssArraySelectorHelper {
    (cssLocator: string): protractor$ElementArrayFinder
}
declare var browser: protractor$IBrowser;
declare var by: protractor$IProtractorLocatorStrategy;
declare var By: protractor$IProtractorLocatorStrategy;
declare var element: protractor$Element;
declare var $: selectorHelper;
declare var $$: cssArraySelectorHelper;
declare module 'protractor' {
    declare module.exports: typeof protractor
}
declare export interface ng$IAngularStatic {
    scenario: any
}
declare export interface angularScenario$RunFunction {
    (functionToRun: any): any
}

declare export interface angularScenario$RunFunctionWithDescription {
    (description: string, functionToRun: any): any
}

declare export interface angularScenario$PauseFunction {
    (): any
}

declare export interface angularScenario$SleepFunction {
    (seconds: number): any
}

declare export interface angularScenario$Future {}

declare export interface angularScenario$testWindow {
    href(): angularScenario$Future,
        path(): angularScenario$Future,
        search(): angularScenario$Future,
        hash(): angularScenario$Future
}

declare export interface angularScenario$testLocation {
    url(): angularScenario$Future,
        path(): angularScenario$Future,
        search(): angularScenario$Future,
        hash(): angularScenario$Future
}

declare export interface angularScenario$Browser {
    navigateTo(url: string): void,
        navigateTo(urlDescription: string, urlFunction: () => string): void,
        reload(): void,
        window(): angularScenario$testWindow,
        location(): angularScenario$testLocation
}

declare export interface angularScenario$Matchers {
    toEqual(value: any): void,
        toBe(value: any): void,
        toBeDefined(): void,
        toBeTruthy(): void,
        toBeFalsy(): void,
        toMatch(regularExpression: any): void,
        toBeNull(): void,
        toContain(value: any): void,
        toBeLessThan(value: any): void,
        toBeGreaterThan(value: any): void
}

declare export type angularScenario$CustomMatchers = {} & angularScenario$Matchers


declare export type angularScenario$Expect = {
    not(): angularScenario$CustomMatchers
} & angularScenario$CustomMatchers


declare export interface angularScenario$UsingFunction {
    (selector: string, selectorDescription?: string): void
}

declare export interface angularScenario$BindingFunction {
    (bracketBindingExpression: string): angularScenario$Future
}

declare export interface angularScenario$Input {
    enter(value: any): any,
        check(): any,
        select(radioButtonValue: any): any,
        val(): angularScenario$Future
}

declare export interface angularScenario$Repeater {
    count(): angularScenario$Future,
        row(index: number): angularScenario$Future,
        column(ngBindingExpression: string): angularScenario$Future
}

declare export interface angularScenario$Select {
    option(value: any): any,
        option(...listOfValues: any[]): any
}


/**
 * Use as: element(locator)
 * 
The ElementFinder can be treated as a WebElement for most purposes, in
particular, you may perform actions (i.e. click, getText) on them as you
would a WebElement. ElementFinders extend Promise, and once an action
is performed on an ElementFinder, the latest result from the chain can be
accessed using then. Unlike a WebElement, an ElementFinder will wait for
angular to settle before performing finds or actions.

ElementFinder can be used to build a chain of locators that is used to find
an element. An ElementFinder does not actually attempt to find the element
until an action is called, which means they can be set up in helper files
before the page is available.
 * @param  An element locator.
 * @return  
*/
declare interface angularScenario$Element {
    (locator: webdriver.Locator): protractor$ElementFinder,

    /**
     * ElementArrayFinder is used for operations on an array of elements (as opposed
     * to a single element).
     * @param  An element locator.
     * @return  
     */
    all(locator: webdriver.Locator): protractor$ElementArrayFinder
}
declare var describe: angularScenario$RunFunctionWithDescription;
declare var ddescribe: angularScenario$RunFunctionWithDescription;
declare var xdescribe: angularScenario$RunFunctionWithDescription;
declare var beforeEach: angularScenario$RunFunction;
declare var afterEach: angularScenario$RunFunction;
declare var it: angularScenario$RunFunctionWithDescription;
declare var iit: angularScenario$RunFunctionWithDescription;
declare var xit: angularScenario$RunFunctionWithDescription;
declare var pause: angularScenario$PauseFunction;
declare var sleep: angularScenario$SleepFunction;
declare function browser(): angularScenario$Browserdeclare function expect(expectation: angularScenario$Future): angularScenario$Expectdeclare var using: angularScenario$UsingFunction;
declare var binding: angularScenario$BindingFunction;
declare function input(ngModelBinding: string): angularScenario$Inputdeclare function repeater(selector: string, repeaterDescription?: string): angularScenario$Repeaterdeclare function select(ngModelBinding: string): angularScenario$Selectdeclare function element(selector: string, elementDescription?: string): angularScenario$Elementdeclare var angular: ng$IAngularStatic;
/**
 * Extends the angular.element object returned by the $document sercive with a few jQuery like functions.
 * see https://github.com/oblador/angular-scroll#angularelement-scroll-api
 */
declare type duScroll$IDocumentService = {
    duScrollTo(left: number, top: number): void,
    duScrollTo(
        left: number,
        top: number,
        duration: number,
        easing?: Function): ng$IPromise<void>,
    duScrollTo(element: ng$IAugmentedJQuery, offset?: number): void,
    duScrollTo(
        element: ng$IAugmentedJQuery,
        offset: number,
        duration: number,
        easing?: Function): ng$IPromise<void>,
    duScrollToElement(element: ng$IAugmentedJQuery, offset?: number): void,
    duScrollToElement(
        element: ng$IAugmentedJQuery,
        offset: number,
        duration: number,
        easing?: Function): ng$IPromise<void>,
    duScrollToElementAnimated(element: ng$IAugmentedJQuery, offset?: number): ng$IPromise<void>,
    duScrollToElementAnimated(
        element: ng$IAugmentedJQuery,
        offset: number,
        duration: number,
        easing?: Function): ng$IPromise<void>,
    duScrollTop(top: number): void,
    duScrollTop(top: number, duration: number, easing?: Function): ng$IPromise<void>,
    duScrollTopAnimated(top: number): ng$IPromise<void>,
    duScrollTopAnimated(top: number, duration: number, easing?: Function): ng$IPromise<void>,
    duScrollLeft(left: number): void,
    duScrollLeft(left: number, duration: number, easing?: Function): ng$IPromise<void>,
    duScrollLeftAnimated(left: number): ng$IPromise<void>,
    duScrollLeftAnimated(left: number, duration: number, easing?: Function): ng$IPromise<void>,
    duScrollTop(): number,
    duScrollLeft(): number
}
declare module 'angular-signalr-hub' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare interface ngSignalr$HubFactory {

    /**
     * Creates a new Hub connection
     */
    new(hubName: string, options: ngSignalr$HubOptions): ngSignalr$Hub
}

declare class Hub {
    hubName: string;
    connection: SignalR.Connection;
    proxy: undefined.Proxy;
    on(event: string, fn: (...args: any[]) => void): void;
    invoke(method: string, ...args: any[]): JQueryDeferred<any>;
    disconnect(): void;
    connect(): JQueryPromise<any >
}

declare interface ngSignalr$HubOptions {

    /**
     * Collection of client side callbacks
     */
    listeners?: {
            [index: string]: (...args: any[]) => void
        },

        /**
         * String array of server side methods which the client can call
         */
        methods?: Array<string>,

        /**
         * Sets the root path for the SignalR web service
         */
        rootPath?: string,

        /**
         * Object representing additional query params to be sent on connection
         */
        queryParams?: {
            [index: string]: string
        },

        /**
         * Function to handle hub connection errors
         */
        errorHandler?: (error: string) => void,

        /**
         * Enable/disable logging
         */
        logging?: boolean,

        /**
         * Use a shared global connection or create a new one just for this hub, defaults to true
         */
        useSharedConnection?: boolean,

        /**
         * Sets transport method (e.g    'longPolling'    or    ['webSockets', 'longPolling'] )
         */
        transport?: any,

        /**
         * Function to handle hub connection state changed event
         */
        stateChanged?: (state: SignalR.StateChanged) => void
}
/**
 * SpinnerService 
 * see https://github.com/urish/angular-spinner
 */
declare interface ISpinnerService {

    /**
     * Start selected spinner
     * @param spinner key
     */
    spin(key: string): void,

        /**
         * Stop selected spinner
         * @param spinner key
         */
        stop(key: string): void
}
declare module 'ngStrap' {
    declare interface modal$IModalService {
        (config?: modal$IModalOptions): modal$IModal
    }

    declare interface modal$IModalProvider {
        defaults: modal$IModalOptions
    }

    declare interface modal$IModal {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface modal$IModalOptions {
        animation?: string,
            backdropAnimation?: string,
            placement?: string,
            title?: string,
            content?: string,
            html?: boolean,
            backdrop?: boolean | string,
            keyboard?: boolean,
            show?: boolean,
            container?: string | boolean,
            template?: string,
            contentTemplate?: string,
            prefixEvent?: string,
            id?: string,
            scope?: ng$IScope
    }

    declare type modal$IModalScope = {
        $show: () => void,
        $hide: () => void,
        $toggle: () => void
    }
    declare interface aside$IAsideService {
        (config?: aside$IAsideOptions): aside$IAside
    }

    declare interface aside$IAsideProvider {
        defaults: aside$IAsideOptions
    }

    declare interface aside$IAside {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface aside$IAsideOptions {
        animation?: string,
            placement?: string,
            title?: string,
            content?: string,
            html?: boolean,
            backdrop?: boolean | string,
            keyboard?: boolean,
            show?: boolean,
            container?: string | boolean,
            template?: string,
            contentTemplate?: string,
            scope?: ng$IScope
    }

    declare type aside$IAsideScope = {
        $show: () => void,
        $hide: () => void,
        $toggle: () => void
    }
    declare interface alert$IAlertService {
        (config?: alert$IAlertOptions): alert$IAlert
    }

    declare interface alert$IAlertProvider {
        defaults: alert$IAlertOptions
    }

    declare interface alert$IAlert {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface alert$IAlertOptions {
        animation?: string,
            placement?: string,
            title?: string,
            content?: string,
            type?: string,
            keyboard?: boolean,
            show?: boolean,
            container?: string | boolean,
            template?: string,
            duration?: number | boolean,
            dismissable?: boolean
    }

    declare type alert$IAlertScope = {
        $show: () => void,
        $hide: () => void,
        $toggle: () => void
    }
    declare interface tooltip$ITooltipService {
        (element: ng$IAugmentedJQuery, config?: tooltip$ITooltipOptions): tooltip$ITooltip
    }

    declare interface tooltip$ITooltipProvider {
        defaults: tooltip$ITooltipOptions
    }

    declare interface tooltip$ITooltip {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface tooltip$ITooltipOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            title?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            target?: string | ng$IAugmentedJQuery | boolean,
            template?: string,
            contentTemplate?: string,
            prefixEvent?: string,
            id?: string,
            viewport?: string | {
                selector: string,
                padding: string | number
            }
    }

    declare type tooltip$ITooltipScope = {
        $show: () => void,
        $hide: () => void,
        $toggle: () => void,
        $setEnabled: (isEnabled: boolean) => void
    }
    declare interface popover$IPopoverService {
        (element: ng$IAugmentedJQuery, config?: popover$IPopoverOptions): popover$IPopover
    }

    declare interface popover$IPopoverProvider {
        defaults: popover$IPopoverOptions
    }

    declare interface popover$IPopover {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface popover$IPopoverOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            title?: string,
            content?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            target?: string | ng$IAugmentedJQuery | boolean,
            template?: string,
            contentTemplate?: string,
            autoClose?: boolean,
            id?: string,
            viewport?: string | {
                selector: string,
                padding: string | number
            }
    }

    declare type popover$IPopoverScope = {
        $show: () => void,
        $hide: () => void,
        $toggle: () => void
    }
    declare interface typeahead$ITypeaheadService {
        (element: ng$IAugmentedJQuery, controller: any, config?: typeahead$ITypeaheadOptions): typeahead$ITypeahead
    }

    declare interface typeahead$ITypeaheadProvider {
        defaults: typeahead$ITypeaheadOptions
    }

    declare interface typeahead$ITypeahead {
        $promise: ng$IPromise<void>,
            show: () => void,
            hide: () => void,
            toggle: () => void
    }

    declare interface typeahead$ITypeaheadOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            template?: string,
            limit?: number,
            minLength?: number,
            autoSelect?: boolean,
            comparator?: string,
            id?: string,
            watchOptions?: boolean
    }
    declare interface datepicker$IDatepickerService {
        (element: ng$IAugmentedJQuery, controller: any, config?: datepicker$IDatepickerOptions): datepicker$IDatepicker
    }

    declare interface datepicker$IDatepickerProvider {
        defaults: datepicker$IDatepickerOptions
    }

    declare interface datepicker$IDatepicker {
        update: (date: Date) => void,
            updateDisabledDates: (dateRanges: datepicker$IDatepickerDateRange[]) => void,
            select: (dateConstructorArg: string | number | number[], keep: boolean) => void,
            setMode: (mode: any) => void,
            int: () => void,
            destroy: () => void,
            show: () => void,
            hide: () => void
    }

    declare interface datepicker$IDatepickerDateRange {
        start: Date,
            end: Date
    }

    declare interface datepicker$IDatepickerOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            template?: string,
            dateFormat?: string,
            modelDateFormat?: string,
            dateType?: string,
            timezone?: string,
            autoclose?: boolean,
            useNative?: boolean,
            minDate?: Date,
            maxDate?: Date,
            startView?: number,
            minView?: number,
            startWeek?: number,
            startDate?: Date,
            iconLeft?: string,
            iconRight?: string,
            daysOfWeekDisabled?: string,
            disabledDates?: datepicker$IDatepickerDateRange[]
    }
    declare interface timepicker$ITimepickerService {
        (element: ng$IAugmentedJQuery, controller: any, config?: timepicker$ITimepickerOptions): timepicker$ITimepicker
    }

    declare interface timepicker$ITimepickerProvider {
        defaults: timepicker$ITimepickerOptions
    }

    declare interface timepicker$ITimepicker {}

    declare interface timepicker$ITimepickerOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            template?: string,
            timeFormat?: string,
            modelTimeFormat?: string,
            timeType?: string,
            autoclose?: boolean,
            useNative?: boolean,
            minTime?: Date,
            maxTime?: Date,
            length?: number,
            hourStep?: number,
            minuteStep?: number,
            secondStep?: number,
            roundDisplay?: boolean,
            iconUp?: string,
            iconDown?: string,
            arrowBehaviour?: string
    }
    declare interface select$ISelectService {
        (element: ng$IAugmentedJQuery, controller: any, config: select$ISelectOptions): select$ISelect
    }

    declare interface select$ISelectProvider {
        defaults: select$ISelectOptions
    }

    declare interface select$ISelect {
        update: (matches: any) => void,
            active: (index: number) => number,
            select: (index: number) => void,
            show: () => void,
            hide: () => void
    }

    declare interface select$ISelectOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            template?: string,
            multiple?: boolean,
            allNoneButtons?: boolean,
            allText?: string,
            noneText?: string,
            maxLength?: number,
            maxLengthHtml?: string,
            sort?: boolean,
            placeholder?: string,
            iconCheckmark?: string,
            id?: string
    }
    declare interface tab$ITabProvider {
        defaults: tab$ITabOptions
    }

    declare interface tab$ITabService {
        defaults: tab$ITabOptions,
            controller: any
    }

    declare interface tab$ITabOptions {
        animation?: string,
            template?: string,
            navClass?: string,
            activeClass?: string
    }
    declare interface collapse$ICollapseProvider {
        defaults: collapse$ICollapseOptions
    }

    declare interface collapse$ICollapseOptions {
        animation?: string,
            activeClass?: string,
            disallowToggle?: boolean,
            startCollapsed?: boolean,
            allowMultiple?: boolean
    }
    declare interface dropdown$IDropdownProvider {
        defaults: dropdown$IDropdownOptions
    }

    declare interface dropdown$IDropdownService {
        (element: ng$IAugmentedJQuery, config: dropdown$IDropdownOptions): dropdown$IDropdown
    }

    declare interface dropdown$IDropdown {
        show: () => void,
            hide: () => void,
            destroy: () => void
    }

    declare interface dropdown$IDropdownOptions {
        animation?: string,
            placement?: string,
            trigger?: string,
            html?: boolean,
            delay?: number | {
                show: number,
                hide: number
            },
            container?: string | boolean,
            template?: string
    }
    declare interface navbar$INavbarProvider {
        defaults: navbar$INavbarOptions
    }

    declare interface navbar$INavbarOptions {
        activeClass?: string,
            routeAttr?: string
    }

    declare interface navbar$INavbarService {
        defaults: navbar$INavbarOptions
    }
    declare interface scrollspy$IScrollspyProvider {
        defaults: scrollspy$IScrollspyOptions
    }

    declare interface scrollspy$IScrollspyService {
        (element: ng$IAugmentedJQuery, options: scrollspy$IScrollspyOptions): scrollspy$IScrollspy
    }

    declare interface scrollspy$IScrollspy {
        checkOffsets: () => void,
            trackElement: (target: any, source: any) => void,
            untrackElement: (target: any, source: any) => void,
            activate: (index: number) => void
    }

    declare interface scrollspy$IScrollspyOptions {
        target?: string,
            offset?: number
    }
    declare interface affix$IAffixProvider {
        defaults: affix$IAffixOptions
    }

    declare interface affix$IAffixService {
        (element: ng$IAugmentedJQuery, options: affix$IAffixOptions): affix$IAffix
    }

    declare interface affix$IAffix {
        init: () => void,
            destroy: () => void,
            checkPositionWithEventLoop: () => void,
            checkPosition: () => void
    }

    declare interface affix$IAffixOptions {
        offsetTop?: number,
            offsetBottom?: number,
            offsetParent?: number,
            offsetUnpin?: number
    }
}
declare module 'angular-toastr' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare interface toasty$IToastyService {

    /**
     * Create a toast with the given options and type.
     * @param options 
     * @param type 
     */
    (options: toasty$IToastyConfig, type?: string): void,

    /**
     * Create a default "quick toast" with the given title.
     * @param title 
     */
    (title: string | number): void,

    /**
     * Create a default toast with the given options.
     * @param options 
     */
    default (options: toasty$IToastyConfig): void,

    /**
     * Create a default "quick toast" with the given title.
     * @param title 
     */
    default (title: string | number): void,

    /**
     * Create an info toast with the given options.
     * @param options 
     */
    info(options: toasty$IToastyConfig): void,

        /**
         * Create an info "quick toast" with the given title.
         * @param title 
         */
        info(title: string | number): void,

        /**
         * Create a wait toast with the given options.
         * @param options 
         */
        wait(options: toasty$IToastyConfig): void,

        /**
         * Create a wait "quick toast" with the given title.
         * @param title 
         */
        wait(title: string | number): void,

        /**
         * Create a success toast with the given options.
         * @param options 
         */
        success(options: toasty$IToastyConfig): void,

        /**
         * Create a success "quick toast" with the given title.
         * @param title 
         */
        success(title: string | number): void,

        /**
         * Create an error toast with the given options.
         * @param options 
         */
        error(options: toasty$IToastyConfig): void,

        /**
         * Create an error "quick toast" with the given title.
         * @param title 
         */
        error(title: string | number): void,

        /**
         * Create a warning toast with the given options.
         * @param options 
         */
        warning(options: toasty$IToastyConfig): void,

        /**
         * Create a warning "quick toast" with the given title.
         * @param title 
         */
        warning(title: string | number): void,

        /**
         * Clear toast(s).
         * @param id Optional ID to clear a specific toast.
         */
        clear(id?: number): void,

        /**
         * Get the global config.
         */
        getGlobalConfig(): toasty$IGlobalConfig
}

declare interface toasty$IToastyConfig {

    /**
     * The toast's title.
     */
    title: string,

        /**
         * The toast's message.
         */
        msg?: string,

        /**
         * Whether to show the 'X' icon to close the toast.
         */
        showClose?: boolean,

        /**
         * Whether clicking the toast closes it.
         */
        clickToClose?: boolean,

        /**
         * How long (in milliseconds) the toast shows before it's removed. Set to false to disable.
         */
        timeout?: number,

        /**
         * Whether to play a sound when a toast is added.
         */
        sound?: boolean,

        /**
         * Whether HTML is allowed in toasts.
         */
        html?: boolean,

        /**
         * Whether to shake the toasts.
         */
        shake?: boolean,

        /**
         * What theme to use.
         * - 'default'
        - 'material'
        - 'bootstrap'
        */
        theme?: string,

        /**
         * The toast's type:
         * - 'default'
        - 'info'
        - 'success'
        - 'wait'
        - 'error'
        - 'warning'
        */
        type?: string,

        /**
         * Add event handler.
         */
        onAdd?: Function,

        /**
         * Remove event handler.
         */
        onRemove?: Function,

        /**
         * Click event handler.
         */
        onClick?: Function
}

declare interface toasty$IGlobalConfig {

    /**
     * Maximum number of toasts to show at once.
     */
    limit?: number,

        /**
         * The toast's title.
         */
        title?: string,

        /**
         * The toast's message.
         */
        msg?: string,

        /**
         * Whether to show the 'X' icon to close the toast.
         */
        showClose?: boolean,

        /**
         * Whether clicking the toast closes it.
         */
        clickToClose?: boolean,

        /**
         * The window position where the toast pops up.
         */
        position?: string,

        /**
         * How long (in miliseconds) the toast shows before it's removed. Set to false to disable.
         */
        timeout?: number | boolean,

        /**
         * Whether to play a sound when a toast is added.
         */
        sound?: boolean,

        /**
         * Whether HTML is allowed in toast.
         */
        html?: boolean,

        /**
         * Whether to shake the toast.
         */
        shake?: boolean,

        /**
         * What theme to use.
         * - 'default'
        - 'material'
        - 'bootstrap'
        */
        theme?: string
}

declare interface toasty$IToastyConfigProvider {
    setConfig(override: toasty$IGlobalConfig): void,
        $get(): toasty$IGlobalConfig
}
declare module 'angular-touchspin' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-translate' {
    declare module.exports: typeof ngt
}
declare module 'angular-bootstrap' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-ui-bootstrap' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-ui-router' {
    declare module.exports: typeof ui.router
    declare     export interface IState {
        ncyBreadcrumb?: {

                /**
                 * Contains the label for the step in the breadcrumb. The state name is used if not defined.
                 */
                label?: string,

                /**
                 * Override the parent state (only for the breadcrumb)
                 */
                parent?: string | Function,

                /**
                 * When defined to true, the state is never included in the chain of states and never appears in the breadcrumb
                 */
                skip?: boolean
            },
            ncyBreadcrumbLabel?: string,
            ncyBreadcrumbLink?: string
    }
    declare     export type IStateProvider = undefined.IStateProvider;
    declare     export type IUrlMatcher = undefined.IUrlMatcher;
    declare     export type IUrlRouterProvider = undefined.IUrlRouterProvider;
    declare     export type IStateOptions = undefined.IStateOptions;
    declare     export type IHrefOptions = undefined.IHrefOptions;
    declare     export type IStateService = undefined.IStateService;
    declare     export type IResolvedState = undefined.IResolvedState;
    declare     export type IStateParamsService = undefined.IStateParamsService;
    declare     export type IUrlRouterService = undefined.IUrlRouterService;
    declare     export type IUiViewScrollProvider = undefined.IUiViewScrollProvider;
    declare     export type IType = undefined.IType;
}
declare interface AngularUITree$IEventSourceInfo {
    cloneModel: any,
        index: number,
        nodeScope: AngularUITree$ITreeNodeScope,
        nodesScope: AngularUITree$ITreeNodeScope
}

declare interface AngularUITree$IPosition {
    dirAx: number,
        dirX: number,
        dirY: number,
        distAxX: number,
        distAxY: number,
        distX: number,
        distY: number,
        lastDirX: number,
        lastDirY: number,
        lastX: number,
        lastY: number,
        moving: boolean,
        nowX: number,
        nowY: number,
        offsetX: number,
        offsetY: number,
        startX: number,
        startY: number
}

declare interface AngularUITree$IEventInfo {
    dest: {
            index: number,
            nodesScope: AngularUITree$IParentTreeNodeScope
        },
        elements: any,
        pos: AngularUITree$IPosition,
        source: AngularUITree$IEventSourceInfo
}

declare interface AngularUITree$IAcceptCallback {
    (source: AngularUITree$ITreeNodeScope, destination: AngularUITree$ITreeNodeScope, destinationIndex: number): boolean
}

declare interface AngularUITree$IDroppedCallback {
    (eventInfo: AngularUITree$IEventInfo): void
}

declare interface AngularUITree$ICallbacks {
    accept: AngularUITree$IAcceptCallback,
        dragStart: AngularUITree$IDroppedCallback,
        dropped: AngularUITree$IDroppedCallback
}


/**
 * Internal representation of node in the UI
 */
declare type AngularUITree$ITreeNodeScope = {
    node: AngularUITree$ITreeNode
}

declare type AngularUITree$IParentTreeNodeScope = {
    isParent(nodeScope: AngularUITree$ITreeNodeScope): boolean
} & AngularUITree$ITreeNodeScope



/**
 * Node in list
 */
declare interface AngularUITree$ITreeNode {
    id: number | string,
        nodes: AngularUITree$ITreeNode[],
        title: string
}
declare interface AngularFireService {
    (firebase: Firebase, config?: any): AngularFire
}
/**
 * 
 * @deprecated  . Not possible with AngularFire 1.0+
 */
declare interface AngularFire {
    $asArray(): AngularFireArray,
        $asObject(): AngularFireObject,
        $ref(): Firebase,
        $push(data: any): ng$IPromise<Firebase>,
        $set(key: string, data: any): ng$IPromise<Firebase>,
        $set(data: any): ng$IPromise<Firebase>,
        $remove(key?: string): ng$IPromise<Firebase>,
        $update(key: string, data: AV$Object): ng$IPromise<Firebase>,
        $update(data: any): ng$IPromise<Firebase>,
        $transaction(
            updateFn: (currentData: any) => any,
            applyLocally?: boolean): ng$IPromise<FirebaseDataSnapshot>,
        $transaction(
            key: string,
            updateFn: (currentData: any) => any,
            applyLocally?: boolean): ng$IPromise<FirebaseDataSnapshot >
}
/**
 * Creates and maintains a synchronized object, with 2-way bindings between Angular and Firebase.
 */
declare type AngularFireObject = {
    $id: string,
    $priority: number,
    $value: any,

    /**
     * Removes all keys from the FirebaseObject and also removes
     * the remote data from the server.
     * @returns  a promise which will resolve after the op completes
     */
    $remove(): ng$IPromise<Firebase>,

    /**
     * Saves all data on the FirebaseObject back to Firebase.
     * @returns  a promise which will resolve after the save is completed.
     */
    $save(): ng$IPromise<Firebase>,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asObject() is now cached
    locally in the object.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  
     * @param  
     * @returns  a promise which resolves after initial data is downloaded from Firebase
    */
    $loaded(
        resolve?: (x: AngularFireObject) => ng$IHttpPromise<{}>,
        reject?: (err: any) => any): ng$IPromise<AngularFireObject>,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asObject() is now cached
    locally in the object.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  
     * @param  
     * @returns  a promise which resolves after initial data is downloaded from Firebase
    */
    $loaded(
        resolve?: (x: AngularFireObject) => ng$IPromise<{}>,
        reject?: (err: any) => any): ng$IPromise<AngularFireObject>,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asObject() is now cached
    locally in the object.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  
     * @param  
     * @returns  a promise which resolves after initial data is downloaded from Firebase
    */
    $loaded(
        resolve?: (x: AngularFireObject) => void,
        reject?: (err: any) => any): ng$IPromise<AngularFireObject>,

    /**
     * 
     * @returns  the original Firebase instance used to create this object.
     */
    $ref(): Firebase,

    /**
     * Creates a 3-way data sync between this object, the Firebase server, and a
     * scope variable. This means that any changes made to the scope variable are
    pushed to Firebase, and vice versa.

    If scope emits a $destroy event, the binding is automatically severed. Otherwise,
    it is possible to unbind the scope variable by using the `unbind` function
    passed into the resolve method.

    Can only be bound to one scope variable at a time. If a second is attempted,
    the promise will be rejected with an error.
     * @param  
     * @param  
     * @returns  a promise which resolves to an unbind method after data is set in scope
    */
    $bindTo(scope: ng$IScope, varName: string): ng$IPromise<any>,

    /**
     * Listeners passed into this method are notified whenever a new change is received
     * from the server. Each invocation is sent an object containing
    <code>{ type: 'value', key: 'my_firebase_id' }</code>

    This method returns an unbind function that can be used to detach the listener.
     * @param  
     * @param  * 
     * @returns  invoke to stop observing events
    */
    $watch(callback: Function, context?: any): Function,

    /**
     * Informs $firebase to stop sending events and clears memory being used
     * by this object (delete's its local content).
     */
    $destroy(): void
} & AngularFireSimpleObject
declare interface AngularFireObjectService {

    /**
     * Creates a synchronized object with 2-way bindings between Angular and Firebase.
     * @param  
     * @returns  
     */
    (firebase: Firebase): AngularFireObject,
    $extend(ChildClass: AV$Object, methods?: AV$Object): AV$Object
}
/**
 * Creates and maintains a synchronized list of data. This is a pseudo-read-only array. One should
 * not call splice(), push(), pop(), et al directly on this array, but should instead use the
$remove and $add methods.

It is acceptable to .sort() this array, but it is important to use this in conjunction with
$watch(), so that it will be re-sorted any time the server data changes. Examples of this are
included in the $watch documentation.
*/
declare type AngularFireArray = {

    /**
     * Create a new record with a unique ID and add it to the end of the array.
     * This should be used instead of Array.prototype.push, since those changes will not be
    synchronized with the server.

    Any value, including a primitive, can be added in this way. Note that when the record
    is created, the primitive value would be stored in $value (records are always objects
    by default).

    Returns a future which is resolved when the data has successfully saved to the server.
    The resolve callback will be passed a Firebase ref representing the new data element.
     * @param data 
     * @returns  a promise resolved after data is added
    */
    $add(newData: any): ng$IPromise<Firebase>,

    /**
     * Pass either an item in the array or the index of an item and it will be saved back
     * to Firebase. While the array is read-only and its structure should not be changed,
    it is okay to modify properties on the objects it contains and then save those back
    individually.

    Returns a future which is resolved when the data has successfully saved to the server.
    The resolve callback will be passed a Firebase ref representing the saved element.
    If passed an invalid index or an object which is not a record in this array,
    the promise will be rejected.
     * @param  
     * @returns  a promise resolved after data is saved
    */
    $save(recordOrIndex: any): ng$IPromise<Firebase>,

    /**
     * Pass either an existing item in this array or the index of that item and it will
     * be removed both locally and in Firebase. This should be used in place of
    Array.prototype.splice for removing items out of the array, as calling splice
    will not update the value on the server.

    Returns a future which is resolved when the data has successfully removed from the
    server. The resolve callback will be passed a Firebase ref representing the deleted
    element. If passed an invalid index or an object which is not a record in this array,
    the promise will be rejected.
     * @param  
     * @returns  a promise which resolves after data is removed
    */
    $remove(recordOrIndex: any): ng$IPromise<Firebase>,

    /**
     * Returns the record for a given Firebase key (record.$id). If the record is not found
     * then returns null.
     * @param  
     * @returns  a record in this array
     */
    $getRecord(key: string): AngularFireSimpleObject,

    /**
     * Given an item in this array or the index of an item in the array, this returns the
     * Firebase key (record.$id) for that record. If passed an invalid key or an item which
    does not exist in this array, it will return null.
     * @param  
     * @returns  
    */
    $keyAt(recordOrIndex: any): string,

    /**
     * The inverse of $keyAt, this method takes a Firebase key (record.$id) and returns the
     * index in the array where that record is stored. If the record is not in the array,
    this method returns -1.
     * @param  
     * @returns  -1 if not found
    */
    $indexFor(key: string): number,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asArray() is now cached
    locally in the array.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  * 
     * @param  * 
     * @returns  a promise
    */
    $loaded(
        resolve?: (x: AngularFireArray) => ng$IHttpPromise<{}>,
        reject?: (err: any) => any): ng$IPromise<AngularFireArray>,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asArray() is now cached
    locally in the array.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  * 
     * @param  * 
     * @returns  a promise
    */
    $loaded(
        resolve?: (x: AngularFireArray) => ng$IPromise<{}>,
        reject?: (err: any) => any): ng$IPromise<AngularFireArray>,

    /**
     * The loaded method is invoked after the initial batch of data arrives from the server.
     * When this resolves, all data which existed prior to calling $asArray() is now cached
    locally in the array.

    As a shortcut is also possible to pass resolve/reject methods directly into this
    method just as they would be passed to .then()
     * @param  * 
     * @param  * 
     * @returns  a promise
    */
    $loaded(
        resolve?: (x: AngularFireArray) => void,
        reject?: (err: any) => any): ng$IPromise<AngularFireArray>,

    /**
     * 
     * @returns  the original Firebase ref used to create this object.
     */
    $ref(): Firebase,

    /**
     * Listeners passed into this method are notified whenever a new change (add, updated,
     * move, remove) is received from the server. Each invocation is sent an object
    containing <code>{ type: 'child_added|child_updated|child_moved|child_removed',
    key: 'key_of_item_affected'}</code>

    Additionally, added and moved events receive a prevChild parameter, containing the
    key of the item before this one in the array.

    This method returns a function which can be invoked to stop observing events.
     * @param  
     * @param  * 
     * @returns  used to stop observing
    */
    $watch(
        cb: (event: string, key: string, prevChild: string) => void,
        context?: any): Function,

    /**
     * Informs $firebase to stop sending events and clears memory being used
     * by this array (delete's its local content).
     */
    $destroy(): void
} & Array
declare interface AngularFireArrayService {
    (firebase: Firebase): AngularFireArray,
    $extend(ChildClass: AV$Object, methods?: AV$Object): AV$Object
}
declare interface AngularFireSimpleObject {
    $id: string,
        $priority: number,
        $value: any, [key: string]: any
}
declare interface AngularFireAuthService {
    (firebase: Firebase): AngularFireAuth
}
declare interface AngularFireAuth {

    /**
     * Authenticates the Firebase reference with a custom authentication token.
     * @param  An authentication token or a Firebase Secret. A Firebase Secret
    should only be used for authenticating a server process and provides full read / write
    access to the entire Firebase.
     * @param  An object containing optional client arguments, such as configuring
    session persistence.
     * @return  A promise fulfilled with an object containing authentication data.
    */
    $authWithCustomToken(authToken: string, options?: AV$Object): ng$IPromise<any>,

        /**
         * Authenticates the Firebase reference anonymously.
         * @param  An object containing optional client arguments, such as configuring
        session persistence.
         * @return  A promise fulfilled with an object containing authentication data.
        */
        $authAnonymously(options?: AV$Object): ng$IPromise<any>,

        /**
         * Authenticates the Firebase reference with an email/password user.
         * @param  An object containing email and password attributes corresponding
        to the user account.
         * @param  An object containing optional client arguments, such as configuring
        session persistence.
         * @return  A promise fulfilled with an object containing authentication data.
        */
        $authWithPassword(credentials: FirebaseCredentials, options?: AV$Object): ng$IPromise<any>,

        /**
         * Authenticates the Firebase reference with the OAuth popup flow.
         * @param  The unique string identifying the OAuth provider to authenticate
        with, e.g. google.
         * @param  An object containing optional client arguments, such as configuring
        session persistence.
         * @return  A promise fulfilled with an object containing authentication data.
        */
        $authWithOAuthPopup(provider: string, options?: AV$Object): ng$IPromise<any>,

        /**
         * Authenticates the Firebase reference with the OAuth redirect flow.
         * @param  The unique string identifying the OAuth provider to authenticate
        with, e.g. google.
         * @param  An object containing optional client arguments, such as configuring
        session persistence.
         * @return  A promise fulfilled with an object containing authentication data.
        */
        $authWithOAuthRedirect(provider: string, options?: AV$Object): ng$IPromise<any>,

        /**
         * Authenticates the Firebase reference with an OAuth token.
         * @param  The unique string identifying the OAuth provider to authenticate
        with, e.g. google.
         * @param  Either a string, such as an OAuth 2.0 access token, or an
        Object of key / value pairs, such as a set of OAuth 1.0a credentials.
         * @param  An object containing optional client arguments, such as configuring
        session persistence.
         * @return  A promise fulfilled with an object containing authentication data.
        */
        $authWithOAuthToken(
            provider: string,
            credentials: AV$Object | string,
            options?: AV$Object): ng$IPromise<any>,

        /**
         * Synchronously retrieves the current authentication data.
         * @return  The client's authentication data.
         */
        $getAuth(): FirebaseAuthData,

        /**
         * Asynchronously fires the provided callback with the current authentication data every time
         * the authentication data changes. It also fires as soon as the authentication data is
        retrieved from the server.
         * @param  A callback that fires when the client's authenticate state
        changes. If authenticated, the callback will be passed an object containing authentication
        data according to the provider used to authenticate. Otherwise, it will be passed null.
         * @param  If provided, this object will be used as this when calling your
        callback.
         * @return  A function which can be used to deregister the provided callback.
        */
        $onAuth(callback: Function, context?: any): Function,

        /**
         * Unauthenticates the Firebase reference.
         */
        $unauth(): void,

        /**
         * Utility method which can be used in a route's resolve() method to grab the current
         * authentication data.
         * @returns  >} A promise fulfilled with the client's current authentication
        state, which will be null if the client is not authenticated.
        */
        $waitForAuth(): ng$IPromise<any>,

        /**
         * Utility method which can be used in a route's resolve() method to require that a route has
         * a logged in client.
         * @returns  A promise fulfilled with the client's current authentication
        state or rejected if the client is not authenticated.
        */
        $requireAuth(): ng$IPromise<any>,

        /**
         * Creates a new email/password user. Note that this function only creates the user, if you
         * wish to log in as the newly created user, call $authWithPassword() after the promise for
        this method has been resolved.
         * @param  An object containing the email and password of the user to create.
         * @return  A promise fulfilled with the user object, which contains the
        uid of the created user.
        */
        $createUser(credentials: FirebaseCredentials): ng$IPromise<any>,

        /**
         * Removes an email/password user.
         * @param  An object containing the email and password of the user to remove.
         * @return  An empty promise fulfilled once the user is removed.
         */
        $removeUser(credentials: FirebaseCredentials): ng$IPromise<any>,

        /**
         * Changes the email for an email/password user.
         * @param  An object containing the old email, new email, and password of
        the user whose email is to change.
         * @return  An empty promise fulfilled once the email change is complete.
        */
        $changeEmail(credentials: FirebaseChangeEmailCredentials): ng$IPromise<any>,

        /**
         * Changes the password for an email/password user.
         * @param  An object containing the email, old password, and new password of
        the user whose password is to change.
         * @return  An empty promise fulfilled once the password change is complete.
        */
        $changePassword(credentials: FirebaseChangePasswordCredentials): ng$IPromise<any>,

        /**
         * Sends a password reset email to an email/password user.
         * @param  An object containing the email of the user to send a reset
        password email to.
         * @return  An empty promise fulfilled once the reset password email is sent.
        */
        $resetPassword(credentials: FirebaseResetPasswordCredentials): ng$IPromise<any >
}
declare interface ngtoaster$IToasterService {
    pop(params: ngtoaster$IPopParams): void,

        /**
         * 
         * @param  Type of toaster  -- 'error', 'info', 'wait', 'success', and 'warning'
         */
        pop(
            type?: string,
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number,
            showCloseButton?: boolean): void,
        error(params: ngtoaster$IPopParams): void,
        error(
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number): void,
        info(params: ngtoaster$IPopParams): void,
        info(
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number): void,
        wait(params: ngtoaster$IPopParams): void,
        wait(
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number): void,
        success(params: ngtoaster$IPopParams): void,
        success(
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number): void,
        warning(params: ngtoaster$IPopParams): void,
        warning(
            title?: string,
            body?: string,
            timeout?: number,
            bodyOutputType?: string,
            clickHandler?: EventListener,
            toasterId?: number): void,
        clear(): void,
        toast: ngtoaster$IToast
}

declare interface ngtoaster$IToasterEventRegistry {
    setup(): void,
        subscribeToNewToastEvent(onNewToast: ngtoaster$IToastEventListener): void,
        subscribeToClearToastsEvent(onClearToasts: ngtoaster$IToastEventListener): void,
        unsubscribeToNewToastEvent(onNewToast: ngtoaster$IToastEventListener): void,
        unsubscribeToClearToastsEvent(onClearToasts: ngtoaster$IToastEventListener): void
}

declare type ngtoaster$IPopParams = {
    toasterId?: number
} & ngtoaster$IToast


declare interface ngtoaster$IToastEventListener {
    (event: autobahn$Event, toasterId: number): void
}

declare interface ngtoaster$IToast {
    el: angular$IAugmentedJQuery,
        iconClass: string,
        isOpened: boolean,
        open: angular$IPromise<any>,
        scope: IToastScope,
        toastId: number
}

declare interface ngtoaster$IToasterConfig {

    /**
     * limits max number of toasts
     */
    limit?: number,
        tap - to - dismiss?: boolean,
        close - button?: boolean,
        newest - on - top?: boolean,
        time - out?: number,
        icon - classes?: ngtoaster$IIconClasses,

        /**
         * Options include:
         * '', 'trustedHtml', 'template', 'templateWithData'
         */
        body - output - type?: string,
        body - template?: string,
        icon - class?: string,

        /**
         * Options include:
         * 'toast-top-full-width', 'toast-bottom-full-width', 'toast-center',
        'toast-top-left', 'toast-top-center', 'toast-top-rigt',
        'toast-bottom-left', 'toast-bottom-center', 'toast-bottom-rigt',
        */
        position - class?: string,
        title - class?: string,
        message - class?: string,
        prevent - duplicates?: boolean,

        /**
         * stop timeout on mouseover and restart timer on mouseout
         */
        mouseover - timer - stop?: boolean
}

declare interface ngtoaster$IIconClasses {
    error: string,
        info: string,
        wait: string,
        success: string,
        warning: string
}
declare module 'ngtoaster' {
    declare module.exports: typeof ngtoaster
}
declare module 'angular-animate' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-cookies' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-mocks/ngMock' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-mocks/ngMockE2E' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-mocks/ngAnimateMock' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare var inject: angular$IInjectStatic;
declare module 'angular-resource' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare interface Array<T>{

    /**
     * the promise of the original server interaction that created this collection. 
     */
    $promise: angular$IPromise<Array<T >> ,
    $resolved: boolean
}
declare module 'angular-route' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare module 'angular-sanitize' {
    declare     var _: string;
    declare module.exports: typeof _
}
declare var angular: angular$IAngularStatic;
declare interface Function {
    $inject?: string[]
}
declare var module: (...modules: any[]) => any;
declare var inject: (...fns: Function[]) => any;
declare var angular: angularScenario$AngularModel;
declare interface angulartics$IAngularticsStatic {
    waitForVendorApi(
        objectName: string,
        delay: number,
        containsField?: any,
        registerFn?: any,
        onTimeout?: boolean): void
}

declare interface angulartics$IAnalyticsService {
    eventTrack(eventName: string, properties?: any): any,
        pageTrack(path: string, location?: angular$ILocationService): any,
        setAlias(alias: string): any,
        setUsername(username: string): any,
        setUserProperties(properties: any): any,
        setSuperProperties(properties: any): any
}

declare type angulartics$IAnalyticsServiceProvider = {
    virtualPageviews(value: boolean): void,
    excludeRoutes(value: string[]): void,
    firstPageview(value: boolean): void,
    withBase(value: boolean): void,
    withAutoBase(value: boolean): void,
    developerMode(value: boolean): void,
    registerPageTrack(callback: (path: string, location?: angular$ILocationService) => any): void,
    registerEventTrack(callback: (eventName: string, properties?: any) => any): void,
    registerSetAlias(callback: (alias: string) => any): void,
    registerSetUsername(callback: (username: string) => any): void,
    registerSetUserProperties(callback: (userProperties: any) => any): void,
    registerSetSuperProperties(callback: (superProperties: any) => any): void,
    settings: {
        pageTracking: {
            autoTrackingVirtualPages: boolean,
            autoTrackingFirstPage: boolean,
            basePath: string,
            autoBasePath: boolean
        },
        developerMode: boolean
    }
}
declare var angulartics: angulartics$IAngularticsStatic;
declare interface AnimationFrame {
    new(): AnimationFrame,
    request(callback: () => void): void
}
declare var AnimationFrame: AnimationFrame;
declare module 'ansi-styles' {
    declare     export interface EscapeCodePair {
        open: string,
            close: string
    }
    declare     export var reset: EscapeCodePair;
    declare     export var bold: EscapeCodePair;
    declare     export var dim: EscapeCodePair;
    declare     export var italic: EscapeCodePair;
    declare     export var underline: EscapeCodePair;
    declare     export var inverse: EscapeCodePair;
    declare     export var hidden: EscapeCodePair;
    declare     export var strikethrough: EscapeCodePair;
    declare     export var black: EscapeCodePair;
    declare     export var red: EscapeCodePair;
    declare     export var green: EscapeCodePair;
    declare     export var yellow: EscapeCodePair;
    declare     export var blue: EscapeCodePair;
    declare     export var magenta: EscapeCodePair;
    declare     export var cyan: EscapeCodePair;
    declare     export var white: EscapeCodePair;
    declare     export var gray: EscapeCodePair;
    declare     export var bgBlack: EscapeCodePair;
    declare     export var bgRed: EscapeCodePair;
    declare     export var bgGreen: EscapeCodePair;
    declare     export var bgYellow: EscapeCodePair;
    declare     export var bgBlue: EscapeCodePair;
    declare     export var bgMagenta: EscapeCodePair;
    declare     export var bgCyan: EscapeCodePair;
    declare     export var bgWhite: EscapeCodePair;
}
declare module 'ansicolors' {
    declare     var colors: {
        [index: string]: (s: string) => string
    };
    declare module.exports: typeof colors
}
declare interface Antd$AffixProps {

    /**
     * 达到指定偏移量后触发
     */
    offset?: number
}


/**
 * # Affix
 * 将页面元素钉在可视范围。
## 何时使用
当内容区域比较长，需要滚动页面时，这部分内容对应的操作或者导航需要在滚动范围内始终展现。常用于侧边菜单和按钮组合。
页面可视范围过小时，慎用此功能以免遮挡页面内容。
*/
declare export class Affix mixins React.Component<Antd$AffixProps, {}>{
    render(): JSX.Element
}

declare interface Antd$AlertProps {

    /**
     * 必选参数，指定警告提示的样式，有四种选择`success`、`info`、`warn`、`error`
     */
    type: string,

        /**
         * 可选参数，默认不显示关闭按钮 
         */
        closable?: boolean,

        /**
         * 可选参数，自定义关闭按钮 
         */
        closeText?: React.ReactNode,

        /**
         * 必选参数，警告提示内容 
         */
        message: React.ReactNode,

        /**
         * 可选参数，警告提示的辅助性文字介绍 
         */
        description?: React.ReactNode,

        /**
         * 可选参数，关闭时触发的回调函数 
         */
        onClose?: Function,

        /**
         * 可选参数，是否显示辅助图标 
         */
        showIcon?: boolean
}


/**
 * # Alert
 * 警告提示，展现需要关注的信息。

## 何时使用

- 当某个页面需要向用户显示警告的信息时。
- 非浮层的静态展现形式，始终展现，不会自动消失，用户可以点击关闭。
*/
declare export class Alert mixins React.Component<Antd$AlertProps, {}>{
    render(): JSX.Element
}


/**
 * #Badge
 * 
图标右上角的圆形徽标数字。

## 何时使用

一般出现在通知图标或头像的右上角，用于显示需要处理的消息条数，通过醒目视觉形式吸引用户处理。
*/
declare export class Badge mixins React.Component<Antd$BadgeProps, {}>{
    render(): JSX.Element
}

declare interface Antd$BadgeProps {

    /**
     * 展示的数字，大于 overflowCount 时显示为 `${overflowCount}+`，为 0 时隐藏
     */
    count: number,

        /**
         * 展示封顶的数字值
         */
        overflowCount?: number,

        /**
         * 不展示数字，只有一个小红点
         */
        dot?: boolean
}

declare interface Antd$ButtonProps {

    /**
     * 设置按钮类型，可选值为 `primary` `ghost` 或者不设 
     */
    type?: ButtonType | string,

        /**
         * 设置按钮形状，可选值为 `circle` `circle-outline` 或者不设
         */
        shape?: string,

        /**
         * 设置按钮大小，可选值为 `small` `large` 或者不设
         */
        size?: string,

        /**
         * 设置 `button` 原生的 `type` 值，可选值请参考 HTML标准
         */
        htmlType?: string,

        /**
         * `click` 事件的 handler
         */
        onClick?: Function,

        /**
         * 设置按钮载入状态
         */
        loading?: boolean,

        /**
         * 样式名
         */
        className?: string
}

declare interface Antd$ButtonGroupProps {

    /**
     * 设置按钮大小，可选值为 `small` `large` 或者不设
     */
    size?: string
}


/**
 * 可以将多个 `Button` 放入 `Button.Group` 的容器中。
 * 
通过设置 `size` 为 `large` `small` 分别把按钮组合设为大、小尺寸。若不设置 `size`，则尺寸为中。
*/
declare class ButtonGroup mixins React.Component<Antd$ButtonGroupProps, {}>{
    render(): JSX.Element
}


/**
 * #Button
 * 按钮用于开始一个即时操作。

##何时使用

标记了一个（或封装一组）操作命令，响应用户点击行为，触发相应的业务逻辑。
*/
declare export class Button mixins React.Component<Antd$ButtonProps, {}>{
    Group: typeof ButtonGroup;
    render(): JSX.Element
}

declare interface Antd$BreadcrumbItemProps {

    /**
     * 链接，如不传则不可点击   
     */
    href?: string
}

declare export class BreadcrumbItem mixins React.Component<Antd$BreadcrumbItemProps, {}>{
    render(): JSX.Element
}

declare interface Antd$BreadcrumbProps {

    /**
     * router 的路由栈信息 
     */
    routes?: Array<React.ReactNode>,

        /**
         * 路由的参数
         */
        params?: AV$Object,

        /**
         * 分隔符自定义
         */
        separator?: string | React.ReactNode
}


/**
 * #Breadcrumb
 * 显示当前页面在系统层级结构中的位置，并能向上返回。

##何时使用

-当系统拥有超过两级以上的层级结构时；
-当需要告知用户“你在哪里”时；
-当需要向上导航的功能时。
*/
declare export class Breadcrumb mixins React.Component<Antd$BreadcrumbProps, {}>{
    Item: typeof BreadcrumbItem;
    render(): JSX.Element
}

declare interface Antd$CalendarProps {

    /**
     * 自定义渲染月单元格
     */
    monthCellRender?: Function,

        /**
         * 自定义渲染日期单元格
         */
        dateCellRender?: Function,

        /**
         * 是否全屏显示
         */
        fullscreen?: boolean,

        /**
         * 国际化配置
         */
        locale?: AV$Object,
        prefixCls?: string,
        className?: string,
        style?: AV$Object,

        /**
         * 日期面板变化回调
         */
        onPanelChange?: Function,

        /**
         * 展示日期
         */
        value?: Date,

        /**
         * 默认展示日期
         */
        defaultValue?: Date,

        /**
         * 初始模式，`month/year`
         */
        mode?: string
}


/**
 * #Calendar
 * 按照日历形式展示数据的容器。

##何时使用

当数据是日期或按照日期划分时，例如日程、课表、价格日历等，农历等。目前支持年/月切换。
*/
declare export class Calendar mixins React.Component<Antd$CalendarProps, {}>{
    render(): JSX.Element
}

declare interface Antd$CarouselProps {

    /**
     * 动画效果函数，可取 scrollx, fade
     */
    effect?: string,

        /**
         * 是否显示面板指示点
         */
        dots?: boolean,

        /**
         * 垂直显示
         */
        vertical?: boolean,

        /**
         * 是否自动切换
         */
        autoplay?: boolean,

        /**
         * 动画效果
         */
        easing?: string,

        /**
         * 切换面板的回调
         */
        beforeChange?: Function,

        /**
         * 切换面板的回调
         */
        afterChange?: Function
}


/**
 * #Carousel
 * 旋转木马，一组轮播的区域。

##何时使用

-当有一组平级的内容。
-当内容空间不足时，可以用走马灯的形式进行收纳，进行轮播展现。
-常用于一组图片或卡片轮播。
*/
declare export class Carousel mixins React.Component<Antd$CarouselProps, {}>{
    render(): JSX.Element
}

declare interface Antd$CascaderProps {

    /**
     * 可选项数据源
     */
    options: AV$Object,

        /**
         * 默认的选中项
         */
        defaultValue?: Array<any>,

        /**
         * 指定选中项
         */
        value?: Array<any>,

        /**
         * 选择完成后的回调
         */
        onChange?: Function,

        /**
         * 选择后展示的渲染函数
         */
        displayRender?: Function,

        /**
         * 自定义样式
         */
        style?: AV$Object,

        /**
         * 自定义类名
         */
        className?: string,

        /**
         * 自定义浮层类名
         */
        popupClassName?: string,

        /**
         * 浮层预设位置：`bottomLeft` `bottomRight` `topLeft` `topRight` 
         */
        popupPlacement?: string,

        /**
         * 输入框占位文本
         */
        placeholder?: string,

        /**
         * 输入框大小，可选 `large` `default` `small` 
         */
        size?: string,

        /**
         * 禁用
         */
        disabled?: boolean,

        /**
         * 是否支持清除
         */
        allowClear?: boolean
}


/**
 * #Cascader
 * 级联选择框。


##何时使用

-需要从一组相关联的数据集合进行选择，例如省市区，公司层级，事物分类等。
-从一个较大的数据集合中进行选择时，用多级分类进行分隔，方便选择。
-比起 Select 组件，可以在同一个浮层中完成选择，有较好的体验。
*/
declare export class Cascader mixins React.Component<Antd$CascaderProps, {}>{
    render(): JSX.Element
}

declare interface Antd$CheckboxProps {

    /**
     * 指定当前是否选中
     */
    checked?: boolean,

        /**
         * 初始是否选中
         */
        defaultChecked?: boolean,

        /**
         * 变化时回调函数
         */
        onChange?: Function
}

declare interface Antd$CheckboxGroupProps {

    /**
     * 默认选中的选项
     */
    defaultValue?: Array<any>,

        /**
         * 指定选中的选项
         */
        value?: Array<any>,

        /**
         * 指定可选项
         */
        options?: Array<any>,

        /**
         * 变化时回调函数
         */
        onChange?: Function
}


/**
 * Checkbox 组
 */
declare class CheckboxGroup mixins React.Component<Antd$CheckboxGroupProps, {}>{
    render(): JSX.Element
}


/**
 * #Checkbox
 * 多选框。

##何时使用

-在一组可选项中进行多项选择时；
-单独使用可以表示两种状态之间的切换，和 `switch` 类似。区别在于切换 `switch` 会直接触发状态改变，而 `checkbox` 一般用于状态标记，需要和提交操作配合。
*/
declare export class Checkbox mixins React.Component<Antd$CheckboxProps, {}>{
    Group: typeof CheckboxGroup;
    render(): JSX.Element
}

declare interface Antd$CollapseProps {

    /**
     * 当前激活 tab 面板的 key
     */
    activeKey?: Array<any>| string,

        /**
         * 初始化选中面板的key 
         */
        defaultActiveKey?: Array<string>,

        /**
         * 切换面板的回调
         */
        onChange?: Function
}

declare class CollapsePanel mixins React.Component<{

    /**
     * 对应 activeKey 
     */
    key: string,

    /**
     * 面板头内容
     */
    header: React.ReactNode | string
}, {}>{
    render(): JSX.Element
}


/**
 * #Collapse
 * 可以折叠/展开的内容区域。

##何时使用

-对复杂区域进行分组和隐藏，保持页面的整洁。
-`手风琴` 是一种特殊的折叠面板，只允许单个内容区域展开。
*/
declare export class Collapse mixins React.Component<Antd$CollapseProps, {}>{
    Panel: typeof CollapsePanel;
    render(): JSX.Element
}

declare interface Antd$DatePickerProps<T>{
    value?: string | Date,
    defaultValue?: string | Date,

    /**
     * 展示的日期格式，配置参考 [GregorianCalendarFormat](https://github.com/yiminghe/gregorian-calendar-format)
     */
    format?: string,

    /**
     * 不可选择的日期
     */
    disabledDate?: Function,

    /**
     * 时间发生变化的回调，发生在用户选择时间时
     */
    onChange?: Function,

    /**
     * 禁用
     */
    disabled?: boolean,
    style?: AV$Object,

    /**
     * 格外的弹出日历样式
     */
    popupStyle?: AV$Object,

    /**
     * 输入框大小，`large` 高度为 32px，`small` 为 22px，默认是 28px
     */
    size?: string,

    /**
     * 国际化配置
     */
    locale?: AV$Object,

    /**
     * 增加时间选择功能
     */
    showTime?: boolean,

    /**
     * 点击确定按钮的回调
     */
    onOk?: Function,

    /**
     * 定义浮层的容器，默认为 body 上新建 div
     */
    getCalendarContainer?: Function
}

declare type Antd$RangePickProps = {} & Antd$DatePickerProps


declare class RangePicker mixins React.Component<Antd$RangePickProps, {}>{
    render(): JSX.Element
}

declare class MonthPicker mixins React.Component<Antd$RangePickProps, {}>{
    render(): JSX.Element
}


/**
 * #DatePicker
 * 输入或选择日期的控件。

##何时使用

当用户需要输入一个日期，可以点击标准输入框，弹出日期面板进行选择。
*/
declare export class DatePicker mixins React.Component<Antd$DatePickerProps<any>, {}>{
    RangePicker: typeof RangePicker;
    MonthPicker: typeof MonthPicker;
    render(): JSX.Element
}

declare interface Antd$DropdownProps {

    /**
     * 触发下拉的行为  ['click'] or ['hover']
     */
    trigger?: Array<string>,

        /**
         * 菜单节点
         */
        overlay: React.ReactNode
}

declare class DropdownButton mixins React.Component<{

    /**
     * 按钮类型
     */
    type?: string,

    /**
     * 点击左侧按钮的回调
     */
    onClick?: Function,

    /**
     * 触发下拉的行为
     */
    trigger?: string,

    /**
     * 菜单节点
     */
    overlay: React.ReactNode
}, {}>{
    render(): JSX.Element
}


/**
 * #Dropdown
 * 向下弹出的列表。

##何时使用

当页面上的操作命令过多时，用此组件可以收纳操作元素。点击或移入触点，会出现一个下拉菜单。可在列表中进行选择，并执行相应的命令。
*/
declare export class Dropdown mixins React.Component<Antd$DropdownProps, {}>{
    Button: typeof DropdownButton;
    render(): JSX.Element
}

declare interface Antd$FormItemProps {
    prefixCls?: string,

        /**
         * label 标签的文本
         */
        label?: React.ReactNode,

        /**
         * label 标签布局，通 `<Col>` 组件，设置 `span` `offset` 值，如 `{span: 3, offset: 12}`
         */
        labelCol?: AV$Object,

        /**
         * 提示信息，如不设置，则会根据校验规则自动生成 
         */
        help?: React.ReactNode | boolean,

        /**
         * 额外的提示信息，和 help 类似，当需要错误信息和提示文案同时出现时，可以使用这个。
         */
        extra?: string,

        /**
         * 是否必填，如不设置，则会根据校验规则自动生成 
         */
        validateStatus?: string,

        /**
         * 配合 validateStatus 属性使用，是否展示校验状态图标 
         */
        hasFeedback?: boolean,

        /**
         * 需要为输入控件设置布局样式时，使用该属性，用法同 labelCol
         */
        wrapperCol?: AV$Object,
        className?: string,
        required?: boolean,
        id?: string
}


/**
 * 表单一定会包含表单域，表单域可以是输入控件，标准表单域，标签，下拉菜单，文本域等。
 * 
这里我们分别封装了表单域 `<Form.Item />` 和输入控件 `<Input />`。
*/
declare export class FormItem mixins React.Component<Antd$FormItemProps, {}>{
    render(): JSX.Element
}

declare interface Antd$FormComponentProps {
    form: Antd$CreateFormOptions
}

declare export class FormComponent mixins React.Component<Antd$FormComponentProps, {}>{
    render(): JSX.Element
}

declare type Antd$CreateFormOptions = {

    /**
     * 获取一组输入控件的值，如不传入参数，则获取全部组件的值
     */
    getFieldsValue(): (fieldNames?: Array<string>) => any,

    /**
     * 获取一个输入控件的值
     */
    getFieldValue(): (fieldName: string) => any,

    /**
     * 设置一组输入控件的值
     */
    setFieldsValue(): (obj: AV$Object) => void,

    /**
     * 设置一组输入控件的值
     */
    setFields(): (obj: AV$Object) => void,

    /**
     * 校验并获取一组输入域的值与 Error
     */
    validateFields(): (
        fieldNames?: Array<string>,
        options?: AV$Object,
        callback?: (erros: any, values: any) => void) => any,

    /**
     * 与 `validateFields` 相似，但校验完后，如果校验不通过的菜单域不在可见范围内，则自动滚动进可见范围 
     */
    validateFieldsAndScroll(): (
        fieldNames?: Array<string>,
        options?: AV$Object,
        callback?: (erros: any, values: any) => void) => any,

    /**
     * 获取某个输入控件的 Error 
     */
    getFieldError(): (name: string) => AV$Object,

    /**
     * 判断一个输入控件是否在校验状态
     */
    isFieldValidating(): (name: string) => AV$Object,

    /**
     * 重置一组输入控件的值与状态，如不传入参数，则重置所有组件
     */
    resetFields(): (names?: Array<string>) => void,
    getFieldsValue(): (
        id: string,
        options: {

            /**
             * 子节点的值的属性，如 Checkbox 的是 'checked'
             */
            valuePropName?: string,

            /**
             * 子节点的初始值，类型、可选值均由子节点决定
             */
            initialValue?: any,

            /**
             * 收集子节点的值的时机
             */
            trigger?: string,

            /**
             * 校验子节点值的时机
             */
            validateTrigger?: string,

            /**
             * 校验规则，参见 [async-validator](https://github.com/yiminghe/async-validator) 
             */
            rules?: Array<any>,

            /**
             * 必填输入控件唯一标志
             */
            id?: string
        }) => Array<any >
};

declare interface Antd$ComponentDecorator {
    (component: T): T
}

declare interface Antd$FormProps {
    prefixCls?: string,

        /**
         * 水平排列布局
         */
        horizontal?: boolean,

        /**
         * 行内排列布局
         */
        inline?: boolean,

        /**
         * 经 `Form.create()` 包装过的组件会自带 `this.props.form` 属性，直接传给 Form 即可
         */
        form?: AV$Object,

        /**
         * 数据验证成功后回调事件
         */
        onSubmit?: (e: React.FormEvent) => void
}


/**
 * #Form
 * 具有数据收集、校验和提交功能的表单，包含复选框、单选框、输入框、下拉选择框等元素。

##表单

我们为 `form` 提供了以下两种排列方式：

-水平排列：可以实现 `label` 标签和表单控件的水平排列;
-行内排列：使其表现为 `inline-block` 级别的控件。
*/
declare export class Form mixins React.Component<Antd$FormProps, {}>{
    Item: typeof FormItem;
    create(
        options?: {

            /**
             * 当 `Form.Item` 子节点的值发生改变时触发，可以把对应的值转存到 Redux store
             */
            onFieldsChange?: (props: AV$Object, fields: Array<any>) => void,

            /**
             * 把 props 转为对应的值，可用于把 Redux store 中的值读出 
             */
            mapPropsToFields?: (props: AV$Object) => void
        }): Antd$ComponentDecorator;
    render(): JSX.Element
}

declare interface Antd$IconProps {

    /**
     * 图标类型
     */
    type: string
}


/**
 * #Icon
 * 有含义的矢量图形，每一个图标打倒一个敌人。

##图标的命名规范

我们为每个图标赋予了语义化的命名，命名规则如下:

-实心和描线图标保持同名，用 `-o` 来区分，比如 `question-circle`(实心) 和 `question-circle-o`(描线)；

-命名顺序：`[icon名]-[形状可选]-[描线与否]-[方向可选]`。

##如何使用

使用 `<Icon />` 标签声明组件，指定图标对应的 type 属性，示例代码如下:

```html
<Icon type="link" />
```

最终会渲染为：

```html
<i class="anticon anticon-${type}"></i>
```
*/
declare export class Icon mixins React.Component<Antd$IconProps, {}>{
    render(): JSX.Element
}

declare interface Antd$InputProps {

    /**
     * 【必须】声明 input 类型，同原生 input 标签的 type 属性
     */
    type?: string,
        id: string | number,

        /**
         * 控件大小，默认值为 default 。注：标准表单内的输入框大小限制为 large。 {'large','default','small'}
         */
        size?: string,

        /**
         * 是否禁用状态，默认为 false
         */
        disabled?: boolean,
        value?: any,

        /**
         * 设置初始默认值
         */
        defaultValue?: any,
        className?: string,

        /**
         * 带标签的 input，设置前置标签
         */
        addonBefore?: React.ReactNode,

        /**
         * 带标签的 input，设置后置标签
         */
        addonAfter?: React.ReactNode,
        prefixCls?: string,
        placeholder?: string
}

declare export class Input mixins React.Component<Antd$InputProps, {}>{
    render(): JSX.Element
}

declare interface Antd$InputNumberProps {

    /**
     * 最小值
     */
    min: number,

        /**
         * 最大值
         */
        max: number,

        /**
         * 当前值
         */
        value?: number,

        /**
         * 每次改变步数
         */
        step?: number,

        /**
         * 初始值
         */
        defaultValue?: number,

        /**
         * 变化回调
         */
        onChange?: Function,

        /**
         * 禁用
         */
        disabled?: boolean,

        /**
         * 输入框大小
         */
        size?: string
}


/**
 * #InputNumber
 * 通过鼠标或键盘，输入范围内的数值。

##何时使用

当需要获取标准数值时。
*/
declare export class InputNumber mixins React.Component<Antd$InputNumberProps, {}>{
    render(): JSX.Element
}

declare interface Antd$RowProps {
    type?: string,
        align?: string,
        justify?: string,
        className?: string
}

declare export class Row mixins React.Component<Antd$RowProps, {}>{
    render(): JSX.Element
}

declare interface Antd$ColProps {
    span?: string,
        order?: string,
        offset?: string,
        push?: string,
        pull?: string,
        className?: string
}


/**
 * 在多数业务情况下，Ant Design需要在设计区域内解决大量信息收纳的问题，因此在12栅格系统的基础上，我们将整个设计建议区域按照24等分的原则进行划分。
 * 
划分之后的信息区块我们称之为“盒子”。建议横向排列的盒子数量最多四个，最少一个。“盒子”在整个屏幕上占比见上图。设计部分基于盒子的单位定制盒子内部的排版规则，以保证视觉层面的舒适感。

## 概述

布局的栅格化系统，我们是基于行（row）和列（col）来定义信息区块的外部框架，以保证页面的每个区域能够稳健地排布起来。下面简单介绍一下它的工作原理：

 通过`row`在水平方向建立一组`column`（简写col）
 你的内容应当放置于`col`内，并且，只有`col`可以作为`row`的直接元素
 栅格系统中的列是指1到24的值来表示其跨越的范围。例如，三个等宽的列可以使用`.col-8`来创建
 如果一个`row`中的`col`总和超过24，那么多余的`col`会作为一个整体另起一行排列

## Flex 布局

我们的栅格化系统支持 Flex 布局，允许子元素在父节点内的水平对齐方式 - 居左、居中、居右、等宽排列、分散排列。子元素与子元素之间，支持顶部对齐、垂直居中对齐、底部对齐的方式。同时，支持使用 order 来定义元素的排列顺序。

Flex 布局是基于 24 栅格来定义每一个“盒子”的宽度，但排版则不拘泥于栅格。
*/
declare export class Col mixins React.Component<Antd$ColProps, {}>{
    render(): JSX.Element
}

declare interface Antd$MenuItemProps {

    /**
     * (是否禁用)
     * @type  
     */
    disabled?: boolean,
        key: string
}

declare export class MenuItem mixins React.Component<Antd$MenuItemProps, {}>{
    render(): JSX.Element
}

declare interface Antd$MenuSubMenuProps {

    /**
     * (子菜单项值)
     * @type  
     */
    title: string | React.ReactNode,

        /**
         * (子菜单的菜单项)
         * @type  
         */
        children?: JSX.Element[]
}

declare export class MenuSubMenu mixins React.Component<Antd$MenuSubMenuProps, {}>{
    render(): JSX.Element
}

declare interface Antd$MenuItemGroupProps {

    /**
     * (分组标题)
     * @type  
     */
    title: string | React.ReactNode,

        /**
         * (分组的菜单项)
         * @type  
         */
        children?: JSX.Element[]
}

declare export class MenuItemGroup mixins React.Component<Antd$MenuItemGroupProps, {}>{
    render(): JSX.Element
}

declare interface Antd$MenuProps {

    /**
     * 主题颜色
     */
    theme?: MenuTheme | string,

        /**
         * 菜单类型  enum: `vertical` `horizontal` `inline`
         */
        mode?: MenuMode | string,

        /**
         * 当前选中的菜单项 key 数组
         */
        selectedKeys?: Array<string>,

        /**
         * 初始选中的菜单项 key 数组
         */
        defaultSelectedKeys?: Array<string>,

        /**
         * 当前展开的菜单项 key 数组
         */
        openKeys?: Array<string>,

        /**
         * 初始展开的菜单项 key 数组
         */
        defaultOpenKeys?: Array<string>,

        /**
         * 被选中时调用
         * @type  : any, key: string, selectedKeys: Array<string>) => void}
         */
        onSelect?: (item: any, key: string, selectedKeys: Array<string>) => void,

        /**
         * 取消选中时调用
         */
        onDeselect?: (item: any, key: string, selectedKeys: Array<string>) => void,

        /**
         * 点击 menuitem 调用此函数
         */
        onClick?: (item: any, key: string) => void,

        /**
         * 根节点样式
         */
        style?: AV$Object
}


/**
 * # Menu
 * 为页面和功能提供导航的菜单列表。

## 何时使用

导航菜单是一个网站的灵魂，用户依赖导航在各个页面中进行跳转。一般分为顶部导航和侧边导航，顶部导航提供全局性的类目和功能，侧边导航提供多级结构来收纳和排列网站架构。

更多布局和导航的范例可以参考：[常用布局](/spec/layout)。
*/
declare export class Menu mixins React.Component<Antd$MenuProps, {}>{
    Item: typeof MenuItem;
    SubMenu: typeof MenuSubMenu;
    ItemGroup: typeof MenuItemGroup;
    Divider: typeof undefined;
    render(): JSX.Element
}

declare type Antd$MessageFunc = (content: string, duration?: number) => void;

declare export var message: {
    success: Antd$MessageFunc,
    error: Antd$MessageFunc,
    info: Antd$MessageFunc,
    loading: Antd$MessageFunc,
    config: (options: {

        /**
         * 消息距离顶部的位置
         * @type  
         */
        top: number
    }) => void,
    destroy: () => void
};

declare type Antd$ModalFunc = (
    options: {
        visible?: boolean,
        title?: React.ReactNode | string,
        onOk?: Function,
        onCancel?: Function,
        width?: string | number,
        iconClassName?: string,
        okText?: string,
        cancelText?: string
    }) => void;

declare interface Antd$ModalProps {

    /**
     * 对话框是否可见
     */
    visible?: boolean,

        /**
         * 确定按钮 loading
         */
        confirmLoading?: boolean,

        /**
         * 标题
         */
        title?: React.ReactNode | string,

        /**
         * 是否显示右上角的关闭按钮
         */
        closable?: boolean,

        /**
         * 点击确定回调
         */
        onOk?: Function,

        /**
         * 点击遮罩层或右上角叉或取消按钮的回调
         */
        onCancel?: Function,

        /**
         * 宽度
         */
        width?: string | number,

        /**
         * 底部内容
         */
        footer?: React.ReactNode | string,

        /**
         * 确认按钮文字
         */
        okText?: string,

        /**
         * 取消按钮文字
         */
        cancelText?: string,

        /**
         * 点击蒙层是否允许关闭
         */
        maskClosable?: boolean
}


/**
 * # Modal
 * 模态对话框。

## 何时使用

需要用户处理事务，又不希望跳转页面以致打断工作流程时，可以使用 `Modal` 在当前页面正中打开一个浮层，承载相应的操作。

另外当需要一个简洁的确认框询问用户时，可以使用精心封装好的 `ant.Modal.confirm()` 等方法。
*/
declare export class Modal mixins React.Component<Antd$ModalProps, {}>{
    info: Antd$ModalFunc;
    success: Antd$ModalFunc;
    error: Antd$ModalFunc;
    confirm: Antd$ModalFunc;
    render(): JSX.Element
}

declare type Antd$NotificationFunc = (
    config: {

        /**
         * 通知提醒标题，必选 
         */
        message: React.ReactNode | string,

        /**
         * 通知提醒内容，必选
         */
        description: React.ReactNode | string,

        /**
         * 自定义关闭按钮
         */
        btn?: React.ReactNode | string,

        /**
         * 当前通知唯一标志
         */
        key?: string,

        /**
         * 点击默认关闭按钮时触发的回调函数
         */
        onClose?: Function,

        /**
         * 默认 4.5 秒后自动关闭，配置为 null 则不自动关闭
         */
        duration?: number
    }) => void;

declare export var notification: {
    success: Antd$NotificationFunc,
    error: Antd$NotificationFunc,
    info: Antd$NotificationFunc,
    warn: Antd$NotificationFunc,
    close: (key: string) => void,
    destroy: () => void,
    config: (options: {

        /**
         * 消息距离顶部的位置
         */
        top: number
    }) => void
};

declare interface Antd$PaginationProps {

    /**
     * 当前页数
     */
    current?: number,

        /**
         * 默认的当前页数
         */
        defaultCurrent?: number,

        /**
         * 数据总数
         */
        total: number,

        /**
         * 初始的每页条数
         */
        defaultPageSize?: number,

        /**
         * 每页条数
         */
        pageSize?: number,

        /**
         * 页码改变的回调，参数是改变后的页码
         */
        onChange?: Function,

        /**
         * 是否可以改变 pageSize 
         */
        showSizeChanger?: boolean,

        /**
         * 指定每页可以显示多少条
         */
        pageSizeOptions?: Array<number>,

        /**
         * pageSize 变化的回调  
         */
        onShowSizeChange?: Function,

        /**
         * 是否可以快速跳转至某页
         */
        showQuickJumper?: boolean,

        /**
         * 当为「small」时，是小尺寸分页 
         */
        size?: string,

        /**
         * 当添加该属性时，显示为简单分页
         */
        simple?: AV$Object,

        /**
         * 用于显示总共有多少条数据
         */
        showTotal?: Function
}


/**
 * #Pagination
 * 采用分页的形式分隔长列表，每次只加载一个页面。

##何时使用

-当加载/渲染所有数据将花费很多时间时；
-可切换页码浏览数据。
*/
declare export class Pagination mixins React.Component<Antd$PaginationProps, {}>{
    render(): JSX.Element
}

declare interface Antd$PopconfirmProps {

    /**
     * 气泡框位置，可选 `top/left/right/bottom`
     * @type  
     */
    placement?: Placement | string,

        /**
         * 确认框的描述
         */
        title?: string,

        /**
         * 点击确认的回调
         */
        onConfirm?: Function,
        onCancel?: Function,

        /**
         * 显示隐藏的回调
         */
        onVisibleChange?: (visible: boolean) => void,

        /**
         * 确认按钮文字
         */
        okText?: string,

        /**
         * 取消按钮文字
         */
        cancelText?: string
}


/**
 * #Popconfirm
 * 点击元素，弹出气泡式的确认框。

##何时使用

目标元素的操作需要用户进一步的确认时，在目标元素附近弹出浮层提示，询问用户。

和`confirm` 弹出的全屏居中模态对话框相比，交互形式更轻量。
*/
declare export class Popconfirm mixins React.Component<Antd$PopconfirmProps, {}>{
    render(): JSX.Element
}

declare interface Antd$PopoverProps {

    /**
     * 触发行为，可选 `hover/focus/click` 
     */
    trigger?: Trigger | string,

        /**
         * 气泡框位置，可选 `top/left/right/bottom` `topLeft/topRight/bottomLeft/bottomRight` `leftTop/leftBottom/rightTop/rightBottom`
         */
        placement?: PopoverPlacement | string,

        /**
         * 卡片标题
         */
        title?: React.ReactNode | string,

        /**
         * 卡片内容
         */
        overlay?: React.ReactNode | string,
        prefixCls?: string,

        /**
         * 用于手动控制浮层显隐
         */
        visible?: boolean,

        /**
         * 显示隐藏改变的回调
         */
        onVisibleChange?: Function
}


/**
 * #Popover
 * 点击/鼠标移入元素，弹出气泡式的卡片浮层。

##何时使用

当目标元素有进一步的描述和相关操作时，可以收纳到卡片中，根据用户的操作行为进行展现。

和`Tooltip` 的区别是，用户可以对浮层上的元素进行操作，因此它可以承载更复杂的内容，比如链接或按钮等。
*/
declare export class Popover mixins React.Component<Antd$PopoverProps, {}>{
    render(): JSX.Element
}

declare interface Antd$LineProps {

    /**
     * 百分比
     */
    percent: number,

        /**
         * 内容的模板函数
         */
        format?: (percent: any) => void,

        /**
         * 状态，可选：normal、exception、active
         */
        status?: ProgressStatus | string,

        /**
         * 进度条线的宽度，单位是px
         */
        strokeWidth?: number,

        /**
         * 是否显示进度数值和状态图标
         */
        showInfo?: boolean
}

declare export class Line mixins React.Component<Antd$LineProps, {}>{
    render(): JSX.Element
}

declare interface Antd$CircleProps {

    /**
     * 百分比
     */
    percent: number,

        /**
         * 内容的模板函数
         */
        format?: (percent: any) => void,

        /**
         * 状态，可选：normal、exception
         */
        status?: ProgressStatus | string,

        /**
         * 进度条线的宽度，单位是进度条画布宽度的百分比
         */
        strokeWidth?: number,

        /**
         * 必填，进度条画布宽度，单位px。这里没有提供height属性设置，Line型高度就是strokeWidth，Circle型高度等于width
         */
        width?: number
}

declare export class Circle mixins React.Component<Antd$CircleProps, {}>{
    render(): JSX.Element
}

declare export var Progress: {
    Line: typeof Line,
    Circle: typeof Circle
};

declare interface Antd$QueueAnimProps {

    /**
     * 动画内置参数 `left` `right` `top` `bottom` `scale` `scaleBig` `scaleX` `scaleY`
     */
    type?: string | Array<string>,

        /**
         * 配置动画参数 如 `{opacity:[1, 0],translateY:[0, -30]}` 具体参考 [velocity](http://julian.com/research/velocity) 的写法
         */
        animConfig?: AV$Object | Array<any>,

        /**
         * 整个动画的延时,以毫秒为单位
         */
        delay?: number | Array<any>,

        /**
         * 每个动画的时间,以毫秒为单位
         */
        duration?: number | Array<any>,

        /**
         * 每个动画的间隔时间,以毫秒为单位
         */
        interval?: number | Array<any>,

        /**
         * 出场时是否倒放,从最后一个 dom 开始往上播放 
         */
        leaveReverse?: boolean,

        /**
         * 动画的缓动函数,[查看详细](http://julian.com/research/velocity/#easing)
         */
        ease?: string | Array<any>,

        /**
         * 进出场动画进行中的类名
         */
        animatingClassName?: Array<string>,

        /**
         * QueueAnim 替换的标签名
         */
        component?: string
}


/**
 * #QueueAnim
 * 通过简单的配置对一组元素添加串行的进场动画效果。

##何时使用

-从内容A到内容B的转变过程时能有效的吸引用户注意力，突出视觉中心，提高整体视觉效果。

-小的信息元素排布或块状较多的情况下，根据一定的路径层次依次进场，区分维度层级，来凸显量级，使页面转场更加流畅和舒适，提高整体视觉效果和产品的质感。

-特别适合首页和需要视觉展示效果的宣传页，以及单页应用的切换页面动效。
*/
declare export class QueueAnim mixins React.Component<Antd$QueueAnimProps, {}>{
    render(): JSX.Element
}

declare interface Antd$RadioGroupProps {

    /**
     * 选项变化时的回调函数
     */
    onChange?: (e: autobahn$Event) => void,

        /**
         * 用于设置当前选中的值
         */
        value?: string,

        /**
         * 默认选中的值
         */
        defaultValue?: string,

        /**
         * 大小，只对按钮样式生效
         */
        size?: RadioGroupSize | string
}

declare export class RadioGroup mixins React.Component<Antd$RadioGroupProps, {}>{
    render(): JSX.Element
}

declare interface Antd$RadioProps {

    /**
     * 指定当前是否选中
     */
    checked?: boolean,

        /**
         * 初始是否选中
         */
        defaultChecked?: boolean,

        /**
         * 根据 value 进行比较，判断是否选中  
         */
        value?: any
}


/**
 * #Radio
 * 单选框。

##何时使用

-用于在多个备选项中选中单个状态。
-和 Select 的区别是，Radio 所有选项默认可见，方便用户在比较中选择，因此选项不宜过多。
*/
declare export class Radio mixins React.Component<Antd$RadioProps, {}>{
    Group: typeof RadioGroup;
    Button: typeof Button;
    render(): JSX.Element
}

declare interface Antd$SelectOptionProps {

    /**
     * 是否禁用
     */
    disabled?: boolean,

        /**
         * 如果 react 需要你设置此项，此项值与 value 的值相同，然后可以省略 value 设置
         */
        key?: string,

        /**
         * 默认根据此属性值进行筛选
         */
        value: string
}

declare export class SelectOption mixins React.Component<Antd$SelectOptionProps, {}>{
    render(): JSX.Element
}

declare interface Antd$SelectOptGroupProps {

    /**
     * 组名
     */
    label: string | React.ReactNode,
        key?: string
}

declare export class SelectOptGroup mixins React.Component<Antd$SelectOptGroupProps, {}>{
    render(): JSX.Element
}

declare interface Antd$SelectProps {

    /**
     * 指定当前选中的条目
     */
    value?: string | Array<any>,

        /**
         * 指定默认选中的条目
         */
        defaultValue?: string | Array<any>,

        /**
         * 支持多选
         */
        multiple?: boolean,

        /**
         * 支持清除, 单选模式有效
         */
        allowClear?: boolean,

        /**
         * 是否根据输入项进行筛选，可为一个函数，返回满足要求的 option 即可
         */
        filterOption?: boolean | Function,

        /**
         * 可以把随意输入的条目作为 tag，输入项不需要与下拉选项匹配
         */
        tags?: boolean,

        /**
         * 被选中时调用，参数为选中项的 value 值 
         */
        onSelect?: (value: any, option: any) => void,

        /**
         * 取消选中时调用，参数为选中项的 option value 值，仅在 multiple 或 tags 模式下生效
         */
        onDeselect?: (value: any, option: any) => void,

        /**
         * 选中option，或input的value变化(combobox 模式下)时，调用此函数
         */
        onChange?: (value: any, label: any) => void,

        /**
         * 文本框值变化时回调
         */
        onSearch?: (value: string) => void,

        /**
         * 选择框默认文字
         */
        placeholder?: string,

        /**
         * 搜索框默认文字
         */
        searchPlaceholder?: string,

        /**
         * 当下拉列表为空时显示的内容
         */
        notFoundContent?: string,

        /**
         * 下拉菜单和选择器同宽
         */
        dropdownMatchSelectWidth?: boolean,

        /**
         * 搜索时过滤对应的 option 属性，如设置为 children 表示对内嵌内容进行搜索
         */
        optionFilterProp?: string,

        /**
         * 输入框自动提示模式
         */
        combobox?: SVGSymbolElement,

        /**
         * 选择框大小，可选 `large` `small` 
         */
        size?: string,

        /**
         * 在下拉中显示搜索框
         */
        showSearch?: boolean,

        /**
         * 是否禁用
         */
        disabled?: boolean,
        style?: AV$Object
}


/**
 * #Select
 * 类似 Select2 的选择器。

##何时使用

弹出一个下拉菜单给用户选择操作，用于代替原生的选择器，或者需要一个更优雅的多选器时。
*/
declare export class Select mixins React.Component<Antd$SelectProps, {}>{
    Option: typeof SelectOption;
    OptGroup: typeof SelectOptGroup;
    render(): JSX.Element
}

declare interface Antd$SliderProps {

    /**
     * 最小值
     */
    min?: number,

        /**
         * 最大值
         */
        max?: number,

        /**
         * 步长，取值必须大于 0，并且可被 (max - min) 整除。当 `marks` 不为空对象时，可以设置 `step` 为 `null`，此时 Slider 的可选值仅有 marks 标出来的部分。
         */
        step?: number,

        /**
         * 分段标记，key 的类型必须为 `Number` 且取值在闭区间 [min, max] 内
         */
        marks?: {
            key: number,
            value: any
        },

        /**
         * 设置当前取值。当 `range` 为 `false` 时，使用 `Number`，否则用 `[Number, Number]`
         */
        value?: number | Array<number>,

        /**
         * 设置当前取值。当 `range` 为 `false` 时，使用 `Number`，否则用 `[Number, Number]`
         */
        defaultValue?: number | Array<number>,

        /**
         * `marks` 不为空对象时有效，值为 true 时表示值为包含关系，false 表示并列
         */
        included?: boolean,

        /**
         * 值为 `true` 时，滑块为禁用状态
         */
        disabled?: boolean,

        /**
         * 当 `range` 为 `true` 时，该属性可以设置是否允许两个滑块交换位置。
         */
        allowCross?: boolean,

        /**
         * 当 Slider 的值发生改变时，会触发 onChange 事件，并把改变后的值作为参数传入。
         */
        onChange?: Function,

        /**
         * 与 `onmouseup` 触发时机一致，把当前值作为参数传入。
         */
        onAfterChange?: Function,

        /**
         * Slider 会把当前值传给 `tipFormatter`，并在 Tooltip 中显示 `tipFormatter` 的返回值，若为 null，则隐藏 Tooltip。
         */
        tipFormatter?: Function | any,
        range?: boolean
}


/**
 * #Slider
 * 滑动型输入器，展示当前值和可选范围。

##何时使用

当用户需要在数值区间/自定义区间内进行选择时，可为连续或离散值。
*/
declare export class Slider mixins React.Component<Antd$SliderProps, {}>{
    render(): JSX.Element
}

declare interface Antd$SpinProps {

    /**
     * spin组件中点的大小，可选值为 small default large
     */
    size?: string,

        /**
         * 用于内嵌其他组件的模式，可以关闭 loading 效果
         */
        spining?: boolean
}


/**
 * #Spin
 * 用于页面和区块的加载中状态。

##何时使用

页面局部处于等待异步数据或正在渲染过程时，合适的加载动效会有效缓解用户的焦虑。
*/
declare export class Spin mixins React.Component<Antd$SpinProps, {}>{
    render(): JSX.Element
}

declare interface Antd$StepProps {

    /**
     * 可选参数，指定状态。当不配置该属性时，会使用父Steps元素的current来自动指定状态。
     */
    status?: StepStatus | string,

        /**
         * 必要参数，标题。
         */
        title: string | React.ReactNode,

        /**
         * 可选参数，步骤的详情描述。
         */
        description?: string | React.ReactNode,

        /**
         * 可选参数，步骤的Icon。如果不指定，则使用默认的样式。
         */
        icon?: string | React.ReactNode
}

declare export class Step mixins React.Component<Antd$StepProps, {}>{
    render(): JSX.Element
}

declare interface Antd$StepsProps {

    /**
     * 可选参数，指定当前处理正在执行状态的步骤，从0开始记数。在子Step元素中，可以通过status属性覆盖状态。
     */
    current?: number,

        /**
         * 可选参数，指定大小（目前只支持普通和迷你两种大小）。 small, default 
         */
        size?: string,

        /**
         * 可选参数，指定步骤条方向（目前支持水平和竖直两种方向，默认水平方向）。
         */
        direction?: string,

        /**
         * 可选参数，指定步骤的详细描述文字的最大宽度。
         */
        maxDescriptionWidth?: number
}


/**
 * #Steps
 * 引导用户按照流程完成任务的导航条。

##何时使用

当任务复杂或者存在先后关系时，将其分解成一系列步骤，从而简化任务。
*/
declare export class Steps mixins React.Component<Antd$StepsProps, {}>{
    Step: typeof Step;
    render(): JSX.Element
}

declare interface Antd$SwitchProps {

    /**
     * 指定当前是否选中
     */
    checked?: boolean,

        /**
         * 初始是否选中
         */
        defaultChecked?: boolean,

        /**
         * 变化时回调函数
         */
        onChange?: (checked: boolean) => void,

        /**
         * 选中时的内容
         */
        checkedChildren?: React.ReactNode,

        /**
         * 非选中时的内容
         */
        unCheckedChildren?: React.ReactNode,

        /**
         * 开关大小
         */
        size?: string
}


/**
 * #Switch
 * 开关选择器。

##何时使用

-需要表示开关状态/两种状态之间的切换时；
-和 `checkbox `的区别是，切换 `switch` 会直接触发状态改变，而 `checkbox` 一般用于状态标记，需要和提交操作配合。
*/
declare export class Switch mixins React.Component<Antd$SwitchProps, {}>{
    render(): JSX.Element
}

declare type Antd$SelectedRowKeys = Array<any>;

declare interface Antd$RowSelection {
    type?: RowSelectionType | string,
        selectedRowKeys?: Antd$SelectedRowKeys,
        onChange?: (selectedRowKeys: Antd$SelectedRowKeys, selectedRows: any) => void,
        getCheckboxProps?: (record: any) => void,
        onSelect?: (record: any, selected: any, selectedRows: any) => void,
        onSelectAll?: (rselectedecord: any, selectedRows: any, changeRows: any) => void
}

declare interface Antd$Columns {

    /**
     * React 需要的 key，建议设置
     */
    key?: string,

        /**
         * 列头显示文字
         */
        title?: string | React.ReactNode,

        /**
         * 列数据在数据项中对应的 key
         */
        dataIndex?: string,

        /**
         * 生成复杂数据的渲染函数，参数分别为当前列的值，当前列数据，列索引，@return里面可以设置表格[行/列合并](#demo-colspan-rowspan)
         */
        render?: (text?: any, record?: any, index?: number) => React.ReactNode,

        /**
         * 表头的筛选菜单项
         */
        filters?: Array<any>,

        /**
         * 本地模式下，确定筛选的运行函数
         */
        onFilter?: Function,

        /**
         * 是否多选
         */
        filterMultiple?: boolean,

        /**
         * 排序函数，本地排序使用一个函数，需要服务端排序可设为 true 
         */
        sorter?: boolean | Function,

        /**
         * 表头列合并,设置为 0 时，不渲染
         */
        colSpan?: number,

        /**
         * 列宽度
         */
        width?: string | number,

        /**
         * 列的 className
         */
        className?: string
}

declare interface Antd$TableProps {

    /**
     * 列表项是否可选择
     */
    rowSelection?: Antd$RowSelection,

        /**
         * 分页器
         */
        pagination?: AV$Object,

        /**
         * 正常或迷你类型 : `default` or `small` 
         */
        size?: string,

        /**
         * 数据数组
         */
        dataSource: Array<any>,

        /**
         * 表格列的配置描述
         */
        columns: Antd$Columns,

        /**
         * 表格行 key 的取值
         */
        rowKey?: (record: any, index: number) => string,

        /**
         * 额外的展开行
         */
        expandedRowRender?: Function,

        /**
         * 默认展开的行
         */
        defaultExpandedRowKeys?: Array<string>,

        /**
         * 分页、排序、筛选变化时触发
         */
        onChange?: (pagination: AV$Object, filters: any, sorter: any) => void,

        /**
         * 页面是否加载中
         */
        loading?: boolean,

        /**
         * 默认文案设置，目前包括排序、过滤、空数据文案: `{ filterConfirm: '确定', filterReset: '重置', emptyText: '暂无数据' }` 
         */
        locale?: AV$Object,

        /**
         * 展示树形数据时，每层缩进的宽度，以 px 为单位
         */
        indentSize?: number,

        /**
         * 处理行点击事件
         */
        onRowClick?: (record: any, index: number) => void,

        /**
         * 是否固定表头
         */
        useFixedHeader?: boolean,

        /**
         * 是否展示外边框和列边框
         */
        bordered?: boolean,

        /**
         * 是否显示表头
         */
        showHeader?: boolean,

        /**
         * 表格底部自定义渲染函数
         */
        footer?: (currentPageData: AV$Object) => void
}


/**
 * #Table
 * 展示行列数据。

##何时使用

-当有大量结构化的数据需要展现时；
-当需要对数据进行排序、搜索、分页、自定义操作等复杂行为时。
*/
declare export class Table mixins React.Component<Antd$TableProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TabPaneProps {

    /**
     * 选项卡头显示文字
     */
    tab: React.ReactNode | string
}

declare export class TabPane mixins React.Component<Antd$TabPaneProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TabsProps {

    /**
     * 当前激活 tab 面板的 key    
     */
    activeKey?: string,

        /**
         * 初始化选中面板的 key，如果没有设置 activeKey
         */
        defaultActiveKey?: string,

        /**
         * 切换面板的回调
         */
        onChange?: Function,

        /**
         * tab 被点击的回调 
         */
        onTabClick?: Function,

        /**
         * tab bar 上额外的元素  
         */
        tabBarExtraContent?: React.ReactNode,

        /**
         * 页签的基本样式，可选 `line`、`card` `editable-card` 类型
         */
        type?: TabsType | string,

        /**
         * 页签位置，可选值有 `top` `right` `bottom` `left`
         */
        tabPosition?: TabsPosition | string,

        /**
         * 新增和删除页签的回调，在 `type="editable-card"` 时有效
         */
        onEdit?: (targetKey: string, action: any) => void
}


/**
 * #Tabs
 * 选项卡切换组件。

##何时使用

提供平级的区域将大块内容进行收纳和展现，保持界面整洁。

Ant Design 依次提供了三级选项卡，分别用于不同的场景。

-卡片式的页签，提供可关闭的样式，常用于容器顶部。
-标准线条式页签，用于容器内部的主功能切换，这是最常用的 Tabs。
-[RadioButton](/components/radio/#demo-radiobutton) 可作为更次级的页签来使用。
*/
declare export class Tabs mixins React.Component<Antd$TabsProps, {}>{
    TabPane: typeof TabPane;
    render(): JSX.Element
}

declare interface Antd$TagProps {

    /**
     * 标签是否可以关闭
     */
    closable?: boolean,

        /**
         * 关闭时的回调
         */
        onClose?: Function,

        /**
         * 动画关闭后的回调
         */
        afterClose?: Function,

        /**
         * 标签的色彩
         */
        color?: string
}


/**
 * #Tag
 * 进行标记和分类的小标签。

##何时使用

-用于标记事物的属性和维度。
-进行分类。
*/
declare export class Tag mixins React.Component<Antd$TagProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TimePickerProps {

    /**
     * 默认时间
     */
    value?: string | Date,

        /**
         * 初始默认时间
         */
        defaultValue?: string | Date,

        /**
         * 展示的时间格式 : "HH:mm:ss"、"HH:mm"、"mm:ss" 
         */
        format?: string,

        /**
         * 时间发生变化的回调
         */
        onChange?: (Date: Date) => void,

        /**
         * 禁用全部操作
         */
        disabled?: boolean,

        /**
         * 没有值的时候显示的内容
         */
        placeholder?: string,

        /**
         * 国际化配置
         */
        locale?: AV$Object,

        /**
         * 隐藏禁止选择的选项
         */
        hideDisabledOptions?: boolean,

        /**
         * 禁止选择部分小时选项
         */
        disabledHours?: Function,

        /**
         * 禁止选择部分分钟选项
         */
        disabledMinutes?: Function,

        /**
         * 禁止选择部分秒选项
         */
        disabledSeconds?: Function
}


/**
 * #TimePicker
 * 输入或选择时间的控件。

何时使用
--------

当用户需要输入一个时间，可以点击标准输入框，弹出时间面板进行选择。
*/
declare export class TimePicker mixins React.Component<Antd$TimePickerProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TimeLineItemProps {

    /**
     * 指定圆圈颜色。
     */
    color?: string
}

declare export class TimeLineItem mixins React.Component<Antd$TimeLineItemProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TimelineProps {

    /**
     * 指定最后一个幽灵节点是否存在或内容
     */
    pending?: boolean | React.ReactNode
}


/**
 * #Timeline
 * 垂直展示的时间流信息。

##何时使用

-当有一系列信息需要从上至下按时间排列时；
-需要有一条时间轴进行视觉上的串联时；
*/
declare export class Timeline mixins React.Component<Antd$TimelineProps, {}>{
    Item: typeof TimeLineItem;
    render(): JSX.Element
}

declare interface Antd$TooltipProps {

    /**
     * 气泡框位置，可选 `top` `left` `right` `bottom` `topLeft` `topRight` `bottomLeft` `bottomRight` `leftTop` `leftBottom` `rightTop` `rightBottom`
     */
    placement?: PopoverPlacement | string,

        /**
         * 提示文字
         */
        title?: string | React.ReactNode
}


/**
 * #Tooltip
 * 简单的文字提示气泡框。

##何时使用

鼠标移入则显示提示，移出消失，气泡浮层不承载复杂文本和操作。

可用来代替系统默认的 `title` 提示，提供一个`按钮/文字/操作`的文案解释。
*/
declare export class Tooltip mixins React.Component<Antd$TooltipProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TransferProps {

    /**
     * 数据源
     */
    dataSource: Array<any>,

        /**
         * 每行数据渲染函数
         */
        render?: (record: AV$Object) => any,

        /**
         * 显示在右侧框数据的key集合
         */
        targetKeys: Array<string>,

        /**
         * 变化时回调函数
         */
        onChange?: (targetKeys: any, direction: string, moveKeys: any) => void,

        /**
         * 两个穿梭框的自定义样式
         */
        listStyle?: AV$Object,

        /**
         * 自定义类
         */
        className?: string,

        /**
         * 标题集合,顺序从左至右
         */
        titles?: Array<string>,

        /**
         * 操作文案集合,顺序从上至下
         */
        operations?: Array<string>,

        /**
         * 是否显示搜索框
         */
        showSearch?: boolean,

        /**
         * 搜索框的默认值
         */
        searchPlaceholder?: string,

        /**
         * 当列表为空时显示的内容
         */
        notFoundContent?: React.ReactNode | string,

        /**
         * 底部渲染函数
         */
        footer?: (props: any) => any
}


/**
 * #Transfer
 * 双栏穿梭选择框。

##何时使用

用直观的方式在两栏中移动元素，完成选择行为。
*/
declare export class Transfer mixins React.Component<Antd$TransferProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TreeNodeProps {
    disabled?: boolean,
        disableCheckbox?: boolean,
        title?: string | React.ReactNode,
        key?: string,
        isLeaf?: boolean
}

declare export class TreeNode mixins React.Component<Antd$TreeNodeProps, {}>{
    render(): JSX.Element
}

declare interface Antd$TreeProps {
    showLine?: boolean,
        className?: string,

        /**
         * 是否支持多选
         */
        multiple?: boolean,

        /**
         * 是否支持选中
         */
        checkable?: boolean,

        /**
         * 默认展开所有树节点
         */
        defaultExpandAll?: boolean,

        /**
         * 默认展开指定的树节点
         */
        defaultExpandedKeys?: Array<string>,

        /**
         * （受控）展开指定的树节点
         */
        expandedKeys?: Array<string>,

        /**
         * （受控）选中复选框的树节点
         */
        checkedKeys?: Array<string>,

        /**
         * 默认选中复选框的树节点
         */
        defaultCheckedKeys?: Array<string>,

        /**
         * （受控）设置选中的树节点
         */
        selectedKeys?: Array<string>,

        /**
         * 默认选中的树节点
         */
        defaultSelectedKeys?: Array<string>,

        /**
         * 展开/收起节点时触发 
         */
        onExpand?: (node: any, expanded: any, expandedKeys: any) => void,

        /**
         * 点击复选框触发
         */
        onCheck?: (
            checkedKeys: any,
            e: {
                checked: boolean,
                checkedNodes: any,
                node: any,
                event: autobahn$Event
            }) => void,

        /**
         * 点击树节点触发
         */
        onSelect?: (
            selectedKeys: any,
            e: {
                selected: boolean,
                selectedNodes: any,
                node: any,
                event: autobahn$Event
            }) => void,

        /**
         * filter some treeNodes as you need. it should return true 
         */
        filterTreeNode?: (node: any) => boolean,

        /**
         * 异步加载数据
         */
        loadData?: (node: any) => void,

        /**
         * 响应右键点击
         */
        onRightClick?: (options: {
            event: autobahn$Event,
            node: any
        }) => void,

        /**
         * 设置节点可拖拽（IE>8）
         */
        draggable?: boolean,

        /**
         * 开始拖拽时调用
         */
        onDragStart?: (options: {
            event: autobahn$Event,
            node: any
        }) => void,

        /**
         * dragenter 触发时调用
         */
        onDragEnter?: (options: {
            event: autobahn$Event,
            node: any,
            expandedKeys: any
        }) => void,

        /**
         * dragover 触发时调用 
         */
        onDragOver?: (options: {
            event: autobahn$Event,
            node: any
        }) => void,

        /**
         * dragleave 触发时调用
         */
        onDragLeave?: (options: {
            event: autobahn$Event,
            node: any
        }) => void,

        /**
         * drop 触发时调用
         */
        onDrop?: (
            options: {
                event: autobahn$Event,
                node: any,
                dragNode: any,
                dragNodesKeys: any
            }) => void
}


/**
 * #Tree
 * 文件夹、组织架构、生物分类、国家地区等等，世间万物的大多数结构都是树形结构。使用`树控件`可以完整展现其中的层级关系，并具有展开收起选择等交互功能。
 */
declare export class Tree mixins React.Component<Antd$TreeProps, {}>{
    TreeNode: typeof TreeNode;
    render(): JSX.Element
}

declare interface Antd$TreeSelectTreeNodeProps {
    disabled?: boolean,

        /**
         * 此项必须设置（其值在整个树范围内唯一）
         */
        key: string,

        /**
         * 默认根据此属性值进行筛选
         */
        value?: string,

        /**
         * 树节点显示的内容
         */
        title?: React.ReactNode | string,

        /**
         * 是否是叶子节点
         */
        isLeaf?: boolean
}

declare export class TreeSelectTreeNode mixins React.Component<Antd$TreeSelectTreeNodeProps, {}>{
    render(): JSX.Element
}

declare type Antd$TreeData = Array<{
    value: any,
    label: string,
    children: Antd$TreeData
}>;

declare interface Antd$TreeSelectProps {
    style?: AV$Object,

        /**
         * 指定当前选中的条目
         */
        value?: string | Array<any>,

        /**
         * 指定默认选中的条目
         */
        defaultValue?: string | Array<any>,

        /**
         * 支持多选
         */
        multiple?: boolean,

        /**
         * 可以把随意输入的条目作为 tag，输入项不需要与下拉选项匹配
         */
        tags?: boolean,

        /**
         * 被选中时调用，参数为选中项的 value 值
         */
        onSelect?: (value: any) => void,

        /**
         * 选中option，或input的value变化(combobox 模式下)时，调用此函数
         */
        onChange?: (value: any, label: any) => void,

        /**
         * 显示清除按钮
         */
        allowClear?: boolean,

        /**
         * 文本框值变化时回调
         */
        onSearch?: (value: any) => void,

        /**
         * 选择框默认文字
         */
        placeholder?: string,

        /**
         * 搜索框默认文字
         */
        searchPlaceholder?: string,

        /**
         * 下拉菜单的样式
         */
        dropdownStyle?: AV$Object,

        /**
         * 下拉菜单和选择器同宽
         */
        dropdownMatchSelectWidth?: boolean,

        /**
         * 输入框自动提示模式
         */
        combobox?: boolean,

        /**
         * 选择框大小，可选 `large` `small`
         */
        size?: string,

        /**
         * 在下拉中显示搜索框
         */
        showSearch?: boolean,

        /**
         * 是否禁用
         */
        disabled?: boolean,

        /**
         * 默认展开所有树节点
         */
        treeDefaultExpandAll?: boolean,

        /**
         * 显示checkbox
         */
        treeCheckable?: boolean,

        /**
         * 是否根据输入项进行筛选，返回值true
         */
        filterTreeNode?: (treeNode: any) => boolean,

        /**
         * 输入项过滤对应的 treeNode 属性
         */
        treeNodeFilterProp?: string,

        /**
         * 作为显示的prop设置
         */
        treeNodeLabelProp?: string,

        /**
         * treeNodes数据，如果设置则不需要手动构造TreeNode节点（如果value在整个树范围内不唯一，需要设置`key`其值为整个树范围内的唯一id
         */
        treeData?: Antd$TreeData,

        /**
         * 异步加载数据
         */
        loadData?: (node: any) => void
}


/**
 * #TreeSelect
 * 树型选择控件。

##何时使用

类似 Select 的选择控件，可选择的数据结构是一个树形结构时，可以使用 TreeSelect，例如公司层级、学科系统、分类目录等等。
*/
declare export class TreeSelect mixins React.Component<Antd$TreeSelectProps, {}>{
    TreeNode: typeof TreeSelectTreeNode;
    render(): JSX.Element
}

declare interface Antd$UploadProps {

    /**
     * 可选参数, 上传的文件  
     */
    name?: string,

        /**
         * 必选参数, 上传的地址   
         */
        action: string,

        /**
         * 可选参数, 上传所需参数    
         */
        data?: AV$Object,

        /**
         * 可选参数, 设置上传的请求头部，IE10 以上有效
         */
        headers?: AV$Object,

        /**
         * 可选参数, 是否展示 uploadList, 默认开启     
         */
        showUploadList?: boolean,

        /**
         * 可选参数, 是否支持多选文件，`ie10+` 支持。开启后按住 ctrl 可选择多个文件。
         */
        multiple?: boolean,

        /**
         * 可选参数, 接受上传的文件类型, 详见 input accept Attribute 
         */
        accept?: string,

        /**
         * 可选参数, 上传文件之前的钩子，参数为上传的文件，若返回 `false` 或者 Promise 则停止上传。*注意：该方法不支持老 IE*。
         */
        beforeUpload?: Function,

        /**
         * 可选参数, 上传文件改变时的状态，详见 onChange   
         */
        onChange?: (info: AV$Object) => void,

        /**
         * 上传列表的内建样式，支持两种基本样式 `text` or `picture`   
         */
        listType?: string,

        /**
         * 自定义类名
         */
        className?: string
}


/**
 * #Upload
 * 文件选择上传和拖拽上传控件。

##何时使用

上传是将信息（网页、文字、图片、视频等）通过网页或者上传工具发布到远程服务器上的过程。

-当需要上传一个或一些文件时。
-当需要展现上传的进度时。
-当需要使用拖拽交互时。
*/
declare export class Upload mixins React.Component<Antd$UploadProps, {}>{
    render(): JSX.Element
}
declare module 'antd' {
    declare module.exports: typeof Antd
}
declare module 'antd/lib/Affix' {
    declare module.exports: typeof Antd$Affix
}
declare module 'antd/lib/Button' {
    declare module.exports: typeof Antd$Button
}
declare module 'antd/lib/Alert' {
    declare module.exports: typeof Antd$Alert
}
declare module 'antd/lib/Badge' {
    declare module.exports: typeof Antd$Badge
}
declare module 'antd/lib/Breadcrumb' {
    declare module.exports: typeof Antd$Breadcrumb
}
declare module 'antd/lib/Calendar' {
    declare module.exports: typeof Antd$Calendar
}
declare module 'antd/lib/Carousel' {
    declare module.exports: typeof Antd$Carousel
}
declare module 'antd/lib/Cascader' {
    declare module.exports: typeof Antd$Cascader
}
declare module 'antd/lib/Checkbox' {
    declare module.exports: typeof Antd$Checkbox
}
declare module 'antd/lib/Collapse' {
    declare module.exports: typeof Antd$Collapse
}
declare module 'antd/lib/DatePicker' {
    declare module.exports: typeof Antd$DatePicker
}
declare module 'antd/lib/Dropdown' {
    declare module.exports: typeof Antd$Dropdown
}
declare module 'antd/lib/Icon' {
    declare module.exports: typeof Antd$Icon
}
declare module 'antd/lib/Form' {
    declare module.exports: typeof Antd$Form
}
declare module 'antd/lib/Input' {
    declare module.exports: typeof Antd$Input
}
declare module 'antd/lib/InputNumber' {
    declare module.exports: typeof Antd$InputNumber
}
declare module 'antd/lib/Row' {
    declare module.exports: typeof Antd$Row
}
declare module 'antd/lib/Col' {
    declare module.exports: typeof Antd$Col
}
declare module 'antd/lib/Menu' {
    declare module.exports: typeof Antd$Menu
}
declare module 'antd/lib/message' {
    declare module.exports: typeof Antd$message
}
declare module 'antd/lib/Modal' {
    declare module.exports: typeof Antd$Modal
}
declare module 'antd/lib/notification' {
    declare module.exports: typeof Antd$notification
}
declare module 'antd/lib/Pagination' {
    declare module.exports: typeof Antd$Pagination
}
declare module 'antd/lib/Popconfirm' {
    declare module.exports: typeof Antd$Popconfirm
}
declare module 'antd/lib/Popover' {
    declare module.exports: typeof Antd$Popover
}
declare module 'antd/lib/Progress' {
    declare module.exports: typeof Antd$Progress
}
declare module 'antd/lib/QueueAnim' {
    declare module.exports: typeof Antd$QueueAnim
}
declare module 'antd/lib/Radio' {
    declare module.exports: typeof Antd$Radio
}
declare module 'antd/lib/Select' {
    declare module.exports: typeof Antd$Select
}
declare module 'antd/lib/Slider' {
    declare module.exports: typeof Antd$Slider
}
declare module 'antd/lib/Spin' {
    declare module.exports: typeof Antd$Spin
}
declare module 'antd/lib/Steps' {
    declare module.exports: typeof Antd$Steps
}
declare module 'antd/lib/Switch' {
    declare module.exports: typeof Antd$Switch
}
declare module 'antd/lib/Table' {
    declare module.exports: typeof Antd$Table
}
declare module 'antd/lib/Tabs' {
    declare module.exports: typeof Antd$Tabs
}
declare module 'antd/lib/Tag' {
    declare module.exports: typeof Antd$Tag
}
declare module 'antd/lib/TimePicker' {
    declare module.exports: typeof Antd$TimePicker
}
declare module 'antd/lib/Timeline' {
    declare module.exports: typeof Antd$Timeline
}
declare module 'antd/lib/Tooltip' {
    declare module.exports: typeof Antd$Tooltip
}
declare module 'antd/lib/Transfer' {
    declare module.exports: typeof Antd$Transfer
}
declare module 'antd/lib/Tree' {
    declare module.exports: typeof Antd$Tree
}
declare module 'antd/lib/TreeSelect' {
    declare module.exports: typeof Antd$TreeSelect
}
declare module 'antd/lib/Upload' {
    declare module.exports: typeof Antd$Upload
}
declare module 'any-db-transaction' {

    /**
     * Transaction objects are are simple wrappers around a Connection that also implement the Queryable API,
     * but guarantee that all queries take place within a single database transaction or not at all. Note that
    begin also understands how to acquire (and release) a connection from a ConnectionPool as well, so you
    can simply pass a pool to it: var tx = begin(pool)

    By default, any queries that error during a transaction will cause an automatic rollback. If a query has
    no callback, the transaction will also handle (and re-emit) 'error' events for the Query instance.
    This enables handling errors for an entire transaction in a single place.

    Transactions may also be nested by passing a Transaction to begin and these nested transactions can
    safely error and rollback without rolling back their parent transaction

    Transaction events:
    'query', query - emitted immediately after .query is called on a connection via tx.query. The argument is a query object.
    'commit:start' - Emitted when .commit() is called.
    'commit:complete' - Emitted after the transaction has committed.
    'rollback:start' - Emitted when .rollback() is called.
    'rollback:complete' - Emitted after the transaction has rolled back.
    'close' - Emitted after rollback or commit completes.
    'error', err - Emitted under three conditions:
    There was an error acquiring a connection.
    Any query performed in this transaction emits an error that would otherwise go unhandled.
    Any of query, begin, commit, or rollback are called after the connection has already been committed or rolled back.
    Note that the 'error' event may be emitted multiple times! depending on the callback you are registering, you way want to wrap it using [once][].
    */
    declare type begin$Transaction = {

        /**
         * Issue a COMMIT (or RELEASE ... in the case of nested transactions) statement to the database.
         * If a continuation is provided it will be called (possibly with an error) after the COMMIT
        statement completes. The transaction object itself will be unusable after calling commit().
        */
        commit(callback?: (error: error$Error) => void): void,

        /**
         * The same as Transaction.commit but issues a ROLLBACK. Again, the transaction will be unusable after calling this method.
         */
        rollback(callback?: (error: error$Error) => void): void
    }

    declare interface begin$TransactionOptions {

        /**
         * Adapter name e.g. 'mysql'
         */
        adapter?: anyDB.Adapter,

            /**
             * SQL statement for beginning a transaction, default 'BEGIN'
             */
            begin?: string,

            /**
             * SQL statement for committing a transaction, default 'COMMIT'
             */
            commit?: string,

            /**
             * SQL statement for rolling back a transaction, default 'ROLLBACK'
             */
            rollback?: string,

            /**
             * Callback for transaction
             */
            callback?: (error: error$Error, transaction: begin$Transaction) => void,

            /**
             * Rollback automatically on error, default true
             */
            autoRollback?: boolean
    }
    declare module.exports: typeof begin
}
declare module 'any-db' {
    declare     export interface ConnectOpts {
        adapter: string
    }
    declare     export interface Adapter {
        name: string,

            /**
             * Create a new connection object. In common usage, config will be created by parse-db-url and passed to the adapter by any-db.
             * If a continuation is given, it must be called, either with an error or the established connection.
             */
            createConnection(
                opts: ConnectOpts,
                callback?: (error: error$Error, result: autobahn$Connection) => void): autobahn$Connection,

            /**
             * Create a Query that may eventually be executed later on by a Connection. While this function is rarely needed by user code,
             * it makes it possible for ConnectionPool.query and Transaction.query to fulfill the Queryable.query contract
            by synchronously returning a Query stream
            */
            createQuery(
                text: string,
                params?: any[],
                callback?: (error: error$Error, result: ResultSet) => void): AV$Query,
            createQuery(query: AV$Query): AV$Query
    }

    /**
     * Other properties are driver specific
     */
    declare     export interface Field {
        name: string
    }

    /**
     * ResultSet objects are just plain data that collect results of a query when a continuation
     * is provided to Queryable.query. The lastInsertId is optional, and currently supported by
    sqlite3 and mysql but not postgres, because it is not supported by Postgres itself.
    */
    declare     export interface ResultSet {

        /**
         * Affected rows. Note e.g. for INSERT queries the rows property is not filled even
         * though rowCount is non-zero.
         */
        rowCount: number,

            /**
             * Result rows
             */
            rows: any[],

            /**
             * Result field descriptions
             */
            fields: Field[],

            /**
             * Not supported by all drivers.
             */
            fieldCount?: number,

            /**
             * Not supported by all drivers.
             */
            lastInsertId?: any,

            /**
             * Not supported by all drivers.
             */
            affectedRows?: number,

            /**
             * Not supported by all drivers.
             */
            changedRows?: number
    }

    /**
     * Query objects are returned by the Queryable.query method, available on connections,
     * pools, and transactions. Queries are instances of Readable, and as such can be piped
    through transforms and support backpressure for more efficient memory-usage on very
    large results sets. (Note: at this time the sqlite3 driver does not support backpressure)

    Internally, Query instances are created by a database Adapter and may have more methods,
    properties, and events than are described here. Consult the documentation for your
    specific adapter to find out about any extensions.

    Events:

    Error event
    The 'error' event is emitted at most once per query. Note that this event will be
    emitted for errors even if a callback was provided, the callback will
    simply be subscribed to the 'error' event.
    One argument is passed to event listeners:
    error - the error object.

    Fields event
    A 'fields' event is emmitted before any 'data' events.
    One argument is passed to event listeners:
    fields - an array of [Field][ResultSet] objects.

    The following events are part of the stream.Readable interface which is implemented by Query:

    Data event
    A 'data' event is emitted for each row in the query result set.
    One argument is passed to event listeners:
    row contains the contents of a single row in the query result

    Close event
    A 'close' event is emitted when the query completes.
    No arguments are passed to event listeners.

    End event
    An 'end' event is emitted after all query results have been consumed.
    No arguments are passed to event listeners.
    */
    declare     export type Query = {

        /**
         * The SQL query as a string. If you are using MySQL this will contain
         * interpolated values after the query has been enqueued by a connection.
         */
        text: string,

        /**
         * The array of parameter values.
         */
        values: any[],

        /**
         * The callback (if any) that was provided to Queryable.query. Note that
         * Query objects must not use a closed over reference to their callback,
        as other any-db libraries may rely on modifying the callback property
        of a Query they did not create.
        */
        callback: (error: error$Error, results: ResultSet) => void
    }

    /**
     * Events:
     * The 'query' event is emitted immediately before a query is executed. One argument is passed to event handlers:
    - query:	a Query object
    */
    declare     export type Queryable = {

        /**
         * The Adapter instance that will be used by this Queryable for creating Query instances and/or connections.
         */
        adapter: Adapter,

        /**
         * Execute a SQL statement using bound parameters (if they are provided) and return a Query object
         * that is a Readable stream of the resulting rows. If a Continuation<ResultSet> is provided the rows
        returned by the database will be aggregated into a [ResultSet][] which will be passed to the
        continuation after the query has completed.
        The second form is not needed for normal use, but must be implemented by adapters to work correctly
        with ConnectionPool and Transaction. See Adapter.createQuery for more details.
        */
        query(
            text: string,
            params?: any[],
            callback?: (error: error$Error, results: ResultSet) => void): AV$Query
    }
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare     export interface ConnectionStatic {
        new(): autobahn$Connection,
        name: string,
            createConnection(): void,
            createPool(): void
    }

    /**
     * ConnectionPool events
     * 'acquire' - emitted whenever pool.acquire is called
    'release' - emitted whenever pool.release is called
    'query', query - emitted immediately after .query is called on a
     		connection via pool.query. The argument is a Query object.
    'close' - emitted when the connection pool has closed all of it
     		connections after a call to close().
    */
    declare     export type ConnectionPool = {

        /**
         * Implements Queryable.query by automatically acquiring a connection
         * and releasing it when the query completes.
         */
        query(
            text: string,
            params?: any[],
            callback?: (error: error$Error, results: ResultSet) => void): AV$Query,

        /**
         * Remove a connection from the pool. If you use this method you must
         * return the connection back to the pool using ConnectionPool.release
         */
        acquire(callback: (error: error$Error, result: autobahn$Connection) => void): void,

        /**
         * Return a connection to the pool. This should only be called with connections
         * you've manually acquired. You must not continue to use the connection after releasing it.
         */
        release(connection: autobahn$Connection): void,

        /**
         * Stop giving out new connections, and close all existing database connections as they
         * are returned to the pool.
         */
        close(callback?: (error: error$Error) => void): void
    } & anydbSQL$Queryable


    /**
     * A PoolConfig is generally a plain object with any of the following properties (they are all optional):
     */
    declare     export interface PoolConfig {

        /**
         * min (default 0) The minimum number of connections to keep open in the pool.
         */
        min?: number,

            /**
             * max (default 10) The maximum number of connections to keep open in the pool.
             * When this limit is reached further requests for connections will queue waiting
            for an existing connection to be released back into the pool.
            */
            max?: number,

            /**
             * (default 30000) The maximum amount of time a connection can sit idle in the pool before being reaped
             */
            idleTimeout?: number,

            /**
             * (default 1000) How frequently the pool should check for connections that are old enough to be reaped.
             */
            reapInterval?: number,

            /**
             * (default true) When this is true, the pool will reap connections that
             * have been idle for more than idleTimeout milliseconds.
             */
            refreshIdle?: boolean,

            /**
             * Called immediately after a connection is first established. Use this to do one-time setup of new connections.
             * The supplied Connection will not be added to the pool until you pass it to the done continuation.
             */
            onConnect?: (
                connection: autobahn$Connection,
                ready: (error: error$Error, result: autobahn$Connection) => void) => void,

            /**
             * Called each time a connection is returned to the pool. Use this to restore a connection to
             * it's original state (e.g. rollback transactions, set the database session vars). If reset
            fails to call the done continuation the connection will be lost in limbo.
            */
            reset?: (connection: autobahn$Connection, done: (error: error$Error) => void) => void,

            /**
             * (default function (err) { return true }) - Called when an error is encountered
             * by pool.query or emitted by an idle connection. If shouldDestroyConnection(error)
            is truthy the connection will be destroyed, otherwise it will be reset.
            */
            shouldDestroyConnection?: (error: error$Error) => boolean
    }

    /**
     * Create a database connection.
     * @param url String of the form adapter://user:password
     * @host  /database
     * @param callback 
     * @returns  Connection object.
     */
    declare     export function createConnection(
        url: string,
        callback?: (error: error$Error, connection: autobahn$Connection) => void): autobahn$Connection
    declare     export function createPool(url: string, config: PoolConfig): ConnectionPool
}
declare module 'anydb-sql-migrations' {

    declare     export interface Migration {
        version: string
    }
    declare     export type MigrationsTable = {
        version: anydbSQL$Column<string >
    } & Antd$Table

    declare     export interface MigFn {
        (tx: begin$Transaction): promise$Promise<any >
    }
    declare     export interface MigrationTask {
        up: MigFn,
            down: MigFn,
            name: string
    }
    declare     export function create(
        db: anydbSQL$AnydbSql,
        tasks: any): {
        run: () => promise$Promise<any>,
        migrateTo: (target?: string) => promise$Promise<any>,
        check: (
            f: (m: {
                type: string,
                items: MigrationTask[]
            }) => any) => promise$Promise<any >
    }
}
declare module 'anydb-sql' {
    declare type AnyDBPool = {
        query: (
            text: string,
            values: any[],
            callback: (err: error$Error, result: any) => void) => void,
        begin: () => anydbSQL$Transaction,
        close: (err: error$Error) => void
    }
    declare interface Dictionary<T>{
        [key: string]: T
    }
    declare     export interface anydbSQL$OrderByValueNode {}

    declare     export interface anydbSQL$ColumnDefinition {
        primaryKey?: boolean,
            dataType?: string,
            references?: {
                table: string,
                column: string
            },
            notNull?: boolean
    }

    declare     export interface anydbSQL$TableDefinition {
        name: string,
            columns: Dictionary<anydbSQL$ColumnDefinition>,
            has?: Dictionary<{
                from: string,
                many?: boolean
            } >
    }

    declare     export interface anydbSQL$QueryLike {
        query: string,
            values: any[],
            text: string
    }

    declare     export interface anydbSQL$DatabaseConnection {
        queryAsync<T>(
                query: string,
                ...params: any[]): promise$Promise<{
                rowCount: number,
                rows: T[]
            }>,
            queryAsync<T>(query: anydbSQL$QueryLike): promise$Promise<{
                rowCount: number,
                rows: T[]
            } >
    }


    /**
     * Transaction objects are are simple wrappers around a Connection that also implement the Queryable API,
     * but guarantee that all queries take place within a single database transaction or not at all. Note that
    begin also understands how to acquire (and release) a connection from a ConnectionPool as well, so you
    can simply pass a pool to it: var tx = begin(pool)

    By default, any queries that error during a transaction will cause an automatic rollback. If a query has
    no callback, the transaction will also handle (and re-emit) 'error' events for the Query instance.
    This enables handling errors for an entire transaction in a single place.

    Transactions may also be nested by passing a Transaction to begin and these nested transactions can
    safely error and rollback without rolling back their parent transaction

    Transaction events:
    'query', query - emitted immediately after .query is called on a connection via tx.query. The argument is a query object.
    'commit:start' - Emitted when .commit() is called.
    'commit:complete' - Emitted after the transaction has committed.
    'rollback:start' - Emitted when .rollback() is called.
    'rollback:complete' - Emitted after the transaction has rolled back.
    'close' - Emitted after rollback or commit completes.
    'error', err - Emitted under three conditions:
    There was an error acquiring a connection.
    Any query performed in this transaction emits an error that would otherwise go unhandled.
    Any of query, begin, commit, or rollback are called after the connection has already been committed or rolled back.
    Note that the 'error' event may be emitted multiple times! depending on the callback you are registering, you way want to wrap it using [once][].
    */
    declare type anydbSQL$Transaction = {

        /**
         * Issue a COMMIT (or RELEASE ... in the case of nested transactions) statement to the database.
         * If a continuation is provided it will be called (possibly with an error) after the COMMIT
        statement completes. The transaction object itself will be unusable after calling commit().
        */
        commit(callback?: (error: error$Error) => void): void,

        /**
         * The same as Transaction.commit but issues a ROLLBACK. Again, the transaction will be unusable after calling this method.
         */
        rollback(callback?: (error: error$Error) => void): void
    }

    declare     export interface anydbSQL$SubQuery<T>{
        select(node: anydbSQL$Column<T>): anydbSQL$SubQuery<T>,
        where(...nodes: any[]): anydbSQL$SubQuery<T>,
        from(table: anydbSQL$TableNode): anydbSQL$SubQuery<T>,
        group(...nodes: any[]): anydbSQL$SubQuery<T>,
        order(criteria: anydbSQL$OrderByValueNode): anydbSQL$SubQuery<T>,
        notExists(subQuery: anydbSQL$SubQuery<any>): anydbSQL$SubQuery<T >
    }

    declare interface anydbSQL$Executable<T>{
        get(): promise$Promise<T>,
        getWithin(tx: anydbSQL$DatabaseConnection): promise$Promise<T>,
        exec(): promise$Promise<void>,
        all(): promise$Promise<T[]>,
        execWithin(tx: anydbSQL$DatabaseConnection): promise$Promise<void>,
        allWithin(tx: anydbSQL$DatabaseConnection): promise$Promise<T[]>,
        toQuery(): anydbSQL$QueryLike
    }


    /**
     * Events:
     * The 'query' event is emitted immediately before a query is executed. One argument is passed to event handlers:
    - query:	a Query object
    */
    declare     export type anydbSQL$Queryable = {

        /**
         * The Adapter instance that will be used by this Queryable for creating Query instances and/or connections.
         */
        adapter: Adapter,

        /**
         * Execute a SQL statement using bound parameters (if they are provided) and return a Query object
         * that is a Readable stream of the resulting rows. If a Continuation<ResultSet> is provided the rows
        returned by the database will be aggregated into a [ResultSet][] which will be passed to the
        continuation after the query has completed.
        The second form is not needed for normal use, but must be implemented by adapters to work correctly
        with ConnectionPool and Transaction. See Adapter.createQuery for more details.
        */
        query(
            text: string,
            params?: any[],
            callback?: (error: error$Error, results: ResultSet) => void): AV$Query
    }


    /**
     * Query objects are returned by the Queryable.query method, available on connections,
     * pools, and transactions. Queries are instances of Readable, and as such can be piped
    through transforms and support backpressure for more efficient memory-usage on very
    large results sets. (Note: at this time the sqlite3 driver does not support backpressure)

    Internally, Query instances are created by a database Adapter and may have more methods,
    properties, and events than are described here. Consult the documentation for your
    specific adapter to find out about any extensions.

    Events:

    Error event
    The 'error' event is emitted at most once per query. Note that this event will be
    emitted for errors even if a callback was provided, the callback will
    simply be subscribed to the 'error' event.
    One argument is passed to event listeners:
    error - the error object.

    Fields event
    A 'fields' event is emmitted before any 'data' events.
    One argument is passed to event listeners:
    fields - an array of [Field][ResultSet] objects.

    The following events are part of the stream.Readable interface which is implemented by Query:

    Data event
    A 'data' event is emitted for each row in the query result set.
    One argument is passed to event listeners:
    row contains the contents of a single row in the query result

    Close event
    A 'close' event is emitted when the query completes.
    No arguments are passed to event listeners.

    End event
    An 'end' event is emitted after all query results have been consumed.
    No arguments are passed to event listeners.
    */
    declare     export type anydbSQL$Query = {

        /**
         * The SQL query as a string. If you are using MySQL this will contain
         * interpolated values after the query has been enqueued by a connection.
         */
        text: string,

        /**
         * The array of parameter values.
         */
        values: any[],

        /**
         * The callback (if any) that was provided to Queryable.query. Note that
         * Query objects must not use a closed over reference to their callback,
        as other any-db libraries may rely on modifying the callback property
        of a Query they did not create.
        */
        callback: (error: error$Error, results: ResultSet) => void
    }

    declare     export type anydbSQL$ModifyingQuery = {
        returning<U>(...nodes: any[]): anydbSQL$Query<U>,
        where(...nodes: any[]): anydbSQL$ModifyingQuery
    } & anydbSQL$Executable


    declare     export interface anydbSQL$TableNode {
        join(table: anydbSQL$TableNode): anydbSQL$JoinTableNode,
            leftJoin(table: anydbSQL$TableNode): anydbSQL$JoinTableNode
    }

    declare     export type anydbSQL$JoinTableNode = {
        on(filter: anydbSQL$BinaryNode): anydbSQL$TableNode,
        on(filter: string): anydbSQL$TableNode
    } & anydbSQL$TableNode


    declare type anydbSQL$CreateQuery = {
        ifNotExists(): anydbSQL$Executable<void >
    } & anydbSQL$Executable


    declare type anydbSQL$DropQuery = {
        ifExists(): anydbSQL$Executable<void >
    } & anydbSQL$Executable


    declare     export type anydbSQL$Table<T>= {
        create(): anydbSQL$CreateQuery,
        drop(): anydbSQL$DropQuery,
        as(name: string): anydbSQL$Table<T>,
        update(o: any): anydbSQL$ModifyingQuery,
        insert(row: T): anydbSQL$ModifyingQuery,
        insert(rows: T[]): anydbSQL$ModifyingQuery,
        select(): anydbSQL$Query<T>,
        select<U>(...nodes: any[]): anydbSQL$Query<U>,
        from<U>(table: anydbSQL$TableNode): anydbSQL$Query<U>,
        star(): anydbSQL$Column<any>,
        subQuery<U>(): anydbSQL$SubQuery<U>,
        eventEmitter: {
            emit: (type: string, ...args: any[]) => void,
            on: (eventName: string, handler: Function) => void
        },
        columns: anydbSQL$Column<any>[],
        sql: anydbSQL$SQL,
        alter(): anydbSQL$AlterQuery<T >
    } & anydbSQL$TableNode & anydbSQL$Queryable


    declare     export type anydbSQL$AlterQuery<T>= {
        addColumn(column: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        addColumn(name: string, options: string): anydbSQL$AlterQuery<T>,
        dropColumn(column: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        renameColumn(
            column: anydbSQL$Column<any>,
            newColumn: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        renameColumn(column: anydbSQL$Column<any>, newName: string): anydbSQL$AlterQuery<T>,
        renameColumn(name: string, newName: string): anydbSQL$AlterQuery<T>,
        rename(newName: string): anydbSQL$AlterQuery<T >
    } & anydbSQL$Executable


    declare     export interface anydbSQL$SQL {
        functions: {
            LOWER(c: anydbSQL$Column<string>): anydbSQL$Column<string >
        }
    }

    declare     export interface anydbSQL$BinaryNode {
        and(node: anydbSQL$BinaryNode): anydbSQL$BinaryNode,
            or(node: anydbSQL$BinaryNode): anydbSQL$BinaryNode
    }

    declare     export interface anydbSQL$Column<T>{ in (arr: T[]): anydbSQL$BinaryNode,
        in (subQuery: anydbSQL$SubQuery<T>): anydbSQL$BinaryNode,
        notIn(arr: T[]): anydbSQL$BinaryNode,
        equals(node: any): anydbSQL$BinaryNode,
        notEquals(node: any): anydbSQL$BinaryNode,
        gte(node: any): anydbSQL$BinaryNode,
        lte(node: any): anydbSQL$BinaryNode,
        gt(node: any): anydbSQL$BinaryNode,
        lt(node: any): anydbSQL$BinaryNode,
        like(str: string): anydbSQL$BinaryNode,
        multiply: {
            (node: anydbSQL$Column<T>): anydbSQL$Column<T>,
            (n: number): anydbSQL$Column<number >
        },
        isNull(): anydbSQL$BinaryNode,
        isNotNull(): anydbSQL$BinaryNode,
        sum(): anydbSQL$Column<number>,
        count(): anydbSQL$Column<number>,
        count(name: string): anydbSQL$Column<number>,
        distinct(): anydbSQL$Column<T>,
        as(name: string): anydbSQL$Column<T>,
        ascending: anydbSQL$OrderByValueNode,
        descending: anydbSQL$OrderByValueNode,
        asc: anydbSQL$OrderByValueNode,
        desc: anydbSQL$OrderByValueNode
    }

    declare     export type anydbSQL$AnydbSql = {
        define<T>(map: anydbSQL$TableDefinition): anydbSQL$Table<T>,
        transaction<T>(fn: (tx: anydbSQL$Transaction) => promise$Promise<T>): promise$Promise<T>,
        allOf(...tables: anydbSQL$Table<any>[]): any,
        models: Dictionary<anydbSQL$Table<any >> ,
        functions: {
            LOWER: (name: anydbSQL$Column<string>) => anydbSQL$Column<string>,
            RTRIM: (name: anydbSQL$Column<string>) => anydbSQL$Column<string >
        },
        makeFunction(name: string): Function,
        begin(): anydbSQL$Transaction,
        open(): void,
        close(): void,
        getPool(): AnyDBPool,
        dialect(): string
    } & anydbSQL$DatabaseConnection

    declare module.exports: typeof anydbSQL
}
declare module 'aphrodite' {


    /**
     * Aphrodite style declaration
     */
    declare     export interface StyleDeclaration {
        [key: string]: React.CSSProperties
    }
    declare interface StyleSheetStatic {

        /**
         * Create style sheet
         */
        create<T>(styles: T): T,

            /**
             * Rehydrate class names from server renderer
             */
            rehydrate(renderedClassNames: string[]): void
    }
    declare     export var StyleSheet: StyleSheetStatic;

    /**
     * Get class names from passed styles
     */
    declare     export function css(...styles: any[]): string
    declare interface StaticRendererResult {
        html: string,
            css: {
                content: string,
                renderedClassNames: string[]
            }
    }

    /**
     * Utilities for using Aphrodite server-side.
     */
    declare interface StyleSheetServerStatic {
        renderStatic(renderFunc: () => string): StaticRendererResult
    }
    declare     export var StyleSheetServer: StyleSheetServerStatic;
    declare interface StyleSheetTestUtilsStatic {

        /**
         * Prevent styles from being injected into the DOM.
         * 
        This is useful in situations where you'd like to test rendering UI
        components which use Aphrodite without any of the side-effects of
        Aphrodite happening. Particularly useful for testing the output of
        components when you have no DOM, e.g. testing in Node without a fake DOM.

        Should be paired with a subsequent call to
        clearBufferAndResumeStyleInjection.
        */
        suppressStyleInjection(): void,

            /**
             * Opposite method of preventStyleInject.
             */
            clearBufferAndResumeStyleInjection(): void
    }
    declare     export var StyleSheetTestUtils: StyleSheetTestUtilsStatic;
}
declare module 'aphrodite/no-important' {

}
declare module 'api-error-handler' {

    declare     export type apiErrorHandler$Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare module.exports: typeof apiErrorHandler
}
declare module 'ApigeeAccess' {
    declare     function getVariable(request: any, name: string): string | number | boolean
    declare     function setVariable(request: any, name: string, value: string | number | boolean): void
    declare     function setIntVariable(request: any, name: string, value: string | number): void
    declare     function deleteVariable(request: any, name: string): void
    declare     function getCache(name: string, options?: CacheOptions): any
    declare     function getVault(name: string, scope?: "organization" | "environment"): SecureVault
    declare     function getQuota(options?: any): QuotaService
    declare     function getMode(): "apigee" | "standalone"
    declare interface CacheOptions {
        resource?: string,
            scope?: "global" | "application" | "exclusive",
            defaultTtl?: number,
            timeout?: number
    }
    declare interface Cache {
        put(key: string, data: any, ttl?: number, callback?: (err: any) => void): void,
            get(key: string, callback: (err: any, data: any) => void): void,
            remove(key: string, callback?: (err: any) => void): void
    }
    declare interface SecureVault {
        getKeys(callback: (err: any, data: any) => void): void,
            get(key: string, callback: (err: any, data: any) => void): void
    }
    declare interface QuotaService {
        apply(
            options?: QuotaServiceApplyOptions,
            callback?: (err: any, data: QuotaServiceApplyCallbackData) => void): void
    }
    declare interface QuotaServiceApplyOptions {
        identifier: string,
            timeUnit: "minute" |
            "hour" |
            "day" |
            "week" |
            "month",
            allow: number,
            interval?: number,
            weight?: number
    }
    declare interface QuotaServiceApplyCallbackData {
        used: number,
            allowed: number,
            isAllowed: boolean,
            expiryTime: number,
            timestamp: number
    }
}
declare module 'apigee-access' {
    declare module.exports: typeof ApigeeAccess
}
declare module 'apn' {
    declare     export interface ConnectionOptions {

        /**
         * The filename of the connection certificate to load from disk, or a Buffer/String containing the certificate data. (Defaults to: `cert.pem`)
         */
        cert?: string | Buffer,

            /**
             * The filename of the connection key to load from disk, or a Buffer/String containing the key data. (Defaults to: `key.pem`)
             */
            key?: string | Buffer,

            /**
             * An array of trusted certificates. Each element should contain either a filename to load, or a Buffer/String (in PEM format) to be used directly. If this is omitted several well known "root" CAs will be used. - You may need to use this as some environments don't include the CA used by Apple (entrust_2048).
             */
            ca?: (string | Buffer)[],

            /**
             * File path for private key, certificate and CA certs in PFX or PKCS12 format, or a Buffer containing the PFX data. If supplied will always be used instead of certificate and key above.
             */
            pfx?: string | Buffer,

            /**
             * The passphrase for the connection key, if required
             */
            passphrase?: string,

            /**
             * Specifies which environment to connect to: Production (if true) or Sandbox - The hostname will be set automatically. (Defaults to NODE_ENV == "production", i.e. false unless the NODE_ENV environment variable is set accordingly)
             */
            production?: boolean,

            /**
             * Enable when you are using a VoIP certificate to enable paylods up to 4096 bytes.
             */
            voip?: boolean,

            /**
             * Gateway port (Defaults to: `2195`)
             */
            port?: number,

            /**
             * Reject Unauthorized property to be passed through to tls.connect() (Defaults to `true`)
             */
            rejectUnauthorized?: boolean,

            /**
             * Number of notifications to cache for error purposes (See "Handling Errors" below, (Defaults to: `1000`)
             */
            cacheLength?: number,

            /**
             * Whether the cache should grow in response to messages being lost after errors. (Will still emit a 'cacheTooSmall' event) (Defaults to: `true`)
             */
            autoAdjustCache?: boolean,

            /**
             * The maximum number of connections to create for sending messages. (Defaults to: `1`)
             */
            maxConnections?: number,

            /**
             * The duration of time the module should wait, in milliseconds, when trying to establish a connection to Apple before failing. 0 = Disabled. {Defaults to: `10000`}
             */
            connectTimeout?: number,

            /**
             * The duration the socket should stay alive with no activity in milliseconds. 0 = Disabled. (Defaults to: `3600000` - 1h)
             */
            connectionTimeout?: number,

            /**
             * The maximum number of connection failures that will be tolerated before `apn` will "terminate". (Defaults to: 10)
             */
            connectionRetryLimit?: number,

            /**
             * Whether to buffer notifications and resend them after failure. (Defaults to: `true`)
             */
            buffersNotifications?: number,

            /**
             * Whether to aggresively empty the notification buffer while connected - if set to true node-apn may enter a tight loop under heavy load while delivering notifications. (Defaults to: `false`)
             */
            fastMode?: boolean
    }
    declare     export class Connection mixins events$EventEmitter {
        constructor(options: ConnectionOptions): this;

        /**
         * This is the business end of the module. Create a `Notification` object and pass it in, along with a single recipient or an array of them and node-apn will take care of the rest, delivering the notification to each recipient.
         * 
        A "recipient" is either a `Device` object, a `String`, or a `Buffer` containing the device token. `Device` objects are used internally and will be created if necessary. Where applicable, all events will return a `Device` regardless of the type passed to this method.
        */
        pushNotification(
            notification: Notification,
            recipient: AppleTVJS$Device | string | Buffer | (AppleTVJS$Device | string | Buffer)[]): void;

        /**
         * Used to manually adjust the "cacheLength" property in the options. This is ideal if you choose to use the `cacheTooSmall` event to tweak your environment. It is safe for increasing and reducing cache size.
         */
        setCacheLength(newLength: number): void;

        /**
         * Indicate to node-apn that when the queue of pending notifications is fully drained that it should close all open connections. This will mean that if there are no other pending resources (open sockets, running timers, etc.) the application will terminate. If notifications are pushed after the connection has completely shutdown a new connection will be established and, if applicable, `shutdown` will need to be called again.
         */
        shutdown(): void;

        /**
         * Emitted when an error occurs during initialisation of the module, usually due to a problem with the keys and certificates.
         */
        on(event: "error", listener: (error: error$Error) => void): this;

        /**
         * Emitted when the connection socket experiences an error. This may be useful for debugging but no action should be necessary.
         */
        on(event: "socketError", listener: (error: error$Error) => void): this;

        /**
         * Emitted when a notification has been sent to Apple - not a guarantee that it has been accepted by Apple, an error relating to it may occur later on. A notification may also be "transmitted" several times if a preceding notification caused an error requiring retransmission.
         */
        on(
            event: "transmitted",
            listener: (notification: Notification, decive: AppleTVJS$Device) => void): this;

        /**
         * Emitted when all pending notifications have been transmitted to Apple and the pending queue is empty. This may be called more than once if a notification error occurs and notifications must be re-sent.
         */
        on(event: "completed", listener: () => void): this;

        /**
         * Emitted when Apple returns a notification as invalid but the notification has already been expunged from the cache - usually due to high throughput and indicates that notifications will be getting lost. The parameter is an estimate of how many notifications have been lost. You should experiment with increasing the cache size or enabling ```autoAdjustCache``` if you see this frequently.
         * 
         *Note*: With ```autoAdjustCache``` enabled this event will still be emitted when an adjustment is triggered.
         */
        on(event: "cacheTooSmall", listener: (sizeDifference: number) => void): this;

        /**
         * Emitted when a connection to Apple is successfully established. The parameter indicates the number of open connections. No action is required as the connection is managed internally.
         */
        on(event: "connected", listener: (openSockets: net.Socket[]) => void): this;

        /**
         * Emitted when the connection to Apple has been closed, this could be for numerous reasons, for example an error has occurred or the connection has timed out. The parameter is the same as for `connected` and again, no action is required.
         */
        on(event: "disconnected", listener: (openSockets: net.Socket[]) => void): this;

        /**
         * Emitted when the connectionTimeout option has been specified and no activity has occurred on a socket for a specified duration. The socket will be closed immediately after this event and a `disconnected` event will also be emitted.
         */
        on(event: "timeout", listener: () => void): this;

        /**
         * Emitted when a message has been received from Apple stating that a notification was invalid or if an internal error occurred before that notification could be pushed to Apple. If the notification is still in the cache it will be passed as the second argument, otherwise null. Where possible the associated `Device` object will be passed as a third parameter, however in cases where the token supplied to the module cannot be parsed into a `Buffer` the supplied value will be returned.
         * 
        Error codes smaller than 512 correspond to those returned by Apple as per their [docs][errors]. Other errors are applicable to `node-apn` itself. Definitions can be found in `lib/errors.js`.
        */
        on(
            event: "transmissionError",
            listener: (
                errorCode: number,
                notification: Notification,
                device: AppleTVJS$Device | Buffer) => void): this;
        on(event: string, listener: Function): this
    }
    declare     export interface NotificationAlertOptions {
        title?: string,
            subtitle?: string,
            body: string,
            title - loc - key?: string,
            title - loc - args?: string[],
            action - loc - key?: string,
            loc - key?: string,
            loc - args?: string[],
            launch - image?: string
    }
    declare     export class Notification {

        /**
         * The maximum number of retries which should be performed when sending a notification if an error occurs. A value of 0 will only allow one attempt at sending (0 retries). Set to -1 to disable (default).
         */
        retryLimit: number;

        /**
         * The UNIX timestamp representing when the notification should expire. This does not contribute to the 2048 byte payload size limit. An expiry of 0 indicates that the notification expires immediately.
         */
        expiry: number;

        /**
         * From Apple's Documentation, Provide one of the following values:
         * 
        - 10 - The push message is sent immediately. (Default)
          >The push notification must trigger an alert, sound, or badge on the device. It is an error use this priority for a push that contains only the content-available key.
        - 5 - The push message is sent at a time that conserves power on the device receiving it.
        */
        priority: number;

        /**
         * The encoding to use when transmitting the notification to APNS, defaults to `utf8`. `utf16le` is also possible but as each character is represented by a minimum of 2 bytes, will at least halve the possible payload size. If in doubt leave as default.
         */
        encoding: string;

        /**
         * This object represents the root JSON object that you can add custom information for your application to. The properties below will only be added to the payload (under `aps`) when the notification is prepared for sending.
         */
        payload: any;

        /**
         * The value to specify for `payload.aps.badge`
         */
        badge: number;

        /**
         * The value to specify for `payload.aps.sound`
         */
        sound: string;

        /**
         * The value to specify for `payload.aps.alert` can be either a `String` or an `Object` as outlined by the payload documentation.
         */
        alert: string | NotificationAlertOptions;

        /**
         * Setting this to true will specify "content-available" in the payload when it is compiled.
         */
        newsstandAvailable: boolean;

        /**
         * Setting this to true will specify "content-available" in the payload when it is compiled.
         */
        contentAvailable: boolean;

        /**
         * The value to specify for the `mdm` field where applicable.
         */
        mdm: string | AV$Object;

        /**
         * The value to specify for `payload.aps['url-args']`. This used for Safari Push NOtifications and should be an array of values in accordance with the Web Payload Documentation.
         */
        urlArgs: string[];

        /**
         * When this parameter is set and `notification#trim()` is called it will attempt to truncate the string at the nearest space.
         */
        truncateAtWordEnd: boolean;

        /**
         * You can optionally pass in an object representing the payload, or configure properties on the returned object.
         */
        constructor(payload?: any): this;

        /**
         * Set the `aps.alert` text body. This will use the most space-efficient means.
         */
        setAlertText(alertText: string): Notification;

        /**
         * Set the `title` property of the `aps.alert` object - used with Safari Push Notifications
         */
        setAlertTitle(alertTitle: string): Notification;

        /**
         * Set the `action` property of the `aps.alert` object - used with Safari Push Notifications
         */
        setAlertAction(alertAction: string): Notification;

        /**
         * Set the `action-loc-key` property of the `aps.alert` object.
         */
        setActionLocKey(key: string): Notification;

        /**
         * Set the `loc-key` property of the `aps.alert` object.
         */
        setLocKey(key: string): Notification;

        /**
         * Set the `loc-args` property of the `aps.alert` object.
         */
        setLocArgs(args: string[]): Notification;

        /**
         * Set the `launch-image` property of the `aps.alert` object.
         */
        setLaunchImage(image: string): Notification;

        /**
         * Set the `mdm` property on the payload.
         */
        setMDM(mdm: string | AV$Object): Notification;

        /**
         * Set the `content-available` property of the `aps` object.
         */
        setNewsstandAvailable(available: boolean): Notification;

        /**
         * Set the `content-available` property of the `aps` object.
         */
        setContentAvailable(available: boolean): Notification;

        /**
         * Set the `url-args` property of the `aps` object.
         */
        setUrlArgs(urlArgs: string[]): Notification;

        /**
         * Attempt to automatically trim the notification alert text body to meet the payload size limit of 2048 bytes.
         */
        trim(): number
    }
    declare     export class Device {
        token: Buffer;

        /**
         * `deviceToken` can be a `Buffer` or a `String` containing a "hex" representation of the token. Throws an error if the deviceToken supplied is invalid.
         */
        constructor(deviceToken: string | Buffer): this
    }
    declare     export interface FeedbackOptions {

        /**
         * The filename of the connection certificate to load from disk, or a Buffer/String containing the certificate data. (Defaults to: `cert.pem`)
         */
        cert?: string | Buffer,

            /**
             * The filename of the connection key to load from disk, or a Buffer/String containing the key data. (Defaults to: `key.pem`)
             */
            key?: string | Buffer,

            /**
             * An array of trusted certificates. Each element should contain either a filename to load, or a Buffer/String (in PEM format) to be used directly. If this is omitted several well known "root" CAs will be used. - You may need to use this as some environments don't include the CA used by Apple (entrust_2048).
             */
            ca?: (string | Buffer)[],

            /**
             * File path for private key, certificate and CA certs in PFX or PKCS12 format, or a Buffer containing the PFX data. If supplied will be used instead of certificate and key above.
             */
            pfx?: string | Buffer,

            /**
             * The passphrase for the connection key, if required
             */
            passphrase?: string,

            /**
             * Specifies which environment to connect to: Production (if true) or Sandbox - The hostname will be set automatically. (Defaults to NODE_ENV == "production", i.e. false unless the NODE_ENV environment variable is set accordingly)
             */
            production?: boolean,

            /**
             * Feedback server port (Defaults to: `2196`)
             */
            port?: number,

            /**
             * Sets the behaviour for triggering the `feedback` event. When `true` the event will be triggered once per connection with an array of timestamp and device token tuples. Otherwise a `feedback` event will be emitted once per token received. (Defaults to: true)
             */
            batchFeedback?: boolean,

            /**
             * The maximum number of tokens to pass when emitting the event - a value of 0 will cause all tokens to be passed after connection is reset. After this number of tokens are received the `feedback` event will be emitted. (Only applies when `batchFeedback` is enabled)
             */
            batchSize?: number,

            /**
             * How often to automatically poll the feedback service. Set to `0` to disable. (Defaults to: `3600`)
             */
            interval?: number
    }
    declare     export interface FeedbackData {
        time: number,
            device: AppleTVJS$Device
    }

    /**
     * Connection to the Apple Push Notification Feedback Service and if `interval` isn't disabled automatically begins polling the service. Many of the options are the same as `apn.Connection()`
     */
    declare     export class Feedback {
        constructor(options: FeedbackOptions): this;

        /**
         * Trigger a query of the feedback service. If `interval` is non-zero then this method will be called automatically.
         */
        start(): void;

        /**
         * You can cancel the interval by calling `feedback.cancel()`. If you do not wish to have the service automatically queried then set `interval` to 0 and use `feedback.start()` to manually invoke it one time.
         */
        cancel(): void;

        /**
         * Emitted when an error occurs initialising the module. Usually caused by failing to load the certificates.
         */
        on(event: "error", listener: (error: error$Error) => void): Feedback;

        /**
         * Emitted when an error occurs receiving or processing the feedback and in the case of a socket error occurring. These errors are usually informational and node-apn will automatically recover.
         */
        on(event: "feedbackError", listener: (error: error$Error) => void): Feedback;

        /**
         * Emitted when data has been received from the feedback service, typically once per connection. `feedbackData` is an array of objects, each containing the `time` returned by the server (epoch time) and the `device` a `Buffer` containing the device token.
         */
        on(event: "feedback", listener: (feedbackData: FeedbackData[]) => void): Feedback;
        on(event: string, listener: Function): Feedback
    }
}
declare module 'app-root-path' {
    declare module.exports: typeof RootPath
    declare     var RootPath: RootPath;
}
declare interface appFrameworkStatic {

    /**
     * This is the internal appframework object that gets extended and added on to it
     * This is also the start of our query selector engine
     * @param  
     * @param  
     */
    (selector: string, context?: any): appFrameworkCollection,
    (collection: appFrameworkCollection): appFrameworkCollection,
    (element: HTMLElement): appFrameworkCollection,
    (htmlString: string): appFrameworkCollection,
    (object: any): appFrameworkCollection,

    /**
     * Checks to see if the parameter is a $afm object
     * ```
    var foo=$('#header');
    $.is$(foo);
    ```
     * @param  
     * @return  * 
     * @title  $.is$(param)
    */
    is$(obj: any): boolean,

        /**
         * Map takes in elements and executes a callback function on each and returns a collection
         * ```
        $.map([1,2],function(ind){return ind+1});
        ```
         * @param  
         * @param  
         * @return  appframework object with elements in it
         * @title  $.map(elements,callback)
        */
        map(collection: any[], fn: (item: any, index: number) => any): any[],

        /**
         * Iterates through elements and executes a callback.  Returns if false
         * ```
        $.each([1,2],function(ind){console.log(ind);});
        ```
         * @param  
         * @param  
         * @return  elements
         * @title  $.each(elements,callback)
        */
        each(collection: any[], fn: (index: number, item: any) => any): void,
        each(collection: any, fn: (key: string, value: any) => any): void,

        /**
         * Extends an object with additional arguments
         * ```
        $.extend({foo:'bar'});
        $.extend(element,{foo:'bar'});
        ```
         * @param  element
         * @param any number of additional arguments
         * @return  [target]
         * @title  $.extend(target,{params})
        */
        extend(target: any, ...sources: any[]): any,

        /**
         * Checks to see if the parameter is an array
         * ```
        var arr=[];
        $.isArray(arr);
        ```
         * @param  
         * @return  * 
         * @example  $.isArray([1]);
         * @title  $.isArray(param)
        */
        isArray(object: any): boolean,

        /**
         * Checks to see if the parameter is a function
         * ```
        var func=function(){};
        $.isFunction(func);
        ```
         * @param  
         * @return  * 
         * @title  $.isFunction(param)
        */
        isFunction(object: any): boolean,

        /**
         * Checks to see if the parameter is a object
         * ```
        var foo={bar:'bar'};
        $.isObject(foo);
        ```
         * @param  
         * @return  * 
         * @title  $.isObject(param)
        */
        isObject(object: any): boolean,

        /**
         * Prototype for afm object.  Also extens $.fn
         */
        fn: AV$Object,
        ajaxSettings: appFrameworkAjaxSettings,

        /**
         * Execute a jsonP call, allowing cross domain scripting
         * options.url - URL to call
        options.success - Success function to call
        options.error - Error function to call
        ```
        $.jsonP({url:'mysite.php?callback=?&foo=bar',success:function(){},error:function(){}});
        ```
         * @param  
         * @title  $.jsonP(options)
        */
        jsonP(options: appFrameworkAjaxSettings): {},

        /**
         * Execute an Ajax call with the given options
         * options.type - Type of request
        options.beforeSend - function to execute before sending the request
        options.success - success callback
        options.error - error callback
        options.complete - complete callback - callled with a success or error
        options.timeout - timeout to wait for the request
        options.url - URL to make request against
        options.contentType - HTTP Request Content Type
        options.headers - Object of headers to set
        options.dataType - Data type of request
        options.data - data to pass into request.  $.param is called on objects
        ```
        var opts={
              type:"GET",
              success:function(data){},
              url:"mypage.php",
              data:{bar:'bar'},
              }
        $.ajax(opts);
        ```
         * @param  
         * @title  $.ajax(options)
        */
        ajax(options: appFrameworkAjaxSettings): XMLHttpRequest,

        /**
         * Shorthand call to an Ajax GET request
         * ```
        $.get("mypage.php?foo=bar",function(data){});
        ```
         * @param  to hit
         * @param  
         * @title  $.get(url,success)
        */
        get(
            url: string,
            fn: (data: any, status?: string, xhr?: XMLHttpRequest) => void): XMLHttpRequest,

        /**
         * Shorthand call to an Ajax POST request
         * ```
        $.post("mypage.php",{bar:'bar'},function(data){});
        ```
         * @param  to hit
         * @param  to pass in
         * @param  
         * @param  * 
         * @title  $.post(url,[data],success,[dataType])
        */
        post(
            url: string,
            fn: (data: any, status?: string, xhr?: XMLHttpRequest) => void,
            dataType?: string): XMLHttpRequest,
        post(
            url: string,
            data: any,
            fn: (data: any, status?: string, xhr?: XMLHttpRequest) => void,
            dataType?: string): XMLHttpRequest,

        /**
         * Shorthand call to an Ajax request that expects a JSON response
         * ```
        $.getJSON("mypage.php",{bar:'bar'},function(data){});
        ```
         * @param  to hit
         * @param  * 
         * @param  * 
         * @title  $.getJSON(url,data,success)
        */
        getJSON(
            url: string,
            fn: (data: any, status?: string, xhr?: XMLHttpRequest) => void): XMLHttpRequest,
        getJSON(
            url: string,
            data: any,
            fn: (data: any, status: string, xhr: XMLHttpRequest) => void): XMLHttpRequest,

        /**
         * Converts an object into a key/value par with an optional prefix.  Used for converting objects to a query string
         * ```
        var obj={
              foo:'foo',
              bar:'bar'
              }
        var kvp=$.param(obj,'data');
        ```
         * @param  
         * @param  * 
         * @return  Key/value pair representation
         * @title  $.param(object,[prefix];
        */
        param(object: any, prefix?: string): string,

        /**
         * Used for backwards compatibility.  Uses native JSON.parse function
         * ```
        var obj=$.parseJSON("{\"bar\":\"bar\"}");
        ```
         * @params  {String} string
         * @return  * 
         * @title  $.parseJSON(string)
        */
        parseJSON(str: string): any,

        /**
         * Helper function to convert XML into  the DOM node representation
         * ```
        var xmlDoc=$.parseXML("<xml><foo>bar</foo></xml>");
        ```
         * @param  
         * @return  DOM nodes
         * @title  $.parseXML(string)
        */
        parseXML(str: string): any,

        /**
         * Utility function to create a psuedo GUID
         * ```
        var id= $.uuid();
        ```
         * @title  $.uuid
        */
        uuid(): string,

        /**
         * Gets the css matrix, or creates a fake one
         * ```
        $.getCssMatrix(domElement)
        ```
         * @returns  matrix with postion
        */
        getCssMatrix(node: HTMLElement): appFrameworkCssMatrix,
        getCssMatrix(elem: appFrameworkCollection): appFrameworkCssMatrix,

        /**
         * $.create - a faster alertnative to $("<div id='main'>this is some text</div>");
         * ```
        $.create("div",{id:'main',innerHTML:'this is some text'});
        $.create("<div id='main'>this is some text</div>");
        ```{Object}] properties to apply to the element
         * @param  Element type or html
         * @return  Returns an appframework object
         * @title  $.create(type,[params])
        */
        create(type: string, params?: any): appFrameworkCollection,

        /**
         * $.query  - a faster alertnative to $("div");
         * ```
        $.query(".panel");
        ```
         * @param  
         * @param  * 
         * @return  Returns an appframework object
         * @title  $.query(selector,[context])
        */
        query(selector: string, context?: any): appFrameworkCollection,

        /**
         * Creates a custom event to be used internally.
         * @param  
         * @param  * 
         * @return  a custom event that can then be dispatched
         * @title  $.Event(type,props);
         */
        Event(type: string, props: any): any,

        /**
         * Bind an event to an object instead of a DOM Node
         * ```
        $.bind(this,'event',function(){});
        ```
         * @param  
         * @param  name
         * @param  to execute
         * @title  $.bind(object,event,function);
        */
        bind(object: any, event: string, fn: Function): void,

        /**
         * Trigger an event to an object instead of a DOM Node
         * ```
        $.trigger(this,'event',arguments);
        ```
         * @param  
         * @param  name
         * @param  
         * @title  $.trigger(object,event,argments);
        */
        trigger(object: any, event: string, args?: any[]): void,

        /**
         * Unbind an event to an object instead of a DOM Node
         * ```
        $.unbind(this,'event',function(){});
        ```
         * @param  
         * @param  name
         * @param  to execute
         * @title  $.unbind(object,event,function);
        */
        unbind(object: any, event: string, fn: Function): void,

        /**
         * Creates a proxy function so you can change the 'this' context in the function
         * Update: now also allows multiple argument call or for you to pass your own arguments
        ```
        var newObj={foo:bar}
        $("#main").bind("click",$.proxy(function(evt){console.log(this)},newObj);

        or

        ($.proxy(function(foo, bar){console.log(this+foo+bar)}, newObj) )('foo', 'bar');

        or

        ($.proxy(function(foo, bar){console.log(this+foo+bar)}, newObj, ['foo', 'bar']) )();
        ```
         * @param  
         * @param  
         * @title  $.proxy(callback,context);
        */
        proxy(callback: Function, context: any): void,

        /**
         * Function to clean up node content to prevent memory leaks
         * ```
        $.cleanUpContent(node,itself,kill)
        ```
         * @param  
         * @param  itself
         * @param  nodes
         * @title  $.cleanUpContent(node,itself,kill)
        */
        cleanUpContent(node: HTMLElement, itself?: boolean, kill?: boolean): void,

        /**
         * This adds a command to execute in the JS stack, but is faster then setTimeout
         * ```
        $.asap(function,context,args)
        ```
         * @param  
         * @param  
         * @param  
        */
        asap(callback: Function, context?: any, args?: any[]): void,

        /**
         * this function executes javascript in HTML.
         * ```
        $.parseJS(content)
        ```
         * @param  
         * @title  $.parseJS(content);
        */
        parseJS(content: string): void,
        parseJS(content: HTMLElement): void,

        /**
         * Helper function to parse the user agent.  Sets the following
         * .os.webkit
        .os.android
        .os.ipad
        .os.iphone
        .os.webos
        .os.touchpad
        .os.blackberry
        .os.opera
        .os.fennec
        .os.ie
        .os.ieTouch
        .os.supportsTouch
        .os.playbook
        .feat.nativetouchScroll
         * @api  private
        */
        os: {
            webkit: boolean,
            android: boolean,
            androidICS: boolean,
            ipad: boolean,
            iphone: boolean,
            ios7: boolean,
            webos: boolean,
            touchpad: boolean,
            ios: boolean,
            playbook: boolean,
            blackberry: boolean,
            blackberry10: boolean,
            chrome: boolean,
            opera: boolean,
            fennec: boolean,
            ie: boolean,
            ieTouch: boolean,
            supportsTouch: boolean
        },
        feat: {
            nativeTouchScroll: boolean,
            cssPrefix: string,
            cssTransformStart: string,
            cssTransformEnd: string
        }
}
declare interface appFrameworkCollection {
    reduce(
            callbackfn: (
                previousValue: appFrameworkCollection,
                currentValue: appFrameworkCollection,
                currentIndex: number,
                array: appFrameworkCollection[]) => appFrameworkCollection,
            initialValue?: appFrameworkCollection): appFrameworkCollection,
        push(...items: appFrameworkCollection[]): number,
        indexOf(searchElement: appFrameworkCollection, fromIndex?: number): number,
        concat(...items: appFrameworkCollection[]): appFrameworkCollection[],
        slice(start: number, end?: number): appFrameworkCollection[],
        length: number,

        /**
         * This is a wrapper to $.map on the selected elements
         * ```
        $().map(function(){this.value+=ind});
        ```
         * @param  
         * @return  an appframework object
         * @title  $().map(function)
        */
        map(fn: (index: number, item: any) => any): appFrameworkCollection,

        /**
         * Iterates through all elements and applys a callback function
         * ```
        $().each(function(){console.log(this.value)});
        ```
         * @param  
         * @return  an appframework object
         * @title  $().each(function)
        */
        each(fn: (index: number, item: any) => any): appFrameworkCollection,
        forEach(fn: (item: any, index: number) => any): void,

        /**
         * This is executed when DOMContentLoaded happens, or after if you've registered for it.
         * ```
        $(document).ready(function(){console.log('I'm ready');});
        ```
         * @param  
         * @return  an appframework object
         * @title  $().ready(function)
        */
        ready(fn: Function): appFrameworkStatic,

        /**
         * Searches through the collection and reduces them to elements that match the selector
         * ```
        $("#foo").find('.bar');
        $("#foo").find($('.bar'));
        $("#foo").find($('.bar').get(0));
        ```
         * @param  
         * @return  an appframework object filtered
         * @title  $().find(selector)
        */
        find(selector: string): appFrameworkCollection,

        /**
         * Gets or sets the innerHTML for the collection.
         * If used as a get, the first elements innerHTML is returned
        ```
        $("#foo").html(); //gets the first elements html
        $("#foo").html('new html');//sets the html
        $("#foo").html('new html',false); //Do not do memory management cleanup
        ```
         * @param  to set
         * @param  - set to false for performance tests and if you do not want to execute memory management cleanup
         * @return  an appframework object
         * @title  $().html([html])
        */
        html(): string,
        html(html: string): appFrameworkCollection,
        html(html: string, cleanup: boolean): appFrameworkCollection,

        /**
         * Gets or sets the innerText for the collection.
         * If used as a get, the first elements innerText is returned
        ```
        $("#foo").text(); //gets the first elements text;
        $("#foo").text('new text'); //sets the text
        ```
         * @param  to set
         * @return  an appframework object
         * @title  $().text([text])
        */
        text(): string,
        text(text: string): appFrameworkCollection,

        /**
         * Gets or sets a css property for the collection
         * If used as a get, the first elements css property is returned
        This will add px to properties that need it.
        ```
        $().css("background"); // Gets the first elements background
        $().css("background","red")  //Sets the elements background to red
        ```
         * @param  to get
         * @param  to set as
         * @return  an appframework object
         * @title  $().css(attribute,[value])
        */
        css(property: string): any,
        css(property: string, value: any): appFrameworkCollection,
        css(properties: any): appFrameworkCollection,

        /**
         * Performs a css vendor specific transform:translate operation on the collection.
         * 
        ```
        $("#main").cssTranslate('200px,0,0');
        ```
         * @param  values
         * @return  an appframework object
         * @title  $().vendorCss(value)
        */
        vendorCss(transform: string): appFrameworkCollection,

        /**
         * Gets the computed style of CSS values
         * 
        ```
        $("#main").computedStyle('display');
        ```
         * @param  property
         * @return  css vlaue
         * @title  $().computedStyle()
        */
        computedStyle(css: string): appFrameworkCollection,

        /**
         * Sets the innerHTML of all elements to an empty string
         * ```
        $().empty();
        ```
         * @return  an appframework object
         * @title  $().empty()
        */
        empty(): appFrameworkCollection,

        /**
         * Sets the elements display property to "none".
         * This will also store the old property into an attribute for hide
        ```
        $().hide();
        ```
         * @return  an appframework object
         * @title  $().hide()
        */
        hide(): appFrameworkCollection,

        /**
         * Shows all the elements by setting the css display property
         * We look to see if we were retaining an old style (like table-cell) and restore that, otherwise we set it to block
        ```
        $().show();
        ```
         * @return  an appframework object
         * @title  $().show()
        */
        show(): appFrameworkCollection,

        /**
         * Toggle the visibility of a div
         * ```
        $().toggle();
        $().toggle(true); //force showing
        ```
         * @param  -force the hiding or showing of the element
         * @return  an appframework object
         * @title  $().toggle([show])
        */
        toggle(show?: boolean): appFrameworkCollection,

        /**
         * Gets or sets an elements value
         * If used as a getter, we return the first elements value.  If nothing is in the collection, we return undefined
        ```
        $().value; //Gets the first elements value;
        $().value="bar"; //Sets all elements value to bar
        ```
         * @param  to set
         * @return  A string as a getter, appframework object as a setter
         * @title  $().val([value])
        */
        val(): string,
        val(value: string): appFrameworkCollection,

        /**
         * Gets or sets an attribute on an element
         * If used as a getter, we return the first elements value.  If nothing is in the collection, we return undefined
        ```
        $().attr("foo"); //Gets the first elements 'foo' attribute
        $().attr("foo","bar");//Sets the elements 'foo' attribute to 'bar'
        $().attr("foo",{bar:'bar'}) //Adds the object to an internal cache
        ```
         * @param  to act upon.  If it's an object (hashmap), it will set the attributes based off the kvp.
         * @param  to set
         * @return  If used as a getter, return the attribute value.  If a setter, return an appframework object
         * @title  $().attr(attribute,[value])
        */
        attr(attribute: string): any,
        attr(attributeHash: AV$Object): appFrameworkCollection,
        attr(attribute: string, value: string): appFrameworkCollection,
        attr(attribute: string, value: any): appFrameworkCollection,

        /**
         * Removes an attribute on the elements
         * ```
        $().removeAttr("foo");
        ```
         * @param  that can be space delimited
         * @return  appframework object
         * @title  $().removeAttr(attribute)
        */
        removeAttr(attribute: string): appFrameworkCollection,

        /**
         * Gets or sets a property on an element
         * If used as a getter, we return the first elements value.  If nothing is in the collection, we return undefined
        ```
        $().prop("foo"); //Gets the first elements 'foo' property
        $().prop("foo","bar");//Sets the elements 'foo' property to 'bar'
        $().prop("foo",{bar:'bar'}) //Adds the object to an internal cache
        ```
         * @param  to act upon.  If it's an object (hashmap), it will set the attributes based off the kvp.
         * @param  to set
         * @return  If used as a getter, return the property value.  If a setter, return an appframework object
         * @title  $().prop(property,[value])
        */
        prop(attribute: string): any,
        prop(attributeHash: AV$Object): appFrameworkCollection,
        prop(attribute: string, value: string): appFrameworkCollection,
        prop(attribute: string, value: any): appFrameworkCollection,

        /**
         * Removes a property on the elements
         * ```
        $().removeProp("foo");
        ```
         * @param  that can be space delimited
         * @return  appframework object
         * @title  $().removeProp(attribute)
        */
        removeProp(attribute: string): appFrameworkCollection,

        /**
         * Removes elements based off a selector
         * ```
        $().remove();  //Remove all
        $().remove(".foo");//Remove off a string selector
        var element=$("#foo").get(0);
        $().remove(element); //Remove by an element
        $().remove($(".foo"));  //Remove by a collection

        ```
         * @param  to filter against
         * @return  appframework object
         * @title  $().remove(selector)
        */
        remove(): appFrameworkCollection,
        remove(selector: string): appFrameworkCollection,
        remove(element: HTMLElement): appFrameworkCollection,
        remove(elements: any[]): appFrameworkCollection,
        remove(elements: appFrameworkCollection): appFrameworkCollection,

        /**
         * Adds a css class to elements.
         * ```
        $().addClass("selected");
        ```
         * @param  that are space delimited
         * @return  appframework object
         * @title  $().addClass(name)
        */
        addClass(className: string): appFrameworkCollection,

        /**
         * Removes a css class from elements.
         * ```
        $().removeClass("foo"); //single class
        $().removeClass("foo selected");//remove multiple classess
        ```
         * @param  that are space delimited
         * @return  appframework object
         * @title  $().removeClass(name)
        */
        removeClass(className: string): appFrameworkCollection,

        /**
         * Adds or removes a css class to elements.
         *    ```
           $().toggleClass("selected");
           ```
         * @param  that are space delimited
         * @param  force toggle to add or remove classes
         * @return  appframework object
         * @title  $().toggleClass(name)
        */
        toggleClass(name: string, state?: boolean): appFrameworkCollection,

        /**
         * Replaces a css class on elements.
         * ```
        $().replaceClass("on", "off");
        ```
         * @param  that are space delimited
         * @param  that are space delimited
         * @return  appframework object
         * @title  $().replaceClass(old, new)
        */
        replaceClass(oldClassName: string, newClassName: string): appFrameworkCollection,

        /**
         * Checks to see if an element has a class.
         * ```
        $().hasClass('foo');
        $().hasClass('foo',element);
        ```
         * @param  name to check against
         * @param  to check against
         * @return  * 
         * @title  $().hasClass(name,[element])
        */
        hasClass(className: string, element: HTMLElement): boolean,

        /**
         * Appends to the elements
         * We boil everything down to an appframework object and then loop through that.
        If it's HTML, we create a dom element so we do not break event bindings.
        if it's a script tag, we evaluate it.
        ```
        $().append("<div></div>"); //Creates the object from the string and appends it
        $().append($("#foo")); //Append an object;
        ```
         * @param  /string to add
         * @param  insert or append
         * @return  appframework object
         * @title  $().append(element,[insert])
        */
        append(content: any): appFrameworkCollection,

        /**
         * Appends the current collection to the selector
         * ```
        $().appendTo("#foo"); //Append an object;
        ```
         * @param  to append to
         * @param  insert or append
         * @title  $().appendTo(element,[insert])
        */
        appendTo(target: any): appFrameworkCollection,

        /**
         * Prepends the current collection to the selector
         * ```
        $().prependTo("#foo"); //Prepend an object;
        ```
         * @param  to prepent to
         * @title  $().prependTo(element)
        */
        prependTo(target: any): appFrameworkCollection,

        /**
         * Prepends to the elements
         * This simply calls append and sets insert to true
        ```
        $().prepend("<div></div>");//Creates the object from the string and appends it
        $().prepend($("#foo")); //Prepends an object
        ```
         * @param  /string to add
         * @return  appframework object
         * @title  $().prepend(element)
        */
        prepend(content: any): appFrameworkCollection,

        /**
         * Inserts collection before the target (adjacent)
         * ```
        $().insertBefore(af("#target"));
        ```
         * @param  
         * @title  $().insertBefore(target);
        */
        insertBefore(target: any): appFrameworkCollection,

        /**
         * Inserts collection after the target (adjacent)
         * ```
        $().insertAfter(af("#target"));
        ```
         * @param  
         * @title  $().insertAfter(target);
        */
        insertAfter(target: any): void,

        /**
         * Returns the raw DOM element.
         * ```
        $().get(0); //returns the first element
        $().get(2);// returns the third element
        ```
         * @param  * 
         * @return  raw DOM element
         * @title  $().get([index])
        */
        get(): HTMLElement[],
        get(index: number): HTMLElement,

        /**
         * Returns the offset of the element, including traversing up the tree
         * ```
        $().offset();
        ```
         * @return  with left, top, width and height properties
         * @title  $().offset()
        */
        offset(): {
            left: number,
            top: number,
            right: number,
            bottom: number,
            width: number,
            height: number
        },

        /**
         * returns the height of the element, including padding on IE
         * ```
        $().height();
        ```
         * @return  height
         * @title  $().height()
        */
        height(): string,

        /**
         * returns the width of the element, including padding on IE
         * ```
        $().width();
        ```
         * @return  width
         * @title  $().width()
        */
        width(): string,

        /**
         * Returns the parent nodes of the elements based off the selector
         * ```
        $("#foo").parent('.bar');
        $("#foo").parent($('.bar'));
        $("#foo").parent($('.bar').get(0));
        ```
         * @param  * 
         * @return  appframework object with unique parents
         * @title  $().parent(selector)
        */
        parent(selector?: any): appFrameworkCollection,

        /**
         * Returns the parents of the elements based off the selector (traversing up until html document)
         * ```
        $("#foo").parents('.bar');
        $("#foo").parents($('.bar'));
        $("#foo").parents($('.bar').get(0));
        ```
         * @param  * 
         * @return  appframework object with unique parents
         * @title  $().parents(selector)
        */
        parents(selector?: any): appFrameworkCollection,

        /**
         * Returns the child nodes of the elements based off the selector
         * ```
        $("#foo").children('.bar'); //Selector
        $("#foo").children($('.bar')); //Objects
        $("#foo").children($('.bar').get(0)); //Single element
        ```
         * @param  * 
         * @return  appframework object with unique children
         * @title  $().children(selector)
        */
        children(selector?: any): appFrameworkCollection,

        /**
         * Returns the siblings of the element based off the selector
         * ```
        $("#foo").siblings('.bar'); //Selector
        $("#foo").siblings($('.bar')); //Objects
        $("#foo").siblings($('.bar').get(0)); //Single element
        ```
         * @param  * 
         * @return  appframework object with unique siblings
         * @title  $().siblings(selector)
        */
        siblings(selector?: any): appFrameworkCollection,

        /**
         * Returns the closest element based off the selector and optional context
         * ```
        $("#foo").closest('.bar'); //Selector
        $("#foo").closest($('.bar')); //Objects
        $("#foo").closest($('.bar').get(0)); //Single element
        ```
         * @param  
         * @param  * 
         * @return  Returns an appframework object with the closest element based off the selector
         * @title  $().closest(selector,[context]);
        */
        closest(selector?: any): appFrameworkCollection,

        /**
         * Filters elements based off the selector
         * ```
        $("#foo").filter('.bar'); //Selector
        $("#foo").filter($('.bar')); //Objects
        $("#foo").filter($('.bar').get(0)); //Single element
        ```
         * @param  
         * @return  Returns an appframework object after the filter was run
         * @title  $().filter(selector);
        */
        filter(selector?: any): appFrameworkCollection,

        /**
         * Basically the reverse of filter.  Return all elements that do NOT match the selector
         * ```
        $("#foo").not('.bar'); //Selector
        $("#foo").not($('.bar')); //Objects
        $("#foo").not($('.bar').get(0)); //Single element
        ```
         * @param  
         * @return  Returns an appframework object after the filter was run
         * @title  $().not(selector);
        */
        not(selector?: any): appFrameworkCollection,

        /**
         * Gets or set data- attribute parameters on elements (when a string)
         * When used as a getter, it's only the first element
        ```
        $().data("foo"); //Gets the data-foo attribute for the first element
        $().data("foo","bar"); //Sets the data-foo attribute for all elements
        $().data("foo",{bar:'bar'});//object as the data
        ```
         * @param  
         * @param  
         * @return  returns the value or appframework object
         * @title  $().data(key,[value]);
        */
        data(attribute: string): any,
        data(attribute: string, value: string): appFrameworkCollection,
        data(attribute: string, value: any): appFrameworkCollection,

        /**
         * Rolls back the appframework elements when filters were applied
         * This can be used after .not(), .filter(), .children(), .parent()
        ```
        $().filter(".panel").end(); //This will return the collection BEFORE filter is applied
        ```
         * @return  returns the previous appframework object before filter was applied
         * @title  $().end();
        */
        end(): appFrameworkCollection,

        /**
         * Clones the nodes in the collection.
         * ```
        $().clone();// Deep clone of all elements
        $().clone(false); //Shallow clone
        ```
         * @param  - do a deep copy or not
         * @return  appframework object of cloned nodes
         * @title  $().clone();
        */
        clone(deep?: boolean): appFrameworkCollection,

        /**
         * Returns the number of elements in the collection
         * ```
        $().size();
        ```
         * @return  * 
         * @title  $().size();
        */
        size(): number,

        /**
         * Serailizes a form into a query string
         * ```
        $().serialize();
        ```
         * @return  * 
         * @title  $().serialize()
        */
        serialize(): string,

        /**
         * Reduce the set of elements based off index
         * ```
        $().eq(index)
        ```
         * @param  - Index to filter by. If negative, it will go back from the end
         * @return  appframework object
         * @title  $().eq(index)
        */
        eq(index: number): appFrameworkCollection,

        /**
         * Returns the index of the selected element in the collection
         * ```
        $().index(elem)
        ```
         * @param  to look for.  Can be a selector or object
         * @return  integer - index of selected element
         * @title  $().index(elem)
        */
        index(): number,
        index(selector: any): number,

        /**
         * Returns boolean if the object is a type of the selector
         * ```
        $().is(selector)
        ```
        param {String|Object} selector to act upon
         * @return  boolean
         * @title  $().is(selector)
        */
        is(selector: any): number,

        /**
         * Binds an event to each element in the collection and executes the callback
         * ```
        $().bind('click',function(){console.log('I clicked '+this.id);});
        ```
         * @param  
         * @param  
         * @return  appframework object
         * @title  $().bind(event,callback)
        */
        bind(eventHash: AV$Object): appFrameworkCollection,
        bind(eventName: string, fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Unbinds an event to each element in the collection.  If a callback is passed in, we remove just that one, otherwise we remove all callbacks for those events
         * ```
        $().unbind('click'); //Unbinds all click events
        $().unbind('click',myFunc); //Unbinds myFunc
        ```
         * @param  
         * @param  * 
         * @return  appframework object
         * @title  $().unbind(event,[callback]);
        */
        unbind(eventHash: {}): appFrameworkCollection,
        unbind(eventName?: string): appFrameworkCollection,
        unbind(eventName: string, fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Binds an event to each element in the collection that will only execute once.  When it executes, we remove the event listener then right away so it no longer happens
         * ```
        $().one('click',function(){console.log('I was clicked once');});
        ```
         * @param  
         * @param  * 
         * @return  appframework object
         * @title  $().one(event,callback);
        */
        one(eventHash: {}): appFrameworkCollection,
        one(eventName: string, fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Delegate an event based off the selector.  The event will be registered at the parent level, but executes on the selector.
         * ```
        $("#div").delegate("p",'click',callback);
        ```
         * @param  
         * @param  
         * @param  
         * @return  appframework object
         * @title  $().delegate(selector,event,callback)
        */
        delegate(selector: any, eventHash: {}): appFrameworkCollection,
        delegate(
            selector: any,
            eventName: string,
            fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Unbinds events that were registered through delegate.  It acts upon the selector and event.  If a callback is specified, it will remove that one, otherwise it removes all of them.
         * ```
        $("#div").undelegate("p",'click',callback);//Undelegates callback for the click event
        $("#div").undelegate("p",'click');//Undelegates all click events
        ```
         * @param  
         * @param  
         * @param  
         * @return  appframework object
         * @title  $().undelegate(selector,event,[callback]);
        */
        undelegate(selector: any, eventHash: {}): appFrameworkCollection,
        undelegate(
            selector: any,
            eventName: string,
            fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Similar to delegate, but the function parameter order is easier to understand.
         * If selector is undefined or a function, we just call .bind, otherwise we use .delegate
        ```
        $("#div").on("click","p",callback);
        ```
         * @param  
         * @param  
         * @param  
         * @return  appframework object
         * @title  $().on(event,selector,callback);
        */
        on(eventHash: {}, selector?: any): appFrameworkCollection,
        on(eventName: string, fn: (e: autobahn$Event) => any): appFrameworkCollection,
        on(
            eventName: string,
            selector: string,
            fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * Removes event listeners for .on()
         * If selector is undefined or a function, we call unbind, otherwise it's undelegate
        ```
        $().off("click","p",callback); //Remove callback function for click events
        $().off("click","p") //Remove all click events
        ```
         * @param  
         * @param  
         * @param  
         * @return  appframework object
         * @title  $().off(event,selector,[callback])
        */
        off(eventHash: {}, selector?: any): appFrameworkCollection,
        off(eventName: string, fn: (e: autobahn$Event) => any): appFrameworkCollection,
        off(
            eventName: string,
            selector: string,
            fn: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * This triggers an event to be dispatched.  Usefull for emulating events, etc.
         * ```
        $().trigger("click",{foo:'bar'});//Trigger the click event and pass in data
        ```

         
         * @param  
         * @param  * 
         * @return  appframework object
         * @title  $().trigger(event,data);
        */
        trigger(eventName: string, data?: any): appFrameworkCollection,
        trigger(eventHash: {}, data?: any): appFrameworkCollection,

        /**
         * custom events since people want to do $().click instead of $().bind("click")
         */
        click(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().keydown instead of $().bind("keydown")
         */
        keydown(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().keyup instead of $().bind("keyup")
         */
        keyup(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().keypress instead of $().bind("keypress")
         */
        keypress(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().submit instead of $().bind("submit")
         */
        submit(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().load instead of $().bind("load")
         */
        load(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().resize instead of $().bind("resize")
         */
        resize(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().change instead of $().bind("change")
         */
        change(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().select instead of $().bind("select")
         */
        select(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().error instead of $().bind("error")
         */
        error(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().focus instead of $().bind("focus")
         */
        focus(fn?: (e: autobahn$Event) => any): appFrameworkCollection,

        /**
         * custom events since people want to do $().blur instead of $().bind("blur")
         */
        blur(fn?: (e: autobahn$Event) => any): appFrameworkCollection
}
declare interface appFrameworkAjaxSettings {
    type?: string,
        beforeSend?: (xhr: XMLHttpRequest, settings: appFrameworkAjaxSettings) => boolean,
        success?: (data: any, status: string, xhr: XMLHttpRequest) => void,
        error?: (xhr: XMLHttpRequest, errorType: string, error: error$Error) => void,
        complete?: (xhr: XMLHttpRequest, status: string) => void,
        timeout?: number,
        url?: string,
        contentType?: string,
        headers?: any,
        dataType?: string,
        data?: any,
        context?: any,
        crossDomain?: boolean
}
declare interface appFrameworkCssMatrix {
    a: number,
        b: number,
        c: number,
        d: number,
        e: number,
        f: number
}
declare var af: (fn: ($: appFrameworkStatic) => void) => void;
declare var $: appFrameworkStatic;
declare var App: AppleTVJS$App;
declare var Device: AppleTVJS$Device;
declare var navigationDocument: AppleTVJS$NavigationDocument;
declare var Settings: AppleTVJS$Settings;
declare function evaluateScripts(scripts: string[], complete: (success: boolean) => void): voiddeclare interface AppleTVJS$App {

    /**
     * The onError attribute is used to handle any errors sent from the device.
     * This attribute must be set to a function that accepts an “options” argument.
    For example App.onError = function (options) {}.
    */
    onError: (options: any) => void,

        /**
         * The onExit attribute is used to complete any actions that need to be cleaned
         * up when the app has been exited. This attribute must be set to a function that
        accepts an “options” argument. For example App.onExit = function (options) {}.
        */
        onExit: (options: any) => void,

        /**
         * The onLaunch attribute is used to start any required actions when the app
         * launches. This attribute must be set to a function that accepts an “options”
        argument. For example App.onLaunch = function (options) {}.
        */
        onLaunch: (options: any) => void,

        /**
         * This function reloads the initial JavaScript file without quitting the app.
         * The optional reloadData parameter provides developers with a way to capture
        and restart the app in it’s current state. If the reloadData parameter is not
        present, the app is restarted in its initial state. This attribute must be set
        to a function that accepts an “options” argument.
        For example App.onError = function (options) {}.
        */
        reload(options?: any, reloadData?: any): void
}

declare interface AppleTVJS$Device {

    /**
     * The unique identifier for the app. 
     */
    appIdentifier: string,

        /**
         * The current app version. 
         */
        appVersion: string,

        /**
         * A string that identifies the device model. 
         */
        model: string,

        /**
         * The version of the product installed on the device. 
         */
        productType: string,

        /**
         * The operating system on the device. 
         */
        systemVersion: string,

        /**
         * The UUID of the device. 
         */
        vendorIdentifier: string
}

declare type AppleTVJS$FeatureElement = {

    /**
     * Gets a feature for a given element. 
     */
    getFeature(feature: string): any
} & angularScenario$Element


declare class Highlight {

    /**
     * The name of the highlight. 
     */
    name: string;

    /**
     * The description of the highlight. 
     */
    description: string;

    /**
     * The starttime of the highlight. 
     */
    starttime: number;

    /**
     * The duration of the highlight. 
     */
    duration: number;

    /**
     * The imageURL of the highlight. 
     */
    imageURL: string
}

declare class HighlightGroup {

    /**
     * The name of the highlight group. 
     */
    name: string;

    /**
     * The hightlights in the highlight group. 
     */
    hightlights: AppleTVJS$Highlight[]
}

declare class Interstitial {

    /**
     * The starttime of the interstitial. 
     */
    starttime: number;

    /**
     * The duration of the interstitial. 
     */
    duration: number
}

declare interface AppleTVJS$Keyboard {

    /**
     * The text inside of a searchField or textField element. 
     */
    text: string,

        /**
         * A callback function that is called when the text inside
         * of searchField or textField element changes.
         */
        onTextChange: () => void
}

declare class MediaItem {

    /**
     * Creates a new MediaItem object from the information stored in the URL location.
     * @type  : Valid values are: audio, video. Defaults to video.
     * @url  : The URL pointing to the media item information.
     */
    constructor(type: string, url?: string): this;

    /**
     * The domain that the rating applies to.
     * There are three valid values for this property: movie, music, and tvshow.
     */
    contentRatingDomain: string;

    /**
     * The rating for a video item.
     * The rating is a value from 0-1000. This value corresponds to a specific rating
    used by different countries. For example, a rating value can represent a PG-13
    rating in the United State and a MA15+ in Australia.
    */
    contentRatingRanking: number;

    /**
     * A value indicating whether the item has explicit lyrics.
     * This property is ignored if the MediaItem object type is video.
     */
    isExplicit: boolean;

    /**
     * The URL path to the artwork that accompanies the media item. 
     */
    artworkImageURL: string;

    /**
     * The description for a media item. 
     */
    description: string;

    /**
     * The subtitle for a the media item. 
     */
    subtitle: string;

    /**
     * The title of the media item. 
     */
    title: string;

    /**
     * The type of media item.
     * The valid values for this attribute are audio and video.
     */
    type: string;

    /**
     * The URL path to the media item. 
     */
    url: string;

    /**
     * An array of highlightGroup objects. 
     */
    highlightGroups: AppleTVJS$HighlightGroup[];

    /**
     * An array of interstitial objects. 
     */
    interstitials: AppleTVJS$Interstitial[];

    /**
     * The number, in seconds, that a media item starts playing at.
     * Use this to begin playing a MediaItem object at a time other than
    at the beginning of the object. If this property contains anything
    other than 0, the player displays “Resume” instead of
    “Play from beginning” on playback.
    */
    resumeTime: number;

    /**
     * A callback function used to load the asset identifier for an item. 
     */
    loadAssetID: (url: string, callback: (assetID: string, error: string) => void) => void;

    /**
     * A callback function used to load the security certificate for an item. 
     */
    loadCertificate: (url: string, callback: (certificate: string, error: string) => void) => void;

    /**
     * A callback function used to load the security key for an item. 
     */
    loadKey: (
        url: string,
        requestData: any,
        callback: (key: string, renewalDate: string, error: string) => void) => void
}

declare interface AppleTVJS$MenuBarDocument {

    /**
     * Retrieves the document associated with the specified menu item.
     */
    getDocument(menuItem: angularScenario$Element): AceAjax$Document,

        /**
         * Associates a document with a menu item.
         */
        setDocument(document: AceAjax$Document, menuItem: angularScenario$Element): void,

        /**
         * Sets the focus in a menu bar to the specified menu item.
         */
        setSelectedItem(menuItem: angularScenario$Element): void
}

declare interface AppleTVJS$NavigationDocument {

    /**
     * Inserts a new document directly before a document currently on the stack.
     */
    insertBeforeDocument(document: AceAjax$Document, beforeDocument?: AceAjax$Document): void,

        /**
         * This function searches the stack for the first instance of the document
         * contained in the beforeDocument parameter and inserts the document contained
        in the document parameter on top of it.
        */
        pushDocument(document: AceAjax$Document): void,

        /**
         * Replaces a document on the stack with a new document.
         */
        replaceDocument(document: AceAjax$Document, beforeDocument?: AceAjax$Document): void,

        /**
         * Dismisses the document displayed in modal view. 
         */
        dismissModal(): void,

        /**
         * Displays the passed document on top of the current document.
         */
        presentModal(document: AceAjax$Document): void,

        /**
         * The documents currently on the stack. 
         */
        documents: AceAjax$Document[],

        /**
         * Removes all documents currently on the stack.
         */
        clear(): void,

        /**
         * Removes the top most document from the stack.
         */
        popDocument(): void,

        /**
         * Removes all of the documents on the stack that are above the passed document.
         */
        popToDocument(document: AceAjax$Document): void,

        /**
         * Removes all documents from the stack except for the bottom most document.
         */
        popToRootDocument(): void,

        /**
         * Removes the specified document from the stack.
         */
        removeDocument(document: AceAjax$Document): void
}

declare class Player {

    /**
     * The annotations for a video created by placing a DOM document over the video. 
     */
    overlayDocument: AceAjax$Document;

    /**
     * The play list for a player. 
     */
    playlist: AppleTVJS$Playlist;

    /**
     * Shows the player UI if it is not currently visible. 
     */
    present(): void;

    /**
     * Pauses the currently playing media item. 
     */
    pause(): void;

    /**
     * Plays the currently selected media item. 
     */
    play(): void;

    /**
     * The current state of the player.
     * 
    This property can contain the following valid values:
    begin
    end
    loading
    playing
    paused
    scanning
    */
    playbackState: string;

    /**
     * Sets the playback point to a specified time. 
     */
    seekToTime(time: number): void;

    /**
     * Sets the playback speed. 
     */
    setPlaybackRate(playbackRate: number): void;

    /**
     * Stops the currently playing item and dismisses the player UI. 
     */
    stop(): void;

    /**
     * The currently selected media item in the playlist. 
     */
    currentMediaItem: AppleTVJS$MediaItem;

    /**
     * The next media item in the playlist. 
     */
    nextMediaItem: AppleTVJS$MediaItem;

    /**
     * The previous MediaItem object in the playlist. 
     */
    previousMediaItem: AppleTVJS$MediaItem;

    /**
     * An event notifying the listener that the player is about to change media items.
     * 
    Valid values are:
    errorDidOccur
    fastForwardedToEndOfMediaItem
    mannuallyChanged
    newPlaylist
    playerInvalidated
    playedToEndOfMediaItem
    */
    mediaItemDidChange: (reason: string) => void;

    /**
     * An event that indicates if a seek to time request was accomplished.
     * 
    The values for this attribute can be one of the following:
    true — The seek performed as requested.
    false or null— The seek was not performed.
    An integer value — The seek will be performed to the stated value and not the initial requested value.
    */
    requestSeekToTime: (result?: any) => void;

    /**
     * An event that indicates a state change request has occurred. 
     */
    shouldHandleStateChange: (result: boolean) => void;

    /**
     * An event that indicates the state has changed. 
     */
    stateDidChange: () => void;

    /**
     * An event that indicates the state is about to change. 
     */
    stateWillChange: () => void;

    /**
     * An event that indicates a particular playback time has been crossed. 
     */
    timeBoundaryDidCross: () => void;

    /**
     * An event that happens at a specified interval. 
     */
    timeDidChange: () => void;

    /**
     * An event that happens whenever a specified piece of metadata occurs. 
     */
    timedMetadata: () => void
}

declare class Playlist {

    /**
     * Returns the MediaItem located in the indicated array index. 
     */
    item(index: number): AppleTVJS$MediaItem;

    /**
     * The number of items in the playlist. 
     */
    length: number;

    /**
     * Removes a media item from the end of a playlist. 
     */
    pop(): AppleTVJS$MediaItem;

    /**
     * Adds a media item to the end of a playlist. 
     */
    push(object: AppleTVJS$MediaItem): void;

    /**
     * Deletes the indicated array elements and replaces them with the specified elements. 
     */
    splice(
        index: number,
        howManu: number,
        object: AppleTVJS$MediaItem): AppleTVJS$MediaItem[]
}

declare interface AppleTVJS$Restrictions {

    /**
     * A boolean value that indicates if explicit media is allowed. 
     */
    allowsExplicit: boolean,

        /**
         * The maximum movie ranking allowed. 
         */
        maxMovieRank: number,

        /**
         * The maximum movie rating allowed for the specified country. 
         */
        maxMovieRatingForCountry(countryCode: string): string,

        /**
         * The maximum television show ranking allowed. 
         */
        maxTVShowRank: number,

        /**
         * Sets the maximum television show rating allowed for the specified country. 
         */
        maxTVShowRatingForCountry(countryCode: string): string
}

declare interface AppleTVJS$Settings {

    /**
     * Contains the restriction information on the device. 
     */
    restrictions: AppleTVJS$Restrictions,

        /**
         * Contains the language the device displays information in. 
         */
        language: string,

        /**
         * Contains the country code used by the store on this device. 
         */
        storefrontCountryCode: string,

        /**
         * Called when changes to a device’s restriction information changes.
         */
        onRestrictionsChange: () => void
}

declare class TVError {

    /**
     * The error code. 
     */
    code: string;

    /**
     * A string containing the description of the error. 
     */
    description: string;

    /**
     * A string containing the error domain.
     * 
    The predefined error domains:
    NSPOSIXErrorDomain - POSIX/BSD errors
    NSOSStatusErrorDomain - OS X/Carbon errors
    NSMachErrorDomain - Mach errors
    */
    domain: string;

    /**
     * The user info dictionary.
     * 
    These keys may exist in the user info dictionary:
    NSLocalizedDesciptionKey
    NSFilePathErrorKey
    NSStringEncodingErrorKey
    NSUnderlyingErrorKey
    NSURLErrorKey
    NSLocalizedFailureReasonErrorKey
    NSLocalizedRecoverySuggestionErrorKey
    NSLocalizedRecoveryOptionsErrorKey
    NSRecoveryAttempterErrorKey
    NSHelpAnchorErrorKey
    NSURLErrorFailingURLErrorKey
    NSURLErrorFailingURLStringErrorKey
    NSURLErrorFailingURLPeerTrustErrorKey
    */
    userInfo: any
}
declare module 'AI' {
    declare class StackFrame {
        level: number;
        method: string;
        assembly: string;
        fileName: string;
        line: number;
        constructor(): this
    }
    declare class ExceptionDetails {
        id: number;
        outerId: number;
        typeName: string;
        message: string;
        hasFullStack: boolean;
        stack: string;
        parsedStack: ContractsModule$StackFrame[];
        constructor(): this
    }
    declare class DataPoint {
        name: string;
        kind: AI.DataPointType;
        value: number;
        count: number;
        min: number;
        max: number;
        stdDev: number;
        constructor(): this
    }
    declare class EventData mixins undefined.Domain {
        ver: number;
        name: string;
        properties: any;
        measurements: any;
        constructor(): this
    }
    declare class PageViewData mixins AI.EventData {
        ver: number;
        url: string;
        name: string;
        duration: string;
        referrer: string;
        referrerData: string;
        properties: any;
        measurements: any;
        constructor(): this
    }
    declare class PageViewPerfData mixins AI.PageViewData {
        ver: number;
        url: string;
        perfTotal: string;
        name: string;
        duration: string;
        networkConnect: string;
        referrer: string;
        sentRequest: string;
        referrerData: string;
        receivedResponse: string;
        domProcessing: string;
        properties: any;
        measurements: any;
        constructor(): this
    }
    declare class RemoteDependencyData mixins undefined.Domain {
        ver: number;
        name: string;
        id: string;
        resultCode: string;
        kind: AI.DataPointType;
        value: number;
        count: number;
        min: number;
        max: number;
        stdDev: number;
        dependencyKind: AI.DependencyKind;
        success: boolean;
        async: boolean;
        dependencySource: AI.DependencySourceType;
        commandName: string;
        dependencyTypeName: string;
        properties: any;
        constructor(): this
    }
    declare class MessageData mixins undefined.Domain {
        ver: number;
        message: string;
        severityLevel: AI.SeverityLevel;
        properties: any;
        constructor(): this
    }
}
declare module 'Microsoft' {
    declare module 'ApplicationInsights' {
        declare module 'Context' {
            declare interface IApplication {

                /**
                 * The application version.
                 */
                ver: string,

                    /**
                     * The application build version.
                     */
                    build: string
            }
            declare interface IDevice {

                /**
                 * The type for the current device.
                 */
                type: string,

                    /**
                     * A device unique ID.
                     */
                    id: string,

                    /**
                     * The device OEM for the current device.
                     */
                    oemName: string,

                    /**
                     * The device model for the current device.
                     */
                    model: string,

                    /**
                     * The IANA interface type for the internet connected network adapter.
                     */
                    network: number,

                    /**
                     * The application screen resolution.
                     */
                    resolution: string,

                    /**
                     * The current display language of the operating system.
                     */
                    locale: string,

                    /**
                     * The IP address.
                     */
                    ip: string,

                    /**
                     * The device language.
                     */
                    language: string,

                    /**
                     * The OS name.
                     */
                    os: string,

                    /**
                     * The OS version.
                     */
                    osversion: string
            }
            declare interface ILocation {

                /**
                 * Client IP address for reverse lookup
                 */
                ip: string
            }
            declare interface IInternal {

                /**
                 * The SDK version used to create this telemetry item.
                 */
                sdkVersion: string,

                    /**
                     * The SDK agent version.
                     */
                    agentVersion: string
            }
            declare interface ISample {

                /**
                 * Sample rate
                 */
                sampleRate: number
            }
            declare interface ISession {

                /**
                 * The session ID.
                 */
                id: string,

                    /**
                     * The true if this is the first session
                     */
                    isFirst: boolean,

                    /**
                     * The date at which this guid was genereated.
                     * Per the spec the ID will be regenerated if more than acquisitionSpan milliseconds ellapse from this time.
                     */
                    acquisitionDate: number,

                    /**
                     * The date at which this session ID was last reported.
                     * This value should be updated whenever telemetry is sent using this ID.
                    Per the spec the ID will be regenerated if more than renewalSpan milliseconds elapse from this time with no activity.
                    */
                    renewalDate: number
            }
            declare interface IOperation {

                /**
                 * Operation id
                 */
                id: string,

                    /**
                     * Operation name
                     */
                    name: string,

                    /**
                     * Parent operation id
                     */
                    parentId: string,

                    /**
                     * Root operation id
                     */
                    rootId: string,

                    /**
                     * Synthetic source of the operation
                     */
                    syntheticSource: string
            }
            declare interface IUser {

                /**
                 * The telemetry configuration.
                 */
                config: any,

                    /**
                     * The user ID.
                     */
                    id: string,

                    /**
                     * Authenticated user id
                     */
                    authenticatedId: string,

                    /**
                     * The account ID.
                     */
                    accountId: string,

                    /**
                     * The account acquisition date.
                     */
                    accountAcquisitionDate: string,

                    /**
                     * The user agent string.
                     */
                    agent: string,

                    /**
                     * The store region.
                     */
                    storeRegion: string
            }
        }

        declare module 'Telemetry' {
            declare class Domain {
                constructor(): this
            }
            declare class Base {
                baseType: string;
                constructor(): this
            }
            declare class Data<TDomain>mixins undefined.Base {
                baseType: string;
                baseData: TDomain;
                constructor(): this
            }
            declare class Event mixins undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                ver: number;
                name: string;
                properties: any;
                measurements: any;
                aiDataContract: {
                    ver: undefined.FieldType,
                    name: undefined.FieldType,
                    properties: undefined.FieldType,
                    measurements: undefined.FieldType
                };

                /**
                 * Constructs a new instance of the EventTelemetry object
                 */
                constructor(name: string, properties?: AV$Object, measurements?: AV$Object): this
            }
            declare class Exception mixins undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                ver: number;
                handledAt: string;
                exceptions: AI.ExceptionDetails[];
                severityLevel: AI.SeverityLevel;
                problemId: string;
                crashThreadId: number;
                properties: any;
                measurements: any;
                aiDataContract: {
                    ver: undefined.FieldType,
                    handledAt: undefined.FieldType,
                    exceptions: undefined.FieldType,
                    severityLevel: undefined.FieldType,
                    properties: undefined.FieldType,
                    measurements: undefined.FieldType
                };

                /**
                 * Constructs a new isntance of the ExceptionTelemetry object
                 */
                constructor(exception: error$Error, handledAt?: string, properties?: AV$Object, measurements?: AV$Object, severityLevel?: AI.SeverityLevel): this;

                /**
                 * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
                 */
                CreateSimpleException(
                    message: string,
                    typeName: string,
                    assembly: string,
                    fileName: string,
                    details: string,
                    line: number,
                    handledAt?: string): Telemetry.Exception
            }
            declare class Metric mixins undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                ver: number;
                metrics: AI.DataPoint[];
                properties: any;
                aiDataContract: {
                    ver: undefined.FieldType,
                    metrics: undefined.FieldType,
                    properties: undefined.FieldType
                };

                /**
                 * Constructs a new instance of the MetricTelemetry object
                 */
                constructor(name: string, value: number, count?: number, min?: number, max?: number, properties?: AV$Object): this
            }
            declare class PageView mixins AI.PageViewData, undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                aiDataContract: {
                    ver: undefined.FieldType,
                    name: undefined.FieldType,
                    url: undefined.FieldType,
                    duration: undefined.FieldType,
                    properties: undefined.FieldType,
                    measurements: undefined.FieldType
                };

                /**
                 * Constructs a new instance of the PageEventTelemetry object
                 */
                constructor(name?: string, url?: string, durationMs?: number, properties?: any, measurements?: any): this
            }
            declare class PageViewPerformance mixins AI.PageViewPerfData, undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                aiDataContract: {
                    ver: undefined.FieldType,
                    name: undefined.FieldType,
                    url: undefined.FieldType,
                    duration: undefined.FieldType,
                    perfTotal: undefined.FieldType,
                    networkConnect: undefined.FieldType,
                    sentRequest: undefined.FieldType,
                    receivedResponse: undefined.FieldType,
                    domProcessing: undefined.FieldType,
                    properties: undefined.FieldType,
                    measurements: undefined.FieldType
                };

                /**
                 * Indicates whether this instance of PageViewPerformance is valid and should be sent
                 */
                getIsValid(): boolean;

                /**
                 * Gets the total duration (PLT) in milliseconds. Check getIsValid() before using this method.
                 */
                getDurationMs(): number;

                /**
                 * Constructs a new instance of the PageEventTelemetry object
                 */
                constructor(name: string, url: string, unused: number, properties?: any, measurements?: any): this;
                getPerformanceTiming(): PerformanceTiming;

                /**
                 * Returns true is window performance timing API is supported, false otherwise.
                 */
                isPerformanceTimingSupported(): PerformanceTiming;

                /**
                 * As page loads different parts of performance timing numbers get set. When all of them are set we can report it.
                 * Returns true if ready, false otherwise.
                 */
                isPerformanceTimingDataReady(): boolean;
                getDuration(start: any, end: any): number
            }
            declare class RemoteDependencyData mixins AI.RemoteDependencyData, undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                aiDataContract: {
                    id: undefined.FieldType,
                    ver: undefined.FieldType,
                    name: undefined.FieldType,
                    kind: undefined.FieldType,
                    value: undefined.FieldType,
                    count: undefined.FieldType,
                    min: undefined.FieldType,
                    max: undefined.FieldType,
                    stdDev: undefined.FieldType,
                    dependencyKind: undefined.FieldType,
                    success: undefined.FieldType,
                    async: undefined.FieldType,
                    dependencySource: undefined.FieldType,
                    commandName: undefined.FieldType,
                    dependencyTypeName: undefined.FieldType,
                    properties: undefined.FieldType,
                    resultCode: undefined.FieldType
                };

                /**
                 * Constructs a new instance of the RemoteDependencyData object
                 */
                constructor(id: string, absoluteUrl: string, commandName: string, value: number, success: boolean, resultCode: number, method?: string): this
            }
            declare class Trace mixins AI.MessageData, undefined.ISerializable {
                envelopeType: string;
                dataType: string;
                aiDataContract: {
                    ver: undefined.FieldType,
                    message: undefined.FieldType,
                    severityLevel: undefined.FieldType,
                    measurements: undefined.FieldType,
                    properties: undefined.FieldType
                };

                /**
                 * Constructs a new instance of the MetricTelemetry object
                 */
                constructor(message: string, properties?: AV$Object): this
            }
            declare module 'Common' {
                declare class Base mixins undefined.Base, undefined.ISerializable {

                    /**
                     * The data contract for serializing this object.
                     */
                    aiDataContract: {}
                }
                declare class Data<TDomain>mixins undefined.Data<TDomain>, undefined.ISerializable {

                    /**
                     * The data contract for serializing this object.
                     */
                    aiDataContract: {
                        baseType: FieldType,
                        baseData: FieldType
                    };

                    /**
                     * Constructs a new instance of telemetry data.
                     */
                    constructor(type: string, data: TDomain): this
                }
                declare class Envelope mixins IEnvelope {
                    ver: number;
                    name: string;
                    time: string;
                    sampleRate: number;
                    seq: string;
                    iKey: string;
                    flags: number;
                    deviceId: string;
                    os: string;
                    osVer: string;
                    appId: string;
                    appVer: string;
                    userId: string;
                    tags: any;
                    data: Base;

                    /**
                     * The data contract for serializing this object.
                     */
                    aiDataContract: any;

                    /**
                     * Constructs a new instance of telemetry data.
                     */
                    constructor(data: undefined.Base, name: string): this
                }
                declare class DataSanitizer {
                    sanitizeKeyAndAddUniqueness(key: any, map: any): any;
                    sanitizeKey(name: any): any;
                    sanitizeString(value: any): any;
                    sanitizeUrl(url: any): any;
                    sanitizeMessage(message: any): any;
                    sanitizeException(exception: any): any;
                    sanitizeProperties(properties: any): any;
                    sanitizeMeasurements(measurements: any): any;
                    padNumber(num: any): string
                }
            }

        }

        declare interface IConfig {
            instrumentationKey?: string,
                endpointUrl?: string,
                emitLineDelimitedJson?: boolean,
                accountId?: string,
                sessionRenewalMs?: number,
                sessionExpirationMs?: number,
                maxBatchSizeInBytes?: number,
                maxBatchInterval?: number,
                enableDebug?: boolean,
                disableExceptionTracking?: boolean,
                disableTelemetry?: boolean,
                verboseLogging?: boolean,
                diagnosticLogInterval?: number,
                samplingPercentage?: number,
                autoTrackPageVisitTime?: boolean,
                disableAjaxTracking?: boolean,
                overridePageViewDuration?: boolean,
                maxAjaxCallsPerView?: number,
                disableDataLossAnalysis?: boolean,
                disableCorrelationHeaders?: boolean,
                disableFlushOnBeforeUnload?: boolean,
                enableSessionStorageBuffer?: boolean,
                cookieDomain?: string,
                url?: string
        }
        declare interface ISerializable {

            /**
             * The set of fields for a serializeable object.
             * This defines the serialization order and a value of true/false
            for each field defines whether the field is required or not.
            */
            aiDataContract: any
        }
        declare type IEnvelope = {
            ver: number,
            name: string,
            time: string,
            sampleRate: number,
            seq: string,
            iKey: string,
            flags: number,
            deviceId: string,
            os: string,
            osVer: string,
            appId: string,
            appVer: string,
            userId: string,
            tags: {
                [name: string]: any
            }
        } & ISerializable

        declare interface ITelemetryContext {

            /**
             * The object describing a component tracked by this object.
             */
            application: Context.IApplication,

                /**
                 * The object describing a device tracked by this object.
                 */
                device: Context.IDevice,

                /**
                 * The object describing internal settings.
                 */
                internal: Context.IInternal,

                /**
                 * The object describing a location tracked by this object.
                 */
                location: Context.ILocation,

                /**
                 * The object describing a operation tracked by this object.
                 */
                operation: Context.IOperation,

                /**
                 * The object describing sampling settings.
                 */
                sample: Context.ISample,

                /**
                 * The object describing a user tracked by this object.
                 */
                user: Context.IUser,

                /**
                 * The object describing a session tracked by this object.
                 */
                session: Context.ISession,

                /**
                 * Adds telemetry initializer to the collection. Telemetry initializers will be called one by one
                 * before telemetry item is pushed for sending and in the order they were added.
                 */
                addTelemetryInitializer(telemetryInitializer: (envelope: undefined.IEnvelope) => boolean): any,

                /**
                 * Tracks telemetry object.
                 */
                track(envelope: undefined.IEnvelope): any
        }
        declare interface IAppInsights {
            config: AtomCore$IConfig,
                context: ITelemetryContext,
                queue: (() => void)[],

                /**
                 * Starts timing how long the user views a page or other item. Call this when the page opens.
                 * This method doesn't send any telemetry. Call {@link stopTrackTelemetry} to log the page when it closes.
                 * @param name A string that idenfities this item, unique within this HTML document. Defaults to the document title.
                 */
                startTrackPage(name?: string): any,

                /**
                 * Logs how long a page or other item was visible, after {@link startTrackPage}. Call this when the page closes.
                 * @param name The string you used as the name in startTrackPage. Defaults to the document title.
                 * @param url String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
                 * @param properties map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
                 * @param measurements map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
                 */
                stopTrackPage(
                    name?: string,
                    url?: string,
                    properties?: {
                        [name: string]: string
                    },
                    measurements?: {
                        [name: string]: number
                    }): any,

                /**
                 * Logs that a page or other item was viewed.
                 * @param name The string you used as the name in startTrackPage. Defaults to the document title.
                 * @param url String - a relative or absolute URL that identifies the page or other item. Defaults to the window location.
                 * @param properties map[string, string] - additional data used to filter pages and metrics in the portal. Defaults to empty.
                 * @param measurements map[string, number] - metrics associated with this page, displayed in Metrics Explorer on the portal. Defaults to empty.
                 * @param duration number - the number of milliseconds it took to load the page. Defaults to undefined. If set to default value, page load time is calculated internally.
                 */
                trackPageView(
                    name?: string,
                    url?: string,
                    properties?: {
                        [name: string]: string
                    },
                    measurements?: {
                        [name: string]: number
                    },
                    duration?: number): any,

                /**
                 * Start timing an extended event. Call {@link stopTrackEvent} to log the event when it ends.
                 * @param name A string that identifies this event uniquely within the document.
                 */
                startTrackEvent(name: string): any,

                /**
                 * Log an extended event that you started timing with {@link startTrackEvent}.
                 * @param name The string you used to identify this event in startTrackEvent.
                 * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
                 * @param measurements map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
                 */
                stopTrackEvent(
                    name: string,
                    properties?: {
                        [name: string]: string
                    },
                    measurements?: {
                        [name: string]: number
                    }): any,

                /**
                 * Log a user action or other occurrence.
                 * @param name A string to identify this event in the portal.
                 * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
                 * @param measurements map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
                 */
                trackEvent(
                    name: string,
                    properties?: {
                        [name: string]: string
                    },
                    measurements?: {
                        [name: string]: number
                    }): any,

                /**
                 * Log an AJAX request
                 * @param id Event id
                 * @param absoluteUrl Full url
                 * @param pathName Leave this parameter blank
                 * @param totalTime Total time it took for AJAX request to complete
                 * @param success Whether AJAX request succeeded or failed
                 * @param resultCode Result code returned from AJAX call
                 * @param method HTTP verb that was used (GET, POST)
                 */
                trackAjax(
                    id: string,
                    absoluteUrl: string,
                    pathName: string,
                    totalTime: number,
                    success: boolean,
                    resultCode: number,
                    method?: string): any,

                /**
                 * Log an exception you have caught.
                 * @param exception An Error from a catch clause, or the string error message.
                 * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
                 * @param measurements map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
                 * @param severityLevel AI.SeverityLevel - severity level
                 */
                trackException(
                    exception: error$Error,
                    handledAt?: string,
                    properties?: {
                        [name: string]: string
                    },
                    measurements?: {
                        [name: string]: number
                    },
                    severityLevel?: AI.SeverityLevel): any,

                /**
                 * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
                 * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
                telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
                 * @param name A string that identifies the metric.
                 * @param average Number representing either a single measurement, or the average of several measurements.
                 * @param sampleCount The number of measurements represented by the average. Defaults to 1.
                 * @param min The smallest measurement in the sample. Defaults to the average.
                 * @param max The largest measurement in the sample. Defaults to the average.
                */
                trackMetric(
                    name: string,
                    average: number,
                    sampleCount?: number,
                    min?: number,
                    max?: number,
                    properties?: {
                        [name: string]: string
                    }): any,

                /**
                 * Log a diagnostic message.
                 * @param message A message string
                 * @param properties map[string, string] - additional data used to filter traces in the portal. Defaults to empty.
                 */
                trackTrace(message: string, properties?: {
                    [name: string]: string
                }): any,

                /**
                 * Immediately send all queued telemetry.
                 */
                flush(): any,

                /**
                 * Sets the autheticated user id and the account id in this session.
                 * User auth id and account id should be of type string. They should not contain commas, semi-colons, equal signs, spaces, or vertical-bars.
                 * @param authenticatedUserId - The authenticated user id. A unique and persistent string that represents each authenticated user in the service.
                 * @param accountId - An optional string to represent the account associated with the authenticated user.
                 */
                setAuthenticatedUserContext(authenticatedUserId: string, accountId?: string): any,

                /**
                 * Clears the authenticated user id and the account id from the user context.
                 */
                clearAuthenticatedUserContext(): any,
                downloadAndSetup(config: undefined.IConfig): void,

                /**
                 * The custom error handler for Application Insights
                 * @param  - The error message
                 * @param  - The url where the error was raised
                 * @param  - The line number where the error was raised
                 * @param  - The column number for the line where the error was raised
                 * @param  - The Error object
                 */
                _onerror(
                    message: string,
                    url: string,
                    lineNumber: number,
                    columnNumber: number,
                    error: error$Error): any
        }
    }

    declare module 'Telemetry' {
        declare class Domain {
            constructor(): this
        }
        declare class Base {
            baseType: string;
            constructor(): this
        }
        declare class Data<TDomain>mixins undefined.Base {
            baseType: string;
            baseData: TDomain;
            constructor(): this
        }
        declare class Event mixins undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            ver: number;
            name: string;
            properties: any;
            measurements: any;
            aiDataContract: {
                ver: undefined.FieldType,
                name: undefined.FieldType,
                properties: undefined.FieldType,
                measurements: undefined.FieldType
            };

            /**
             * Constructs a new instance of the EventTelemetry object
             */
            constructor(name: string, properties?: AV$Object, measurements?: AV$Object): this
        }
        declare class Exception mixins undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            ver: number;
            handledAt: string;
            exceptions: AI.ExceptionDetails[];
            severityLevel: AI.SeverityLevel;
            problemId: string;
            crashThreadId: number;
            properties: any;
            measurements: any;
            aiDataContract: {
                ver: undefined.FieldType,
                handledAt: undefined.FieldType,
                exceptions: undefined.FieldType,
                severityLevel: undefined.FieldType,
                properties: undefined.FieldType,
                measurements: undefined.FieldType
            };

            /**
             * Constructs a new isntance of the ExceptionTelemetry object
             */
            constructor(exception: error$Error, handledAt?: string, properties?: AV$Object, measurements?: AV$Object, severityLevel?: AI.SeverityLevel): this;

            /**
             * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
             */
            CreateSimpleException(
                message: string,
                typeName: string,
                assembly: string,
                fileName: string,
                details: string,
                line: number,
                handledAt?: string): Telemetry.Exception
        }
        declare class Metric mixins undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            ver: number;
            metrics: AI.DataPoint[];
            properties: any;
            aiDataContract: {
                ver: undefined.FieldType,
                metrics: undefined.FieldType,
                properties: undefined.FieldType
            };

            /**
             * Constructs a new instance of the MetricTelemetry object
             */
            constructor(name: string, value: number, count?: number, min?: number, max?: number, properties?: AV$Object): this
        }
        declare class PageView mixins AI.PageViewData, undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            aiDataContract: {
                ver: undefined.FieldType,
                name: undefined.FieldType,
                url: undefined.FieldType,
                duration: undefined.FieldType,
                properties: undefined.FieldType,
                measurements: undefined.FieldType
            };

            /**
             * Constructs a new instance of the PageEventTelemetry object
             */
            constructor(name?: string, url?: string, durationMs?: number, properties?: any, measurements?: any): this
        }
        declare class PageViewPerformance mixins AI.PageViewPerfData, undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            aiDataContract: {
                ver: undefined.FieldType,
                name: undefined.FieldType,
                url: undefined.FieldType,
                duration: undefined.FieldType,
                perfTotal: undefined.FieldType,
                networkConnect: undefined.FieldType,
                sentRequest: undefined.FieldType,
                receivedResponse: undefined.FieldType,
                domProcessing: undefined.FieldType,
                properties: undefined.FieldType,
                measurements: undefined.FieldType
            };

            /**
             * Indicates whether this instance of PageViewPerformance is valid and should be sent
             */
            getIsValid(): boolean;

            /**
             * Gets the total duration (PLT) in milliseconds. Check getIsValid() before using this method.
             */
            getDurationMs(): number;

            /**
             * Constructs a new instance of the PageEventTelemetry object
             */
            constructor(name: string, url: string, unused: number, properties?: any, measurements?: any): this;
            getPerformanceTiming(): PerformanceTiming;

            /**
             * Returns true is window performance timing API is supported, false otherwise.
             */
            isPerformanceTimingSupported(): PerformanceTiming;

            /**
             * As page loads different parts of performance timing numbers get set. When all of them are set we can report it.
             * Returns true if ready, false otherwise.
             */
            isPerformanceTimingDataReady(): boolean;
            getDuration(start: any, end: any): number
        }
        declare class RemoteDependencyData mixins AI.RemoteDependencyData, undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            aiDataContract: {
                id: undefined.FieldType,
                ver: undefined.FieldType,
                name: undefined.FieldType,
                kind: undefined.FieldType,
                value: undefined.FieldType,
                count: undefined.FieldType,
                min: undefined.FieldType,
                max: undefined.FieldType,
                stdDev: undefined.FieldType,
                dependencyKind: undefined.FieldType,
                success: undefined.FieldType,
                async: undefined.FieldType,
                dependencySource: undefined.FieldType,
                commandName: undefined.FieldType,
                dependencyTypeName: undefined.FieldType,
                properties: undefined.FieldType,
                resultCode: undefined.FieldType
            };

            /**
             * Constructs a new instance of the RemoteDependencyData object
             */
            constructor(id: string, absoluteUrl: string, commandName: string, value: number, success: boolean, resultCode: number, method?: string): this
        }
        declare class Trace mixins AI.MessageData, undefined.ISerializable {
            envelopeType: string;
            dataType: string;
            aiDataContract: {
                ver: undefined.FieldType,
                message: undefined.FieldType,
                severityLevel: undefined.FieldType,
                measurements: undefined.FieldType,
                properties: undefined.FieldType
            };

            /**
             * Constructs a new instance of the MetricTelemetry object
             */
            constructor(message: string, properties?: AV$Object): this
        }
        declare module 'Common' {
            declare class Base mixins undefined.Base, undefined.ISerializable {

                /**
                 * The data contract for serializing this object.
                 */
                aiDataContract: {}
            }
            declare class Data<TDomain>mixins undefined.Data<TDomain>, undefined.ISerializable {

                /**
                 * The data contract for serializing this object.
                 */
                aiDataContract: {
                    baseType: FieldType,
                    baseData: FieldType
                };

                /**
                 * Constructs a new instance of telemetry data.
                 */
                constructor(type: string, data: TDomain): this
            }
            declare class Envelope mixins IEnvelope {
                ver: number;
                name: string;
                time: string;
                sampleRate: number;
                seq: string;
                iKey: string;
                flags: number;
                deviceId: string;
                os: string;
                osVer: string;
                appId: string;
                appVer: string;
                userId: string;
                tags: any;
                data: Base;

                /**
                 * The data contract for serializing this object.
                 */
                aiDataContract: any;

                /**
                 * Constructs a new instance of telemetry data.
                 */
                constructor(data: undefined.Base, name: string): this
            }
            declare class DataSanitizer {
                sanitizeKeyAndAddUniqueness(key: any, map: any): any;
                sanitizeKey(name: any): any;
                sanitizeString(value: any): any;
                sanitizeUrl(url: any): any;
                sanitizeMessage(message: any): any;
                sanitizeException(exception: any): any;
                sanitizeProperties(properties: any): any;
                sanitizeMeasurements(measurements: any): any;
                padNumber(num: any): string
            }
        }

    }

}
declare module 'applicationinsights-js' {
    declare     export var AppInsights: undefined.IAppInsights;
}
declare var appInsights: undefined.IAppInsights;
declare interface AutoCollectConsole {
    constructor(client: PayPalCordovaPlugin$Client): AutoCollectConsole,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface AutoCollectExceptions {
    constructor(client: PayPalCordovaPlugin$Client): AutoCollectExceptions,
        isInitialized(): boolean,
        enable(isEnabled: boolean): void
}
declare interface AutoCollectPerformance {
    constructor(client: PayPalCordovaPlugin$Client): AutoCollectPerformance,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface AutoCollectRequests {
    constructor(client: PayPalCordovaPlugin$Client): AutoCollectRequests,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface ContractsModule$ContextTagKeys {
    applicationVersion: string,
        applicationBuild: string,
        deviceId: string,
        deviceIp: string,
        deviceLanguage: string,
        deviceLocale: string,
        deviceModel: string,
        deviceNetwork: string,
        deviceOEMName: string,
        deviceOS: string,
        deviceOSVersion: string,
        deviceRoleInstance: string,
        deviceRoleName: string,
        deviceScreenResolution: string,
        deviceType: string,
        deviceMachineName: string,
        locationIp: string,
        operationId: string,
        operationName: string,
        operationParentId: string,
        operationRootId: string,
        operationSyntheticSource: string,
        operationIsSynthetic: string,
        sessionId: string,
        sessionIsFirst: string,
        sessionIsNew: string,
        userAccountAcquisitionDate: string,
        userAccountId: string,
        userAgent: string,
        userId: string,
        userStoreRegion: string,
        sampleRate: string,
        internalSdkVersion: string,
        internalAgentVersion: string,
        constructor(): ContractsModule$ContextTagKeys
}

declare interface ContractsModule$Domain {
    ver: number,
        properties: any,
        constructor(): ContractsModule$Domain
}

declare interface ContractsModule$Data<TDomain>{
    baseType: string,
    baseData: TDomain,
    constructor(): ContractsModule$Data<TDomain >
}

declare interface ContractsModule$Envelope {
    ver: number,
        name: string,
        time: string,
        sampleRate: number,
        seq: string,
        iKey: string,
        flags: number,
        deviceId: string,
        os: string,
        osVer: string,
        appId: string,
        appVer: string,
        userId: string,
        tags: {
            [key: string]: string
        },
        data: ContractsModule$Data<ContractsModule$Domain>,
        constructor(): ContractsModule$Envelope
}

declare type ContractsModule$EventData = {
    ver: number,
    name: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$EventData
}

declare type ContractsModule$MessageData = {
    ver: number,
    message: string,
    severityLevel: ContractsModule$SeverityLevel,
    properties: any,
    constructor(): ContractsModule$MessageData
}

declare type ContractsModule$ExceptionData = {
    ver: number,
    handledAt: string,
    exceptions: ContractsModule$ExceptionDetails[],
    severityLevel: ContractsModule$SeverityLevel,
    problemId: string,
    crashThreadId: number,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$ExceptionData
}

declare interface ContractsModule$StackFrame {
    level: number,
        method: string,
        assembly: string,
        fileName: string,
        line: number,
        constructor(): ContractsModule$StackFrame
}

declare interface ContractsModule$ExceptionDetails {
    id: number,
        outerId: number,
        typeName: string,
        message: string,
        hasFullStack: boolean,
        stack: string,
        parsedStack: ContractsModule$StackFrame[],
        constructor(): ContractsModule$ExceptionDetails
}

declare interface ContractsModule$DataPoint {
    name: string,
        kind: ContractsModule$DataPointType,
        value: number,
        count: number,
        min: number,
        max: number,
        stdDev: number,
        constructor(): ContractsModule$DataPoint
}

declare type ContractsModule$MetricData = {
    ver: number,
    metrics: ContractsModule$DataPoint[],
    properties: any,
    constructor(): ContractsModule$MetricData
}

declare type ContractsModule$PageViewData = {
    ver: number,
    url: string,
    name: string,
    duration: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$PageViewData
}

declare type ContractsModule$PageViewPerfData = {
    ver: number,
    url: string,
    perfTotal: string,
    name: string,
    duration: string,
    networkConnect: string,
    sentRequest: string,
    receivedResponse: string,
    domProcessing: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$PageViewPerfData
}

declare type ContractsModule$RemoteDependencyData = {
    ver: number,
    name: string,
    kind: ContractsModule$DataPointType,
    value: number,
    count: number,
    min: number,
    max: number,
    stdDev: number,
    dependencyKind: ContractsModule$DependencyKind,
    success: boolean,
    async: boolean,
    dependencySource: ContractsModule$DependencySourceType,
    commandName: string,
    dependencyTypeName: string,
    properties: any,
    constructor(): ContractsModule$RemoteDependencyData
}

declare type ContractsModule$AjaxCallData = {
    ver: number,
    url: string,
    ajaxUrl: string,
    name: string,
    duration: string,
    requestSize: number,
    responseSize: number,
    timeToFirstByte: string,
    timeToLastByte: string,
    callbackDuration: string,
    responseCode: string,
    success: boolean,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$AjaxCallData
}

declare type ContractsModule$RequestData = {
    ver: number,
    id: string,
    name: string,
    startTime: string,
    duration: string,
    responseCode: string,
    success: boolean,
    httpMethod: string,
    url: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$RequestData
}

declare type ContractsModule$SessionStateData = {
    ver: number,
    state: ContractsModule$SessionState,
    constructor(): ContractsModule$SessionStateData
}

declare type ContractsModule$PerformanceCounterData = {
    ver: number,
    categoryName: string,
    counterName: string,
    instanceName: string,
    kind: DataPointType,
    count: number,
    min: number,
    max: number,
    stdDev: number,
    value: number,
    properties: any,
    constructor(): ContractsModule$PerformanceCounterData
}
declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    /**
     * Represents the client portion of the response.
     */
declare export interface Client {
    paypal_sdk_version: string,
        environment: string,
        platform: string,
        product_name: string
}
declare interface Config {
    tenant?: string,
        clientId: string,
        redirectUri?: string,
        cacheLocation?: string,
        displayCall?: (urlNavigate: string) => any,
        correlationId?: string,
        loginResource?: string,
        resource?: string,
        endpoints?: any,
        extraQueryParameter?: string,
        postLogoutRedirectUri?: string
}
declare interface Context {
    callbackWaitsForEmptyEventLoop: boolean,
        logGroupName: string,
        logStreamName: string,
        functionName: string,
        memoryLimitInMB: string,
        functionVersion: string,
        invokeid: string,
        awsRequestId: string
}
declare interface Sender {
    constructor(
            getUrl: () => string,
            onSuccess?: (response: string) => void,
            onError?: (error: error$Error) => void): Sender,
        send(payload: any): void,
        saveOnCrash(payload: string): void,

        /**
         * enable caching events locally on error
         */
        enableCacheOnError(): void,

        /**
         * disable caching events locally on error
         */
        disableCacheOnError(): void
}
/**
 * The singleton meta interface for the default client of the client. This interface is used to setup/start and configure
 * the auto-collection behavior of the application insights module.
 */
declare interface ApplicationInsights {
    client: PayPalCordovaPlugin$Client,

        /**
         * Initializes a client with the given instrumentation key, if this is not specified, the value will be
         * read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY
         * @returns  /Client} a new client
         */
        getClient(instrumentationKey?: string): PayPalCordovaPlugin$Client,

        /**
         * Initializes the default client of the client and sets the default configuration
         * @param instrumentationKey the instrumentation key to use. Optional, if this is not specified, the value will be
        read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY
         * @returns  this interface
        */
        setup(instrumentationKey?: string): ApplicationInsights,

        /**
         * Starts automatic collection of telemetry. Prior to calling start no telemetry will be collected
         * @returns  this interface
         */
        start(): ApplicationInsights,

        /**
         * Sets the state of console tracking (enabled by default)
         * @param value if true console activity will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectConsole(value: boolean): ApplicationInsights,

        /**
         * Sets the state of exception tracking (enabled by default)
         * @param value if true uncaught exceptions will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectExceptions(value: boolean): ApplicationInsights,

        /**
         * Sets the state of performance tracking (enabled by default)
         * @param value if true performance counters will be collected every second and sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectPerformance(value: boolean): ApplicationInsights,

        /**
         * Sets the state of request tracking (enabled by default)
         * @param value if true requests will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectRequests(value: boolean): ApplicationInsights,

        /**
         * Enables verbose debug logging
         * @returns  this interface
         */
        enableVerboseLogging(): ApplicationInsights
}
declare module 'applicationinsights' {
    declare     var applicationinsights: ApplicationInsights;
    declare module.exports: typeof applicationinsights
}
declare export interface ArbiterDef$SubscribeHandler {
    (data: any, message: string, subscriber_context: any): void
}

declare export interface ArbiterDef$SubscribeOptions {

    /**
     * By default, all subscribers have a priority of 0. Higher values get higher
     * priority and are executed first. Negative values are allowed.
     */
    priority?: number,

        /**
         * A subscriber can be set to execute asynchronously, even if the message wasn't published as async.
         */
        async?: boolean,

        /**
         * If your subscriber is not interested in any past messages that may have been
         * persisted, you can force them to be ignored.
         */
        persist?: boolean
}

declare export interface ArbiterDef$PublishOptions {

    /**
     * By default, subscribers can return "false" to prevent subsequent subscribers from
     * receiving the message. By passing cancelable:false in the options, the publisher
    can prevent canceling.
    */
    cancelable?: boolean,

        /**
         * If the publishers wants subscribers to be notified even if they subscribe later,
         * setting the persist flag will do that.
         */
        persist?: boolean,

        /**
         * If you wish to notify the subscribers but return from the publish() call before
         * the subscriber functions execute, use asynchronous mode
         */
        async?: boolean
}

declare export interface ArbiterDef$ArbiterStatic {
    version: string,
        updated_on: string,

        /**
         * Creates a separate Arbiter instance.
         */
        create(): ArbiterDef$ArbiterStatic,

        /**
         * Publishes a message to all subscribers.
         * Returns: true on success, false if any subscriber has thrown a js exception.
         * @param msg Message may be in any format, but may not contain [ ,*]. A structure like a/b/c is recommended by convention, to allow messages to be categorized.
         * @param data Pass data to subscribers that contains details about the message.
         */
        publish(msg: string, data?: any, options?: ArbiterDef$PublishOptions): boolean,

        /**
         * Subscribes to messages.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         * @param msg comma separated messages or use wildcard like a/b/*
         */
        subscribe(msg: string, func: ArbiterDef$SubscribeHandler): any,

        /**
         * Subscribes to messages.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         * @param msg comma separated messages or use wildcard like a/b/*
         */
        subscribe(
            msg: string,
            options: ArbiterDef$SubscribeOptions,
            func: ArbiterDef$SubscribeHandler): any,

        /**
         * Subscribes to messages. Can use comma separated or wildcards in message.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         */
        subscribe(
            msg: string,
            options: ArbiterDef$SubscribeOptions,
            context: any,
            func: ArbiterDef$SubscribeHandler): any,

        /**
         * Subscribes to messages.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         * @param msg comma separated messages or use wildcard like a/b/*
         */
        subscribe(msg: string[], func: ArbiterDef$SubscribeHandler): any,

        /**
         * Subscribes to messages.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         * @param msg comma separated messages or use wildcard like a/b/*
         */
        subscribe(
            msg: string[],
            options: ArbiterDef$SubscribeOptions,
            func: ArbiterDef$SubscribeHandler): any,

        /**
         * Subscribes to messages.
         * Returns: subscription id or [id1,id2] if subscribing to multiple messages
         * @param msg comma separated messages or use wildcard like a/b/*
         */
        subscribe(
            msg: string[],
            options: ArbiterDef$SubscribeOptions,
            context: any,
            func: ArbiterDef$SubscribeHandler): any,

        /**
         * Unsubscribing simply sets a flag which prevents the subscriber from executing, in case you want to re-subscribe later.
         */
        unsubscribe(subscription_id: number): boolean,

        /**
         * After unsubscribing, you can later re-subscribe to begin receiving messages again.
         */
        resubscribe(subscription_id: number): boolean
}
declare var Arbiter: ArbiterDef$ArbiterStatic;
declare module 'esri' {
    declare     export type AGSMouseEvent = {
        graphic?: Graphic,
        mapPoint: Point,
        screenPoint: ScreenPoint
    } & MouseEvent

    declare     export interface AddOptions {

        /**
         * The features that were added to the feature layer. 
         */
        addedGraphics?: Graphic[],

            /**
             * The feature layer where the new feature(s) are added. 
             */
            featureLayer?: FeatureLayer
    }
    declare     export interface AggregatePointsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * A field name from pointLayer based on which the points will be grouped. 
             */
            groupByField?: string,

            /**
             * When true, the polygons that have no points within them will be returned in the output. 
             */
            keepBoundariesWithNoPoints?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The point feature layer that will be aggregated into the polygons in the polygon feature layer. 
             */
            pointLayer: FeatureLayer,

            /**
             * The polygon layer to be shown selected in in the Choose area menu. 
             */
            polygonLayer: FeatureLayer,

            /**
             * An array of feature layer candidates to be selected as the input polygon layer. 
             */
            polygonLayers: FeatureLayer[],

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of attribute field names and statistic types that you would like to aggregate for all points within each polygon. 
             */
            summaryFields?: string[]
    }
    declare     export interface ArcGISDynamicMapServiceLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string,

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * Represents the image parameter options. 
             */
            imageParameters?: ImageParameters,

            /**
             * infoTemplates object. 
             */
            infoTemplates?: any,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * By default, images are exported in MIME format, and the image is streamed to the client. 
             */
            useMapImage?: boolean,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface ArcGISImageServiceLayerOptions {

        /**
         * Id to assign to the layer. 
         */
        id?: string,

            /**
             * The image service parameter options used when exporting an Image Service layer. 
             */
            imageServiceParameters?: ImageServiceParameters,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a raster. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * By default, images are exported in MIME format, and the image is streamed to the client. 
             */
            useMapImage?: boolean,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface ArcGISImageServiceVectorLayerOptions {

        /**
         * Apply a function for visualization or post-processing purposes. 
         */
        pixelFilter?: any,

            /**
             * Set the default renderer from a list of predefined options. 
             */
            rendererStyle?: string,

            /**
             * A value used to aggregate pixels into tiles for visualization purposes. 
             */
            symbolTileSize?: number
    }
    declare     export interface ArcGISTiledMapServiceLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Lists which levels to draw. 
             */
            displayLevels?: number[],

            /**
             * An array of objects that define areas where a tiled map service should not display tiles. 
             */
            exclusionAreas?: any[],

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * infoTemplates object. 
             */
            infoTemplates?: any,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * The purpose of resampling is to enlarge the image and fill in at the levels where there are no tiles available. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * Array of REST endpoints that can be used to retrieve tile images. 
             */
            tileServers?: string[],

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface AttributeInspectorOptions {

        /**
         * See the object specifications table below for the structure of the layerInfos  object. 
         */
        layerInfos: any[]
    }
    declare     export interface AttributionOptions {

        /**
         * String used as the delimiter between attribution items. 
         */
        itemDelimiter?: string,

            /**
             * Reference to the map object. 
             */
            map: Map
    }
    declare     export interface BasemapGalleryOptions {

        /**
         * List of basemap layer ids in the current map. 
         */
        basemapIds?: string[],

            /**
             * An array of user-defined basemaps to display in the BasemapGallery. 
             */
            basemaps?: Basemap[],

            /**
             * Specify an ArcGIS.com group that contains web maps that will be used as basemaps in the gallery. 
             */
            basemapsGroup?: any,

            /**
             * Specify your Bing Maps key if the basemap group you want to display in the gallery contains bing basemaps. 
             */
            bingMapsKey?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Specify the portal url, including the instance name, used to access the group that contains the basemap gallery items. 
             */
            portalUrl?: string,

            /**
             * List of reference layer ids in the current map. 
             */
            referenceIds?: string[],

            /**
             * When true, queries ArcGIS.com to retrieve available basemaps. 
             */
            showArcGISBasemaps?: boolean
    }
    declare     export interface BasemapLayerOptions {

        /**
         * If the url points to an image service, you can specify which band ids will display. 
         */
        bandIds?: number[],

            /**
             * The attribution information for the layer. 
             */
            copyright?: string,

            /**
             * If the url points to a cached map service you can specify the levels to draw. 
             */
            displayLevels?: number[],

            /**
             * Specify the full extent of the layer. 
             */
            fullExtent?: Extent,

            /**
             * Specify the initial extent of the layer. 
             */
            initialExtent?: Extent,

            /**
             * Set to true if the layer is a reference layer and should be drawn on top of all other layers in the map. 
             */
            isReference?: boolean,

            /**
             * Initial opacity or transparency of the basemap layer. 
             */
            opacity?: number,

            /**
             * Specify subDomains where tiles are served to speed up tile retrieval (using subDomains gets around the browser limit of the max number of concurrent requests to a domain). 
             */
            subDomains?: string[],

            /**
             * The URL template used to retrieve the tiles. 
             */
            templateUrl?: string,

            /**
             * Define the tile info for the layer including lods, rows, cols, origin and spatial reference. 
             */
            tileInfo?: TileInfo,

            /**
             * Define additional tile server domains for the layer. 
             */
            tileServer?: string[],

            /**
             * The type of layer, valid values are "BingMapsAerial", "BingMapsHybrid", "BingMapsRoad", "OpenStreetMap", or "WebTiledLayer". 
             */
            type?: string,

            /**
             * URL to the ArcGIS Server REST resource that represents a map or image service. 
             */
            url?: string,

            /**
             * If the url points to a dynamic map service you can specify a subset of layers to display. 
             */
            visibleLayers?: number[]
    }
    declare     export interface BasemapOptions {

        /**
         * The id of the basemap. 
         */
        id?: string,

            /**
             * An array of layers to add to the basemap. 
             */
            layers: BasemapLayer[],

            /**
             * A URL to a thumbnail image for the basemap that will be displayed in the BasemapGallery. 
             */
            thumbnailUrl?: string,

            /**
             * Title for the basemap. 
             */
            title?: string
    }
    declare     export interface BasemapToggleOptions {

        /**
         * The secondary basemap to toggle to. 
         */
        basemap?: string,

            /**
             * Object containing the labels and URLs for the image of each basemap. 
             */
            basemaps?: any,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface BlendRendererOptions {

        /**
         * This determines how colors are blended together. 
         */
        blendMode?: string,

            /**
             * An array of objects to blend containing the field name and color to use. 
             */
            fields: any[],

            /**
             * The field to normalize. 
             */
            normalizationField?: string,

            /**
             * An array of objects which determines opacity. 
             */
            opacityStops: any[],

            /**
             * The symbol in which the BlendRenderer is applied. 
             */
            symbol: Symbol
    }
    declare     export interface BookmarksOptions {

        /**
         * An array of BookmarkItem objects or a json object with the BookmarkItem format to initially display in the bookmark widget. 
         */
        bookmarks?: BookmarkItem[],

            /**
             * When true, users can add, remove and edit bookmark items. 
             */
            editable?: boolean,

            /**
             * Reference to the map. 
             */
            map: Map
    }
    declare     export interface CSVLayerOptions {

        /**
         * The column delimiter. 
         */
        columnDelimiter?: string,

            /**
             * Copyright information for the layer. 
             */
            copyright?: string,

            /**
             * The fields property contains objects with "name", "alias" and "type" String properties. 
             */
            fields?: any[],

            /**
             * The latitude field name. 
             */
            latitudeFieldName?: string,

            /**
             * The longitude field name. 
             */
            longitudeFieldName?: string,

            /**
             * An array of strings which correspond to fields to include in the CSVLayer. 
             */
            outFields?: string[]
    }
    declare     export interface ChooseBestFacilitiesOptions {

        /**
         * The URL to the analysis service, for example "http://analysis.arcgis.com/arcgis/rest/services/tasks/GPServer". 
         */
        analysisGpServer?: string,

            /**
             * The number of facilities to choose when allocating demand locations. 
             */
            candidateCount?: number,

            /**
             * Specify how much demand every facility in the candidateFacilitiesLayer is capable of supplying. 
             */
            candidateFacilitiesCapacity?: string,

            /**
             * String value indicating the field name on the candidateFacilitiesLayer  representing how much demand each facility in the candidatesFacilitiesLayer is capable of supplying. 
             */
            candidateFacilitiesCapacityField?: string,

            /**
             * A point layer specifying one or more locations that act as facilities by providing some kind of service. 
             */
            candidateFacilitiesLayer?: FeatureLayer,

            /**
             * The amount of demand available at every demand locations. 
             */
            demand?: number,

            /**
             * String value indicating the field name on the demandLocationLayer  representing the amount of demand available at each demand location. 
             */
            demandField?: string,

            /**
             * A point layer specifying the locations that have demand for facilities. 
             */
            demandLocationLayer?: FeatureLayer,

            /**
             * Array of point layers to be used for choosing the demandLocationLayer. 
             */
            demandLocationLayers: FeatureLayer[],

            /**
             * When true, Travel Modes (Driving Time) is enabled for the inputLayer with the point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * Array of point layers used for setting the required facilities layer and candidate facilities layer. 
             */
            featureLayers: FeatureLayer[],

            /**
             * Sets the selected folder of the select folder dropdown. 
             */
            folderId?: string,

            /**
             * Sets the selected folder of the select folder dropdown. 
             */
            folderName?: string,

            /**
             * Reference to the map. 
             */
            map?: Map,

            /**
             * The maximum travel time or distance allowed between a demand location and its allocated facility. 
             */
            maxTravelRange?: number,

            /**
             * String value indicating the field name on the demandLocationLayer specifying the maximum travel time or distance allowed between a demand location and its allocated facility. 
             */
            maxTravelRangeField?: string,

            /**
             * The name of the output layer to be displayed in the result layer  nameinputbox. 
             */
            outputLayerName?: string,

            /**
             * The percentage of the total demand that you want the chosen and required facilities to capture. 
             */
            percentDemandCoverage?: number,

            /**
             * The URL to the ArcGIS organization or Portal site where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Specify how much demand every facility in the requiredFacilitiesLayer is capable of supplying. 
             */
            requiredFacilitiesCapacity?: number,

            /**
             * A field on the requiredFacilitiesLayer representing how much demand each facility in this layer is capable of supplying. 
             */
            requiredFacilitiesCapacityField?: string,

            /**
             * A point layer specifying one or more locations that act as facilities by providing some kind of service. 
             */
            requiredFacilitiesLayer?: FeatureLayer,

            /**
             * Indicates whether to return the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * Indicates whether the "choose extent checkbox" is displayed. 
             */
            showChooseExtent?: boolean,

            /**
             * Indicates whether to show the credit options. 
             */
            showCredits?: boolean,

            /**
             * Indicates whether the help links are displayed. 
             */
            showHelp?: boolean,

            /**
             * Indicates whether to add an option to the UI that allows users to choose ready-to-use analysis layers from the Living Atlas Analysis Layers. 
             */
            showReadyToUseLayers?: boolean,

            /**
             * Indicates whether to display a dropdown menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean,

            /**
             * Indicates whether the select folder dropdown will be displayed. 
             */
            showSelectFolder?: boolean,

            /**
             * The default widget title with a custom title. 
             */
            title?: string
    }
    declare     export interface CircleOptions1 {

        /**
         * Applicable when the spatial reference of the center point is either set to Web Mercator or geographic/geodesic as true would apply. 
         */
        geodesic?: boolean,

            /**
             * A circle can be thought of similar to a polygon. 
             */
            numberOfPoints?: number,

            /**
             * Radius of the circle. 
             */
            radius?: number,

            /**
             * Unit of the radius. 
             */
            radiusUnit?: string
    }
    declare     export interface CircleOptions2 {

        /**
         * The center point of the circle. 
         */
        center: Point | number[],

            /**
             * Applicable when the spatial reference of the center point is either set to Web Mercator or geographic/geodesic as true would apply. 
             */
            geodesic?: boolean,

            /**
             * A circle can be thought of similar to a polygon. 
             */
            numberOfPoints?: number,

            /**
             * The radius of the circle. 
             */
            radius?: number,

            /**
             * Unit of the radius. 
             */
            radiusUnit?: string
    }
    declare     export interface ClassedColorSliderOptions {

        /**
         * Data map containing renderer information. 
         */
        breakInfos: any,

            /**
             * Indicates the classification method used to divide the range of values into bins. 
             */
            classificationMethod?: string,

            /**
             * Required: Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of the histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * Indicates how data values are normalized. 
             */
            normalizationType?: string,

            /**
             * Handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of the widget ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays ticks on slider when true. 
             */
            showTicks?: boolean,

            /**
             * Represents the statistics data object. 
             */
            statistics?: any
    }
    declare     export interface ClassedSizeSliderOptions {

        /**
         * The data map containing renderer information. 
         */
        breakInfos: any,

            /**
             * Optional: Indicates the classification method used to divide the range of values into bins. 
             */
            classificationMethod?: string,

            /**
             * Required: Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * Indicates how data values are normalized. 
             */
            normalizationType?: string,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of slider ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Indicates whether to display the histogram. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Optional: Represents the statistics data object. 
             */
            statistics?: any
    }
    declare     export interface ColorInfoSliderOptions {

        /**
         * The data map containing renderer information. 
         */
        colorInfo: any,

            /**
             * Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Optional: Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Width of widget ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays handles when set to true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when set to true. 
             */
            showLabels?: boolean,

            /**
             * Indicates whether to display percentage labels. 
             */
            showRatioLabels?: boolean | string,

            /**
             * Displays tick marks when set to true. 
             */
            showTicks?: boolean,

            /**
             * Displays transparent background when set to true. 
             */
            showTransparentBackground?: boolean,

            /**
             * Represents a statistics data object. 
             */
            statistics?: any,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface ColorPickerOptions {

        /**
         * The selected color. 
         */
        color: Color,

            /**
             * The row size of the palette. 
             */
            colorsPerRow: number,

            /**
             * The set of available color options. 
             */
            palette: Color[],

            /**
             * Array of recent colors to show in the recent colors row. 
             */
            recentColors: Color[],

            /**
             * Toggles color selection being required. 
             */
            required: boolean,

            /**
             * Toggles the recent color row. 
             */
            showRecentColors: boolean,

            /**
             * Toggles the transparency slider. 
             */
            showTransparencySlider: boolean
    }
    declare     export interface ConnectOriginsToDestinationsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The linear unit used with the distance value(s). 
             */
            distanceDefaultUnits?: string,

            /**
             * An array of feature layers containing destination points. 
             */
            featureLayers: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The point feature layers containing the origin points. 
             */
            originsLayers: FeatureLayer[],

            /**
             * The name of the output layer to be shown in the Result layer name input box. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean
    }
    declare     export interface CoordinatesLocationProviderOptions {

        /**
         * The attribute field in the graphic object that contains the longitude (X) values. 
         */
        xField: string,

            /**
             * The attribute field in the graphic object that has the latitude (Y) values. 
             */
            yField: string
    }
    declare     export interface CreateBuffersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of buffer distances to buffer the input feature layer. 
             */
            bufferDistance?: number[],

            /**
             * The input point, line, or polygon feature layer to be buffered. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: string,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface CreateDriveTimeAreasOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The units of the breakValues parameter. 
             */
            breakUnits?: string,

            /**
             * An array of driving time break values. 
             */
            breakValues?: number[],

            /**
             * The point feature layer around which drive-time areas will be drawn. 
             */
            inputLayer: FeatureLayer,

            /**
             * The geometry type of the input layer. 
             */
            inputType?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The rule of overlap. 
             */
            overlapPolicy?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface CreateViewshedOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * Feature layer containing observation points to be used as input. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string
    }
    declare     export interface CreateWatershedsOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layers containing input points used for calculating watersheds. 
             */
            inputLayers: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean
    }
    declare     export interface CutOptions {

        /**
         * The feature(s) added to the feature layer by the cut operation. 
         */
        addedGraphics?: Graphic[],

            /**
             * The feature layer that contains the cut feature(s). 
             */
            featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) before the cut operation is performed. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface DataAdapterFeatureLayerOptions {

        /**
         * The query parameters to use in retrieving the data through the DataAdapter. 
         */
        dataAdapterQuery: any,

            /**
             * An instance of the LocationProvider class. 
             */
            locationProvider: LocationProviderBase
    }
    declare     export interface DataBrowserOptions {

        /**
         * Whether or not to display the hierarchy dropdown for countries with multiple hierarchies (e.g. 
         */
        allowHierarchies?: boolean,

            /**
             * Show/hide country drop down. 
             */
            countryBox?: boolean,

            /**
             * Two-digit country code selected in the country drop down. 
             */
            countryID?: string,

            /**
             * The hierarchy to load for a country (e.g. 
             */
            hierarchyID?: string,

            /**
             * Text string to display on the back button on the second and third pages of the Data Browser. 
             */
            pageBackButton?: string,

            /**
             * Selected variables array. 
             */
            selection?: string[],

            /**
             * Whether to display the "Shopping Cart" of selected variables. 
             */
            shoppingCart?: boolean,

            /**
             * Title to show in the top left hand corner. 
             */
            title?: string
    }
    declare     export interface DeleteOptions {

        /**
         * The features that were removed from the feature layer. 
         */
        deletedGraphics?: Graphic[],

            /**
             * The feature layer from which the feature(s) are removed. 
             */
            featureLayer?: FeatureLayer
    }
    declare     export interface DirectionsOptions {

        /**
         * Defines the values that label each stop. 
         */
        alphabet?: string | string[] | boolean,

            /**
             * When true, solve will start when the last destination is complete and enter key is hit. 
             */
            autoSolve?: boolean,

            /**
             * Display the 'Add Destination' button. 
             */
            canModifyStops?: boolean,

            /**
             * Center the map at the start of the selected route segment. 
             */
            centerAtSegmentStart?: boolean,

            /**
             * The returned directions object from the routing solve result. 
             */
            directions?: any,

            /**
             * Length units. 
             */
            directionsLengthUnits?: string,

            /**
             * Enable the dragging of stop locations on the map. 
             */
            dragging?: boolean,

            /**
             * Focus the cursor in the stop input when a new stop is added. 
             */
            focusOnNewStop?: boolean,

            /**
             * The symbol that is used to denote the start location on the map. 
             */
            fromSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when the from location is dragged to a new location. 
             */
            fromSymbolDrag?: PictureMarkerSymbol,

            /**
             * If available, this geometry service is used to provide latitude/longitude values for stops whose reverse geocoding did not return an address (Added at v3.11). 
             */
            geometryTaskUrl?: string,

            /**
             * Reference to the map object. 
             */
            map: Map,

            /**
             * Activates the map-click-active toggle button when true. 
             */
            mapClickActive?: boolean,

            /**
             * Maximum number of stops. 
             */
            maxStops?: number,

            /**
             * Minimum number of stops. 
             */
            minStops?: number,

            /**
             * When true, stops on the route are re-ordered to provide an optimal route. 
             */
            optimalRoute?: boolean,

            /**
             * If specified, this specifies the portal where the produced route layers are going to be stored and accessed. 
             */
            portalUrl?: string,

            /**
             * URL link to a custom print page. 
             */
            printPage?: string,

            /**
             * If available, this print task is used to display an overview map of the route on the directions print page (Added at v3.11). 
             */
            printTaskUrl?: string,

            /**
             * HTML string for providing a custom printing page 
             */
            printTemplate?: string,

            /**
             * When true, the route will return to start point. 
             */
            returnToStart?: boolean,

            /**
             * Specify the input parameters for the route task. 
             */
            routeParams?: RouteParameters,

            /**
             * Define the symbol used to draw the route on the map. 
             */
            routeSymbol?: SimpleLineSymbol,

            /**
             * Specify the service that will be used to calculate directions. 
             */
            routeTaskUrl?: string,

            /**
             * Used to define optional search options. 
             */
            searchOptions?: any,

            /**
             * Define the info template for the popup that appears when the popup for a route segment is displayed. 
             */
            segmentInfoTemplate?: InfoTemplate,

            /**
             * Specify the symbol used to render the individual route segments that display on the map when a direction step is clicked. 
             */
            segmentSymbol?: SimpleLineSymbol,

            /**
             * Defines whether the Directions widget will show the map-click-active toggle button. 
             */
            showActivateButton?: boolean,

            /**
             * If true, the Clear button is shown. 
             */
            showClearButton?: boolean,

            /**
             * If true, the toggle button group allowing user to choose between Miles and Kilometers is shown. 
             */
            showMilesKilometersOption?: boolean,

            /**
             * When true, the Optimize order option is shown. 
             */
            showOptimalRouteOption?: boolean,

            /**
             * When true the 'Print' button is displayed that allows users to display driving directions in a print page. 
             */
            showPrintPage?: boolean,

            /**
             * When true, the Return to start option is shown. 
             */
            showReturnToStartOption?: boolean,

            /**
             * Display the 'Show Reverse Stops' button. 
             */
            showReverseStopsButton?: boolean,

            /**
             * Applicable if the widget works with a Network Analyst Server federated with ArcGIS Online or Portal. 
             */
            showSaveButton?: boolean,

            /**
             * Highlight the route segment when a directions step is clicked. 
             */
            showSegmentHighlight?: boolean,

            /**
             * Display a popup with segment details when a direction step is clicked. 
             */
            showSegmentPopup?: boolean,

            /**
             * When true, the Use traffic option is shown. 
             */
            showTrafficOption?: boolean,

            /**
             * If true, and six Standard Travel Modes are supported by the service and accessible using current credentials, then two toggle button groups are shown: one to allow user to choose between Driving a Car, a Truck, and Walking, and one more group to choose between Fastest and Shortest routes. 
             */
            showTravelModesOption?: boolean,

            /**
             * True if currently calculating the route from the routing service. 
             */
            solving?: boolean,

            /**
             * List of graphics used to display the point marker. 
             */
            stopGraphics?: Graphic[],

            /**
             * An array of points that define the stop locations. 
             */
            stops?: Point[] | number[][] | string[] | any[],

            /**
             * Define the info template for the popup that appears when a stop is clicked. 
             */
            stopsInfoTemplate?: InfoTemplate,

            /**
             * The symbol that displays on the map for the locations between the origin and final destination locations. 
             */
            stopSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when an intermediate location is dragged to a new location. 
             */
            stopSymbolDrag?: PictureMarkerSymbol,

            /**
             * List of graphics used to display the text over the point marker. 
             */
            textGraphics?: Graphic[],

            /**
             * The text color for the text that appears for each destination. 
             */
            textSymbolColor?: Color,

            /**
             * The font used for the text that displays on the map for each stop location. 
             */
            textSymbolFont?: Font,

            /**
             * Define an x and/or y offset for the text symbols that are used for the stop locations on the map. 
             */
            textSymbolOffset?: any,

            /**
             * Specify a theme for the widget. 
             */
            theme?: string,

            /**
             * The symbol that is used to denote the final destination location on the map. 
             */
            toSymbol?: PictureMarkerSymbol,

            /**
             * The symbol that displays when an final destination location is dragged to a new location. 
             */
            toSymbolDrag?: PictureMarkerSymbol,

            /**
             * When true, real-time traffic is used to plan the route. 
             */
            traffic?: boolean,

            /**
             * The traffic layer used for real-time traffic. 
             */
            trafficLayer?: ArcGISDynamicMapServiceLayer
    }
    declare     export interface DissolveBoundariesOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of field names based on which polygons are merged. 
             */
            dissolveFields?: string[],

            /**
             * The layer containing polygon features that will be dissolved. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of field names and statistical summary types that you wish to calculate from the polygons that are dissolved together. 
             */
            summaryFields?: string[]
    }
    declare     export interface DotDensityRendererOptions {

        /**
         * The color to be used for the background of the symbol. 
         */
        backgroundColor?: Color,

            /**
             * The shape to be used for the dot. 
             */
            dotShape?: string,

            /**
             * The size of the dot in pixels. 
             */
            dotSize?: number,

            /**
             * The value that a dot represents. 
             */
            dotValue: number,

            /**
             * An array of objects, where each object defines a field to be mapped and its color. 
             */
            fields: any[],

            /**
             * The line symbol to use on the outline of the feature. 
             */
            outline?: LineSymbol
    }
    declare     export interface DrawOptions {

        /**
         * Determines how much time to wait before adding a new point when using a freehand tool. 
         */
        drawTime?: number,

            /**
             * If true, tooltips are displayed when creating new graphics with the draw toolbar. 
             */
            showTooltips?: boolean,

            /**
             * Determines how far the mouse moves before adding a new point when using one of the freehand tools. 
             */
            tolerance?: number,

            /**
             * Determines how far to offset the tool tip from the mouse pointer. 
             */
            tooltipOffset?: number
    }
    declare     export interface DriveBufferOptions {

        /**
         * The radii to use to create ring buffers 
         */
        radius: number[],

            /**
             * The units of the radii. 
             */
            units: string
    }
    declare     export interface EditOptions {

        /**
         * Specifies whether users can add new vertices. 
         */
        allowAddVertices?: boolean,

            /**
             * Specifies whether users can delete vertices. 
             */
            allowDeleteVertices?: boolean,

            /**
             * Line symbol used to draw the guild lines, displayed when moving vertices. 
             */
            ghostLineSymbol?: LineSymbol,

            /**
             * Marker symbol used to display the insertable vertices. 
             */
            ghostVertexSymbol?: MarkerSymbol,

            /**
             * If users want to place the text symbol editor to a user defined HTML element. 
             */
            textSymbolEditorHolder?: CSG$Node | string,

            /**
             * When true, if the geometry is re-sized the aspect ration will be preserved. 
             */
            uniformScaling?: boolean,

            /**
             * Marker symbol used to draw the vertices. 
             */
            vertexSymbol?: MarkerSymbol
    }
    declare     export interface EditorOptions {

        /**
         * Create a new settings object that defines the capabilities of the widget. 
         */
        settings?: any
    }
    declare     export interface ElevationProfileOptions {

        /**
         * This object contains properties used to render the chart. 
         */
        chartOptions?: any,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * The URL to the elevation profile service. 
             */
            profileTaskUrl: string,

            /**
             * The measurement unit of the scalebar units. 
             */
            scalebarUnits?: string
    }
    declare     export interface EnrichLayerOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An buffer distance or driving time value to buffer the input feature layer. 
             */
            distance?: number,

            /**
             * When true, Travel Modes (Driving Time) is enabled for inputLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * The input feature layer to enrich with new data. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * When true, you can specify a time for traffic condition under Define areas to enrich - Driving Time. 
             */
            showTrafficWidget?: boolean
    }
    declare     export interface ExtractDataOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * If true, the Clip features option in Study area will be ckecked. 
             */
            clip?: boolean,

            /**
             * The format of output data shown as the default selection in the Output data format menu. 
             */
            dataFormat?: string,

            /**
             * An array for feature layers to be extracted. 
             */
            featureLayers: FeatureLayer[],

            /**
             * An array for feature layers to be extracted. 
             */
            inputLayers?: FeatureLayer[],

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FeatureLayerOptions {

        /**
         * Enable or disable the auto generalization of features from a non-editable layer in on-demand mode. 
         */
        autoGeneralize?: boolean,

            /**
             * Class attribute to set for the layer's node. 
             */
            className?: string,

            /**
             * Where clause to use as definition expression for layer. 
             */
            definitionExpression?: string,

            /**
             * When true, graphics are displayed during panning. 
             */
            displayOnPan?: boolean,

            /**
             * Set a callback function that will be invoked by  FeatureLayer.getEditSummary. 
             */
            editSummaryCallback?: Function,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string,

            /**
             * Unique ID to assign to the layer. 
             */
            id?: string,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * The maximum allowable offset, only applicable for layers that are not editable. 
             */
            maxAllowableOffset?: number,

            /**
             * The query mode for the feature layer. 
             */
            mode?: number,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * One or more fields used to order features by - for queries as well as for rendering. 
             */
            orderByFields?: string[],

            /**
             * An array of strings which correspond to fields to include in the FeatureLayer. 
             */
            outFields?: string[],

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Specify the metadata of the layer. 
             */
            resourceInfo?: any,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean,

            /**
             * Indicates whether to show labels on the layer. 
             */
            showLabels?: boolean,

            /**
             * The dynamic layer or table source. 
             */
            source?: LayerSource,

            /**
             * Specify the size of the virtual tiles, used in on-demand mode. 
             */
            tileHeight?: number,

            /**
             * Specify the size of the virtual tiles, used in on-demand mode. 
             */
            tileWidth?: number,

            /**
             * The name of the trackIdField. 
             */
            trackIdField?: string,

            /**
             * When true, the layer will update its content based on the map's time extent. 
             */
            useMapTime?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface FeatureLayerStatisticsOptions {

        /**
         * The feature layer that will be the source for calculating statistics. 
         */
        layer: FeatureLayer
    }
    declare     export interface FeatureTableOptions {

        /**
         * The number of features a service will try to fetch. 
         */
        batchCount?: number,

            /**
             * Object defining the date options specifically for formatting date and time editors. 
             */
            dateOptions?: any,

            /**
             * Sets the editing state for the FeatureTable. 
             */
            editable?: boolean,

            /**
             * The featureLayer that the table is associated with. 
             */
            featureLayer: FeatureLayer,

            /**
             * An array of objects representing field information. 
             */
            fieldInfos?: any[],

            /**
             * Reference to the 'Options' drop-down menu. 
             */
            gridMenu?: any,

            /**
             * Object that can be used to set properties used by the underlying dgrid. 
             */
            gridOptions?: any,

            /**
             * Columns to hide by default using the dGrid ColumnHider extension. 
             */
            hiddenFields?: string[],

            /**
             * A reference to the Map. 
             */
            map?: Map,

            /**
             * Adds additional functional menu items for the 'Options' drop-down menu. 
             */
            menuFunctions?: any[],

            /**
             * Attribute fields to include in the FeatureTable. 
             */
            outFields?: string[],

            /**
             * Displays or hides the attachment column. 
             */
            showAttachments?: boolean,

            /**
             * Displays or hides tooltips for column headers. 
             */
            showColumnHeaderTooltips?: boolean,

            /**
             * Shows or hides cyclical relationship. 
             */
            showCyclicalRelationships?: boolean,

            /**
             * Displays the data type of the field right under the field label. 
             */
            showDataTypes?: boolean,

            /**
             * Displays or hides total number of features and selected number of features in the grid header. 
             */
            showFeatureCount?: boolean,

            /**
             * Displays or hides the FeatureTable header. 
             */
            showGridHeader?: boolean,

            /**
             * Displays or hides 'Options' drop-down menu of the FeatureTable. 
             */
            showGridMenu?: boolean,

            /**
             * Displays or hides the option to show related records in a table if the layer has pre-established relationship. 
             */
            showRelatedRecords?: boolean,

            /**
             * Displays or hides the 'Statistics' option in column menus for numeric fields. 
             */
            showStatistics?: boolean,

            /**
             * Enables an interaction between the map and the feature table. 
             */
            syncSelection?: boolean,

            /**
             * Enables pan/zoom to selected features on the map when the table in 'sync selection' mode. 
             */
            zoomToSelection?: boolean
    }
    declare     export interface FindHotSpotsOptions {

        /**
         * An array of feature layer candidates to be selected as the aggregation polygon layer. 
         */
        aggregationPolygonLayers: FeatureLayer[],

            /**
             * The numeric field in the AnalysisLayer that will be analyzed. 
             */
            analysisField?: string,

            /**
             * The URL to the GPServer used to execute an analysis job. 
             */
            analysisGpServer?: string,

            /**
             * The feature layer for which hot spots will be calculated. 
             */
            analysisLayer: FeatureLayer,

            /**
             * An array of feature layer candidates to be selected as the bounding polygon layer. 
             */
            boundingPolygonLayers: FeatureLayer[],

            /**
             * When true, make process info to get analysis report. 
             */
            isProcessInfo?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FindNearestOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer from which the nearest features are found. 
             */
            analysisLayer: FeatureLayer,

            /**
             * When true, Travel Modes ( Driving Distance, Driving Time) are enabled for analysisLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The maximum number of nearest locations to find for each feature in analysisLayer. 
             */
            maxCount?: number,

            /**
             * The feature layer to be shown selected in the "1. 
             */
            nearLayer: FeatureLayer,

            /**
             * An array of near layer candidates. 
             */
            nearLayers: FeatureLayer[],

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * The maximum range to search for nearest locations from each feature in the analysisLayer. 
             */
            searchCutoff?: number,

            /**
             * The units of the searchCutoff parameter. 
             */
            searchCutoffUnits?: string,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }
    declare     export interface FindTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface GalleryOptions {

        /**
         * An array of items, see example below. 
         */
        items: any[],

            /**
             * Display the title for each item in the gallery. 
             */
            showTitle?: boolean,

            /**
             * Specify the size of the gallery's thumbnail image. 
             */
            thumbnailStyle?: string
    }
    declare     export interface GaugeOptions {

        /**
         * Text to display at the bottom of the gauge. 
         */
        caption?: string,

            /**
             * Color used for the arc indicator on the gauge. 
             */
            color?: string,

            /**
             * Name of the attribute field used to drive the gauge. 
             */
            dataField?: string,

            /**
             * Either "value" or "percentage". 
             */
            dataFormat?: string,

            /**
             * Name of the attribute field used to display a feature name on the gauge. 
             */
            dataLabelField?: string,

            /**
             * When true, the gauge is created with JSON from an ArcGIS Online webmap. 
             */
            fromWebmap?: boolean,

            /**
             * A esri.layers.GraphicsLayer or esri.layers.FeatureLayer used to drive the gauge. 
             */
            layer?: GraphicsLayer,

            /**
             * Maximum value that will be displayed on the gauge. 
             */
            maxDataValue?: number,

            /**
             * The text to display when a feature does not not a value for the dataLabelField. 
             */
            noDataLabel?: string,

            /**
             * Object passed to dojo.number.format to specify how data values are formatted. 
             */
            numberFormat?: any,

            /**
             * Text displayed above the gauge. 
             */
            title?: string,

            /**
             * What to dsiplay after the value of the currently selected feature. 
             */
            unitLabel?: string
    }
    declare     export interface GenerateRendererTaskOptions {

        /**
         * Prior to ArcGIS Server 10.2, map server/feature service only sample 1000 features to generate the renderer when using GenerateRenderer operation, which mean if there are more than 1000 features, it may run into the case that some feature will not be categorized into any breaks/unique values. 
         */
        checkValueRange?: boolean,

            /**
             * Specify the geodatabase version to display. 
             */
            gdbVersion?: string
    }
    declare     export interface GeoRSSLayerOptions {

        /**
         * The template used to display popup window for identify operation. 
         */
        infoTemplate?: InfoTemplate,

            /**
             * The output spatial reference for the GeoRSSLayer. 
             */
            outSpatialReference?: SpatialReference,

            /**
             * The default symbol use to display point features. 
             */
            pointSymbol?: Symbol,

            /**
             * The default symbol used to display polygon features. 
             */
            polygonSymbol?: Symbol,

            /**
             * The default symbol used to display polyline features. 
             */
            polylineSymbol?: Symbol
    }
    declare     export interface GeocoderOptions {

        /**
         * By default, the Geocoder widget uses the Esri World Locator to find search locations. 
         */
        arcgisGeocoder?: boolean | any,

            /**
             * When false, the geocoder will not display the auto-complete results menu. 
             */
            autoComplete?: boolean,

            /**
             * When false, the geolocator will not navigate to the result after selection or search. 
             */
            autoNavigate?: boolean,

            /**
             * When false, the geocoder menu will not be displayed when more than one geocoder is set. 
             */
            geocoderMenu?: boolean,

            /**
             * Defines the geocoders that will be used by the Geocoder widget. 
             */
            geocoders?: any[],

            /**
             * Specify a graphicsLayer to use when  highlightSymbol is true. 
             */
            graphicsLayer?: GraphicsLayer,

            /**
             * Indicates whether to show a graphic at a selected location. 
             */
            highlightLocation?: boolean,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Maximum number of results to return. 
             */
            maxLocations?: number,

            /**
             * Minimum number of characters entered into the search field before querying for results. 
             */
            minCharacters?: number,

            /**
             * Number of milliseconds before querying for results will begin. 
             */
            searchDelay?: number,

            /**
             * When false, the geocoder will not show search suggestions while typing. 
             */
            showResults?: boolean,

            /**
             * Symbol to use when highlightLocation is true. 
             */
            symbol?: Symbol,

            /**
             * Specify a theme for the geocoder. 
             */
            theme?: string,

            /**
             * Start the geocoder with a default value. 
             */
            value?: string,

            /**
             * Scale to zoom to when geocoder does not return an extent. 
             */
            zoomScale?: number
    }
    declare     export interface GeometryLocationProviderOptions {

        /**
         * The attribute field in the graphic object that contains the JSON string representing the geometry. 
         */
        geometryField: string,

            /**
             * The geometry type of the returned features. 
             */
            geometryType: string
    }
    declare     export interface GraphicsLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * List of attribute fields to be added as custom data attributes to graphics node. 
             */
            dataAttributes?: string | string[],

            /**
             * When true, graphics are displayed during panning. 
             */
            displayOnPan?: boolean,

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * The info template for the layer. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * Indicates whether the layer is responsible for styling graphics. 
             */
            styling?: boolean,

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface Handle {

        /**
         * Remove the listener 
         */
        remove(): void
    }
    declare     export interface HeatmapRendererOptions {

        /**
         * The radius (in pixels) of the circle over which the majority of each points value is spread out over. 
         */
        blurRadius?: number,

            /**
             * An array of CSS color strings (#RGB, #RRGGBB, rgb(r,g,b), rgba(r,g,b,a)). 
             */
            colors: string[],

            /**
             * The name of the attribute field used to weight the heatmap points. 
             */
            field?: string,

            /**
             * The pixel intensity value which is assigned the final color in the color ramp. 
             */
            maxPixelIntensity?: number,

            /**
             * The pixel intensity value which is assigned the initial color in the color ramp. 
             */
            minPixelIntensity?: number
    }
    declare     export interface HeatmapSliderOptions {

        /**
         * An array of colorStop objects describing the renderer's color ramp with more specificity than just colors. 
         */
        colorStops: any[],

            /**
             * Handles identified by their index values within the stops array. 
             */
            handles: number[],

            /**
             * Absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * Absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * Width of slider ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean
    }
    declare     export interface HistogramTimeSliderOptions {

        /**
         * Change color of histogram bars, default is "rgb(5, 112, 176)".color: "#555555" 
         */
        color?: string,

            /**
             * Formats dates displayed by histogram slider.dateFormat: "DateFormat(selector: 'date', fullYear: true)" 
             */
            dateFormat?: string,

            /**
             * Array of feature layers to be used by slider. 
             */
            layers?: Layer[],

            /**
             * With a stream layer, when the number of points on the map exceeds the maximum number allowed, this histogram will start removing bins at the beginning of the array if in the "show_partial" mode. 
             */
            mode?: string,

            /**
             * Sets resolution for histogram slider (seconds/minutes/hours/etc) using Esri date formats. 
             */
            timeInterval?: string
    }
    declare     export interface HomeButtonOptions {

        /**
         * The extent used to zoom to when clicked. 
         */
        extent?: Extent,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface HorizontalSliderOptions {

        /**
         * Array of text labels to render - evenly spaced from left-to-right. 
         */
        labels: string[]
    }
    declare     export interface IdentifyTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface ImageServiceMeasureOptions {

        /**
         * The angular unit in which directions of line segments will be calculated. 
         */
        angularUnit?: string,

            /**
             * The area unit in which areas of polygons will be calculated. 
             */
            areaUnit?: string,

            /**
             * Defines whether to show the widget result in a popup or in the widget's result area when the widget has 'toolbar' layout. 
             */
            displayMeasureResultInPopup?: boolean,

            /**
             * Symbol to be used when drawing a polygon or extent. 
             */
            fillSymbol?: SimpleFillSymbol,

            /**
             * Image service layer with which the toolbar is associated. 
             */
            layer: ArcGISImageServiceLayer,

            /**
             * Defines the layout of the widget. 
             */
            layout?: string,

            /**
             * The linear unit in which height, length, or perimeters will be calculated. 
             */
            linearUnit?: string,

            /**
             * Symbol to be used when drawing a line. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Map instance with which the toolbar is associate. 
             */
            map: Map,

            /**
             * Symbol to be used when drawing a point. 
             */
            markerSymbol?: SimpleMarkerSymbol
    }
    declare     export interface ImageServiceMeasureToolOptions {

        /**
         * The angular unit in which directions of line segments will be calculated. 
         */
        angularUnit?: string,

            /**
             * The area unit in which areas of polygons will be calculated. 
             */
            areaUnit?: string,

            /**
             * Symbol to be used when drawing a polygon or extent. 
             */
            fillSymbol?: SimpleFillSymbol,

            /**
             * Image service layer the toolbar is associated with. 
             */
            layer: ArcGISImageServiceLayer,

            /**
             * The linear unit in which height, length, or perimeters will be calculated. 
             */
            linearUnit?: string,

            /**
             * Symbol to be used when drawing a line. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Map instance the toolbar is associated with. 
             */
            map: Map,

            /**
             * Symbol to be used when drawing a point. 
             */
            markerSymbol?: SimpleMarkerSymbol
    }
    declare     export interface ImageSpatialReferenceOptions {

        /**
         * The full Image Coordinate System object, which includes transformations and map spatial reference information specific to each image. 
         */
        ics?: any,

            /**
             * The OBJECTID of the image in a mosaic dataset. 
             */
            icsid?: number,

            /**
             * The url of the image service. 
             */
            url: string
    }
    declare     export interface KMLLayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * The output spatial reference for the KMLLayer. 
             */
            outSR?: SpatialReference,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number
    }
    declare     export interface LabelLayerOptions {

        /**
         * ID assigned to the layer. 
         */
        id?: string,

            /**
             * Display mode for the label layer. 
             */
            mode?: string
    }
    declare     export interface LayerListOptions {

        /**
         * An array of operational layers. 
         */
        layers: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Indicates whether to remove underscores from the layer title. 
             */
            removeUnderscores?: boolean,

            /**
             * Indicates whether to display a legend for the layer items. 
             */
            showLegend?: boolean,

            /**
             * Indicates whether to display the opacity slider. 
             */
            showOpacitySlider?: boolean,

            /**
             * Indicates whether to show sublayers in the list of layers. 
             */
            showSubLayers?: boolean,

            /**
             * The CSS class selector used to uniquely style the widget. 
             */
            theme?: string,

            /**
             * Indicates whether to show the LayerList widget. 
             */
            visible?: boolean
    }
    declare     export interface LayerOptions {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number,

            /**
             * When true, the layer's attribution is displayed on the map. 
             */
            showAttribution?: boolean
    }
    declare     export interface LayerSwipeOptions {

        /**
         * The number of pixels to clip the swipe tool. 
         */
        clip?: number,

            /**
             * If the widget is enabled and layers can be swiped. 
             */
            enabled?: boolean,

            /**
             * The layers to be swiped. 
             */
            layers: Layer[],

            /**
             * The number of pixels to place the tool from the left of the map. 
             */
            left?: number,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * The number of pixels to place the tool from the top of the map. 
             */
            top?: number,

            /**
             * Type of swipe tool to use. 
             */
            type?: string
    }
    declare     export interface LegendOptions {

        /**
         * Specify the alignment of the legend within the HTML element where the legend is rendered. 
         */
        arrangement?: number,

            /**
             * When false, the legend will not automatically update if the map changes scale or when layers are added are removed from the map. 
             */
            autoUpdate?: boolean,

            /**
             * Specify a subset of the layers in the map to display in the legend. 
             */
            layerInfos?: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * When true the legend will update with every scale change and displays only the layers and sub layers that are visible in the current map scale. 
             */
            respectCurrentMapScale?: boolean
    }
    declare     export interface LocateButtonOptions {

        /**
         * Centers the map to the location when a new position is returned. 
         */
        centerAt?: boolean,

            /**
             * The HTML5 Geolocation Position options for locating. 
             */
            geolocationOptions?: any,

            /**
             * If highlightLocation is on and this property is set then a graphic will be added to this layer instead of map.graphics. 
             */
            graphicsLayer?: GraphicsLayer,

            /**
             * If true, the users location will be highlighted with a point. 
             */
            highlightLocation?: boolean,

            /**
             * The infoTemplate used for the highlight graphic. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Map object that this dijit is associated with. 
             */
            map: Map,

            /**
             * The scale to zoom to when a users location has been found. 
             */
            scale?: number,

            /**
             * Sets the maps scale when a new position is returned. 
             */
            setScale?: boolean,

            /**
             * The symbol used on the highlight graphic to highlight the users location on the map. 
             */
            symbol?: Symbol,

            /**
             * Class used for styling the widget. 
             */
            theme?: string,

            /**
             * When enabled, the button becomes a toggle that creates an event to watch for location changes. 
             */
            useTracking?: boolean,

            /**
             * Whether the widget is visible by default. 
             */
            visible?: boolean
    }
    declare     export interface LocatorLocationProviderOptions {

        /**
         * Object that matches the Locator address fields to corresponding attribute names in the Graphic object. 
         */
        addressFields: any,

            /**
             * An instance of a Locator object. 
             */
            locator: Locator
    }
    declare     export interface MapImageOptions {

        /**
         * Specfiy an extent for the image. 
         */
        extent?: Extent,

            /**
             * Specify the url of the image. 
             */
            href?: string
    }
    declare     export interface MapOptions {

        /**
         * Width of the attribution node relative to the map width. 
         */
        attributionWidth?: number,

            /**
             * When true the map will automatically resize when the browser window is resized or when the ContentPane widget enclosing the map is resized. 
             */
            autoResize?: boolean,

            /**
             * Specify a basemap for the map. 
             */
            basemap?: string,

            /**
             * The location where the map should be centered. 
             */
            center?: number[] | Point,

            /**
             * When true, graphics are displayed during panning. 
             */
            displayGraphicsOnPan?: boolean,

            /**
             * If provided, the extent and projection of the map is set to the properties of Extent. 
             */
            extent?: Extent,

            /**
             * When true a fade effect is enabled for supported layers. 
             */
            fadeOnZoom?: boolean,

            /**
             * When true, for maps that contain tiled map service layers, you are guaranteed to have the initial extent defined using the extent constructor option shown completely on the map. 
             */
            fitExtent?: boolean,

            /**
             * When the mapNavigation mode is set to 'css-transforms', CSS3 transforms will be used for map navigation when supported by the browser. 
             */
            force3DTransforms?: boolean,

            /**
             * By default the map creates and uses an out-of-the-box esri/dijit/Popup. 
             */
            infoWindow?: InfoWindowBase,

            /**
             * If provided, the map is initialized with the specified levels of detail. 
             */
            lods?: LOD[],

            /**
             * Display the esri logo on the map. 
             */
            logo?: boolean,

            /**
             * Maximum visible scale of the map. 
             */
            maxScale?: number,

            /**
             * Maximum map zoom level. 
             */
            maxZoom?: number,

            /**
             * Minimum visible scale of the map. 
             */
            minScale?: number,

            /**
             * Minimum map zoom level. 
             */
            minZoom?: number,

            /**
             * Displays pan buttons on map. 
             */
            nav?: boolean,

            /**
             * Specify whether or not to use CSS3 transformations when panning and zooming. 
             */
            navigationMode?: string,

            /**
             * Default value is true, indicating that the map will skip panning animation when calling map.centerAt() or map.setExtent() (for map.setExtent(), the animation is only skipped if the map's zoom level is not changing) if the panning distance is twice the distance of the current extent. 
             */
            optimizePanAnimation?: boolean,

            /**
             * Specify a time period in milliseconds to ignore repeated calls to the resize method. 
             */
            resizeDelay?: number,

            /**
             * Initial map scale. 
             */
            scale?: number,

            /**
             * Enable or disable map attribution display. 
             */
            showAttribution?: boolean,

            /**
             * If true and a map click event occurs, it may show the map's infoWindow. 
             */
            showInfoWindowOnClick?: boolean,

            /**
             * Indicate whether to display labels. 
             */
            showLabels?: boolean,

            /**
             * Displays a slider on the map. 
             */
            slider?: boolean,

            /**
             * Define labels for the slider. 
             */
            sliderLabels?: string[],

            /**
             * Orientation of the zoom slider. 
             */
            sliderOrientation?: string,

            /**
             * Position of the zoom slider within the map control. 
             */
            sliderPosition?: string,

            /**
             * Defines the slider style. 
             */
            sliderStyle?: string,

            /**
             * When true, for Apple computers with a trackpad or magic mouse use, swipe pans instead of zooming. 
             */
            smartNavigation?: boolean,

            /**
             * When true, supports continuous pan across the dateline. 
             */
            wrapAround180?: boolean,

            /**
             * Initial zoom level of the map. 
             */
            zoom?: number
    }
    declare     export interface MeasurementOptions {

        /**
         * Flag for showing full list of units in the Location tool. 
         */
        advancedLocationUnits?: boolean,

            /**
             * The default area unit for the measure area tool. 
             */
            defaultAreaUnit?: string,

            /**
             * The default length unit for the measure distance tool. 
             */
            defaultLengthUnit?: string,

            /**
             * Allows the user to immediately measure previously-created geometry on dijit creation. 
             */
            geometry?: Point | Polyline | CSG$Polygon,

            /**
             * Line symbol used to draw the lines for the measure line and measure distance tools. 
             */
            lineSymbol?: SimpleLineSymbol,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Marker symbol used to draw the points for the measure line tool. 
             */
            pointSymbol?: MarkerSymbol
    }
    declare     export interface MergeLayersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer to be merged with the mergeLayer. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * An array of feature layer candidates to be selected as the merge layer. 
             */
            mergeLayers: FeatureLayer[],

            /**
             * An array of values that describe how fields from the mergeLayer are to be modified. 
             */
            mergingAttributes?: string[],

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean
    }

    /**
     * Constants representing how the geometry is returned. 
     */
    declare     export interface NAOutputLine {

        /**
         * Do not return geometries. 
         */
        NONE: any,

            /**
             * Return polylines containing striaght lines between input locations. 
             */
            STRAIGHT: any,

            /**
             * Return polylines based on the underlying street geometries. 
             */
            TRUE_SHAPE: any,

            /**
             * Return polylines based on the underlying street geometries with the M values set based on the accumulated impedance at each vertex. 
             */
            TRUE_SHAPE_WITH_MEASURE: any
    }

    /**
     * Constants representing how the geometry is returned. 
     */
    declare     export interface NAOutputPolygon {

        /**
         * Detailed output polygons 
         */
        DETAILED: any,

            /**
             * No output polygons 
             */
            NONE: any,

            /**
             * Simplified output polygons. 
             */
            SIMPLIFIED: any
    }

    /**
     * Constants representing directionality in network analysis. 
     */
    declare     export interface NATravelDirection {

        /**
         * Travel direction from the facility 
         */
        FROM_FACILITY: any,

            /**
             * Travel direction to the facility 
             */
            TO_FACILITY: any
    }

    /**
     * Constants representing how U-Turns are handled. 
     */
    declare     export interface NAUTurn {

        /**
         * Allow u-turns at the end of any street. 
         */
        ALLOW_BACKTRACK: any,

            /**
             * Allow u-turns at dead ends and intersections. 
             */
            AT_DEAD_ENDS_AND_INTERSECTIONS: any,

            /**
             * Only allow u-turns at dead ends where a street is not connected to another street. 
             */
            AT_DEAD_ENDS_ONLY: any,

            /**
             * Do not allow u-turns at the end of any streets. 
             */
            NO_BACKTRACK: any
    }
    declare     export interface OAuthInfoOptions {

        /**
         * The registered application Id. 
         */
        appId: string,

            /**
             * Applications with the same value will share the stored token on the same host. 
             */
            authNamespace?: string,

            /**
             * The number of minutes the token will be valid for. 
             */
            expiration?: number,

            /**
             * The locale for the OAuth sign in page. 
             */
            locale?: string,

            /**
             * The minimum time in minutes before a saved token is due to expire that it should still be considered valid for use. 
             */
            minTimeUntilExpiration?: number,

            /**
             * Set to true to show the OAuth sign in page in a popup window. 
             */
            popup?: boolean,

            /**
             * The relative page URL for the user to be sent to from the OAuth sign in page. 
             */
            popupCallbackUrl?: string,

            /**
             * The window features passed to window.open(). 
             */
            popupWindowFeatures?: string,

            /**
             * The ArcGIS for Portal URL. 
             */
            portalUrl?: string,

            /**
             * Indicates whether to display social logins such as Google/Facebook. 
             */
            showSocialLogins?: boolean
    }
    declare     export interface ObliqueViewerOptions {

        /**
         * Azimuth angle value for which to display oblique images. 
         */
        azimuthAngle?: number,

            /**
             * Image service field that denotes the sensor azimuth value for a record. 
             */
            azimuthField?: string,

            /**
             * Tolerance value applied when filtering azimuth images. 
             */
            azimuthTolerance?: number,

            /**
             * Image service field that denotes the sensor elevation value for a record. 
             */
            elevationField?: string,

            /**
             * Elevation value between 0 and 90 that differentiates an image as oblique or nadir. 
             */
            elevationThreshold?: number,

            /**
             * Image service layer to be used as source for oblique images. 
             */
            imageServiceLayer: ArcGISImageServiceLayer,

            /**
             * Map object associated with the widget. 
             */
            map: Map,

            /**
             * When true, the widget doesn't refresh itself with new oblique records when the map's extent changes. 
             */
            noQueryOnExtentChange?: boolean,

            /**
             * Raster info fields to be queried and displayed in the raster list. 
             */
            rasterInfoFields?: any[],

            /**
             * DOM Node or id, where the list element is to be placed. 
             */
            rasterListDiv?: string | CSG$Node,

            /**
             * When true, list is populated on data refresh. 
             */
            rasterListRefresh?: boolean,

            /**
             * DOM Node or id, where the oblique rotation gauge element is to be placed. 
             */
            rotationDiv?: string | CSG$Node,

            /**
             * When true, thumbnail images for records are displayed in the list. 
             */
            showThumbnail?: boolean,

            /**
             * Sorting function that takes query results and sorts them. 
             */
            sorter?: Function
    }
    declare     export interface OpacitySliderOptions {

        /**
         * Handles identified by their index values within the stops array. 
         */
        handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The data map containing renderer information. 
             */
            opacityInfo: any,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Represents the width of the SVG ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays slider labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Displays the transparent background when true. 
             */
            showTransparentBackground?: boolean,

            /**
             * Represents a statistics data object. 
             */
            statistics?: any,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface OpenStreetMapLayerOptions {

        /**
         * An array of levels at which to draw. 
         */
        displayLevels?: number[],

            /**
             * Id to assign to the layer. 
             */
            id?: string,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * An array of tile servers 
             */
            tileServers?: string[],

            /**
             * Initial visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface OperationBaseOptions {

        /**
         * Provide information about the operation. 
         */
        label?: string,

            /**
             * Specify the type of operation, for example: "edit" or "navigation". 
             */
            type?: string
    }
    declare     export interface OverlayLayersOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * The feature layer that will be overlayed with the overlayLayer. 
             */
            inputLayer: FeatureLayer,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * An array of feature layers to be overlaid with inputLayer. 
             */
            overlayLayer: FeatureLayer[],

            /**
             * Defines how two input layers are combined. 
             */
            overlayType?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * When the distance between features is less than the tolerance, the features in the overlay layer will snap to the features in the input layer. 
             */
            snapToInput?: boolean,

            /**
             * The minimum distance separating all feature coordinates (nodes and vertices) as well as the distance a coordinate can move in X or Y (or both). 
             */
            tolerance?: number
    }
    declare     export interface OverviewMapOptions {

        /**
         * Specifies which corner of the map to attach the OverviewMap dijit. 
         */
        attachTo?: string,

            /**
             * Specify the base layer for the overview map. 
             */
            baseLayer?: Layer,

            /**
             * Fill color for the extent rectangle. 
             */
            color?: string,

            /**
             * The ratio between the size of the overview map and the extent rectangle displayed on the overview map. 
             */
            expandFactor?: number,

            /**
             * Height of the overview map dijit in screen pixels. 
             */
            height?: number,

            /**
             * Unique identifier for the dijit. 
             */
            id?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Defines the visibility of the maximize/restore button. 
             */
            maximizeButton?: boolean,

            /**
             * Opacity of the extent rectangle, defined as a number between 0 (invisible) and 1 (opaque). 
             */
            opacity?: number,

            /**
             * Specifies the initial visibility of the overview map. 
             */
            visible?: boolean,

            /**
             * Width of the overview map dijit in screen pixels. 
             */
            width?: number
    }
    declare     export interface PixelBlockOptions {

        /**
         * Number of rows. 
         */
        height: number,

            /**
             * An array of nodata mask. 
             */
            mask?: any[],

            /**
             * A two dimensional array. 
             */
            pixels: number[][],

            /**
             * Pixel type. 
             */
            pixelType?: string,

            /**
             * Array of objects containing numeric statistical properties (e.g. 
             */
            statistics?: any[],

            /**
             * Number of columns. 
             */
            width: number
    }
    declare     export interface PopupMobileOptions {

        /**
         * Define the symbol used to highlight polygon features. 
         */
        fillSymbol?: FillSymbol,

            /**
             * When true, the feature is highlighted, set to false to disable highlighting. 
             */
            highlight?: boolean,

            /**
             * Define the symbol used to highlight line features. 
             */
            lineSymbol?: LineSymbol,

            /**
             * Specify the margin (in pixels) to leave to the left of the popup window when it is maximized. 
             */
            marginLeft?: number,

            /**
             * Specify the margin (in pixels) to leave at the top of the popup window when it is maximized. 
             */
            marginTop?: number,

            /**
             * Define the marker symbol used to highlight point features. 
             */
            markerSymbol?: MarkerSymbol,

            /**
             * Specify the x-offset (in pixels) used when positioning the popup. 
             */
            offsetX?: number,

            /**
             * Specify the y-offset (in pixels) used when positioning the popup. 
             */
            offsetY?: number,

            /**
             * Define the number of levels to zoom in, default value is 4. 
             */
            zoomFactor?: number
    }
    declare     export interface PopupOptions {

        /**
         * Controls the placement of the popup window with respect to the geographic location. 
         */
        anchor?: string,

            /**
             * Define the symbol used to highlight polygon features. 
             */
            fillSymbol?: FillSymbol,

            /**
             * Number of milliseconds after which the popup window will be hidden when visibleWhenEmpty is false and there are no features to be displayed. 
             */
            hideDelay?: boolean,

            /**
             * Indicates whether popup should highlight features. 
             */
            highlight?: boolean,

            /**
             * Indicates whether a feature should remain highlighted after the user closes the popup window. 
             */
            keepHighlightOnHide?: boolean,

            /**
             * Define the symbol used to highlight line features. 
             */
            lineSymbol?: LineSymbol,

            /**
             * Specify the margin (in pixels) to leave to the left of the popup window when it is maximized. 
             */
            marginLeft?: number,

            /**
             * Specify the margin (in pixels) to leave at the top of the popup window when it is maximized. 
             */
            marginTop?: number,

            /**
             * Define the marker symbol used to highlight point features. 
             */
            markerSymbol?: MarkerSymbol,

            /**
             * Specify the x-offset (in pixels) used when positioning the popup. 
             */
            offsetX?: number,

            /**
             * Specify the y-offset (in pixels) used when positioning the popup. 
             */
            offsetY?: number,

            /**
             * Indicates whether popup should display previous and next buttons in the title bar. 
             */
            pagingControls?: boolean,

            /**
             * Indicates whether popup should display the title bar text that contains the page number and total number of available features. 
             */
            pagingInfo?: boolean,

            /**
             * Indicates whether the popup window should be displayed. 
             */
            popupWindow?: boolean,

            /**
             * Indicates whether the feature's title should display within the body of the popup window as opposed to in the titlebar. 
             */
            titleInBody?: boolean,

            /**
             * Indicates whether the popup window remains visible when there are no features to be displayed. 
             */
            visibleWhenEmpty?: boolean,

            /**
             * Define the number of levels to zoom in when the 'Zoom to' link is clicked. 
             */
            zoomFactor?: number
    }
    declare     export interface PopupTemplateOptions {

        /**
         * Positive or negative offset (in minutes) from UTC. 
         */
        utcOffset?: number
    }
    declare     export interface PrintOptions {

        /**
         * Set to true if the print service is an asynchronous geoprocessing service. 
         */
        async?: boolean,

        /**
         * The map to  print. 
         */
        map?: Map,

            /**
             * An optional array of user-defined templates. 
             */
            templates?: PrintTemplate[],

            /**
             * The url to an export web map task. 
             */
            url?: string
    }
    declare     export interface PrintTaskOptions {

        /**
         * Set to true if the print service is an asynchronous geoprocessing service. 
         */
        async?: boolean
    }
    declare type ProcessorOptions = {
        verbose?: boolean,
        viewerwidth?: number,
        viewerheight?: number,
        viewerheightratio?: number
    } & OpenJsCad$IViewerOptions

    declare     export interface QueryTaskLocationProviderOptions {

        /**
         * Object containing properties that will be used to query the ArcGIS layer. 
         */
        queryParameters: any,

            /**
             * An instance of a QueryTask. 
             */
            queryTask: QueryTask,

            /**
             * Set to true when querying a field that contains unicode characters. 
             */
            unicode: boolean,

            /**
             * A mapping of the fields in the data and the ArcGIS layer to use to perform a join. 
             */
            whereFields: any
    }
    declare     export interface QueryTaskOptions {

        /**
         * Specify the geodatabase version to display. 
         */
        gdbVersion?: string
    }
    declare     export interface RasterLayerOptions {

        /**
         * Sets the layer's draw mode. 
         */
        drawMode?: boolean,

            /**
             * Sets the context of the Canvas. 
             */
            drawType?: string,

            /**
             * Additional parameters defined in an  ImageServiceParameters object. 
             */
            imageServiceParameters?: ImageServiceParameters,

            /**
             * Applies a function for visualization or post-processing purposes. 
             */
            pixelFilter?: any
    }
    declare     export interface RendererSliderOptions {

        /**
         * Collection of indexes that indicates which children from the infos array to use as handles. 
         */
        handles?: number[],

            /**
             * Absolute maximum value allowed by the slider. 
             */
            maximum: number,

            /**
             * Top label for the slider. 
             */
            maxLabel?: string,

            /**
             * Absolute minimum value allowed by the slider. 
             */
            minimum: number,

            /**
             * Bottom label for the slider. 
             */
            minLabel?: string,

            /**
             * Accuracy of the data (related to rounding). 
             */
            precision?: number,

            /**
             * Primary handle identified by its index value within the related infos array (color, size, break). 
             */
            primaryHandle?: number,

            /**
             * Toggle for showing the black handle bars. 
             */
            showHandles?: boolean,

            /**
             * Flexible toggle for showing labels (e.g. 
             */
            showLabels?: boolean | string[],

            /**
             * Toggle for showing the horizontal line indicators from the center of the handle. 
             */
            showTicks?: boolean,

            /**
             * Stores positions represented as numbers that fall between minimum and maximum. 
             */
            values: number[]
    }
    declare     export interface RingBufferOptions {

        /**
         * The radii to use to create ring buffers 
         */
        radii: number[],

            /**
             * The units of the radii. 
             */
            units: string
    }
    declare     export interface ScaleDependentRendererOptions {

        /**
         * An array of objects where each object defines a renderer and  the zoom or scale range to which it applies. 
         */
        rendererInfos?: any[]
    }
    declare     export interface ScalebarOptions {

        /**
         * Specify the scalebar position on the map. 
         */
        attachTo?: string,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Specify the style for the scalebar. 
             */
            scalebarStyle?: string,

            /**
             * Specify the scalebar units. 
             */
            scalebarUnit?: string
    }
    declare     export interface SearchOptions {

        /**
         * The currently selected source. 
         */
        activeSourceIndex?: number | string,

            /**
             * Indicates whether to automatically add all the feature layers from the map. 
             */
            addLayersFromMap?: boolean,

            /**
             * This is the default value used as a hint for input text when searching on multiple sources. 
             */
            allPlaceholder?: string,

            /**
             * Indicates whether to automatically navigate to the selected result. 
             */
            autoNavigate?: boolean,

            /**
             * Indicates whether to automatically select the first geocoded result (not the first suggestion). 
             */
            autoSelect?: boolean,

            /**
             * Indicates whether to enable an option to collapse/expand the search into a button. 
             */
            enableButtonMode?: boolean,

            /**
             * Indicates whether to show the selected feature on the map using the highlight symbol property. 
             */
            enableHighlight?: boolean,

            /**
             * Indicates whether to display the infoWindow on feature click. 
             */
            enableInfoWindow?: boolean,

            /**
             * Indicates whether to enable showing a label for the geometry.The default value is false. 
             */
            enableLabel?: boolean,

            /**
             * Indicates whether to display the option to search "All" sources. 
             */
            enableSearchingAll?: boolean,

            /**
             * Indicates whether to enable the menu for selecting different sources. 
             */
            enableSourcesMenu?: boolean,

            /**
             * Indicates whether or not to enable suggest on the widget. 
             */
            enableSuggestions?: boolean,

            /**
             * Indicates whether to display suggest results. 
             */
            enableSuggestionsMenu?: boolean,

            /**
             * Indicates whether to set the state of the enableButtonMode to expanded (true) or collapsed (false). 
             */
            expanded?: boolean,

            /**
             * This the specified graphicsLayer to use for the highlightGraphic and labelGraphic instead of map.graphics. 
             */
            graphicsLayer?: Layer,

            /**
             * The symbol used for highlightGraphic. 
             */
            highlightSymbol?: Symbol,

            /**
             * A customized infoTemplate for the selected feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * The text symbol for the label graphic. 
             */
            labelSymbol?: TextSymbol,

            /**
             * The default distance specified in meters used to reverse geocode, (if not specified by source). 
             */
            locationToAddressDistance?: number,

            /**
             * Reference to the map. 
             */
            map?: Map,

            /**
             * The default maximum number of results returned by the widget if not specified by source. 
             */
            maxResults?: number,

            /**
             * The default maximum number of suggestions returned by the widget if not specified by source. 
             */
            maxSuggestions?: number,

            /**
             * The default minimum amount of characters needed for the search if not specified by source. 
             */
            minCharacters?: number,

            /**
             * Indicates whether to show the infoWindow when a result is selected. 
             */
            showInfoWindowOnSelect?: boolean,

            /**
             * An array of source objects used to find search results. 
             */
            sources?: any[],

            /**
             * The millisecond delay after keyup and before making a suggest network request. 
             */
            suggestionDelay?: number,

            /**
             * The CSS class selector used to uniquely style the widget. 
             */
            theme?: string,

            /**
             * Current value of the search box input text string. 
             */
            value?: string,

            /**
             * Indicates whether to show the Search widget. 
             */
            visible?: boolean,

            /**
             * If the result does not have an associated extent, specify this number to use as the zoom scale for the result. 
             */
            zoomScale?: number
    }
    declare     export interface SizeInfoSliderOptions {

        /**
         * Handles identified by their index values within the stops array. 
         */
        handles: number[],

            /**
             * Represents the histogram data object. 
             */
            histogram?: any,

            /**
             * Width of the histogram in pixels. 
             */
            histogramWidth?: number,

            /**
             * The absolute maximum value of the slider. 
             */
            maxValue?: number,

            /**
             * The absolute minimum value of the slider. 
             */
            minValue?: number,

            /**
             * The handle identified by its index value within the stops array. 
             */
            primaryHandle?: number,

            /**
             * Represents the width of the SVG ramp in pixels. 
             */
            rampWidth?: number,

            /**
             * Displays slider handles when true. 
             */
            showHandles?: boolean,

            /**
             * Displays the histogram when true. 
             */
            showHistogram?: boolean,

            /**
             * Displays labels when true. 
             */
            showLabels?: boolean,

            /**
             * Displays slider ticks when true. 
             */
            showTicks?: boolean,

            /**
             * Defines the size of the symbol where feature size is proportional to data value. 
             */
            sizeInfo: any,

            /**
             * Represents the statistics data object. 
             */
            statistics?: any,

            /**
             * The SimpleLineSymbol or SimpleMarkerSymbol used with the widget. 
             */
            symbol: Symbol,

            /**
             * Additional options to customize slider. 
             */
            zoomOptions?: any
    }
    declare     export interface SnappingManagerOptions {

        /**
         * When true, snapping is always enabled. 
         */
        alwaysSnap?: boolean,

            /**
             * See the object specifications table below for the structure of the  layerInfos  object. 
             */
            layerInfos?: any[],

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * When alwaysSnap is set to false use this option to define the key users press to enable snapping. 
             */
            snapKey?: any,

            /**
             * Define a symbol for the snapping location. 
             */
            snapPointSymbol?: SimpleMarkerSymbol,

            /**
             * Specify the radius of the snapping circle in pixels. 
             */
            tolerance?: number
    }
    declare     export interface SpatialIndexOptions {

        /**
         * Start processing features immediately. 
         */
        autostart?: boolean,

            /**
             * Whether the processor allow the feature layer to draw its features. 
             */
            drawFeatures?: boolean,

            /**
             * Whether the processor do the layer's I/O via a worker. 
             */
            fetchWithWorkers?: boolean,

            /**
             * Index system specific options. 
             */
            indexOptions?: any,

            /**
             * The indexing system to use. 
             */
            indexType?: string,

            /**
             * A FeatureLayer or array of FeatureLayers to attach the processor to. 
             */
            layers?: FeatureLayer[],

            /**
             * Uses all FeatureLayers associated with the map in the processor. 
             */
            map?: Map,

            /**
             * Whether the processor pass the features through without modification or delay to the FeatureLayer. 
             */
            passFeatures?: boolean,

            /**
             * Whether the processor require Workers to function properly. 
             */
            requireWorkerSupport?: boolean
    }
    declare     export interface StandardGeographyQueryLocationProviderOptions {

        /**
         * A template to be used to build the query for Standard Geography query. 
         */
        geographyQueryTemplate: string,

            /**
             * An object that specifies the parameters to use in the Standard Geography query. 
             */
            queryParameters?: any,

            /**
             * An instance of the StandardGeographyQuery class. 
             */
            standardGeographyQueryTask: StandardGeographyQueryTask
    }
    declare     export interface StreamLayerOptions1 {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * Where clause to use as definition expression for layer. 
             */
            definitionExpression?: string,

            /**
             * The extent to use as the spatial filter for the layer. 
             */
            geometryDefinition?: Extent,

            /**
             * Maximum number of observations to show for each unique track. 
             */
            maximumTrackPoints?: number,

            /**
             * An array of strings corresponding with fields to include in the StreamLayer. 
             */
            outFields?: string[],

            /**
             * Rules for purging data from the layer to avoid overloading the browser with too many features. 
             */
            purgeOptions?: any
    }
    declare     export interface StreamLayerOptions2 {

        /**
         * Class attribute to set for the layer's node. 
         */
        className?: string,

            /**
             * The extent to use as the spatial filter for the layer. 
             */
            geometryDefinition?: Extent,

            /**
             * Maximum number of observations to show for each unique track. 
             */
            maximumTrackPoints?: number,

            /**
             * An array of strings corresponding with fields to include in the StreamLayer. 
             */
            outFields?: string[],

            /**
             * Rules for purging data from the layer to avoid overloading the browser with too many features. 
             */
            purgeOptions?: any,

            /**
             * The URL to use for connecting to a socket. 
             */
            socketUrl?: string
    }
    declare     export interface StretchFilterOptions {

        /**
         * Indicates whether to perform dynamic range adjustment using the current pixel data. 
         */
        dra?: boolean,

            /**
             * An array of gamma values, for example [0.8, 0.8, 0.8]. 
             */
            gamma?: number[],

            /**
             * The maximum value of stretched pixels. 
             */
            max?: number,

            /**
             * Percent of pixels clipped on the right histogram tail, for example 0.25. 
             */
            maxPercent?: number,

            /**
             * The minimum value of stretched pixels. 
             */
            min?: number,

            /**
             * Percent of pixels clipped on the left histogram tail, for example 1.5. 
             */
            minPercent?: number,

            /**
             * The number of standard deviations for StandardDeviation stretch, for example 2.5. 
             */
            numberOfStandardDeviations?: number,

            /**
             * The output pixel type. 
             */
            outputPixelType?: string,

            /**
             * An array of arrays containing custom statistics objects. 
             */
            statistics?: any[][],

            /**
             * See the constants table for a list of possible stretchType values. 
             */
            stretchType?: number,

            /**
             * Indicates whether to perform non-linear gamma stretch. 
             */
            useGamma?: boolean
    }
    declare     export interface SummarizeNearbyOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * An array of numbers that defines the search distance (for StraightLine or DrivingDistance) or time (for DrivingTime) shown in the distance input in the Find nearest features using a option. 
             */
            distance?: number[],

            /**
             * When true, Travel Modes (Driving Distance, Driving Time) are enabled for sumNearbyLayer with point geometries (esriGeometryPoint). 
             */
            enableTravelModes?: boolean,

            /**
             * A field of the summarizeLayer features that you can use to calculate statistics separately for each unique attribute value. 
             */
            groupByField?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * Type of distance measurement shown as the defeault value in the Find nearest features using a option. 
             */
            nearType?: string,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * Type of units shown under the Total Area checkbox in the Add statistics from option. 
             */
            shapeUnits?: string,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * Indicates whether to display a drop down menu listing valid input analysis layers. 
             */
            showSelectAnalysisLayer?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * An array of possible statistics attribute field names and summary types that you wish to calculate for all nearby features. 
             */
            summaryFields?: string[],

            /**
             * The feature layer to be shown selected in the Choose layer to summarize dropdown. 
             */
            summaryLayer?: FeatureLayer,

            /**
             * An array of possible feature layers summarizing toward. 
             */
            summaryLayers: FeatureLayer[],

            /**
             * The point, line, or polygon feature layers from which distances will be measured to features in summarizeLayer. 
             */
            sumNearbyLayers: FeatureLayer[],

            /**
             * If true. 
             */
            sumShape?: boolean,

            /**
             * Type of units shown as the defeault value in the Find nearest features using a option. 
             */
            units?: string
    }
    declare     export interface SummarizeWithinOptions {

        /**
         * The URL to the GPServer used to execute an analysis job. 
         */
        analysisGpServer?: string,

            /**
             * A field name from summaryLayer that you can use to calculate statistics separately for each unique attribute value. 
             */
            groupByField?: string,

            /**
             * Reference to the map object. 
             */
            map?: Map,

            /**
             * The name of the output layer to be shown in the Result layer name inputbox. 
             */
            outputLayerName?: string,

            /**
             * The url to the ArcGIS.com site or in-house portal where the GP server is hosted. 
             */
            portalUrl?: string,

            /**
             * When true, returns the result of analysis as a client-side feature collection. 
             */
            returnFeatureCollection?: boolean,

            /**
             * When true, the choose extent checkbox will be shown. 
             */
            showChooseExtent?: boolean,

            /**
             * When true, the show credit option is visible. 
             */
            showCredits?: boolean,

            /**
             * When true, the help links will be shown. 
             */
            showHelp?: boolean,

            /**
             * When true, the select folder dropdown will be shown. 
             */
            showSelectFolder?: boolean,

            /**
             * A list of field names and statistical summary type that you wish to calculate for all features in SummaryLayer that are within each polygon in sumWithinLayer. 
             */
            summaryFields?: string,

            /**
             * The summary layer to be shown selected in in the Choose layer to summarize menu. 
             */
            summaryLayer?: FeatureLayer,

            /**
             * An array of summarize layer candidates. 
             */
            summaryLayers: FeatureLayer[],

            /**
             * The polygon feature layer to be summarized toward. 
             */
            sumWithinLayer: FeatureLayer
    }
    declare     export interface SymbolStylerOptions {

        /**
         * Added at v. 
         */
        portal?: string | any,

            /**
             * Self response of Portal used as symbol provider. 
             */
            portalSelf?: any,

            /**
             * URL to Portal used as symbol provider. 
             */
            portalUrl?: string
    }
    declare     export interface TemplatePickerOptions {

        /**
         * Number of visible columns. 
         */
        columns?: number,

            /**
             * Defines the text to be displayed when the template picker does not have any templates to display. 
             */
            emptyMessage?: string,

            /**
             * Array of input feature layers. 
             */
            featureLayers?: FeatureLayer[],

            /**
             * Templates are grouped based on the containing feature layer. 
             */
            grouping?: boolean,

            /**
             * An array of items described using the syntax below. 
             */
            items?: any[],

            /**
             * Length of label description. 
             */
            maxLabelLength?: number,

            /**
             * Number of visible rows. 
             */
            rows?: number,

            /**
             * Tooltip content contains the template name and description. 
             */
            showTooltip?: boolean,

            /**
             * HTML style attributes for the widget. 
             */
            style?: string,

            /**
             * When true, the template picker displays map service legend swatches for feature layers created in selection mode that have an associated map service added to the map as a dynamic map service layer. 
             */
            useLegend?: boolean
    }
    declare     export interface TimeClassBreaksAgerOptions {

        /**
         * The alpha opacity for the break. 
         */
        alpha: number,

            /**
             * The color for the break. 
             */
            color: Color,

            /**
             * The maximum age for the break info. 
             */
            maxAge: number,

            /**
             * The minimum age for the break info. 
             */
            minAge: number,

            /**
             * The size for the break. 
             */
            size: number
    }
    declare     export interface TimeSliderOptions {

        /**
         * When true, subtracts one second to the time extent's end time to exclude data at the exact end time instant. 
         */
        excludeDataAtLeadingThumb?: boolean,

            /**
             * When true, adds one second to the time extent's start time to exclude data at the exact start time instant. 
             */
            excludeDataAtTrailingThumb?: boolean
    }
    declare     export interface UndoManagerOptions {

        /**
         * The maximum number of operations the UndoManager can perform. 
         */
        maxOperations?: number
    }
    declare     export interface UnionOptions {

        /**
         * The feature(s) removed from the feature layer by the union operation. 
         */
        deletedGraphics?: Graphic[],

            /**
             * The feature layer that contains the unioned feature(s). 
             */
            featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) before the union operation is performed. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface UpdateOptions {

        /**
         * The feature layer that contains the updated feature(s). 
         */
        featureLayer?: FeatureLayer,

            /**
             * The updated feature(s). 
             */
            postUpdatedGraphics?: Graphic[],

            /**
             * The feature(s) prior to the update. 
             */
            preUpdatedGraphics?: Graphic[]
    }
    declare     export interface VEGeocoderOptions {

        /**
         * Key used to access Bing Maps maps. 
         */
        bingMapsKey?: string,

            /**
             * Specifies the culture in which to return results. 
             */
            culture?: string
    }
    declare     export interface VETiledLayerOptions {

        /**
         * Key used to access Bing Maps maps. 
         */
        bingMapsKey?: string,

            /**
             * Class attribute to set for the layer's node. 
             */
            className?: string,

            /**
             * Specifies the culture in which to return results. 
             */
            culture?: string,

            /**
             * Bing Maps style. 
             */
            mapStyle?: string,

            /**
             * Refresh interval of the layer in minutes. 
             */
            refreshInterval?: number
    }
    declare     export interface VectorFieldRendererOptions {

        /**
         * Sets the flow direction of the data. 
         */
        flowRepresentation?: string,

            /**
             * A symbol that can be defined if the style is set to STYLE_SINGLE_ARROW. 
             */
            singleArrowSymbol?: Symbol,

            /**
             * A predefined style. 
             */
            style?: string
    }
    declare     export interface VectorTileLayerOptions {

        /**
         * Lists which levels of the layer to draw. 
         */
        displayLevels?: number[],

            /**
             * Maximum visible scale for the layer. 
             */
            maxScale?: number,

            /**
             * Minimum visible scale for the layer. 
             */
            minScale?: number,

            /**
             * Initial opacity or transparency of layer. 
             */
            opacity?: number,

            /**
             * Visibility of the layer. 
             */
            visible?: boolean
    }
    declare     export interface VisibleScaleRangeSliderOptions {

        /**
         * Layer used to determine the suggested scale range and set the minScale, maxScale values. 
         */
        layer?: Layer,

            /**
             * Reference to the map. 
             */
            map: Map,

            /**
             * Region of preview scale thumbnails. 
             */
            region?: string
    }
    declare     export interface WCSConnectionOptions {

        /**
         * The coverage identifier, defaults to the first coverage. 
         */
        coverageId?: string,

            /**
             * The version of WCSLayer, can be: 1.0.01.1.01.1.11.1.22.0.1 
             */
            version?: string
    }
    declare     export interface WCSLayerOptions {

        /**
         * The coverage identifier, defaults to the first coverage. 
         */
        coverageId?: string,

            /**
             * Sets the layer's draw mode. 
             */
            drawMode?: boolean,

            /**
             * Sets the context of the Canvas. 
             */
            drawType?: string,

            /**
             * A function that takes a pixelData object as input and processes it. 
             */
            pixelFilter?: Function,

            /**
             * The version of WCSLayer, can be: 1.0.01.1.01.1.11.1.22.0.1 
             */
            version?: string,

            /**
             * A WCS Connection object. 
             */
            wcsConnection?: WCSConnection
    }
    declare     export interface WFSLayerOptions {

        /**
         * Use this to append custom parameters to WFS requests. 
         */
        customParameters?: any,

            /**
             * The template that defines the content to display in the map info window when the user clicks on a feature. 
             */
            infoTemplate?: InfoTemplate,

            /**
             * Specifies the maximum number of features to return in one response. 
             */
            maxFeatures?: number,

            /**
             * The query mode for the WFS layer. 
             */
            mode?: string,

            /**
             * The simple layer name (excluding the namespace). 
             */
            name?: string,

            /**
             * URL to the WFS server. 
             */
            url: string,

            /**
             * OGC WFS version number. 
             */
            version?: string,

            /**
             * The well-known ID of the spatial reference used by the WFSLayer. 
             */
            wkid?: string
    }
    declare     export interface WMSLayerInfoOptions {

        /**
         * All the bounding extents defined for this layer. 
         */
        allExtents?: Extent[],

            /**
             * A description of the WMS layer. 
             */
            description?: string,

            /**
             * The extent of the WMS Layer. 
             */
            extent?: Extent,

            /**
             * The URL to the legend image. 
             */
            legendURL?: string,

            /**
             * The name of the WMS layer. 
             */
            name: string,

            /**
             * Returns true if the layer can be queried and the service supports GetFeatureInfo with either text/html or text/plain formats. 
             */
            queryable?: boolean,

            /**
             * Indicates if this layer should be included in the popup. 
             */
            showPopup?: boolean,

            /**
             * All the spatial references defined for this layer. 
             */
            spatialReferences?: SpatialReference[],

            /**
             * WMSLayerInfos of the layer's sub layers. 
             */
            subLayers?: WMSLayerInfo[],

            /**
             * The title of the WMS layer. 
             */
            title?: string
    }
    declare     export interface WMSLayerOptions {

        /**
         * The customLayerParameters object used for the WMS Layer. 
         */
        customLayerParameters?: any,

            /**
             * The customParameters object used for the WMS Layer. 
             */
            customParameters?: any,

            /**
             * Specify the map image format, valid options are png,jpg,bmp,gif,svg. 
             */
            format?: string,

            /**
             * An optional resourceInfo object. 
             */
            resourceInfo?: any,

            /**
             * If the WMS service supports transparency, specify whether the image background is transparent. 
             */
            transparent?: boolean,

            /**
             * A version number. 
             */
            version?: string,

            /**
             * A list of layer names that represent the layers to include in the exported map. 
             */
            visibleLayers?: string[]
    }
    declare     export interface WMTSLayerInfoOptions {

        /**
         * The description of the layer defined by the abstract property of the capabilities file or resource info. 
         */
        description?: string,

            /**
             * Specify a format supported by the service. 
             */
            format?: string,

            /**
             * The full extent of the WMTS layer. 
             */
            fullExtent?: Extent,

            /**
             * The layer id. 
             */
            identifier?: string,

            /**
             * The initial extent of the WMTS layer. 
             */
            initialExtent?: Extent,

            /**
             * Specify the layer style. 
             */
            style?: string,

            /**
             * A tile info object. 
             */
            tileInfo?: TileInfo,

            /**
             * Define the tileMatrixSet for the layer. 
             */
            tileMatrixSet?: string,

            /**
             * The layer title. 
             */
            title?: string
    }
    declare     export interface WMTSLayerOptions {

        /**
         * The customLayerParameters object used for the WMTS Layer. 
         */
        customLayerParameters?: any,

            /**
             * The customParameters object used for the WMTS Layer. 
             */
            customParameters?: any,

            /**
             * A WMTSLayerInfo object that when ResourceInfo options are not specified the map will display the first layer in the WMTS capabilities that matches the properties specified by WMTSLayerInfo. 
             */
            layerInfo?: WMTSLayerInfo,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * An optional resource info object. 
             */
            resourceInfo?: any,

            /**
             * Specify the service type. 
             */
            serviceMode?: string
    }
    declare     export interface WebTiledLayerOptions {

        /**
         * Define attribution information for the layer to be used by the Attribution widget. 
         */
        copyright?: string,

            /**
             * Specify the full extent of the layer. 
             */
            fullExtent?: Extent,

            /**
             * Specify the initial extent of the layer. 
             */
            initialExtent?: Extent,

            /**
             * When true, tile resampling is enabled. 
             */
            resampling?: boolean,

            /**
             * Number of levels beyond the last level where tiles are available. 
             */
            resamplingTolerance?: number,

            /**
             * Specify subDomains where tiles are served to speed up tile retrieval (using subDomains gets around the browser limit of the max number of concurrent requests to a domain). 
             */
            subDomains?: string[],

            /**
             * Define the tile info for the layer including lods, rows, cols, origin and spatial reference. 
             */
            tileInfo?: TileInfo,

            /**
             * Define additional tile server domains for the layer. 
             */
            tileServers?: string[]
    }
}
declare module 'esri/Color' {
    declare module.exports: typeof Color
}
declare module 'esri/Credential' {
    declare module.exports: typeof Credential
}
declare module 'esri/IdentityManager' {
    declare module.exports: typeof IdentityManager
}
declare module 'esri/IdentityManagerBase' {
    declare module.exports: typeof IdentityManagerBase
}
declare module 'esri/ImageSpatialReference' {
    declare module.exports: typeof ImageSpatialReference
}
declare module 'esri/InfoTemplate' {
    declare module.exports: typeof InfoTemplate
}
declare module 'esri/InfoWindowBase' {
    declare module.exports: typeof InfoWindowBase
}
declare module 'esri/OperationBase' {
    declare module.exports: typeof OperationBase
}
declare module 'esri/ServerInfo' {
    declare module.exports: typeof ServerInfo
}
declare module 'esri/SnappingManager' {
    declare module.exports: typeof SnappingManager
}
declare module 'esri/SpatialReference' {
    declare module.exports: typeof SpatialReference
}
declare module 'esri/TimeExtent' {
    declare module.exports: typeof TimeExtent
}
declare module 'esri/arcgis/OAuthInfo' {
    declare module.exports: typeof OAuthInfo
}
declare module 'esri/arcgis/Portal' {

    /**
     * The Portal class is part of the ArcGIS Portal API which provides a way to build applications that work with content from ArcGIS Online or an ArcGIS Portal. 
     */
    declare     export class Portal {

        /**
         * The access level of the organization. 
         */
        access: string;

        /**
         * When true, access to the organization's Portal resources must occur over SSL. 
         */
        allSSL: boolean;

        /**
         * The query that defines the basemaps that are displayed in the Basemap Gallery. 
         */
        basemapGalleryGroupQuery: string;

        /**
         * The Bing key to use for web maps using Bing Maps. 
         */
        bingKey: string;

        /**
         * Whether an organization can list applications in the marketplace . 
         */
        canListApps: boolean;

        /**
         * Whether an organization can list data services in the marketplace. 
         */
        canListData: boolean;

        /**
         * Whether an organization can list pre-provisioned items in the marketplace. 
         */
        canListPreProvisionedItems: boolean;

        /**
         * Whether an organization can provision direct purchases in the marketplace without customer request. 
         */
        canProvisionDirectPurchase: boolean;

        /**
         * When true, the organization's public items, groups and users are included in search queries. 
         */
        canSearchPublic: boolean;

        /**
         * The Bing key can be shared to the public and is returned as part of a portal's description call (/sharing/rest/portals/). 
         */
        canShareBingPublic: boolean;

        /**
         * When true, members of the organization can share resources outside the organization. 
         */
        canSharePublic: boolean;

        /**
         * Whether to allow an organization with an enterprise IDP configured to be able to turn on or off the ArcGIS sign in. 
         */
        canSignInArcGIS: boolean;

        /**
         * Whether to allow an organization with an enterprise IDP configured to be able to turn on or off the enterprise sign in. 
         */
        canSignInIDP: boolean;

        /**
         * The query that identifies the group containing the color sets used for rendering in the map viewer. 
         */
        colorSetsGroupQuery: string;

        /**
         * Whether to allow the organization to disable commenting. 
         */
        commentsEnabled: boolean;

        /**
         * Date the organization was created. 
         */
        created: Date;

        /**
         * The default locale (language and country) information. 
         */
        culture: string;

        /**
         * The custom base URL for the portal. 
         */
        customBaseUrl: string;

        /**
         * The default basemap the portal displays in the map viewer. 
         */
        defaultBasemap: any;

        /**
         * The default extent for the map the portal displays in the map viewer. 
         */
        defaultExtent: any;

        /**
         * A description of the organization / portal. 
         */
        description: string;

        /**
         * The featured groups for the portal. 
         */
        featuredGroups: any[];

        /**
         * The featured groups for the organization. 
         */
        featuredGroupsId: string;

        /**
         * The query that defines the featured group. 
         */
        featuredItemsGroupQuery: string;

        /**
         * The query that identifies the group containing features items for the gallery. 
         */
        galleryTemplatesGroupQuery: string;

        /**
         * The group that contains featured content to be displayed on the home page. 
         */
        homePageFeaturedContent: string;

        /**
         * The number of featured items that can be displayed on the home page. 
         */
        homePageFeaturedContentCount: number;

        /**
         * The port used by the portal for HTTP communication. 
         */
        httpPort: number;

        /**
         * The port used by the portal for HTTPS communication. 
         */
        httpsPort: number;

        /**
         * The id of the organization that owns this portal. 
         */
        id: string;

        /**
         * The country code of the calling IP (ArcGIS Online only). 
         */
        ipCntryCode: string;

        /**
         * Indicates if the portal is an organization. 
         */
        isOrganization: boolean;

        /**
         * Indicates if the portal is on premises. 
         */
        isPortal: boolean;

        /**
         * The query that defines the collection of editable layer templates. 
         */
        layerTemplatesGroupQuery: string;

        /**
         * The maximum validity in minutes of tokens issued for users of the organization. 
         */
        maxTokenExpirationMinutes: number;

        /**
         * Date the organization was last modified. 
         */
        modified: Date;

        /**
         * The Name of the organization / portal. 
         */
        name: string;

        /**
         * The portal host's URL. 
         */
        portalHostname: string;

        /**
         * Denotes multitenant or singletenant. 
         */
        portalMode: string;

        /**
         * The name of the portal, i.e., ArcGIS Online. 
         */
        portalName: string;

        /**
         * Stores properties specific to the organization, for example the "contact us" link. 
         */
        portalProperties: any;

        /**
         * The URL to the thumbnail of the portal. 
         */
        portalThumbnail: string;

        /**
         * URL to the portal. 
         */
        portalUrl: string;

        /**
         * The region for the organization. 
         */
        region: string;

        /**
         * Custom HTML for the home page. 
         */
        rotatorPanels: string[];

        /**
         * Whether the description of your organization displays on the home page. 
         */
        showHomePageDescription: boolean;

        /**
         * Whether hosted services are supported. 
         */
        supportsHostedServices: boolean;

        /**
         * Whether OAuth is supported. 
         */
        supportsOAuth: boolean;

        /**
         * The query that defines the symbols sets used by the map viewer. 
         */
        symbolSetsGroupQuery: string;

        /**
         * The query that defines the collection of templates that will appear in the template gallery. 
         */
        templatesGroupQuery: string;

        /**
         * The URL to the thumbnail of the organization. 
         */
        thumbnail: string;

        /**
         * The url to the thumbnail of the organization (full path). 
         */
        thumbnailUrl: string;

        /**
         * Sets the units of measure for the organization's users. 
         */
        units: string;

        /**
         * The portal url. 
         */
        url: string;

        /**
         * The prefix selected by the organization's administrator to be used with the customBaseURL. 
         */
        urlKey: string;

        /**
         * User information for the accessing user is returned only when a token is passed in. 
         */
        user: PortalUser;

        /**
         * If true, only simple where clauses that are complaint with SQL92 can be used when querying layers and tables. 
         */
        useStandardizedQuery: boolean;

        /**
         * Creates a new Portal object.
         * @param url URL to the ArcGIS.com site or in-house portal.
         */
        constructor(url: string): this;

        /**
         * Returns a PortalUser object that describes the user currently signed in to the portal. 
         */
        getPortalUser(): PortalUser;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalGroup objects for all the groups that match the input query.
         * @param queryParams The input query parameters.
         */
        queryGroups(queryParams?: any): any;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalItem objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryItems(queryParams?: any): any;

        /**
         * Execute a query against the Portal to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalUser objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryUsers(queryParams?: any): any;

        /**
         * Prompts the user using the IdentityManager and returns a deferred that, when resolved, returns the PortalUser for the input credentials. 
         */
        signIn(): any;

        /**
         * Sign out of the Portal which resets the Portal and disables identity checking. 
         */
        signOut(): Portal;

        /**
         * Fires when the signIn() call fails or if the Portal is not able to load. 
         */
        on(
            type: "error",
            listener: (event: {
                error: error$Error,
                target: Portal
            }) => void): esri.Handle;

        /**
         * Fired when the portal has loaded. 
         */
        on(type: "load", listener: (event: {
            target: Portal
        }) => void): esri.Handle;
        on(type: string, listener: (event: any) => void): esri.Handle
    }

    /**
     * Details about a comment on a Portal item.View the ArcGIS Portal API REST documentation for the item comment for more details. 
     */
    declare     export class PortalComment {

        /**
         * The comment text. 
         */
        comment: string;

        /**
         * The date and time the comment was created. 
         */
        created: string;

        /**
         * The comment id. 
         */
        id: string;

        /**
         * The user name of the user who created the comment. 
         */
        owner: string
    }

    /**
     * The PortalFolder class provides information about folders used to organize content in a portal. 
     */
    declare     export class PortalFolder {

        /**
         * The date the folder was created. 
         */
        created: Date;

        /**
         * The id of the folder. 
         */
        id: string;

        /**
         * The portal for the folder. 
         */
        portal: Portal;

        /**
         * The title of the folder. 
         */
        title: string;

        /**
         * The url to to the folder. 
         */
        url: string;

        /**
         * Find all the items in the folder. 
         */
        getItems(): any
    }

    /**
     * The group resource represents a group within the Portal. 
     */
    declare     export class PortalGroup {

        /**
         * The access privileges on the group which determines who can see and access the group. 
         */
        access: string;

        /**
         * The date the group was created. 
         */
        created: Date;

        /**
         * A detailed description of the group. 
         */
        description: string;

        /**
         * The id for the group. 
         */
        id: string;

        /**
         * If this is set to true, then users will not be able to apply to join the group. 
         */
        isInvitationOnly: boolean;

        /**
         * Denotes a view only group where members are not able to share items. 
         */
        isViewOnly: boolean;

        /**
         * The date the group was last modified. 
         */
        modified: Date;

        /**
         * The username of the group's owner. 
         */
        owner: string;

        /**
         * The portal for the group. 
         */
        portal: Portal;

        /**
         * A short summary that describes the group. 
         */
        snippet: string;

        /**
         * User defined tags that describe the group. 
         */
        tags: string[];

        /**
         * The url to the thumbnail used for the group. 
         */
        thumbnailUrl: string;

        /**
         * The title for the group. 
         */
        title: string;

        /**
         * The url to the group. 
         */
        url: string;

        /**
         * Get the current members for the group. 
         */
        getMembers(): any;

        /**
         * Execute a query against the group to return a deferred that when resolved returns PortalQueryResult that contain a results array of PortalItem objects that match the input query.
         * @param queryParams The input query parameters.
         */
        queryItems(queryParams?: any): any
    }

    /**
     * An item (a unit of content) in the Portal. 
     */
    declare     export class PortalItem {

        /**
         * Indicates the level of access: private, shared, org, or public. 
         */
        access: string;

        /**
         * Information on the source of the item. 
         */
        accessInformation: string;

        /**
         * Average rating. 
         */
        avgRating: number;

        /**
         * The date the item was created. 
         */
        created: Date;

        /**
         * The item locale information (language and country). 
         */
        culture: string;

        /**
         * The detailed description of the item. 
         */
        description: string;

        /**
         * The bounding rectangle of the item. 
         */
        extent: any;

        /**
         * The unique id for this item. 
         */
        id: string;

        /**
         * The url to the data resource associated with the item. 
         */
        itemDataUrl: string;

        /**
         * The url to the item. 
         */
        itemUrl: string;

        /**
         * Any license information or restrictions. 
         */
        licenseInfo: string;

        /**
         * Date the item was last modified. 
         */
        modified: Date;

        /**
         * The name of the item. 
         */
        name: string;

        /**
         * Number of comments on the item. 
         */
        numComments: number;

        /**
         * Number of ratings on the item. 
         */
        numRatings: number;

        /**
         * Number of views on the item. 
         */
        numViews: number;

        /**
         * The username of the user who owns this item. 
         */
        owner: string;

        /**
         * The portal that contains the item. 
         */
        portal: Portal;

        /**
         * The size of the item. 
         */
        size: number;

        /**
         * A summary description of the item. 
         */
        snippet: string;

        /**
         * The item's coordinate system. 
         */
        spatialReference: string;

        /**
         * User defined tags that describe the item. 
         */
        tags: string[];

        /**
         * The url to the thumbnail used for the item. 
         */
        thumbnailUrl: string;

        /**
         * The title for the item. 
         */
        title: string;

        /**
         * The gis content type of this item. 
         */
        type: string;

        /**
         * A set of keywords that further describes the type of this item. 
         */
        typeKeywords: string[];

        /**
         * The url for the resource represented by the item. 
         */
        url: string;

        /**
         * The url to the user item. 
         */
        userItemUrl: string;

        /**
         * Add a comment to the item.
         * @param comment The text for the comment.
         */
        addComment(comment: string): any;

        /**
         * Add a rating to an item that you have access to.
         * @param rating Rating to set for the item.
         */
        addRating(rating: number): any;

        /**
         * Deletes an item comment.
         * @param comment The PortalComment to delete.
         */
        deleteComment(comment: PortalComment): any;

        /**
         * Delete a rating that you created for the specified item.
         * @param rating Rating to delete.
         */
        deleteRating(rating: PortalRating): any;

        /**
         * Get the comments associated with the item. 
         */
        getComments(): any;

        /**
         * Returns the rating (if any) given to the item. 
         */
        getRating(): any;

        /**
         * Updates an item comment.
         * @param comment A PortalComment that contains the comment updates.
         */
        updateComment(comment: PortalComment): any
    }

    /**
     * Details about the result of a query. 
     */
    declare     export class PortalQueryResult {

        /**
         * The query parameters for the next set of results. 
         */
        nextQueryParams: any;

        /**
         * The query parameters for the first set of results. 
         */
        queryParams: any;

        /**
         * An array of  result item objects. 
         */
        results: any[];

        /**
         * The total number of results. 
         */
        total: number
    }

    /**
     * Details about the rating associated with a Portal item. 
     */
    declare     export class PortalRating {

        /**
         * Date the rating was added to the item. 
         */
        created: Date;

        /**
         * A rating between 1.0 and 5.0 for the item. 
         */
        rating: number
    }

    /**
     * Represents a registered user of the Portal. 
     */
    declare     export class PortalUser {

        /**
         * The access level for the user: private, org or public. 
         */
        access: string;

        /**
         * The date the user was created. 
         */
        created: Date;

        /**
         * The default culture for the user. 
         */
        culture: string;

        /**
         * Description of the user. 
         */
        description: string;

        /**
         * The user's email address. 
         */
        email: string;

        /**
         * The user's full name. 
         */
        fullName: string;

        /**
         * The date the user was modified. 
         */
        modified: Date;

        /**
         * The id of the organization the user belongs to. 
         */
        orgId: string;

        /**
         * The portal. 
         */
        portal: Portal;

        /**
         * The user's preferred view for content, either Web or GIS. 
         */
        preferredView: string;

        /**
         * The user's preferred region, used to set the featured maps on the portal home page, content in the gallery and the default extent for new maps in the Viewer. 
         */
        region: string;

        /**
         * The user's role in the organization: administrator (org_admin), publisher (org_publisher), or user (org_user). 
         */
        role: string;

        /**
         * User-defined tags that describe the user. 
         */
        tags: string[];

        /**
         * The url to the thumbnail image for the user. 
         */
        thumbnailUrl: string;

        /**
         * The url for the user content. 
         */
        userContentUrl: string;

        /**
         * The username for the user. 
         */
        username: string;

        /**
         * Find folders for the portal user. 
         */
        getFolders(): any;

        /**
         * Provides access to the group invitations for the portal user. 
         */
        getGroupInvitations(): any;

        /**
         * Find all the groups that the portal user has permissions to access. 
         */
        getGroups(): any;

        /**
         * Get the portal item along with folder info for the input item id.
         * @param itemId The id of the item.
         */
        getItem(itemId: string): any;

        /**
         * Retrieve all the items in the specified folder.
         * @param folderId The id of the folder that contains the items to retrieve.
         */
        getItems(folderId?: string): any;

        /**
         * Get information about any notifications for the portal user. 
         */
        getNotifications(): any;

        /**
         * Access the tag objects that have been created by the portal user. 
         */
        getTags(): any
    }
}
declare module 'esri/arcgis/utils' {
    declare     var utils: {

        /**
         * Specify the domain where the map associated with the webmap id is located. 
         */
        arcgisUrl: string,

        /**
         * Create a map using information from an ArcGIS.com item.
         * @param itemIdOrItemInfo An itemId for an ArcGIS.com item or the response object obtained from calling the arcgisUtils.getItem method.
         * @param mapDiv Container ID for referencing map.
         * @param options Optional parameters that define the map functionality.
         */
        createMap(itemIdOrItemInfo: string | any, mapDiv: string, options?: any): any,

        /**
         * Get details about the input ArcGIS.com item.
         * @param itemId The itemId for a publicly shared ArcGIS.com item.
         */
        getItem(itemId: string): any,

        /**
         * Can be used with LayerList widget to get the layers list to be passed into the constructor.
         * @param createMapResponse The object created from the resolved promise returned by createMap().
         */
        getLayerList(createMapResponse: any): any[],

        /**
         * Can be used with esri.dijit.Legend to get the layerInfos list to be passed into the Legend constructor.
         * @param createMapResponse Object returned by .createMap() in the .then() callback.
         */
        getLegendLayers(createMapResponse: any): any[]
    };
    declare module.exports: typeof utils
}
declare module 'esri/basemaps' {
    declare     var basemaps: {

        /**
         * The Light Gray Canvas basemap is designed to be used as a neutral background map for overlaying and emphasizing other map layers. 
         */
        gray: any,

        /**
         * The World Imagery map is a detailed imagery map layer and labels that is designed to be used as a basemap for various maps and applications. 
         */
        hybrid: any,

        /**
         * The Ocean Basemap is designed to be used as a basemap by marine GIS professionals and as a reference map by anyone interested in ocean data. 
         */
        oceans: any,

        /**
         * The OpenStreetMap is a community map layer that is designed to be used as a basemap for various maps and applications. 
         */
        osm: any,

        /**
         * The World Imagery map is a detailed imagery map layer that is designed to be used as a basemap for various maps and applications. 
         */
        satellite: any,

        /**
         * The Streets basemap presents a multiscale street map for the world. 
         */
        streets: any,

        /**
         * The Terrain with Labels basemap is designed to be used to overlay and emphasize other thematic map layers. 
         */
        terrain: any,

        /**
         * The Topographic map includes boundaries, cities, water features, physiographic features, parks, landmarks, transportation, and buildings. 
         */
        topo: any
    };
    declare module.exports: typeof basemaps
}
declare module 'esri/config' {
    declare     var config: {

        /**
         * ArcGIS JavaScript API default configurations that can be overridden programmatically. 
         */
        defaults: any
    };
    declare module.exports: typeof config
}
declare module 'esri/dijit/AttributeInspector' {
    declare module.exports: typeof AttributeInspector
}
declare module 'esri/dijit/Attribution' {
    declare module.exports: typeof Attribution
}
declare module 'esri/dijit/Basemap' {
    declare module.exports: typeof Basemap
}
declare module 'esri/dijit/BasemapGallery' {
    declare module.exports: typeof BasemapGallery
}
declare module 'esri/dijit/BasemapLayer' {
    declare module.exports: typeof BasemapLayer
}
declare module 'esri/dijit/BasemapToggle' {
    declare module.exports: typeof BasemapToggle
}
declare module 'esri/dijit/BookmarkItem' {
    declare module.exports: typeof BookmarkItem
}
declare module 'esri/dijit/Bookmarks' {
    declare module.exports: typeof Bookmarks
}
declare module 'esri/dijit/ClassedColorSlider' {
    declare module.exports: typeof ClassedColorSlider
}
declare module 'esri/dijit/ClassedSizeSlider' {
    declare module.exports: typeof ClassedSizeSlider
}
declare module 'esri/dijit/ColorInfoSlider' {
    declare module.exports: typeof ColorInfoSlider
}
declare module 'esri/dijit/ColorPicker' {
    declare module.exports: typeof ColorPicker
}
declare module 'esri/dijit/Directions' {
    declare module.exports: typeof Directions
}
declare module 'esri/dijit/ElevationProfile' {
    declare module.exports: typeof ElevationProfile
}
declare module 'esri/dijit/FeatureTable' {
    declare module.exports: typeof FeatureTable
}
declare module 'esri/dijit/Gallery' {
    declare module.exports: typeof Gallery
}
declare module 'esri/dijit/Gauge' {
    declare module.exports: typeof Gauge
}
declare module 'esri/dijit/Geocoder' {
    declare module.exports: typeof Geocoder
}
declare module 'esri/dijit/HeatmapSlider' {
    declare module.exports: typeof HeatmapSlider
}
declare module 'esri/dijit/HistogramTimeSlider' {
    declare module.exports: typeof HistogramTimeSlider
}
declare module 'esri/dijit/HomeButton' {
    declare module.exports: typeof HomeButton
}
declare module 'esri/dijit/HorizontalSlider' {
    declare module.exports: typeof HorizontalSlider
}
declare module 'esri/dijit/ImageServiceMeasure' {
    declare module.exports: typeof ImageServiceMeasure
}
declare module 'esri/dijit/InfoWindow' {
    declare module.exports: typeof InfoWindow
}
declare module 'esri/dijit/InfoWindowLite' {
    declare module.exports: typeof InfoWindowLite
}
declare module 'esri/dijit/LayerList' {
    declare module.exports: typeof LayerList
}
declare module 'esri/dijit/LayerSwipe' {
    declare module.exports: typeof LayerSwipe
}
declare module 'esri/dijit/Legend' {
    declare module.exports: typeof Legend
}
declare module 'esri/dijit/LocateButton' {
    declare module.exports: typeof LocateButton
}
declare module 'esri/dijit/Measurement' {
    declare module.exports: typeof Measurement
}
declare module 'esri/dijit/ObliqueViewer' {
    declare module.exports: typeof ObliqueViewer
}
declare module 'esri/dijit/OpacitySlider' {
    declare module.exports: typeof OpacitySlider
}
declare module 'esri/dijit/OverviewMap' {
    declare module.exports: typeof OverviewMap
}
declare module 'esri/dijit/Popup' {
    declare module.exports: typeof Popup
}
declare module 'esri/dijit/PopupMobile' {
    declare module.exports: typeof PopupMobile
}
declare module 'esri/dijit/PopupTemplate' {
    declare module.exports: typeof PopupTemplate
}
declare module 'esri/dijit/Print' {
    declare module.exports: typeof Print
}
declare module 'esri/dijit/RendererSlider' {
    declare module.exports: typeof RendererSlider
}
declare module 'esri/dijit/Scalebar' {
    declare module.exports: typeof Scalebar
}
declare module 'esri/dijit/Search' {
    declare module.exports: typeof Search
}
declare module 'esri/dijit/SizeInfoSlider' {
    declare module.exports: typeof SizeInfoSlider
}
declare module 'esri/dijit/SymbolStyler' {
    declare module.exports: typeof SymbolStyler
}
declare module 'esri/dijit/TimeSlider' {
    declare module.exports: typeof TimeSlider
}
declare module 'esri/dijit/VisibleScaleRangeSlider' {
    declare module.exports: typeof VisibleScaleRangeSlider
}
declare module 'esri/dijit/analysis/AggregatePoints' {
    declare module.exports: typeof AggregatePoints
}
declare module 'esri/dijit/analysis/AnalysisBase' {
    declare module.exports: typeof AnalysisBase
}
declare module 'esri/dijit/analysis/CalculateDensity' {
    declare module.exports: typeof CalculateDensity
}
declare module 'esri/dijit/analysis/ChooseBestFacilities' {
    declare module.exports: typeof ChooseBestFacilities
}
declare module 'esri/dijit/analysis/ConnectOriginsToDestinations' {
    declare module.exports: typeof ConnectOriginsToDestinations
}
declare module 'esri/dijit/analysis/CreateBuffers' {
    declare module.exports: typeof CreateBuffers
}
declare module 'esri/dijit/analysis/CreateDriveTimeAreas' {
    declare module.exports: typeof CreateDriveTimeAreas
}
declare module 'esri/dijit/analysis/CreateViewshed' {
    declare module.exports: typeof CreateViewshed
}
declare module 'esri/dijit/analysis/CreateWatersheds' {
    declare module.exports: typeof CreateWatersheds
}
declare module 'esri/dijit/analysis/DeriveNewLocations' {
    declare module.exports: typeof DeriveNewLocations
}
declare module 'esri/dijit/analysis/DissolveBoundaries' {
    declare module.exports: typeof DissolveBoundaries
}
declare module 'esri/dijit/analysis/EnrichLayer' {
    declare module.exports: typeof EnrichLayer
}
declare module 'esri/dijit/analysis/ExtractData' {
    declare module.exports: typeof ExtractData
}
declare module 'esri/dijit/analysis/FindExistingLocations' {
    declare module.exports: typeof FindExistingLocations
}
declare module 'esri/dijit/analysis/FindHotSpots' {
    declare module.exports: typeof FindHotSpots
}
declare module 'esri/dijit/analysis/FindNearest' {
    declare module.exports: typeof FindNearest
}
declare module 'esri/dijit/analysis/FindSimilarLocations' {
    declare module.exports: typeof FindSimilarLocations
}
declare module 'esri/dijit/analysis/InterpolatePoints' {
    declare module.exports: typeof InterpolatePoints
}
declare module 'esri/dijit/analysis/MergeLayers' {
    declare module.exports: typeof MergeLayers
}
declare module 'esri/dijit/analysis/OverlayLayers' {
    declare module.exports: typeof OverlayLayers
}
declare module 'esri/dijit/analysis/PlanRoutes' {
    declare module.exports: typeof PlanRoutes
}
declare module 'esri/dijit/analysis/SummarizeNearby' {
    declare module.exports: typeof SummarizeNearby
}
declare module 'esri/dijit/analysis/SummarizeWithin' {
    declare module.exports: typeof SummarizeWithin
}
declare module 'esri/dijit/analysis/TraceDownstream' {
    declare module.exports: typeof TraceDownstream
}
declare module 'esri/dijit/editing/Add' {
    declare module.exports: typeof Add
}
declare module 'esri/dijit/editing/AttachmentEditor' {
    declare module.exports: typeof AttachmentEditor
}
declare module 'esri/dijit/editing/Cut' {
    declare module.exports: typeof Cut
}
declare module 'esri/dijit/editing/Delete' {
    declare module.exports: typeof Delete
}
declare module 'esri/dijit/editing/Editor' {
    declare module.exports: typeof Editor
}
declare module 'esri/dijit/editing/TemplatePicker' {
    declare module.exports: typeof TemplatePicker
}
declare module 'esri/dijit/editing/Union' {
    declare module.exports: typeof Union
}
declare module 'esri/dijit/editing/Update' {
    declare module.exports: typeof Update
}
declare module 'esri/dijit/geoenrichment/DataBrowser' {
    declare module.exports: typeof DataBrowser
}
declare module 'esri/dijit/geoenrichment/Infographic' {
    declare module.exports: typeof Infographic
}
declare module 'esri/dijit/geoenrichment/InfographicsCarousel' {
    declare module.exports: typeof InfographicsCarousel
}
declare module 'esri/dijit/geoenrichment/InfographicsOptions' {
    declare module.exports: typeof InfographicsOptions
}
declare module 'esri/dijit/geoenrichment/InfographicsOptionsItem' {
    declare module.exports: typeof InfographicsOptionsItem
}
declare module 'esri/dijit/util/busyIndicator' {
    declare     var busyIndicator: {

        /**
         * Creates a busy indicator on a target.
         * @param target The String (Node id, dijit/_WidgetBase id), HTMLElement reference (Node), or dijit/_WidgetBase.
         * @param params (Optional) The params options can be used when needing more fine-grained control.
         */
        create(target: string | HTMLElement | any, params?: any): any
    };
    declare module.exports: typeof busyIndicator
}
declare module 'esri/domUtils' {
    declare     var domUtils: {

        /**
         * Represents the size of the client side window or document at first load. 
         */
        documentBox: any,

        /**
         * Returns the DOM node from HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase to retrieve.
         */
        getNode(target: HTMLElement | any): CSG$Node,

        /**
         * Hides the HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        hide(target: HTMLElement | any): void,

        /**
         * Shows the HTMLElement or dijit/_WidgetBase.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        show(target: HTMLElement | any): void,

        /**
         * If the target (HTMLElement or dijit/_WidgetBase) is currently visible, the target is hidden.
         * @param target The HTMLElement or dijit/_WidgetBase.
         */
        toggle(target: HTMLElement | any): void
    };
    declare module.exports: typeof domUtils
}
declare module 'esri/geometry/Circle' {
    declare module.exports: typeof Circle
}
declare module 'esri/geometry/Extent' {
    declare module.exports: typeof Extent
}
declare module 'esri/geometry/Geometry' {
    declare module.exports: typeof Geometry
}
declare module 'esri/geometry/Multipoint' {
    declare module.exports: typeof Multipoint
}
declare module 'esri/geometry/Point' {
    declare module.exports: typeof Point
}
declare module 'esri/geometry/Polygon' {
    declare module.exports: typeof Polygon
}
declare module 'esri/geometry/Polyline' {
    declare module.exports: typeof Polyline
}
declare module 'esri/geometry/ScreenPoint' {
    declare module.exports: typeof ScreenPoint
}
declare module 'esri/geometry/geodesicUtils' {
    declare     var geodesicUtils: {

        /**
         * Determine the area for the input polygons.
         * @param polygons An array of polygons.
         * @param areaUnit The area unit.
         */
        geodesicAreas(polygons: CSG$Polygon[], areaUnit: string): number[],

        /**
         * Returns a densified geometry.
         * @param geometry A polyline or polygon to densify.
         * @param maxSegmentLength The maximum segment length in meters.
         */
        geodesicDensify(geometry: Geometry, maxSegmentLength: number): Geometry,

        /**
         * Determine the length for the input polylines using the specified length unit.
         * @param polylines An array of polylines.
         * @param lengthUnit The length unit.
         */
        geodesicLengths(polylines: Polyline[], lengthUnit: string): number[]
    };
    declare module.exports: typeof geodesicUtils
}
declare module 'esri/geometry/geometryEngine' {
    declare     var geometryEngine: {

        /**
         * Creates planar (or Euclidean) buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        buffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): CSG$Polygon | CSG$Polygon[],

        /**
         * Calculates the clipped geometry from a target geometry by an envelope.
         * @param geometry The geometry to be clipped.
         * @param envelope The envelope used to clip.
         */
        clip(geometry: Geometry, envelope: Extent): Geometry,

        /**
         * Indicates if one geometry contains another geometry.
         * @param geometry1 The geometry that is tested for the contains relationship to the other geometry.
         * @param geometry2 The geometry that is tested for within relationship to the other geometry.
         */
        contains(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the convex hull of the input geometry.
         * @param geometry The input geometry.
         * @param merge Whether to merge output geometries.
         */
        convexHull(geometry: Geometry | Geometry[], merge?: boolean): Geometry | Geometry[],

        /**
         * Indicates if one geometry crosses another geometry.
         * @param geometry1 The geometry to cross.
         * @param geometry2 The geometry being crossed.
         */
        crosses(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Split the input Polyline or Polygon where it crosses a cutting Polyline.
         * @param geometry The geometry to be cut.
         * @param cutter The polyline to cut the geometry.
         */
        cut(geometry: Geometry, cutter: Polyline): Geometry[],

        /**
         * Densify geometries by plotting points between existing vertices.
         * @param geometry The geometry to be densified.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        densify(
            geometry: Geometry,
            maxSegmentLength: number,
            maxSegmentLengthUnit: string | number): Geometry,

        /**
         * Creates the difference of two geometries.
         * @param inputGeometry The input geometry to subtract from.
         * @param subtractor The geometry being subtracted from inputGeometry.
         */
        difference(
            inputGeometry: Geometry | Geometry[],
            subtractor: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry is disjoint (doesn't intersect in any way) with another geometry.
         * @param geometry1 The base geometry that is tested for the "disjoint" relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the disjoint relationship to the other geometry.
         */
        disjoint(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the shortest planar distance between two geometries.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         * @param distanceUnit Measurement unit of the return value.
         */
        distance(
            geometry1: Geometry,
            geometry2: Geometry,
            distanceUnit: string | number): number,

        /**
         * Indicates if two geometries are equal.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         */
        equals(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Returns an object containing additional information about the input spatial reference.
         * @param spatialReference The spatial Reference.
         */
        extendedSpatialReferenceInfo(spatialReference: SpatialReference): any,

        /**
         * Flips a geometry on the horizontal axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipHorizontal(geometry: Geometry, flipOrigin?: Point): Geometry,

        /**
         * Flips a geometry on the vertical axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipVertical(geometry: Geometry, flipOrigin?: Point): Geometry,

        /**
         * Performs the generalize operation on the geometries in the cursor.
         * @param geometry The geometry to be generalized.
         * @param maxDeviation The maximum allowed deviation from the generalized geometry to the original geometry.
         * @param removeDegenerateParts When true, the degenerate parts of the geometry will be removed from the output (may be undesired for drawing).
         * @param maxDeviationUnit Measurement unit for maxDeviation.
         */
        generalize(
            geometry: Geometry,
            maxDeviation: number,
            removeDegenerateParts?: boolean,
            maxDeviationUnit?: string | number): Geometry,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicArea(geometry: Geometry, unit: string | number): number,

        /**
         * Creates geodesic buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        geodesicBuffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): CSG$Polygon | CSG$Polygon[],

        /**
         * Returns a geodesically densified version of the input geometry.
         * @param geometry A polyline or polygon geometry to densify.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        geodesicDensify(
            geometry: Polyline | CSG$Polygon,
            maxSegmentLength: number,
            maxSegmentLengthUnit?: number): Geometry,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicLength(geometry: Geometry, unit: string | number): number,

        /**
         * Creates a new geometry through intersection between two geometries.
         * @param geometry The input geometry.
         * @param intersector The geometry being intersected.
         */
        intersect(geometry: Geometry | Geometry[], intersector: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry intersects another geometry.
         * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
         * @param geometry2 The geometry being intersected.
         */
        intersects(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Indicates if the given geometry is topologically simple.
         * @param geometry Geometry
         */
        isSimple(geometry: Geometry): boolean,

        /**
         * Finds the coordinate of the geometry which is closest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest coordinate in the geometry.
         */
        nearestCoordinate(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds vertex on the geometry nearest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest vertex in the geometry.
         */
        nearestVertex(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds all vertices in the given distance from the specified point, sorted from the closest to the furthest and returns them as an array of objects.
         * @param geometry The geometry to consider.
         * @param inputPoint The point from which to measure.
         * @param searchRadius The search radius.
         * @param maxVertexCountToReturn The maximum number number of vertices to return.
         */
        nearestVertices(
            geometry: Geometry,
            inputPoint: Point,
            searchRadius: number,
            maxVertexCountToReturn: number): any[],

        /**
         * Creates offset version of the input geometry.
         * @param geometry The geometries to offset.
         * @param offsetDistance The offset distance for the Geometries.
         * @param offsetUnit Measurement unit for the offset.
         * @param joinType The join type.
         * @param bevelRatio Applicable to MITER, bevelRatio is multiplied by the offset distance and the result determines how far a mitered offset intersection can be located before it is beveled.
         * @param flattenError Applicable to ROUND, flattenError determines the maximum distance of the resulting segments compared to the true circular arc.
         */
        offset(
            geometry: Geometry | Geometry[],
            offsetDistance: number,
            offsetUnit: string | number,
            joinType: string,
            bevelRatio?: number,
            flattenError?: number): Geometry | Geometry[],

        /**
         * Indicates if one geometry  overlaps another geometry.
         * @param geometry1 The base geometry that is tested for overlaps relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the overlaps relationship to the other geometry.
         */
        overlaps(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarArea(geometry: Geometry, unit: string | number): number,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarLength(geometry: Geometry, unit: string | number): number,

        /**
         * Indicates if the given DE-9IM relation holds for the two geometries.
         * @param geometry1 The first geometry for the relation.
         * @param geometry2 The second geometry for the relation.
         * @param relation The Dimensionally Extended 9 Intersection Model (DE-9IM) matrix relation (encoded as a string) to test against the relationship of the two geometries.
         */
        relate(geometry1: Geometry, geometry2: Geometry, relation: string): boolean,

        /**
         * Rotates a geometry by a specified angle.
         * @param geometry The input geometry.
         * @param angle The rotation angle
         * @param rotationOrigin Point to rotate the geometry around.
         */
        rotate(geometry: Geometry, angle: number, rotationOrigin?: Point): Geometry,

        /**
         * Performs the simplify operation on the geometry which alters the given geometries to make their definitions topologically legal with respect to their geometry type.
         * @param geometry The geometry to be simplified.
         */
        simplify(geometry: Geometry): Geometry,

        /**
         * Creates the symmetric difference of two geometries.
         * @param leftGeometry One of the Geometry instances in the XOR operation.
         * @param rightGeometry One of the Geometry instances in the XOR operation.
         */
        symmetricDifference(
            leftGeometry: Geometry | Geometry[],
            rightGeometry: Geometry): Geometry | Geometry[],

        /**
         * Indicates if one geometry touches another geometry.
         * @param geometry1 The geometry which may be touching another geometry.
         * @param geometry2 The geometry to be touched.
         */
        touches(geometry1: Geometry, geometry2: Geometry): boolean,

        /**
         * All inputs must be of the same type of geometries and share one spatial reference.
         * @param geometries The geometries to union.
         */
        union(geometries: Geometry[]): Geometry,

        /**
         * Indicates if one geometry is within another geometry.
         * @param geometry1 The base geometry that is tested for within relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the contains relationship to the other geometry.
         */
        within(geometry1: Geometry, geometry2: Geometry): boolean
    };
    declare module.exports: typeof geometryEngine
}
declare module 'esri/geometry/geometryEngineAsync' {
    declare     var geometryEngineAsync: {

        /**
         * Creates planar (or Euclidean) buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        buffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): any,

        /**
         * Calculates the clipped geometry from a target geometry by an envelope.
         * @param geometry The geometry to be clipped.
         * @param envelope The envelope used to clip.
         */
        clip(geometry: Geometry, envelope: Extent): any,

        /**
         * Indicates if one geometry contains another geometry.
         * @param geometry1 The geometry that is tested for the contains relationship to the other geometry.
         * @param geometry2 The geometry that is tested for within relationship to the other geometry.
         */
        contains(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the convex hull of the input geometry.
         * @param geometry The input geometry.
         * @param merge Whether to merge output geometries.
         */
        convexHull(geometry: Geometry | Geometry[], merge?: boolean): any,

        /**
         * Indicates if one geometry crosses another geometry.
         * @param geometry1 The geometry to cross.
         * @param geometry2 The geometry being crossed.
         */
        crosses(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Split the input polyline or polygon where it crosses a cutting polyline.
         * @param geometry The geometry to be cut.
         * @param cutter The polyline to cut the geometry.
         */
        cut(geometry: Geometry, cutter: Polyline): any,

        /**
         * Densify geometries by plotting points between existing vertices.
         * @param geometry The geometry to be densified.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        densify(
            geometry: Geometry,
            maxSegmentLength: number,
            maxSegmentLengthUnit: string | number): any,

        /**
         * Creates the difference of two geometries.
         * @param inputGeometry The input geometry to subtract from.
         * @param subtractor The geometry being subtracted.
         */
        difference(inputGeometry: Geometry | Geometry[], subtractor: Geometry): any,

        /**
         * Indicates if one geometry is disjoint (doesn't intersect in any way) with another geometry.
         * @param geometry1 The base geometry that is tested for the "disjoint" relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the disjoint relationship to the other geometry.
         */
        disjoint(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the shortest planar distance between two geometries.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         * @param distanceUnit Measurement unit of the return value.
         */
        distance(geometry1: Geometry, geometry2: Geometry, distanceUnit: string | number): any,

        /**
         * Indicates if two geometries are equal.
         * @param geometry1 First input geometry.
         * @param geometry2 Second input geometry.
         */
        equals(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Returns an object containing additional information about the input spatial reference.
         * @param spatialReference The input spatial reference.
         */
        extendedSpatialReferenceInfo(spatialReference: SpatialReference): any,

        /**
         * Flips a geometry on the horizontal axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipHorizontal(geometry: Geometry, flipOrigin?: Point): any,

        /**
         * Flips a geometry on the vertical axis.
         * @param geometry The input geometry.
         * @param flipOrigin Point to flip the geometry around.
         */
        flipVertical(geometry: Geometry, flipOrigin?: Point): any,

        /**
         * Performs the generalize operation on the geometries in the cursor.
         * @param geometry The geometry to be generalized.
         * @param maxDeviation The maximum allowed deviation from the generalized geometry to the original geometry.
         * @param removeDegenerateParts When true, the degenerate parts of the geometry will be removed from the output (may be undesired for drawing).
         * @param maxDeviationUnit Measurement unit for maxDeviation.
         */
        generalize(
            geometry: Geometry,
            maxDeviation: number,
            removeDegenerateParts?: boolean,
            maxDeviationUnit?: string | number): any,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicArea(geometry: Geometry, unit: string | number): any,

        /**
         * Creates geodesic buffer polygons at a specified distance around the input geometries.
         * @param geometry The buffer input geometry.
         * @param distance The specified distance(s) for buffering.
         * @param unit Measurement unit for the distance(s).
         * @param unionResults Whether the output geometries should be unioned into a single polygon.
         */
        geodesicBuffer(
            geometry: Geometry | Geometry[],
            distance: number | number[],
            unit: string | number,
            unionResults?: boolean): any,

        /**
         * Resolves to a geodesically densified version of the input geometry.
         * @param geometry A polyline or polygon geometry to densify.
         * @param maxSegmentLength The maximum segment length allowed.
         * @param maxSegmentLengthUnit Measurement unit for maxSegmentLength.
         */
        geodesicDensify(
            geometry: Polyline | CSG$Polygon,
            maxSegmentLength: number,
            maxSegmentLengthUnit?: number): any,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        geodesicLength(geometry: Geometry, unit: string | number): any,

        /**
         * Creates a new geometry through intersection between two geometries.
         * @param geometry The input geometry.
         * @param intersector The geometry being intersected.
         */
        intersect(geometry: Geometry | Geometry[], intersector: Geometry): any,

        /**
         * Indicates if one geometry intersects another geometry.
         * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
         * @param geometry2 The geometry being intersected.
         */
        intersects(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Indicates if the given geometry is topologically simple.
         * @param geometry Geometry
         */
        isSimple(geometry: Geometry): any,

        /**
         * Finds the coordinate of the geometry which is closest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest coordinate in the geometry.
         */
        nearestCoordinate(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds vertex on the geometry nearest to the specified point.
         * @param geometry The geometry to consider.
         * @param inputPoint The point used to search the nearest vertex in the geometry.
         */
        nearestVertex(geometry: Geometry, inputPoint: Point): any,

        /**
         * Finds all vertices in the given distance from the specified point, sorted from the closest to the furthest and returns them as an array of objects once resolved.
         * @param geometry The geometry to consider.
         * @param inputPoint The point from which to measure.
         * @param searchRadius The search radius.
         * @param maxVertexCountToReturn The maximum number number of vertices to return.
         */
        nearestVertices(
            geometry: Geometry,
            inputPoint: Point,
            searchRadius: number,
            maxVertexCountToReturn: number): any,

        /**
         * Creates offset version of the input geometry.
         * @param geometry The geometries to offset.
         * @param offsetDistance The offset distance for the Geometries.
         * @param offsetUnit Measurement unit for the offset.
         * @param joinType The join type.
         * @param bevelRatio Applicable to MITER, bevelRatio is multiplied by the offset distance and the result determines how far a mitered offset intersection can be located before it is beveled.
         * @param flattenError Applicable to ROUND, flattenError determines the maximum distance of the resulting segments compared to the true circular arc.
         */
        offset(
            geometry: Geometry | Geometry[],
            offsetDistance: number,
            offsetUnit: string | number,
            joinType: string,
            bevelRatio?: number,
            flattenError?: number): any,

        /**
         * Indicates if one geometry  overlaps another geometry.
         * @param geometry1 The base geometry that is tested for overlaps relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the overlaps relationship to the other geometry.
         */
        overlaps(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * Calculates the area of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarArea(geometry: Geometry, unit: string | number): any,

        /**
         * Calculates the length of the input geometry.
         * @param geometry The input geometry.
         * @param unit Measurement unit of the return value.
         */
        planarLength(geometry: Geometry, unit: string | number): any,

        /**
         * Indicates if the given DE-9IM relation holds for the two geometries.
         * @param geometry1 The first geometry for the relation.
         * @param geometry2 The second geometry for the relation.
         * @param relation The Dimensionally Extended 9 Intersection Model (DE-9IM) matrix relation (encoded as a string) to test against the relationship of the two geometries.
         */
        relate(geometry1: Geometry, geometry2: Geometry, relation: string): any,

        /**
         * Rotates a geometry by a specified angle.
         * @param geometry The input geometry.
         * @param angle The rotation angle
         * @param rotationOrigin Point to rotate the geometry around.
         */
        rotate(geometry: Geometry, angle: number, rotationOrigin?: Point): any,

        /**
         * Performs the simplify operation on the geometry which alters the given geometries to make their definitions topologically legal with respect to their geometry type.
         * @param geometry The geometry to be simplified.
         */
        simplify(geometry: Geometry): any,

        /**
         * Creates the symmetric difference of two geometries.
         * @param leftGeometry One of the Geometry instances in the XOR operation.
         * @param rightGeometry One of the Geometry instances in the XOR operation.
         */
        symmetricDifference(leftGeometry: Geometry | Geometry[], rightGeometry: Geometry): any,

        /**
         * Indicates if one geometry touches another geometry.
         * @param geometry1 The geometry which may be touching another geometry.
         * @param geometry2 The geometry to be touched.
         */
        touches(geometry1: Geometry, geometry2: Geometry): any,

        /**
         * All inputs must be of the same type of geometries and share one spatial reference.
         * @param geometries The geometries to union.
         */
        union(geometries: Geometry[]): any,

        /**
         * Indicates if one geometry is within another geometry.
         * @param geometry1 The base geometry that is tested for within relationship to the other geometry.
         * @param geometry2 The comparison geometry that is tested for the contains relationship to the other geometry.
         */
        within(geometry1: Geometry, geometry2: Geometry): any
    };
    declare module.exports: typeof geometryEngineAsync
}
declare module 'esri/geometry/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts the input JSON object to the appropriate esri.geometry. object.
         * @param json The JSON object.
         */
        fromJson(json: AV$Object): Geometry,

        /**
         * Requests the geometry type name as represented in the ArcGIS REST.
         * @param geometry The ArcGIS JavaScript API geometry type to be converted.
         */
        getJsonType(geometry: Geometry): string
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/geometry/mathUtils' {
    declare     var mathUtils: {

        /**
         * Calculates the length of a line based on the input of two points.
         * @param point1 The beginning point.
         * @param point2 The ending point.
         */
        getLength(point1: Point, point2: Point): number,

        /**
         * Calculates the intersecting point of two lines.
         * @param line1start The beginning point of the first line.
         * @param line1end The ending point of the first line.
         * @param line2start The beginning point of the second line.
         * @param line2end The ending point of the second line.
         */
        getLineIntersection(line1start: Point, line1end: Point, line2start: Point, line2end: Point): Point
    };
    declare module.exports: typeof mathUtils
}
declare module 'esri/geometry/normalizeUtils' {
    declare     var normalizeUtils: {

        /**
         * Normalizes  geometries that intersect the central meridian or fall outside the world extent so they stay within the current coordinate system.
         * @param geometries An array of geometries to normalize.
         * @param geometryService Specify a valid geometry service.
         * @param callback The function to call when the method has completed.
         * @param errback An error object is returned, if an error occurs on the Server during task execution.
         */
        normalizeCentralMeridian(
            geometries: Geometry[],
            geometryService?: GeometryService,
            callback?: Function,
            errback?: Function): any
    };
    declare module.exports: typeof normalizeUtils
}
declare module 'esri/geometry/scaleUtils' {
    declare     var scaleUtils: {

        /**
         * Get the extent for the specified scale.
         * @param map The input map.
         * @param scale The input scale.
         */
        getExtentForScale(map: Map, scale: number): Extent,

        /**
         * Gets the current scale of the map.
         * @param map The map whose scale should be calculated.
         */
        getScale(map: Map): number,

        /**
         * Returns the value of one map unit for the given spatial reference (in meters).
         * @param sr The spatial reference represented as a SpatialReference class, Number, or String.
         */
        getUnitValueForSR(sr: SpatialReference | number | string): number
    };
    declare module.exports: typeof scaleUtils
}
declare module 'esri/geometry/screenUtils' {
    declare     var screenUtils: {

        /**
         * Converts the geometry argument to map coordinates based on the extent, width, and height of the Map.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param screenGeometry The geometry to convert from screen to map units.
         */
        toMapGeometry(
            extent: Extent,
            width: number,
            height: number,
            screenGeometry: Geometry): Geometry,

        /**
         * Converts and returns the argument screen point in map coordinates.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param screenPoint The screenPoint to convert from screen to map units.
         */
        toMapPoint(extent: Extent, width: number, height: number, screenPoint: ScreenPoint): Point,

        /**
         * Converts the geometry argument to screen coordinates based on the extent, width, and height of the Map.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param mapGeometry The geometry to convert from map to screen units.
         */
        toScreenGeometry(extent: Extent, width: number, height: number, mapGeometry: Geometry): Geometry,

        /**
         * Converts and returns the argument map point in screen coordinates.
         * @param extent The current extent of the map in map coordinates.
         * @param width The current width of the map in screen units.
         * @param height The current height of the map in screen units.
         * @param mapPoint The point to convert from map to screen units.
         */
        toScreenPoint(extent: Extent, width: number, height: number, mapPoint: Point): ScreenPoint
    };
    declare module.exports: typeof screenUtils
}
declare module 'esri/geometry/webMercatorUtils' {
    declare     var webMercatorUtils: {

        /**
         * Returns true if the 'source' can be projected to 'target' by the project() function, or if the 'source' and 'target' is the same spatialReference.
         * @param source An input of type SpatialReference or an object with spatialReference property such as Geometry or Map.
         * @param target The target spatial reference, of type SpatialReference or an object with spatialReference property such as Map.
         */
        canProject(source: SpatialReference | any, target: SpatialReference | any): boolean,

        /**
         * Converts geometry from geographic units to Web Mercator units.
         * @param geometry The geometry to convert.
         */
        geographicToWebMercator(geometry: Geometry): Geometry,

        /**
         * Translates the given latitude and longitude values to Web Mercator.
         * @param long The longitude value to convert.
         * @param lat The latitude value to convert.
         */
        lngLatToXY(long: number, lat: number): number[],

        /**
         * Project the geometry clientside (if possible).
         * @param geometry An input geometry.
         * @param target The target spatial reference, of type SpatialReference or an object with spatialReference property such as Map.
         */
        project(geometry: Geometry, target: SpatialReference | any): any,

        /**
         * Converts geometry from Web Mercator units to geographic units.
         * @param geometry The geometry to convert.
         * @param isLinear Indicates whether to work with linear values, i.e., do not normalize.
         */
        webMercatorToGeographic(geometry: Geometry, isLinear?: boolean): Geometry,

        /**
         * Translates the given Web Mercator coordinates to Longitude and Latitude.
         * @param x The x coordinate value to convert.
         * @param y The y coordinate value to convert.
         */
        xyToLngLat(x: number, y: number): number[]
    };
    declare module.exports: typeof webMercatorUtils
}
declare module 'esri/graphic' {
    declare module.exports: typeof Graphic
}
declare module 'esri/graphicsUtils' {
    declare     var graphicsUtils: {

        /**
         * Converts an array of graphics to an array of geometries.
         * @param graphics Array of graphics to convert to geometries
         */
        getGeometries(graphics: Graphic[]): Geometry[],

        /**
         * Utility function that returns the extent of an array of graphics.
         * @param graphics The input graphics array.
         */
        graphicsExtent(graphics: Graphic[]): Extent
    };
    declare module.exports: typeof graphicsUtils
}
declare module 'esri/kernel' {
    declare     var kernel: {

        /**
         * Current version of the JavaScript API. 
         */
        version: string
    };
    declare module.exports: typeof kernel
}
declare module 'esri/lang' {
    declare     var lang: {

        /**
         * Creates a new object with all properties that pass the test implemented by the filter provided in the function.
         * @param object Object  to filter.
         * @param callback Function or string implementing the filtering.
         * @param thisObject Optional object used to scope the call to the callback.
         */
        filter(object: any, callback: Function, thisObject: any): any,

        /**
         * Returns true when the value is neither null or undefined.
         * @param value The value to test.
         */
        isDefined(value: any): boolean,

        /**
         * Strips HTML tags from a String or Object.
         * @param value Object or String to be stripped of HTML tags.
         */
        stripTags(value: any | string): any | string,

        /**
         * A wrapper around dojo.string.substitute that can also handle wildcard substitution.
         * @param data The data object used in the substitution.
         * @param template The template used for the substitution.
         * @param first When true, returns only the first property found in the data object.
         */
        substitute(data: any, template?: string, first?: boolean): string,

        /**
         * Iterates through the argument array and searches for the identifier to which the argument value matches.
         * @param array The argument array for testing.
         * @param value The value used in the search.
         */
        valueOf(array: any[], value: any): any
    };
    declare module.exports: typeof lang
}
declare module 'esri/layers/ArcGISDynamicMapServiceLayer' {
    declare module.exports: typeof ArcGISDynamicMapServiceLayer
}
declare module 'esri/layers/ArcGISImageServiceLayer' {
    declare module.exports: typeof ArcGISImageServiceLayer
}
declare module 'esri/layers/ArcGISImageServiceVectorLayer' {
    declare module.exports: typeof ArcGISImageServiceVectorLayer
}
declare module 'esri/layers/ArcGISTiledMapServiceLayer' {
    declare module.exports: typeof ArcGISTiledMapServiceLayer
}
declare module 'esri/layers/CSVLayer' {
    declare module.exports: typeof CSVLayer
}
declare module 'esri/layers/CodedValueDomain' {
    declare module.exports: typeof CodedValueDomain
}
declare module 'esri/layers/DataAdapterFeatureLayer' {
    declare module.exports: typeof DataAdapterFeatureLayer
}
declare module 'esri/layers/DataSource' {
    declare module.exports: typeof DataSource
}
declare module 'esri/layers/DimensionalDefinition' {
    declare module.exports: typeof DimensionalDefinition
}
declare module 'esri/layers/Domain' {
    declare module.exports: typeof Domain
}
declare module 'esri/layers/DynamicLayerInfo' {
    declare module.exports: typeof DynamicLayerInfo
}
declare module 'esri/layers/DynamicMapServiceLayer' {
    declare module.exports: typeof DynamicMapServiceLayer
}
declare module 'esri/layers/FeatureEditResult' {
    declare module.exports: typeof FeatureEditResult
}
declare module 'esri/layers/FeatureLayer' {
    declare module.exports: typeof FeatureLayer
}
declare module 'esri/layers/FeatureTemplate' {
    declare module.exports: typeof FeatureTemplate
}
declare module 'esri/layers/FeatureType' {
    declare module.exports: typeof FeatureType
}
declare module 'esri/layers/Field' {
    declare module.exports: typeof Field
}
declare module 'esri/layers/GeoRSSLayer' {
    declare module.exports: typeof GeoRSSLayer
}
declare module 'esri/layers/GraphicsLayer' {
    declare module.exports: typeof GraphicsLayer
}
declare module 'esri/layers/ImageParameters' {
    declare module.exports: typeof ImageParameters
}
declare module 'esri/layers/ImageServiceParameters' {
    declare module.exports: typeof ImageServiceParameters
}
declare module 'esri/layers/InheritedDomain' {
    declare module.exports: typeof InheritedDomain
}
declare module 'esri/layers/JoinDataSource' {
    declare module.exports: typeof JoinDataSource
}
declare module 'esri/layers/KMLFolder' {
    declare module.exports: typeof KMLFolder
}
declare module 'esri/layers/KMLGroundOverlay' {
    declare module.exports: typeof KMLGroundOverlay
}
declare module 'esri/layers/KMLLayer' {
    declare module.exports: typeof KMLLayer
}
declare module 'esri/layers/LOD' {
    declare module.exports: typeof LOD
}
declare module 'esri/layers/LabelClass' {
    declare module.exports: typeof LabelClass
}
declare module 'esri/layers/LabelLayer' {
    declare module.exports: typeof LabelLayer
}
declare module 'esri/layers/LayerDataSource' {
    declare module.exports: typeof LayerDataSource
}
declare module 'esri/layers/LayerDrawingOptions' {
    declare module.exports: typeof LayerDrawingOptions
}
declare module 'esri/layers/LayerInfo' {
    declare module.exports: typeof LayerInfo
}
declare module 'esri/layers/LayerMapSource' {
    declare module.exports: typeof LayerMapSource
}
declare module 'esri/layers/LayerSource' {
    declare module.exports: typeof LayerSource
}
declare module 'esri/layers/LayerTimeOptions' {
    declare module.exports: typeof LayerTimeOptions
}
declare module 'esri/layers/MapImage' {
    declare module.exports: typeof MapImage
}
declare module 'esri/layers/MapImageLayer' {
    declare module.exports: typeof MapImageLayer
}
declare module 'esri/layers/MosaicRule' {
    declare module.exports: typeof MosaicRule
}
declare module 'esri/layers/OpenStreetMapLayer' {
    declare module.exports: typeof OpenStreetMapLayer
}
declare module 'esri/layers/PixelBlock' {
    declare module.exports: typeof PixelBlock
}
declare module 'esri/layers/QueryDataSource' {
    declare module.exports: typeof QueryDataSource
}
declare module 'esri/layers/RangeDomain' {
    declare module.exports: typeof RangeDomain
}
declare module 'esri/layers/RasterDataSource' {
    declare module.exports: typeof RasterDataSource
}
declare module 'esri/layers/RasterFunction' {
    declare module.exports: typeof RasterFunction
}
declare module 'esri/layers/RasterLayer' {
    declare module.exports: typeof RasterLayer
}
declare module 'esri/layers/StreamLayer' {
    declare module.exports: typeof StreamLayer
}
declare module 'esri/layers/TableDataSource' {
    declare module.exports: typeof TableDataSource
}
declare module 'esri/layers/TileInfo' {
    declare module.exports: typeof TileInfo
}
declare module 'esri/layers/TiledMapServiceLayer' {
    declare module.exports: typeof TiledMapServiceLayer
}
declare module 'esri/layers/TimeInfo' {
    declare module.exports: typeof TimeInfo
}
declare module 'esri/layers/TimeReference' {
    declare module.exports: typeof TimeReference
}
declare module 'esri/layers/VectorTileLayer' {
    declare module.exports: typeof VectorTileLayer
}
declare module 'esri/layers/WCSConnection' {
    declare module.exports: typeof WCSConnection
}
declare module 'esri/layers/WCSCoverageDescription' {
    declare module.exports: typeof WCSCoverageDescription
}
declare module 'esri/layers/WCSLayer' {
    declare module.exports: typeof WCSLayer
}
declare module 'esri/layers/WFSLayer' {
    declare module.exports: typeof WFSLayer
}
declare module 'esri/layers/WMSLayer' {
    declare module.exports: typeof WMSLayer
}
declare module 'esri/layers/WMSLayerInfo' {
    declare module.exports: typeof WMSLayerInfo
}
declare module 'esri/layers/WMTSLayer' {
    declare module.exports: typeof WMTSLayer
}
declare module 'esri/layers/WMTSLayerInfo' {
    declare module.exports: typeof WMTSLayerInfo
}
declare module 'esri/layers/WebTiledLayer' {
    declare module.exports: typeof WebTiledLayer
}
declare module 'esri/layers/layer' {
    declare module.exports: typeof Layer
}
declare module 'esri/layers/pixelfilters/StretchFilter' {
    declare module.exports: typeof StretchFilter
}
declare module 'esri/map' {
    declare module.exports: typeof Map
}
declare module 'esri/opsdashboard/DataSourceProxy' {
    declare module.exports: typeof DataSourceProxy
}
declare module 'esri/opsdashboard/ExtensionBase' {
    declare module.exports: typeof ExtensionBase
}
declare module 'esri/opsdashboard/ExtensionConfigurationBase' {
    declare module.exports: typeof ExtensionConfigurationBase
}
declare module 'esri/opsdashboard/FeatureActionConfigurationProxy' {
    declare module.exports: typeof FeatureActionConfigurationProxy
}
declare module 'esri/opsdashboard/FeatureActionFeatures' {
    declare module.exports: typeof FeatureActionFeatures
}
declare module 'esri/opsdashboard/GraphicsLayerProxy' {
    declare module.exports: typeof GraphicsLayerProxy
}
declare module 'esri/opsdashboard/MapToolConfigurationProxy' {
    declare module.exports: typeof MapToolConfigurationProxy
}
declare module 'esri/opsdashboard/MapToolProxy' {
    declare module.exports: typeof MapToolProxy
}
declare module 'esri/opsdashboard/MapWidgetProxy' {
    declare module.exports: typeof MapWidgetProxy
}
declare module 'esri/opsdashboard/WidgetConfigurationProxy' {
    declare module.exports: typeof WidgetConfigurationProxy
}
declare module 'esri/opsdashboard/WidgetProxy' {
    declare module.exports: typeof WidgetProxy
}
declare module 'esri/opsdashboard/featureActionProxy' {
    declare module.exports: typeof featureActionProxy
}
declare module 'esri/plugins/FeatureLayerStatistics' {
    declare module.exports: typeof FeatureLayerStatistics
}
declare module 'esri/plugins/spatialIndex' {
    declare     var spatialIndex: {

        /**
         * Adds an index property to the target instance.
         * @param target The map or feature layer to which the index is connected.
         * @param options See the object specifications table below for the structure of the index  options  object.
         */
        add(target: Map | FeatureLayer, options?: any): void,

        /**
         * Removes the index plugin. 
         */
        remove(): void
    };
    declare module.exports: typeof spatialIndex
}
declare module 'esri/process/Processor' {
    declare module.exports: typeof Processor
}
declare module 'esri/process/SpatialIndex' {
    declare module.exports: typeof SpatialIndex
}
declare module 'esri/renderers/BlendRenderer' {
    declare module.exports: typeof BlendRenderer
}
declare module 'esri/renderers/ClassBreaksRenderer' {
    declare module.exports: typeof ClassBreaksRenderer
}
declare module 'esri/renderers/DotDensityRenderer' {
    declare module.exports: typeof DotDensityRenderer
}
declare module 'esri/renderers/HeatmapRenderer' {
    declare module.exports: typeof HeatmapRenderer
}
declare module 'esri/renderers/Renderer' {
    declare module.exports: typeof Renderer
}
declare module 'esri/renderers/ScaleDependentRenderer' {
    declare module.exports: typeof ScaleDependentRenderer
}
declare module 'esri/renderers/SimpleRenderer' {
    declare module.exports: typeof SimpleRenderer
}
declare module 'esri/renderers/SymbolAger' {
    declare module.exports: typeof SymbolAger
}
declare module 'esri/renderers/TemporalRenderer' {
    declare module.exports: typeof TemporalRenderer
}
declare module 'esri/renderers/TimeClassBreaksAger' {
    declare module.exports: typeof TimeClassBreaksAger
}
declare module 'esri/renderers/TimeRampAger' {
    declare module.exports: typeof TimeRampAger
}
declare module 'esri/renderers/UniqueValueRenderer' {
    declare module.exports: typeof UniqueValueRenderer
}
declare module 'esri/renderers/VectorFieldRenderer' {
    declare module.exports: typeof VectorFieldRenderer
}
declare module 'esri/renderers/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts the input JSON object to the appropriate esri.renderer. object.
         * @param json The JSON object.
         */
        fromJson(json: AV$Object): Renderer
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/renderers/smartMapping' {
    declare     var smartMapping: {

        /**
         * Creates a renderer for visualizing features using colors.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createClassedColorRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features by varying their size.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createClassedSizeRenderer(params: any): any,

        /**
         * Creates an object defining a color ramp used to render a layer.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createColorInfo(params: any): any,

        /**
         * Creates a renderer for visualizing features using colors.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createColorRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features using heatmap.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createHeatmapRenderer(params: any): any,

        /**
         * Creates an object that describes how opacity of features is calculated.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createOpacityInfo(params: any): any,

        /**
         * Creates a renderer for identifying features by their color.
         * @param params See the Object Specifications table below for the structure of the params object.
         */
        createPredominanceRenderer(params: any): any,

        /**
         * Defines the size of the symbol where feature size is proportional to data value.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createSizeInfo(params: any): any,

        /**
         * Creates a renderer for visualizing features by varying their size based on data.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createSizeRenderer(params: any): any,

        /**
         * Creates a renderer for visualizing features by their type.
         * @param params See the object specifications table below for the structure of the params object.
         */
        createTypeRenderer(params: any): any,

        /**
         * Searches the fields of an input layer or array of field objects for field names commonly used in rendering based on usage (e.g.
         * @param params See the object specifications table below for details about the params object.
         */
        getSuggestedField(params: any): any
    };
    declare module.exports: typeof smartMapping
}
declare module 'esri/request' {
    declare     var request: {

        /**
         * Retrieve data from a remote server or upload a file from a user's computer.
         * @param request The request parameter is an object with the following properties that describe the request.
         * @param options See the object specifications table below for the structure of the  options  object.
         */
        (request: any, options?: any): any,

        /**
         * Define a callback function that will be called just before esri.request calls into dojo IO functions such as dojo.rawXhrPost and dojo.io.script.get.
         * @param callbackFunction The callback function that will be executed prior to esri.request calls into dojo IO functions.
         */
        setRequestPreCallback(callbackFunction: Function): void
    };
    declare module.exports: typeof request
}
declare module 'esri/symbols/CartographicLineSymbol' {
    declare module.exports: typeof CartographicLineSymbol
}
declare module 'esri/symbols/FillSymbol' {
    declare module.exports: typeof FillSymbol
}
declare module 'esri/symbols/Font' {
    declare module.exports: typeof Font
}
declare module 'esri/symbols/LineSymbol' {
    declare module.exports: typeof LineSymbol
}
declare module 'esri/symbols/MarkerSymbol' {
    declare module.exports: typeof MarkerSymbol
}
declare module 'esri/symbols/PictureFillSymbol' {
    declare module.exports: typeof PictureFillSymbol
}
declare module 'esri/symbols/PictureMarkerSymbol' {
    declare module.exports: typeof PictureMarkerSymbol
}
declare module 'esri/symbols/SimpleFillSymbol' {
    declare module.exports: typeof SimpleFillSymbol
}
declare module 'esri/symbols/SimpleLineSymbol' {
    declare module.exports: typeof SimpleLineSymbol
}
declare module 'esri/symbols/SimpleMarkerSymbol' {
    declare module.exports: typeof SimpleMarkerSymbol
}
declare module 'esri/symbols/Symbol' {
    declare module.exports: typeof Symbol
}
declare module 'esri/symbols/TextSymbol' {
    declare module.exports: typeof TextSymbol
}
declare module 'esri/symbols/jsonUtils' {
    declare     var jsonUtils: {

        /**
         * Converts input json into a symbol, returns null if the input json represents an unknown or unsupported symbol type.
         * @param json The input JSON.
         */
        fromJson(json: AV$Object): Symbol,

        /**
         * Returns the shape description properties for the given symbol as defined by the Dojo GFX API.
         * @param symbol The input symbol.
         */
        getShapeDescriptors(symbol: Symbol): any
    };
    declare module.exports: typeof jsonUtils
}
declare module 'esri/tasks/AddressCandidate' {
    declare module.exports: typeof AddressCandidate
}
declare module 'esri/tasks/AlgorithmicColorRamp' {
    declare module.exports: typeof AlgorithmicColorRamp
}
declare module 'esri/tasks/AreasAndLengthsParameters' {
    declare module.exports: typeof AreasAndLengthsParameters
}
declare module 'esri/tasks/BufferParameters' {
    declare module.exports: typeof BufferParameters
}
declare module 'esri/tasks/ClassBreaksDefinition' {
    declare module.exports: typeof ClassBreaksDefinition
}
declare module 'esri/tasks/ClassificationDefinition' {
    declare module.exports: typeof ClassificationDefinition
}
declare module 'esri/tasks/ClosestFacilityParameters' {
    declare module.exports: typeof ClosestFacilityParameters
}
declare module 'esri/tasks/ClosestFacilitySolveResult' {
    declare module.exports: typeof ClosestFacilitySolveResult
}
declare module 'esri/tasks/ClosestFacilityTask' {
    declare module.exports: typeof ClosestFacilityTask
}
declare module 'esri/tasks/ColorRamp' {
    declare module.exports: typeof ColorRamp
}
declare module 'esri/tasks/DataFile' {
    declare module.exports: typeof DataFile
}
declare module 'esri/tasks/DataLayer' {
    declare module.exports: typeof DataLayer
}
declare module 'esri/tasks/Date' {
    declare module.exports: typeof AGSDate
}
declare module 'esri/tasks/DensifyParameters' {
    declare module.exports: typeof DensifyParameters
}
declare module 'esri/tasks/DirectionsFeatureSet' {
    declare module.exports: typeof DirectionsFeatureSet
}
declare module 'esri/tasks/DistanceParameters' {
    declare module.exports: typeof DistanceParameters
}
declare module 'esri/tasks/FeatureSet' {
    declare module.exports: typeof FeatureSet
}
declare module 'esri/tasks/FindParameters' {
    declare module.exports: typeof FindParameters
}
declare module 'esri/tasks/FindResult' {
    declare module.exports: typeof FindResult
}
declare module 'esri/tasks/FindTask' {
    declare module.exports: typeof FindTask
}
declare module 'esri/tasks/GPMessage' {
    declare module.exports: typeof GPMessage
}
declare module 'esri/tasks/GeneralizeParameters' {
    declare module.exports: typeof GeneralizeParameters
}
declare module 'esri/tasks/GenerateRendererParameters' {
    declare module.exports: typeof GenerateRendererParameters
}
declare module 'esri/tasks/GenerateRendererTask' {
    declare module.exports: typeof GenerateRendererTask
}
declare module 'esri/tasks/GeometryService' {
    declare module.exports: typeof GeometryService
}
declare module 'esri/tasks/Geoprocessor' {
    declare module.exports: typeof Geoprocessor
}
declare module 'esri/tasks/IdentifyParameters' {
    declare module.exports: typeof IdentifyParameters
}
declare module 'esri/tasks/IdentifyResult' {
    declare module.exports: typeof IdentifyResult
}
declare module 'esri/tasks/IdentifyTask' {
    declare module.exports: typeof IdentifyTask
}
declare module 'esri/tasks/ImageServiceIdentifyParameters' {
    declare module.exports: typeof ImageServiceIdentifyParameters
}
declare module 'esri/tasks/ImageServiceIdentifyResult' {
    declare module.exports: typeof ImageServiceIdentifyResult
}
declare module 'esri/tasks/ImageServiceIdentifyTask' {
    declare module.exports: typeof ImageServiceIdentifyTask
}
declare module 'esri/tasks/ImageServiceMeasureParameters' {
    declare module.exports: typeof ImageServiceMeasureParameters
}
declare module 'esri/tasks/ImageServiceMeasureTask' {
    declare module.exports: typeof ImageServiceMeasureTask
}
declare module 'esri/tasks/JobInfo' {
    declare module.exports: typeof JobInfo
}
declare module 'esri/tasks/LegendLayer' {
    declare module.exports: typeof LegendLayer
}
declare module 'esri/tasks/LengthsParameters' {
    declare module.exports: typeof LengthsParameters
}
declare module 'esri/tasks/LinearUnit' {
    declare module.exports: typeof LinearUnit
}
declare module 'esri/tasks/MultipartColorRamp' {
    declare module.exports: typeof MultipartColorRamp
}
declare module 'esri/tasks/NAMessage' {
    declare module.exports: typeof NAMessage
}
declare module 'esri/tasks/NATypes' {
    declare     var NATypes: {
        OutputLine: esri.NAOutputLine,
        OutputPolygon: esri.NAOutputPolygon,
        TravelDirection: esri.NATravelDirection,
        UTurn: esri.NAUTurn
    };
    declare module.exports: typeof NATypes
}
declare module 'esri/tasks/OffsetParameters' {
    declare module.exports: typeof OffsetParameters
}
declare module 'esri/tasks/ParameterValue' {
    declare module.exports: typeof ParameterValue
}
declare module 'esri/tasks/PrintParameters' {
    declare module.exports: typeof PrintParameters
}
declare module 'esri/tasks/PrintTask' {
    declare module.exports: typeof PrintTask
}
declare module 'esri/tasks/PrintTemplate' {
    declare module.exports: typeof PrintTemplate
}
declare module 'esri/tasks/ProjectParameters' {
    declare module.exports: typeof ProjectParameters
}
declare module 'esri/tasks/QueryTask' {
    declare module.exports: typeof QueryTask
}
declare module 'esri/tasks/RasterData' {
    declare module.exports: typeof RasterData
}
declare module 'esri/tasks/RelationParameters' {
    declare module.exports: typeof RelationParameters
}
declare module 'esri/tasks/RelationshipQuery' {
    declare module.exports: typeof RelationshipQuery
}
declare module 'esri/tasks/RouteParameters' {
    declare module.exports: typeof RouteParameters
}
declare module 'esri/tasks/RouteResult' {
    declare module.exports: typeof RouteResult
}
declare module 'esri/tasks/RouteTask' {
    declare module.exports: typeof RouteTask
}
declare module 'esri/tasks/ServiceAreaParameters' {
    declare module.exports: typeof ServiceAreaParameters
}
declare module 'esri/tasks/ServiceAreaSolveResult' {
    declare module.exports: typeof ServiceAreaSolveResult
}
declare module 'esri/tasks/ServiceAreaTask' {
    declare module.exports: typeof ServiceAreaTask
}
declare module 'esri/tasks/StatisticDefinition' {
    declare module.exports: typeof StatisticDefinition
}
declare module 'esri/tasks/TrimExtendParameters' {
    declare module.exports: typeof TrimExtendParameters
}
declare module 'esri/tasks/UniqueValueDefinition' {
    declare module.exports: typeof UniqueValueDefinition
}
declare module 'esri/tasks/datareviewer/BatchValidationJob' {
    declare module.exports: typeof BatchValidationJob
}
declare module 'esri/tasks/datareviewer/BatchValidationJobInfo' {
    declare module.exports: typeof BatchValidationJobInfo
}
declare module 'esri/tasks/datareviewer/BatchValidationParameters' {
    declare module.exports: typeof BatchValidationParameters
}
declare module 'esri/tasks/datareviewer/BatchValidationTask' {
    declare module.exports: typeof BatchValidationTask
}
declare module 'esri/tasks/datareviewer/DashboardResult' {
    declare module.exports: typeof DashboardResult
}
declare module 'esri/tasks/datareviewer/DashboardTask' {
    declare module.exports: typeof DashboardTask
}
declare module 'esri/tasks/datareviewer/GetResultsQueryParameters' {
    declare module.exports: typeof GetResultsQueryParameters
}
declare module 'esri/tasks/datareviewer/ReviewerAttributes' {
    declare module.exports: typeof ReviewerAttributes
}
declare module 'esri/tasks/datareviewer/ReviewerFilters' {
    declare module.exports: typeof ReviewerFilters
}
declare module 'esri/tasks/datareviewer/ReviewerLifecycle' {
    declare     var ReviewerLifecycle: {

        /**
         * Acceptable lifecycleStatus code = 4 belongs to Verification Phase. 
         */
        ACCEPTABLE: number,

        /**
         * Code for Correction Phase. 
         */
        CORRECTION: number,

        /**
         * Exception lifecycleStatus code = 9 belongs to Verification Phase. 
         */
        EXCEPTION: number,

        /**
         * Failed lifecycleStatus code = 12 belongs to Verification Phase. 
         */
        FAILED: number,

        /**
         * Object containing lifecycle phase codes and their associated descriptions. 
         */
        LIFECYCLEPHASE_DESCRIPTIONS: any,

        /**
         * Object containing lifecycle status codes and their associated descriptions. 
         */
        LIFECYCLESTATUS_DESCRIPTIONS: any,

        /**
         * Mark As Exception lifecycleStatus code = 3 belongs to Correction Phase. 
         */
        MARK_AS_EXCEPTION: number,

        /**
         * New lifecycleStatus code = 10 belongs to Review Phase. 
         */
        NEW: number,

        /**
         * Passed lifecycleStatus code = 11 belongs to Verification Phase. 
         */
        PASSED: number,

        /**
         * Resolved lifecycleStatus code = 2 belongs to Correction Phase. 
         */
        RESOLVED: number,

        /**
         * Code for Review Phase. 
         */
        REVIEW: number,

        /**
         * Reviewed lifecycleStatus code = 1 belongs to Review Phase. 
         */
        REVIEWED: number,

        /**
         * Unacceptable lifecycleStatus code = 6 belongs to Review Phase. 
         */
        UNACCEPTABLE: number,

        /**
         * Unknown lifecycleStatus code = 0 belongs to Review Phase. 
         */
        UNKNOWN: number,

        /**
         * Unresolved Acceptable lifecycleStatus code = 8 belongs to Verification Phase. 
         */
        UNRESOLVED_ACCEPTABLE: number,

        /**
         * Unresolved Exception lifecycleStatus code = 5 belongs to Verification Phase. 
         */
        UNRESOLVED_EXCEPTION: number,

        /**
         * Unresolved Unacceptable lifecycleStatus code = 7 belongs to Review Phase. 
         */
        UNRESOLVED_UNACCEPTABLE: number,

        /**
         * Code for Verififcation Phase. 
         */
        VERIFICATION: number,

        /**
         * This function returns the the associated lifecycle phase of the input lifecycle status.
         * @param lifecycleStatus The lifecycle status code.
         */
        getCurrentLifecyclePhase(lifecycleStatus: number): string,

        /**
         * This function accepts an array of lifecycle statuses and returns an object containing the next appropriate lifecycle status and phase that the record will advance to.
         * @param lifecycleStatus An Array of lifecycle statuses.
         */
        getLifecycleInfo(lifecycleStatus: any[]): any,

        /**
         * This function returns lifecycle phase string associated with the input lifecycle phase code.
         * @param lifecyclePhase The lifecycle phase code.
         */
        toLifecyclePhaseString(lifecyclePhase: number): string,

        /**
         * This function returns lifecycle status string associated with the input lifecycle status code.
         * @param lifecycleStatus The lifecycle status code.
         */
        toLifecycleStatusString(lifecycleStatus: number): string
    };
    declare module.exports: typeof ReviewerLifecycle
}
declare module 'esri/tasks/datareviewer/ReviewerResultsTask' {
    declare module.exports: typeof ReviewerResultsTask
}
declare module 'esri/tasks/datareviewer/ReviewerSession' {
    declare module.exports: typeof ReviewerSession
}
declare module 'esri/tasks/datareviewer/SessionOptions' {
    declare module.exports: typeof SessionOptions
}
declare module 'esri/tasks/geoenrichment/AddressStudyArea' {
    declare module.exports: typeof AddressStudyArea
}
declare module 'esri/tasks/geoenrichment/DriveBuffer' {
    declare module.exports: typeof DriveBuffer
}
declare module 'esri/tasks/geoenrichment/DriveUnits' {
    declare module.exports: typeof DriveUnits
}
declare module 'esri/tasks/geoenrichment/GeographyLevel' {
    declare module.exports: typeof GeographyLevel
}
declare module 'esri/tasks/geoenrichment/GeographyQuery' {
    declare module.exports: typeof GeographyQuery
}
declare module 'esri/tasks/geoenrichment/GeographyQueryBase' {
    declare module.exports: typeof GeographyQueryBase
}
declare module 'esri/tasks/geoenrichment/GeometryStudyArea' {
    declare module.exports: typeof GeometryStudyArea
}
declare module 'esri/tasks/geoenrichment/IntersectingGeographies' {
    declare module.exports: typeof IntersectingGeographies
}
declare module 'esri/tasks/geoenrichment/RingBuffer' {
    declare module.exports: typeof RingBuffer
}
declare module 'esri/tasks/geoenrichment/StandardGeographyQueryTask' {
    declare module.exports: typeof StandardGeographyQueryTask
}
declare module 'esri/tasks/geoenrichment/StandardGeographyStudyArea' {
    declare module.exports: typeof StandardGeographyStudyArea
}
declare module 'esri/tasks/geoenrichment/StudyArea' {
    declare module.exports: typeof StudyArea
}
declare module 'esri/tasks/geoenrichment/SubGeographyQuery' {
    declare module.exports: typeof SubGeographyQuery
}
declare module 'esri/tasks/locationproviders/CoordinatesLocationProvider' {
    declare module.exports: typeof CoordinatesLocationProvider
}
declare module 'esri/tasks/locationproviders/GeometryLocationProvider' {
    declare module.exports: typeof GeometryLocationProvider
}
declare module 'esri/tasks/locationproviders/LocationProviderBase' {
    declare module.exports: typeof LocationProviderBase
}
declare module 'esri/tasks/locationproviders/LocationProviderClientBase' {
    declare module.exports: typeof LocationProviderClientBase
}
declare module 'esri/tasks/locationproviders/LocationProviderRemoteBase' {
    declare module.exports: typeof LocationProviderRemoteBase
}
declare module 'esri/tasks/locationproviders/LocatorLocationProvider' {
    declare module.exports: typeof LocatorLocationProvider
}
declare module 'esri/tasks/locationproviders/QueryTaskLocationProvider' {
    declare module.exports: typeof QueryTaskLocationProvider
}
declare module 'esri/tasks/locationproviders/StandardGeographyQueryLocationProvider' {
    declare module.exports: typeof StandardGeographyQueryLocationProvider
}
declare module 'esri/tasks/locator' {
    declare module.exports: typeof Locator
}
declare module 'esri/tasks/query' {
    declare module.exports: typeof Query
}
declare module 'esri/toolbars/ImageServiceMeasureTool' {
    declare module.exports: typeof ImageServiceMeasureTool
}
declare module 'esri/toolbars/draw' {
    declare module.exports: typeof Draw
}
declare module 'esri/toolbars/edit' {
    declare module.exports: typeof Edit
}
declare module 'esri/toolbars/navigation' {
    declare module.exports: typeof Navigation
}
declare module 'esri/undoManager' {
    declare module.exports: typeof UndoManager
}
declare module 'esri/units' {
    declare module.exports: typeof Units
}
declare module 'esri/urlUtils' {
    declare     var urlUtils: {

        /**
         * Adds the given proxy rule to the proxy rules list: esri.config.defaults.io.proxyRules
         * @param rule The rule argument should have the following properties.
         */
        addProxyRule(rule: any): number,

        /**
         * Returns the proxy rule that matches the given url. 
         */
        getProxyRule(): any,

        /**
         * Converts the URL arguments to an object representation.
         * @param url The input URL.
         */
        urlToObject(url: string): any
    };
    declare module.exports: typeof urlUtils
}
declare module 'esri/virtualearth/VEAddress' {
    declare module.exports: typeof VEAddress
}
declare module 'esri/virtualearth/VEGeocodeResult' {
    declare module.exports: typeof VEGeocodeResult
}
declare module 'esri/virtualearth/VEGeocoder' {
    declare module.exports: typeof VEGeocoder
}
declare module 'esri/virtualearth/VETiledLayer' {
    declare module.exports: typeof VETiledLayer
}
declare module 'esri/workers/WorkerClient' {
    declare module.exports: typeof WorkerClient
}
declare module 'archiver' {


    declare interface nameInterface {
        name?: string
    }
    declare type Archiver = {
        pipe(writeStream: FS.WriteStream): void,
        append(source: FS.ReadStream | Buffer | string, name: nameInterface): void,
        directory(dirpath: string, destpath: nameInterface | string): void,
        directory(dirpath: string, destpath: nameInterface | string, data: any | Function): void,
        bulk(mappings: any): void,
        finalize(): void
    }
    declare     export interface Options {
        recurse: boolean
    }
    declare module.exports: typeof archiver

    declare     var npm$namespace$archiver: {
        create: typeof archiver$create,
    }
    declare     export function archiver$create(
        db: anydbSQL$AnydbSql,
        tasks: any): {
        run: () => promise$Promise<any>,
        migrateTo: (target?: string) => promise$Promise<any>,
        check: (
            f: (m: {
                type: string,
                items: MigrationTask[]
            }) => any) => promise$Promise<any >
    }
}
declare module 'archy' {
    declare module.exports: typeof archy
    declare interface archy$Data<TDomain>{
        baseType: string,
        baseData: TDomain,
        constructor(): archy$Data<TDomain >
    }

    declare     export interface archy$Options {
        recurse: boolean
    }
}
declare module 'argparse' {
    declare     export class ArgumentParser mixins ArgumentGroup {
        constructor(options?: ArgumentParserOptions): this;
        addSubparsers(options?: SubparserOptions): SubParser;
        parseArgs(args?: string[], ns?: Namespace | AV$Object): any;
        printUsage(): void;
        printHelp(): void;
        formatUsage(): string;
        formatHelp(): string;
        parseKnownArgs(args?: string[], ns?: Namespace | AV$Object): any[];
        convertArgLineToArg(argLine: string): string[];
        exit(status: number, message: string): void;
        error(err: string | error$Error): void
    }
    declare interface Namespace {}
    declare class SubParser {
        addParser(name: string, options?: SubArgumentParserOptions): ArgumentParser
    }
    declare class ArgumentGroup {
        addArgument(args: string[], options?: ArgumentOptions): void;
        addArgumentGroup(options?: ArgumentGroupOptions): ArgumentGroup;
        addMutuallyExclusiveGroup(options?: {
            required: boolean
        }): ArgumentGroup;
        setDefaults(options?: {}): void;
        getDefault(dest: string): any
    }
    declare interface SubparserOptions {
        title?: string,
            description?: string,
            prog?: string,
            parserClass?: {
                new(): any
            },
            action?: string,
            dest?: string,
            help?: string,
            metavar?: string
    }
    declare type SubArgumentParserOptions = {
        aliases?: string[],
        help?: string
    } & ArgumentParserOptions

    declare interface ArgumentParserOptions {
        description?: string,
            epilog?: string,
            addHelp?: boolean,
            argumentDefault?: any,
            parents?: ArgumentParser[],
            prefixChars?: string,
            formatterClass?: {
                new(): HelpFormatter | ArgumentDefaultsHelpFormatter | RawDescriptionHelpFormatter | RawTextHelpFormatter
            },
            prog?: string,
            usage?: string,
            version?: string
    }
    declare interface ArgumentGroupOptions {
        prefixChars?: string,
            argumentDefault?: any,
            title?: string,
            description?: string
    }
    declare     export class HelpFormatter {}
    declare     export class ArgumentDefaultsHelpFormatter {}
    declare     export class RawDescriptionHelpFormatter {}
    declare     export class RawTextHelpFormatter {}
    declare interface ArgumentOptions {
        action?: string,
            optionStrings?: string[],
            dest?: string,
            nargs?: string | number,
            constant?: any,
            defaultValue?: any,
            type?: string | Function,
            choices?: string | string[],
            required?: boolean,
            help?: string,
            metavar?: string
    }
}
declare module 'argv' {
    declare type args = {
        targets: string[],
        options: {
            [key: string]: any
        }
    };
    declare type helpOption = {
        name: string,
        type: string,
        short?: string,
        description?: string,
        example?: string
    };
    declare type module = {
        mod: string,
        description: string,
        options: {
            [key: string]: helpOption
        }
    };
    declare type typeFunction = (value: any, ...arglist: any[]) => any;
    declare module.exports: typeof argv
    declare     var argv: argv;
}
declare module 'array-find-index' {
    declare type Predicate = (element: any, index: number, array: any[]) => boolean;
    declare module.exports: typeof arrayFindIndex

}
declare module 'asana' {

    declare     var Client: asana$ClientStatic;

    declare interface asana$ClientStatic {

        /**
         * Constructs a Client with instances of all the resources using the dispatcher.
         * It also keeps a reference to the dispatcher so that way the end user can have
        access to it.
         * @class  * 
         * @classdesc  A wrapper for the Asana API which is authenticated for one user
         * @param  The request dispatcher to use
         * @param  Options to configure the client
         * @param  ID of the client, required for Oauth
         * @param  Secret key, for some Oauth flows
         * @param  Default redirect URI for this client
         * @param  Base URL for Asana, for debugging
        */
        (dispatcher: asana$Dispatcher, options?: asana$ClientOptions): asana$Client,

        /**
         * Creates a new client.
         * @param  Options for specifying the client, see constructor.
         */
        create(options?: asana$ClientOptions): PayPalCordovaPlugin$Client
    }

    declare interface asana$ClientOptions {

        /**
         * Timeout for requests to our servers, in milliseconds
         * default: 15s (node), 2s (browser)
        https://github.com/algolia/algoliasearch-client-js#client-options
        */
        timeout?: number,

            /**
             * Protocol to use when communicating with algolia
             * default: current protocol(browser), https(node)
            https://github.com/algolia/algoliasearch-client-js#client-options
            */
            protocol?: string,

            /**
             * (node only) httpAgent instance to use when communicating with Algolia servers.
             * https://github.com/algolia/algoliasearch-client-js#client-options
             */
            httpAgent?: any,

            /**
             * read: array of read hosts to use to call Algolia servers, computed automatically
             * write: array of read hosts to use to call Algolia servers, computed automatically
            https://github.com/algolia/algoliasearch-client-js#client-options
            */
            hosts?: {
                read?: string[],
                write?: string[]
            }
    }


    /**
     * Represents the client portion of the response.
     */
    declare     export interface asana$Client {
        paypal_sdk_version: string,
            environment: string,
            platform: string,
            product_name: string
    }

    declare     var Dispatcher: asana$DispatcherStatic;

    declare interface asana$DispatcherStatic {

        /**
         * Creates a dispatcher which will act as a basic wrapper for making HTTP
         * requests to the API, and handle authentication.
         * @class  * 
         * @classdesc  A HTTP wrapper for the Asana API
         * @param  for default behavior of the Dispatcher
         * @option  {Authenticator} [authenticator] Object to use for authentication.
        Can also be set later with `setAuthenticator`.
         * @option  {String} [retryOnRateLimit] Automatically handle `RateLimitEnforced`
        errors by sleeping and retrying after the waiting period.
         * @option  {Function} [handleUnauthorized] Automatically handle
        `NoAuthorization` with the callback. If the callback returns `true`
        (or a promise resolving to `true), will retry the request.
         * @option  {String} [asanaBaseUrl] Base URL for Asana, for debugging
         * @option  {Number} [requestTimeout] Timeout (in milliseconds) to wait for the
        request to finish.
        */
        new(options?: asana$DispatcherOptions): asana$Dispatcher,

        /**
         * Default handler for requests that are considered unauthorized.
         * Requests that the authenticator try to refresh its credentials if
        possible.
         * @return  True iff refresh was successful, false if not.
         * @return  
        */
        maybeReauthorize(): promise$Promise<boolean>,

            /**
             * The relative API path for the current version of the Asana API.
             * @type  
             */
            API_PATH: string
    }

    declare interface asana$DispatcherOptions {
        authenticator?: auth$Authenticator,
            retryOnRateLimit?: boolean,
            handleUnauthorized?: () => boolean | promise$Promise<boolean>,
            requestTimeout?: string
    }

    declare interface asana$Dispatcher {

        /**
         * Creates an Asana API Url by concatenating the ROOT_URL with path provided.
         * @param  The path
         * @return  The url
         * @param path 
         * @return  
         */
        url(path: string): string,

            /**
             * Configure the authentication mechanism to use.
             * @returns  this
             * @param authenticator 
             * @return  
             */
            setAuthenticator(authenticator: auth$Authenticator): this,

            /**
             * Ensure the dispatcher is authorized to make requests. Call this before
             * making any API requests.
             * @returns  Resolves when the dispatcher is authorized, rejected if
            there was a problem authorizing.
             * @return  
            */
            authorize(): promise$Promise<void>,

            /**
             * Dispatches a request to the Asana API. The request parameters are passed to
             * the request module.
             * @param  The params for request
             * @param  Options for handling request/response
             * @return  The response for the request
             * @param params 
             * @param dispatchOptions ?
             * @return  
             */
            dispatch(params: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a GET request to the Asana API.
             * @param  The path of the API
             * @param  The query params
             * @param  Options for handling the request and
            response. See `dispatch`.
             * @return  The response for the request
             * @param path 
             * @param query ?
             * @param dispatchOptions ?
             * @return  
            */
            get(path: string, query?: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a POST request to the Asana API.
             * @param  The path of the API
             * @param  The data to be sent
             * @param  Options for handling the request and
            response. See `dispatch`.
             * @return  The response for the request
             * @param path 
             * @param data 
             * @param dispatchOptions ?
             * @return  
            */
            post(path: string, data: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a PUT request to the Asana API.
             * @param  The path of the API
             * @param  The data to be sent
             * @param  Options for handling the request and
            response. See `dispatch`.
             * @return  The response for the request
             * @param path 
             * @param data 
             * @param dispatchOptions ?
             * @return  
            */
            put(path: string, data: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a DELETE request to the Asana API.
             * @param  The path of the API
             * @param  Options for handling the request and
            response. See `dispatch`.
             * @return  The response for the request
             * @param path 
             * @param dispatchOptions ?
             * @return  
            */
            delete(path: string, dispatchOptions?: any): promise$Promise<any>,

            /**
             * The base URL for Asana
             * @type  
             */
            asanaBaseUrl: string,

            /**
             * Whether requests should be automatically retried if rate limited.
             * @type  
             */
            retryOnRateLimit: boolean,

            /**
             * Handler for unauthorized requests which may seek reauthorization.
             * Default behavior is available if configured with an Oauth authenticator
            that has a refresh token, and will refresh the current access token.
             * @type  
            */
            handleUnauthorized: () => boolean | promise$Promise<boolean>,

            /**
             * The amount of time in milliseconds to wait for a request to finish.
             * @type  
             */
            requestTimeout: number
    }


    declare     var npm$namespace$auth: {
        autoDetect: typeof auth$autoDetect,
    }
    declare     var BasicAuthenticator: auth$BasicAuthenticatorStatic;

    declare interface auth$BasicAuthenticatorStatic {

        /**
         * 
         * @param apiKey 
         */
        new(apiKey: string): auth$BasicAuthenticator
    }

    declare type auth$BasicAuthenticator = {

        /**
         * 
         * @param  The request to modify, for the `request` library.
         * @return  The `request` parameter, modified to include authentication
        information using the stored credentials.
         * @param request 
         * @return  
        */
        authenticateRequest(request: auth$BasicAuthenticatorRequest): auth$BasicAuthenticatorRequest
    } & auth$Authenticator


    declare interface auth$BasicAuthenticatorRequest {
        auth: {
            username: string,
            password: string
        }
    }

    declare     var OauthAuthenticator: auth$OauthAuthenticatorStatic;

    declare interface auth$OauthAuthenticatorStatic {

        /**
         * Creates an authenticator that uses Oauth for authentication.
         * @param  Configure the authenticator; must specify one
        of `flow` or `credentials`.
         * @option  {App}           app           The app being authenticated for.
         * @option  {OauthFlow}     [flow]        The flow to use to get credentials
        when needed.
         * @option  {String|Object} [credentials] Initial credentials to use. This can
        be either the object returned from an access token request (which
        contains the token and some other metadata) or just the `access_token`
        field.
         * @constructor  
        */
        new(options: auth$OauthAuthenticatorOptions): auth$OauthAuthenticator
    }

    declare interface auth$OauthAuthenticatorOptions {
        flowType?: auth$FlowType,
            credentials?: auth$Credentials | string
    }

    declare interface auth$Credentials {
        access_token?: string,
            refresh_token?: string
    }

    declare type auth$OauthAuthenticator = {

        /**
         * 
         * @param  The request to modify, for the `request` library.
         * @return  The `request` parameter, modified to include authentication
        information using the stored credentials.
         * @param request 
         * @return  
        */
        authenticateRequest(request: auth$OauthAuthenticatorRequest): auth$OauthAuthenticatorRequest
    } & auth$Authenticator


    declare interface auth$OauthAuthenticatorRequest {

        /**
         * When browserify-d, the `auth` component of the `request` library
         * doesn't work so well, so we just manually set the bearer token instead.
         */
        headers: {
            Authorization: string
        }
    }


    /**
     * A layer to abstract the differences between using different types of
     * authentication (Oauth vs. Basic). The Authenticator is responsible for
    establishing credentials and applying them to outgoing requests.
     * @constructor  
    */
    declare interface auth$Authenticator {

        /**
         * Establishes credentials.
         * @return  Resolves when initial credentials have been
        completed and `authenticateRequest` calls can expect to succeed.
         * @return  
        */
        establishCredentials(): promise$Promise<void>,

            /**
             * Attempts to refresh credentials, if possible, given the current credentials.
             * @return  Resolves to `true` if credentials have been successfully
            established and `authenticateRequests` can expect to succeed, else
            resolves to `false`.
             * @return  
            */
            refreshCredentials(): promise$Promise<boolean >
    }

    declare     var App: auth$AppStatic;

    declare interface auth$AppStatic {

        /**
         * An abstraction around an App used with Asana.
         * @options  {Object} Options to construct the app
         * @option  {String} clientId       The ID of the app
         * @option  {String} [clientSecret] The secret key, if available here
         * @option  {String} [redirectUri]  The default redirect URI
         * @option  {String} [scope]        Scope to use, supports `default` and `scim`
         * @option  {String} [asanaBaseUrl] Base URL to use for Asana, for debugging
         * @constructor  
         */
        new(options: auth$AppOptions): AppleTVJS$App
    }

    declare type auth$AppOptions = {
        clientId?: string | number,
        clientSecret?: string,
        scope?: string
    } & auth$AsanaAuthorizeUrlOptions


    declare interface auth$App {

        /**
         * The onError attribute is used to handle any errors sent from the device.
         * This attribute must be set to a function that accepts an “options” argument.
        For example App.onError = function (options) {}.
        */
        onError: (options: any) => void,

            /**
             * The onExit attribute is used to complete any actions that need to be cleaned
             * up when the app has been exited. This attribute must be set to a function that
            accepts an “options” argument. For example App.onExit = function (options) {}.
            */
            onExit: (options: any) => void,

            /**
             * The onLaunch attribute is used to start any required actions when the app
             * launches. This attribute must be set to a function that accepts an “options”
            argument. For example App.onLaunch = function (options) {}.
            */
            onLaunch: (options: any) => void,

            /**
             * This function reloads the initial JavaScript file without quitting the app.
             * The optional reloadData parameter provides developers with a way to capture
            and restart the app in it’s current state. If the reloadData parameter is not
            present, the app is restarted in its initial state. This attribute must be set
            to a function that accepts an “options” argument.
            For example App.onError = function (options) {}.
            */
            reload(options?: any, reloadData?: any): void
    }

    declare interface auth$AsanaAuthorizeUrlOptions {
        redirectUri?: string,
            asanaBaseUrl?: string
    }

    declare     var OauthError: auth$OauthErrorStatic;

    declare interface auth$OauthErrorStatic {

        /**
         * 
         * @param options A data blob parsed from a query string or JSON
        response from the Asana API
         * @option  {String} error The string code identifying the error.
         * @option  {String} [error_uri] A link to help and information about the error.
         * @option  {String} [error_description] A description of the error.
         * @constructor  
        */
        new(options: auth$OauthErrorOptions): auth$OauthError
    }

    declare interface auth$OauthErrorOptions {
        error?: string,
            error_uri?: string,
            error_description?: string
    }

    declare type auth$OauthError = {} & error$Error



    /**
     * Auto-detects the type of Oauth flow to use that's appropriate to the
     * environment.
     * @returns  The type of Oauth flow to use, or null if no
    appropriate type could be determined.
     * @param env 
     * @return  
    */
    declare     function auth$autoDetect(env: any): Function

    declare     var RedirectFlow: auth$RedirectFlowStatic;

    declare type auth$RedirectFlowStatic = {

        /**
         * An Oauth flow that runs in the browser and requests user authorization by
         * redirecting to an authorization page on Asana, and redirecting back with
        the credentials.
         * @param  See `BaseBrowserFlow` for options.
         * @constructor  
        */
        new(options: any): auth$RedirectFlow
    } & auth$FlowType


    declare type auth$RedirectFlow = {} & auth$BaseBrowserFlow


    declare     var PopupFlow: auth$PopupFlowStatic;

    declare type auth$PopupFlowStatic = {

        /**
         * An Oauth flow that runs in the browser and requests user authorization by
         * popping up a window and prompting the user.
         * @param  See `BaseBrowserFlow` for options.
         * @constructor  
         */
        new(options: any): auth$PopupFlow
    } & auth$FlowType


    declare type auth$PopupFlow = {

        /**
         * 
         * @param popupWidth 
         * @param popupHeight 
         */
        _popupParams(popupWidth: number, popupHeight: number): void,
        runReceiver(): void
    } & auth$BaseBrowserFlow


    declare     var NativeFlow: auth$NativeFlowStatic;

    declare type auth$NativeFlowStatic = {

        /**
         * An Oauth flow that can be run from the console or an app that does
         * not have the ability to open and manage a browser on its own.
         * @param  
         * @option  {App} app App to authenticate for
         * @option  {String function(String)} [instructions] Function returning the
        instructions to output to the user. Passed the authorize url.
         * @option  {String function()} [prompt] String to output immediately before
        waiting for a line from stdin.
         * @constructor  
        */
        new(options: any): auth$NativeFlow
    } & auth$FlowType


    declare type auth$NativeFlow = {

        /**
         * Run the Oauth flow, prompting the user to go to the authorization URL
         * and enter the code it displays when finished.
         * @return  The access token object, which will include
        `access_token` and `refresh_token`.
        */
        run(): void,

        /**
         * 
         * @param  An authorization code obtained via `asanaAuthorizeUrl`.
         * @return  The token, which will include the `access_token`
        used for API access, as well as a `refresh_token` which can be stored
        to get a new access token without going through the flow again.
         * @param code 
        */
        accessToken(code: string): void,

        /**
         * 
         * @return  The access token, which will include a refresh token
        that can be stored in the future to create a client without going
        through the Oauth flow.
         * @param url 
         * @return  
        */
        promptForCode(url: string): any
    } & auth$Flow


    declare     var ChromeExtensionFlow: auth$ChromeExtensionFlowStatic;

    declare type auth$ChromeExtensionFlowStatic = {

        /**
         * An Oauth flow that runs in a Chrome browser extension and requests user
         * authorization by opening a temporary tab to prompt the user.
         * @param  See `BaseBrowserFlow` for options, plus the below:
         * @options  {String} [receiverPath] Full path and filename from the base
        directory of the extension to the receiver page. This is an HTML file
        that has been made web-accessible, and that calls the receiver method
        `Asana.auth.ChromeExtensionFlow.runReceiver();`.
         * @constructor  
        */
        new(options: any): auth$ChromeExtensionFlow
    } & auth$FlowType


    declare type auth$ChromeExtensionFlow = {

        /**
         * Runs the receiver code to send the Oauth result to the requesting tab.
         */
        runReceiver(): void
    } & auth$BaseBrowserFlow


    declare     var BaseBrowserFlow: auth$BaseBrowserFlowStatic;

    declare type auth$BaseBrowserFlowStatic = {

        /**
         * A base class for any flow that runs in the browser. All subclasses use the
         * "implicit grant" flow to authenticate via the browser.
         * @param  
         * @option  {App} app The app this flow is for
         * @option  {String} [redirectUri] The URL that Asana should redirect to once
        user authorization is complete. Defaults to the URL configured in
        the app, and if none then the current page URL.
         * @constructor  
        */
        new(options: any): auth$BaseBrowserFlow
    } & auth$FlowType


    declare type auth$BaseBrowserFlow = {

        /**
         * 
         * @param  The URL the user should be navigated to in order
        to authorize the app.
         * @param  The unique state generated for this auth request.
         * @return  Resolved when authorization has successfully started,
        i.e. the user has been navigated to a page requesting authorization.
         * @param authUrl 
         * @param state 
         * @return  
        */
        startAuthorization(authUrl: string, state: string): any,

        /**
         * 
         * @return  Credentials returned from Oauth.
         * @param state 
         */
        finishAuthorization(state: string): void,

        /**
         * 
         * @return  The URL to redirect to that will receive the
         * @return  
         */
        receiverUrl(): string,

        /**
         * 
         * @return  The URL to redirect to that will receive the
         * @return  
         */
        asanaBaseUrl(): string,

        /**
         * 
         * @returns  Generate a new unique state parameter for a request.
         * @return  
         */
        getStateParam(): string
    } & auth$Flow


    declare interface auth$FlowType {
        new(options: any): auth$Flow
    }

    declare interface auth$Flow {

        /**
         * 
         * @returns  The URL used to authorize the user for the app.
         * @return  
         */
        authorizeUrl(): string,

            /**
             * Run the appropriate parts of the Oauth flow, attempting to establish user
             * authorization.
             * @returns  A promise that resolves to the Oauth credentials.
             */
            run(): void
    }

    declare class AsanaError mixins Error {

        /**
         * 
         * @param message 
         * @return  
         */
        constructor(message: any): this;
        code: number;
        value: any
    }

    declare class Forbidden mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare class InvalidRequest mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare class NoAuthorization mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare class NotFound mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare class RateLimitEnforced mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare class ServerError mixins AsanaError {

        /**
         * 
         * @param value 
         * @return  
         */
        constructor(value: any): this
    }

    declare interface resources$AttachmentsStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Attachments
    }


    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Attachments$Type = {} & Function


    declare     var Attachments: resources$AttachmentsStatic;


    /**
     * An _attachment_ object represents any file attached to a task in Asana,
     * whether it's an uploaded file or one associated via a third-party service
    such as Dropbox or Google Drive.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Attachments = {

        /**
         * * Returns the full record for a single attachment.
         *    * @param {Number} attachment Globally unique identifier for the attachment.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param attachment 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            attachment: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Attachments$Type>,

        /**
         * * Returns the compact records for all attachments on the task.
         *    * @param {Number} task Globally unique identifier for the task.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByTask(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Attachments$Type >>
    } & resources$Resource


    declare interface resources$EventsStatic {

        /**
         * 
         * @param dispatcher 
         * @return  
         */
        new(dispatcher: asana$Dispatcher): AV$Events
    }

    declare     var Events: resources$EventsStatic;


    /**
     * An _event_ is an object representing a change to a resource that was observed
     * by an event subscription.

    In general, requesting events on a resource is faster and subject to higher
    rate limits than requesting the resource itself. Additionally, change events
    bubble up - listening to events on a project would include when stories are
    added to tasks in the project, even on subtasks.

    Establish an initial sync token by making a request with no sync token.
    The response will be a `412` error - the same as if the sync token had
    expired.

    Subsequent requests should always provide the sync token from the immediately
    preceding call.

    Sync tokens may not be valid if you attempt to go 'backward' in the history
    by requesting previous tokens, though re-requesting the current sync token
    is generally safe, and will always return the same results.

    When you receive a `412 Precondition Failed` error, it means that the
    sync token is either invalid or expired. If you are attempting to keep a set
    of data in sync, this signals you may need to re-crawl the data.

    Sync tokens always expire after 24 hours, but may expire sooner, depending on
    load on the service.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Events = {} & resources$Resource


    declare interface resources$ProjectsStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Projects
    }


    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Projects$Type = {} & Function


    declare interface Projects$CreateParams {
        name?: string,
            team?: number,
            public?: boolean,
            due_date: string,
            notes?: string,
            color?: string
    }

    declare interface Projects$FollowersParams {
        followers: (number | string)[]
    }

    declare interface Projects$MembersParams {
        members: (number | string)[]
    }

    declare interface Projects$Status {
        color: string,
            text: string,
            html_text: string,
            modified_at: string,
            author: resources$Resource
    }

    declare type Projects$FindAllParams = {
        team?: number,
        archived?: boolean
    } & resources$PaginationParams


    declare type Projects$FindByParams = {
        archived?: boolean
    } & resources$PaginationParams


    declare     var Projects: resources$ProjectsStatic;


    /**
     * A _project_ represents a prioritized list of tasks in Asana. It exists in a
     * single workspace or organization and is accessible to a subset of users in
    that workspace or organization, depending on its permissions.

    Projects in organizations are shared with a single team. You cannot currently
    change the team of a project via the API. Non-organization workspaces do not
    have teams and so you should not specify the team of project in a
    regular workspace.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Projects = {

        /**
         * * Creates a new project in a workspace or team.
         * *
         * Every project is required to be created in a specific workspace or
         * organization, and this cannot be changed once set. Note that you can use
         * the `workspace` parameter regardless of whether or not it is an
         * organization.
         *
         * If the workspace for your project _is_ an organization, you must also
         * supply a `team` to share the project with.
         *
         * Returns the full record of the newly created project.
         * @param {Object} data Data for the request
         * @param {String} data.workspace The workspace or organization to create the project in.
         * @param {String} [data.team] If creating in an organization, the specific team to create the
         * project in.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        create(
            data: Projects$CreateParams & {
                workspace: number
            },
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * If the workspace for your project _is_ an organization, you must also
         * * supply a `team` to share the project with.
         *
         * Returns the full record of the newly created project.
         * @param {Number} workspace The workspace or organization to create the project in.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createInWorkspace(
            workspace: number,
            data: Projects$CreateParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * Creates a project shared with the given team.
         * *
         * Returns the full record of the newly created project.
         * @param {Number} team The team to create the project in.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param team 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createInTeam(
            team: number,
            data: Projects$CreateParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * Returns the complete project record for a single project.
         *    * @param {Number} project The project to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param project 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            project: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * A specific, existing project can be updated by making a PUT request on the
         * * URL for that project. Only the fields provided in the `data` block will be
         * updated; any unspecified fields will remain unchanged.
         *
         * When using this method, it is best to specify only those fields you wish
         * to change, or else you may overwrite changes made by another user since
         * you last retrieved the task.
         *
         * Returns the complete updated project record.
         * @param {Number} project The project to update.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        update(
            project: number,
            data: Projects$CreateParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * A specific, existing project can be deleted by making a DELETE request
         * * on the URL for that project.
         *
         * Returns an empty data record.
         * @param {Number} project The project to delete.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param dispatchOptions ?
         * @return  
         */
        delete(project: number, dispatchOptions?: any): promise$Promise<void>,

        /**
         * * Returns the compact project records for some filtered set of projects.
         * * Use one or more of the parameters provided to filter the projects returned.
         * @param {Object} [params] Parameters for the request
         * @param {String} [params.workspace] The workspace or organization to filter projects on.
         * @param {String} [params.team] The team to filter projects on.
         * @param {Boolean} [params.archived] Only return projects whose `archived` field takes on the value of
         * this parameter.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params?: Projects$FindAllParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Projects$Type >> ,

        /**
         * * Returns the compact project records for all projects in the workspace.
         *    * @param {Number} workspace The workspace or organization to find projects in.
         * @param {Object} [params] Parameters for the request
         * @param {Boolean} [params.archived] Only return projects whose `archived` field takes on the value of
         * this parameter.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByWorkspace(
            workspace: number,
            params?: Projects$FindByParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Projects$Type >> ,

        /**
         * * Returns the compact project records for all projects in the team.
         *    * @param {Number} team The team to find projects in.
         * @param {Object} [params] Parameters for the request
         * @param {Boolean} [params.archived] Only return projects whose `archived` field takes on the value of
         * this parameter.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param team 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByTeam(
            team: number,
            params?: Projects$FindByParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Projects$Type >> ,

        /**
         * * Returns compact records for all sections in the specified project.
         *    * @param {Number} project The project to get sections from.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        sections(
            project: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Returns the compact task records for all tasks within the given project,
         * * ordered by their priority within the project. Tasks can exist in more than one project at a time.
         * @param {Number} project The project in which to search for tasks.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        tasks(
            project: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Adds the specified list of users as followers to the project. Followers are a subset of members, therefore if
         * * the users are not already members of the project they will also become members as a result of this operation.
         * Returns the updated project record.
         * @param {Number} project The project to add followers to.
         * @param {Object} data Data for the request
         * @param {Array} data.followers An array of followers to add to the project.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addFollowers(
            project: number,
            data: Projects$FollowersParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * Removes the specified list of users from following the project, this will not affect project membership status.
         * * Returns the updated project record.
         * @param {Number} project The project to remove followers from.
         * @param {Object} data Data for the request
         * @param {Array} data.followers An array of followers to remove from the project.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeFollowers(
            project: number,
            data: Projects$FollowersParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * Adds the specified list of users as members of the project. Returns the updated project record.
         *    * @param {Number} project The project to add members to.
         * @param {Object} data Data for the request
         * @param {Array} data.members An array of members to add to the project.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addMembers(
            project: number,
            data: Projects$MembersParams,
            dispatchOptions?: any): promise$Promise<Projects$Type>,

        /**
         * * Removes the specified list of members from the project. Returns the updated project record.
         *    * @param {Number} project The project to remove members from.
         * @param {Object} data Data for the request
         * @param {Array} data.members An array of members to remove from the project.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param project 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeMembers(
            project: number,
            data: Projects$MembersParams,
            dispatchOptions?: any): promise$Promise<Projects$Type >
    } & resources$Resource


    declare interface resources$StoriesStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Stories
    }

    declare type Stories$ShortType = {
        created_at: string,
        created_by: resources$Resource,
        type: string,
        text: string
    } & resources$Resource



    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Stories$Type = {} & Function


    declare     var Stories: resources$StoriesStatic;


    /**
     * A _story_ represents an activity associated with an object in the Asana
     * system. Stories are generated by the system whenever users take actions such
    as creating or assigning tasks, or moving tasks between projects. _Comments_
    are also a form of user-generated story.

    Stories are a form of history in the system, and as such they are read-only.
    Once generated, it is not possible to modify a story.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Stories = {

        /**
         * * Returns the compact records for all stories on the task.
         *    * @param {Number} task Globally unique identifier for the task.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByTask(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Stories$Type >> ,

        /**
         * * Returns the full record for a single story.
         *    * @param {Number} story Globally unique identifier for the story.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param story 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            story: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Stories$Type>,

        /**
         * * Adds a comment to a task. The comment will be authored by the
         * * currently authenticated user, and timestamped when the server receives
         * the request.
         *
         * Returns the full record for the new story added to the task.
         * @param {Number} task Globally unique identifier for the task.
         * @param {Object} data Data for the request
         * @param {String} data.text The plain text of the comment to add.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createOnTask(
            task: number,
            data: any,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Stories$ShortType >>
    } & resources$Resource


    declare interface resources$TagsStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Tags
    }


    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Tags$Type = {} & Function


    declare type Tags$FindAllParams = {
        team?: number,
        archived?: boolean
    } & resources$PaginationParams


    declare     var Tags: resources$TagsStatic;


    /**
     * A _tag_ is a label that can be attached to any task in Asana. It exists in a
     * single workspace or organization.

    Tags have some metadata associated with them, but it is possible that we will
    simplify them in the future so it is not encouraged to rely too heavily on it.
    Unlike projects, tags do not provide any ordering on the tasks they
    are associated with.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Tags = {

        /**
         * * Creates a new tag in a workspace or organization.
         * *
         * Every tag is required to be created in a specific workspace or
         * organization, and this cannot be changed once set. Note that you can use
         * the `workspace` parameter regardless of whether or not it is an
         * organization.
         *
         * Returns the full record of the newly created tag.
         * @param {Object} data Data for the request
         * @param {String} data.workspace The workspace or organization to create the tag in.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        create(
            data: Tags$Type & {
                workspace: string
            },
            dispatchOptions?: any): promise$Promise<Tags$Type>,

        /**
         * * Creates a new tag in a workspace or organization.
         * *
         * Every tag is required to be created in a specific workspace or
         * organization, and this cannot be changed once set. Note that you can use
         * the `workspace` parameter regardless of whether or not it is an
         * organization.
         *
         * Returns the full record of the newly created tag.
         * @param {Number} workspace The workspace or organization to create the tag in.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createInWorkspace(
            workspace: number,
            data: Tags$Type,
            dispatchOptions?: any): promise$Promise<Tags$Type>,

        /**
         * * Returns the complete tag record for a single tag.
         *    * @param {Number} tag The tag to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param tag 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            tag: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Tags$Type>,

        /**
         * * Updates the properties of a tag. Only the fields provided in the `data`
         * * block will be updated; any unspecified fields will remain unchanged.
         *
         * When using this method, it is best to specify only those fields you wish
         * to change, or else you may overwrite changes made by another user since
         * you last retrieved the task.
         *
         * Returns the complete updated tag record.
         * @param {Number} tag The tag to update.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        update(
            tag: number,
            data: Tags$Type,
            dispatchOptions?: any): promise$Promise<Tags$Type>,

        /**
         * * A specific, existing tag can be deleted by making a DELETE request
         * * on the URL for that tag.
         *
         * Returns an empty data record.
         * @param {Number} tag The tag to delete.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param dispatchOptions ?
         * @return  
         */
        delete(tag: number, dispatchOptions?: any): promise$Promise<void>,

        /**
         * * Returns the compact tag records for some filtered set of tags.
         * * Use one or more of the parameters provided to filter the tags returned.
         * @param {Object} [params] Parameters for the request
         * @param {String} [params.workspace] The workspace or organization to filter tags on.
         * @param {String} [params.team] The team to filter tags on.
         * @param {Boolean} [params.archived] Only return tags whose `archived` field takes on the value of
         * this parameter.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params?: Tags$FindAllParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tags$Type >> ,

        /**
         * * Returns the compact tag records for all tags in the workspace.
         *    * @param {Number} workspace The workspace or organization to find tags in.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByWorkspace(
            workspace: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tags$Type >> ,

        /**
         * * Returns the compact task records for all tasks with the given tag.
         * * Tasks can have more than one tag at a time.
         * @param {Number} tag The tag to fetch tasks from.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        getTasksWithTag(
            tag: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >>
    } & resources$Resource


    declare interface resources$TasksStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Tasks
    }


    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Tasks$Type = {} & Function


    declare interface Tasks$CreateParams {
        name?: string,
            team?: number,
            public?: boolean,
            due_date: string,
            notes?: string,
            color?: string
    }

    declare interface Tasks$FollowersParams {
        followers: (number | string)[]
    }

    declare interface Tasks$AddProjectParams {
        project: number,
            insertBefore?: number,
            insertAfter?: number,
            section?: number
    }

    declare interface Tasks$RemoveProjectParams {
        project: number
    }

    declare interface Tasks$TagParams {
        tag: string
    }

    declare interface Tasks$CommentParams {
        text: string
    }

    declare type Tasks$FindAllParams = {
        team?: number,
        archived?: boolean
    } & resources$PaginationParams


    declare     var Tasks: resources$TasksStatic;


    /**
     * The _task_ is the basic object around which many operations in Asana are
     * centered. In the Asana application, multiple tasks populate the middle pane
    according to some view parameters, and the set of selected tasks determines
    the more detailed information presented in the details pane.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Tasks = {

        /**
         * * Creating a new task is as easy as POSTing to the `/tasks` endpoint
         * * with a data block containing the fields you'd like to set on the task.
         * Any unspecified fields will take on default values.
         *
         * Every task is required to be created in a specific workspace, and this
         * workspace cannot be changed once set. The workspace need not be set
         * explicitly if you specify a `project` or a `parent` task instead.
         * @param {Object} data Data for the request
         * @param {Number} [data.workspace] The workspace to create a task in.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        create(
            data: Tasks$CreateParams & {
                workspace: string
            },
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * Creating a new task is as easy as POSTing to the `/tasks` endpoint
         * * with a data block containing the fields you'd like to set on the task.
         * Any unspecified fields will take on default values.
         *
         * Every task is required to be created in a specific workspace, and this
         * workspace cannot be changed once set. The workspace need not be set
         * explicitly if you specify a `project` or a `parent` task instead.
         * @param {Number} workspace The workspace to create a task in.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createInWorkspace(
            workspace: number,
            data: Tasks$CreateParams,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * Returns the complete task record for a single task.
         *    * @param {Number} task The task to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            task: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * A specific, existing task can be updated by making a PUT request on the
         * * URL for that task. Only the fields provided in the `data` block will be
         * updated; any unspecified fields will remain unchanged.
         *
         * When using this method, it is best to specify only those fields you wish
         * to change, or else you may overwrite changes made by another user since
         * you last retrieved the task.
         *
         * Returns the complete updated task record.
         * @param {Number} task The task to update.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        update(
            task: number,
            data: Tasks$CreateParams,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * A specific, existing task can be deleted by making a DELETE request on the
         * * URL for that task. Deleted tasks go into the "trash" of the user making
         * the delete request. Tasks can be recovered from the trash within a period
         * of 30 days; afterward they are completely removed from the system.
         *
         * Returns an empty data record.
         * @param {Number} task The task to delete.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param dispatchOptions ?
         * @return  
         */
        delete(task: number, dispatchOptions?: any): promise$Promise<void>,

        /**
         * * Returns the compact task records for all tasks within the given project,
         * * ordered by their priority within the project.
         * @param {Number} projectId The project in which to search for tasks.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param projectId 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByProject(
            projectId: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Returns the compact task records for all tasks with the given tag.
         *    * @param {Number} tag The tag in which to search for tasks.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByTag(
            tag: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Returns the compact task records for some filtered set of tasks. Use one
         * * or more of the parameters provided to filter the tasks returned.
         * @param {Object} [params] Parameters for the request
         * @param {Number} [params.assignee] The assignee to filter tasks on.
         * @param {Number} [params.workspace] The workspace or organization to filter tasks on.
         * @param {Number} [params.completed_since] Only return tasks that are either incomplete or that have been
         * completed since this time.
         * @param {Number} [params.modified_since] Only return tasks that have been modified since the given time.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params?: Tasks$FindAllParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Adds each of the specified followers to the task, if they are not already
         * * following. Returns the complete, updated record for the affected task.
         * @param {Number} task The task to add followers to.
         * @param {Object} data Data for the request
         * @param {Array} data.followers An array of followers to add to the task.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addFollowers(
            task: number,
            data: Tasks$FollowersParams,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * Removes each of the specified followers from the task if they are
         * * following. Returns the complete, updated record for the affected task.
         * @param {Number} task The task to remove followers from.
         * @param {Object} data Data for the request
         * @param {Array} data.followers An array of followers to remove from the task.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeFollowers(
            task: number,
            data: Tasks$FollowersParams,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * Returns a compact representation of all of the projects the task is in.
         *    * @param {Number} task The task to get projects on.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        projects(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Projects$Type >> ,

        /**
         * * Adds the task to the specified project, in the optional location
         * * specified. If no location arguments are given, the task will be added to
         * the beginning of the project.
         *
         * `addProject` can also be used to reorder a task within a project that
         * already contains it.
         *
         * Returns an empty data block.
         * @param {Number} task The task to add to a project.
         * @param {Object} data Data for the request
         * @param {Number} data.project The project to add the task to.
         * @param {Number} [data.insertAfter] A task in the project to insert the task after, or `null` to
         * insert at the beginning of the list.
         * @param {Number} [data.insertBefore] A task in the project to insert the task before, or `null` to
         * insert at the end of the list.
         * @param {Number} [data.section] A section in the project to insert the task into. The task will be
         * inserted at the top of the section.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addProject(
            task: number,
            data: Tasks$AddProjectParams,
            dispatchOptions?: any): promise$Promise<{}>,

        /**
         * * Removes the task from the specified project. The task will still exist
         * * in the system, but it will not be in the project anymore.
         *
         * Returns an empty data block.
         * @param {Number} task The task to remove from a project.
         * @param {Object} data Data for the request
         * @param {Number} data.project The project to remove the task from.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeProject(
            task: number,
            data: Tasks$RemoveProjectParams,
            dispatchOptions?: any): promise$Promise<{}>,

        /**
         * * Returns a compact representation of all of the tags the task has.
         *    * @param {Number} task The task to get tags on.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        tags(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tags$Type >> ,

        /**
         * * Adds a tag to a task. Returns an empty data block.
         *    * @param {Number} task The task to add a tag to.
         * @param {Object} data Data for the request
         * @param {Number} data.tag The tag to add to the task.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addTag(
            task: number,
            data: Tasks$TagParams,
            dispatchOptions?: any): promise$Promise<{}>,

        /**
         * * Removes a tag from the task. Returns an empty data block.
         *    * @param {Number} task The task to remove a tag from.
         * @param {Object} data Data for the request
         * @param {String} data.tag The tag to remove from the task.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeTag(
            task: number,
            data: Tasks$TagParams,
            dispatchOptions?: any): promise$Promise<{}>,

        /**
         * * Returns a compact representation of all of the subtasks of a task.
         *    * @param {Number} task The task to get the subtasks of.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        subtasks(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Tasks$Type >> ,

        /**
         * * Creates a new subtask and adds it to the parent task. Returns the full record
         * * for the newly created subtask.
         * @param {Number} task The task to add a subtask to.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addSubtask(
            task: number,
            data: Tasks$CreateParams,
            dispatchOptions?: any): promise$Promise<Tasks$Type>,

        /**
         * * Returns a compact representation of all of the stories on the task.
         *    * @param {Number} task The task containing the stories to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        stories(
            task: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Stories$Type >> ,

        /**
         * * Adds a comment to a task. The comment will be authored by the
         * * currently authenticated user, and timestamped when the server receives
         * the request.
         *
         * Returns the full record for the new story added to the task.
         * @param {Number} task Globally unique identifier for the task.
         * @param {Object} data Data for the request
         * @param {String} data.text The plain text of the comment to add.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param task 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addComment(
            task: number,
            data: Tasks$CommentParams,
            dispatchOptions?: any): promise$Promise<Stories$Type >
    } & resources$Resource


    declare interface resources$TeamsStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Teams
    }


    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Teams$Type = {} & Function


    declare     var Teams: resources$TeamsStatic;


    /**
     * A _team_ is used to group related projects and people together within an
     * organization. Each project in an organization is associated with a team.
     * @class  * 
     * @param  The API dispatcher
     */
    declare type resources$Teams = {

        /**
         * * Returns the full record for a single team.
         *    * @param {Number} team Globally unique identifier for the team.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param team 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            team: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Teams$Type>,

        /**
         * * Returns the compact records for all teams in the organization visible to
         * * the authorized user.
         * @param {Number} organization Globally unique identifier for the workspace or organization.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param organization 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByOrganization(
            organization: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<resources$SimpleResourceList>,

        /**
         * * Returns the compact records for all users that are members of the team.
         *    * @param {Number} team Globally unique identifier for the team.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param team 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        users(
            team: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<resources$SimpleResourceList>,

        /**
         * * The user making this call must be a member of the team in order to add others.
         * * The user to add must exist in the same organization as the team in order to be added.
         * The user to add can be referenced by their globally unique user ID or their email address.
         * Returns the full user record for the added user.
         * @param {Number} team Globally unique identifier for the team.
         * @param {Object} data Data for the request
         * @param {Number|String} data.user An identifier for the user. Can be one of an email address,
         * the globally unique identifier for the user, or the keyword `me`
         * to indicate the current user making the request.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param team 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addUser(
            team: number,
            data: resources$UserParams,
            dispatchOptions?: any): promise$Promise<any>,

        /**
         * * The user to remove can be referenced by their globally unique user ID or their email address.
         * * Removes the user from the specified team. Returns an empty data record.
         * @param {Number} team Globally unique identifier for the team.
         * @param {Object} data Data for the request
         * @param {Number|String} data.user An identifier for the user. Can be one of an email address,
         * the globally unique identifier for the user, or the keyword `me`
         * to indicate the current user making the request.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param team 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeUser(
            team: number,
            data: resources$UserParams,
            dispatchOptions?: any): promise$Promise<any >
    } & resources$Resource


    declare interface resources$UsersStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Users
    }

    declare type Users$FindAllParams = {
        team?: number,
        archived?: boolean
    } & resources$PaginationParams



    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Users$Type = {} & Function


    declare     var Users: resources$UsersStatic;


    /**
     * A _user_ object represents an account in Asana that can be given access to
     * various workspaces, projects, and tasks.

    Like other objects in the system, users are referred to by numerical IDs.
    However, the special string identifier `me` can be used anywhere
    a user ID is accepted, to refer to the current authenticated user.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Users = {

        /**
         * * Returns the full user record for the currently authenticated user.
         *    * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        me(params?: resources$Params, dispatchOptions?: any): promise$Promise<Users$Type>,

        /**
         * * Returns the full user record for the single user with the provided ID.
         *    * @param {Number|String} user An identifier for the user. Can be one of an email address,
         * the globally unique identifier for the user, or the keyword `me`
         * to indicate the current user making the request.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param user 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            user: string | number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Users$Type>,

        /**
         * * Returns the user records for all users in the specified workspace or
         * * organization.
         * @param {Number} workspace The workspace in which to get users.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByWorkspace(
            workspace: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Users$Type >> ,

        /**
         * * Returns the user records for all users in all workspaces and organizations
         * * accessible to the authenticated user. Accepts an optional workspace ID
         * parameter.
         * @param {Object} [params] Parameters for the request
         * @param {Number} [params.workspace] The workspace or organization to filter users on.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params 
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params: Users$FindAllParams,
            dispatchOptions?: any): promise$Promise<resources$SimpleResourceList >
    } & resources$Resource



    /**
     * *Webhooks are currently in BETA - The information here may change.*
     * 
    Webhooks allow an application to be notified of changes. This is in addition
    to the ability to fetch those changes directly as
    [Events](/developers/api-reference/events) - in fact, Webhooks are just a way
    to receive Events via HTTP POST at the time they occur instead of polling for
    them. For services accessible via HTTP this is often vastly more convenient,
    and if events are not too frequent can be significantly more efficient.

    In both cases, however, changes are represented as Event objects - refer to
    the [Events documentation](/developers/api-reference/events) for more
    information on what data these events contain.

    *NOTE:* While Webhooks send arrays of Event objects to their target, the
    Event objects themselves contain only IDs, rather than the actual resource
    they are referencing. So while a normal event you receive via GET /events
    would look like this:

         {\
           "resource": {\
             "id": 1337,\
             "name": "My Task"\
           },\
           "parent": null,\
           "created_at": "2013-08-21T18:20:37.972Z",\
           "user": {\
             "id": 1123,\
             "name": "Tom Bizarro"\
           },\
           "action": "changed",\
           "type": "task"\
         }

    In a Webhook payload you would instead receive this:

         {\
           "resource": 1337,\
           "parent": null,\
           "created_at": "2013-08-21T18:20:37.972Z",\
           "user": 1123,\
           "action": "changed",\
           "type": "task"\
         }

    Webhooks themselves contain only the information necessary to deliver the
    events to the desired target as they are generated.
     * @class  * 
     * @param  The API dispatcher
    */
    declare class Webhooks mixins Resource {

        /**
         * 
         * @param dispatcher 
         */
        constructor(dispatcher: asana$Dispatcher): this;

        /**
         * * Establishing a webhook is a two-part process. First, a simple HTTP POST
         * * similar to any other resource creation. Since you could have multiple
         * webhooks we recommend specifying a unique local id for each target.
         *
         * Next comes the confirmation handshake. When a webhook is created, we will
         * send a test POST to the `target` with an `X-Hook-Secret` header as
         * described in the
         * [Resthooks Security documentation](http://resthooks.org/docs/security/).
         * The target must respond with a `200 OK` and a matching `X-Hook-Secret`
         * header to confirm that this webhook subscription is indeed expected.
         *
         * If you do not acknowledge the webhook's confirmation handshake it will
         * fail to setup, and you will receive an error in response to your attempt
         * to create it. This means you need to be able to receive and complete the
         * webhook while the POST request is in-flight.
         * @param {Number} resource A resource ID to subscribe to. The resource can be a task or project.
         * @param {String} target The URL to receive the HTTP POST.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param resource 
         * @param target 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        create(
            resource: number,
            target: string,
            data: any,
            dispatchOptions?: any): promise$Promise<any>;

        /**
         * * Returns the compact representation of all webhooks your app has
         * * registered for the authenticated user in the given workspace.
         * @param {Number} workspace The workspace to query for webhooks in.
         * @param {Object} [params] Parameters for the request
         * @param {Number} [params.resource] Only return webhooks for the given resource.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        getAll(workspace: number, params?: any, dispatchOptions?: any): promise$Promise<any>;

        /**
         * * Returns the full record for the given webhook.
         *    * @param {String} webhook The webhook to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param webhook 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        getById(webhook: string, params?: any, dispatchOptions?: any): promise$Promise<any>;

        /**
         * * This method permanently removes a webhook. Note that it may be possible
         * * to receive a request that was already in flight after deleting the
         * webhook, but no further requests will be issued.
         * @param {String} webhook The webhook to delete.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param webhook 
         * @param dispatchOptions ?
         * @return  
         */
        deleteById(webhook: string, dispatchOptions?: any): promise$Promise<any >
    }

    declare interface resources$WorkspacesStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Workspaces
    }

    declare type Workspaces$ShortType = {
        created_at: string,
        created_by: resources$Resource,
        type: string,
        text: string
    } & resources$Resource



    /**
     * Runtime representation a type that a Component or other object is instances of.
     * 
    An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
    the `MyCustomComponent` constructor function.
    */
    declare type Workspaces$Type = {} & Function


    declare interface Workspaces$TypeaheadParams {
        type: string,
            query?: string,
            count?: number
    }

    declare     var Workspaces: resources$WorkspacesStatic;


    /**
     * A _workspace_ is the highest-level organizational unit in Asana. All projects
     * and tasks have an associated workspace.

    An _organization_ is a special kind of workspace that represents a company.
    In an organization, you can group your projects into teams. You can read
    more about how organizations work on the Asana Guide.
    To tell if your workspace is an organization or not, check its
    `is_organization` property.

    Over time, we intend to migrate most workspaces into organizations and to
    release more organization-specific functionality. We may eventually deprecate
    using workspace-based APIs for organizations. Currently, and until after
    some reasonable grace period following any further announcements, you can
    still reference organizations in any `workspace` parameter.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type resources$Workspaces = {

        /**
         * * Returns the full workspace record for a single workspace.
         *    * @param {Number} workspace Globally unique identifier for the workspace or organization.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            workspace: number,
            params?: resources$Params,
            dispatchOptions?: any): promise$Promise<Workspaces$Type>,

        /**
         * * Returns the compact records for all workspaces visible to the authorized user.
         *    * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params?: resources$PaginationParams,
            dispatchOptions?: any): promise$Promise<resources$ResourceList<Workspaces$ShortType >> ,

        /**
         * * A specific, existing workspace can be updated by making a PUT request on
         * * the URL for that workspace. Only the fields provided in the data block
         * will be updated; any unspecified fields will remain unchanged.
         *
         * Currently the only field that can be modified for a workspace is its `name`.
         *
         * Returns the complete, updated workspace record.
         * @param {Number} workspace The workspace to update.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        update(
            workspace: number,
            data: {
                name?: string
            },
            dispatchOptions?: any): promise$Promise<Workspaces$Type>,

        /**
         * * Retrieves objects in the workspace based on an auto-completion/typeahead
         * * search algorithm. This feature is meant to provide results quickly, so do
         * not rely on this API to provide extremely accurate search results. The
         * result set is limited to a single page of results with a maximum size,
         * so you won't be able to fetch large numbers of results.
         * @param {Number} workspace The workspace to fetch objects from.
         * @param {Object} [params] Parameters for the request
         * @param {String} params.type The type of values the typeahead should return.
         * Note that unlike in the names of endpoints, the types listed here are
         * in singular form (e.g. `task`). Using multiple types is not yet supported.
         * @param {String} [params.query] The string that will be used to search for relevant objects. If an
         * empty string is passed in, the API will currently return an empty
         * result set.
         * @param {Number} [params.count] The number of results to return. The default is `20` if this
         * parameter is omitted, with a minimum of `1` and a maximum of `100`.
         * If there are fewer results found than requested, all will be returned.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        typeahead(
            workspace: number,
            params?: Workspaces$TypeaheadParams,
            dispatchOptions?: any): promise$Promise<resources$SimpleResourceList>,

        /**
         * * The user can be referenced by their globally unique user ID or their email address.
         * * Returns the full user record for the invited user.
         * @param {Number} workspace The workspace or organization to invite the user to.
         * @param {Object} data Data for the request
         * @param {Number|String} data.user An identifier for the user. Can be one of an email address,
         * the globally unique identifier for the user, or the keyword `me`
         * to indicate the current user making the request.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        addUser(
            workspace: number,
            data: resources$UserParams,
            dispatchOptions?: any): promise$Promise<Users$Type>,

        /**
         * * The user making this call must be an admin in the workspace.
         * * Returns an empty data record.
         * @param {Number} workspace The workspace or organization to invite the user to.
         * @param {Object} data Data for the request
         * @param {Number|String} data.user An identifier for the user. Can be one of an email address,
         * the globally unique identifier for the user, or the keyword `me`
         * to indicate the current user making the request.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        removeUser(
            workspace: number,
            data: resources$UserParams,
            dispatchOptions?: any): promise$Promise<any >
    } & resources$Resource


    declare interface resources$ResourceStatic {

        /**
         * 
         * @param dispatcher 
         */
        new(dispatcher: asana$Dispatcher): resources$Resource,

        /**
         * 
         * @type  Default number of items to get per page.
         */
        DEFAULT_PAGE_LIMIT: number,

            /**
             * Helper method that dispatches a GET request to the API, where the expected
             * result is a collection.
             * @param  
             * @param  The path of the API
             * @param  The query params
             * @param  Options for handling the request and
            response. See `Dispatcher.dispatch`.
             * @return  The Collection response for the request
             * @param dispatcher 
             * @param path 
             * @param query ?
             * @param dispatchOptions ?
            */
            getCollection(
                dispatcher: any,
                path: string,
                query?: any,
                dispatchOptions?: any): promise$Promise<any>,

            /**
             * Helper method for any request Promise from the Dispatcher, unwraps the `data`
             * value from the payload.
             * @param  A promise returned from a `Dispatcher` request.
             * @return  The `data` portion of the response payload.
             * @param promise 
             * @return  
             */
            unwrap(promise: any): promise$Promise<any >
    }

    declare     var Resource: resources$ResourceStatic;


    /**
     * Base class for a resource accessible via the API. Uses a `Dispatcher` to
     * access the resources.
     * @param  
     * @constructor  
     */
    declare interface resources$Resource {

        /**
         * Dispatches a GET request to the API, where the expected result is a
         * single resource.
         * @param  The path of the API
         * @param  The query params
         * @param  Options for handling the request and
        response. See `Dispatcher.dispatch`.
         * @return  The response for the request
         * @param path 
         * @param query ?
         * @param dispatchOptions ?
         * @return  
        */
        dispatchGet(path: string, query?: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a GET request to the API, where the expected result is a
             * collection.
             * @param  The path of the API
             * @param  The query params
             * @param  Options for handling the request and
            response. See `Dispatcher.dispatch`.
             * @return  The response for the request
             * @param path 
             * @param query ?
             * @param dispatchOptions ?
             * @return  
            */
            dispatchGetCollection(path: string, query?: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a POST request to the API, where the expected response is a
             * single resource.
             * @param  The path of the API
             * @param  The query params
             * @param  Options for handling the request and
            response. See `Dispatcher.dispatch`.
             * @return  The response for the request
             * @param path 
             * @param query ?
             * @param dispatchOptions ?
             * @return  
            */
            dispatchPost(path: string, query?: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a POST request to the API, where the expected response is a
             * single resource.
             * @param  The path of the API
             * @param  The query params
             * @param  Options for handling the request and
            response. See `Dispatcher.dispatch`.
             * @return  The response for the request
             * @param path 
             * @param query ?
             * @param dispatchOptions ?
             * @return  
            */
            dispatchPut(path: string, query?: any, dispatchOptions?: any): promise$Promise<any>,

            /**
             * Dispatches a DELETE request to the API. The expected response is an
             * empty resource.
             * @param  The path of the API
             * @param  Options for handling the request and
            response. See `Dispatcher.dispatch`.
             * @return  The response for the request
             * @param path 
             * @param dispatchOptions ?
             * @return  
            */
            dispatchDelete(path: string, dispatchOptions?: any): promise$Promise<any >
    }

    declare interface resources$ResourceList<T>{
        data: T[],
        _response: {
            data: T[],
            next_page?: resources$NextPage
        },
        _dispatcher: {
            authenticator: {
                apiKey: string
            },
            asanaBaseUrl: string,
            retryOnRateLimit: boolean,
            requestTimeout: number,
            _cachedVersionInfo: resources$VersionInfo
        }
    }

    declare type resources$SimpleResourceList = resources$ResourceList<resources$Resource>;

    declare interface resources$NextPage {
        offset: string,
            uri: string,
            path: string
    }

    declare interface resources$VersionInfo {
        version: string,
            language: string,
            language_version: string,
            os: string,
            os_version: string
    }

    declare type resources$PaginationParams = {
        limit?: number,
        offset?: string
    } & resources$Params


    declare interface resources$Params {
        opt_fields?: string,
            opt_expand?: string
    }

    declare interface resources$UserParams {
        user: string | number
    }

    declare interface resources$Membership {
        project: resources$Resource,
            section: resources$Resource
    }

    declare     var VERSION: string;
    declare module.exports: typeof asana
}
declare interface AsciifyOptions {
    font?: string,
        maxWidth?: number,
        color?: string
}
declare interface AsciifyCallback {
    (err: any, asciifiedText: string): void
}
declare module 'asciify' {
    declare module.exports: typeof asciify

    declare     var npm$namespace$asciify: {
        getFonts: typeof asciify$getFonts,
    }
    declare     function asciify$getFonts(callback: (err: error$Error, fonts: string[]) => void): void
}
declare module 'aspnet-identity-pw' {
    declare     export function hashPassword(password: string): string
    declare     export function validatePassword(password: string, hashedPass: string): boolean
}
declare module 'assert' {
    declare module.exports: typeof assert
}

declare var npm$namespace$assert: {
    fail: typeof assert$fail,
    ok: typeof assert$ok,
    equal: typeof assert$equal,
    notEqual: typeof assert$notEqual,
    deepEqual: typeof assert$deepEqual,
    notDeepEqual: typeof assert$notDeepEqual,
    strictEqual: typeof assert$strictEqual,
    notStrictEqual: typeof assert$notStrictEqual,
    ifError: typeof assert$ifError,
}
declare export class AssertionError mixins Error {
    name: string;
    message: string;
    actual: any;
    expected: any;
    operator: string;
    generatedMessage: boolean;
    constructor(options?: {
        message?: string,
        actual?: any,
        expected?: any,
        operator?: string,
        stackStartFunction?: Function
    }): this
}

declare export function assert$fail(actual?: any, expected?: any, message?: string, operator?: string): void

declare export function assert$ok(value: any, message?: string): void

declare export function assert$equal(actual: any, expected: any, message?: string): void

declare export function assert$notEqual(actual: any, expected: any, message?: string): void

declare export function assert$deepEqual(actual: any, expected: any, message?: string): void

declare export function assert$notDeepEqual(acutal: any, expected: any, message?: string): void

declare export function assert$strictEqual(actual: any, expected: any, message?: string): void

declare export function assert$notStrictEqual(actual: any, expected: any, message?: string): void

declare export var throws: {
    (block: Function, message?: string): void,
    (block: Function, error: Function, message?: string): void,
    (block: Function, error: RegExp, message?: string): void,
    (block: Function, error: (err: any) => boolean, message?: string): void
};

declare export var doesNotThrow: {
    (block: Function, message?: string): void,
    (block: Function, error: Function, message?: string): void,
    (block: Function, error: RegExp, message?: string): void,
    (block: Function, error: (err: any) => boolean, message?: string): void
};

declare export function assert$ifError(value: any): voiddeclare module 'assertion-error' {
    declare module.exports: typeof AssertionError
}
declare module 'assertsharp' {
    declare     export default class Assert {
        AreEqual<T>(expected: T, actual: T, message?: string): void;
        AreNotEqual<T>(notExpected: T, actual: T, message?: string): void;
        AreNotSame<T>(notExpected: T, actual: T, message?: string): void;
        AreSequenceEqual<T>(
            expected: T[],
            actual: T[],
            equals?: (x: any, y: any) => boolean,
            message?: string): void;
        Fail(message?: string): void;
        IsFalse(actual: boolean, message?: string): void;
        IsInstanceOfType(actual: any, expectedType: Function, message?: string): void;
        IsNotInstanceOfType(actual: any, wrongType: Function, message?: string): void;
        IsNotNull(actual: any, message?: string): void;
        IsNull(actual: any, message?: string): void;
        IsTrue(actual: boolean, message?: string): void;
        Throws(fn: () => void, message?: string): void
    }
}
declare module 'async-lock' {
    declare interface AsyncLockDoneCallback {
        (err?: error$Error, ret?: any): void
    }
    declare interface AsyncLockOptions {
        timeout?: number,
            maxPending?: number,
            domainReentrant?: boolean,
            Promise?: any
    }
    declare module.exports: typeof AsyncLock

}
declare module 'async-polling' {
    declare module.exports: typeof AsyncPolling
}
declare module 'async-writer' {

    declare     var npm$namespace$async_writer: {
        create: typeof async_writer$create,
        enableAsyncStackTrace: typeof async_writer$enableAsyncStackTrace,
    }
    declare interface async_writer$EventFunction {
        (event: string, callback: Function): void
    }

    declare class StringWriter {
        constructor(events: events$EventEmitter): this;
        end(): void;
        write(what: string): async_writer$StringWriter;
        toString(): string
    }

    declare class BufferedWriter {
        constructor(wrappedStream: stream.Stream): this;
        flush(): void;
        on(event: string, callback: Function): async_writer$BufferedWriter;
        once(event: string, callback: Function): async_writer$BufferedWriter;
        clear(): void;
        end(): void;
        write(what: string): async_writer$BufferedWriter
    }

    declare interface async_writer$BeginAsyncOptions {
        last?: boolean,
            timeout?: number,
            name?: string
    }

    declare class AsyncWriter {
        enableAsyncStackTrace(): void;
        constructor(writer?: any, global?: {
            [s: string]: any
        }, async?: boolean, buffer?: boolean): this;
        isAsyncWriter: async_writer$AsyncWriter;
        sync(): void;
        getAttributes(): {
            [s: string]: any
        };
        getAttribute(): any;
        write(str: string): async_writer$AsyncWriter;
        getOutput(): string;
        captureString(func: Function, thisObj: AV$Object): string;
        swapWriter(
            newWriter: async_writer$StringWriter | async_writer$BufferedWriter,
            func: Function,
            thisObj: AV$Object): void;
        createNestedWriter(
            writer: async_writer$StringWriter | async_writer$BufferedWriter): async_writer$AsyncWriter;
        beginAsync(options?: number | async_writer$BeginAsyncOptions): async_writer$AsyncWriter;
        handleBeginAsync(
            options: number | async_writer$BeginAsyncOptions,
            parent: async_writer$AsyncWriter): void;
        on(event: string, callback: Function): async_writer$AsyncWriter;
        once(event: string, callback: Function): async_writer$AsyncWriter;
        onLast(callback: Function): async_writer$AsyncWriter;
        emit(arg: any): async_writer$AsyncWriter;
        removeListener(): async_writer$AsyncWriter;
        pipe(stream: stream.Stream): async_writer$AsyncWriter;
        error(e: error$Error): void;
        end(data?: any): async_writer$AsyncWriter;
        handleEnd(isAsync: boolean): void;
        _finish(): void;
        flush(): void
    }

    declare interface async_writer$AsyncWriterOptions {
        global?: {
                [s: string]: any
            },
            buffer?: boolean
    }

    declare     export function async_writer$create(
        db: anydbSQL$AnydbSql,
        tasks: any): {
        run: () => promise$Promise<any>,
        migrateTo: (target?: string) => promise$Promise<any>,
        check: (
            f: (m: {
                type: string,
                items: MigrationTask[]
            }) => any) => promise$Promise<any >
    }

    declare     function async_writer$enableAsyncStackTrace(): void
    declare module.exports: typeof async_writer
}
declare interface Dictionary<T>{
    [key: string]: T
}
declare interface ErrorCallback<T>{
    (err?: T): void
}
declare interface AsyncWaterfallCallback<E>{
    (err: E, ...args: any[]): void
}
declare interface AsyncBooleanResultCallback<E>{
    (err: E, truthValue: boolean): void
}
declare interface AsyncResultCallback<T, E>{
    (err: E, result: T): void
}
declare interface AsyncResultArrayCallback<T, E>{
    (err: E, results: T[]): void
}
declare interface AsyncResultObjectCallback<T, E>{
    (err: E, results: Dictionary<T>): void
}
declare interface AsyncFunction<T, E>{
    (callback: (err?: E, result?: T) => void): void
}
declare interface AsyncIterator<T, E>{
    (item: T, callback: ErrorCallback<E>): void
}
declare interface AsyncForEachOfIterator<T, E>{
    (item: T, key: number | string, callback: ErrorCallback<E>): void
}
declare interface AsyncResultIterator<T, R, E>{
    (item: T, callback: AsyncResultCallback<R, E>): void
}
declare interface AsyncMemoIterator<T, R, E>{
    (memo: R, item: T, callback: AsyncResultCallback<R, E>): void
}
declare interface AsyncBooleanIterator<T, E>{
    (item: T, callback: AsyncBooleanResultCallback<E>): void
}
declare interface AsyncWorker<T, E>{
    (task: T, callback: ErrorCallback<E>): void
}
declare interface AsyncVoidFunction<E>{
    (callback: ErrorCallback<E>): void
}
declare interface AsyncQueue<T>{
    length(): number,
    started: boolean,
    running(): number,
    idle(): boolean,
    concurrency: number,
    push<E>(task: T, callback?: ErrorCallback<E>): void,
    push<E>(task: T[], callback?: ErrorCallback<E>): void,
    unshift<E>(task: T, callback?: ErrorCallback<E>): void,
    unshift<E>(task: T[], callback?: ErrorCallback<E>): void,
    saturated: () => any,
    empty: () => any,
    drain: () => any,
    paused: boolean,
    pause(): void,
    resume(): void,
    kill(): void,
    workersList(): {
        data: T,
        callback: Function
    }[],
    error(error: error$Error, data: any): void,
    unsaturated(): void,
    buffer: number
}
declare interface AsyncPriorityQueue<T>{
    length(): number,
    concurrency: number,
    started: boolean,
    paused: boolean,
    push<E>(task: T, priority: number, callback?: AsyncResultArrayCallback<T, E>): void,
    push<E>(
        task: T[],
        priority: number,
        callback?: AsyncResultArrayCallback<T, E>): void,
    saturated: () => any,
    empty: () => any,
    drain: () => any,
    running(): number,
    idle(): boolean,
    pause(): void,
    resume(): void,
    kill(): void,
    workersList(): {
        data: T,
        priority: number,
        callback: Function
    }[],
    error(error: error$Error, data: any): void,
    unsaturated(): void,
    buffer: number
}
declare interface AsyncCargo {
    length(): number,
        payload: number,
        push(task: any, callback?: Function): void,
        push(task: any[], callback?: Function): void,
        saturated(): void,
        empty(): void,
        drain(): void,
        idle(): boolean,
        pause(): void,
        resume(): void,
        kill(): void
}
declare interface Async {
    each<T, E>(
            arr: T[],
            iterator: AsyncIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        each<T, E>(
            arr: Dictionary<T>,
            iterator: AsyncIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        eachSeries: typeof undefined,
        eachLimit<T, E>(
            arr: T[],
            limit: number,
            iterator: AsyncIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        eachLimit<T, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        forEach: typeof undefined,
        forEachSeries: typeof undefined,
        forEachLimit: typeof undefined,
        forEachOf<T, E>(
            obj: T[],
            iterator: AsyncForEachOfIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        forEachOf<T, E>(
            obj: Dictionary<T>,
            iterator: AsyncForEachOfIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        forEachOfSeries: typeof undefined,
        forEachOfLimit<T, E>(
            obj: T[],
            limit: number,
            iterator: AsyncForEachOfIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        forEachOfLimit<T, E>(
            obj: Dictionary<T>,
            limit: number,
            iterator: AsyncForEachOfIterator<T, E>,
            callback?: ErrorCallback<E>): void,
        eachOf: typeof undefined,
        eachOfSeries: typeof undefined,
        eachOfLimit: typeof undefined,
        map<T, R, E>(
            arr: T[],
            iterator: AsyncResultIterator<T, R, E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        map<T, R, E>(
            arr: Dictionary<T>,
            iterator: AsyncResultIterator<T, R, E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        mapSeries: typeof undefined,
        mapLimit<T, R, E>(
            arr: T[],
            limit: number,
            iterator: AsyncResultIterator<T, R, E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        mapLimit<T, R, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncResultIterator<T, R, E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        mapValuesLimit<T, R, E>(
            obj: Dictionary<T>,
            limit: number,
            iteratee: (value: T, key: string, callback: AsyncResultCallback<R, E>) => void,
            callback: AsyncResultCallback<R[], E>): void,
        mapValues<T, R, E>(
            obj: Dictionary<T>,
            iteratee: (value: T, key: string, callback: AsyncResultCallback<R, E>) => void,
            callback: AsyncResultCallback<R[], E>): void,
        mapValuesSeries: typeof undefined,
        filter<T, E>(
            arr: T[],
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultArrayCallback<T, E>): void,
        filter<T, E>(
            arr: Dictionary<T>,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultArrayCallback<T, E>): void,
        filterSeries: typeof undefined,
        filterLimit<T, E>(
            arr: T[],
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultArrayCallback<T, E>): void,
        filterLimit<T, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultArrayCallback<T, E>): void,
        select: typeof undefined,
        selectSeries: typeof undefined,
        selectLimit: typeof undefined,
        reject: typeof undefined,
        rejectSeries: typeof undefined,
        rejectLimit: typeof undefined,
        reduce<T, R, E>(
            arr: T[],
            memo: R,
            iterator: AsyncMemoIterator<T, R, E>,
            callback?: AsyncResultCallback<R, E>): void,
        inject: typeof undefined,
        foldl: typeof undefined,
        reduceRight: typeof undefined,
        foldr: typeof undefined,
        detect<T, E>(
            arr: T[],
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultCallback<T, E>): void,
        detect<T, E>(
            arr: Dictionary<T>,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultCallback<T, E>): void,
        detectSeries: typeof undefined,
        detectLimit<T, E>(
            arr: T[],
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultCallback<T, E>): void,
        detectLimit<T, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncResultCallback<T, E>): void,
        find: typeof undefined,
        findSeries: typeof undefined,
        findLimit: typeof undefined,
        sortBy<T, V, E>(
            arr: T[],
            iterator: AsyncResultIterator<T, V, E>,
            callback?: AsyncResultArrayCallback<T, E>): void,
        some<T, E>(
            arr: T[],
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        some<T, E>(
            arr: Dictionary<T>,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        someSeries: typeof undefined,
        someLimit<T, E>(
            arr: T[],
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        someLimit<T, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        any: typeof undefined,
        anySeries: typeof undefined,
        anyLimit: typeof undefined,
        every<T, E>(
            arr: T[],
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        every<T, E>(
            arr: Dictionary<T>,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        everySeries: typeof undefined,
        everyLimit<T, E>(
            arr: T[],
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        everyLimit<T, E>(
            arr: Dictionary<T>,
            limit: number,
            iterator: AsyncBooleanIterator<T, E>,
            callback?: AsyncBooleanResultCallback<E>): void,
        all: typeof undefined,
        allSeries: typeof undefined,
        allLimit: typeof undefined,
        concat<T, R, E>(
            arr: T[],
            iterator: AsyncResultIterator<T, R[], E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        concat<T, R, E>(
            arr: Dictionary<T>,
            iterator: AsyncResultIterator<T, R[], E>,
            callback?: AsyncResultArrayCallback<R, E>): void,
        concatSeries: typeof undefined,
        series<T, E>(
            tasks: AsyncFunction<T, E>[],
            callback?: AsyncResultArrayCallback<T, E>): void,
        series<T, E>(
            tasks: Dictionary<AsyncFunction<T, E >> ,
            callback?: AsyncResultObjectCallback<T, E>): void,
        parallel<T, E>(
            tasks: Array<AsyncFunction<T, E >> ,
            callback?: AsyncResultArrayCallback<T, E>): void,
        parallel<T, E>(
            tasks: Dictionary<AsyncFunction<T, E >> ,
            callback?: AsyncResultObjectCallback<T, E>): void,
        parallelLimit<T, E>(
            tasks: Array<AsyncFunction<T, E >> ,
            limit: number,
            callback?: AsyncResultArrayCallback<T, E>): void,
        parallelLimit<T, E>(
            tasks: Dictionary<AsyncFunction<T, E >> ,
            limit: number,
            callback?: AsyncResultObjectCallback<T, E>): void,
        whilst<E>(
            test: () => boolean,
            fn: AsyncVoidFunction<E>,
            callback: ErrorCallback<E>): void,
        doWhilst<E>(
            fn: AsyncVoidFunction<E>,
            test: () => boolean,
            callback: ErrorCallback<E>): void,
        until<E>(
            test: () => boolean,
            fn: AsyncVoidFunction<E>,
            callback: ErrorCallback<E>): void,
        doUntil<E>(
            fn: AsyncVoidFunction<E>,
            test: () => boolean,
            callback: ErrorCallback<E>): void,
        during<E>(
            test: (testCallback: AsyncBooleanResultCallback<E>) => void,
            fn: AsyncVoidFunction<E>,
            callback: ErrorCallback<E>): void,
        doDuring<E>(
            fn: AsyncVoidFunction<E>,
            test: (testCallback: AsyncBooleanResultCallback<E>) => void,
            callback: ErrorCallback<E>): void,
        forever<E>(next: (next: ErrorCallback<E>) => void, errBack: ErrorCallback<E>): void,
        waterfall<T, E>(tasks: Function[], callback?: AsyncResultCallback<T, E>): void,
        compose(...fns: Function[]): Function,
        seq(...fns: Function[]): Function,
        applyEach(fns: Function[], argsAndCallback: any[]): void,
        applyEachSeries(fns: Function[], argsAndCallback: any[]): void,
        queue<T, E>(worker: AsyncWorker<T, E>, concurrency?: number): AsyncQueue<T>,
        priorityQueue<T, E>(worker: AsyncWorker<T, E>, concurrency: number): AsyncPriorityQueue<T>,
        cargo<E>(
            worker: (tasks: any[], callback: ErrorCallback<E>) => void,
            payload?: number): AsyncCargo,
        auto<E>(
            tasks: any,
            concurrency?: number,
            callback?: AsyncResultCallback<any, E>): void,
        autoInject<E>(tasks: any, callback?: AsyncResultCallback<any, E>): void,
        retry<T, E>(
            opts: number,
            task: (callback: AsyncResultCallback<T, E>, results: any) => void,
            callback: AsyncResultCallback<any, E>): void,
        retry<T, E>(
            opts: {
                times: number,
                interval: number | ((retryCount: number) => number)
            },
            task: (callback: AsyncResultCallback<T, E>, results: any) => void,
            callback: AsyncResultCallback<any, E>): void,
        retryable<T, E>(
            opts: number | {
                times: number,
                interval: number
            },
            task: AsyncFunction<T, E>): AsyncFunction<T, E>,
        apply<E>(fn: Function, ...arguments: any[]): AsyncFunction<any, E>,
        nextTick(callback: Function, ...args: any[]): void,
        setImmediate: typeof undefined,
        reflect<T, E>(
            fn: AsyncFunction<T, E>): (
            callback: (err: void, result: {
                error?: error$Error,
                value?: T
            }) => void) => void,
        reflectAll<T, E>(
            tasks: AsyncFunction<T, E>[]): ((
            callback: (err: void, result: {
                error?: error$Error,
                value?: T
            }) => void) => void)[],
        timeout<T, E>(
            fn: AsyncFunction<T, E>,
            milliseconds: number,
            info: any): AsyncFunction<T, E>,
        times<T, E>(
            n: number,
            iterator: AsyncResultIterator<number, T, E>,
            callback: AsyncResultArrayCallback<T, E>): void,
        timesSeries<T, E>(
            n: number,
            iterator: AsyncResultIterator<number, T, E>,
            callback: AsyncResultArrayCallback<T, E>): void,
        timesLimit<T, E>(
            n: number,
            limit: number,
            iterator: AsyncResultIterator<number, T, E>,
            callback: AsyncResultArrayCallback<T, E>): void,
        transform<T, R, E>(
            arr: T[],
            iteratee: (acc: R[], item: T, key: string, callback: (error?: E) => void) => void): void,
        transform<T, R, E>(
            arr: T[],
            acc: R[],
            iteratee: (acc: R[], item: T, key: string, callback: (error?: E) => void) => void): void,
        transform<T, R, E>(
            arr: {
                [key: string]: T
            },
            iteratee: (
                acc: {
                    [key: string]: R
                },
                item: T,
                key: string,
                callback: (error?: E) => void) => void): void,
        transform<T, R, E>(
            arr: {
                [key: string]: T
            },
            acc: {
                [key: string]: R
            },
            iteratee: (
                acc: {
                    [key: string]: R
                },
                item: T,
                key: string,
                callback: (error?: E) => void) => void): void,
        race<T, E>(
            tasks: (AsyncFunction<T, E>)[],
            callback: AsyncResultCallback<T, E>): void,
        memoize(fn: Function, hasher?: Function): Function,
        unmemoize(fn: Function): Function,
        ensureAsync(fn: (...argsAndCallback: any[]) => void): Function,
        constant(...values: any[]): Function,
        asyncify(fn: Function): Function,
        wrapSync(fn: Function): Function,
        log(fn: Function, ...arguments: any[]): void,
        dir(fn: Function, ...arguments: any[]): void
}
declare var async: Async;
declare module 'async' {
    declare module.exports: typeof async
}
declare module 'asyncblock' {
    declare module.exports: typeof asyncblock

    declare     var npm$namespace$asyncblock: {
        nostack: typeof asyncblock$nostack,
    }
    declare     export function asyncblock$nostack<T>(
        f: (flow: asyncblock$IFlow) => void,
        callback?: (err: any, res: T) => void): void

    declare     export interface asyncblock$IFlow {
        add(responseFormat?: string[]): asyncblock$IExecuteFunction,
            add(key: string, responseFormat?: string[]): asyncblock$IExecuteFunction,
            add(key: number, responseFormat?: string[]): asyncblock$IExecuteFunction,
            add(options: asyncblock$IFlowOptions): asyncblock$IExecuteFunction,
            callback(responseFormat?: string[]): asyncblock$IExecuteFunction,
            callback(key: string, responseFormat?: string[]): asyncblock$IExecuteFunction,
            callback(key: number, responseFormat?: string[]): asyncblock$IExecuteFunction,
            callback(options: asyncblock$IFlowOptions): asyncblock$IExecuteFunction,
            wait<T>(key?: string): T,
            wait<T>(key?: number): T,
            get<T>(key: string): T,
            set(key: string, responseFormat?: string[]): asyncblock$IExecuteFunction,
            set(options: asyncblock$IFlowOptions): asyncblock$IExecuteFunction,
            del(key: string): void,
            sync<T>(task: any): T,
            queue(toExecute: asyncblock$IExecuteFunction): void,
            queue(key: string, toExecute: asyncblock$IExecuteFunction): void,
            queue(key: number, toExecute: asyncblock$IExecuteFunction): void,
            queue(responseFormat: string[], toExecute: asyncblock$IExecuteFunction): void,
            queue(
                key: string,
                responseFormat: string[],
                toExecute: asyncblock$IExecuteFunction): void,
            queue(
                key: number,
                responseFormat: string[],
                toExecute: asyncblock$IExecuteFunction): void,
            queue(options: asyncblock$IFlowOptions, toExecute: asyncblock$IExecuteFunction): void,
            doneAdding(): void,
            forceWait<T>(): T,
            maxParallel: number,
            errorCallback: (err: any) => void,
            taskTimeout: number,
            timeoutIsError: boolean
    }

    declare     export interface asyncblock$IFlowOptions {
        ignoreError?: boolean,
            key?: string,
            responseFormat?: string[],
            timeout?: number,
            timeoutIsError?: boolean,
            dontWait?: boolean,
            firstArgIsError?: boolean
    }

    declare     export interface asyncblock$IExecuteFunction {
        (err: any, res1: T1, res2: T2, res3: T3): any,
        (err: any, res1: T1, res2: T2): any,
        (err: any, res: T): any,
        (err: any): any,
        (res1: T1, res2: T2, res3: T3): any,
        (res1: T1, res2: T2): any,
        (res: T): any
    }
}
declare interface Atmosphere$Atmosphere {

    /**
     * The atmosphere API is a little bit special here: the first parameter can either be
     * a URL string or a Request object. If it is a URL string, then the additional parameters are expected.
     */
    subscribe?: (
            requestOrUrl: any,
            callback?: Function,
            request?: Atmosphere$Request) => Atmosphere$Request,
        unsubscribe?: () => void,
        AtmosphereRequest?: Atmosphere$AtmosphereRequest
}

declare interface Atmosphere$AtmosphereRequest {
    new(): Atmosphere$Request
}

declare export type Atmosphere$Request = {} & Message & adal$RequestInfo


declare export type Atmosphere$Response = {
    request_seq: number,
    success: boolean,

    /**
     * Contains error message if success === false. 
     */
    message?: string,

    /**
     * Contains message body if success === true. 
     */
    body?: any
} & Message
declare var atmosphere: Atmosphere$Atmosphere;
declare module 'atmosphere' {
    declare module.exports: typeof atmosphere
}
declare type AtomKeymap$Disposable = AtomEventKit.Disposable;

declare export interface AtomKeymap$KeyBinding {
    setDefaultHandler(kb: any): void,
        setKeyboardHandler(kb: any): void,
        addKeyboardHandler(kb: any, pos: any): void,
        removeKeyboardHandler(kb: any): boolean,
        getKeyboardHandler(): any,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        onTextInput(text: any): void
}

declare interface AtomKeymap$ICompleteMatchEvent {

    /**
     * Keystrokes that matched the binding. 
     */
    keystrokes: string,

        /**
         * Binding that was matched to the keystrokes. 
         */
        binding: AtomKeymap$KeyBinding,

        /**
         * DOM element that was the target of the most recent `KeyboardEvent`. 
         */
        keyboardEventTarget: angularScenario$Element
}

declare interface AtomKeymap$IPartialMatchEvent {

    /**
     * Keystrokes that matched the binding. 
     */
    keystrokes: string,

        /**
         * Bindings that were partially matched to the keystrokes. 
         */
        partiallyMatchedBindings: AtomKeymap$KeyBinding[],

        /**
         * DOM element that was the target of the most recent `KeyboardEvent`. 
         */
        keyboardEventTarget: angularScenario$Element
}

declare interface AtomKeymap$IFailedMatchEvent {

    /**
     * Keystrokes that failed to match a binding. 
     */
    keystrokes: string,

        /**
         * DOM element that was the target of the most recent `KeyboardEvent`. 
         */
        keyboardEventTarget: angularScenario$Element
}

declare interface AtomKeymap$IKeymapLoadEvent {

    /**
     * Path to a keymap file. 
     */
    path: string
}


/**
 * Static side of KeymapManager class. 
 */
declare interface AtomKeymap$KeymapManagerStatic {
    prototype: AtomKeymap$KeymapManager,
        new(
            options?: {
                defaultTarget?: angularScenario$Element
            }): AtomKeymap$KeymapManager
}


/**
 * Instance side of KeymapManager class. 
 */
declare interface AtomKeymap$KeymapManager {
    constructor: AtomKeymap$KeymapManagerStatic,

        /**
         * Unwatches all watched paths. 
         */
        destroy(): void,

        /**
         * Sets callback to invoke when one or more keystrokes completely match a key binding. 
         */
        onDidMatchBinding(
            callback: (event: AtomKeymap$ICompleteMatchEvent) => void): AtomKeymap$Disposable,

        /**
         * Sets callback to invoke when one or more keystrokes partially match a binding. 
         */
        onDidPartiallyMatchBindings(
            callback: (event: AtomKeymap$IPartialMatchEvent) => void): AtomKeymap$Disposable,

        /**
         * Sets callback to invoke when one or more keystrokes fail to match any bindings. 
         */
        onDidFailToMatchBinding(callback: (event: AtomKeymap$IFailedMatchEvent) => void): AtomKeymap$Disposable,

        /**
         * Sets callback to invoke when a keymap file is reloaded. 
         */
        onDidReloadKeymap(callback: (event: AtomKeymap$IKeymapLoadEvent) => void): AtomKeymap$Disposable,

        /**
         * Sets callback to invoke when a keymap file is unloaded. 
         */
        onDidUnloadKeymap(callback: (event: AtomKeymap$IKeymapLoadEvent) => void): AtomKeymap$Disposable,

        /**
         * Sets callback to invoke when a keymap file could not to be loaded. 
         */
        onDidFailToReadFile(callback: (error: error$Error) => void): AtomKeymap$Disposable,

        /**
         * Adds sets of key bindings grouped by CSS selector. 
         */
        add(source: string, keyBindingsBySelector: any): AtomKeymap$Disposable,
        getKeyBindings(): AtomKeymap$KeyBinding[],
        findKeyBindings(
            params?: {
                keystrokes: string,
                command: string,
                target?: angularScenario$Element
            }): AtomKeymap$KeyBinding[],

        /**
         * Loads the key bindings from the given path.
         * @param bindingsPath A path to a file or a directory. If the path is a directory all files
        inside it will be loaded.
        */
        loadKeymap(bindingsPath: string, options?: {
            watch: boolean
        }): void,

        /**
         * Starts watching the given file/directory for changes, reloading any keymaps at that location
         * when changes are detected.
         * @param filePath A path to a file or a directory.
         */
        watchKeymap(filePath: string): void,

        /**
         * Dispatches a custom event associated with the matching key binding for the given
         * `KeyboardEvent` if one can be found.
         */
        handleKeyboardEvent(event: KeyboardEvent): void,

        /**
         * Translates a keydown event to a keystroke string. 
         */
        keystrokeForKeyboardEvent(event: KeyboardEvent): string,

        /**
         * 
         * @return  The number of milliseconds allowed before pending states caused by partial matches of
        multi-keystroke bindings are terminated.
        */
        getPartialMatchTimeout(): number
}

declare var KeymapManager: AtomKeymap$KeymapManagerStatic;
declare module 'atom-keymap' {
    declare module.exports: typeof AtomKeymap
}
declare interface AtomDocTypes$Metadata {
    classes: {
        [className: string]: AtomDocTypes$ClassInfo
    }
}

declare interface AtomDocTypes$ClassInfo {
    name: string,
        superClass: string,
        visibility: string,
        filename: string,
        srcUrl: string,
        summary: string,
        description: string,
        examples: AtomDocTypes$Example[],
        sections: AtomDocTypes$Section[],
        classMethods: AtomDocTypes$ClassMethod[],
        classProperties: AtomDocTypes$ClassProperty[],
        instanceMethods: AtomDocTypes$InstanceMethod[],
        instanceProperties: AtomDocTypes$InstanceProperty[]
}

declare interface AtomDocTypes$Example {
    description: string,
        lang: string,
        code: string,
        raw: string
}

declare interface AtomDocTypes$Section {
    name: string,
        description: string
}

declare interface AtomDocTypes$ClassMethod {
    name: string,
        sectionName: string,
        srcUrl: string,
        visibility: string,
        summary: string,
        description: string,
        arguments: AtomDocTypes$Argument[],
        returnValues: AtomDocTypes$ReturnValue[]
}

declare interface AtomDocTypes$ClassProperty {}

declare interface AtomDocTypes$InstanceMethod {
    name: string,
        sectionName: string,
        srcUrl: string,
        visibility: string,
        summary: string,
        description: string,
        arguments: AtomDocTypes$Argument[],
        returnValues: AtomDocTypes$ReturnValue[],
        titledArguments: AtomDocTypes$TitledArgument[]
}

declare interface AtomDocTypes$InstanceProperty {
    name: string,
        sectionName: string,
        srcUrl: string,
        visibility: string,
        summary: string,
        description: string
}

declare interface AtomDocTypes$Argument {
    name: string,
        description: string,
        type: string,
        isOptional: boolean,
        children: AtomDocTypes$Argument[]
}

declare interface AtomDocTypes$TitledArgument {
    title: string,
        description: string,
        arguments: AtomDocTypes$Argument[]
}

declare interface AtomDocTypes$ReturnValue {
    type: string,
        description: string
}
declare interface AtomCore$IWorkspaceViewStatic {
    new(): AtomCore$IWorkspaceView,
    version: number,
        configDefaults: any,
        content(): any
}

declare interface AtomCore$Decoration {
    destroy(): void
}


/**
 * Represents a buffer annotation that remains logically stationary even as the buffer changes. This is used
 * to represent cursors, folds, snippet targets, misspelled words, any anything else that needs to track a
logical location in the buffer over time.
*/
declare interface AtomCore$Marker {

    /**
     * Destroys the marker, causing it to emit the 'destroyed' event. Once destroyed, a marker cannot be
     * restored by undo/redo operations.
     */
    destroy(): void,

        /**
         * Gets the screen range of the display marker.
         */
        getScreenRange(): AceAjax$Range
}

declare type AtomCore$IWorkspaceView = {
    fullScreen: boolean,
    open(uri: string, options: any): Q.Promise<View>,
    openSync(uri: string, options?: any): any,
    saveActivePaneItem(): any,
    saveActivePaneItemAs(): any,
    saveAll(): void,
    destroyActivePaneItem(): any,
    destroyActivePane(): any,
    increaseFontSize(): void,
    decreaseFontSize(): void,
    initialize(model: AtomCore$IWorkspace): any,
    initialize(view: View, args: any): void,
    model: AtomCore$IWorkspace,
    panes: AtomCore$IPaneContainerView,
    getModel(): AtomCore$IWorkspace,
    installShellCommands(): any,
    handleFocus(): any,
    afterAttach(onDom?: any): any,
    confirmClose(): boolean,
    updateTitle(): any,
    setTitle(title: string): any,
    getEditorViews(): any[],
    prependToTop(element: any): any,
    appendToTop(element: any): any,
    prependToBottom(element: any): any,
    appendToBottom(element: any): any,
    prependToLeft(element: any): any,
    appendToLeft(element: any): any,
    prependToRight(element: any): any,
    appendToRight(element: any): any,
    getActivePaneView(): AtomCore$IPaneView,
    getActiveView(): View,
    focusPreviousPaneView(): any,
    focusNextPaneView(): any,
    focusPaneViewAbove(): any,
    focusPaneViewBelow(): any,
    focusPaneViewOnLeft(): any,
    focusPaneViewOnRight(): any,
    eachPaneView(callback: (paneView: AtomCore$IPaneView) => any): {
        off(): any
    },
    getPaneViews(): AtomCore$IPaneView[],
    eachEditorView(callback: (editorView: any) => any): {
        off(): any
    },
    beforeRemove(): any,
    command(eventName: string, handler: Function): any,
    command(eventName: string, selector: Function, handler: Function): any,
    command(eventName: string, options: any, handler: Function): any,
    command(eventName: string, selector: Function, options: any, handler: Function): any,
    statusBar: StatusBar.IStatusBarView
} & View


declare interface AtomCore$IPanes {}

declare interface AtomCore$IPaneView {}

declare interface AtomCore$IPaneContainerView {}

declare interface AtomCore$ITreeView {}

declare interface AtomCore$IGutterViewStatic {
    new(): AtomCore$IGutterView,
    content(): any
}

declare type AtomCore$IGutterView = {
    firstScreenRow: any,
    lastScreenRow: any,
    initialize(): void,
    initialize(view: View, args: any): void,
    afterAttach(onDom?: any): any,
    beforeRemove(): any,
    handleMouseEvents(e: JQueryMouseEventObject): any,
    getEditorView(): any,
    getEditor(): AtomCore$IEditor,
    getLineNumberElements(): HTMLCollection,
    getLineNumberElementsForClass(klass: string): NodeList,
    getLineNumberElement(bufferRow: number): NodeList,
    addClassToAllLines(klass: string): boolean,
    removeClassFromAllLines(klass: string): boolean,
    addClassToLine(bufferRow: number, klass: string): boolean,
    removeClassFromLine(bufferRow: number, klass: string): boolean,
    updateLineNumbers(changes: any[], startScreenRow?: number, endScreenRow?: number): any,
    prependLineElements(lineElements: any): void,
    appendLineElements(lineElements: any): void,
    removeLineElements(numberOfElements: number): void,
    buildLineElements(startScreenRow: any, endScreenRow: any): any,
    buildLineElementsHtml(startScreenRow: any, endScreenRow: any): any,
    updateFoldableClasses(changes: any[]): any,
    removeLineHighlights(): void,
    addLineHighlight(row: number, emptySelection?: boolean): any,
    highlightLines(): boolean
} & View


declare interface AtomCore$ICommandRegistry {
    add(target: string, commandName: AV$Object, callback?: (event: any) => void): any,
        findCommands(params: AV$Object): AV$Object[],
        dispatch(selector: any, name: string): void
}

declare interface AtomCore$ICommandPanel {}

declare interface AtomCore$IDisplayBufferStatic {
    new(_arg?: any): AtomCore$IDisplayBuffer
}

declare interface AtomCore$IDisplayBuffer {
    constructor: AtomCore$IDisplayBufferStatic,
        verticalScrollMargin: number,
        horizontalScrollMargin: number,
        declaredPropertyValues: any,
        tokenizedBuffer: AtomCore$ITokenizedBuffer,
        buffer: TextBuffer.ITextBuffer,
        charWidthsByScope: any,
        markers: {
            [index: number]: AtomCore$IDisplayBufferMarker
        },
        foldsByMarkerId: any,
        maxLineLength: number,
        screenLines: AtomCore$ITokenizedLine[],
        rowMap: any,
        longestScreenRow: number,
        subscriptions: Emissary.ISubscription[],
        subscriptionsByObject: any,
        behaviors: any,
        subscriptionCounts: any,
        eventHandlersByEventName: any,
        pendingChangeEvent: any,
        softWrap: boolean,
        serializeParams(): {
            id: number,
            softWrap: boolean,
            editorWidthInChars: number,
            scrollTop: number,
            scrollLeft: number,
            tokenizedBuffer: any
        },
        deserializeParams(params: any): any,
        copy(): AtomCore$IDisplayBuffer,
        updateAllScreenLines(): any,
        emitChanged(eventProperties: any, refreshMarkers?: boolean): any,
        updateWrappedScreenLines(): any,
        setVisible(visible: any): any,
        getVerticalScrollMargin(): number,
        setVerticalScrollMargin(verticalScrollMargin: number): number,
        getHorizontalScrollMargin(): number,
        setHorizontalScrollMargin(horizontalScrollMargin: number): number,
        getHeight(): any,
        setHeight(height: any): any,
        getWidth(): any,
        setWidth(newWidth: any): any,
        getScrollTop(): number,
        setScrollTop(scrollTop: number): number,
        getScrollBottom(): number,
        setScrollBottom(scrollBottom: number): number,
        getScrollLeft(): number,
        setScrollLeft(scrollLeft: number): number,
        getScrollRight(): number,
        setScrollRight(scrollRight: number): number,
        getLineHeight(): any,
        setLineHeight(lineHeight: any): any,
        getDefaultCharWidth(): any,
        setDefaultCharWidth(defaultCharWidth: any): any,
        getScopedCharWidth(scopeNames: any, char: any): any,
        getScopedCharWidths(scopeNames: any): any,
        setScopedCharWidth(scopeNames: any, char: any, width: any): any,
        setScopedCharWidths(scopeNames: any, charWidths: any): any,
        clearScopedCharWidths(): any,
        getScrollHeight(): number,
        getScrollWidth(): number,
        getVisibleRowRange(): number[],
        intersectsVisibleRowRange(startRow: any, endRow: any): any,
        selectionIntersectsVisibleRowRange(selection: any): any,
        scrollToScreenRange(screenRange: any): any,
        scrollToScreenPosition(screenPosition: any): any,
        scrollToBufferPosition(bufferPosition: any): any,
        pixelRectForScreenRange(screenRange: TextBuffer.IRange): any,
        getTabLength(): number,
        setTabLength(tabLength: number): any,
        setSoftWrap(softWrap: boolean): boolean,
        getSoftWrap(): boolean,
        setEditorWidthInChars(editorWidthInChars: number): any,
        getEditorWidthInChars(): number,
        getSoftWrapColumn(): number,
        lineForRow(row: number): any,
        linesForRows(startRow: number, endRow: number): any,
        getLines(): any[],
        indentLevelForLine(line: any): any,
        bufferRowsForScreenRows(startScreenRow: any, endScreenRow: any): any,
        createFold(startRow: number, endRow: number): AtomCore$IFold,
        isFoldedAtBufferRow(bufferRow: number): boolean,
        isFoldedAtScreenRow(screenRow: number): boolean,
        destroyFoldWithId(id: number): any,
        unfoldBufferRow(bufferRow: number): any[],
        largestFoldStartingAtBufferRow(bufferRow: number): any,
        foldsStartingAtBufferRow(bufferRow: number): any,
        largestFoldStartingAtScreenRow(screenRow: any): any,
        largestFoldContainingBufferRow(bufferRow: any): any,
        outermostFoldsInBufferRowRange(startRow: any, endRow: any): any[],
        foldsContainingBufferRow(bufferRow: any): any[],
        screenRowForBufferRow(bufferRow: number): number,
        lastScreenRowForBufferRow(bufferRow: number): number,
        bufferRowForScreenRow(screenRow: number): number,
        screenRangeForBufferRange(bufferRange: TextBuffer.IPoint[]): TextBuffer.IRange,
        screenRangeForBufferRange(bufferRange: TextBuffer.IRange): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: TextBuffer.IPoint,
                end: TextBuffer.IPoint
            }): TextBuffer.IRange,
        screenRangeForBufferRange(bufferRange: {
            start: number[],
            end: TextBuffer.IPoint
        }): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: {
                    row: number,
                    col: number
                },
                end: TextBuffer.IPoint
            }): TextBuffer.IRange,
        screenRangeForBufferRange(bufferRange: {
            start: TextBuffer.IPoint,
            end: number[]
        }): TextBuffer.IRange,
        screenRangeForBufferRange(bufferRange: {
            start: number[],
            end: number[]
        }): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: {
                    row: number,
                    col: number
                },
                end: number[]
            }): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: TextBuffer.IPoint,
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: number[],
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        screenRangeForBufferRange(
            bufferRange: {
                start: {
                    row: number,
                    col: number
                },
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: TextBuffer.IPoint[]): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: TextBuffer.IRange): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: TextBuffer.IPoint,
                end: TextBuffer.IPoint
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: {
            start: number[],
            end: TextBuffer.IPoint
        }): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: TextBuffer.IPoint
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: {
            start: TextBuffer.IPoint,
            end: number[]
        }): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: {
            start: number[],
            end: number[]
        }): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: number[]
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: TextBuffer.IPoint,
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: number[],
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        bufferRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: {
                    row: number,
                    col: number
                }
            }): TextBuffer.IRange,
        pixelRangeForScreenRange(screenRange: TextBuffer.IPoint[], clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(screenRange: TextBuffer.IRange, clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: TextBuffer.IPoint,
                end: TextBuffer.IPoint
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: number[],
                end: TextBuffer.IPoint
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: TextBuffer.IPoint
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: TextBuffer.IPoint,
                end: number[]
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: number[],
                end: number[]
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: number[]
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: TextBuffer.IPoint,
                end: {
                    row: number,
                    col: number
                }
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: number[],
                end: {
                    row: number,
                    col: number
                }
            },
            clip?: boolean): TextBuffer.IRange,
        pixelRangeForScreenRange(
            screenRange: {
                start: {
                    row: number,
                    col: number
                },
                end: {
                    row: number,
                    col: number
                }
            },
            clip?: boolean): TextBuffer.IRange,
        pixelPositionForScreenPosition(screenPosition: TextBuffer.IPoint, clip?: boolean): TextBuffer.IPoint,
        pixelPositionForScreenPosition(screenPosition: number[], clip?: boolean): TextBuffer.IPoint,
        pixelPositionForScreenPosition(
            screenPosition: {
                row: number,
                col: number
            },
            clip?: boolean): TextBuffer.IPoint,
        screenPositionForPixelPosition(pixelPosition: any): TextBuffer.IPoint,
        pixelPositionForBufferPosition(bufferPosition: any): any,
        getLineCount(): number,
        getLastRow(): number,
        getMaxLineLength(): number,
        screenPositionForBufferPosition(bufferPosition: any, options: any): any,
        bufferPositionForScreenPosition(bufferPosition: any, options: any): any,
        scopesForBufferPosition(bufferPosition: any): any,
        bufferRangeForScopeAtPosition(selector: any, position: any): any,
        tokenForBufferPosition(bufferPosition: any): any,
        getGrammar(): AtomCore$IGrammar,
        setGrammar(grammar: AtomCore$IGrammar): any,
        reloadGrammar(): any,
        clipScreenPosition(screenPosition: any, options: any): any,
        findWrapColumn(line: any, softWrapColumn: any): any,
        rangeForAllLines(): TextBuffer.IRange,
        getMarker(id: number): AtomCore$IDisplayBufferMarker,
        getMarkers(): AtomCore$IDisplayBufferMarker[],
        getMarkerCount(): number,
        markScreenRange(range: TextBuffer.IRange, ...args: any[]): AtomCore$IDisplayBufferMarker,
        markBufferRange(range: TextBuffer.IRange, options?: any): AtomCore$IDisplayBufferMarker,
        markScreenPosition(
            screenPosition: TextBuffer.IPoint,
            options?: any): AtomCore$IDisplayBufferMarker,
        markBufferPosition(
            bufferPosition: TextBuffer.IPoint,
            options?: any): AtomCore$IDisplayBufferMarker,
        destroyMarker(id: number): any,
        findMarker(params?: any): AtomCore$IDisplayBufferMarker,
        findMarkers(params?: any): AtomCore$IDisplayBufferMarker[],
        translateToBufferMarkerParams(params?: any): any,
        findFoldMarker(attributes: any): AtomCore$IMarker,
        findFoldMarkers(attributes: any): AtomCore$IMarker[],
        getFoldMarkerAttributes(attributes?: any): any,
        pauseMarkerObservers(): any,
        resumeMarkerObservers(): any,
        refreshMarkerScreenPositions(): any,
        destroy(): any,
        logLines(start: number, end: number): any[],
        handleTokenizedBufferChange(tokenizedBufferChange: any): any,
        updateScreenLines(
            startBufferRow: any,
            endBufferRow: any,
            bufferDelta?: number,
            options?: any): any,
        buildScreenLines(startBufferRow: any, endBufferRow: any): any,
        findMaxLineLength(startScreenRow: any, endScreenRow: any, newScreenLines: any): any,
        handleBufferMarkersUpdated(): any,
        handleBufferMarkerCreated(marker: any): any,
        createFoldForMarker(maker: any): AtomCore$IFold,
        foldForMarker(marker: any): any
}

declare interface AtomCore$IViewRegistry {
    getView(selector: any): any
}

declare interface AtomCore$ICursorStatic {
    new(
        arg: {
            editor: AtomCore$IEditor,
            marker: AtomCore$IDisplayBufferMarker,
            id: number
        }): AtomCore$ICursor
}

declare interface AtomCore$ScopeDescriptor {
    scopes: string[]
}

declare interface AtomCore$ICursor {
    getScopeDescriptor(): AtomCore$ScopeDescriptor,
        screenPosition: any,
        bufferPosition: any,
        goalColumn: any,
        visible: boolean,
        needsAutoscroll: boolean,
        editor: AtomCore$IEditor,
        marker: AtomCore$IDisplayBufferMarker,
        id: number,
        destroy(): any,
        changePosition(options: any, fn: Function): any,
        getPixelRect(): any,
        setScreenPosition(screenPosition: any, options?: any): any,
        getScreenPosition(): TextBuffer.IPoint,
        getScreenRange(): TextBuffer.IRange,
        setBufferPosition(bufferPosition: any, options?: any): any,
        getBufferPosition(): TextBuffer.IPoint,
        autoscroll(): any,
        updateVisibility(): any,
        setVisible(visible: boolean): any,
        isVisible(): boolean,
        wordRegExp(arg?: any): any,
        isLastCursor(): boolean,
        isSurroundedByWhitespace(): boolean,
        isBetweenWordAndNonWord(): boolean,
        isInsideWord(): boolean,
        clearAutoscroll(): void,
        clearSelection(): void,
        getScreenRow(): number,
        getScreenColumn(): number,
        getBufferRow(): number,
        getBufferColumn(): number,
        getCurrentBufferLine(): string,
        moveUp(rowCount: number, arg?: any): any,
        moveDown(rowCount: number, arg?: any): any,
        moveLeft(arg?: any): any,
        moveRight(arg?: any): any,
        moveToTop(): any,
        moveToBottom(): void,
        moveToBeginningOfScreenLine(): void,
        moveToBeginningOfLine(): void,
        moveToFirstCharacterOfLine(): void,
        moveToEndOfScreenLine(): void,
        moveToEndOfLine(): void,
        moveToBeginningOfWord(): void,
        moveToEndOfWord(): void,
        moveToBeginningOfNextWord(): void,
        moveToPreviousWordBoundary(): void,
        moveToNextWordBoundary(): void,
        getBeginningOfCurrentWordBufferPosition(options?: any): TextBuffer.IPoint,
        getPreviousWordBoundaryBufferPosition(options?: any): TextBuffer.IPoint,
        getMoveNextWordBoundaryBufferPosition(options?: any): TextBuffer.IPoint,
        getEndOfCurrentWordBufferPosition(options?: any): TextBuffer.IPoint,
        getBeginningOfNextWordBufferPosition(options?: any): TextBuffer.IPoint,
        getCurrentWordBufferRange(options?: any): TextBuffer.IPoint,
        getCurrentLineBufferRange(options?: any): TextBuffer.IPoint,
        getCurrentParagraphBufferRange(): any,
        getCurrentWordPrefix(): string,
        isAtBeginningOfLine(): boolean,
        getIndentLevel(): number,
        isAtEndOfLine(): boolean,
        getScopes(): string[],
        hasPrecedingCharactersOnLine(): boolean,
        getMarker(): AtomCore$Marker
}

declare interface AtomCore$ILanguageMode {}

declare interface AtomCore$ISelection {
    onDidChangeRange(
            callback: (
                event: {
                    oldBufferRange: TextBuffer.IRange,
                    oldScreenRange: TextBuffer.IRange,
                    newBufferRange: TextBuffer.IRange,
                    newScreenRange: TextBuffer.IRange,
                    selection: AtomCore$ISelection
                }) => {}): AtomKeymap$Disposable,
        onDidDestroy(callback: () => {}): AtomKeymap$Disposable,
        getScreenRange(): TextBuffer.IRange,
        setScreenRange(
            screenRange: TextBuffer.IRange,
            options?: {
                preserveFolds?: boolean,
                autoscroll?: boolean
            }): void,
        getBufferRange(): TextBuffer.IRange,
        setBufferRange(
            bufferRange: TextBuffer.IRange,
            options?: {
                preserveFolds?: boolean,
                autoscroll?: boolean
            }): void,
        getBufferRowRange(): [number],
        isEmpty(): boolean,
        isReversed(): boolean,
        isSingleScreenLine(): boolean,
        getText(): string,
        intersectsBufferRange(bufferRange: TextBuffer.IRange): boolean,
        intersectsWith(otherSelection: AtomCore$ISelection): boolean,
        clear(options?: {
            autoscroll?: boolean
        }): void,
        selectToScreenPosition(position: any): void,
        selectToBufferPosition(position: any): void,
        selectRight(columnCount?: number): void,
        selectLeft(columnCount?: number): void,
        selectUp(rowCount: number): void,
        selectDown(rowCount: number): void,
        selectToTop(): void,
        selectToBottom(): void,
        selectAll(): void,
        selectToBeginningOfLine(): void,
        selectToFirstCharacterOfLine(): void,
        selectToEndOfLine(): void,
        selectToEndOfBufferLine(): void,
        selectToBeginningOfWord(): void,
        selectToEndOfWord(): void,
        selectToBeginningOfNextWord(): void,
        selectToPreviousWordBoundary(): void,
        selectToNextWordBoundary(): void,
        selectToPreviousSubwordBoundary(): void,
        selectToNextSubwordBoundary(): void,
        selectToBeginningOfNextParagraph(): void,
        selectToBeginningOfPreviousParagraph(): void,
        selectWord(): TextBuffer.IRange,
        expandOverWord(): void,
        selectLine(row?: number): void,
        expandOverLine(): void,
        insertText(
            text: string,
            options?: {
                select: boolean,
                autoIndent: boolean,
                autoIndentNewline: boolean,
                autoDecreaseIndent: boolean,
                normalizeLineEndings?: boolean,
                undo?: "skip"
            }): void,
        backspace(): void,
        deleteToPreviousWordBoundary(): void,
        deleteToNextWordBoundary(): void,
        deleteToBeginningOfWord(): void,
        deleteToBeginningOfLine(): void,
        delete(): void,
        deleteToEndOfLine(): void,
        deleteToEndOfWord(): void,
        deleteToBeginningOfSubword(): void,
        deleteToEndOfSubword(): void,
        deleteSelectedText(): void,
        deleteLine(): void,
        joinLines(): void,
        outdentSelectedRows(): void,
        autoIndentSelectedRows(): void,
        toggleLineComments(): void,
        cutToEndOfLine(): void,
        cutToEndOfBufferLine(): void,
        cut(maintainClipboard?: boolean, fullLine?: boolean): void,
        copy(maintainClipboard?: boolean, fullLine?: boolean): void,
        fold(): void,
        indentSelectedRows(): void,
        addSelectionBelow(): void,
        addSelectionAbove(): void,
        merge(
            otherSelection: AtomCore$ISelection,
            options?: {
                preserveFolds?: boolean,
                autoscroll?: boolean
            }): void,
        compare(otherSelection: AtomCore$ISelection): any
}

declare interface AtomCore$IDecorationParams {
    id?: number,
        class: string,
        type: any
}

declare interface AtomCore$IDecorationStatic {
    isType(decorationParams: AtomCore$IDecorationParams, type: any): boolean,
        new(
            marker: AtomCore$IDisplayBufferMarker,
            displayBuffer: AtomCore$IDisplayBuffer,
            params: AtomCore$IDecorationParams): AtomCore$IDecoration
}

declare type AtomCore$IDecoration = {
    marker: AtomCore$IDisplayBufferMarker,
    displayBuffer: AtomCore$IDisplayBuffer,
    params: AtomCore$IDecorationParams,
    id: number,
    flashQueue: any[],
    isDestroyed: boolean,
    destroy(): void,
    update(newParams: AtomCore$IDecorationParams): void,
    getMarker(): AtomCore$IDisplayBufferMarker,
    getParams(): AtomCore$IDecorationParams,
    isType(type: string): boolean,
    matchesPattern(decorationPattern: {
        [key: string]: AtomCore$IDecorationParams
    }): boolean,
    flash(klass: string, duration?: number): void,
    consumeNextFlash(): any
}

declare interface AtomCore$IEditor {
    deserializing: boolean,
        callDisplayBufferCreatedHook: boolean,
        registerEditor: boolean,
        buffer: TextBuffer.ITextBuffer,
        languageMode: AtomCore$ILanguageMode,
        cursors: AtomCore$ICursor[],
        selections: AtomCore$ISelection[],
        suppressSelectionMerging: boolean,
        updateBatchDepth: number,
        selectionFlashDuration: number,
        softTabs: boolean,
        displayBuffer: AtomCore$IDisplayBuffer,
        id: number,
        behaviors: any,
        declaredPropertyValues: any,
        eventHandlersByEventName: any,
        eventHandlersByNamespace: any,
        lastOpened: number,
        subscriptionCounts: any,
        subscriptionsByObject: any,
        subscriptions: Emissary.ISubscription[],
        destroy(): void,
        mini: any,
        serializeParams(): {
            id: number,
            softTabs: boolean,
            scrollTop: number,
            scrollLeft: number,
            displayBuffer: any
        },
        deserializeParams(params: any): any,
        subscribeToBuffer(): void,
        subscribeToDisplayBuffer(): void,
        getViewClass(): any,
        destroyed(): void,
        isDestroyed(): boolean,
        copy(): AtomCore$IEditor,
        getTitle(): string,
        getLongTitle(): string,
        setVisible(visible: boolean): void,
        setMini(mini: any): void,
        setScrollTop(scrollTop: any): void,
        getScrollTop(): number,
        setScrollLeft(scrollLeft: any): void,
        getScrollLeft(): number,
        setEditorWidthInChars(editorWidthInChars: any): void,
        getSoftWrapColumn(): number,
        getSoftTabs(): boolean,
        setSoftTabs(softTabs: boolean): void,
        getSoftWrap(): boolean,
        setSoftWrap(softWrap: any): void,
        getTabText(): string,
        getTabLength(): number,
        setTabLength(tabLength: any): void,
        usesSoftTabs(): boolean,
        clipBufferPosition(bufferPosition: any): void,
        clipBufferRange(range: any): void,
        indentationForBufferRow(bufferRow: any): void,
        setIndentationForBufferRow(bufferRow: any, newLevel: any, _arg: any): void,
        indentLevelForLine(line: any): number,
        buildIndentString(number: any): string,
        save(): void,
        saveAs(filePath: any): void,
        copyPathToClipboard(): void,
        getPath(): string,
        getText(): string,
        setText(text: any): void,
        getTextInRange(range: any): any,
        getLineCount(): number,
        getBuffer(): TextBuffer.ITextBuffer,
        getURI(): string,
        isBufferRowBlank(bufferRow: any): boolean,
        isBufferRowCommented(bufferRow: any): void,
        nextNonBlankBufferRow(bufferRow: any): void,
        getEofBufferPosition(): TextBuffer.IPoint,
        getLastBufferRow(): number,
        bufferRangeForBufferRow(row: any, options: any): TextBuffer.IRange,
        lineForBufferRow(row: number): string,
        lineLengthForBufferRow(row: number): number,
        scan(): any,
        scanInBufferRange(): any,
        backwardsScanInBufferRange(): any,
        isModified(): boolean,
        isEmpty(): boolean,
        shouldPromptToSave(): boolean,
        screenPositionForBufferPosition(bufferPosition: any, options?: any): TextBuffer.IPoint,
        bufferPositionForScreenPosition(screenPosition: any, options?: any): TextBuffer.IPoint,
        screenRangeForBufferRange(bufferRange: any): TextBuffer.IRange,
        bufferRangeForScreenRange(screenRange: any): TextBuffer.IRange,
        clipScreenPosition(screenPosition: any, options: any): TextBuffer.IRange,
        lineForScreenRow(row: any): AtomCore$ITokenizedLine,
        linesForScreenRows(start?: any, end?: any): AtomCore$ITokenizedLine[],
        getScreenLineCount(): number,
        getMaxScreenLineLength(): number,
        getLastScreenRow(): number,
        bufferRowsForScreenRows(startRow: any, endRow: any): any[],
        bufferRowForScreenRow(row: any): number,
        scopesForBufferPosition(bufferPosition: any): string[],
        bufferRangeForScopeAtCursor(selector: string): any,
        tokenForBufferPosition(bufferPosition: any): AtomCore$IToken,
        getCursorScopes(): string[],
        logCursorScope(): void,
        insertText(text: string, options?: any): TextBuffer.IRange[],
        insertNewline(): TextBuffer.IRange[],
        insertNewlineBelow(): TextBuffer.IRange[],
        insertNewlineAbove(): any,
        indent(options?: any): any,
        backspace(): any[],
        deleteToBeginningOfWord(): any[],
        deleteToBeginningOfLine(): any[],
        delete(): any[],
        deleteToEndOfLine(): any[],
        deleteToEndOfWord(): any[],
        deleteLine(): TextBuffer.IRange[],
        indentSelectedRows(): TextBuffer.IRange[][],
        outdentSelectedRows(): TextBuffer.IRange[][],
        toggleLineCommentsInSelection(): TextBuffer.IRange[],
        autoIndentSelectedRows(): TextBuffer.IRange[][],
        normalizeTabsInBufferRange(bufferRange: any): any,
        cutToEndOfLine(): boolean[],
        cutSelectedText(): boolean[],
        copySelectedText(): boolean[],
        pasteText(options?: any): TextBuffer.IRange[],
        undo(): any[],
        redo(): any[],
        foldCurrentRow(): any,
        unfoldCurrentRow(): any[],
        foldSelectedLines(): any[],
        foldAll(): any[],
        unfoldAll(): any[],
        foldAllAtIndentLevel(level: any): any,
        foldBufferRow(bufferRow: any): any,
        unfoldBufferRow(bufferRow: any): any,
        isFoldableAtBufferRow(bufferRow: any): boolean,
        isFoldableAtScreenRow(screenRow: any): boolean,
        createFold(startRow: any, endRow: any): AtomCore$IFold,
        destroyFoldWithId(id: any): any,
        destroyFoldsIntersectingBufferRange(bufferRange: any): any,
        toggleFoldAtBufferRow(bufferRow: any): any,
        isFoldedAtCursorRow(): boolean,
        isFoldedAtBufferRow(bufferRow: any): boolean,
        isFoldedAtScreenRow(screenRow: any): boolean,
        largestFoldContainingBufferRow(bufferRow: any): boolean,
        largestFoldStartingAtScreenRow(screenRow: any): any,
        outermostFoldsInBufferRowRange(startRow: any, endRow: any): any[],
        moveLineUp(): AtomCore$ISelection[],
        moveLineDown(): AtomCore$ISelection[],
        duplicateLines(): any[][],
        mutateSelectedText(fn: (selection: AtomCore$ISelection) => any): any,
        replaceSelectedText(options: any, fn: (selection: string) => any): any,
        decorationsForScreenRowRange(
            startScreenRow: any,
            endScreenRow: any): {
            [id: number]: AtomCore$IDecoration[]
        },
        decorateMarker(
            marker: AtomCore$IDisplayBufferMarker,
            decorationParams: {
                type: string,
                class: string
            }): AtomCore$IDecoration,
        decorationForId(id: number): AtomCore$IDecoration,
        getMarker(id: number): AtomCore$IDisplayBufferMarker,
        getMarkers(): AtomCore$IDisplayBufferMarker[],
        findMarkers(...args: any[]): AtomCore$IDisplayBufferMarker[],
        markScreenRange(...args: any[]): AtomCore$IDisplayBufferMarker,
        markBufferRange(...args: any[]): AtomCore$IDisplayBufferMarker,
        markScreenPosition(...args: any[]): AtomCore$IDisplayBufferMarker,
        markBufferPosition(...args: any[]): AtomCore$IDisplayBufferMarker,
        destroyMarker(...args: any[]): boolean,
        getMarkerCount(): number,
        hasMultipleCursors(): boolean,
        getCursors(): AtomCore$ICursor[],
        getCursor(): AtomCore$ICursor,
        addCursorAtScreenPosition(screenPosition: any): AtomCore$ICursor,
        addCursorAtBufferPosition(bufferPosition: any): AtomCore$ICursor,
        addCursor(marker: any): AtomCore$ICursor,
        removeCursor(cursor: any): AtomCore$ICursor[],
        addSelection(marker: any, options: any): AtomCore$ISelection,
        addSelectionForBufferRange(bufferRange: any, options: any): AtomCore$ISelection,
        setSelectedBufferRange(bufferRange: any, options: any): any,
        setSelectedBufferRanges(bufferRanges: any, options: any): any,
        removeSelection(selection: AtomCore$ISelection): any,
        clearSelections(): boolean,
        consolidateSelections(): boolean,
        selectionScreenRangeChanged(selection: any): void,
        getSelections(): AtomCore$ISelection[],
        getSelection(index?: number): AtomCore$ISelection,
        getLastSelection(): AtomCore$ISelection,
        getSelectionsOrderedByBufferPosition(): AtomCore$ISelection[],
        getLastSelectionInBuffer(): AtomCore$ISelection,
        selectionIntersectsBufferRange(bufferRange: any): any,
        setCursorScreenPosition(position: TextBuffer.IPoint, options?: any): any,
        getCursorScreenPosition(): TextBuffer.IPoint,
        getCursorScreenRow(): number,
        setCursorBufferPosition(position: any, options?: any): any,
        getCursorBufferPosition(): TextBuffer.IPoint,
        getSelectedScreenRange(): TextBuffer.IRange,
        getSelectedBufferRange(): TextBuffer.IRange,
        getSelectedBufferRanges(): TextBuffer.IRange[],
        getSelectedText(): string,
        getTextInBufferRange(range: TextBuffer.IRange): string,
        setTextInBufferRange(range: TextBuffer.IRange | any[], text: string): any,
        getCurrentParagraphBufferRange(): TextBuffer.IRange,
        getWordUnderCursor(options?: any): string,
        moveCursorUp(lineCount?: number): void,
        moveCursorDown(lineCount?: number): void,
        moveCursorLeft(): void,
        moveCursorRight(): void,
        moveCursorToTop(): void,
        moveCursorToBottom(): void,
        moveCursorToBeginningOfScreenLine(): void,
        moveCursorToBeginningOfLine(): void,
        moveCursorToFirstCharacterOfLine(): void,
        moveCursorToEndOfScreenLine(): void,
        moveCursorToEndOfLine(): void,
        moveCursorToBeginningOfWord(): void,
        moveCursorToEndOfWord(): void,
        moveCursorToBeginningOfNextWord(): void,
        moveCursorToPreviousWordBoundary(): void,
        moveCursorToNextWordBoundary(): void,
        moveCursorToBeginningOfNextParagraph(): void,
        moveCursorToBeginningOfPreviousParagraph(): void,
        moveToBottom(): void,
        scrollToCursorPosition(options: any): any,
        pageUp(): void,
        pageDown(): void,
        selectPageUp(): void,
        selectPageDown(): void,
        getRowsPerPage(): number,
        moveCursors(fn: (cursor: AtomCore$ICursor) => any): any,
        cursorMoved(event: any): void,
        selectToScreenPosition(position: TextBuffer.IPoint): any,
        selectRight(): AtomCore$ISelection[],
        selectLeft(): AtomCore$ISelection[],
        selectUp(rowCount?: number): AtomCore$ISelection[],
        selectDown(rowCount?: number): AtomCore$ISelection[],
        selectToTop(): AtomCore$ISelection[],
        selectAll(): AtomCore$ISelection[],
        selectToBottom(): AtomCore$ISelection[],
        selectToBeginningOfLine(): AtomCore$ISelection[],
        selectToFirstCharacterOfLine(): AtomCore$ISelection[],
        selectToEndOfLine(): AtomCore$ISelection[],
        selectToPreviousWordBoundary(): AtomCore$ISelection[],
        selectToNextWordBoundary(): AtomCore$ISelection[],
        selectLine(): AtomCore$ISelection[],
        selectLinesContainingCursors(): AtomCore$ISelection[],
        addSelectionBelow(): AtomCore$ISelection[],
        addSelectionAbove(): AtomCore$ISelection[],
        splitSelectionsIntoLines(): any[],
        transpose(): TextBuffer.IRange[],
        upperCase(): boolean[],
        lowerCase(): boolean[],
        joinLines(): any[],
        selectToBeginningOfWord(): AtomCore$ISelection[],
        selectToEndOfWord(): AtomCore$ISelection[],
        selectToBeginningOfNextWord(): AtomCore$ISelection[],
        selectWord(): AtomCore$ISelection[],
        selectToBeginningOfNextParagraph(): AtomCore$ISelection[],
        selectToBeginningOfPreviousParagraph(): AtomCore$ISelection[],
        selectMarker(marker: any): any,
        mergeCursors(): number[],
        expandSelectionsForward(): any,
        expandSelectionsBackward(fn: (selection: AtomCore$ISelection) => any): AtomCore$ISelection[],
        finalizeSelections(): boolean[],
        mergeIntersectingSelections(): any,
        preserveCursorPositionOnBufferReload(): Emissary.ISubscription,
        getGrammar(): AtomCore$IGrammar,
        setGrammar(grammer: AtomCore$IGrammar): void,
        reloadGrammar(): any,
        shouldAutoIndent(): boolean,
        shouldShowInvisibles(): boolean,
        updateInvisibles(): void,
        transact(fn: Function): any,
        beginTransaction(): AtomCore$ITransaction,
        commitTransaction(): any,
        abortTransaction(): any[],
        inspect(): string,
        logScreenLines(start: number, end: number): any[],
        handleTokenization(): void,
        handleGrammarChange(): void,
        handleMarkerCreated(marker: any): any,
        getSelectionMarkerAttributes(): {
            type: string,
            editorId: number,
            invalidate: string
        },
        getVerticalScrollMargin(): number,
        setVerticalScrollMargin(verticalScrollMargin: number): void,
        getHorizontalScrollMargin(): number,
        setHorizontalScrollMargin(horizontalScrollMargin: number): void,
        getLineHeightInPixels(): number,
        setLineHeightInPixels(lineHeightInPixels: number): void,
        batchCharacterMeasurement(fn: Function): void,
        getScopedCharWidth(scopeNames: any, char: any): any,
        setScopedCharWidth(scopeNames: any, char: any, width: any): any,
        getScopedCharWidths(scopeNames: any): any,
        clearScopedCharWidths(): any,
        getDefaultCharWidth(): number,
        setDefaultCharWidth(defaultCharWidth: number): void,
        setHeight(height: number): void,
        getHeight(): number,
        getClientHeight(): number,
        setWidth(width: number): void,
        getWidth(): number,
        getScrollTop(): number,
        setScrollTop(scrollTop: number): void,
        getScrollBottom(): number,
        setScrollBottom(scrollBottom: number): void,
        getScrollLeft(): number,
        setScrollLeft(scrollLeft: number): void,
        getScrollRight(): number,
        setScrollRight(scrollRight: number): void,
        getScrollHeight(): number,
        getScrollWidth(): number,
        getVisibleRowRange(): number,
        intersectsVisibleRowRange(startRow: any, endRow: any): any,
        selectionIntersectsVisibleRowRange(selection: any): any,
        pixelPositionForScreenPosition(screenPosition: any): any,
        pixelPositionForBufferPosition(bufferPosition: any): any,
        screenPositionForPixelPosition(pixelPosition: any): any,
        pixelRectForScreenRange(screenRange: any): any,
        scrollToScreenRange(screenRange: any, options: any): any,
        scrollToScreenPosition(screenPosition: any, options: any): any,
        scrollToBufferPosition(bufferPosition: any, options: any): any,
        horizontallyScrollable(): any,
        verticallyScrollable(): any,
        getHorizontalScrollbarHeight(): any,
        setHorizontalScrollbarHeight(height: any): any,
        getVerticalScrollbarWidth(): any,
        setVerticalScrollbarWidth(width: any): any,
        onDidChange(callback: Function): AtomKeymap$Disposable,
        onDidDestroy(callback: Function): AtomKeymap$Disposable,
        onDidStopChanging(callback: Function): AtomKeymap$Disposable,
        onDidChangeCursorPosition(callback: Function): AtomKeymap$Disposable,
        onDidSave(callback: (event: {
            path: string
        }) => void): AtomKeymap$Disposable,
        decorateMarker(marker: AtomCore$Marker, options: any): AtomCore$Decoration,
        getLastCursor(): AtomCore$ICursor
}

declare interface AtomCore$IGrammar {
    bundledPackage: boolean,
        emitter: any,
        fileTypes: [string],
        firstLineRegex: any,
        foldingStopMarker: any,
        includedGrammarScopes: [any],
        initialRule: any,
        injectionSelector: any,
        injections: any,
        maxTokensPerLine: Number,
        name: string,
        packageName: string,
        path: string,
        rawPatterns: [any],
        rawRepository: any,
        registration: AtomKeymap$Disposable,
        registry: any,
        repository: AV$Object,
        scopeName: string,
        tokenizeLines: (text: string) => any
}

declare interface AtomCore$IGrammars {
    grammarForScopeName(scope: string): AtomCore$IGrammar
}

declare interface AtomCore$IPane {
    itemForURI: (uri: string) => AtomCore$IEditor,
        items: any[],
        activeItem: any,
        serializeParams(): any,
        deserializeParams(params: any): any,
        getViewClass(): any,
        isActive(): boolean,
        isDestroyed(): boolean,
        focus(): void,
        blur(): void,
        activate(): void,
        getPanes(): AtomCore$IPane[],
        getItems(): any[],
        getActiveItem(): any,
        getActiveEditor(): any,
        itemAtIndex(index: number): any,
        activateNextItem(): any,
        activatePreviousItem(): any,
        getActiveItemIndex(): number,
        activateItemAtIndex(index: number): any,
        activateItem(item: any): any,
        addItem(item: any, index: number): any,
        addItems(items: any[], index: number): any[],
        removeItem(item: any, destroying: any): void,
        moveItem(item: any, newIndex: number): void,
        moveItemToPane(item: any, pane: AtomCore$IPane, index: number): void,
        destroyActiveItem(): boolean,
        destroyItem(item: any): boolean,
        destroyItems(): any[],
        destroyInactiveItems(): any[],
        destroy(): void,
        destroyed(): any[],
        promptToSaveItem(item: any): boolean,
        saveActiveItem(): void,
        saveActiveItemAs(): void,
        saveItem(item: any, nextAction: Function): void,
        saveItemAs(item: any, nextAction: Function): void,
        saveItems(): any[],
        activateItemForURI(uri: any): any,
        copyActiveItem(): void,
        splitLeft(params: any): AtomCore$IPane,
        splitRight(params: any): AtomCore$IPane,
        splitUp(params: any): AtomCore$IPane,
        splitDown(params: any): AtomCore$IPane,
        split(orientation: string, side: string, params: any): AtomCore$IPane,
        findLeftmostSibling(): AtomCore$IPane,
        findOrCreateRightmostSibling(): AtomCore$IPane
}

declare interface AtomCore$ISerializationStatic<T>{
    deserialize(data: AtomCore$ISerializationInfo): T,
    new(data: T): AtomCore$ISerialization
}

declare interface AtomCore$ISerialization {
    serialize(): AtomCore$ISerializationInfo
}

declare interface AtomCore$ISerializationInfo {
    deserializer: string
}

declare interface AtomCore$IBrowserWindow {
    getPosition(): number[],
        getSize(): number[]
}

declare interface AtomCore$IAtomWindowDimentions {
    x: number,
        y: number,
        width: number,
        height: number
}

declare interface AtomCore$IProjectStatic {
    pathForRepositoryUrl(repoUrl: string): string,
        new(arg?: {
            path: any,
            buffers: any[]
        }): AtomCore$IProject
}

declare interface AtomCore$IProject {
    path: string,

        /**
         * deprecated 
         */
        rootDirectory?: PathWatcher.IDirectory,
        rootDirectories: PathWatcher.IDirectory[],
        serializeParams(): any,
        deserializeParams(params: any): any,
        destroyed(): any,
        destroyRepo(): any,
        destroyUnretainedBuffers(): any,
        getRepo(): AtomCore$IGit,
        getPath(): string,
        setPath(projectPath: string): any,
        getRootDirectory(): PathWatcher.IDirectory,
        resolve(uri: string): string,
        relativize(fullPath: string): string,
        contains(pathToCheck: string): boolean,
        open(filePath: string, options?: any): Q.Promise<AtomCore$IEditor>,
        openSync(filePath: string, options?: any): AtomCore$IEditor,
        getBuffers(): TextBuffer.ITextBuffer,
        isPathModified(filePath: string): boolean,
        findBufferForPath(filePath: string): TextBuffer.ITextBuffer,
        bufferForPathSync(filePath: string): TextBuffer.ITextBuffer,
        bufferForPath(filePath: string): Q.Promise<TextBuffer.ITextBuffer>,
        bufferForId(id: any): TextBuffer.ITextBuffer,
        buildBufferSync(absoluteFilePath: string): TextBuffer.ITextBuffer,
        buildBuffer(absoluteFilePath: string): Q.Promise<TextBuffer.ITextBuffer>,
        addBuffer(buffer: TextBuffer.ITextBuffer, options?: any): any,
        addBufferAtIndex(buffer: TextBuffer.ITextBuffer, index: number, options?: any): any,
        scan(regex: any, options: any, iterator: any): Q.Promise<any>,
        replace(
            regex: any,
            replacementText: any,
            filePaths: any,
            iterator: any): Q.Promise<any>,
        buildEditorForBuffer(buffer: any, editorOptions: any): AtomCore$IEditor,
        eachBuffer(...args: any[]): any,
        onDidChangePaths(callback: Function): AtomKeymap$Disposable
}

declare interface AtomCore$IWorkspaceStatic {
    new(): AtomCore$IWorkspace
}

declare interface AtomCore$IWorkspacePanelOptions {
    item: any,
        visible?: boolean,
        priority?: number
}

declare interface AtomCore$Panel {
    getItem(): any,
        getPriority(): any,
        isVisible(): boolean,
        show(): void,
        hide(): void
}

declare interface AtomCore$IWorkspace {
    addBottomPanel(options: AtomCore$IWorkspacePanelOptions): AtomCore$Panel,
        addLeftPanel(options: AtomCore$IWorkspacePanelOptions): AtomCore$Panel,
        addRightPanel(options: AtomCore$IWorkspacePanelOptions): AtomCore$Panel,
        addTopPanel(options: AtomCore$IWorkspacePanelOptions): AtomCore$Panel,
        addModalPanel(options: AtomCore$IWorkspacePanelOptions): AtomCore$Panel,
        addOpener(opener: Function): any,
        deserializeParams(params: any): any,
        serializeParams(): {
            paneContainer: any,
            fullScreen: boolean
        },
        eachEditor(callback: Function): void,
        getTextEditors(): AtomCore$IEditor[],
        open(uri: string, options: any): Q.Promise<View>,
        openLicense(): void,
        openSync(uri: string, options: any): any,
        openUriInPane(uri: string, pane: any, options: any): Q.Promise<View>,
        observeTextEditors(callback: Function): AtomKeymap$Disposable,
        reopenItemSync(): any,
        registerOpener(opener: (urlToOpen: string) => any): void,
        unregisterOpener(opener: Function): void,
        getOpeners(): any,
        getActivePane(): AtomCore$IPane,
        getActivePaneItem(): AtomCore$IPane,
        getActiveTextEditor(): AtomCore$IEditor,
        getPanes(): any,
        saveAll(): void,
        activateNextPane(): any,
        activatePreviousPane(): any,
        paneForURI: (uri: string) => AtomCore$IPane,
        saveActivePaneItem(): any,
        saveActivePaneItemAs(): any,
        destroyActivePaneItem(): any,
        destroyActivePane(): any,
        getActiveEditor(): AtomCore$IEditor,
        increaseFontSize(): void,
        decreaseFontSize(): void,
        resetFontSize(): void,
        itemOpened(item: any): void,
        onPaneItemDestroyed(item: any): void,
        destroyed(): void,
        isTextEditor(object: any): boolean,
        onDidChangeActivePaneItem(item: any): AtomKeymap$Disposable
}

declare interface AtomCore$IAtomSettings {
    appVersion: string,
        bootstrapScript: string,
        devMode: boolean,
        initialPath: string,
        pathToOpen: string,
        resourcePath: string,
        shellLoadTime: number,
        windowState: string
}

declare interface AtomCore$IAtomState {
    mode: string,
        packageStates: any,
        project: any,
        syntax: any,
        version: number,
        windowDimensions: any,
        workspace: any
}

declare interface AtomCore$IDeserializerManager {
    deserializers: Function,
        add: Function,
        remove: Function,
        deserialize: Function,
        get: Function
}

declare interface AtomCore$IConfig {
    instrumentationKey?: string,
        endpointUrl?: string,
        emitLineDelimitedJson?: boolean,
        accountId?: string,
        sessionRenewalMs?: number,
        sessionExpirationMs?: number,
        maxBatchSizeInBytes?: number,
        maxBatchInterval?: number,
        enableDebug?: boolean,
        disableExceptionTracking?: boolean,
        disableTelemetry?: boolean,
        verboseLogging?: boolean,
        diagnosticLogInterval?: number,
        samplingPercentage?: number,
        autoTrackPageVisitTime?: boolean,
        disableAjaxTracking?: boolean,
        overridePageViewDuration?: boolean,
        maxAjaxCallsPerView?: number,
        disableDataLossAnalysis?: boolean,
        disableCorrelationHeaders?: boolean,
        disableFlushOnBeforeUnload?: boolean,
        enableSessionStorageBuffer?: boolean,
        cookieDomain?: string,
        url?: string
}

declare interface AtomCore$IKeymapManager {
    defaultTarget: HTMLElement
}

declare interface AtomCore$IPackage {
    mainModulePath: string,
        mainModule: any,
        enable(): void,
        disable(): void,
        isTheme(): boolean,
        getType(): string,
        getStylesheetType(): string,
        load(): AtomCore$IPackage,
        reset(): void,
        activate(): Q.Promise<any[]>,
        activateNow(): void
}

declare type AtomCore$IPackageManager = {
    packageDirPaths: string[],
    loadedPackages: any,
    activePackages: any,
    packageStates: any,
    packageActivators: any[],
    getApmPath(): string,
    getPackageDirPaths(): string,
    getPackageState(name: string): any,
    setPackageState(name: string, state: any): void,
    enablePackage(name: string): any,
    disablePackage(name: string): any,
    activate(): void,
    registerPackageActivator(activator: any, types: any): void,
    activatePackages(packages: any): void,
    activatePackage(name: string): Q.Promise<AtomCore$IPackage>,
    deactivatePackages(): void,
    deactivatePackage(name: string): void,
    getActivePackages(): any,
    getActivePackage(name: string): any,
    isPackageActive(name: string): boolean,
    unobserveDisabledPackages(): void,
    observeDisabledPackages(): void,
    loadPackages(): void,
    loadPackage(nameOrPath: string): void,
    unloadPackages(): void,
    unloadPackage(name: string): void,
    getLoadedPackage(name: string): any,
    isPackageLoaded(name: string): boolean,
    getLoadedPackages(): any,
    getLoadedPackagesForTypes(types: any): any[],
    resolvePackagePath(name: string): string,
    isPackageDisabled(name: string): boolean,
    hasAtomEngine(packagePath: string): boolean,
    isBundledPackage(name: string): boolean,
    getPackageDependencies(): any,
    getAvailablePackagePaths(): any[],
    getAvailablePackageNames(): any[],
    getAvailablePackageMetadata(): any[]
}

declare interface AtomCore$INotifications {
    addInfo: Function,
        addError: Function,
        addSuccess: Function,
        addWarning: Function
}

declare interface AtomCore$IThemeManager {}

declare interface AtomCore$IContextMenuManager {}

declare interface AtomCore$IMenuManager {}

declare interface AtomCore$IClipboard {
    write(text: string, metadata?: any): any,
        read(): string
}

declare interface AtomCore$ISyntax {}

declare interface AtomCore$IWindowEventHandler {}

declare type AtomCore$IAtomStatic = {
    version: number,
    loadSettings: AtomCore$IAtomSettings,
    loadOrCreate(mode: "editor"): AtomCore$IAtom,
    loadOrCreate(mode: "spec"): AtomCore$IAtom,
    loadOrCreate(mode: string): AtomCore$IAtom,
    loadState(mode: any): void,
    getStatePath(mode: any): string,
    getConfigDirPath(): string,
    getStorageDirPath(): string,
    getLoadSettings(): AtomCore$IAtomSettings,
    getCurrentWindow(): AtomCore$IBrowserWindow,
    getVersion(): string,
    isReleasedVersion(): boolean,
    new(state: AtomCore$IAtomState): AtomCore$IAtom
} & AtomCore$ISerializationStatic


declare class Disposable {
    constructor(disposalAction: any): this;
    dispose(): void
}

declare interface AtomCore$IAtom {
    constructor: AtomCore$IAtomStatic,
        state: AtomCore$IAtomState,
        mode: string,
        deserializers: AtomCore$IDeserializerManager,
        config: AtomCore$IConfig,
        commands: AtomCore$ICommandRegistry,
        grammars: AtomCore$IGrammars,
        keymaps: AtomCore$IKeymapManager,
        keymap: AtomCore$IKeymapManager,
        packages: AtomCore$IPackageManager,
        themes: AtomCore$IThemeManager,
        contextManu: AtomCore$IContextMenuManager,
        menu: AtomCore$IMenuManager,
        notifications: AtomCore$INotifications,
        clipboard: AtomCore$IClipboard,
        syntax: AtomCore$ISyntax,
        views: AtomCore$IViewRegistry,
        windowEventHandler: AtomCore$IWindowEventHandler,
        subscribe: Function,
        unsubscribe: Function,
        loadTime: number,
        workspaceViewParentSelector: string,
        project: AtomCore$IProject,
        workspaceView: AtomCore$IWorkspaceView,
        workspace: AtomCore$IWorkspace,
        initialize: Function,
        setBodyPlatformClass: Function,
        getCurrentWindow(): AtomCore$IBrowserWindow,
        getWindowDimensions: Function,
        setWindowDimensions: Function,
        restoreWindowDimensions: Function,
        storeWindowDimensions: Function,
        getLoadSettings: Function,
        deserializeProject: Function,
        deserializeWorkspaceView: Function,
        deserializePackageStates: Function,
        deserializeEditorWindow: Function,
        startEditorWindow: Function,
        unloadEditorWindow: Function,
        loadThemes: Function,
        watchThemes: Function,
        open: Function,
        confirm: Function,
        showSaveDialog: Function,
        showSaveDialogSync: Function,
        openDevTools: Function,
        toggleDevTools: Function,
        executeJavaScriptInDevTools: Function,
        reload: Function,
        focus: Function,
        show: Function,
        hide: Function,
        setSize: Function,
        setPosition: Function,
        center: Function,
        displayWindow: Function,
        close: Function,
        exit: Function,
        inDevMode: Function,
        inSpecMode: Function,
        toggleFullScreen: Function,
        setFullScreen: Function,
        isFullScreen: Function,
        getVersion: Function,
        isReleasedVersion: Function,
        getGitHubAuthTokenName: Function,
        setGitHubAuthToken: Function,
        getGitHubAuthToken: Function,
        getConfigDirPath: Function,
        saveSync: Function,
        getWindowLoadTime(): number,
        crashMainProcess: Function,
        crashRenderProcess: Function,
        beep: Function,
        getUserInitScriptPath: Function,
        requireUserInitScript: Function,
        requireWithGlobals: Function,
        services: any
}

declare interface AtomCore$IBufferedNodeProcessStatic {
    new(arg: any): AtomCore$IBufferedNodeProcess
}

declare type AtomCore$IBufferedNodeProcess = {} & AtomCore$IBufferedProcess


declare interface AtomCore$IBufferedProcessStatic {
    new(arg: any): AtomCore$IBufferedProcess
}

declare interface AtomCore$IBufferedProcess {
    process: Function,
        killed: boolean,
        bufferStream: Function,
        kill: Function
}

declare interface AtomCore$IGitStatic {
    new(path: any, options: any): AtomCore$IGit
}

declare interface AtomCore$IGit {}

declare interface AtomCore$ITokenizedBuffer {}

declare interface AtomCore$ITokenizedLine {}

declare interface AtomCore$IToken {}

declare interface AtomCore$IFoldStatic {
    new(
        displayBuffer: AtomCore$IDisplayBuffer,
        marker: AtomCore$IMarker): AtomCore$IFold
}

declare interface AtomCore$IFold {
    id: number,
        displayBuffer: AtomCore$IDisplayBuffer,
        marker: AtomCore$IMarker
}

declare interface AtomCore$IDisplayBufferMarkerStatic {
    new(
        _arg: {
            bufferMarker: AtomCore$IMarker,
            displayBuffer: AtomCore$IDisplayBuffer
        }): AtomCore$IDisplayBufferMarker
}

declare type AtomCore$IDisplayBufferMarker = {
        constructor: AtomCore$IDisplayBufferMarkerStatic,
        id: number,
        bufferMarkerSubscription: any,
        oldHeadBufferPosition: TextBuffer.IPoint,
        oldHeadScreenPosition: TextBuffer.IPoint,
        oldTailBufferPosition: TextBuffer.IPoint,
        oldTailScreenPosition: TextBuffer.IPoint,
        wasValid: boolean,
        bufferMarker: AtomCore$IMarker,
        displayBuffer: AtomCore$IDisplayBuffer,
        globalPauseCount: number,
        globalQueuedEvents: any,
        subscriptions: Emissary.ISubscription[],
        subscriptionsByObject: any,
        copy(attributes?: any): AtomCore$IDisplayBufferMarker,
        getScreenRange(): TextBuffer.IRange,
        setScreenRange(screenRange: any, options: any): any,
        getBufferRange(): TextBuffer.IRange,
        setBufferRange(bufferRange: any, options: any): any,
        getPixelRange(): any,
        getHeadScreenPosition(): TextBuffer.IPoint,
        setHeadScreenPosition(screenPosition: any, options: any): any,
        getHeadBufferPosition(): TextBuffer.IPoint,
        setHeadBufferPosition(bufferPosition: any): any,
        getTailScreenPosition(): TextBuffer.IPoint,
        setTailScreenPosition(screenPosition: any, options: any): any,
        getTailBufferPosition(): TextBuffer.IPoint,
        setTailBufferPosition(bufferPosition: any): any,
        plantTail(): boolean,
        clearTail(): boolean,
        hasTail(): boolean,
        isReversed(): boolean,
        isValid(): boolean,
        isDestroyed(): boolean,
        getAttributes(): any,
        setAttributes(attributes: any): any,
        matchesAttributes(attributes: any): any,
        destroy(): any,
        isEqual(other: AtomCore$IDisplayBufferMarker): boolean,
        compare(other: AtomCore$IDisplayBufferMarker): boolean,
        inspect(): string,
        destroyed(): any,
        notifyObservers(_arg: any): any
    } & &


    declare interface AtomCore$ITransaction {}

declare type AtomCore$IMarker = {}

declare interface AtomCore$ITaskStatic {
    new(taskPath: any): AtomCore$ITask
}

declare interface AtomCore$ITask {}
declare var atom: AtomCore$IAtom;
declare module 'atom' {
    declare     var $: typeof undefined;
    declare     var $$: typeof undefined;
    declare     var $$$: typeof undefined;
    declare     var BufferedNodeProcess: AtomCore$IBufferedNodeProcessStatic;
    declare     var BufferedProcess: AtomCore$IBufferedProcessStatic;
    declare     var Git: AtomCore$IGitStatic;
    declare     var Point: TextBuffer.IPointStatic;
    declare     var Range: TextBuffer.IRangeStatic;
    declare class View mixins spacePen.View, Emissary.ISubscriber {
        subscribeWith(eventEmitter: any, methodName: string, args: any): any;
        addSubscription(subscription: any): any;
        subscribe(eventEmitterOrSubscription: any, ...args: any[]): any;
        subscribeToCommand(eventEmitter: any, ...args: any[]): any;
        unsubscribe(object?: any): any
    }
    declare class EditorView mixins View {
        characterWidthCache: any;
        configDefaults: any;
        nextEditorId: number;
        content(params: any): void;
        classes(_arg?: {
            mini?: any
        }): string;
        vScrollMargin: number;
        hScrollMargin: number;
        lineHeight: any;
        charWidth: any;
        charHeight: any;
        cursorViews: any[];
        selectionViews: any[];
        lineCache: any[];
        isFocused: any;
        editor: AtomCore$IEditor;
        attached: any;
        lineOverdraw: number;
        pendingChanges: any[];
        newCursors: any[];
        newSelections: any[];
        redrawOnReattach: any;
        bottomPaddingInLines: number;
        active: boolean;
        id: number;
        gutter: AtomCore$IGutterView;
        overlayer: JQuery;
        scrollView: JQuery;
        renderedLines: JQuery;
        underlayer: JQuery;
        hiddenInput: JQuery;
        verticalScrollbar: JQuery;
        verticalScrollbarContent: JQuery;
        constructor(editor: AtomCore$IEditor): this;
        initialize(editorOrOptions: AtomCore$IEditor): void;
        initialize(
            editorOrOptions?: {
                editor: AtomCore$IEditor,
                mini: any,
                placeholderText: any
            }): void;
        initialize(editorOrOptions: {}): void;
        bindKeys(): void;
        getEditor(): AtomCore$IEditor;
        getText(): string;
        setText(text: string): void;
        insertText(text: string, options?: any): TextBuffer.IRange[];
        setHeightInLines(heightInLines: number): number;
        setWidthInChars(widthInChars: number): number;
        pageDown(): void;
        pageUp(): void;
        getPageRows(): number;
        setShowInvisibles(showInvisibles: boolean): void;
        setInvisibles(invisibles: {
            eol: string,
            space: string,
            tab: string,
            cr: string
        }): void;
        setShowIndentGuide(showIndentGuide: boolean): void;
        setPlaceholderText(placeholderText: string): void;
        getPlaceholderText(): string;
        checkoutHead(): boolean;
        configure(): Emissary.ISubscription;
        handleEvents(): void;
        handleInputEvents(): void;
        bringHiddenInputIntoView(): JQuery;
        selectOnMousemoveUntilMouseup(): any;
        afterAttach(onDom: any): any;
        edit(editor: AtomCore$IEditor): any;
        getModel(): AtomCore$IEditor;
        setModel(editor: AtomCore$IEditor): any;
        showBufferConflictAlert(editor: AtomCore$IEditor): any;
        scrollTop(scrollTop: number, options?: any): any;
        scrollBottom(scrollBottom?: number): any;
        scrollLeft(scrollLeft?: number): number;
        scrollRight(scrollRight?: number): any;
        scrollToBottom(): any;
        scrollToCursorPosition(): any;
        scrollToBufferPosition(bufferPosition: any, options: any): any;
        scrollToScreenPosition(screenPosition: any, options: any): any;
        scrollToPixelPosition(pixelPosition: any, options: any): any;
        highlightFoldsContainingBufferRange(bufferRange: any): any;
        saveScrollPositionForEditor(): any;
        toggleSoftTabs(): any;
        toggleSoftWrap(): any;
        calculateWidthInChars(): number;
        calculateHeightInLines(): number;
        getScrollbarWidth(): number;
        setSoftWrap(softWrap: boolean): any;
        setFontSize(fontSize: number): any;
        getFontSize(): number;
        setFontFamily(fontFamily?: string): any;
        getFontFamily(): string;
        setLineHeight(lineHeight: number): any;
        redraw(): any;
        splitLeft(): any;
        splitRight(): any;
        splitUp(): any;
        splitDown(): any;
        getPane(): any;
        remove(selector: any, keepData: any): any;
        beforeRemove(): any;
        getCursorView(index?: number): any;
        getCursorViews(): any[];
        addCursorView(cursor: any, options: any): any;
        removeCursorView(cursorView: any): any;
        getSelectionView(index?: number): any;
        getSelectionViews(): any[];
        addSelectionView(selection: any): any;
        removeSelectionView(selectionView: any): any;
        removeAllCursorAndSelectionViews(): any[];
        appendToLinesView(view: any): any;
        scrollVertically(pixelPosition: any, _arg: any): any;
        scrollHorizontally(pixelPosition: any): any;
        calculateDimensions(): number;
        recalculateDimensions(): any;
        updateLayerDimensions(): any;
        isHidden(): boolean;
        clearRenderedLines(): void;
        resetDisplay(): any;
        requestDisplayUpdate(): any;
        updateDisplay(options?: any): any;
        updateCursorViews(): any;
        shouldUpdateCursor(cursorView: any): any;
        updateSelectionViews(): any[];
        shouldUpdateSelection(selectionView: any): any;
        syncCursorAnimations(): any[];
        autoscroll(suppressAutoscroll?: any): any[];
        updatePlaceholderText(): any;
        updateRenderedLines(scrollViewWidth: any): any;
        computeSurroundingEmptyLineChanges(change: any): any;
        computeIntactRanges(renderFrom: any, renderTo: any): any;
        truncateIntactRanges(intactRanges: any, renderFrom: any, renderTo: any): any;
        clearDirtyRanges(intactRanges: any): any;
        clearLine(lineElement: any): any;
        fillDirtyRanges(intactRanges: any, renderFrom: any, renderTo: any): any;
        updatePaddingOfRenderedLines(): any;
        getFirstVisibleScreenRow(): number;
        getLastVisibleScreenRow(): number;
        isScreenRowVisible(): boolean;
        handleScreenLinesChange(change: any): any;
        buildLineElementForScreenRow(screenRow: any): any;
        buildLineElementsForScreenRows(startRow: any, endRow: any): any;
        htmlForScreenRows(startRow: any, endRow: any): any;
        htmlForScreenLine(screenLine: any, screenRow: any): any;
        buildIndentation(screenRow: any, editor: any): any;
        buildHtmlEndOfLineInvisibles(screenLine: any): any;
        getEndOfLineInvisibles(screenLine: any): any;
        lineElementForScreenRow(screenRow: any): any;
        toggleLineCommentsInSelection(): any;
        pixelPositionForBufferPosition(position: any): any;
        pixelPositionForScreenPosition(position: any): any;
        positionLeftForLineAndColumn(lineElement: any, screenRow: any, screenColumn: any): any;
        measureToColumn(lineElement: any, tokenizedLine: any, screenColumn: any): any;
        getCharacterWidthCache(scopes: any, char: any): any;
        setCharacterWidthCache(scopes: any, char: any, val: any): any;
        clearCharacterWidthCache(): any;
        pixelOffsetForScreenPosition(position: any): any;
        screenPositionFromMouseEvent(e: any): any;
        highlightCursorLine(): any;
        copyPathToClipboard(): any;
        buildLineHtml(_arg: any): any;
        updateScopeStack(line: any, scopeStack: any, desiredScopes: any): any;
        pushScope(line: any, scopeStack: any, scope: any): any;
        popScope(line: any, scopeStack: any): any;
        buildEmptyLineHtml(
            showIndentGuide: any,
            eolInvisibles: any,
            htmlEolInvisibles: any,
            indentation: any,
            editor: any,
            mini: any): any;
        replaceSelectedText(replaceFn: (str: string) => string): any;
        consolidateSelections(e: any): any;
        logCursorScope(): any;
        logScreenLines(start: any, end: any): any;
        logRenderedLines(): any
    }
    declare class ScrollView mixins View {}
    declare interface ISelectListItem {

        /**
         * e.g. application:about 
         */
        eventName: string,

            /**
             * e.g. Application: About 
             */
            eventDescription: string
    }
    declare class SelectListView mixins View {
        content(): any;
        maxItems: number;
        scheduleTimeout: any;
        inputThrottle: number;
        cancelling: boolean;
        items: any[];
        list: JQuery;
        filterEditorView: JQuery;
        previouslyFocusedElement: JQuery;
        initialize(): any;
        schedulePopulateList(): number;
        setItems(items: any[]): any;
        setError(message?: string): any;
        setLoading(message?: string): any;
        getFilterQuery(): string;
        populateList(): any;
        getEmptyMessage(itemCount?: any, filteredItemCount?: any): string;
        setMaxItems(maxItems: number): void;
        selectPreviousItemView(): any;
        selectNextItemView(): any;
        selectItemView(view: any): any;
        scrollToItemView(view: any): any;
        getSelectedItemView(): any;
        getSelectedItem(): any;
        confirmSelection(): any;
        viewForItem(item: any): JQuery | string | HTMLElement | View;
        confirmed(item: any): any;
        getFilterKey(): any;
        focusFilterEditor(): any;
        storeFocusedElement(): any;
        restoreFocus(): any;
        cancelled(): any;
        cancel(): any
    }
    declare     var WorkspaceView: AtomCore$IWorkspaceViewStatic;
    declare     var Task: AtomCore$ITaskStatic;
    declare     var Workspace: AtomCore$IWorkspaceStatic;
}
declare module 'atpl' {
    declare     export function compile(templateString: string, options: any): (context: any) => string
    declare     export function ___express(filename: string, options: any, callback: Function): any
    declare     export function registerExtension(items: any): void
    declare     export function registerTags(items: any): void
    declare     export function registerFunctions(items: any): void
    declare     export function registerFilters(items: any): void
    declare     export function registerTests(items: any): void
    declare     export function renderFileSync(viewsPath: string, filename: string, parameters: any, cache: boolean): string
    declare     export function renderFile(
        viewsPath: string,
        filename: string,
        parameters: any,
        cache: boolean,
        done: (err: error$Error, result?: string) => void): void
}
declare module 'angular' {
    declare interface IDeferredBootstrapperStatic {
        bootstrap(configParam: IConfigParam): ng$IPromise<boolean >
    }
    declare interface IConfigParam {
        element?: CSG$Node,
            module?: string,
            resolve: any
    }
    declare interface IPromise<T>{

        /**
         * This method can be used as a replacement for then. Similarly, it takes two parameters, a callback when all promises are resolved and a callback for failure. The resolve callback is going to be called with the result of the list of promises passed to $q.all as separate parameters instead of one parameters which is an array.
         *  
         * @param successCallback Callback for resolved promise, similar to then's one, but takes multiple parameters instead of single array parameter
         * @param errorCallback Callback for error, the same as for then
         */
        spread<TResult>(
            successCallback: (...promiseValues: any[]) => AV$IPromise<TResult>| TResult,
            errorCallback?: (reason: any) => any): AV$IPromise<TResult >
    }
    declare interface IModule {
        animation(name: string, animationFactory: undefined.IAnimateFactory): angular$IModule,
            animation(name: string, inlineAnnotatedFunction: any[]): angular$IModule,
            animation(object: AV$Object): angular$IModule
    }
    declare module.exports: typeof angular
    declare     export interface IAngularStatic {
        scenario: any
    }
    declare interface IInjectStatic {
        (...fns: Function[]): any,
        (...inlineAnnotatedConstructor: any[]): any,
        strictDi(val?: boolean): void
    }
    declare interface IMockStatic {
        dump(obj: any): string,
            inject: angular$IInjectStatic,
            module: {
                (...modules: any[]): any,
                sharedInjector(): void
            },
            TzDate(offset: number, timestamp: number): Date,
            TzDate(offset: number, timestamp: string): Date
    }
    declare type IExceptionHandlerProvider = {
        mode(mode: string): void
    } & angular$IServiceProvider

    declare interface ITimeoutService {
        flush(delay?: number): void,
            flushNext(expectedDelay?: number): void,
            verifyNoPendingTasks(): void
    }
    declare interface IIntervalService {
        flush(millis?: number): number
    }
    declare interface ILogService {
        assertEmpty(): void,
            reset(): void
    }
    declare interface ILogCall {
        logs: string[]
    }
    declare interface IHttpBackendService {

        /**
         * Flushes all pending requests using the trained responses.
         * @param count Number of responses to flush (in the order they arrived). If undefined, all pending requests will be flushed.
         */
        flush(count?: number): void,

            /**
             * Resets all request expectations, but preserves all backend definitions.
             */
            resetExpectations(): void,

            /**
             * Verifies that all of the requests defined via the expect api were made. If any of the requests were not made, verifyNoOutstandingExpectation throws an exception.
             */
            verifyNoOutstandingExpectation(): void,

            /**
             * Verifies that there are no outstanding requests that need to be flushed.
             */
            verifyNoOutstandingRequest(): void,

            /**
             * Creates a new request expectation.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param method HTTP method.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expect(
                method: string,
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for DELETE requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url is as expected.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectDELETE(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for GET requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectGET(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for HEAD requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object to be compared with the HTTP headers in the request.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectHEAD(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for JSONP requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectJSONP(
                url: string | RegExp | ((url: string) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for PATCH requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPATCH(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for POST requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPOST(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new request expectation for PUT requests.
             * Throws a preformatted error if expectation(s) don't match supplied string, regular expression, object, or if function returns false.
            Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
            */
            expectPUT(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object,
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param method HTTP method.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            when(
                method: string,
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for DELETE requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenDELETE(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for GET requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in request url described above
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenGET(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for HEAD requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenHEAD(
                url: string | RegExp | ((url: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for JSONP requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenJSONP(
                url: string | RegExp | ((url: string) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for PATCH requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPATCH(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for POST requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPOST(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler,

            /**
             * Creates a new backend definition for PUT requests.
             * Returns an object with respond method that controls how a matched request is handled.
             * @param url HTTP url string, regular expression or function that receives a url and returns true if the url matches the current expctation.
             * @param data HTTP request body string, json object, regular expression or function that receives the data and returns true if the data matches the current expectation.
             * @param headers HTTP headers object or function that receives the headers and returns true if the headers match the current expectation.
             * @param keys Array of keys to assign to regex matches in the request url.
             */
            whenPUT(
                url: string | RegExp | ((url: string) => boolean),
                data?: string | RegExp | AV$Object | ((data: string) => boolean),
                headers?: AV$Object | ((object: AV$Object) => boolean),
                keys?: AV$Object[]): mock.IRequestHandler
    }
    declare module 'mock' {
        declare interface IRequestHandler {

            /**
             * Controls the response for a matched request using a function to construct the response.
             * Returns the RequestHandler object for possible overrides.
             * @param func Function that receives the request HTTP method, url, data, headers, and an array of keys to regex matches in the request url and returns an array containing response status (number), data, headers, and status text.
             */
            respond(
                    func: ((
                        method: string,
                        url: string,
                        data: string | AV$Object,
                        headers: AV$Object,
                        params?: any) => [number, string | AV$Object, AV$Object, string])): IRequestHandler,

                /**
                 * Controls the response for a matched request using supplied static data to construct the response.
                 * Returns the RequestHandler object for possible overrides.
                 * @param status HTTP status code to add to the response.
                 * @param data Data to add to the response.
                 * @param headers Headers object to add to the response.
                 * @param responseText Response text to add to the response.
                 */
                respond(
                    status: number,
                    data: string | AV$Object,
                    headers?: AV$Object,
                    responseText?: string): IRequestHandler,

                /**
                 * Controls the response for a matched request using the HTTP status code 200 and supplied static data to construct the response.
                 * Returns the RequestHandler object for possible overrides.
                 * @param data Data to add to the response.
                 * @param headers Headers object to add to the response.
                 * @param responseText Response text to add to the response.
                 */
                respond(
                    data: string | AV$Object,
                    headers?: AV$Object,
                    responseText?: string): IRequestHandler,

                /**
                 * Any request matching a backend definition or expectation with passThrough handler will be passed through to the real backend (an XHR request will be made to the server.)
                 */
                passThrough(): IRequestHandler
        }
    }

    declare interface IAuth0ClientOptions {

        /**
         * Login url if you're using ngRoute
         */
        loginUrl?: string,

            /**
             * Login state if you're using ui-router
             */
            loginState?: string,

            /**
             * Client identifier of your Auth0 application
             */
            clientID: string,

            /**
             * Domain of your Auth0 account
             */
            domain: string,

            /**
             * Use single signon
             */
            sso?: boolean
    }
    declare interface ITokenOptions {
        targetClientId?: string,
            api?: string
    }
    declare interface IAuth0Options {

        /**
         * Connection name
         */
        connection?: string,

            /**
             * Username
             */
            username?: string,

            /**
             * Email address
             */
            email?: string
    }
    declare interface ISuccessCallback {
        (profile?: string, idToken?: string, accessToken?: string, state?: string, refreshToken?: string): void
    }
    declare interface IErrorCallback {
        (error: any): void
    }
    declare interface IAuth0Service {

        /**
         * Hooks to internal Angular events so that a user will be redirected to the login page if trying to visit a restricted resource
         */
        hookEvents(): void,

            /**
             * Performs a token delegation request exchanging th ecurrent token for another one.
             * @param options Token options
             */
            getToken(options?: ITokenOptions): ng$IPromise<any>,

            /**
             * Refreshes the Id token
             * @param refreshToken Refresh token to use when renewing
             */
            refreshIdToken(refreshToken: string): ng$IPromise<any>,

            /**
             * Renews the Id Token with the same scopes as the original token
             * @param id_token Id Token
             */
            renewIdToken(id_token: string): ng$IPromise<any>,

            /**
             * Logs in a user, returning tokens and profile information
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful login
             * @param errorCallback Callback on failed login
             */
            signin(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Displays Lock in signup mode, and logs the user in immediately after a successful signup.
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful signup
             * @param errorCallback Callback on failed signup
             */
            signup(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Performs the "forgot your password" flow.
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful reset
             * @param errorCallback Callback on failed reset
             */
            reset(
                options?: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Validates the user
             * @param options Options to bypass displaying the Lock UI
             * @param successCallback Callback on successful validation
             * @param errorCallback Callback on failed validation
             */
            validateUser(
                options: IAuth0Options,
                successCallback?: ISuccessCallback,
                errorCallback?: IErrorCallback): void,

            /**
             * Logs the user out locally by deleting their token from local storage.
             */
            signout(): void,

            /**
             * Reauthenticates the user by using a stored profile and token without going through the login flow.
             * @param profile Profile of the user
             * @param idToken Id token
             * @param accessToken Access token
             * @param state State
             * @param refreshToken Flag to indicate refreshing the token
             */
            authenticate(
                profile?: any,
                idToken?: string,
                accessToken?: string,
                state?: any,
                refreshToken?: boolean): ng$IPromise<any>,

            /**
             * Gets the user's profile
             * @param idToken Id token
             */
            getProfile(idToken?: string): ng$IPromise<any>,
            accessToken: string,
            idToken: string,
            profile: any,
            isAuthenticated: boolean,
            config: any
    }
    declare interface IAuth0ServiceProvider {

        /**
         * Configures the auth service
         * @param options Client options passed into Auth0
         */
        init(options: IAuth0ClientOptions): void,

            /**
             * 
             * @param event Name of the event to handle.
             * @param handler Event handler
             */
            on(event: string, handler: (...args: any[]) => any): void
    }
}

/**
 * This is the interface for the main Auth0 client. 
 */
declare interface Auth0Static {
    new(options: Auth0ClientOptions): Auth0Static,
    changePassword(options: any, callback?: Function): void,
        decodeJwt(jwt: string): any,
        login(
            options: any,
            callback: (
                error?: Auth0Error,
                profile?: Auth0UserProfile,
                id_token?: string,
                access_token?: string,
                state?: string) => any): void,
        loginWithPopup(
            options: Auth0LoginOptions,
            callback: (
                error?: Auth0Error,
                profile?: Auth0UserProfile,
                id_token?: string,
                access_token?: string,
                state?: string) => any): void,
        loginWithResourceOwner(
            options: Auth0LoginOptions,
            callback: (
                error?: Auth0Error,
                profile?: Auth0UserProfile,
                id_token?: string,
                access_token?: string,
                state?: any) => any): void,
        loginWithUsernamePassword(
            options: Auth0LoginOptions,
            callback: (
                error?: Auth0Error,
                profile?: Auth0UserProfile,
                id_token?: string,
                access_token?: string,
                state?: string) => any): void,
        logout(query: string): void,
        getConnections(callback?: Function): void,
        refreshToken(
            refreshToken: string,
            callback: (error?: Auth0Error, delegationResult?: Auth0DelegationToken) => any): void,
        getDelegationToken(
            targetClientId: string,
            id_token: string,
            options: any,
            callback: (error?: Auth0Error, delegationResult?: Auth0DelegationToken) => any): void,
        getProfile(id_token: string, callback?: Function): Auth0UserProfile,
        getSSOData(withActiveDirectories: any, callback?: Function): void,
        parseHash(hash: string): Auth0DecodedHash,
        signup(options: Auth0SignupOptions, callback: Function): void,
        validateUser(options: any, callback: (error?: Auth0Error, valid?: any) => any): void
}
/**
 * Represents constructor options for the Auth0 client. 
 */
declare interface Auth0ClientOptions {
    clientID: string,
        callbackURL: string,
        callbackOnLocationHash?: boolean,
        domain: string,
        forceJSONP?: boolean
}
/**
 * Represents a normalized UserProfile. 
 */
declare interface Auth0UserProfile {
    email: string,
        email_verified: boolean,
        family_name: string,
        gender: string,
        given_name: string,
        locale: string,
        name: string,
        nickname: string,
        picture: string,
        user_id: string,

        /**
         * Represents one or more Identities that may be associated with the User. 
         */
        identities: Auth0Identity[],
        user_metadata?: any,
        app_metadata?: any
}
/**
 * Represents an Auth0UserProfile that has a Microsoft Account as the primary identity. 
 */
declare type MicrosoftUserProfile = {
    emails: string[]
} & Auth0UserProfile

/**
 * Represents an Auth0UserProfile that has an Office365 account as the primary identity. 
 */
declare type Office365UserProfile = {
    tenantid: string,
    upn: string
} & Auth0UserProfile

/**
 * Represents an Auth0UserProfile that has an Active Directory account as the primary identity. 
 */
declare type AdfsUserProfile = {
    issuer: string
} & Auth0UserProfile

/**
 * Represents multiple identities assigned to a user. 
 */
declare interface Auth0Identity {
    access_token: string,
        connection: string,
        isSocial: boolean,
        provider: string,
        user_id: string
}
declare interface Auth0DecodedHash {
    access_token: string,
        id_token: string,
        profile: Auth0UserProfile,
        state: any
}
declare interface Auth0PopupOptions {
    width: number,
        height: number
}
declare interface Auth0LoginOptions {
    auto_login?: boolean,
        connection?: string,
        email?: string,
        username?: string,
        password?: string,
        popup?: boolean,
        popupOptions?: Auth0PopupOptions
}
declare type Auth0SignupOptions = {
    auto_login: boolean
} & Auth0LoginOptions
declare interface Auth0Error {
    code: any,
        details: any,
        name: string,
        message: string,
        status: any
}
/**
 * Represents the response from an API Token Delegation request. 
 */
declare interface Auth0DelegationToken {

    /**
     * The length of time in seconds the token is valid for. 
     */
    expires_in: string,

        /**
         * The JWT for delegated access.  
         */
        id_token: string,

        /**
         * The type of token being returned. Possible values: "Bearer"  
         */
        token_type: string
}
declare var Auth0: Auth0Static;
declare module 'auth0-js' {
    declare module.exports: typeof Auth0
}
declare interface Auth0LockAdditionalSignUpFieldOption {
    value: string,
        label: string
}
declare type Auth0LockAdditionalSignUpFieldOptionsCallback = (error: Auth0Error, options: Auth0LockAdditionalSignUpFieldOption[]) => void;
declare type Auth0LockAdditionalSignUpFieldOptionsFunction = (callback: Auth0LockAdditionalSignUpFieldOptionsCallback) => void;
declare type Auth0LockAdditionalSignUpFieldPrefillCallback = (error: Auth0Error, prefill: string) => void;
declare type Auth0LockAdditionalSignUpFieldPrefillFunction = (callback: Auth0LockAdditionalSignUpFieldPrefillCallback) => void;
declare interface Auth0LockAdditionalSignUpField {
    icon?: string,
        name: string,
        options?: Auth0LockAdditionalSignUpFieldOption[] | Auth0LockAdditionalSignUpFieldOptionsFunction,
        placeholder: string,
        prefill?: string | Auth0LockAdditionalSignUpFieldPrefillFunction,
        type?: "select" | "text",
        validator?: (input: string) => {
            valid: boolean,
            hint?: string
        }
}
declare type Auth0LockAvatarUrlCallback = (error: Auth0Error, url: string) => void;
declare type Auth0LockAvatarDisplayNameCallback = (error: Auth0Error, displayName: string) => void;
declare interface Auth0LockAvatarOptions {
    url: (email: string, callback: Auth0LockAvatarUrlCallback) => void,
        displayName: (email: string, callback: Auth0LockAvatarDisplayNameCallback) => void
}
declare interface Auth0LockThemeOptions {
    logo?: string,
        primaryColor?: string
}
declare interface Auth0LockAuthParamsOptions {
    access_token?: any,
        connection_scopes?: any,
        device?: any,
        nonce?: any,
        protocol?: any,
        request_id?: any,
        scope?: string,
        state?: string
}
declare interface Auth0LockAuthOptions {
    params?: Auth0LockAuthParamsOptions,
        redirect?: boolean,
        redirectUrl?: string,
        responseType?: string,
        sso?: boolean
}
declare interface Auth0LockPopupOptions {
    width: number,
        height: number,
        left: number,
        top: number
}
declare interface Auth0LockConstructorOptions {
    additionalSignUpFields?: Auth0LockAdditionalSignUpField[],
        allowedConnections?: string[],
        allowForgotPassword?: boolean,
        allowLogin?: boolean,
        allowSignUp?: boolean,
        assetsUrl?: string,
        auth?: Auth0LockAuthOptions,
        autoclose?: boolean,
        autofocus?: boolean,
        avatar?: Auth0LockAvatarOptions,
        closable?: boolean,
        container?: string,
        defaultADUsernameFromEmailPrefix?: string,
        defaultDatabaseConnection?: string,
        defaultEnterpriseConnection?: string,
        forgotPasswordLink?: string,
        initialScreen?: "login" | "signUp" | "forgotPassword",
        language?: string,
        languageDictionary?: any,
        loginAfterSignUp?: boolean,
        mustAcceptTerms?: boolean,
        popupOptions?: Auth0LockPopupOptions,
        prefill?: {
            email?: string,
            username?: string
        },
        rememberLastLogin?: boolean,
        signupLink?: string,
        socialButtonStyle?: "big" | "small",
        theme?: Auth0LockThemeOptions,
        usernameStyle?: string
}
declare interface Auth0LockStatic {
    new(
        clientId: string,
        domain: string,
        options?: Auth0LockConstructorOptions): Auth0LockStatic,
    getProfile(
            token: string,
            callback: (error: Auth0Error, profile: Auth0UserProfile) => void): void,
        show(): void,
        hide(): void,
        logout(query: any): void,
        on(event: "show", callback: () => void): void,
        on(event: "hide", callback: () => void): void,
        on(event: "unrecoverable_error", callback: (error: Auth0Error) => void): void,
        on(event: "authorization_error", callback: (error: Auth0Error) => void): void,
        on(event: "authenticated", callback: (authResult: any) => void): void,
        on(event: string, callback: (...args: any[]) => void): void
}
declare var Auth0Lock: Auth0LockStatic;
declare module 'auth0-lock' {
    declare module.exports: typeof Auth0Lock
}
declare interface Auth0WidgetStatic {
    new(params: Auth0Constructor): Auth0WidgetStatic,
    getClient(): Auth0Static,
        getProfile(token: string, callback: Function): Auth0UserProfile,
        parseHash(hash: string): Auth0DecodedHash,
        reset(options: Auth0Options, callback?: Function): Auth0WidgetStatic,
        signin(
            options: Auth0Options,
            widgetLoadedCallback?: Function,
            popupCallback?: Function): Auth0WidgetStatic,
        signup(
            options: Auth0Options,
            callback: (
                error?: Auth0Error,
                profile?: Auth0UserProfile,
                id_token?: string,
                access_token?: string,
                state?: string) => any): Auth0WidgetStatic
}
declare type Auth0Constructor = {
    assetsUrl?: string,
    cdn?: string,
    dict?: any
} & Auth0ClientOptions
declare interface Auth0Options {
    access_token?: string,
        connections?: string[],
        container?: string,
        enableReturnUserExperience?: boolean,
        extraParameters?: any,
        icon?: string,
        protocol?: string,
        request_id?: string,
        scope?: string,
        showIcon?: boolean,
        showForgot?: boolean,
        showSignup?: boolean,
        state?: any,
        userPwdConnectionName?: string,
        username_style?: string
}
declare var Auth0Widget: Auth0WidgetStatic;
declare module 'Auth0Widget' {
    declare module.exports: typeof Auth0Widget
}
declare module 'auth0' {

    declare     export interface ManagementClientOptions {
        token: string,
            domain?: string
    }
    declare     export interface UserData {
        connection: string,
            email?: string,
            username?: string,
            password?: string,
            phone_number?: string,
            user_metadata?: {},
            email_verified?: boolean,
            app_metadata?: {}
    }
    declare     export interface GetUsersData {
        per_page?: number,
            page?: number,
            include_totals?: boolean,
            sort?: string,
            connection?: string,
            fields?: string,
            include_fields?: boolean,
            q?: string,
            search_engine?: string
    }
    declare interface User {
        userName: string,
            profile: any
    }
    declare     export interface Identity {
        connection: string,
            user_id: string,
            provider: string,
            isSocial: boolean
    }
    declare     export class ManagementClient {
        constructor(options: ManagementClientOptions): this;
        getUsers(params?: GetUsersData): promise$Promise<adal$User[]>;
        getUsers(
            params?: GetUsersData,
            cb?: (err: error$Error, users: adal$User[]) => void): void;
        createUser(data: UserData): promise$Promise<adal$User>;
        createUser(data: UserData, cb: (err: error$Error, data: adal$User) => void): void
    }
    declare     export interface AuthenticationClientOptions {
        clientId?: string,
            domain: string
    }
    declare     export interface RequestChangePasswordEmailData {
        connection: string,
            email: string
    }
    declare     export class AuthenticationClient {
        constructor(options: AuthenticationClientOptions): this;
        requestChangePasswordEmail(data: RequestChangePasswordEmailData): promise$Promise<string>;
        requestChangePasswordEmail(
            data: RequestChangePasswordEmailData,
            cb: (err: error$Error, message: string) => void): void
    }
}
declare interface AutoLaunchOption {

    /**
     * Application name.
     */
    name: string,

        /**
         * Hidden on launch or not.  Default is false.
         */
        isHidden?: boolean,

        /**
         * Path to application directory.
         * Default is process.execPath.
         */
        path?: string
}
declare class AutoLaunch {
    constructor(opts: AutoLaunchOption): this;

    /**
     * Enables to launch at start up
     */
    enable(callback?: (err: error$Error) => void): void;

    /**
     * Disables to launch at start up
     */
    disable(callback?: (err: error$Error) => void): void;

    /**
     * Returns if auto start up is enabled
     */
    isEnabled(callback: (enabled: boolean) => void): void
}
declare module 'auto-launch' {
    declare     var al: typeof AutoLaunch;
    declare module.exports: typeof al
}
declare export class Session {
    id: number;
    realm: string;
    isOpen: boolean;
    features: any;
    caller_disclose_me: boolean;
    publisher_disclose_me: boolean;
    subscriptions: autobahn$ISubscription[][];
    registrations: autobahn$IRegistration[];
    constructor(transport: autobahn$ITransport, defer: autobahn$DeferFactory, challenge: autobahn$OnChallengeHandler): this;
    join(realm: string, authmethods: string[], authid: string): void;
    leave(reason: string, message: string): void;
    call<TResult>(
        procedure: string,
        args?: any[],
        kwargs?: any,
        options?: autobahn$ICallOptions): When.Promise<TResult>;
    publish(
        topic: string,
        args?: any[],
        kwargs?: any,
        options?: autobahn$IPublishOptions): When.Promise<autobahn$IPublication>;
    subscribe(
        topic: string,
        handler: ArbiterDef$SubscribeHandler,
        options?: autobahn$ISubscribeOptions): When.Promise<autobahn$ISubscription>;
    register(
        procedure: string,
        endpoint: autobahn$RegisterEndpoint,
        options?: autobahn$IRegisterOptions): When.Promise<autobahn$IRegistration>;
    unsubscribe(subscription: autobahn$ISubscription): When.Promise<any>;
    unregister(registration: autobahn$IRegistration): When.Promise<any>;
    prefix(prefix: string, uri: string): void;
    resolve(curie: string): string;
    onjoin: (roleFeatures: any) => void;
    onleave: (reason: string, details: any) => void
}

declare interface autobahn$IInvocation {
    caller?: number,
        progress?: (args: any[], kwargs: any) => void,
        procedure: string
}

declare class Invocation mixins IInvocation {
    constructor(caller?: number, progress?: boolean, procedure?: string): this;
    procedure: string
}

declare interface autobahn$IEvent {

    /**
     * The title of the event
     */
    title: string,

        /**
         * The type of the event (determines its color). Can be important, warning, info, inverse, success or special
         */
        type: string,

        /**
         * A javascript date object for when the event starts
         */
        startsAt: Date,

        /**
         * Optional - a javascript date object for when the event ends
         */
        endsAt?: Date,

        /**
         * If edit-event-html is set and this field is explicitly set to false then dont make it editable.
         */
        editable?: boolean,

        /**
         * If delete-event-html is set and this field is explicitly set to false then dont make it deleteable
         */
        deletable?: boolean,

        /**
         * Allow an event to be dragged and dropped
         */
        draggable?: boolean,

        /**
         * Allow an event to be resizable
         */
        resizable?: boolean,

        /**
         * If set to false then will not count towards the badge total amount on the month and year view
         */
        incrementsBadgeTotal?: boolean,

        /**
         * If set the event will recur on the given period. Valid values are year or month
         */
        recursOn?: string,

        /**
         * A CSS class (or more, just separate with spaces) that will be added to the event when it is displayed on each view. Useful for marking an event as selected / active etc
         */
        cssClass?: string
}

declare class Event mixins IEvent {
    constructor(publication?: number, publisher?: string, topic?: string): this;
    publication: number;
    topic: string
}

declare interface autobahn$IResult {
    args: any[],
        kwargs: any
}

declare class Result mixins IResult {
    constructor(args?: any[], kwargs?: any): this;
    args: any[];
    kwargs: any
}

declare interface autobahn$IError {
    error: string,
        args: any[],
        kwargs: any
}

declare class Error mixins IError {
    constructor(error?: string, args?: any[], kwargs?: any): this;
    error: string;
    args: any[];
    kwargs: any
}

declare export interface autobahn$SubscribeHandler {
    (data: any, message: string, subscriber_context: any): void
}

declare interface autobahn$ISubscription {
    topic: string,
        handler: autobahn$SubscribeHandler,
        options: autobahn$ISubscribeOptions,
        session: autobahn$Session,
        id: number,
        active: boolean,
        unsubscribe(): When.Promise<any >
}

declare class Subscription mixins ISubscription {
    constructor(topic?: string, handler?: autobahn$SubscribeHandler, options?: autobahn$ISubscribeOptions, session?: autobahn$Session, id?: number): this;
    handler: autobahn$SubscribeHandler;
    unsubscribe(): When.Promise<any>;
    topic: string;
    options: autobahn$ISubscribeOptions;
    session: autobahn$Session;
    id: number;
    active: boolean
}

declare type autobahn$RegisterEndpoint = (args?: any[], kwargs?: any, details?: autobahn$IInvocation) => void;

declare interface autobahn$IRegistration {
    procedure: string,
        endpoint: autobahn$RegisterEndpoint,
        options: autobahn$IRegisterOptions,
        session: autobahn$Session,
        id: number,
        active: boolean,
        unregister(): When.Promise<any >
}

declare class Registration mixins IRegistration {
    constructor(procedure?: string, endpoint?: autobahn$RegisterEndpoint, options?: autobahn$IRegisterOptions, session?: autobahn$Session, id?: number): this;
    endpoint: autobahn$RegisterEndpoint;
    unregister(): When.Promise<any>;
    procedure: string;
    options: autobahn$IRegisterOptions;
    session: autobahn$Session;
    id: number;
    active: boolean
}

declare interface autobahn$IPublication {
    id: number
}

declare class Publication mixins IPublication {
    constructor(id: number): this;
    id: number
}

declare interface autobahn$ICallOptions {
    timeout?: number,
        receive_progress?: boolean,
        disclose_me?: boolean
}

declare interface autobahn$IPublishOptions {
    acknowledge?: boolean,
        exclude?: number[],
        eligible?: number[],
        disclose_me?: Boolean
}

declare interface autobahn$ISubscribeOptions {
    match?: string
}

declare interface autobahn$IRegisterOptions {
    disclose_caller?: boolean
}

declare export class Connection {
    constructor(options?: autobahn$IConnectionOptions): this;
    open(): void;
    close(reason?: string, message?: string): void;
    onopen: (session: autobahn$Session, details: any) => void;
    onclose: (reason: string, details: any) => boolean
}

declare interface autobahn$ITransportDefinition {
    url?: string,
        protocols?: string[],
        type: string
}

declare type autobahn$DeferFactory = () => When.Promise<any>;

declare type autobahn$OnChallengeHandler = (session: autobahn$Session, method: string, extra: any) => When.Promise<string>;

declare interface autobahn$IConnectionOptions {
    use_es6_promises?: boolean,
        use_deferred?: autobahn$DeferFactory,
        transports?: autobahn$ITransportDefinition[],
        retry_if_unreachable?: boolean,
        max_retries?: number,
        initial_retry_delay?: number,
        max_retry_delay?: number,
        retry_delay_growth?: number,
        retry_delay_jitter?: number,
        url?: string,
        protocols?: string[],
        onchallenge?: autobahn$OnChallengeHandler,
        realm?: string,
        authmethods?: string[],
        authid?: string
}

declare interface autobahn$ICloseEventDetails {
    wasClean: boolean,
        reason: string,
        code: number
}

declare interface autobahn$ITransport {
    onopen: () => void,
        onmessage: (message: any[]) => void,
        onclose: (details: autobahn$ICloseEventDetails) => void,
        send(message: any[]): void,
        close(errorCode: number, reason?: string): void
}

declare interface autobahn$ITransportFactory {
    type: string,
        create(): autobahn$ITransport
}

declare interface autobahn$ITransports {
    register(name: string, factory: any): void,
        isRegistered(name: string): boolean,
        get(name: string): any,
        list(): string[]
}

declare interface autobahn$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare interface autobahn$IUtil {
    assert(condition: boolean, message: string): void
}

declare interface autobahn$IAuthCra {
    derive_key(secret: string, salt: string, iterations: number, keylen: number): string,
        sign(key: string, challenge: string): string
}

declare var util: autobahn$IUtil;

declare var log: autobahn$ILog;

declare var transports: autobahn$ITransports;

declare var auth_cra: autobahn$IAuthCra;
declare module 'autobahn' {
    declare module.exports: typeof autobahn
}
declare module 'autobind-decorator' {
    declare module.exports: typeof autobind
}
declare interface ___Autolinker$ConfigOptions {
    className?: string,
        email?: boolean,
        hashtag?: boolean | string,
        newWindow?: boolean,
        phone?: boolean,
        replaceFn?: (autolinker: ___Autolinker$Autolinker, match: any) => string,
        stripPrefix?: boolean,
        truncate?: number | {
            length?: number,
            location?: string
        },
        twitter?: boolean,
        urls?: boolean | {
            schemeMatches: boolean,
            wwwMatches: boolean,
            tldMatches: boolean
        }
}

declare interface ___Autolinker$Autolinker {
    getTagBuilder(): any,

        /**
         * Automatically links URLs, Email addresses, Phone numbers, Twitter handles, and Hashtags found in the given chunk of HTML. Does not link URLs found within HTML tags.
         */
        link(textOrHtml: string): string,

        /**
         * Parses the input textOrHtml looking for URLs, email addresses, phone numbers, username handles, and hashtags (depending on the configuration of the Autolinker instance), and returns an array of Autolinker.match.Match objects describing those matches.
         */
        parse(textOrHtml: string): any[]
}

declare interface ___Autolinker$Static {
    new(cfg?: ___Autolinker$ConfigOptions): ___Autolinker$Autolinker,

    /**
     * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles, and Hashtags found in the given chunk of HTML. Does not link URLs found within HTML tags.
     */
    link(textOrHtml: string, options?: ___Autolinker$ConfigOptions): string
}
declare var Autolinker: ___Autolinker$Static;
declare module 'autolinker' {
    declare module.exports: typeof Autolinker
}
declare module 'AutoMapperJs' {

    /**
     * AutoMapper implementation, for both creating maps and performing maps. Comparable usage and functionality to the original
     * .NET AutoMapper library is the pursuit of this implementation.
     */
    declare class AutoMapper {

        /**
         * Initializes the mapper with the supplied configuration.: IConfiguration) => void} Configuration function to call.
         */
        initialize(configFunction: (config: IConfiguration) => void): void;

        /**
         * Create a createMap curry function which expects only a destination key.
         * @param  The map source key.
         * @returns  : string) => ICreateMapFluentFunctions}
         */
        createMap(
            sourceKey: string | (() => any)): (destinationKey: string | (() => any)) => ICreateMapFluentFunctions;

        /**
         * Create a mapping profile.
         * @param  The map source key.
         * @param  The map destination key.
         * @returns  
         */
        createMap(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any)): ICreateMapFluentFunctions;

        /**
         * Create a map curry function which expects a destination key and a source object.
         * @param sourceKey Source key, for instance the source type name.
         * @returns  : string, sourceObject: any) => any}
         */
        map(
            sourceKey: string | (() => any)): (destinationKey: string | (() => any), sourceObject: any) => any;

        /**
         * Create a map curry function which expects only a source object.
         * @param sourceKey Source key, for instance the source type name.
         * @param destinationKey Destination key, for instance the destination type name.
         * @returns  : any) => any}
         */
        map(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any)): (sourceObject: any) => any;

        /**
         * Execute a mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).
         * @param sourceKey Source key, for instance the source type name.
         * @param destinationKey Destination key, for instance the destination type name.
         * @param sourceObject The source object to map.
         * @returns  Destination object.
         */
        map(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any),
            sourceObject: any): any;

        /**
         * Create a mapAsync curry function which expects a destination key, a source object and a callback function.
         * @param sourceKey Source key, for instance the source type name.
         * @returns  : string, sourceObject: any, callback: IMapCallback) => void}
         */
        mapAsync(
            sourceKey: string | (() => any)): (
            destinationKey: string | (() => any),
            sourceObject: any,
            callback: IMapCallback) => void;

        /**
         * Create a map curry function which expects only a source object and a callback function.
         * @param sourceKey Source key, for instance the source type name.
         * @param destinationKey Destination key, for instance the destination type name.
         * @param sourceObject The source object to map.
         * @returns  : IMapCallback) => void}
         */
        mapAsync(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any),
            sourceObject: any): (callback: IMapCallback) => void;

        /**
         * Create a map curry function which expects only a source object and a callback function.
         * @param sourceKey Source key, for instance the source type name.
         * @param destinationKey Destination key, for instance the destination type name.
         * @returns  : any, callback: IMapCallback) => void}
         */
        mapAsync(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any)): (sourceObject: any, callback: IMapCallback) => void;

        /**
         * Execute an asynchronous mapping from the source object to a new destination object with explicit mapping configuration and supplied mapping options (using createMap).
         * @param sourceKey Source key, for instance the source type name.
         * @param destinationKey Destination key, for instance the destination type name.
         * @param sourceObject The source object to map.
         * @param  The callback to call when asynchronous mapping is complete.
         */
        mapAsync(
            sourceKey: string | (() => any),
            destinationKey: string | (() => any),
            sourceObject: any,
            callback: IMapCallback): void;

        /**
         * Validates mapping configuration by dry-running. Since JS does not
         * fully support typing, it only checks if properties match on both
        sides. The function needs IMapping.sourceTypeClass and 
        IMapping.destinationTypeClass to function.
         * @param  Whether or not to fail when properties
        sourceTypeClass or destinationTypeClass
        are unavailable. 
        */
        assertConfigurationIsValid(strictMode?: boolean): void
    }
    declare class AsyncAutoMapper {}

    /**
     * Converts source type to destination type instead of normal member mapping
     */
    declare class TypeConverter mixins ITypeConverter {

        /**
         * Performs conversion from source to destination type.
         * @param  Resolution context.
         * @returns  Destination object.
         */
        convert(resolutionContext: IResolutionContext): any
    }
    declare     export class Profile mixins IProfile {

        /**
         * Profile name 
         */
        profileName: string;

        /**
         * Naming convention for source members 
         */
        sourceMemberNamingConvention: INamingConvention;

        /**
         * Naming convention for destination members 
         */
        destinationMemberNamingConvention: INamingConvention;

        /**
         * Create a createMap curry function which expects only a destination key.
         * @param  The map source key.
         * @returns  : string) => ICreateMapFluentFunctions}
         */
        createMap(sourceKey: string): (destinationKey: string) => ICreateMapFluentFunctions;

        /**
         * Create a mapping profile.
         * @param  The map source key.
         * @param  The map destination key.
         * @returns  
         */
        createMap(sourceKey: string, destinationKey: string): ICreateMapFluentFunctions;

        /**
         * Implement this method in a derived class and call the CreateMap method to associate that map with this profile.
         * Avoid calling the AutoMapper class / automapper instance from this method. 
         */
        configure(): void
    }

    /**
     * Defines the PascalCase naming convention strategy.
     */
    declare class PascalCaseNamingConvention mixins INamingConvention {

        /**
         * Regular expression on how to tokenize a member. 
         */
        splittingExpression: RegExp;

        /**
         * Character to separate on. 
         */
        separatorCharacter: string;

        /**
         * Transformation function called when this convention is the destination naming convention.
         * @param  Array containing tokenized source property name parts.
         * @returns  Destination property name
         */
        transformPropertyName(sourcePropertyNameParts: string[]): string
    }

    /**
     * Defines the camelCase naming convention strategy.
     */
    declare class CamelCaseNamingConvention mixins INamingConvention {

        /**
         * Regular expression on how to tokenize a member. 
         */
        splittingExpression: RegExp;

        /**
         * Character to separate on. 
         */
        separatorCharacter: string;

        /**
         * Transformation function called when this convention is the destination naming convention.
         * @param  Array containing tokenized source property name parts.
         * @returns  Destination property name
         */
        transformPropertyName(sourcePropertyNameParts: string[]): string
    }
    declare interface IProperty {
        name: string,
            metadata: IPropertyMetadata,
            level: number,
            sourceMapping: boolean,
            ignore: boolean,
            async: boolean,
            children?: IProperty[],
            destinations?: IProperty[],
            conversionValuesAndFunctions: any[],
            conditionFunction?: (sourceObject: any) => boolean
    }
    declare interface IPropertyMetadata {
        mapping: IMapping,
            root: IProperty,
            parent: IProperty,
            destinations: {
                [name: string]: IPropertyDestinationMetadata
            },
            destinationCount: number
    }
    declare interface IPropertyDestinationMetadata {
        source: IProperty,
            destination: IProperty
    }
    declare interface IMemberMappingMetaData {
        destination: string,
            source: string,
            sourceMapping: boolean,
            ignore: boolean,
            async: boolean,
            condition: (sourceObject: any) => boolean
    }

    /**
     * Member mapping properties.
     */
    declare interface IForMemberMapping {

        /**
         * The source member property name. 
         */
        sourceProperty: string,

            /**
             * The destination member property name parts for nested property support (e.g. 'type.name'). 
             */
            destinationProperty: string,

            /**
             * Source or destination mapping. 
             */
            sourceMapping: boolean,

            /**
             * All mapping values and/or functions resulting from stacked for(Source)Member calls. 
             */
            mappingValuesAndFunctions: Array<any>,

            /**
             * Whether or not this destination property must be ignored. 
             */
            ignore: boolean,

            /**
             * Whether or not this member mapping has an asynchronous mapping function. 
             */
            async: boolean,

            /**
             * The object will only be mapped when the condition is met.
             * @param  The source object to check.
             * @returns  
             */
            conditionFunction: (sourceObject: any) => boolean
    }

    /**
     * Interface for returning an object with available 'sub' functions to enable method chaining (e.g. automapper.createMap().forMember().forMember() ...)
     */
    declare interface ICreateMapFluentFunctions {

        /**
         * Customize configuration for an individual destination member.
         * @param sourceProperty The destination member property name.
         * @param valueOrFunction The value or function to use for this individual member.
         * @returns  
         */
        forMember: (
                sourceProperty: string,
                valueOrFunction: any | ((opts: IMemberConfigurationOptions) => any) | ((opts: IMemberConfigurationOptions, cb: IMemberCallback) => void)) => ICreateMapFluentFunctions,

            /**
             * Customize configuration for an individual source member.
             * @param sourceProperty The source member property name.
             * @param sourceMemberConfigFunction The function to use for this individual member.
             * @returns  
             */
            forSourceMember: (
                sourceProperty: string,
                sourceMemberConfigFunction: ((opts: ISourceMemberConfigurationOptions) => any) | ((opts: ISourceMemberConfigurationOptions, cb: IMemberCallback) => void)) => ICreateMapFluentFunctions,

            /**
             * Customize configuration for all destination members.
             * @param func The function to use for this individual member.
             * @returns  
             */
            forAllMembers: (
                func: (destinationObject: any, destinationPropertyName: string, value: any) => void) => ICreateMapFluentFunctions,

            /**
             * Ignore all members not specified explicitly.
             */
            ignoreAllNonExisting: () => ICreateMapFluentFunctions,

            /**
             * Skip normal member mapping and convert using a custom type converter (instantiated during mapping).
             * @param typeConverterClassOrFunction The converter class or function to use when converting.
             */
            convertUsing: (
                typeConverterClassOrFunction: ((resolutionContext: IResolutionContext) => any) | ((resolutionContext: IResolutionContext, callback: IMapCallback) => void) | ITypeConverter | (() => ITypeConverter)) => void,

            /**
             * Specify to which class type AutoMapper should convert. When specified, AutoMapper will create an instance of the given type, instead of returning a new object literal.
             * @param typeClass The destination type class.
             * @returns  
             */
            convertToType: (typeClass: () => any) => ICreateMapFluentFunctions,

            /**
             * Specify which profile should be used when mapping.
             * @param  The profile name.
             * @returns  
             */
            withProfile: (profileName: string) => void
    }

    /**
     * The mapping configuration for the current mapping keys/types.
     */
    declare interface IMapping {

        /**
         * The mapping source key. 
         */
        sourceKey: string,

            /**
             * The mapping destination key. 
             */
            destinationKey: string,

            /**
             * The mappings for forAllMembers functions. 
             */
            forAllMemberMappings: Array<(destinationObject: any, destinationPropertyName: string, value: any) => void>,
            properties: IProperty[],

            /**
             * Skip normal member mapping and convert using a type converter.
             * @param resolutionContext Context information regarding resolution of a destination value
             * @returns  Destination object.
             */
            typeConverterFunction: ((resolutionContext: IResolutionContext) => any) | ((resolutionContext: IResolutionContext, callback: IMapCallback) => void),

            /**
             * The source type class to convert from. 
             */
            sourceTypeClass: any,

            /**
             * The destination type class to convert to. 
             */
            destinationTypeClass: any,

            /**
             * The profile used when mapping. 
             */
            profile?: IProfile,

            /**
             * Whether or not to ignore all properties not specified using createMap. 
             */
            ignoreAllNonExisting?: boolean,

            /**
             * Whether or not an mapping has to be asynchronous. 
             */
            async: boolean,

            /**
             * Item mapping function to use.
             */
            mapItemFunction: IMapItemFunction | IAsyncMapItemFunction
    }

    /**
     * Context information regarding resolution of a destination value
     */
    declare     export interface IResolutionContext {

        /**
         * Source value 
         */
        sourceValue: any,

            /**
             * Destination value 
             */
            destinationValue: any,

            /**
             * Source property name 
             */
            sourcePropertyName?: string,

            /**
             * Destination property name 
             */
            destinationPropertyName?: string,

            /**
             * Index of current collection mapping 
             */
            arrayIndex?: number
    }

    /**
     * Configuration options for forMember mapping function.
     */
    declare interface IMemberConfigurationOptions {

        /**
         * Map from a custom source property name.
         * @param sourcePropertyName The source property to map.
         */
        mapFrom: (sourcePropertyName: string) => void,

            /**
             * When this configuration function is used, the (destination) property is ignored
             * when mapping. 
             */
            ignore?: () => void,

            /**
             * If specified, the property will only be mapped when the condition is fulfilled.
             */
            condition: (predicate: ((sourceObject: any) => boolean)) => void,

            /**
             * The source object to map. 
             */
            sourceObject: any,

            /**
             * The source property to map. 
             */
            sourcePropertyName: string,

            /**
             * The intermediate destination property value, used for stacking multiple for(Source)Member calls 
             * while elaborating the intermediate result.
             */
            intermediatePropertyValue: any
    }

    /**
     * Configuration options for forSourceMember mapping function.
     */
    declare interface ISourceMemberConfigurationOptions {

        /**
         * When this configuration function is used, the source property is ignored
         * when mapping.
         */
        ignore: () => void
    }

    /**
     * Member callback interface
     */
    declare interface IMemberCallback {

        /**
         * Callback function to call when the async operation is executed.
         * @param  Callback value to be used as output for the for(Source)Member call.
         */
        (callbackValue: any): void
    }

    /**
     * Member callback interface
     */
    declare interface IMapCallback {

        /**
         * Callback function to call when the async operation is executed.
         * @param  Callback value to be used as output for the mapAsync call.
         */
        (result: any): void
    }

    /**
     * Converts source type to destination type instead of normal member mapping
     */
    declare     export interface ITypeConverter {

        /**
         * Performs conversion from source to destination type.
         * @param  Resolution context.
         * @returns  Destination object.
         */
        convert: (resolutionContext: IResolutionContext) => any
    }

    /**
     * Defines a naming convention strategy.
     */
    declare     export interface INamingConvention {

        /**
         * Regular expression on how to tokenize a member. 
         */
        splittingExpression: RegExp,

            /**
             * Character to separate on. 
             */
            separatorCharacter: string,

            /**
             * Transformation function called when this convention is the destination naming convention.
             * @param  Array containing tokenized source property name parts.
             * @returns  Destination property name
             */
            transformPropertyName: (sourcePropertyNameParts: string[]) => string
    }

    /**
     * Configuration for profile-specific maps.
     */
    declare     export interface IConfiguration {

        /**
         * Add an existing profile
         * @param profile Profile to add.
         */
        addProfile(profile: IProfile): void,

            /**
             * Create a createMap curry function which expects only a destination key.
             * @param  The map source key.
             * @returns  : string) => IAutoMapperCreateMapChainingFunctions}
             */
            createMap(sourceKey: string): (destinationKey: string) => ICreateMapFluentFunctions,

            /**
             * Create a mapping profile.
             * @param  The map source key.
             * @param  The map destination key.
             * @returns  
             */
            createMap(sourceKey: string, destinationKey: string): ICreateMapFluentFunctions
    }

    /**
     * Provides a named configuration for maps. Naming conventions become scoped per profile.
     */
    declare     export interface IProfile {

        /**
         * Profile name 
         */
        profileName: string,

            /**
             * Naming convention for source members 
             */
            sourceMemberNamingConvention: INamingConvention,

            /**
             * Naming convention for destination members 
             */
            destinationMemberNamingConvention: INamingConvention,

            /**
             * Implement this method in a derived class and call the CreateMap method to associate that map with this profile.
             * Avoid calling the AutoMapper class / automapper instance from this method. 
             */
            configure: () => void
    }
    declare     export interface IMapItemFunction {
        (mapping: IMapping, sourceObject: any, destinationObject: any): any
    }
    declare     export interface IAsyncMapItemFunction {
        (mapping: IMapping, sourceObject: any, destinationObject: any, callback: IMapCallback): void
    }
    declare interface ICreateMapParameters {
        mapping: IMapping,
            destinationProperty: string,
            conversionValueOrFunction: any,
            sourceMapping: boolean,
            fluentFunctions: ICreateMapFluentFunctions
    }
    declare interface IGetOrCreatePropertyParameters {
        propertyNameParts: string[],
            mapping: IMapping,
            parent?: IProperty,
            propertyArray: IProperty[],
            destination?: string,
            sourceMapping: boolean
    }
    declare interface ICreatePropertyParameters {
        name: string,
            mapping: IMapping,
            parent: IProperty,
            propertyArray: IProperty[],
            sourceMapping: boolean
    }
}
declare var automapper: AutoMapperJs.AutoMapper;
declare module 'autoprefixer-core' {
    declare interface Config {
        tenant?: string,
            clientId: string,
            redirectUri?: string,
            cacheLocation?: string,
            displayCall?: (urlNavigate: string) => any,
            correlationId?: string,
            loginResource?: string,
            resource?: string,
            endpoints?: any,
            extraQueryParameter?: string,
            postLogoutRedirectUri?: string
    }
    declare     export interface Options {
        recurse: boolean
    }
    declare interface Result {
        css: string,
            map: string,
            opts: archy$Options
    }
    declare interface Processor {
        postcss: any,
            info(): string,
            process(css: string, opts?: archy$Options): autobahn$Result
    }
    declare interface Exports {
        (config: adal$Config): OpenJsCad$Processor,
        postcss: any,
            info(): string,
            process(css: string, opts?: archy$Options): autobahn$Result
    }
    declare     var exports: Exports;
    declare module.exports: typeof exports
}
declare interface autosize$AutosizeStatic {
    (el: angularScenario$Element): void,
    (el: NodeList): void
}
declare var autosize: autosize$AutosizeStatic;
declare module 'autosize' {
    declare module.exports: typeof autosize
}
declare module 'avoscloud-sdk' {

    declare     var npm$namespace$AV: {
        initialize: typeof AV$initialize,
    }
    declare     var applicationId: string;

    declare     var applicationKey: string;

    declare     var masterKey: string;

    declare interface AV$SuccessOption {
        success?: Function
    }

    declare interface AV$ErrorOption {
        error?: Function
    }

    declare type AV$SuccessFailureOptions = {} & AV$SuccessOption & AV$ErrorOption


    declare interface AV$WaitOption {

        /**
         * Set to true to wait for the server to confirm success
         * before triggering an event.
         */
        wait?: boolean
    }

    declare interface AV$UseMasterKeyOption {

        /**
         * In Cloud Code and Node only, causes the Master Key to be used for this request.
         */
        useMasterKey?: boolean
    }

    declare interface AV$SilentOption {

        /**
         * Set to true to avoid firing the event.
         */
        silent?: boolean
    }

    declare interface AV$IPromise<T>{

        /**
         * This method can be used as a replacement for then. Similarly, it takes two parameters, a callback when all promises are resolved and a callback for failure. The resolve callback is going to be called with the result of the list of promises passed to $q.all as separate parameters instead of one parameters which is an array.
         *  
         * @param successCallback Callback for resolved promise, similar to then's one, but takes multiple parameters instead of single array parameter
         * @param errorCallback Callback for error, the same as for then
         */
        spread<TResult>(
            successCallback: (...promiseValues: any[]) => AV$IPromise<TResult>| TResult,
            errorCallback?: (reason: any) => any): AV$IPromise<TResult >
    }

    declare class Promise<T>{
        as<U>(resolvedValue: U): AV$Promise<U>;
        error<U>(error: U): AV$Promise<U>;
        is(possiblePromise: any): Boolean;
        when(promises: AV$Promise<any>[]): AV$Promise<any>;
        always(callback: Function): AV$Promise<T>;
        done(callback: Function): AV$Promise<T>;
        fail(callback: Function): AV$Promise<T>;
        reject(error: any): void;
        resolve(result: any): void;
        then<U>(
            resolvedCallback: (value: T) => AV$Promise<U>,
            rejectedCallback?: (reason: any) => AV$Promise<U>): AV$IPromise<T>;
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => AV$IPromise<U>): AV$IPromise<T>;
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => U): AV$IPromise<T >
    }

    declare interface AV$IBaseObject {
        toJSON(): any
    }

    declare class BaseObject mixins IBaseObject {
        toJSON(): any
    }


    /**
     * Creates a new ACL.
     * If no argument is given, the ACL has no permissions for anyone.
    If the argument is a AV.User, the ACL will have read and write
       permission for only that user.
    If the argument is any other JSON object, that object will be interpretted
       as a serialized ACL created with toJSON().
     * @see  AV.Object#setACL
     * @class  *
    <p>An ACL, or Access Control List can be added to any
    <code>AV.Object</code> to restrict access to only a subset of users
    of your application.</p>
    */
    declare class ACL mixins BaseObject {
        permissionsById: any;
        constructor(arg1?: any): this;
        setPublicReadAccess(allowed: boolean): void;
        getPublicReadAccess(): boolean;
        setPublicWriteAccess(allowed: boolean): void;
        getPublicWriteAccess(): boolean;
        setReadAccess(userId: adal$User, allowed: boolean): void;
        getReadAccess(userId: adal$User): boolean;
        setReadAccess(userId: string, allowed: boolean): void;
        getReadAccess(userId: string): boolean;
        setRoleReadAccess(role: AV$Role, allowed: boolean): void;
        setRoleReadAccess(role: string, allowed: boolean): void;
        getRoleReadAccess(role: AV$Role): boolean;
        getRoleReadAccess(role: string): boolean;
        setRoleWriteAccess(role: AV$Role, allowed: boolean): void;
        setRoleWriteAccess(role: string, allowed: boolean): void;
        getRoleWriteAccess(role: AV$Role): boolean;
        getRoleWriteAccess(role: string): boolean;
        setWriteAccess(userId: adal$User, allowed: boolean): void;
        setWriteAccess(userId: string, allowed: boolean): void;
        getWriteAccess(userId: adal$User): boolean;
        getWriteAccess(userId: string): boolean
    }


    /**
     * A AV.File is a local representation of a file that is saved to the AV
     * cloud.
     * @class  * 
     * @param name The file's name. This will be prefixed by a unique
    value once the file has finished saving. The file name must begin with
    an alphanumeric character, and consist of alphanumeric characters,
    periods, spaces, underscores, or dashes.
     * @param data The data for the file, as either:
    1. an Array of byte value Numbers, or
    2. an Object like { base64: "..." } with a base64-encoded String.
    3. a File object selected with a file upload control. (3) only works
    in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.
    For example:<pre>
    var fileUploadControl = $("#profilePhotoFileUpload")[0];
    if (fileUploadControl.files.length>0) {
    var file = fileUploadControl.files[0];
    var name = "photo.jpg";
    var AVFile = new AV.File(name, file);
    AVFile.save().then(function() {
    // The file has been saved to AV.
    }, function(error) {
    // The file either could not be read, or could not be saved to AV.
    });
    }</pre>
     * @param type Optional Content-Type header to use for the file. If
    this is omitted, the content type will be inferred from the name's
    extension.
    */
    declare class File {
        constructor(name: string, data: any, type?: string): this;
        name(): string;
        url(): string;
        save<T>(options?: AV$SuccessFailureOptions): AV$Promise<T >
    }


    /**
     * Creates a new GeoPoint with any of the following forms:<br>
     *    <pre>
       new GeoPoint(otherGeoPoint)
       new GeoPoint(30, 30)
       new GeoPoint([30, 30])
       new GeoPoint({latitude: 30, longitude: 30})
       new GeoPoint()  // defaults to (0, 0)
       </pre>
     * @class  *
    <p>Represents a latitude / longitude point that may be associated
    with a key in a AVObject or used as a reference point for geo queries.
    This allows proximity-based queries on the key.</p>

    <p>Only one key in a class may contain a GeoPoint.</p>

    <p>Example:<pre>
    var point = new AV.GeoPoint(30.0, -20.0);
    var object = new AV.Object("PlaceObject");
    object.set("location", point);
    object.save();</pre></p>
    */
    declare class GeoPoint mixins BaseObject {
        latitude: number;
        longitude: number;
        constructor(arg1?: any, arg2?: any): this;
        current(options?: AV$SuccessFailureOptions): AV$GeoPoint;
        radiansTo(point: AV$GeoPoint): number;
        kilometersTo(point: AV$GeoPoint): number;
        milesTo(point: AV$GeoPoint): number
    }


    /**
     * A class that is used to access all of the children of a many-to-many relationship.
     * Each instance of AV.Relation is associated with a particular parent object and key.
     */
    declare class Relation mixins BaseObject {
        parent: AV$Object;
        key: string;
        targetClassName: string;
        constructor(parent?: AV$Object, key?: string): this;
        add(object: AV$Object): void;
        query(): anydbSQL$Query;
        remove(object: AV$Object): void
    }


    /**
     * Creates a new model with defined attributes. A client id (cid) is
     * automatically generated and assigned for you.

    <p>You won't normally call this method directly.  It is recommended that
    you use a subclass of <code>AV.Object</code> instead, created by calling
    <code>extend</code>.</p>

    <p>However, if you don't want to use a subclass, or aren't sure which
    subclass is appropriate, you can use this form:<pre>
         var object = new AV.Object("ClassName");
    </pre>
    That is basically equivalent to:<pre>
         var MyClass = AV.Object.extend("ClassName");
         var object = new MyClass();
    </pre></p>
     * @param  The initial set of data to store in the object.
     * @param  A set of Backbone-like options for creating the
    object.  The only option currently supported is "collection".
     * @see  AV.Object.extend
     * @class  *
    <p>The fundamental unit of AV data, which implements the Backbone Model
    interface.</p>
    */
    declare class Object mixins BaseObject {
        id: any;
        createdAt: any;
        updatedAt: any;
        attributes: any;
        cid: string;
        changed: boolean;
        className: string;
        constructor(className?: string, options?: any): this;
        constructor(attributes?: string[], options?: any): this;
        extend(className: string, protoProps?: any, classProps?: any): any;
        fetchAll<T>(list: AV$Object[], options: AV$SuccessFailureOptions): AV$Promise<T>;
        fetchAllIfNeeded<T>(list: AV$Object[], options: AV$SuccessFailureOptions): AV$Promise<T>;
        destroyAll<T>(list: AV$Object[], options?: Object$DestroyAllOptions): AV$Promise<T>;
        saveAll<T>(list: AV$Object[], options?: Object$SaveAllOptions): AV$Promise<T>;
        initialize(): void;
        add(attr: string, item: any): AV$Object;
        addUnique(attr: string, item: any): any;
        change(options: any): AV$Object;
        changedAttributes(diff: any): boolean;
        clear(options: any): any;
        clone(): AV$Object;
        destroy<T>(options?: Object$DestroyOptions): AV$Promise<T>;
        dirty(attr: String): boolean;
        dirtyKeys(): string[];
        escape(attr: string): string;
        existed(): boolean;
        fetch<T>(options?: Object$FetchOptions): AV$Promise<T>;
        get(attr: string): any;
        getACL(): AV$ACL;
        getObjectId(): string;
        has(attr: string): boolean;
        hasChanged(attr: string): boolean;
        increment(attr: string, amount?: number): any;
        isValid(): boolean;
        op(attr: string): any;
        previous(attr: string): any;
        previousAttributes(): any;
        relation(attr: string): AV$Relation;
        remove(attr: string, item: any): any;
        save<T>(options?: Object$SaveOptions, arg2?: any, arg3?: any): AV$Promise<T>;
        set(key: string, value: any, options?: Object$SetOptions): boolean;
        setACL(acl: AV$ACL, options?: AV$SuccessFailureOptions): boolean;
        unset(attr: string, options?: any): any;
        validate(attrs: any, options?: AV$SuccessFailureOptions): boolean
    }

    declare type Object$DestroyOptions = {} & AV$SuccessFailureOptions & AV$WaitOption & AV$UseMasterKeyOption


    declare type Object$DestroyAllOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$FetchOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$SaveOptions = {} & AV$SuccessFailureOptions & AV$SilentOption & AV$UseMasterKeyOption & AV$WaitOption


    declare type Object$SaveAllOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$SetOptions = {
        promise?: any
    } & AV$ErrorOption & AV$SilentOption



    /**
     * Every AV application installed on a device registered for
     * push notifications has an associated Installation object.
     */
    declare class Installation mixins Object {
        badge: any;
        channels: string[];
        timeZone: any;
        deviceType: string;
        pushType: string;
        installationId: string;
        deviceToken: string;
        channelUris: string;
        appName: string;
        appVersion: string;
        AVVersion: string;
        appIdentifier: string
    }


    /**
     * Creates a new instance with the given models and options.  Typically, you
     * will not call this method directly, but will instead make a subclass using
    <code>AV.Collection.extend</code>.
     * @param  An array of instances of <code>AV.Object</code>.
     * @param  An optional object with Backbone-style options.
    Valid options are:<ul>
    <li>model: The AV.Object subclass that this collection contains.
    <li>query: An instance of AV.Query to use when fetching items.
    <li>comparator: A string property name or function to sort by.
    </ul>
     * @see  AV.Collection.extend
     * @class  *
    <p>Provides a standard collection class for our sets of models, ordered
    or unordered.  For more information, see the
    <a href="http://documentcloud.github.com/backbone/#Collection">Backbone
    documentation</a>.</p>
    */
    declare class Collection<T>mixins Events, IBaseObject {
        model: AV$Object;
        models: AV$Object[];
        query: anydbSQL$Query;
        comparator: (object: AV$Object) => any;
        constructor(models?: AV$Object[], options?: Collection$Options): this;
        extend(instanceProps: any, classProps: any): any;
        initialize(): void;
        add(models: any[], options?: Collection$AddOptions): AV$Collection<T>;
        at(index: number): AV$Object;
        fetch(options?: Collection$FetchOptions): AV$Promise<T>;
        create(model: AV$Object, options?: Collection$CreateOptions): AV$Object;
        get(id: string): AV$Object;
        getByCid(cid: any): any;
        pluck(attr: string): any[];
        remove(model: any, options?: Collection$RemoveOptions): AV$Collection<T>;
        remove(models: any[], options?: Collection$RemoveOptions): AV$Collection<T>;
        reset(models: any[], options?: Collection$ResetOptions): AV$Collection<T>;
        sort(options?: Collection$SortOptions): AV$Collection<T>;
        toJSON(): any
    }

    declare     export interface Collection$Options {
        recurse: boolean
    }

    declare     export interface Collection$AddOptions {

        /**
         * The features that were added to the feature layer. 
         */
        addedGraphics?: Graphic[],

            /**
             * The feature layer where the new feature(s) are added. 
             */
            featureLayer?: FeatureLayer
    }

    declare type Collection$CreateOptions = {} & AV$SuccessFailureOptions & AV$WaitOption & AV$SilentOption & AV$UseMasterKeyOption


    declare type Collection$FetchOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Collection$RemoveOptions = {} & AV$SilentOption


    declare type Collection$ResetOptions = {} & AV$SilentOption


    declare type Collection$SortOptions = {} & AV$SilentOption



    /**
     * 
     * @class  *
    <p>AV.Events is a fork of Backbone's Events module, provided for your
    convenience.</p>

    <p>A module that can be mixed in to any object in order to provide
    it with custom events. You may bind callback functions to an event
    with `on`, or remove these functions with `off`.
    Triggering an event fires all callbacks in the order that `on` was
    called.

    <pre>
    var object = {};
    _.extend(object, AV.Events);
    object.on('expand', function(){ alert('expanded'); });
    object.trigger('expand');</pre></p>

    <p>For more information, see the
    <a href="http://documentcloud.github.com/backbone/#Events">Backbone
    documentation</a>.</p>
    */
    declare class Events {
        off(events: string[], callback?: Function, context?: any): AV$Events;
        on(events: string[], callback?: Function, context?: any): AV$Events;
        trigger(events: string[]): AV$Events;
        bind(): AV$Events;
        unbind(): AV$Events;
        on(eventName: string, callback?: Function, context?: any): AV$Events;
        off(eventName?: string, callback?: Function, context?: any): AV$Events;
        trigger(eventName: string, ...args: any[]): AV$Events;
        bind(eventName: string, callback: Function, context?: any): AV$Events;
        unbind(eventName?: string, callback?: Function, context?: any): AV$Events
    }


    /**
     * Creates a new AV AV.Query for the given AV.Object subclass.
     * @param objectClass -
    An instance of a subclass of AV.Object, or a AV className string.
     * @class  *
    <p>AV.Query defines a query that is used to fetch AV.Objects. The
    most common use case is finding all objects that match a query through the
    <code>find</code> method. For example, this sample code fetches all objects
    of class <code>MyClass</code>. It calls a different function depending on
    whether the fetch succeeded or not.

    <pre>
    var query = new AV.Query(MyClass);
    query.find({
    success: function(results) {
    // results is an array of AV.Object.
    },

    error: function(error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>

    <p>A AV.Query can also be used to retrieve a single object whose id is
    known, through the get method. For example, this sample code fetches an
    object of class <code>MyClass</code> and id <code>myId</code>. It calls a
    different function depending on whether the fetch succeeded or not.

    <pre>
    var query = new AV.Query(MyClass);
    query.get(myId, {
    success: function(object) {
    // object is an instance of AV.Object.
    },

    error: function(object, error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>

    <p>A AV.Query can also be used to count the number of objects that match
    the query without retrieving all of those objects. For example, this
    sample code counts the number of objects of the class <code>MyClass</code>
    <pre>
    var query = new AV.Query(MyClass);
    query.count({
    success: function(number) {
    // There are number instances of MyClass.
    },

    error: function(error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>
    */
    declare class Query mixins BaseObject {
        objectClass: any;
        className: string;
        constructor(objectClass: any): this;
        and(...var_args: AV$Query[]): AV$Query;
        or(...var_args: AV$Query[]): AV$Query;
        addAscending(key: string): AV$Query;
        addAscending(key: string[]): AV$Query;
        addDescending(key: string): AV$Query;
        addDescending(key: string[]): AV$Query;
        ascending(key: string): AV$Query;
        ascending(key: string[]): AV$Query;
        collection(items?: AV$Object[], options?: Collection$Options): AV$Collection<AV$Object>;
        containedIn(key: string, values: any[]): AV$Query;
        contains(key: string, substring: string): AV$Query;
        containsAll(key: string, values: any[]): AV$Query;
        count<T>(options?: Query$CountOptions): AV$Promise<T>;
        descending(key: string): AV$Query;
        descending(key: string[]): AV$Query;
        doesNotExist(key: string): AV$Query;
        doesNotMatchKeyInQuery(key: string, queryKey: string, query: AV$Query): AV$Query;
        doesNotMatchQuery(key: string, query: AV$Query): AV$Query;
        each<T>(callback: Function, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        endsWith(key: string, suffix: string): AV$Query;
        equalTo(key: string, value: any): AV$Query;
        exists(key: string): AV$Query;
        find<T>(options?: Query$FindOptions): AV$Promise<T>;
        first<T>(options?: Query$FirstOptions): AV$Promise<T>;
        get(objectId: string, options?: Query$GetOptions): AV$Promise<any>;
        greaterThan(key: string, value: any): AV$Query;
        greaterThanOrEqualTo(key: string, value: any): AV$Query;
        include(key: string): AV$Query;
        include(keys: string[]): AV$Query;
        lessThan(key: string, value: any): AV$Query;
        lessThanOrEqualTo(key: string, value: any): AV$Query;
        limit(n: number): AV$Query;
        matches(key: string, regex: RegExp, modifiers: any): AV$Query;
        matchesKeyInQuery(key: string, queryKey: string, query: AV$Query): AV$Query;
        matchesQuery(key: string, query: AV$Query): AV$Query;
        near(key: string, point: AV$GeoPoint): AV$Query;
        notContainedIn(key: string, values: any[]): AV$Query;
        notEqualTo(key: string, value: any): AV$Query;
        select(...keys: string[]): AV$Query;
        skip(n: number): AV$Query;
        startsWith(key: string, prefix: string): AV$Query;
        withinGeoBox(key: string, southwest: AV$GeoPoint, northeast: AV$GeoPoint): AV$Query;
        withinKilometers(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query;
        withinMiles(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query;
        withinRadians(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query
    }

    declare type Query$CountOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$FindOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$FirstOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$GetOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption



    /**
     * Represents a Role on the AV server. Roles represent groupings of
     * Users for the purposes of granting permissions (e.g. specifying an ACL
    for an Object). Roles are specified by their sets of child users and
    child roles, all of which are granted any permissions that the parent
    role has.

    <p>Roles must have a name (which cannot be changed after creation of the
    role), and must specify an ACL.</p>
     * @class  * A AV.Role is a local representation of a role persisted to the AV
    cloud.
    */
    declare class Role mixins Object {
        constructor(name: string, acl: AV$ACL): this;
        getRoles(): AV$Relation;
        getUsers(): AV$Relation;
        getName(): string;
        setName(name: string, options?: AV$SuccessFailureOptions): any
    }


    /**
     * 
     * @class  *
    <p>A AV.User object is a local representation of a user persisted to the
    AV cloud. This class is a subclass of a AV.Object, and retains the
    same functionality of a AV.Object, but also extends it with various
    user specific methods, like authentication, signing up, and validation of
    uniqueness.</p>
    */
    declare class User mixins Object {
        current(): AV$User;
        signUp<T>(
            username: string,
            password: string,
            attrs: any,
            options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logIn<T>(
            username: string,
            password: string,
            options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logOut<T>(): AV$Promise<T>;
        allowCustomUserClass(isAllowed: boolean): void;
        become<T>(sessionToken: string, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        requestPasswordReset<T>(email: string, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        signUp<T>(attrs: any, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logIn<T>(options?: AV$SuccessFailureOptions): AV$Promise<T>;
        fetch<T>(options?: AV$SuccessFailureOptions): AV$Promise<T>;
        save<T>(arg1?: any, arg2?: any, arg3?: any): AV$Promise<T>;
        authenticated(): boolean;
        isCurrent(): boolean;
        getEmail(): string;
        setEmail(email: string, options: AV$SuccessFailureOptions): boolean;
        getUsername(): string;
        setUsername(username: string, options?: AV$SuccessFailureOptions): boolean;
        setPassword(password: string, options?: AV$SuccessFailureOptions): boolean;
        getSessionToken(): string
    }


    declare     var npm$namespace$Analytics: {
        track: typeof Analytics$track,
    }
    declare     function Analytics$track<T>(name: string, dimensions: any): AV$Promise<T >

        declare class Error {
            code: ErrorCode;
            message: string;
            constructor(code: ErrorCode, message: string): this
        }

    declare type Op$BaseOperation = {
        objects(): any[]
    } & AV$IBaseObject


    declare type Op$Add = {} & Op$BaseOperation


    declare type Op$AddUnique = {} & Op$BaseOperation


    declare type Op$Increment = {
        amount: number
    } & AV$IBaseObject


    declare type Op$Relation = {
        added(): AV$Object[],
        removed: AV$Object[]
    } & AV$IBaseObject


    declare type Op$Set = {
        value(): any
    } & AV$IBaseObject


    declare type Op$Unset = {} & AV$IBaseObject



    declare     var npm$namespace$Push: {
        send: typeof Push$send,
    }
    declare     function Push$send<T>(data: Push$PushData, options?: Push$SendOptions): AV$Promise<T >

        declare interface Push$PushData {
            channels?: string[],
                push_time?: Date,
                expiration_time?: Date,
                expiration_interval?: number,
                where?: AV$Query,
                data?: any,
                alert?: string,
                badge?: string,
                sound?: string,
                title?: string
        }

    declare interface Push$SendOptions {
        success?: () => void,
            error?: (error: AV$Error) => void
    }


    /**
     * Call this method first to set up your authentication tokens for AV.
     * @param  Your Application ID.
     * @param  Your Application Key.
     * @param  (optional) Your Application Master Key. (Node.js only!)
     */
    declare     function AV$initialize(applicationId: string, applicationKey: string, masterKey?: string): void
    declare module.exports: typeof AV
}
declare module 'leanengine' {
    declare module.exports: typeof alias
}
declare class Awesomplete {
    constructor(input: angularScenario$Element | HTMLElement | string, o?: AwesompleteOptions): this;
    all: Array<any>;
    $$: (expr: string | NodeSelector, con?: any) => NodeList;
    ITEM: (text: string, input: string) => HTMLElement;
    $: {
        (expr: string | angularScenario$Element, con?: NodeSelector): string | angularScenario$Element,
        regExpEscape: (s: {
            replace: (arg0: RegExp, arg1: string) => void
        }) => any,
        create: (tag: string, o: any) => HTMLElement,
        fire: (target: EventTarget, type: string, properties: any) => any,
        siblingIndex: (el: angularScenario$Element) => number
    };
    FILTER_STARTSWITH: (text: string, input: string) => boolean;
    FILTER_CONTAINS: (text: string, input: string) => boolean;
    SORT_BYLENGTH: (a: number | any[], b: number | any[]) => number;
    REPLACE: (text: any) => void;
    next: () => void;
    container: HTMLElement;
    select: (selected?: HTMLElement, originalTarget?: HTMLElement) => void;
    previous: () => void;
    index: number;
    opened: number;
    list: string |
        string[] |
        angularScenario$Element |
        {
            label: string,
            value: any
        }[] |
        [string, string][];
    input: HTMLElement | string;
    goto: (i: number) => void;
    ul: HTMLElement;
    close: () => void;
    evaluate: () => void;
    selected: boolean;
    open: () => void;
    status: HTMLElement
}
declare interface AwesompleteOptions {
    list?: string |
        string[] |
        angularScenario$Element |
        {
            label: string,
            value: any
        }[] |
        [string, string][],
        minChars?: Number,
        maxItems?: Number,
        autoFirst?: boolean,
        data?: Function,
        filter?: Function,
        sort?: Function,
        item?: Function,
        replace?: Function
}
declare module 'aws-lambda' {
    declare interface Context {
        callbackWaitsForEmptyEventLoop: boolean,
            logGroupName: string,
            logStreamName: string,
            functionName: string,
            memoryLimitInMB: string,
            functionVersion: string,
            invokeid: string,
            awsRequestId: string
    }
    declare interface CognitoIdentity {
        cognitoIdentityId: string,
            cognitoIdentityPoolId: string
    }
    declare interface ClientContext {
        client: ClientContextClient,
            Custom?: any,
            env: ClientContextEnv
    }
    declare interface ClientContextClient {
        installationId: string,
            appTitle: string,
            appVersionName: string,
            appVersionCode: string,
            appPackageName: string
    }
    declare interface ClientContextEnv {
        platformVersion: string,
            platform: string,
            make: string,
            model: string,
            locale: string
    }
    declare type Callback = (err: AV$Error) => any;
}
declare module 'aws-sdk' {
    declare     export var config: ClientConfig;
    declare interface Config {
        tenant?: string,
            clientId: string,
            redirectUri?: string,
            cacheLocation?: string,
            displayCall?: (urlNavigate: string) => any,
            correlationId?: string,
            loginResource?: string,
            resource?: string,
            endpoints?: any,
            extraQueryParameter?: string,
            postLogoutRedirectUri?: string
    }
    declare     export class Credentials {
        constructor(accessKeyId: string, secretAccessKey: string, sessionToken?: string): this;
        accessKeyId: string
    }
    declare     export class EnvironmentCredentials mixins Credentials {
        constructor(profile: string): this
    }
    declare module 'CognitoIdentity' {
        declare         export interface CognitoIdentityCredentialsParams {
            IdentityPoolId?: string,
                AccountId?: string,
                Logins?: {
                    [k: string]: any
                },
                RoleArn?: string,
                RoleSessionName?: string,
                WebIdentityToken?: string,
                ProviderId?: string,
                Policy?: string,
                DurationSeconds?: number,
                IdentityId?: string
        }
    }

    declare     export class CognitoIdentityCredentials mixins Credentials {
        constructor(params: CognitoIdentity.CognitoIdentityCredentialsParams): this
    }
    declare interface Logger {
        debug: (msg: string) => any
    }
    declare     export interface HttpOptions {
        proxy?: string,
            agent?: any,
            timeout?: number,
            xhrAsync?: boolean,
            xhrWithCredentials?: boolean
    }
    declare     export class Endpoint {
        constructor(endpoint: string): this;
        host: string;
        hostname: string;
        href: string;
        port: number;
        protocol: string
    }
    declare type AwsError = {
        stack: string
    } & AV$Error

    declare     export interface RetryDelayOption {
        base?: number,
            customBackoff?: (retryCount: number) => number
    }
    declare     export interface Ebs {
        SnapshotId?: string,
            VolumeSize?: number,
            VolumeType?: string,
            DeleteOnTermination?: boolean,
            Iops?: number,
            Encrypted?: boolean
    }
    declare     export interface BlockDeviceMapping {
        VirtualName?: string,
            DeviceName: string,
            Ebs?: Ebs,
            NoDevice?: boolean
    }
    declare     export interface InstanceMonitoring {
        SpotPrice?: string,
            Enabled?: boolean
    }
    declare interface Filter {
        getGui(): any,
            isFilterActive(): boolean,
            doesFilterPass(params: any): boolean,
            afterGuiAttached(params?: {
                hidePopup?: Function
            }): void,
            onNewRowsLoaded(): void
    }
    declare     export interface StepAdjustment {
        scalingAdjustment: number,
            metricIntervalLowerBound?: number,
            metricIntervalUpperBound?: number
    }

    /**
     * A _tag_ is a label that can be attached to any task in Asana. It exists in a
     * single workspace or organization.

    Tags have some metadata associated with them, but it is possible that we will
    simplify them in the future so it is not encouraged to rely too heavily on it.
    Unlike projects, tags do not provide any ordering on the tasks they
    are associated with.
     * @class  * 
     * @param  The API dispatcher
    */
    declare type Tags = {

        /**
         * * Creates a new tag in a workspace or organization.
         * *
         * Every tag is required to be created in a specific workspace or
         * organization, and this cannot be changed once set. Note that you can use
         * the `workspace` parameter regardless of whether or not it is an
         * organization.
         *
         * Returns the full record of the newly created tag.
         * @param {Object} data Data for the request
         * @param {String} data.workspace The workspace or organization to create the tag in.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        create(
            data: Tags$Type & {
                workspace: string
            },
            dispatchOptions?: any): AV$Promise<Tags$Type>,

        /**
         * * Creates a new tag in a workspace or organization.
         * *
         * Every tag is required to be created in a specific workspace or
         * organization, and this cannot be changed once set. Note that you can use
         * the `workspace` parameter regardless of whether or not it is an
         * organization.
         *
         * Returns the full record of the newly created tag.
         * @param {Number} workspace The workspace or organization to create the tag in.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        createInWorkspace(
            workspace: number,
            data: Tags$Type,
            dispatchOptions?: any): AV$Promise<Tags$Type>,

        /**
         * * Returns the complete tag record for a single tag.
         *    * @param {Number} tag The tag to get.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The requested resource
         * @param tag 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findById(
            tag: number,
            params?: resources$Params,
            dispatchOptions?: any): AV$Promise<Tags$Type>,

        /**
         * * Updates the properties of a tag. Only the fields provided in the `data`
         * * block will be updated; any unspecified fields will remain unchanged.
         *
         * When using this method, it is best to specify only those fields you wish
         * to change, or else you may overwrite changes made by another user since
         * you last retrieved the task.
         *
         * Returns the complete updated tag record.
         * @param {Number} tag The tag to update.
         * @param {Object} data Data for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param data 
         * @param dispatchOptions ?
         * @return  
         */
        update(tag: number, data: Tags$Type, dispatchOptions?: any): AV$Promise<Tags$Type>,

        /**
         * * A specific, existing tag can be deleted by making a DELETE request
         * * on the URL for that tag.
         *
         * Returns an empty data record.
         * @param {Number} tag The tag to delete.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param dispatchOptions ?
         * @return  
         */
        delete(tag: number, dispatchOptions?: any): AV$Promise<void>,

        /**
         * * Returns the compact tag records for some filtered set of tags.
         * * Use one or more of the parameters provided to filter the tags returned.
         * @param {Object} [params] Parameters for the request
         * @param {String} [params.workspace] The workspace or organization to filter tags on.
         * @param {String} [params.team] The team to filter tags on.
         * @param {Boolean} [params.archived] Only return tags whose `archived` field takes on the value of
         * this parameter.
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findAll(
            params?: Tags$FindAllParams,
            dispatchOptions?: any): AV$Promise<resources$ResourceList<Tags$Type >> ,

        /**
         * * Returns the compact tag records for all tags in the workspace.
         *    * @param {Number} workspace The workspace or organization to find tags in.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param workspace 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        findByWorkspace(
            workspace: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): AV$Promise<resources$ResourceList<Tags$Type >> ,

        /**
         * * Returns the compact task records for all tasks with the given tag.
         * * Tasks can have more than one tag at a time.
         * @param {Number} tag The tag to fetch tasks from.
         * @param {Object} [params] Parameters for the request
         * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
         * @return {Promise} The response from the API
         * @param tag 
         * @param params ?
         * @param dispatchOptions ?
         * @return  
         */
        getTasksWithTag(
            tag: number,
            params?: resources$PaginationParams,
            dispatchOptions?: any): AV$Promise<resources$ResourceList<Tasks$Type >>
    } & resources$Resource

    declare     export interface Services {
        autoscaling?: any,
            cloudformation?: any,
            cloudfront?: any,
            cloudsearch?: any,
            cloudsearchdomain?: any,
            cloudtrail?: any,
            cloudwatch?: any,
            cloudwatchlogs?: any,
            cognitoidentity?: any,
            cognitosync?: any,
            datapipeline?: any,
            directconnect?: any,
            dynamodb?: any,
            ec2?: any,
            ecs?: any,
            elasticache?: any,
            elasticbeanstalk?: any,
            elastictranscoder?: any,
            elb?: any,
            emr?: any,
            glacier?: any,
            httpOptions?: HttpOptions,
            iam?: any,
            importexport?: any,
            kinesis?: any,
            opsworks?: any,
            rds?: any,
            redshift?: any,
            route53?: any,
            route53domains?: any,
            s3?: any,
            ses?: any,
            simpledb?: any,
            sns?: any,
            sqs?: any,
            storagegateway?: any,
            sts?: any,
            support?: any,
            swf?: any
    }
    declare     export type ClientConfigPartial = {
        credentials?: auth$Credentials,
        region?: string,
        accessKeyId?: string,
        secretAccessKey?: string,
        computeChecksums?: boolean,
        convertResponseTypes?: boolean,
        logger?: Logger,
        maxRedirects?: number,
        maxRetries?: number,
        paramValidation?: boolean,
        s3ForcePathStyle?: boolean,
        apiVersion?: any,
        apiVersions?: Services,
        signatureVersion?: string,
        sslEnabled?: boolean,
        systemClockOffset?: number
    } & Services

    declare     export type ClientConfig = {
        update?: (options: ClientConfigPartial, allUnknownKeys?: boolean) => void,
        getCredentials?: (callback: (err?: any) => void) => void,
        loadFromPath?: (path: string) => void,
        credentials: auth$Credentials,
        region: string
    } & ClientConfigPartial

    declare module 'CloudFormation' {
        declare         export interface CancelUpdateStackParams {
            StackName: string
        }
        declare         export interface ContinueUpdateRollbackParams {
            StackName: string
        }
        declare         export interface CreateChangeSetParams {
            StackName: string,
                TemplateBody?: string,
                TemplateURL?: string,
                UsePreviousTemplate?: boolean,
                Parameters?: CloudFormation.Parameter[],
                Capabilities?: string[],
                ResourceTypes?: string[],
                NotificationARNs?: string[],
                Tags?: CloudFormation.Tag[],
                ChangeSetName: string,
                ClientToken?: string,
                Description?: string
        }
        declare         export interface CreateStackParams {
            StackName: string,
                TemplateBody?: string,
                TemplateURL?: string,
                Parameters?: CloudFormation.Parameter[],
                DisableRollback?: boolean,
                TimeoutInMinutes?: number,
                NotificationARNs?: string[],
                Capabilities?: string[],
                ResourceTypes?: string[],
                OnFailure?: string[],
                StackPolicyBody?: string[],
                StackPolicyURL?: string[],
                Tags?: CloudFormation.Tag[]
        }
        declare         export interface DeleteChangeSetParams {
            ChangeSetName: string,
                StackName?: string
        }
        declare         export interface DeleteStackParams {
            StackName: string,
                RetainResources?: string[]
        }
        declare         export interface DescribeAccountLimitsParams {
            NextToken?: string
        }
        declare         export interface DescribeChangeSetParams {
            ChangeSetName: string,
                StackName?: string,
                NextToken?: string
        }
        declare         export interface DescribeStackEventsParams {
            StackName?: string,
                NextToken?: string
        }
        declare         export interface DescribeStackResourceParams {
            StackName: string,
                LogicalResourceId: string
        }
        declare         export interface DescribeStackResourcesParams {
            StackName?: string,
                LogicalResourceId?: string,
                PhysicalResourceId?: string
        }
        declare         export interface DescribeStacksParams {
            StackName?: string,
                NextToken?: string
        }
        declare         export interface EstimateTemplateCostParams {
            TemplateBody?: string,
                TemplateURL?: string,
                Parameters?: CloudFormation.Parameter[]
        }
        declare         export interface ExecuteChangeSetParams {
            ChangeSetName: string,
                StackName?: string
        }
        declare         export interface GetStackPolicyParams {
            StackName: string
        }
        declare         export interface GetTemplateParams {
            StackName: string
        }
        declare         export interface GetTemplateSummaryParams {
            TemplateBody?: string,
                TemplateURL?: string,
                StackName?: string
        }
        declare         export interface ListChangeSetsParams {
            StackName: string,
                NextToken?: string
        }
        declare         export interface ListStackResourcesParams {
            StackName: string,
                NextToken?: string
        }
        declare         export interface ListStacksParams {
            NextToken?: string,
                StackStatusFilter?: string[]
        }
        declare         export interface SetStackPolicyParams {
            StackName: string,
                StackPolicyBody?: string,
                StackPolicyURL?: string
        }
        declare         export interface SignalResourceParams {
            StackName: string,
                LogicalResourceId: string,
                UniqueId: string,
                Status: string
        }
        declare         export interface UpdateStackParams {
            StackName: string,
                TemplateBody?: string,
                TemplateURL?: string,
                UsePreviousTemplate?: boolean,
                StackPolicyDuringUpdateBody?: string,
                StackPolicyDuringUpdateURL?: string,
                Parameters?: CloudFormation.Parameter[],
                Capabilities?: string[],
                ResourceTypes?: string[],
                StackPolicyBody?: string,
                StackPolicyURL?: string,
                NotificationARNs?: string[],
                Tags?: CloudFormation.Tag[]
        }
        declare         export interface ValidateTemplateParams {
            TemplateBody?: string,
                TemplateURL?: string
        }
        declare         export interface WaitForParams {
            StackName: string,
                NextToken?: string
        }
        declare         export interface Options {
            recurse: boolean
        }
        declare         export interface Parameter {
            ParameterKey: string,
                ParameterValue: string,
                UsePreviousValue?: boolean
        }
        declare         export interface Tag {
            Key: string,
                Value: string
        }
    }

    declare module 'Lambda' {
        declare         export interface AddPermissionParams {
            Action: string,
                FunctionName: string,
                Principal: string,
                StatementId: string,
                Qualifier?: string,
                SourceAccount?: string,
                SourceArn?: string
        }
        declare         export interface CreateAliasParams {
            FunctionName: string,
                FunctionVersion: string,
                Name: string,
                Description?: string
        }
        declare         export interface CreateEventSourceMappingParams {
            EventSourceArn: string,
                FunctionName: string,
                StartingPosition: string,
                BatchSize?: number,
                Enabled?: boolean
        }
        declare         export interface CreateFunctionParams {
            Code: {
                    S3Bucket?: string,
                    S3Key?: string,
                    S3ObjectVersion?: string,
                    ZipFile?: any
                },
                FunctionName: string,
                Handler: string,
                Role: string,
                Runtime: string,
                Description?: string,
                MemorySize?: number,
                Publish?: boolean,
                Timeout?: number,
                VpcConfig?: {
                    SecurityGroupIds?: string[],
                    SubnetIds?: string[]
                }
        }
        declare         export interface DeleteAliasParams {
            FunctionName: string,
                Name: string
        }
        declare         export interface DeleteEventSourceMappingParams {
            UUID: string
        }
        declare         export interface DeleteFunctionParams {
            FunctionName: string,
                Qualifier?: string
        }
        declare         export interface GetAliasParams {
            FunctionName: string,
                Name: string
        }
        declare         export interface GetEventSourceMappingParams {
            UUID: string
        }
        declare         export interface GetFunctionParams {
            FunctionName: string,
                Qualifier?: string
        }
        declare         export interface GetFunctionConfigurationParams {
            FunctionName: string,
                Qualifier?: string
        }
        declare         export interface GetPolicyParams {
            FunctionName: string,
                Qualifier?: string
        }
        declare         export interface InvokeParams {
            FunctionName: string,
                ClientContext?: string,
                InvocationType?: string,
                LogType?: string,
                Payload?: any,
                Qualifier?: string
        }
        declare         export interface ListAliasesParams {
            FunctionName: string,
                FunctionVersion?: string,
                Marker?: string,
                MaxItems?: number
        }
        declare         export interface ListEventSourceMappingsParams {
            EventSourceArn?: string,
                FunctionName?: string,
                Marker?: string,
                MaxItems?: number
        }
        declare         export interface ListFunctionsParams {
            Marker?: string,
                MaxItems?: number
        }
        declare         export interface ListVersionsByFunctionParams {
            FunctionName: string,
                Marker?: string,
                MaxItems?: number
        }
        declare         export interface PublishVersionParams {
            FunctionName: string,
                CodeSha256?: string,
                Description?: string
        }
        declare         export interface RemovePermissionParams {
            FunctionName: string,
                StatementId: string,
                Qualifier?: string
        }
        declare         export interface UpdateAliasParams {
            FunctionName: string,
                Name: string,
                Description?: string,
                FunctionVersion?: string
        }
        declare         export interface UpdateEventSourceMappingParams {
            UUID: string,
                BatchSize?: number,
                Enabled?: boolean,
                FunctionName?: string
        }
        declare         export interface UpdateFunctionCodeParams {
            FunctionName: string,
                Publish?: boolean,
                S3Bucket?: string,
                S3Key?: string,
                S3ObjectVersion?: string,
                ZipFile?: any
        }
        declare         export interface UpdateFunctionConfigurationParams {
            FunctionName: string,
                Description?: string,
                Handler?: string,
                MemorySize?: number,
                Role?: string,
                Timeout?: number,
                VpcConfig?: {
                    SecurityGroupIds?: string[],
                    SubnetIds?: string[]
                }
        }
    }

    declare module 'AutoScaling' {
        declare         export interface AutoScalingOptions {
            params?: any,
                endpoint?: string,
                accessKeyId?: string,
                secretAccessKey?: string,
                sessionToken?: auth$Credentials,
                credentials?: auth$Credentials,
                credentialProvider?: any,
                region?: string,
                maxRetries?: number,
                maxRedirects?: number,
                sslEnabled?: boolean,
                paramValidation?: boolean,
                computeChecksums?: boolean,
                convertResponseTypes?: boolean,
                correctClockSkew?: boolean,
                s3ForcePathStyle?: boolean,
                s3BucketEndpoint?: boolean,
                s3DisableBodySigning?: boolean,
                retryDelayOptions?: RetryDelayOption,
                httpOptions?: HttpOptions,
                apiVersion?: string,
                apiVersions?: {
                    [serviceName: string]: string
                },
                logger?: Logger,
                systemClockOffset?: number,
                signatureVersion?: string,
                signatureCache?: boolean
        }
        declare         export interface AttachInstancesParams {
            AutoScalingGroupName: string,
                InstanceIds: string[]
        }
        declare         export interface AttachLoadBalancersParams {
            AutoScalingGroupName: string,
                LoadBalancerNames: string[]
        }
        declare         export interface AttachLoadBalancerTargetGroupsParams {
            AutoScalingGroupName: string,
                TargetGroupARNs: string[]
        }
        declare         export interface CompleteLifecycleActionParams {
            AutoScalingGroupName: string,
                LifecycleActionResult: string,
                LifecycleHookName: string,
                lifecycleActionToken?: string,
                InstanceId?: string
        }
        declare         export interface CreateAutoScalingGroupParams {
            AutoScalingGroupName: string,
                MinSize: number,
                MaxSize: number,
                LaunchConfigurationName?: string,
                InstanceId?: string,
                DesiredCapacity?: number,
                DefaultCooldown?: number,
                AvailabilityZones?: string[],
                LoadBalancerNames?: string[],
                TargetGroupARNs?: string[],
                HealthCheckType?: string,
                HealthCheckGracePeriod?: number,
                PlacementGroup?: string,
                VPCZoneIdentifier?: string,
                TerminationPolicies?: string,
                NewInstancesProtectedFromScaleIn?: boolean,
                Tags?: resources$Tags
        }
        declare         export interface CreateLaunchConfigurationParams {
            LaunchConfigurationName: string,
                AssociatePublicIpAddress?: boolean,
                ImageId?: string,
                KeyName?: string,
                SecurityGroups?: string[],
                ClassicLinkVPCId?: string,
                ClassicLinkVPCSecurityGroups?: string[],
                UserData?: string,
                InstanceId?: string,
                InstanceType?: string,
                KernelId?: string,
                RamdiskId?: string,
                BlockDeviceMappings?: BlockDeviceMapping[],
                InstanceMonitoring?: InstanceMonitoring,
                SpotPrice?: string,
                IamInstanceProfile?: string,
                EbsOptimized?: boolean,
                PlacementTenancy?: string
        }
        declare         export interface CreateOrUpdateTagsParams {
            Tags: resources$Tags[]
        }
        declare         export interface DeleteAutoScalingGroupParams {
            AutoScalingGroupName: string,
                ForceDelete?: boolean
        }
        declare         export interface DeleteLaunchConfigurationParams {
            LaunchConfigurationName: string
        }
        declare         export interface DeleteLifecycleHookParams {
            AutoScalingGroupName: string,
                LifecycleHookName: string
        }
        declare         export interface DeleteNotificationConfigurationParams {
            AutoScalingGroupName: string,
                TopicARN: string
        }
        declare         export interface DeletePolicyParams {
            PolicyName: string,
                AutoScalingGroupName?: string
        }
        declare         export interface DeleteScheduledActionParams {
            AutoScalingGroupName: string,
                ScheduledActionName: string
        }
        declare         export interface DeleteTagsParams {
            Tags: resources$Tags[]
        }
        declare         export interface DescribeAutoScalingGroupsParams {
            AutoScalingGroupName?: string,
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeAutoScalingInstancesParams {
            InstanceIds?: string[],
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeLaunchConfigurationsParams {
            LaunchConfigurationNames?: string[],
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeLifecycleHooksParams {
            AutoScalingGroupName: string,
                LifecycleHookNames?: string[]
        }
        declare         export interface DescribeLoadBalancersParams {
            AutoScalingGroupName: string,
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeLoadBalancerTargetGroupsParams {
            AutoScalingGroupName: string,
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeNotificationConfigurationsParams {
            AutoScalingGroupName?: string,
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribePoliciesParams {
            AutoScalingGroupName?: string,
                PolicyNames?: string[],
                PolicyTypes?: string[],
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeScalingActivitiesParams {
            AutoScalingGroupName?: string,
                ActivityIds?: string[],
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeScheduledActionsParams {
            AutoScalingGroupName?: string,
                ScheduledActionNames?: string[],
                StartTime?: Date,
                EndTime?: Date,
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DescribeTagsParams {
            Filters?: Filter[],
                NextToken?: string,
                MaxRecords?: number
        }
        declare         export interface DetachInstancesParams {
            AutoScalingGroupName: string,
                ShouldDecrementDesiredCapacity: boolean,
                InstanceIds?: string[]
        }
        declare         export interface DetachLoadBalancersParams {
            AutoScalingGroupName: string,
                LoadBalancerNames: string
        }
        declare         export interface DetachLoadBalancerTargetGroupsParams {
            AutoScalingGroupName: string,
                TargetGroupARNs: string[]
        }
        declare         export interface DisableMetricsCollectionParams {
            AutoScalingGroupName: string,
                Metrics?: string[]
        }
        declare         export interface EnableMetricsCollectionParams {
            AutoScalingGroupName: string,
                Granularity: string,
                Metrics?: string[]
        }
        declare         export interface EnterStandbyParams {
            AutoScalingGroupName: string,
                ShouldDecrementDesiredCapacity: boolean,
                InstanceIds?: string[]
        }
        declare         export interface ExecutePolicyParams {
            PolicyName: string,
                AutoScalingGroupName?: string,
                HonorCooldown?: boolean,
                MetricValue?: number,
                BreachThreshold?: number
        }
        declare         export interface ExitStandbyParams {
            AutoScalingGroupName: string,
                InstanceIds?: string[]
        }
        declare         export interface PutLifecycleHookParams {
            AutoScalingGroupName: string,
                LifecycleHookName: string,
                LifecycleTransition?: string,
                RoleARN?: string,
                NotificationTargetARN?: string,
                NotificationMetadata?: string,
                HeartbeatTimeout?: number,
                DefaultResult?: string
        }
        declare         export interface PutNotificationConfigurationParams {
            AutoScalingGroupName: string,
                NotificationTypes: string[],
                TopicARN: string
        }
        declare         export interface PutScalingPolicyParams {
            AutoScalingGroupName: string,
                AdjustmentType: string,
                PolicyName: string,
                PolicyType?: string,
                MinAdjustmentStep?: number,
                MinAdjustmentMagnitude?: number,
                ScalingAdjustment?: number,
                Cooldown?: number,
                MetricAggregationType?: string,
                StepAdjustments?: StepAdjustment[],
                EstimatedInstanceWarmup: number
        }
        declare         export interface PutScheduledUpdateGroupActionParams {
            AutoScalingGroupName: string,
                ScheduledActionName: string,
                Time?: Date,
                StartTime?: Date,
                EndTime?: Date,
                Recurrence?: string,
                MinSize?: number,
                MaxSize?: number,
                DesiredCapacity?: number
        }
        declare         export interface RecordLifecycleActionHeartbeatParams {
            AutoScalingGroupName: string,
                LifecycleHookName: string,
                LifecycleActionToken?: string,
                InstanceId?: string
        }
        declare         export interface ResumeProcessesParams {
            AutoScalingGroupName: string,
                ScalingProcesses?: string[]
        }
        declare         export interface SetDesiredCapacityParams {
            AutoScalingGroupName: string,
                DesiredCapacity: number,
                HonorCooldown?: boolean
        }
        declare         export interface SetInstanceHealthParams {
            HealthStatus: string,
                InstanceId: string,
                ShouldRespectGracePeriod?: boolean
        }
        declare         export interface SetInstanceProtectionParams {
            AutoScalingGroupName: string,
                InstanceIds: string[],
                ProtectedFromScaleIn: boolean
        }
        declare         export interface SuspendProcessesParams {
            AutoScalingGroupName: string,
                ScalingProcesses?: string[]
        }
        declare         export interface TerminateInstanceInAutoScalingGroupParams {
            InstanceId: string,
                ShouldDecrementDesiredCapacity: boolean
        }
        declare         export interface UpdateAutoScalingGroupParams {
            AutoScalingGroupName: string,
                LaunchConfigurationName: string,
                MinSize: number,
                MaxSize: number,
                DesiredCapacity: number,
                DefaultCooldown: number,
                AvailabilityZones: string[],
                HealthCheckType: string,
                HealthCheckGracePeriod: number,
                PlacementGroup: string,
                VPCZoneIdentifier: string,
                TerminationPolicies: string[],
                NewInstancesProtectedFromScaleIn?: boolean
        }
    }

    declare module 'SQS' {
        declare         export interface SqsOptions {
            params?: any,
                endpoint?: string,
                accessKeyId?: string,
                secretAccessKey?: string,
                sessionToken?: auth$Credentials,
                credentials?: auth$Credentials,
                credentialProvider?: any,
                region?: string,
                maxRetries?: number,
                maxRedirects?: number,
                sslEnabled?: boolean,
                paramValidation?: boolean,
                computeChecksums?: boolean,
                convertResponseTypes?: boolean,
                correctClockSkew?: boolean,
                s3ForcePathStyle?: boolean,
                s3BucketEndpoint?: boolean,
                httpOptions?: HttpOptions,
                apiVersion?: string,
                apiVersions?: {
                    [serviceName: string]: string
                },
                logger?: Logger,
                systemClockOffset?: number,
                signatureVersion?: string,
                signatureCache?: boolean
        }
        declare         export interface AddPermissionParams {
            Action: string,
                FunctionName: string,
                Principal: string,
                StatementId: string,
                Qualifier?: string,
                SourceAccount?: string,
                SourceArn?: string
        }
        declare         export interface ChangeMessageVisibilityParams {
            QueueUrl: string,
                ReceiptHandle: string,
                VisibilityTimeout: number
        }
        declare         export interface ChangeMessageVisibilityBatchParams {
            QueueUrl: string,
                Entries: {
                    Id: string,
                    ReceiptHandle: string,
                    VisibilityTimeout?: number
                }[]
        }
        declare         export interface ChangeMessageVisibilityBatchResponse {
            Successful: {
                    Id: string
                }[],
                Failed: BatchResultErrorEntry[]
        }
        declare         export interface SendMessageParams {
            QueueUrl?: string,
                MessageBody: string,
                DelaySeconds?: number,
                MessageAttributes?: {
                    [name: string]: MessageAttribute
                }
        }
        declare         export interface ReceiveMessageParams {
            QueueUrl: string,
                MaxNumberOfMessages?: number,
                VisibilityTimeout?: number,
                AttributeNames?: string[],
                MessageAttributeNames?: string[],
                WaitTimeSeconds?: number
        }
        declare         export interface DeleteMessageBatchParams {
            QueueUrl: string,
                Entries: DeleteMessageBatchRequestEntry[]
        }
        declare         export interface DeleteMessageBatchRequestEntry {
            Id: string,
                ReceiptHandle: string
        }
        declare         export interface DeleteMessageParams {
            QueueUrl: string,
                ReceiptHandle: string
        }
        declare         export interface SendMessageBatchParams {
            QueueUrl: string,
                Entries: SendMessageBatchRequestEntry[]
        }
        declare         export interface SendMessageBatchRequestEntry {
            Id: string,
                MessageBody: string,
                DelaySeconds?: number,
                MessageAttributes?: {
                    [name: string]: MessageAttribute
                }
        }
        declare         export interface CreateQueueParams {
            QueueName: string,
                Attributes: QueueAttributes
        }
        declare         export interface QueueAttributes {
            [name: string]: any,
            DelaySeconds?: number,
                MaximumMessageSize?: number,
                MessageRetentionPeriod?: number,
                Policy?: any,
                ReceiveMessageWaitTimeSeconds?: number,
                VisibilityTimeout?: number,
                RedrivePolicy?: any
        }
        declare         export interface GetQueueAttributesParams {
            QueueUrl: string,
                AttributeNames: string[]
        }
        declare         export interface GetQueueAttributesResult {
            Attributes: {
                [name: string]: string
            }
        }
        declare         export interface GetQueueUrlParams {
            QueueName: string,
                QueueOwnerAWSAccountId?: string
        }
        declare         export interface SendMessageResult {
            MessageId: string,
                MD5OfMessageBody: string,
                MD5OfMessageAttributes: string
        }
        declare         export interface ReceiveMessageResult {
            Messages: Message[]
        }
        declare         export interface Message {
            seq: number,
                type: string
        }
        declare         export interface MessageAttribute {
            StringValue?: string,
                BinaryValue?: any,
                StringListValues?: string[],
                BinaryListValues?: any[],
                DataType: string
        }
        declare         export interface DeleteMessageBatchResult {
            Successful: DeleteMessageBatchResultEntry[],
                Failed: BatchResultErrorEntry[]
        }
        declare         export interface DeleteMessageBatchResultEntry {
            Id: string
        }
        declare         export interface BatchResultErrorEntry {
            Id: string,
                Code: string,
                Message?: string,
                SenderFault: boolean
        }
        declare         export interface SendMessageBatchResult {
            Successful: SendMessageBatchResultEntry[],
                Failed: BatchResultErrorEntry[]
        }
        declare         export interface SendMessageBatchResultEntry {
            Id: string,
                MessageId: string,
                MD5OfMessageBody: string,
                MD5OfMessageAttributes: string
        }
        declare         export interface CreateQueueResult {
            QueueUrl: string
        }
        declare         export interface SetQueueAttributesParams {
            QueueUrl: string,
                Attributes: QueueAttributes
        }
    }

    declare module 'SES' {

        /**
         * Represents the client portion of the response.
         */
        declare         export interface Client {
            paypal_sdk_version: string,
                environment: string,
                platform: string,
                product_name: string
        }
        declare         export interface SendEmailRequest {
            Source: string,
                Destination: Destination,
                Message: Message,
                ReplyToAddresses: string[],
                ReturnPath: string
        }
        declare         export class Destination {
            ToAddresses: string[];
            CcAddresses: string[];
            BccAddresses: string[]
        }
        declare         export class Message {
            Subject: Content;
            Body: Body
        }
        declare         export class Content {
            Data: string;
            Charset: string
        }
        declare         export class Body {
            Text: Content;
            Html: Content
        }
        declare         export class SendEmailResult {
            MessageId: string
        }
    }

    declare     export class SNS {
        constructor(options?: any): this;
        endpoint: Endpoint;
        publish(request: Sns.PublishRequest, callback: (err: any, data: any) => void): void
    }
    declare     export class SWF {
        constructor(options?: any): this;
        endpoint: Endpoint;
        countClosedWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
        countOpenWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
        countPendingActivityTasks(params: any, callback: (err: any, data: any) => void): void;
        countPendingDecisionTasks(params: any, callback: (err: any, data: any) => void): void;
        deprecateActivityType(params: any, callback: (err: any, data: any) => void): void;
        deprecateDomain(params: any, callback: (err: any, data: any) => void): void;
        deprecateWorkflowType(params: any, callback: (err: any, data: any) => void): void;
        describeActivityType(params: any, callback: (err: any, data: any) => void): void;
        describeDomain(params: any, callback: (err: any, data: any) => void): void;
        describeWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
        describeWorkflowType(params: any, callback: (err: any, data: any) => void): void;
        getWorkflowExecutionHistory(params: any, callback: (err: any, data: any) => void): void;
        listActivityTypes(params: any, callback: (err: any, data: any) => void): void;
        listClosedWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
        listDomains(params: any, callback: (err: any, data: any) => void): void;
        listOpenWorkflowExecutions(params: any, callback: (err: any, data: any) => void): void;
        listWorkflowTypes(params: any, callback: (err: any, data: any) => void): void;
        pollForActivityTask(params: any, callback: (err: any, data: Swf.ActivityTask) => void): void;
        pollForDecisionTask(params: any, callback: (err: any, data: Swf.DecisionTask) => void): void;
        recordActivityTaskHeartbeat(params: any, callback: (err: any, data: any) => void): void;
        registerActivityType(params: any, callback: (err: any, data: any) => void): void;
        registerDomain(params: any, callback: (err: any, data: any) => void): void;
        registerWorkflowType(params: any, callback: (err: any, data: any) => void): void;
        requestCancelWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
        respondActivityTaskCanceled(
            params: Swf.RespondActivityTaskCanceledRequest,
            callback: (err: any, data: any) => void): void;
        respondActivityTaskCompleted(
            params: Swf.RespondActivityTaskCompletedRequest,
            callback: (err: any, data: any) => void): void;
        respondActivityTaskFailed(
            params: Swf.RespondActivityTaskFailedRequest,
            callback: (err: any, data: any) => void): void;
        respondDecisionTaskCompleted(
            params: Swf.RespondDecisionTaskCompletedRequest,
            callback: (err: any, data: any) => void): void;
        signalWorkflowExecution(params: any, callback: (err: any, data: any) => void): void;
        startWorkflowExecution(
            params: any,
            callback: (err: any, data: Swf.StartWorkflowExecutionResult) => void): void;
        terminateWorkflowExecution(params: any, callback: (err: any, data: any) => void): void
    }
    declare     export class S3 {
        constructor(options?: any): this;
        endpoint: Endpoint;
        getObject(
            params: s3.GetObjectRequest,
            callback?: (err: AV$Error, data: any) => void): any;
        putObject(
            params: s3.PutObjectRequest,
            callback?: (err: AV$Error, data: any) => void): any;
        copyObject(
            params: s3.CopyObjectRequest,
            callback?: (err: AV$Error, data: any) => void): any;
        deleteObject(
            params: s3.DeleteObjectRequest,
            callback: (err: AV$Error, data: any) => void): void;
        headObject(
            params: s3.HeadObjectRequest,
            callback: (err: AV$Error, data: any) => void): void;
        getSignedUrl(operation: string, params: any): string;
        getSignedUrl(
            operation: string,
            params: any,
            callback: (err: AV$Error, url: string) => void): void;
        upload(
            params?: s3.PutObjectRequest,
            options?: s3.UploadOptions,
            callback?: (err: AV$Error, data: any) => void): void;
        listObjects(
            params: s3.ListObjectRequest,
            callback: (err: AV$Error, data: s3.ListObjectResponse) => void): void;
        listObjectsV2(
            params: s3.ListObjectV2Request,
            callback: (err: AV$Error, data: s3.ListObjectV2Response) => void): void;
        waitFor(
            state: string,
            params: s3.HeadObjectRequest,
            callback: (err: AV$Error, data: any) => void): void;
        createMultipartUpload(params: any, callback: (err: AV$Error, data: any) => void): void;
        uploadPart(params: any, callback: (err: AV$Error, data: any) => void): void;
        listParts(params: any, callback: (err: AV$Error, data: any) => void): void;
        completeMultipartUpload(params: any, callback: (err: AV$Error, data: any) => void): void
    }
    declare     export class STS {
        constructor(options?: any): this;
        endpoint: Endpoint;

        /**
         * Returns a set of temporary security credentials (consisting of an access key ID, a secret access key, and a security token) that you can use to access AWS resources that you might not normally have access to.
         */
        assumeRole(
            params: sts.AssumeRoleParams,
            callback: (err: any, data: sts.AssumeRoleCallbackData) => void): void;

        /**
         * Returns a set of temporary security credentials for users who have been authenticated via a SAML authentication response.
         */
        assumeRoleWithSAML(
            params: sts.AssumeRoleWithSAMLParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Returns a set of temporary security credentials for users who have been authenticated in a mobile or web application with a web identity provider, such as Amazon Cognito, Login with Amazon, Facebook, Google, or any OpenID Connect-compatible identity provider.
         */
        assumeRoleWithWebIdentity(
            params: sts.AssumeRoleWithWebIdentityParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Creates a credentials object from STS response data containing credentials information.
         */
        credentialsFrom(
            params: sts.CredentialsFromParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Decodes additional information about the authorization status of a request from an encoded message returned in response to an AWS request.
         */
        decodeAuthorizationMessage(
            params: sts.DecodeAuthorizationMessageParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Returns details about the IAM identity whose credentials are used to call the API.
         */
        getCallerIdentity(params: {}, callback: (err: any, data: any) => void): void;

        /**
         * Returns a set of temporary security credentials (consisting of an access key ID, a secret access key, and a security token) for a federated user.
         */
        getFederationToken(
            params: sts.GetFederationTokenParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Returns a set of temporary credentials for an AWS account or IAM user.
         */
        getSessionToken(
            params: sts.GetSessionTokenParams,
            callback: (err: any, data: any) => void): void
    }
    declare     export class ECS {
        constructor(options?: any): this;
        endpoint: Endpoint;

        /**
         * Runs and maintains a desired number of tasks from a specified task definition. If the number of tasks running in a service drops below desiredCount, Amazon ECS spawns another instantiation of the task in the specified cluster. To update an existing service, see UpdateService.
         */
        createService(
            params: ecs.CreateServicesParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Describes one or more of your clusters.
         */
        describeClusters(
            params: ecs.DescribeClustersParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Describes the specified services running in your cluster.
         */
        describeServices(
            params: ecs.DescribeServicesParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Describes a specified task or tasks.
         */
        describeTasks(params: ecs.DescribeTasksParams, callback: (err: any, data: any) => void): void;

        /**
         * Describes a task definition. You can specify a family and revision to find information about a specific task definition, or you can simply specify the family to find the latest ACTIVE revision in that family.
         */
        describeTaskDefinition(
            params: ecs.DescribeTaskDefinitionParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Registers a new task definition from the supplied family and containerDefinitions. Optionally, you can add data volumes to your containers with the volumes parameter. For more information about task definition parameters and defaults, see Amazon ECS Task Definitions in the Amazon EC2 Container Service Developer Guide.
         */
        registerTaskDefinition(
            params: ecs.RegisterTaskDefinitionParams,
            callback: (err: any, data: any) => void): void;

        /**
         * Modifies the desired count, deployment configuration, or task definition used in a service.
         */
        updateService(params: ecs.UpdateServiceParams, callback: (err: any, data: any) => void): void
    }
    declare module 'DynamoDB' {
        declare interface _DDBDC_Generic {
            TableName: string,
                ExpressionAttributeNames?: {
                    [someKey: string]: string
                },
                ReturnConsumedCapacity?: "INDEXES" | "TOTAL" | "NONE"
        }
        declare type _DDBDC_ComparisonOperator = "EQ" |
            "NE" |
            "IN" |
            "LE" |
            "LT" |
            "GE" |
            "GT" |
            "BETWEEN" |
            "NOT_NULL" |
            "NULL" |
            "CONTAINS" |
            "NOT_CONTAINS" |
            "BEGINS_WITH";
        declare type _DDBDC_Keys = {
            [someKey: string]: any
        };
        declare type _DDBDC_KeyComparison = {
            [someKey: string]: {
                AttributeValueList: any[],
                ComparisonOperator: _DDBDC_ComparisonOperator
            }
        };
        declare type _DDBDC_Reader = {
            ConsistentRead?: boolean,
            ProjectionExpression?: string,
            AttributesToGet?: string[]
        } & _DDBDC_Generic

        declare type _DDBDC_Writer = {
            ExpressionAttributeValues?: _DDBDC_Keys,
            ReturnItemCollectionMetrics?: "SIZE" | "NONE",
            ReturnValues?: "NONE" |
                "ALL_OLD" |
                "UPDATED_OLD" |
                "ALL_NEW" |
                "UPDATED_NEW",
            ConditionExpression?: string,
            ConditionalOperator?: "AND" | "OR",
            Expected?: {
                [someKey: string]: {
                    AttributeValueList?: any[],
                    ComparisonOperator?: _DDBDC_ComparisonOperator,
                    Exists: boolean,
                    Value?: any
                }
            }
        } & _DDBDC_Generic

        declare type UpdateParam = {
            Key: _DDBDC_Keys,
            UpdateExpression?: string,
            AttributeUpdates?: {
                [someKey: string]: {
                    Action: "PUT" | "ADD" | "DELETE",
                    Value: any
                }
            }
        } & _DDBDC_Writer

        declare type QueryParam = {
            ConditionalOperator?: "AND" | "OR",
            ExclusiveStartKey?: _DDBDC_Keys,
            ExpressionAttributeValues?: _DDBDC_Keys,
            FilterExpression?: string,
            IndexName?: string,
            KeyConditionExpression?: string,
            KeyConditions?: _DDBDC_KeyComparison,
            Limit?: number,
            QueryFilter?: _DDBDC_KeyComparison,
            ScanIndexForward?: boolean,
            Select?: "ALL_ATTRIBUTES" | "ALL_PROJECTED_ATTRIBUTES" | "SPECIFIC_ATTRIBUTES" | "COUNT"
        } & _DDBDC_Reader

        declare type ScanParam = {
            Segment?: number,
            ScanFilter?: _DDBDC_KeyComparison,
            TotalSegments?: number
        } & QueryParam

        declare type GetParam = {
            Key: _DDBDC_Keys
        } & _DDBDC_Reader

        declare type PutParam = {
            Item: _DDBDC_Keys
        } & _DDBDC_Writer

        declare type DeleteParam = {
            Key: _DDBDC_Keys
        } & _DDBDC_Writer

        declare         export class DocumentClient {
            constructor(options?: any): this;
            get(params: GetParam, next: (err: any, data: any) => void): void;
            put(params: PutParam, next: (err: any, data: any) => void): void;
            delete(params: DeleteParam, next: (err: any, data: any) => void): void;
            query(params: QueryParam, next: (err: any, data: any) => void): void;
            scan(params: ScanParam, next: (err: any, data: any) => void): void;
            update(params: UpdateParam, next: (err: any, data: any) => void): void;
            createSet(list: any[], options?: {
                validate?: boolean
            }): {
                values: any[],
                type: string
            };
            batchGet(params: any, next: (err: any, data: any) => void): void;
            batchWrite(params: any, next: (err: any, data: any) => void): void
        }
    }

    declare module 'Swf' {

        /**
         * Represents the client portion of the response.
         */
        declare         export interface Client {
            paypal_sdk_version: string,
                environment: string,
                platform: string,
                product_name: string
        }
        declare         export interface PollForActivityTaskRequest {
            domain?: string,
                taskList?: TaskList,
                identity?: string
        }
        declare         export interface TaskList {
            name?: string
        }
        declare         export interface PollForDecisionTaskRequest {
            domain?: string,
                taskList?: TaskList,
                identity?: string,
                nextPageToken?: string,
                maximumPageSize?: number,
                reverseOrder?: Boolean
        }
        declare         export interface StartWorkflowExecutionRequest {
            domain?: string,
                workflowId?: string,
                workflowType?: WorkflowType,
                taskList?: TaskList,
                input?: string,
                executionStartToCloseTimeout?: string,
                tagList?: string[],
                taskStartToCloseTimeout?: string,
                childPolicy?: string
        }
        declare         export interface WorkflowType {
            name?: string,
                version?: string
        }
        declare         export interface RespondDecisionTaskCompletedRequest {
            taskToken?: string,
                decisions?: Decision[],
                executionContext?: string
        }
        declare         export interface Decision {
            decisionType?: string,
                scheduleActivityTaskDecisionAttributes?: ScheduleActivityTaskDecisionAttributes,
                requestCancelActivityTaskDecisionAttributes?: RequestCancelActivityTaskDecisionAttributes,
                completeWorkflowExecutionDecisionAttributes?: CompleteWorkflowExecutionDecisionAttributes,
                failWorkflowExecutionDecisionAttributes?: FailWorkflowExecutionDecisionAttributes,
                cancelWorkflowExecutionDecisionAttributes?: CancelWorkflowExecutionDecisionAttributes,
                continueAsNewWorkflowExecutionDecisionAttributes?: ContinueAsNewWorkflowExecutionDecisionAttributes,
                recordMarkerDecisionAttributes?: RecordMarkerDecisionAttributes,
                startTimerDecisionAttributes?: StartTimerDecisionAttributes,
                cancelTimerDecisionAttributes?: CancelTimerDecisionAttributes,
                signalExternalWorkflowExecutionDecisionAttributes?: SignalExternalWorkflowExecutionDecisionAttributes,
                requestCancelExternalWorkflowExecutionDecisionAttributes?: RequestCancelExternalWorkflowExecutionDecisionAttributes,
                startChildWorkflowExecutionDecisionAttributes?: StartChildWorkflowExecutionDecisionAttributes
        }
        declare         export interface ScheduleActivityTaskDecisionAttributes {
            activityType?: ActivityType,
                activityId?: string,
                control?: string,
                input?: string,
                scheduleToCloseTimeout?: string,
                taskList?: TaskList,
                scheduleToStartTimeout?: string,
                startToCloseTimeout?: string,
                heartbeatTimeout?: string
        }
        declare         export interface ActivityType {
            name?: string,
                version?: string
        }
        declare         export interface RequestCancelActivityTaskDecisionAttributes {
            activityId?: string
        }
        declare         export interface CompleteWorkflowExecutionDecisionAttributes {
            result?: string
        }
        declare         export interface FailWorkflowExecutionDecisionAttributes {
            reason?: string,
                details?: string
        }
        declare         export interface CancelWorkflowExecutionDecisionAttributes {
            details?: string
        }
        declare         export interface ContinueAsNewWorkflowExecutionDecisionAttributes {
            input?: string,
                executionStartToCloseTimeout?: string,
                taskList?: TaskList,
                taskStartToCloseTimeout?: string,
                childPolicy?: string,
                tagList?: string[],
                workflowTypeVersion?: string
        }
        declare         export interface RecordMarkerDecisionAttributes {
            markerName?: string,
                details?: string
        }
        declare         export interface StartTimerDecisionAttributes {
            timerId?: string,
                control?: string,
                startToFireTimeout?: string
        }
        declare         export interface CancelTimerDecisionAttributes {
            timerId?: string
        }
        declare         export interface SignalExternalWorkflowExecutionDecisionAttributes {
            workflowId?: string,
                runId?: string,
                signalName?: string,
                input?: string,
                control?: string
        }
        declare         export interface RequestCancelExternalWorkflowExecutionDecisionAttributes {
            workflowId?: string,
                runId?: string,
                control?: string
        }
        declare         export interface StartChildWorkflowExecutionDecisionAttributes {
            workflowType?: WorkflowType,
                workflowId?: string,
                control?: string,
                input?: string,
                executionStartToCloseTimeout?: string,
                taskList?: TaskList,
                taskStartToCloseTimeout?: string,
                childPolicy?: string,
                tagList?: string[]
        }
        declare         export interface RespondActivityTaskCompletedRequest {
            taskToken?: string,
                result?: string
        }
        declare         export interface RespondActivityTaskFailedRequest {
            taskToken?: string,
                reason?: string,
                details?: string
        }
        declare         export interface RespondActivityTaskCanceledRequest {
            taskToken?: string,
                details?: string
        }
        declare         export interface DecisionTask {
            taskToken?: string,
                startedEventId?: number,
                workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                events?: HistoryEvent[],
                nextPageToken?: string,
                previousStartedEventId?: number
        }
        declare         export interface WorkflowExecution {
            workflowId?: string,
                runId?: string
        }
        declare         export interface HistoryEvent {
            eventTimestamp?: any,
                eventType?: string,
                eventId?: number,
                workflowExecutionStartedEventAttributes?: WorkflowExecutionStartedEventAttributes,
                workflowExecutionCompletedEventAttributes?: WorkflowExecutionCompletedEventAttributes,
                completeWorkflowExecutionFailedEventAttributes?: CompleteWorkflowExecutionFailedEventAttributes,
                workflowExecutionFailedEventAttributes?: WorkflowExecutionFailedEventAttributes,
                failWorkflowExecutionFailedEventAttributes?: FailWorkflowExecutionFailedEventAttributes,
                workflowExecutionTimedOutEventAttributes?: WorkflowExecutionTimedOutEventAttributes,
                workflowExecutionCanceledEventAttributes?: WorkflowExecutionCanceledEventAttributes,
                cancelWorkflowExecutionFailedEventAttributes?: CancelWorkflowExecutionFailedEventAttributes,
                workflowExecutionContinuedAsNewEventAttributes?: WorkflowExecutionContinuedAsNewEventAttributes,
                continueAsNewWorkflowExecutionFailedEventAttributes?: ContinueAsNewWorkflowExecutionFailedEventAttributes,
                workflowExecutionTerminatedEventAttributes?: WorkflowExecutionTerminatedEventAttributes,
                workflowExecutionCancelRequestedEventAttributes?: WorkflowExecutionCancelRequestedEventAttributes,
                decisionTaskScheduledEventAttributes?: DecisionTaskScheduledEventAttributes,
                decisionTaskStartedEventAttributes?: DecisionTaskStartedEventAttributes,
                decisionTaskCompletedEventAttributes?: DecisionTaskCompletedEventAttributes,
                decisionTaskTimedOutEventAttributes?: DecisionTaskTimedOutEventAttributes,
                activityTaskScheduledEventAttributes?: ActivityTaskScheduledEventAttributes,
                activityTaskStartedEventAttributes?: ActivityTaskStartedEventAttributes,
                activityTaskCompletedEventAttributes?: ActivityTaskCompletedEventAttributes,
                activityTaskFailedEventAttributes?: ActivityTaskFailedEventAttributes,
                activityTaskTimedOutEventAttributes?: ActivityTaskTimedOutEventAttributes,
                activityTaskCanceledEventAttributes?: ActivityTaskCanceledEventAttributes,
                activityTaskCancelRequestedEventAttributes?: ActivityTaskCancelRequestedEventAttributes,
                workflowExecutionSignaledEventAttributes?: WorkflowExecutionSignaledEventAttributes,
                markerRecordedEventAttributes?: MarkerRecordedEventAttributes,
                timerStartedEventAttributes?: TimerStartedEventAttributes,
                timerFiredEventAttributes?: TimerFiredEventAttributes,
                timerCanceledEventAttributes?: TimerCanceledEventAttributes,
                startChildWorkflowExecutionInitiatedEventAttributes?: StartChildWorkflowExecutionInitiatedEventAttributes,
                childWorkflowExecutionStartedEventAttributes?: ChildWorkflowExecutionStartedEventAttributes,
                childWorkflowExecutionCompletedEventAttributes?: ChildWorkflowExecutionCompletedEventAttributes,
                childWorkflowExecutionFailedEventAttributes?: ChildWorkflowExecutionFailedEventAttributes,
                childWorkflowExecutionTimedOutEventAttributes?: ChildWorkflowExecutionTimedOutEventAttributes,
                childWorkflowExecutionCanceledEventAttributes?: ChildWorkflowExecutionCanceledEventAttributes,
                childWorkflowExecutionTerminatedEventAttributes?: ChildWorkflowExecutionTerminatedEventAttributes,
                signalExternalWorkflowExecutionInitiatedEventAttributes?: SignalExternalWorkflowExecutionInitiatedEventAttributes,
                externalWorkflowExecutionSignaledEventAttributes?: ExternalWorkflowExecutionSignaledEventAttributes,
                signalExternalWorkflowExecutionFailedEventAttributes?: SignalExternalWorkflowExecutionFailedEventAttributes,
                externalWorkflowExecutionCancelRequestedEventAttributes?: ExternalWorkflowExecutionCancelRequestedEventAttributes,
                requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: RequestCancelExternalWorkflowExecutionInitiatedEventAttributes,
                requestCancelExternalWorkflowExecutionFailedEventAttributes?: RequestCancelExternalWorkflowExecutionFailedEventAttributes,
                scheduleActivityTaskFailedEventAttributes?: ScheduleActivityTaskFailedEventAttributes,
                requestCancelActivityTaskFailedEventAttributes?: RequestCancelActivityTaskFailedEventAttributes,
                startTimerFailedEventAttributes?: StartTimerFailedEventAttributes,
                cancelTimerFailedEventAttributes?: CancelTimerFailedEventAttributes,
                startChildWorkflowExecutionFailedEventAttributes?: StartChildWorkflowExecutionFailedEventAttributes
        }
        declare         export interface WorkflowExecutionStartedEventAttributes {
            input?: string,
                executionStartToCloseTimeout?: string,
                taskStartToCloseTimeout?: string,
                childPolicy?: string,
                taskList?: TaskList,
                workflowType?: WorkflowType,
                tagList?: string[],
                continuedExecutionRunId?: string,
                parentWorkflowExecution?: WorkflowExecution,
                parentInitiatedEventId?: number
        }
        declare         export interface WorkflowExecutionCompletedEventAttributes {
            result?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface CompleteWorkflowExecutionFailedEventAttributes {
            cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface WorkflowExecutionFailedEventAttributes {
            reason?: string,
                details?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface FailWorkflowExecutionFailedEventAttributes {
            cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface WorkflowExecutionTimedOutEventAttributes {
            timeoutType?: string,
                childPolicy?: string
        }
        declare         export interface WorkflowExecutionCanceledEventAttributes {
            details?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface CancelWorkflowExecutionFailedEventAttributes {
            cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface WorkflowExecutionContinuedAsNewEventAttributes {
            input?: string,
                decisionTaskCompletedEventId?: number,
                newExecutionRunId?: string,
                executionStartToCloseTimeout?: string,
                taskList?: TaskList,
                taskStartToCloseTimeout?: string,
                childPolicy?: string,
                tagList?: string[],
                workflowType?: WorkflowType
        }
        declare         export interface ContinueAsNewWorkflowExecutionFailedEventAttributes {
            cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface WorkflowExecutionTerminatedEventAttributes {
            reason?: string,
                details?: string,
                childPolicy?: string,
                cause?: string
        }
        declare         export interface WorkflowExecutionCancelRequestedEventAttributes {
            externalWorkflowExecution?: WorkflowExecution,
                externalInitiatedEventId?: number,
                cause?: string
        }
        declare         export interface DecisionTaskScheduledEventAttributes {
            taskList?: TaskList,
                startToCloseTimeout?: string
        }
        declare         export interface DecisionTaskStartedEventAttributes {
            identity?: string,
                scheduledEventId?: number
        }
        declare         export interface DecisionTaskCompletedEventAttributes {
            executionContext?: string,
                scheduledEventId?: number,
                startedEventId?: number
        }
        declare         export interface DecisionTaskTimedOutEventAttributes {
            timeoutType?: string,
                scheduledEventId?: number,
                startedEventId?: number
        }
        declare         export interface ActivityTaskScheduledEventAttributes {
            activityType?: ActivityType,
                activityId?: string,
                input?: string,
                control?: string,
                scheduleToStartTimeout?: string,
                scheduleToCloseTimeout?: string,
                startToCloseTimeout?: string,
                taskList?: TaskList,
                decisionTaskCompletedEventId?: number,
                heartbeatTimeout?: string
        }
        declare         export interface ActivityTaskStartedEventAttributes {
            identity?: string,
                scheduledEventId?: number
        }
        declare         export interface ActivityTaskCompletedEventAttributes {
            result?: string,
                scheduledEventId?: number,
                startedEventId?: number
        }
        declare         export interface ActivityTaskFailedEventAttributes {
            reason?: string,
                details?: string,
                scheduledEventId?: number,
                startedEventId?: number
        }
        declare         export interface ActivityTaskTimedOutEventAttributes {
            timeoutType?: string,
                scheduledEventId?: number,
                startedEventId?: number,
                details?: string
        }
        declare         export interface ActivityTaskCanceledEventAttributes {
            details?: string,
                scheduledEventId?: number,
                startedEventId?: number,
                latestCancelRequestedEventId?: number
        }
        declare         export interface ActivityTaskCancelRequestedEventAttributes {
            decisionTaskCompletedEventId?: number,
                activityId?: string
        }
        declare         export interface WorkflowExecutionSignaledEventAttributes {
            signalName?: string,
                input?: string,
                externalWorkflowExecution?: WorkflowExecution,
                externalInitiatedEventId?: number
        }
        declare         export interface MarkerRecordedEventAttributes {
            markerName?: string,
                details?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface TimerStartedEventAttributes {
            timerId?: string,
                control?: string,
                startToFireTimeout?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface TimerFiredEventAttributes {
            timerId?: string,
                startedEventId?: number
        }
        declare         export interface TimerCanceledEventAttributes {
            timerId?: string,
                startedEventId?: number,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface StartChildWorkflowExecutionInitiatedEventAttributes {
            workflowId?: string,
                workflowType?: WorkflowType,
                control?: string,
                input?: string,
                executionStartToCloseTimeout?: string,
                taskList?: TaskList,
                decisionTaskCompletedEventId?: number,
                childPolicy?: string,
                taskStartToCloseTimeout?: string,
                tagList?: string[]
        }
        declare         export interface ChildWorkflowExecutionStartedEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                initiatedEventId?: number
        }
        declare         export interface ChildWorkflowExecutionCompletedEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                result?: string,
                initiatedEventId?: number,
                startedEventId?: number
        }
        declare         export interface ChildWorkflowExecutionFailedEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                reason?: string,
                details?: string,
                initiatedEventId?: number,
                startedEventId?: number
        }
        declare         export interface ChildWorkflowExecutionTimedOutEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                timeoutType?: string,
                initiatedEventId?: number,
                startedEventId?: number
        }
        declare         export interface ChildWorkflowExecutionCanceledEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                details?: string,
                initiatedEventId?: number,
                startedEventId?: number
        }
        declare         export interface ChildWorkflowExecutionTerminatedEventAttributes {
            workflowExecution?: WorkflowExecution,
                workflowType?: WorkflowType,
                initiatedEventId?: number,
                startedEventId?: number
        }
        declare         export interface SignalExternalWorkflowExecutionInitiatedEventAttributes {
            workflowId?: string,
                runId?: string,
                signalName?: string,
                input?: string,
                decisionTaskCompletedEventId?: number,
                control?: string
        }
        declare         export interface ExternalWorkflowExecutionSignaledEventAttributes {
            workflowExecution?: WorkflowExecution,
                initiatedEventId?: number
        }
        declare         export interface SignalExternalWorkflowExecutionFailedEventAttributes {
            workflowId?: string,
                runId?: string,
                cause?: string,
                initiatedEventId?: number,
                decisionTaskCompletedEventId?: number,
                control?: string
        }
        declare         export interface ExternalWorkflowExecutionCancelRequestedEventAttributes {
            workflowExecution?: WorkflowExecution,
                initiatedEventId?: number
        }
        declare         export interface RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
            workflowId?: string,
                runId?: string,
                decisionTaskCompletedEventId?: number,
                control?: string
        }
        declare         export interface RequestCancelExternalWorkflowExecutionFailedEventAttributes {
            workflowId?: string,
                runId?: string,
                cause?: string,
                initiatedEventId?: number,
                decisionTaskCompletedEventId?: number,
                control?: string
        }
        declare         export interface ScheduleActivityTaskFailedEventAttributes {
            activityType?: ActivityType,
                activityId?: string,
                cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface RequestCancelActivityTaskFailedEventAttributes {
            activityId?: string,
                cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface StartTimerFailedEventAttributes {
            timerId?: string,
                cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface CancelTimerFailedEventAttributes {
            timerId?: string,
                cause?: string,
                decisionTaskCompletedEventId?: number
        }
        declare         export interface StartChildWorkflowExecutionFailedEventAttributes {
            workflowType?: WorkflowType,
                cause?: string,
                workflowId?: string,
                initiatedEventId?: number,
                decisionTaskCompletedEventId?: number,
                control?: string
        }
        declare         export interface ActivityTask {
            taskToken?: string,
                activityId?: string,
                startedEventId?: number,
                workflowExecution?: WorkflowExecution,
                activityType?: ActivityType,
                input?: string
        }
        declare         export interface PollForActivityTaskResult {
            activityTask?: ActivityTask
        }
        declare         export interface PollForDecisionTaskResult {
            decisionTask?: DecisionTask
        }
        declare         export interface StartWorkflowExecutionResult {
            run?: Run
        }

        /**
         * Register run block
         * @returns  - decorated class
         */
        declare         function Run(): ngESDecorator
    }

    declare module 'Sns' {

        /**
         * Represents the client portion of the response.
         */
        declare         export interface Client {
            paypal_sdk_version: string,
                environment: string,
                platform: string,
                product_name: string
        }
        declare         export interface PublishRequest {
            TopicArn?: string,
                TargetArn?: string,
                MessageAttributes?: {
                    [name: string]: MessageAttribute
                },
                Message?: string,
                MessageStructure?: string,
                Subject?: string
        }
        declare         export interface MessageAttribute {
            StringValue?: string,
                BinaryValue?: any,
                StringListValues?: string[],
                BinaryListValues?: any[],
                DataType: string
        }
        declare         export interface PublishResult {
            MessageId?: string
        }
        declare         export interface CreateTopicRequest {
            Name?: string
        }
        declare         export interface CreateTopicResult {
            TopicArn?: string
        }
        declare         export interface DeleteTopicRequest {
            TopicArn?: string
        }
    }

    declare module 's3' {
        declare interface Owner {
            DisplayName: string,
                ID: string
        }
        declare interface ObjectKeyPrefix {
            Prefix: string
        }
        declare         export interface ListObjectContent {
            Key: string,
                LastModified: Date,
                ETag: string,
                Size: number,
                StorageClass: "STANDARD" | "REDUCED_REDUNDANCY" | "GLACIER",
                Owner?: Owner
        }
        declare interface ListObjectRequestBase {
            Bucket: string,
                Delimiter?: string,
                EncodingType?: "url",
                MaxKeys?: number,
                Prefix?: string
        }
        declare interface ListObjectResponseBase {
            IsTruncated: boolean,
                Contents: ListObjectContent[],
                Name: string,
                Prefix?: string,
                Delimiter?: string,
                MaxKeys: number,
                CommonPrefixes?: ObjectKeyPrefix[],
                EncodingType?: "url"
        }
        declare         export interface PutObjectRequest {
            ACL?: string,
                Body?: any,
                Bucket: string,
                CacheControl?: string,
                ContentDisposition?: string,
                ContentEncoding?: string,
                ContentLanguage?: string,
                ContentLength?: string,
                ContentMD5?: string,
                ContentType?: string,
                Expires?: any,
                GrantFullControl?: string,
                GrantRead?: string,
                GrantReadACP?: string,
                GrantWriteACP?: string,
                Key: string,
                Metadata?: {
                    [key: string]: string
                },
                ServerSideEncryption?: string,
                StorageClass?: string,
                WebsiteRedirectLocation?: string
        }
        declare         export interface CopyObjectRequest {
            Bucket: string,
                CopySource: string,
                Key: string,
                ACL?: string,
                CacheControl?: string,
                ContentDisposition?: string,
                ContentEncoding?: string,
                ContentLanguage?: string,
                ContentType?: string,
                CopySourceIfMatch?: string,
                CopySourceIfModifiedSince?: any,
                CopySourceIfNoneMatch?: string,
                CopySourceIfUnmodifiedSince?: any,
                CopySourceSSECustomerAlgorithm?: string,
                CopySourceSSECustomerKey?: any,
                CopySourceSSECustomerKeyMD5?: string,
                Expires?: any,
                GrantFullControl?: string,
                GrantRead?: string,
                GrantReadACP?: string,
                GrantWriteACP?: string,
                Metadata?: {
                    [key: string]: string
                },
                MetadataDirective?: string,
                RequestPayer?: string,
                SSECustomerAlgorithm?: string,
                SSECustomerKey?: any,
                SSECustomerKeyMD5?: string,
                SSEKMSKeyId?: string,
                ServerSideEncryption?: string,
                StorageClass?: string,
                WebsiteRedirectLocation?: string
        }
        declare         export interface GetObjectRequest {
            Bucket: string,
                IfMatch?: string,
                IfModifiedSince?: any,
                IfNoneMatch?: string,
                IfUnmodifiedSince?: any,
                Key: string,
                Range?: string,
                ResponseCacheControl?: string,
                ResponseContentDisposition?: string,
                ResponseContentEncoding?: string,
                ResponseContentLanguage?: string,
                ResponseContentType?: string,
                ResponseExpires?: any,
                VersionId?: string
        }
        declare         export interface DeleteObjectRequest {
            Bucket: string,
                Key: string,
                MFA?: string,
                RequestPayer?: string,
                VersionId?: string
        }
        declare         export interface HeadObjectRequest {
            Bucket: string,
                Key: string,
                IfMatch?: string,
                IfModifiedSince?: Date,
                IfNoneMatch?: string,
                IfUnmodifiedSince?: Date,
                Range?: string,
                RequestPayer?: string,
                SSECustomerAlgorithm?: string,
                SSECustomerKey?: Buffer | string,
                SSECustomerKeyMD5?: string,
                VersionId?: string
        }
        declare         export interface UploadOptions {
            partSize?: number,
                queueSize?: number
        }
        declare         export type ListObjectRequest = {
            Marker?: string
        } & ListObjectRequestBase

        declare         export type ListObjectV2Request = {
            ContinuationToken?: string,
            FetchOwner?: boolean,
            StartAfter?: string
        } & ListObjectRequestBase

        declare         export type ListObjectResponse = {
            Marker?: string,
            NextMarker?: string
        } & ListObjectResponseBase

        declare         export type ListObjectV2Response = {
            KeyCount: number,
            ContinuationToken?: string,
            NextContinuationToken?: string,
            StartAfter?: string
        } & ListObjectResponseBase

    }

    declare module 'ecs' {
        declare         export interface CreateServicesParams {
            desiredCount: number,
                serviceName: string,
                taskDefinition: string,
                clientToken?: string,
                cluster?: string,
                deploymentConfiguration?: {
                    maximumPercent?: number,
                    minimumHealthyPercent?: number
                },
                loadBalancers?: {
                    containerName?: string,
                    containerPort?: number,
                    loadBalancerName?: string
                }[],
                role?: string
        }
        declare         export interface DescribeServicesParams {

            /**
             * A list of services to describe.
             */
            services: string[],

                /**
                 * The name of the cluster that hosts the service to describe. If you do not specify a cluster, the default cluster is assumed.
                 */
                cluster?: string
        }
        declare         export interface DescribeClustersParams {

            /**
             * A space-separated list of cluster names or full cluster Amazon Resource Name (ARN) entries. If you do not specify a cluster, the default cluster is assumed.
             */
            clusters?: string[]
        }
        declare         export interface DescribeTasksParams {

            /**
             * A space-separated list of task IDs or full Amazon Resource Name (ARN) entries.
             */
            tasks: string[],

                /**
                 * The short name or full Amazon Resource Name (ARN) of the cluster that hosts the task to describe. If you do not specify a cluster, the default cluster is assumed.
                 */
                cluster?: string
        }
        declare         export interface DescribeTaskDefinitionParams {

            /**
             * The `family` for the latest `ACTIVE` revision, `family` and `revision` (`family:revision`) for a specific revision in the family, or full Amazon Resource Name (ARN) of the task definition to describe.
             */
            taskDefinition: string
        }
        declare         export interface RegisterTaskDefinitionParams {
            containerDefinitions: {
                    command?: string[],
                    cpu?: number,
                    disableNetworking?: boolean,
                    dnsSearchDomains?: string[],
                    dnsServers?: string[],
                    dockerLabels?: any,
                    dockerSecurityOptions?: string[],
                    entryPoint?: string[],
                    environment?: any[],
                    essential?: boolean,
                    extraHosts?: {
                        hostName: string,
                        ipAddress: string
                    }[],
                    hostname?: string,
                    image?: string,
                    links?: string[],
                    logConfiguration?: {
                        logDriver: string,
                        options: any
                    }[],
                    memory?: number,
                    mountPoints?: {
                        containerPath: string,
                        readOnly: boolean,
                        sourceVolume: string
                    }[],
                    name?: string,
                    portMappings?: {
                        containerPort?: number,
                        hostPort?: number,
                        protocol: string
                    }[],
                    privileged?: boolean,
                    readonlyRootFilesystem?: boolean,
                    ulimits?: {
                        hardLimit: number,
                        name: string,
                        softLimit: number
                    }[],
                    user?: string,
                    volumesFrom?: {
                        readOnly?: boolean,
                        sourceContainer?: string
                    }[],
                    workingDirectory?: string
                }[],
                family: string,
                volumes?: {
                    host: {
                        sourcePath: string
                    },
                    name: string
                }[]
        }
        declare         export interface UpdateServiceParams {
            service: string,
                cluster?: string,
                deploymentConfiguration?: {
                    maximumPercent: number,
                    minimumHealthyPercent: number
                },
                desiredCount?: number,
                taskDefinition: string
        }
    }

    declare module 'sts' {
        declare         export interface AssumeRoleParams {
            RoleArn: string,
                RoleSessionName: string,
                DurationSeconds?: number,
                ExternalId?: string,
                Policy?: string,
                SerialNumber?: string,
                TokenCode?: string
        }
        declare         export interface AssumeRoleCallbackData {
            Credentials: TemporaryCredentials,
                AssumedRoleUser: AssumedRoleUser,
                PackedPolicySize: number
        }
        declare         export interface TemporaryCredentials {
            AccessKeyId: string,
                SecretAccessKey: string,
                SessionToken: string,
                Expiration: Date
        }
        declare         export interface AssumedRoleUser {
            AssumedRoleId: string,
                Arn: string
        }
        declare         export interface AssumeRoleWithSAMLParams {
            PrincipalArn: string,
                RoleArn: string,
                SAMLAssertion: string,
                DurationSeconds?: number,
                Policy?: string
        }
        declare         export interface AssumeRoleWithWebIdentityParams {
            RoleArn: string,
                RoleSessionName: string,
                WebIdentityToken: string,
                DurationSeconds?: number,
                Policy?: string,
                ProviderId?: string
        }
        declare         export interface CredentialsFromParams {

            /**
             * Data retrieved from a call to AWS.STS.getFederatedToken, getSessionToken(), assumeRole(), or assumeRoleWithWebIdentity().
             */
            Data: any,

                /**
                 * An optional credentials object to fill instead of creating a new object. Useful when modifying an existing credentials object from a refresh call.
                 */
                Credentials?: auth$Credentials
        }
        declare         export interface DecodeAuthorizationMessageParams {
            EncodedMessage: string
        }
        declare         export interface GetFederationTokenParams {
            Name: string,
                DurationSeconds?: number,
                Policy?: string
        }
        declare         export interface GetSessionTokenParams {
            DurationSeconds: number,
                SerialNumber: string,
                TokenCode: string
        }
    }

}