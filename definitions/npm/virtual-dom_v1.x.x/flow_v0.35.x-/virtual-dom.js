/**
 * Flowtype definitions for virtual-dom
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$VirtualDOM: {
    create: typeof VirtualDOM$create,
    h: typeof VirtualDOM$h,
    diff: typeof VirtualDOM$diff,
    patch: typeof VirtualDOM$patch,
}
declare interface VirtualDOM$VHook {
    hook(node: Element, propertyName: string): void,
        unhook(node: Element, propertyName: string): void
}

declare type VirtualDOM$EventHandler = (...args: any[]) => void;

declare interface VirtualDOM$VProperties {
    attributes?: {
            [index: string]: string
        },

        /**
         * I would like to use {[index: string]: string}, but then we couldn't use an
         * object literal when setting the styles, since TypeScript doesn't seem to
        infer that {'fontSize': string; 'fontWeight': string;} is actually quite
        assignable to the type { [index: string]: string; }
        */
        style?: any, [index: string]: any |
        string |
        boolean |
        number |
        VirtualDOM$VHook |
        VirtualDOM$EventHandler |
        {
            [index: string]: string | boolean | number
        }
}

declare interface VirtualDOM$VNode {
    tagName: string,
        properties: VirtualDOM$VProperties,
        children: VirtualDOM$VTree[],
        key?: string,
        namespace?: string,
        count: number,
        hasWidgets: boolean,
        hasThunks: boolean,
        hooks: any[],
        descendantHooks: any[],
        version: string,
        type: string
}

declare interface VirtualDOM$VText {
    text: string,
        new(text: any): VirtualDOM$VText,
        version: string,
        type: string
}

declare interface VirtualDOM$Widget {
    type: string,
        init(): Element,
        update(previous: VirtualDOM$Widget, domNode: Element): void,
        destroy(node: Element): void
}

declare interface VirtualDOM$Thunk {
    type: string,
        vnode: VirtualDOM$VTree,
        render(previous: VirtualDOM$VTree): VirtualDOM$VTree
}

declare type VirtualDOM$VTree = VirtualDOM$VText | VirtualDOM$VNode | VirtualDOM$Widget | VirtualDOM$Thunk;

declare interface VirtualDOM$VPatch {
    vNode: VirtualDOM$VNode,
        patch: any,
        new(type: number, vNode: VirtualDOM$VNode, patch: any): VirtualDOM$VPatch,
        version: string,

        /**
         * type is set to 'VirtualPatch' on the prototype, but overridden in the
         * constructor with a number.
         */
        type: number
}

declare type VirtualDOM$createProperties = {
    key?: string,
    namespace?: string
} & VirtualDOM$VProperties


declare type VirtualDOM$VChild = VirtualDOM$VTree[] | VirtualDOM$VTree | string[] | string;


/**
 * create() calls either document.createElement() or document.createElementNS(),
 * for which the common denominator is Element (not HTMLElement).
 */
declare function VirtualDOM$create(vnode: VirtualDOM$VText, opts?: {
    document?: Document,
    warn?: boolean
}): Text

declare function VirtualDOM$h(
    tagName: string,
    properties: VirtualDOM$createProperties,
    children: string | VirtualDOM$VChild[]): VirtualDOM$VNode

declare function VirtualDOM$diff(left: VirtualDOM$VTree, right: VirtualDOM$VTree): VirtualDOM$VPatch[]


/**
 * patch() usually just returns rootNode after doing stuff to it, so we want
 * to preserve that type (though it will usually be just Element).
 */
declare function VirtualDOM$patch<T>(rootNode: T, patches: VirtualDOM$VPatch[], renderOptions?: any): Tdeclare module 'virtual-dom/h' {
    declare module.exports: typeof h
}
declare module 'virtual-dom/create-element' {
    declare module.exports: typeof create
}
declare module 'virtual-dom/diff' {
    declare module.exports: typeof diff
}
declare module 'virtual-dom/patch' {
    declare module.exports: typeof patch
}
declare module 'virtual-dom' {
    declare module.exports: typeof VirtualDOM
}