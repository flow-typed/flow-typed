/**
 * Flowtype definitions for lodash-3.10
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare var _: _.LoDashStatic;
declare module '_' {
    declare interface LoDashStatic {

        /**
         * Creates a lodash object which wraps the given value to enable intuitive method chaining.
         * 
        In addition to Lo-Dash methods, wrappers also have the following Array methods:
        concat, join, pop, push, reverse, shift, slice, sort, splice, and unshift

        Chaining is supported in custom builds as long as the value method is implicitly or
        explicitly included in the build.

        The chainable wrapper functions are:
        after, assign, bind, bindAll, bindKey, chain, chunk, compact, compose, concat, countBy,
        createCallback, curry, debounce, defaults, defer, delay, difference, filter, flatten,
        forEach, forEachRight, forIn, forInRight, forOwn, forOwnRight, functions, groupBy,
        indexBy, initial, intersection, invert, invoke, keys, map, max, memoize, merge, min,
        object, omit, once, pairs, partial, partialRight, pick, pluck, pull, push, range, reject,
        remove, rest, reverse, sample, shuffle, slice, sort, sortBy, splice, tap, throttle, times,
        toArray, transform, union, uniq, unshift, unzip, values, where, without, wrap, and zip

        The non-chainable wrapper functions are:
        clone, cloneDeep, contains, escape, every, find, findIndex, findKey, findLast,
        findLastIndex, findLastKey, has, identity, indexOf, isArguments, isArray, isBoolean,
        isDate, isElement, isEmpty, isEqual, isFinite, isFunction, isNaN, isNull, isNumber,
        isObject, isPlainObject, isRegExp, isString, isUndefined, join, lastIndexOf, mixin,
        noConflict, parseInt, pop, random, reduce, reduceRight, result, shift, size, some,
        sortedIndex, runInContext, template, unescape, uniqueId, and value

        The wrapper functions first and last return wrapped values when n is provided, otherwise
        they return unwrapped values.

        Explicit chaining can be enabled by using the _.chain method.
        */
        (value: number): LoDashImplicitWrapper<number>,
            (value: string): LoDashImplicitStringWrapper,
            (value: boolean): LoDashImplicitWrapper<boolean>,
            (value: Array<number>): LoDashImplicitNumberArrayWrapper,
            (value: Array<T>): LoDashImplicitArrayWrapper<T>,
            (value: T): LoDashImplicitObjectWrapper<T>,
            (value: any): LoDashImplicitWrapper<any>,

            /**
             * The semantic version number.
             */
            VERSION: string,

            /**
             * An object used to flag environments features.
             */
            support: Support,

            /**
             * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby
             * (ERB). Change the following template settings to use alternative delimiters.
             */
            templateSettings: TemplateSettings
    }

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby
     * (ERB). Change the following template settings to use alternative delimiters.
     */
    declare interface TemplateSettings {

        /**
         * The "escape" delimiter.
         */
        escape?: RegExp,

            /**
             * The "evaluate" delimiter.
             */
            evaluate?: RegExp,

            /**
             * An object to import into the template as local variables.
             */
            imports?: Dictionary<any>,

            /**
             * The "interpolate" delimiter.
             */
            interpolate?: RegExp,

            /**
             * Used to reference the data object in the template text.
             */
            variable?: string
    }

    /**
     * Creates a cache object to store key/value pairs.
     */
    declare interface MapCache {

        /**
         * Removes `key` and its value from the cache.
         * @param key The key of the value to remove.
         * @return  Returns `true` if the entry was removed successfully, else `false`.
         */
        delete(key: string): boolean,

            /**
             * Gets the cached value for `key`.
             * @param key The key of the value to get.
             * @return  Returns the cached value.
             */
            get(key: string): any,

            /**
             * Checks if a cached value for `key` exists.
             * @param key The key of the entry to check.
             * @return  Returns `true` if an entry for `key` exists, else `false`.
             */
            has(key: string): boolean,

            /**
             * Sets `value` to `key` of the cache.
             * @param key The key of the value to cache.
             * @param value The value to cache.
             * @return  Returns the cache object.
             */
            set(key: string, value: any): _.Dictionary<any >
    }

    /**
     * An object used to flag environments features.
     */
    declare interface Support {

        /**
         * Detect if an arguments object's [[Class]] is resolvable (all but Firefox<4, IE<9).
         */
        argsClass: boolean,

            /**
             * Detect if arguments objects are Object objects (all but Narwhal and Opera<10.5).
             */
            argsObject: boolean,

            /**
             * Detect if name or message properties of Error.prototype are enumerable by default.
             * (IE<9, Safari<5.1)
             */
            enumErrorProps: boolean,

            /**
             * Detect if prototype properties are enumerable by default.
             * 
            Firefox<3.6, Opera>9.50 - Opera<11.60, and Safari<5.1 (if the prototype or a property on the
            prototype has been set) incorrectly set the [[Enumerable]] value of a function’s prototype property to true.
            */
            enumPrototypes: boolean,

            /**
             * Detect if Function#bind exists and is inferred to be fast (all but V8).
             */
            fastBind: boolean,

            /**
             * Detect if functions can be decompiled by Function#toString (all but PS3 and older Opera
             * mobile browsers & avoided in Windows 8 apps).
             */
            funcDecomp: boolean,

            /**
             * Detect if Function#name is supported (all but IE).
             */
            funcNames: boolean,

            /**
             * Detect if arguments object indexes are non-enumerable (Firefox<4, IE<9, PhantomJS,
             * Safari<5.1).
             */
            nonEnumArgs: boolean,

            /**
             * Detect if properties shadowing those on Object.prototype are non-enumerable.
             * 
            In IE<9 an objects own properties, shadowing non-enumerable ones, are made
            non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
            */
            nonEnumShadows: boolean,

            /**
             * Detect if own properties are iterated after inherited properties (all but IE<9).
             */
            ownLast: boolean,

            /**
             * Detect if Array#shift and Array#splice augment array-like objects correctly.
             * 
            Firefox<10, IE compatibility mode, and IE<9 have buggy Array shift() and splice()
            functions that fail to remove the last element, value[0], of array-like objects even
            though the length property is set to 0. The shift() method is buggy in IE 8 compatibility
            mode, while splice() is buggy regardless of mode in IE<9 and buggy in compatibility mode
            in IE 9.
            */
            spliceObjects: boolean,

            /**
             * Detect lack of support for accessing string characters by index.
             * 
            IE<8 can't access characters by index and IE 8 can only access characters by index on
            string literals.
            */
            unindexedChars: boolean
    }
    declare interface LoDashWrapperBase<T, TWrapper>{}
    declare type LoDashImplicitWrapperBase<T, TWrapper>= {} & LoDashWrapperBase

    declare type LoDashExplicitWrapperBase<T, TWrapper>= {} & LoDashWrapperBase

    declare type LoDashImplicitWrapper<T>= {} & LoDashImplicitWrapperBase

    declare type LoDashExplicitWrapper<T>= {} & LoDashExplicitWrapperBase

    declare type LoDashImplicitStringWrapper = {} & LoDashImplicitWrapper

    declare type LoDashExplicitStringWrapper = {} & LoDashExplicitWrapper

    declare type LoDashImplicitObjectWrapper<T>= {} & LoDashImplicitWrapperBase

    declare type LoDashExplicitObjectWrapper<T>= {} & LoDashExplicitWrapperBase

    declare type LoDashImplicitArrayWrapper<T>= {
        pop(): T,
        push(...items: T[]): LoDashImplicitArrayWrapper<T>,
        shift(): T,
        sort(compareFn?: (a: T, b: T) => number): LoDashImplicitArrayWrapper<T>,
        splice(start: number): LoDashImplicitArrayWrapper<T>,
        splice(
            start: number,
            deleteCount: number,
            ...items: any[]): LoDashImplicitArrayWrapper<T>,
        unshift(...items: T[]): LoDashImplicitArrayWrapper<T >
    } & LoDashImplicitWrapperBase

    declare type LoDashExplicitArrayWrapper<T>= {} & LoDashExplicitWrapperBase

    declare type LoDashImplicitNumberArrayWrapper = {} & LoDashImplicitArrayWrapper

    declare type LoDashExplicitNumberArrayWrapper = {} & LoDashExplicitArrayWrapper

    declare type RecursiveArray<T>= {} & Array

    declare type ListOfRecursiveArraysOrValues<T>= {} & List

    declare interface FunctionBind {
        placeholder: any,
            (func: T, thisArg: any, ...partials: any[]): TResult,
            (func: Function, thisArg: any, ...partials: any[]): TResult
    }
    declare interface FunctionBindKey {
        placeholder: any,
            (object: T, key: any, ...partials: any[]): TResult,
            (object: Object, key: any, ...partials: any[]): TResult
    }
    declare interface CurriedFunction1<T1, R>{
        (): CurriedFunction1<T1,
        R>,
        (t1: T1): R
    }
    declare interface CurriedFunction2<T1, T2, R>{
        (): CurriedFunction2<T1,
        T2,
        R>,
        (t1: T1): CurriedFunction1<T2,
        R>,
        (t1: T1, t2: T2): R
    }
    declare interface CurriedFunction3<T1, T2, T3, R>{
        (): CurriedFunction3<T1,
        T2,
        T3,
        R>,
        (t1: T1): CurriedFunction2<T2,
        T3,
        R>,
        (t1: T1, t2: T2): CurriedFunction1<T3,
        R>,
        (t1: T1, t2: T2, t3: T3): R
    }
    declare interface CurriedFunction4<T1, T2, T3, T4, R>{
        (): CurriedFunction4<T1,
        T2,
        T3,
        T4,
        R>,
        (t1: T1): CurriedFunction3<T2,
        T3,
        T4,
        R>,
        (t1: T1, t2: T2): CurriedFunction2<T3,
        T4,
        R>,
        (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4,
        R>,
        (t1: T1, t2: T2, t3: T3, t4: T4): R
    }
    declare interface CurriedFunction5<T1, T2, T3, T4, T5, R>{
        (): CurriedFunction5<T1,
        T2,
        T3,
        T4,
        T5,
        R>,
        (t1: T1): CurriedFunction4<T2,
        T3,
        T4,
        T5,
        R>,
        (t1: T1, t2: T2): CurriedFunction3<T3,
        T4,
        T5,
        R>,
        (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4,
        T5,
        R>,
        (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5,
        R>,
        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R
    }
    declare interface DebounceSettings {

        /**
         * Specify invoking on the leading edge of the timeout.
         */
        leading?: boolean,

            /**
             * The maximum time func is allowed to be delayed before it’s invoked.
             */
            maxWait?: number,

            /**
             * Specify invoking on the trailing edge of the timeout.
             */
            trailing?: boolean
    }
    declare type MemoizedFunction = {
        cache: MapCache
    } & Function

    declare type PH = LoDashStatic;
    declare interface Function0<R>{
        (): R
    }
    declare interface Function1<T1, R>{
        (t1: T1): R
    }
    declare interface Function2<T1, T2, R>{
        (t1: T1, t2: T2): R
    }
    declare interface Function3<T1, T2, T3, R>{
        (t1: T1, t2: T2, t3: T3): R
    }
    declare interface Function4<T1, T2, T3, T4, R>{
        (t1: T1, t2: T2, t3: T3, t4: T4): R
    }
    declare interface Partial {
        (func: Function0<R>): Function0<R>,
            (func: Function1<T1, R>): Function1<T1, R>,
            (func: Function1<T1, R>, arg1: T1): Function0<R>,
            (func: Function2<T1, T2, R>): Function2<T1, T2, R>,
            (func: Function2<T1, T2, R>, arg1: T1): Function1<T2, R>,
            (func: Function2<T1, T2, R>, plc1: PH, arg2: T2): Function1<T1, R>,
            (func: Function2<T1, T2, R>, arg1: T1, arg2: T2): Function0<R>,
            (func: Function3<T1, T2, T3, R>): Function3<T1, T2, T3, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1): Function2<T2, T3, R>,
            (func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2): Function2<T1, T3, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2): Function1<T3, R>,
            (func: Function3<T1, T2, T3, R>, plc1: PH, plc2: PH, arg3: T3): Function2<T1, T2, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3): Function1<T2, R>,
            (func: Function3<T1, T2, T3, R>, plc1: PH, arg2: T2, arg3: T3): Function1<T1, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): Function0<R>,
            (func: Function4<T1, T2, T3, T4, R>): Function4<T1, T2, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1): Function3<T2, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2): Function3<T1, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2): Function2<T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3): Function3<T1, T2, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3): Function2<T2, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3): Function2<T1, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3): Function1<T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, plc3: PH, arg4: T4): Function3<T1, T2, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4): Function2<T2, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, plc3: PH, arg4: T4): Function2<T1, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4): Function1<T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, plc2: PH, arg3: T3, arg4: T4): Function2<T1, T2, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4): Function1<T2, R>,
            (func: Function4<T1, T2, T3, T4, R>, plc1: PH, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>,
            (func: Function, ...args: any[]): Function
    }
    declare interface PartialRight {
        (func: Function0<R>): Function0<R>,
            (func: Function1<T1, R>): Function1<T1, R>,
            (func: Function1<T1, R>, arg1: T1): Function0<R>,
            (func: Function2<T1, T2, R>): Function2<T1, T2, R>,
            (func: Function2<T1, T2, R>, arg1: T1, plc2: PH): Function1<T2, R>,
            (func: Function2<T1, T2, R>, arg2: T2): Function1<T1, R>,
            (func: Function2<T1, T2, R>, arg1: T1, arg2: T2): Function0<R>,
            (func: Function3<T1, T2, T3, R>): Function3<T1, T2, T3, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, plc3: PH): Function2<T2, T3, R>,
            (func: Function3<T1, T2, T3, R>, arg2: T2, plc3: PH): Function2<T1, T3, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, plc3: PH): Function1<T3, R>,
            (func: Function3<T1, T2, T3, R>, arg3: T3): Function2<T1, T2, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, plc2: PH, arg3: T3): Function1<T2, R>,
            (func: Function3<T1, T2, T3, R>, arg2: T2, arg3: T3): Function1<T1, R>,
            (func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): Function0<R>,
            (func: Function4<T1, T2, T3, T4, R>): Function4<T1, T2, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, plc4: PH): Function3<T2, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: PH, plc4: PH): Function3<T1, T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, plc4: PH): Function2<T3, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg3: T3, plc4: PH): Function3<T1, T2, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, plc4: PH): Function2<T2, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, plc4: PH): Function2<T1, T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, plc4: PH): Function1<T4, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg4: T4): Function3<T1, T2, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, plc3: PH, arg4: T4): Function2<T2, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: PH, arg4: T4): Function2<T1, T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: PH, arg4: T4): Function1<T3, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg3: T3, arg4: T4): Function2<T1, T2, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: PH, arg3: T3, arg4: T4): Function1<T2, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>,
            (func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>,
            (func: Function, ...args: any[]): Function
    }
    declare interface ThrottleSettings {

        /**
         * If you'd like to disable the leading-edge call, pass this as false.
         */
        leading?: boolean,

            /**
             * If you'd like to disable the execution on the trailing-edge, pass false.
             */
            trailing?: boolean
    }
    declare interface CloneCustomizer<TValue, TResult>{
        (value: TValue): TResult
    }
    declare interface CloneDeepCustomizer<TValue, TResult>{
        (value: TValue): TResult
    }
    declare interface IsEqualCustomizer {
        (value: any, other: any, indexOrKey?: number | string): boolean
    }
    declare interface isMatchCustomizer {
        (value: any, other: any, indexOrKey?: number | string): boolean
    }
    declare interface AssignCustomizer {
        (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}): any
    }
    declare interface MergeCustomizer {
        (value: any, srcValue: any, key?: string, object?: Object, source?: Object): any
    }
    declare type TemplateOptions = {

        /**
         * The sourceURL of the template's compiled source.
         */
        sourceURL?: string
    } & TemplateSettings

    declare interface TemplateExecutor {
        (data?: Object): string,
        source: string
    }
    declare interface TruncOptions {

        /**
         * The maximum string length. 
         */
        length?: number,

            /**
             * The string to indicate text is omitted. 
             */
            omission?: string,

            /**
             * The separator pattern to truncate to. 
             */
            separator?: string | RegExp
    }
    declare interface MixinOptions {
        chain?: boolean
    }
    declare interface ListIterator<T, TResult>{
        (value: T, index: number, collection: List<T>): TResult
    }
    declare interface DictionaryIterator<T, TResult>{
        (value: T, key?: string, collection?: Dictionary<T>): TResult
    }
    declare interface NumericDictionaryIterator<T, TResult>{
        (value: T, key?: number, collection?: Dictionary<T>): TResult
    }
    declare interface ObjectIterator<T, TResult>{
        (element: T, key?: string, collection?: any): TResult
    }
    declare interface StringIterator<TResult>{
        (char: string, index?: number, string?: string): TResult
    }
    declare interface MemoVoidIterator<T, TResult>{
        (prev: TResult, curr: T, indexOrKey?: any, list?: T[]): void
    }
    declare interface MemoIterator<T, TResult>{
        (prev: TResult, curr: T, indexOrKey?: any, list?: T[]): TResult
    }
    declare interface MemoVoidArrayIterator<T, TResult>{
        (acc: TResult, curr: T, index?: number, arr?: T[]): void
    }
    declare interface MemoVoidDictionaryIterator<T, TResult>{
        (acc: TResult, curr: T, key?: string, dict?: Dictionary<T>): void
    }
    declare interface List<T>{
        [index: number]: T,
        length: number
    }
    declare interface Dictionary<T>{
        [index: string]: T
    }
    declare interface NumericDictionary<T>{
        [index: number]: T
    }
    declare interface StringRepresentable {
        toString(): string
    }
    declare interface Cancelable {
        cancel(): void
    }
}
declare module 'lodash' {
    declare module.exports: typeof _
}