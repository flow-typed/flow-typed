/**
 * Flowtype definitions for matter-js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'matter-js' {
    declare module.exports: typeof Matter
}

/**
 * The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
 * @class  Axes
 */
declare
export class Axes {

    /**
     * Creates a new set of axes from the given vertices.
     * @method  fromVertices
     * @param  
     * @return  A new axes from the given vertices
     */
    fromVertices(vertices: Array<Matter$Vector>): Array<Matter$Vector>;

    /**
     * Rotates a set of axes by the given angle.
     * @method  rotate
     * @param  
     * @param  
     */
    rotate(axes: Array<Matter$Vector>, angle: number): void
}

declare interface Matter$IChamfer {
    radius?: number | Array<number>,
        quality?: number,
        qualityMin?: number,
        qualityMax?: number
}

declare type Matter$IChamferableBodyDefinition = {
    chamfer?: Matter$IChamfer
} & Matter$IBodyDefinition



/**
 * The `Matter.Bodies` module contains factory methods for creating rigid body models
 * with commonly used body configurations (such as rectangles, circles and other polygons).

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Bodies
*/
declare
export class Bodies {

    /**
     * Creates a new rigid body model with a circle hull.
     * The options parameter is an object that specifies any properties you wish to override the defaults.
    See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method  circle
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @param  * 
     * @return  A new circle body
    */
    circle(
        x: number,
        y: number,
        radius: number,
        options?: Matter$IBodyDefinition,
        maxSides?: number): Matter$Body;

    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides.
     * The options parameter is an object that specifies any properties you wish to override the defaults.
    See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method  polygon
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @return  A new regular polygon body
    */
    polygon(
        x: number,
        y: number,
        sides: number,
        radius: number,
        options?: Matter$IChamferableBodyDefinition): Matter$Body;

    /**
     * Creates a new rigid body model with a rectangle hull.
     * The options parameter is an object that specifies any properties you wish to override the defaults.
    See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method  rectangle
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @return  A new rectangle body
    */
    rectangle(
        x: number,
        y: number,
        width: number,
        height: number,
        options?: Matter$IChamferableBodyDefinition): Matter$Body;

    /**
     * Creates a new rigid body model with a trapezoid hull.
     * The options parameter is an object that specifies any properties you wish to override the defaults.
    See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method  trapezoid
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @return  A new trapezoid body
    */
    trapezoid(
        x: number,
        y: number,
        width: number,
        height: number,
        slope: number,
        options?: Matter$IChamferableBodyDefinition): Matter$Body;

    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
    Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
    Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
    By default the decomposition will discard collinear edges (to improve performance).
    It can also optionally discard any parts that have an area less than `minimumArea`.
    If the vertices can not be decomposed, the result will fall back to using the convex hull.
    The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
    See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.[vector]] vertexSets
     * @method  fromVertices
     * @param  
     * @param  
     * @param  * 
     * @param  * 
     * @param  * 
     * @param  * 
     * @return  
    */
    fromVertices(
        x: number,
        y: number,
        vertexSets: Array<Array<Matter$Vector >> ,
        options?: Matter$IBodyDefinition,
        flagInternal?: boolean,
        removeCollinear?: number,
        minimumArea?: number): Matter$Body
}

declare
export interface Matter$IBodyDefinition {

    /**
     * A `Number` specifying the angle of the body, in radians.
     * @property  angle
     * @type  number
     * @default  0
     */
    angle?: number,

        /**
         * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
         * @readOnly  * 
         * @property  angularSpeed
         * @type  number
         * @default  0
         */
        angularSpeed?: number,

        /**
         * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only.
         * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
         * @readOnly  * 
         * @property  angularVelocity
         * @type  number
         * @default  0
         */
        angularVelocity?: number,

        /**
         * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
         * @property  area
         * @type  string
         * @default  
         */
        area?: number,

        /**
         * An array of unique axis vectors (edge normals) used for collision detection.
         * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
        They are constantly updated by `Body.update` during the simulation.
         * @property  axes
         * @type  vector[]
        */
        axes?: Array<Matter$Vector>,

        /**
         * A `Bounds` object that defines the AABB region for the body.
         * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
         * @property  bounds
         * @type  bounds
         */
        bounds?: Matter$Bounds,

        /**
         * A `Number` that defines the density of the body, that is its mass per unit area.
         * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
        This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
         * @property  density
         * @type  number
         * @default  0.001
        */
        density?: number,

        /**
         * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
         * @property  force
         * @type  vector
         * @default  { x: 0, y: 0 }
         */
        force?: Matter$Vector,

        /**
         * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
         * A value of `0` means that the body may slide indefinitely.
        A value of `1` means the body may come to a stop almost instantly after a force is applied.

        The effects of the value may be non-linear.
        High values may be unstable depending on the body.
        The engine uses a Coulomb friction model including static and kinetic friction.
        Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:

            Math.min(bodyA.friction, bodyB.friction)
         * @property  friction
         * @type  number
         * @default  0.1
        */
        friction?: number,

        /**
         * A `Number` that defines the air friction of the body (air resistance).
         * A value of `0` means the body will never slow as it moves through space.
        The higher the value, the faster a body slows when moving through space.
        The effects of the value are non-linear.
         * @property  frictionAir
         * @type  number
         * @default  0.01
        */
        frictionAir?: number,

        /**
         * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
         * @property  id
         * @type  number
         */
        id?: number,

        /**
         * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
         * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
        If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
         * @property  inertia
         * @type  number
        */
        inertia?: number,

        /**
         * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
         * If you modify this value, you must also modify the `body.inertia` property.
         * @property  inverseInertia
         * @type  number
         */
        inverseInertia?: number,

        /**
         * A `Number` that defines the inverse mass of the body (`1 / mass`).
         * If you modify this value, you must also modify the `body.mass` property.
         * @property  inverseMass
         * @type  number
         */
        inverseMass?: number,

        /**
         * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
         * @property  isSensor
         * @type  boolean
         * @default  false
         */
        isSensor?: boolean,

        /**
         * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
         * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
         * @property  isSleeping
         * @type  boolean
         * @default  false
         */
        isSleeping?: boolean,

        /**
         * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
         * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
         * @property  isStatic
         * @type  boolean
         * @default  false
         */
        isStatic?: boolean,

        /**
         * An arbitrary `String` name to help the user identify and manage bodies.
         * @property  label
         * @type  string
         * @default  "Body"
         */
        label?: string,

        /**
         * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
         * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
         * @property  mass
         * @type  number
         */
        mass?: number,

        /**
         * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
         * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
         * @readOnly  * 
         * @property  motion
         * @type  number
         * @default  0
         */
        motion?: number,

        /**
         * A `Vector` that specifies the current world-space position of the body.
         * @property  position
         * @type  vector
         * @default  { x: 0, y:      
         */
        position?: Matter$Vector,

        /**
         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
         * @property  render
         * @type  object
         */
        render?: Matter$IBodyRenderOptions,

        /**
         * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
         * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur.
        A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
        Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:

            Math.max(bodyA.restitution, bodyB.restitution)
         * @property  restitution
         * @type  number
         * @default  0
        */
        restitution?: number,

        /**
         * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
         * @property  sleepThreshold
         * @type  number
         * @default  60
         */
        sleepThreshold?: number,

        /**
         * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
         * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
        The default should generally suffice, although very large bodies may require larger values for stable stacking.
         * @property  slop
         * @type  number
         * @default  0.05
        */
        slop?: number,

        /**
         * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
         * @readOnly  * 
         * @property  speed
         * @type  number
         * @default  0
         */
        speed?: number,

        /**
         * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
         * @property  timeScale
         * @type  number
         * @default  1
         */
        timeScale?: number,

        /**
         * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
         * @property  torque
         * @type  number
         * @default  0
         */
        torque?: number,

        /**
         * A `String` denoting the type of object.
         * @property  type
         * @type  string
         * @default  "body"
         */
        type?: string,

        /**
         * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only.
         * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
         * @readOnly  * 
         * @property  velocity
         * @type  vector
         * @default  { x: 0, y: 0 }
         */
        velocity?: Matter$Vector,

        /**
         * An array of `Vector` objects that specify the convex hull of the rigid body.
         * These should be provided about the origin `(0, 0)`. E.g.

            [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]

        When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
        The `Vector` objects are also augmented with additional properties required for efficient collision detection.

        Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
        Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
         * @property  vertices
         * @type  vector[]
        */
        vertices?: Array<Matter$Vector>,

        /**
         * An array of bodies that make up this body.
         * The first body in the array must always be a self reference to the current body instance.
        All bodies in the `parts` array together form a single rigid compound body.
        Parts are allowed to overlap, have gaps or holes or even form concave bodies.
        Parts themselves should never be added to a `World`, only the parent body should be.
        Use `Body.setParts` when setting parts to ensure correct updates of all properties.
         * @property  parts
         * @type  body[]
        */
        parts?: Array<Matter$Body>,

        /**
         * A self reference if the body is _not_ a part of another body.
         * Otherwise this is a reference to the body that this is a part of.
        See `body.parts`.
         * @property  parent
         * @type  body
        */
        parent?: Matter$Body,

        /**
         * A `Number` that defines the static friction of the body (in the Coulomb friction model).
         * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
        The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
        This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
         * @property  frictionStatic
         * @type  number
         * @default  0.5
        */
        frictionStatic?: number,

        /**
         * An `Object` that specifies the collision filtering properties of this body.
         * 
        Collisions between two bodies will obey the following rules:
        - If the two bodies have the same non-zero value of `collisionFilter.group`,
          they will always collide if the value is positive, and they will never collide
          if the value is negative.
        - If the two bodies have different values of `collisionFilter.group` or if one
          (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:

        Each body belongs to a collision category, given by `collisionFilter.category`. This
        value is used as a bit field and the category should have only one bit set, meaning that
        the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
        different collision categories available.

        Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
        the categories it collides with (the value is the bitwise AND value of all these categories).

        Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
        category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
        are both true.
         * @property  collisionFilter
         * @type  object
        */
        collisionFilter?: Matter$ICollisionFilter
}

declare
export interface Matter$IBodyRenderOptions {

    /**
     * A flag that indicates if the body should be rendered.
     * @property  render.visible
     * @type  boolean
     * @default  true
     */
    visible?: boolean,

        /**
         * An `Object` that defines the sprite properties to use when rendering, if any.
         * @property  render.sprite
         * @type  object
         */
        sprite?: Matter$IBodyRenderOptionsSprite,

        /**
         * A String that defines the fill style to use when rendering the body (if a sprite is not defined). It is the same as when using a canvas, so it accepts CSS style property values.
         * Default: a random colour
         */
        fillStyle?: string,

        /**
         * A Number that defines the line width to use when rendering the body outline (if a sprite is not defined). A value of 0 means no outline will be rendered.
         * Default: 1.5
         */
        lineWidth?: number,

        /**
         * A String that defines the stroke style to use when rendering the body outline (if a sprite is not defined). It is the same as when using a canvas, so it accepts CSS style property values.
         * Default: a random colour
         */
        strokeStyle?: string,
        opacity?: number
}

declare
export interface Matter$IBodyRenderOptionsSprite {

    /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     * @property  render.sprite.texture
     * @type  string
     */
    texture: string,

        /**
         * A `Number` that defines the scaling in the x-axis for the sprite, if any.
         * @property  render.sprite.xScale
         * @type  number
         * @default  1
         */
        xScale: number,

        /**
         * A `Number` that defines the scaling in the y-axis for the sprite, if any.
         * @property  render.sprite.yScale
         * @type  number
         * @default  1
         */
        yScale: number
}


/**
 * The `Matter.Body` module contains methods for creating and manipulating body models.
 * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Body
*/
declare
export class Body {

    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method  applyForce
     * @param  
     * @param  
     * @param  
     */
    applyForce(body: Matter$Body, position: Matter$Vector, force: Matter$Vector): void;

    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  
     * @return  body
    */
    create(options: Matter$IBodyDefinition): Matter$Body;

    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method  rotate
     * @param  
     * @param  
     */
    rotate(body: Matter$Body, rotation: number): void;

    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
    See `body.collisionFilter` for more information.
     * @method  nextGroup
     * @param  * 
     * @return  Unique group index
    */
    nextGroup(isNonColliding: boolean): number;

    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method  nextCategory
     * @return  Unique category bitfield
     */
    nextCategory(): number;

    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method  set
     * @param  
     * @param  A property name (or map of properties and values) to set on the body.
     * @param  The value to set if `settings` is a single property name.
     */
    set(body: Matter$Body, settings: any, value?: any): void;

    /**
     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
     * @method  setMass
     * @param  
     * @param  
     */
    setMass(body: Matter$Body, mass: number): void;

    /**
     * Sets the density of the body. Mass is automatically updated to reflect the change.
     * @method  setDensity
     * @param  
     * @param  
     */
    setDensity(body: Matter$Body, density: number): void;

    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body.
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method  setInertia
     * @param  
     * @param  
     */
    setInertia(body: Matter$Body, interna: number): void;

    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
    They are then automatically translated to world space based on `body.position`.

    The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
    Vertices must form a convex hull, concave hulls are not supported.
     * @method  setVertices
     * @param  
     * @param  
    */
    setVertices(body: Matter$Body, vertices: Array<Matter$Vector>): void;

    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
    By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
    Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method  setParts
     * @param  
     * @param body parts
     * @param  
    */
    setParts(body: Matter$Body, parts: Matter$Body[], autoHull?: boolean): void;

    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method  setPosition
     * @param  
     * @param  
     */
    setPosition(body: Matter$Body, position: Matter$Vector): void;

    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method  setAngle
     * @param  
     * @param  
     */
    setAngle(body: Matter$Body, angle: number): void;

    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method  setVelocity
     * @param  
     * @param  
     */
    setVelocity(body: Matter$Body, velocity: Matter$Vector): void;

    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method  setAngularVelocity
     * @param  
     * @param  
     */
    setAngularVelocity(body: Matter$Body, velocity: number): void;

    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method  setStatic
     * @param  
     * @param  
     */
    setStatic(body: Matter$Body, isStatic: boolean): void;

    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method  scale
     * @param  
     * @param  
     * @param  
     * @param  
     */
    scale(body: Matter$Body, scaleX: number, scaleY: number, point?: Matter$Vector): void;

    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method  translate
     * @param  
     * @param  
     */
    translate(body: Matter$Body, translation: Matter$Vector): void;

    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method  update
     * @param  
     * @param  
     * @param  
     * @param  
     */
    update(
        body: Matter$Body,
        deltaTime: number,
        timeScale: number,
        correction: number): void;

    /**
     * A `Number` specifying the angle of the body, in radians.
     * @property  angle
     * @type  number
     * @default  0
     */
    angle: number;

    /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     * @readOnly  * 
     * @property  angularSpeed
     * @type  number
     * @default  0
     */
    angularSpeed: number;

    /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only.
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     * @readOnly  * 
     * @property  angularVelocity
     * @type  number
     * @default  0
     */
    angularVelocity: number;

    /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     * @property  area
     * @type  string
     * @default  
     */
    area: number;

    /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
    They are constantly updated by `Body.update` during the simulation.
     * @property  axes
     * @type  vector[]
    */
    axes: Array<Matter$Vector>;

    /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     * @property  bounds
     * @type  bounds
     */
    bounds: Matter$Bounds;

    /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
    This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     * @property  density
     * @type  number
     * @default  0.001
    */
    density: number;

    /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     * @property  force
     * @type  vector
     * @default  { x: 0, y: 0 }
     */
    force: Matter$Vector;

    /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
    A value of `1` means the body may come to a stop almost instantly after a force is applied.

    The effects of the value may be non-linear.
    High values may be unstable depending on the body.
    The engine uses a Coulomb friction model including static and kinetic friction.
    Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:

        Math.min(bodyA.friction, bodyB.friction)
     * @property  friction
     * @type  number
     * @default  0.1
    */
    friction: number;

    /**
     * A `Number` that defines the air friction of the body (air resistance).
     * A value of `0` means the body will never slow as it moves through space.
    The higher the value, the faster a body slows when moving through space.
    The effects of the value are non-linear.
     * @property  frictionAir
     * @type  number
     * @default  0.01
    */
    frictionAir: number;

    /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     * @property  id
     * @type  number
     */
    id: number;

    /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
    If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     * @property  inertia
     * @type  number
    */
    inertia: number;

    /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     * @property  inverseInertia
     * @type  number
     */
    inverseInertia: number;

    /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     * @property  inverseMass
     * @type  number
     */
    inverseMass: number;

    /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     * @property  isSleeping
     * @type  boolean
     * @default  false
     */
    isSleeping: boolean;

    /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     * @property  isStatic
     * @type  boolean
     * @default  false
     */
    isStatic: boolean;

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     * @property  label
     * @type  string
     * @default  "Body"
     */
    label: string;

    /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     * @property  mass
     * @type  number
     */
    mass: number;

    /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     * @readOnly  * 
     * @property  motion
     * @type  number
     * @default  0
     */
    motion: number;

    /**
     * A `Vector` that specifies the current world-space position of the body.
     * @property  position
     * @type  vector
     * @default  { x: 0, y:      
     */
    position: Matter$Vector;

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     * @property  render
     * @type  object
     */
    render: Matter$IBodyRenderOptions;

    /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur.
    A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
    Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:

        Math.max(bodyA.restitution, bodyB.restitution)
     * @property  restitution
     * @type  number
     * @default  0
    */
    restitution: number;

    /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     * @property  sleepThreshold
     * @type  number
     * @default  60
     */
    sleepThreshold: number;

    /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
    The default should generally suffice, although very large bodies may require larger values for stable stacking.
     * @property  slop
     * @type  number
     * @default  0.05
    */
    slop: number;

    /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     * @readOnly  * 
     * @property  speed
     * @type  number
     * @default  0
     */
    speed: number;

    /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     * @property  timeScale
     * @type  number
     * @default  1
     */
    timeScale: number;

    /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     * @property  torque
     * @type  number
     * @default  0
     */
    torque: number;

    /**
     * A `String` denoting the type of object.
     * @property  type
     * @type  string
     * @default  "body"
     */
    type: string;

    /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only.
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     * @readOnly  * 
     * @property  velocity
     * @type  vector
     * @default  { x: 0, y: 0 }
     */
    velocity: Matter$Vector;

    /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.

        [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]

    When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
    The `Vector` objects are also augmented with additional properties required for efficient collision detection.

    Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
    Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     * @property  vertices
     * @type  vector[]
    */
    vertices: Array<Matter$Vector>;

    /**
     * An array of bodies that make up this body.
     * The first body in the array must always be a self reference to the current body instance.
    All bodies in the `parts` array together form a single rigid compound body.
    Parts are allowed to overlap, have gaps or holes or even form concave bodies.
    Parts themselves should never be added to a `World`, only the parent body should be.
    Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     * @property  parts
     * @type  body[]
    */
    parts: Array<Matter$Body>;

    /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
    See `body.parts`.
     * @property  parent
     * @type  body
    */
    parent: Matter$Body;

    /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model).
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
    The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
    This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     * @property  frictionStatic
     * @type  number
     * @default  0.5
    */
    frictionStatic: number;

    /**
     * An `Object` that specifies the collision filtering properties of this body.
     * 
    Collisions between two bodies will obey the following rules:
    - If the two bodies have the same non-zero value of `collisionFilter.group`,
      they will always collide if the value is positive, and they will never collide
      if the value is negative.
    - If the two bodies have different values of `collisionFilter.group` or if one
      (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:

    Each body belongs to a collision category, given by `collisionFilter.category`. This
    value is used as a bit field and the category should have only one bit set, meaning that
    the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
    different collision categories available.

    Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
    the categories it collides with (the value is the bitwise AND value of all these categories).

    Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
    category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
    are both true.
     * @property  collisionFilter
     * @type  object
    */
    collisionFilter: Matter$ICollisionFilter
}

declare
export interface Matter$IBound {
    min: {
            x: number,
            y: number
        },
        max: {
            x: number,
            y: number
        }
}


/**
 * The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
 * @class  Bounds
 */
declare
export class Bounds {

    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method  create
     * @param  
     * @return  A new bounds object
     */
    create(vertices: Matter$Vertices): Matter$Bounds;

    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method  update
     * @param  
     * @param  
     * @param  
     */
    update(
        bounds: Matter$Bounds,
        vertices: Matter$Vertices,
        velocity: Matter$Vector): void;

    /**
     * Returns true if the bounds contains the given point.
     * @method  contains
     * @param  
     * @param  
     * @return  True if the bounds contain the point, otherwise false
     */
    contains(bounds: Matter$Bounds, point: Matter$Vector): boolean;

    /**
     * Returns true if the two bounds intersect.
     * @method  overlaps
     * @param  
     * @param  
     * @return  True if the bounds overlap, otherwise false
     */
    overlaps(boundsA: Matter$Bounds, boundsB: Matter$Bounds): boolean;

    /**
     * Translates the bounds by the given vector.
     * @method  translate
     * @param  
     * @param  
     */
    translate(bounds: Matter$Bounds, vector: Matter$Vector): void;

    /**
     * Shifts the bounds to the given position.
     * @method  shift
     * @param  
     * @param  
     */
    shift(bounds: Matter$Bounds, position: Matter$Vector): void
}

declare
export interface Matter$ICompositeDefinition {

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
    If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     * @property  bodies
     * @type  body[]
     * @default  []
    */
    bodies?: Array<Matter$Body>,

        /**
         * An array of `Composite` that are _direct_ children of this composite.
         * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
        If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
         * @property  composites
         * @type  composite[]
         * @default  []
        */
        composites?: Array<Matter$Composite>,

        /**
         * An array of `Constraint` that are _direct_ children of this composite.
         * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
        If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
         * @property  constraints
         * @type  constraint[]
         * @default  []
        */
        constraints?: Array<Matter$Constraint>,

        /**
         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
         * @property  id
         * @type  number
         */
        id?: number,

        /**
         * A flag that specifies whether the composite has been modified during the current step.
         * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
        If you need to change it manually, you should use the `Composite.setModified` method.
         * @property  isModified
         * @type  boolean
         * @default  false
        */
        isModified?: boolean,

        /**
         * An arbitrary `String` name to help the user identify and manage composites.
         * @property  label
         * @type  string
         * @default  "Composite"
         */
        label?: string,

        /**
         * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
         * @property  parent
         * @type  composite
         * @default  null
         */
        parent?: Matter$Composite,

        /**
         * A `String` denoting the type of object.
         * @property  type
         * @type  string
         * @default  "composite"
         */
        type?: String
}


/**
 * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
 * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Composite
*/
declare
export class Composite {

    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method  add
     * @param  
     * @param  
     * @return  The original composite with the objects added
     */
    add(
        composite: Matter$Composite,
        object: Matter$Body | Matter$Composite | Matter$Constraint): Matter$Composite;

    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method  allBodies
     * @param  
     * @return  All the bodies
     */
    allBodies(composite: Matter$Composite): Array<Matter$Body>;

    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method  allComposites
     * @param  
     * @return  All the composites
     */
    allComposites(composite: Matter$Composite): Array<Matter$Composite>;

    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method  allConstraints
     * @param  
     * @return  All the constraints
     */
    allConstraints(composite: Matter$Composite): Array<Matter$Composite>;

    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method  clear
     * @param  
     * @param  
     * @param  
     */
    clear(composite: Matter$Composite, keepStatic: boolean, deep?: boolean): void;

    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  * 
     * @return  A new composite
     */
    create(options?: Matter$ICompositeDefinition): Matter$Composite;

    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method  get
     * @param  
     * @param  
     * @param  
     * @return  The requested object, if found
     */
    get(
        composite: Matter$Composite,
        id: number,
        type: string): Matter$Body | Matter$Composite | Matter$Constraint;

    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method  move
     * @param  
     * @param  
     * @param  
     * @return  Returns compositeA
     */
    move(
        compositeA: Matter$Composite,
        objects: Array<Matter$Body | Matter$Composite | Matter$Constraint>,
        compositeB: Matter$Composite): Matter$Composite;

    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method  rebase
     * @param  
     * @return  Returns composite
     */
    rebase(composite: Matter$Composite): Matter$Composite;

    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
    Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method  remove
     * @param  
     * @param  
     * @param  * 
     * @return  The original composite with the objects removed
    */
    remove(
        composite: Matter$Composite,
        object: Matter$Body | Matter$Composite | Matter$Constraint,
        deep?: boolean): Matter$Composite;

    /**
     * Sets the composite's `isModified` flag.
     * If `updateParents` is true, all parents will be set (default: false).
    If `updateChildren` is true, all children will be set (default: false).
     * @method  setModified
     * @param  
     * @param  
     * @param  * 
     * @param  
    */
    setModified(
        composite: Matter$Composite,
        isModified: boolean,
        updateParents?: boolean,
        updateChildren?: boolean): void;

    /**
     * Translates all children in the composite by a given vector relative to their current positions,
     * without imparting any velocity.
     * @method  translate
     * @param  
     * @param  
     * @param  
     */
    translate(
        composite: Matter$Composite,
        translation: Matter$Vector,
        recursive?: boolean): void;

    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method  rotate
     * @param  
     * @param  
     * @param  
     * @param  
     */
    rotate(
        composite: Matter$Composite,
        rotation: number,
        point: Matter$Vector,
        recursive?: boolean): void;

    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method  scale
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     */
    scale(
        composite: Matter$Composite,
        scaleX: number,
        scaleY: number,
        point: Matter$Vector,
        recursive?: boolean): void;

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
    If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     * @property  bodies
     * @type  body[]
     * @default  []
    */
    bodies: Array<Matter$Body>;

    /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
    If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     * @property  composites
     * @type  composite[]
     * @default  []
    */
    composites: Array<Matter$Composite>;

    /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
    If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     * @property  constraints
     * @type  constraint[]
     * @default  []
    */
    constraints: Array<Matter$Constraint>;

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     * @property  id
     * @type  number
     */
    id: number;

    /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
    If you need to change it manually, you should use the `Composite.setModified` method.
     * @property  isModified
     * @type  boolean
     * @default  false
    */
    isModified: boolean;

    /**
     * An arbitrary `String` name to help the user identify and manage composites.
     * @property  label
     * @type  string
     * @default  "Composite"
     */
    label: string;

    /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     * @property  parent
     * @type  composite
     * @default  null
     */
    parent: Matter$Composite;

    /**
     * A `String` denoting the type of object.
     * @property  type
     * @type  string
     * @default  "composite"
     */
    type: String
}


/**
 * The `Matter.Composites` module contains factory methods for creating composite bodies
 * with commonly used configurations (such as stacks and chains).

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Composites
*/
declare
export class Composites {

    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method  car
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite car body
     */
    car(
        xx: number,
        yy: number,
        width: number,
        height: number,
        wheelSize: number): Matter$Composite;

    /**
     * Chains all bodies in the given composite together using constraints.
     * @method  chain
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite containing objects chained together with constraints
     */
    chain(
        composite: Matter$Composite,
        xOffsetA: number,
        yOffsetA: number,
        xOffsetB: number,
        yOffsetB: number,
        options: any): Matter$Composite;

    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method  mesh
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  The composite containing objects meshed together with constraints
     */
    mesh(
        composite: Matter$Composite,
        columns: number,
        rows: number,
        crossBrace: boolean,
        options: any): Matter$Composite;

    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method  newtonsCradle
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite newtonsCradle body
     */
    newtonsCradle(
        xx: number,
        yy: number,
        _number: number,
        size: number,
        length: number): Matter$Composite;

    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method  pyramid
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite containing objects created in the callback
     */
    pyramid(
        xx: number,
        yy: number,
        columns: number,
        rows: number,
        columnGap: number,
        rowGap: number,
        callback: Function): Matter$Composite;

    /**
     * Creates a simple soft body like object.
     * @method  softBody
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite softBody
     */
    softBody(
        xx: number,
        yy: number,
        columns: number,
        rows: number,
        columnGap: number,
        rowGap: number,
        crossBrace: boolean,
        particleRadius: number,
        particleOptions: any,
        constraintOptions: any): Matter$Composite;

    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method  stack
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     * @return  A new composite containing objects created in the callback
     */
    stack(
        xx: number,
        yy: number,
        columns: number,
        rows: number,
        columnGap: number,
        rowGap: number,
        callback: Function): Matter$Composite
}

declare
export interface Matter$IConstraintDefinition {

    /**
     * The first possible `Body` that this constraint is attached to.
     * @property  bodyA
     * @type  body
     * @default  null
     */
    bodyA?: Matter$Body,

        /**
         * The second possible `Body` that this constraint is attached to.
         * @property  bodyB
         * @type  body
         * @default  null
         */
        bodyB?: Matter$Body,

        /**
         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
         * @property  id
         * @type  number
         */
        id?: number,

        /**
         * An arbitrary `String` name to help the user identify and manage bodies.
         * @property  label
         * @type  string
         * @default  "Constraint"
         */
        label?: string,

        /**
         * A `Number` that specifies the target resting length of the constraint.
         * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
         * @property  length
         * @type  number
         */
        length?: number,

        /**
         * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
         * @property  pointA
         * @type  vector
         * @default  { x: 0, y: 0 }
         */
        pointA?: Matter$Vector,

        /**
         * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
         * @property  pointB
         * @type  vector
         * @default  { x: 0, y: 0 }
         */
        pointB?: Matter$Vector,

        /**
         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
         * @property  render
         * @type  object
         */
        render?: Matter$IConstraintRenderDefinition,

        /**
         * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
         * A value of `1` means the constraint should be very stiff.
        A value of `0.2` means the constraint acts like a soft spring.
         * @property  stiffness
         * @type  number
         * @default  1
        */
        stiffness?: number,

        /**
         * A `String` denoting the type of object.
         * @property  type
         * @type  string
         * @default  "constraint"
         */
        type?: string
}

declare
export interface Matter$IConstraintRenderDefinition {

    /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     * @property  render.lineWidth
     * @type  number
     * @default  2
     */
    lineWidth: number,

        /**
         * A `String` that defines the stroke style to use when rendering the constraint outline.
         * It is the same as when using a canvas, so it accepts CSS style property values.
         * @property  render.strokeStyle
         * @type  string
         * @default  a random colour
         */
        strokeStyle: string,

        /**
         * A flag that indicates if the constraint should be rendered.
         * @property  render.visible
         * @type  boolean
         * @default  true
         */
        visible: boolean
}


/**
 * The `Matter.Constraint` module contains methods for creating and manipulating constraints.
 * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
The stiffness of constraints can be modified to create springs or elastic.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Constraint
*/
declare
export class Constraint {

    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  
     * @return  constraint
    */
    create(options: Matter$IConstraintDefinition): Matter$Constraint;

    /**
     * The first possible `Body` that this constraint is attached to.
     * @property  bodyA
     * @type  body
     * @default  null
     */
    bodyA: Matter$Body;

    /**
     * The second possible `Body` that this constraint is attached to.
     * @property  bodyB
     * @type  body
     * @default  null
     */
    bodyB: Matter$Body;

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     * @property  id
     * @type  number
     */
    id: number;

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     * @property  label
     * @type  string
     * @default  "Constraint"
     */
    label: string;

    /**
     * A `Number` that specifies the target resting length of the constraint.
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     * @property  length
     * @type  number
     */
    length: number;

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     * @property  pointA
     * @type  vector
     * @default  { x: 0, y: 0 }
     */
    pointA: Matter$Vector;

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     * @property  pointB
     * @type  vector
     * @default  { x: 0, y: 0 }
     */
    pointB: Matter$Vector;

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     * @property  render
     * @type  object
     */
    render: Matter$IConstraintRenderDefinition;

    /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
    A value of `0.2` means the constraint acts like a soft spring.
     * @property  stiffness
     * @type  number
     * @default  1
    */
    stiffness: number;

    /**
     * A `String` denoting the type of object.
     * @property  type
     * @type  string
     * @default  "constraint"
     */
    type: string
}

declare
export interface Matter$IEngineDefinition {

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * @property  positionIterations
     * @type  number
     * @default  6
     */
    positionIterations?: number,

        /**
         * An integer `Number` that specifies the number of velocity iterations to perform each update.
         * The higher the value, the higher quality the simulation will be at the expense of performance.
         * @property  velocityIterations
         * @type  number
         * @default  4
         */
        velocityIterations?: number,

        /**
         * An integer `Number` that specifies the number of constraint iterations to perform each update.
         * The higher the value, the higher quality the simulation will be at the expense of performance.
        The default value of `2` is usually very adequate.
         * @property  constraintIterations
         * @type  number
         * @default  2
        */
        constraintIterations?: number,

        /**
         * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
         * Sleeping can improve stability and performance, but often at the expense of accuracy.
         * @property  enableSleeping
         * @type  boolean
         * @default  false
         */
        enableSleeping?: boolean,

        /**
         * An `Object` containing properties regarding the timing systems of the engine.
         * @property  timing
         * @type  object
         */
        timing?: Matter$IEngineTimingOptions,

        /**
         * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
         * @property  broadphase
         * @type  grid
         * @default  a Matter.Grid instance
         */
        grid?: Matter$Grid,

        /**
         * A `World` composite object that will contain all simulated bodies and constraints.
         * @property  world
         * @type  world
         * @default  a Matter.World instance
         */
        world?: Matter$World
}

declare
export interface Matter$IEngineTimingOptions {

    /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
    A value of `0.1` gives a slow-motion effect.
    A value of `1.2` gives a speed-up effect.
     * @property  timing.timeScale
     * @type  number
     * @default  1
    */
    timeScale: number,

        /**
         * A `Number` that specifies the current simulation-time in milliseconds starting from `0`.
         * It is incremented on every `Engine.update` by the given `delta` argument.
         * @property  timing.timestamp
         * @type  number
         * @default  0
         */
        timestamp: number
}


/**
 * The `Matter.Engine` module contains methods for creating and manipulating engines.
 * An engine is a controller that manages updating the simulation of the world.
See `Matter.Runner` for an optional game loop utility.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Engine
*/
declare
export class Engine {

    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method  clear
     * @param  
     */
    clear(engine: Matter$Engine): void;

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  
     * @param  * 
     * @return  engine
     * @deprecated  
    */
    create(
        element?: HTMLElement | Matter$IEngineDefinition,
        options?: Matter$IEngineDefinition): Matter$Engine;

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  * 
     * @return  engine
     * @deprecated  
    */
    create(options?: Matter$IEngineDefinition): Matter$Engine;

    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method  merge
     * @param  
     * @param  
     */
    merge(engineA: Matter$Engine, engineB: Matter$Engine): void;

    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
    This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
    The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
    Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
    See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.

    Triggers `beforeUpdate` and `afterUpdate` events.
    Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method  update
     * @param  
     * @param  * 
     * @param  
    */
    update(engine: Matter$Engine, delta?: number, correction?: number): Matter$Engine;

    /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method  run
     * @param  
     */
    run(enige: Matter$Engine): void;

    /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     * @property  broadphase
     * @type  grid
     * @default  a Matter.Grid instance
     */
    broadphase: Matter$Grid;

    /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
    The default value of `2` is usually very adequate.
     * @property  constraintIterations
     * @type  number
     * @default  2
    */
    constraintIterations: number;

    /**
     * A flag that specifies whether the engine is running or not.
     */
    enabled: boolean;

    /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     * @property  enableSleeping
     * @type  boolean
     * @default  false
     */
    enableSleeping: boolean;

    /**
     * Collision pair set for this `Engine`.
     */
    pairs: any;

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * @property  positionIterations
     * @type  number
     * @default  6
     */
    positionIterations: number;

    /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.

    A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
    It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     * @property  render
     * @type  render
     * @default  a Matter.Render instance
    */
    render: Matter$Render;

    /**
     * An `Object` containing properties regarding the timing systems of the engine.
     * @property  timing
     * @type  object
     */
    timing: Matter$IEngineTimingOptions;

    /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * @property  velocityIterations
     * @type  number
     * @default  4
     */
    velocityIterations: number;

    /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     * @property  world
     * @type  world
     * @default  a Matter.World instance
     */
    world: Matter$World
}

declare
export interface Matter$IGridDefinition {}


/**
 * The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
 * @class  Grid
 */
declare
export class Grid {

    /**
     * Creates a new grid.
     * @method  create
     * @param  
     * @return  A new grid
     */
    create(options?: Matter$IGridDefinition): Matter$Grid;

    /**
     * Updates the grid.
     * @method  update
     * @param  
     * @param  
     * @param  
     * @param  
     */
    update(
        grid: Matter$Grid,
        bodies: Array<Matter$Body>,
        engine: Matter$Engine,
        forceUpdate: boolean): void;

    /**
     * Clears the grid.
     * @method  clear
     * @param  
     */
    clear(grid: Matter$Grid): void
}

declare
export interface Matter$IMouseConstraintDefinition {

    /**
     * The `Constraint` object that is used to move the body during interaction.
     * @property  constraint
     * @type  constraint
     */
    constraint?: Matter$Constraint,

        /**
         * An `Object` that specifies the collision filter properties.
         * The collision filter allows the user to define which types of body this mouse constraint can interact with.
        See `body.collisionFilter` for more information.
         * @property  collisionFilter
         * @type  object
        */
        collisionFilter?: Matter$ICollisionFilter,

        /**
         * The `Body` that is currently being moved by the user, or `null` if no body.
         * @property  body
         * @type  body
         * @default  null
         */
        body?: Matter$Body,

        /**
         * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
         * @property  mouse
         * @type  mouse
         * @default  mouse
         */
        mouse?: Matter$Mouse,

        /**
         * A `String` denoting the type of object.
         * @property  type
         * @type  string
         * @default  "constraint"
         */
        type?: string
}


/**
 * The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
 * Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  MouseConstraint
*/
declare
export class MouseConstraint {

    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  
     * @param  
     * @return  A new MouseConstraint
    */
    create(
        engine: Matter$Engine,
        options?: Matter$IMouseConstraintDefinition): Matter$MouseConstraint;

    /**
     * The `Constraint` object that is used to move the body during interaction.
     * @property  constraint
     * @type  constraint
     */
    constraint: Matter$Constraint;

    /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
    See `body.collisionFilter` for more information.
     * @property  collisionFilter
     * @type  object
    */
    collisionFilter: Matter$ICollisionFilter;

    /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     * @property  body
     * @type  body
     * @default  null
     */
    body: Matter$Body;

    /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     * @property  mouse
     * @type  mouse
     * @default  mouse
     */
    mouse: Matter$Mouse;

    /**
     * A `String` denoting the type of object.
     * @property  type
     * @type  string
     * @default  "constraint"
     */
    type: string
}


/**
 * The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
 * @class  Pairs
 */
declare
export class Pairs {

    /**
     * Clears the given pairs structure.
     * @method  clear
     * @param  
     * @return  pairs
     */
    clear(pairs: any): any
}

declare
export interface Matter$IPair {
    id: number,
        bodyA: Matter$Body,
        bodyB: Matter$Body,
        contacts: any,
        activeContacts: any,
        separation: number,
        isActive: boolean,
        timeCreated: number,
        timeUpdated: number,
        inverseMass: number,
        friction: number,
        frictionStatic: number,
        restitution: number,
        slop: number
}


/**
 * The `Matter.Query` module contains methods for performing collision queries.
 * 
See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Query
*/
declare
export class Query {

    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method  ray
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @return  Collisions
     */
    ray(
        bodies: Array<Matter$Body>,
        startPoint: Matter$Vector,
        endPoint: Matter$Vector,
        rayWidth?: number): Array<any>;

    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method  region
     * @param  
     * @param  
     * @param  * 
     * @return  The bodies matching the query
     */
    region(
        bodies: Array<Matter$Body>,
        bounds: Matter$Bounds,
        outside?: boolean): Array<Matter$Body>;

    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method  point
     * @param  
     * @param  
     * @return  The bodies matching the query
     */
    point(bodies: Array<Matter$Body>, point: Matter$Vector): Array<Matter$Body >
}

declare
export interface Matter$IRenderDefinition {

    /**
     * A back-reference to the `Matter.Render` module.
     * @property  controller
     * @type  render
     */
    controller?: any,

        /**
         * A reference to the `Matter.Engine` instance to be used.
         * @property  engine
         * @type  engine
         */
        engine: Matter$Engine,

        /**
         * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
         * @property  element
         * @type  HTMLElement
         * @default  null
         * @deprecated  
         */
        element?: HTMLElement,

        /**
         * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
         * @property  canvas
         * @type  HTMLCanvasElement
         * @default  null
         */
        canvas?: HTMLCanvasElement,

        /**
         * The configuration options of the renderer.
         * @property  options
         * @type  
         */
        options?: Matter$IRendererOptions,

        /**
         * A `Bounds` object that specifies the drawing view region.
         * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
        This allows for creating views that can pan or zoom around the scene.
        You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
         * @property  bounds
         * @type  bounds
        */
        bounds?: Matter$Bounds,

        /**
         * The 2d rendering context from the `render.canvas` element.
         * @property  context
         * @type  CanvasRenderingContext2D
         */
        context?: CanvasRenderingContext2D,

        /**
         * The sprite texture cache.
         * @property  textures
         * @type  
         */
        textures?: any
}

declare
export interface Matter$IRendererOptions {

    /**
     * The target width in pixels of the `render.canvas` to be created.
     * @property  options.width
     * @type  number
     * @default  800
     */
    width?: number,

        /**
         * The target height in pixels of the `render.canvas` to be created.
         * @property  options.height
         * @type  number
         * @default  600
         */
        height?: number,

        /**
         * A flag that specifies if `render.bounds` should be used when rendering.
         * @property  options.hasBounds
         * @type  boolean
         * @default  false
         */
        hasBounds?: boolean,

        /**
         * Render wireframes only
         * @type  boolean
         * @default  true 
         */
        wireframes?: boolean
}


/**
 * The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
 * It is intended for development and debugging purposes, but may also be suitable for simple games.
It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
 * @class  Render
*/
declare
export class Render {

    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
    See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @param  * 
     * @return  A new renderer
    */
    create(options: Matter$IRenderDefinition): Matter$Render;

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method  run
     * @param  
     */
    run(render: Matter$Render): void;

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method  stop
     * @param  
     */
    stop(render: Matter$Render): void;

    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method  setPixelRatio
     * @param  
     * @param  
     */
    setPixelRatio(render: Matter$Render, pixelRatio: number): void;

    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method  world
     * @param  
     */
    world(render: Matter$Render): void;

    /**
     * A back-reference to the `Matter.Render` module.
     * @property  controller
     * @type  render
     */
    controller: any;

    /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     * @property  element
     * @type  HTMLElement
     * @default  null
     */
    element: HTMLElement;

    /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     * @property  canvas
     * @type  HTMLCanvasElement
     * @default  null
     */
    canvas: HTMLCanvasElement;

    /**
     * The configuration options of the renderer.
     * @property  options
     * @type  
     */
    options: Matter$IRendererOptions;

    /**
     * A `Bounds` object that specifies the drawing view region.
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
    This allows for creating views that can pan or zoom around the scene.
    You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     * @property  bounds
     * @type  bounds
    */
    bounds: Matter$Bounds;

    /**
     * The 2d rendering context from the `render.canvas` element.
     * @property  context
     * @type  CanvasRenderingContext2D
     */
    context: CanvasRenderingContext2D;

    /**
     * The sprite texture cache.
     * @property  textures
     * @type  
     */
    textures: any
}

declare
export interface Matter$IRunnerOptions {

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
    If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     * @property  isFixed
     * @type  boolean
     * @default  false
    */
    isFixed?: boolean,

        /**
         * A `Number` that specifies the time step between updates in milliseconds.
         * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
        If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
         * @property  delta
         * @type  number
         * @default  1000 / 60
        */
        delta?: number
}


/**
 * The `Matter.Runner` module is an optional utility which provides a game loop,
 * that handles updating and rendering a `Matter.Engine` for you within a browser.
It is intended for demo and testing purposes, but may be adequate for simple games.
If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
Instead just call `Engine.update(engine, delta)` in your own loop.
Note that the method `Engine.run` is an alias for `Runner.run`.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Runner
*/
declare
export class Runner {

    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method  create
     * @param  
     */
    create(options: Matter$IRunnerOptions): Matter$Runner;

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method  run
     * @param  
     */
    run(runner: Matter$Runner, engine: Matter$Engine): Matter$Runner;

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method  run
     * @param  
     */
    run(engine: Matter$Engine): Matter$Runner;

    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
    Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
    Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method  tick
     * @param  
     * @param  
     * @param  
    */
    tick(runner: Matter$Runner, engine: Matter$Engine, time: number): void;

    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method  stop
     * @param  
     */
    stop(runner: Matter$Runner): void;

    /**
     * Alias for `Runner.run`.
     * @method  start
     * @param  
     * @param  
     */
    start(runner: Matter$Runner, engine: Matter$Engine): void;

    /**
     * A flag that specifies whether the runner is running or not.
     * @property  enabled
     * @type  boolean
     * @default  true
     */
    enabled: boolean;

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
    If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     * @property  isFixed
     * @type  boolean
     * @default  false
    */
    isFixed: boolean;

    /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
    If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     * @property  delta
     * @type  number
     * @default  1000 / 60
    */
    delta: number
}


/**
 * The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
 * @class  Sleeping
 */
declare
export class Sleeping {
    set(body: Matter$Body, isSleeping: boolean): void
}


/**
 * The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
 * 
See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Svg
*/
declare
export class Svg {

    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
    See `Bodies.fromVertices` which provides support for this.
    Note that this function is not guaranteed to support complex paths (such as those with holes).
     * @method  pathToVertices
     * @param  
     * @param  * 
     * @return  points
    */
    pathToVertices(path: SVGPathElement, sampleLength: number): Array<Matter$Vector >
}


/**
 * The `Matter.Vector` module contains methods for creating and manipulating vectors.
 * Vectors are the basis of all the geometry related operations in the engine.
A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Vector
*/
declare
export class Vector {
    x: number;
    y: number;

    /**
     * Creates a new vector.
     * @method  create
     * @param  
     * @param  
     * @return  A new vector
     */
    create(x?: number, y?: number): Matter$Vector;

    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method  clone
     * @param  
     * @return  A new cloned vector
     */
    clone(vector: Matter$Vector): Matter$Vector;

    /**
     * Returns the cross-product of three vectors.
     * @method  cross3
     * @param  
     * @param  
     * @param  
     * @return  The cross product of the three vectors
     */
    cross3(vectorA: Matter$Vector, vectorB: Matter$Vector, vectorC: Matter$Vector): number;

    /**
     * Adds the two vectors.
     * @method  add
     * @param  
     * @param  
     * @param  * 
     * @return  A new vector of vectorA and vectorB added
     */
    add(
        vectorA: Matter$Vector,
        vectorB: Matter$Vector,
        output?: Matter$Vector): Matter$Vector;

    /**
     * Returns the angle in radians between the two vectors relative to the x-axis.
     * @method  angle
     * @param  
     * @param  
     * @return  The angle in radians
     */
    angle(vectorA: Matter$Vector, vectorB: Matter$Vector): number;

    /**
     * Returns the cross-product of two vectors.
     * @method  cross
     * @param  
     * @param  
     * @return  The cross product of the two vectors
     */
    cross(vectorA: Matter$Vector, vectorB: Matter$Vector): number;

    /**
     * Divides a vector and a scalar.
     * @method  div
     * @param  
     * @param  
     * @return  A new vector divided by scalar
     */
    div(vector: Matter$Vector, scalar: number): Matter$Vector;

    /**
     * Returns the dot-product of two vectors.
     * @method  dot
     * @param  
     * @param  
     * @return  The dot product of the two vectors
     */
    dot(vectorA: Matter$Vector, vectorB: Matter$Vector): Number;

    /**
     * Returns the magnitude (length) of a vector.
     * @method  magnitude
     * @param  
     * @return  The magnitude of the vector
     */
    magnitude(vector: Matter$Vector): number;

    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method  magnitudeSquared
     * @param  
     * @return  The squared magnitude of the vector
     */
    magnitudeSquared(vector: Matter$Vector): number;

    /**
     * Multiplies a vector and a scalar.
     * @method  mult
     * @param  
     * @param  
     * @return  A new vector multiplied by scalar
     */
    mult(vector: Matter$Vector, scalar: number): Matter$Vector;

    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method  neg
     * @param  
     * @return  The negated vector
     */
    neg(vector: Matter$Vector): Matter$Vector;

    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method  normalise
     * @param  
     * @return  A new vector normalised
     */
    normalise(vector: Matter$Vector): Matter$Vector;

    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method  perp
     * @param  
     * @param  * 
     * @return  The perpendicular vector
     */
    perp(vector: Matter$Vector, negate?: boolean): Matter$Vector;

    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method  rotate
     * @param  
     * @param  
     * @return  A new vector rotated about (0, 0)
     */
    rotate(vector: Matter$Vector, angle: number): Matter$Vector;

    /**
     * Rotates the vector about a specified point by specified angle.
     * @method  rotateAbout
     * @param  
     * @param  
     * @param  
     * @param  * 
     * @return  A new vector rotated about the point
     */
    rotateAbout(
        vector: Matter$Vector,
        angle: number,
        point: Matter$Vector,
        output?: Matter$Vector): Matter$Vector;

    /**
     * Subtracts the two vectors.
     * @method  sub
     * @param  
     * @param  
     * @param  * 
     * @return  A new vector of vectorA and vectorB subtracted
     */
    sub(
        vectorA: Matter$Vector,
        vectorB: Matter$Vector,
        optional?: Matter$Vector): Matter$Vector
}


/**
 * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
 * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  Vertices
*/
declare
export class Vertices {

    /**
     * Returns the average (mean) of the set of vertices.
     * @method  mean
     * @param  
     * @return  The average point
     */
    mean(vertices: Array<Matter$Vector>): Array<Matter$Vector>;

    /**
     * Sorts the input vertices into clockwise order in place.
     * @method  clockwiseSort
     * @param  
     * @return  vertices
     */
    clockwiseSort(vertices: Array<Matter$Vector>): Array<Matter$Vector>;

    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method  isConvex
     * @param  
     * @return  `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */
    isConvex(vertices: Array<Matter$Vector>): boolean;

    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method  hull
     * @param  
     * @return  [vertex] vertices
     */
    hull(vertices: Array<Matter$Vector>): Array<Matter$Vector>;

    /**
     * Returns the area of the set of vertices.
     * @method  area
     * @param  
     * @param  
     * @return  The area
     */
    area(vertices: Array<Matter$Vector>, signed: boolean): number;

    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method  centre
     * @param  
     * @return  The centre point
     */
    centre(vertices: Array<Matter$Vector>): Matter$Vector;

    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method  chamfer
     * @param  
     * @param  
     * @param  
     * @param  
     * @param  
     */
    chamfer(
        vertices: Array<Matter$Vector>,
        radius: number | Array<number>,
        quality: number,
        qualityMin: number,
        qualityMax: number): void;

    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method  contains
     * @param  
     * @param  
     * @return  True if the vertices contains point, otherwise false
     */
    contains(vertices: Array<Matter$Vector>, point: Matter$Vector): boolean;

    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:

        [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]

    The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
    but with some additional references required for efficient collision detection routines.

    Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     * @method  create
     * @param  
     * @param  
    */
    create(points: Array<Matter$Vector>, body: Matter$Body): void;

    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas),
     * into a `Matter.Vertices` object for the given `Matter.Body`.
    For parsing SVG paths, see `Svg.pathToVertices`.
     * @method  fromPath
     * @param  
     * @param  
     * @return  vertices
    */
    fromPath(path: string, body: Matter$Body): Array<Matter$Vector>;

    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method  inertia
     * @param  
     * @param  
     * @return  The polygon's moment of inertia
     */
    inertia(vertices: Array<Matter$Vector>, mass: number): number;

    /**
     * Rotates the set of vertices in-place.
     * @method  rotate
     * @param  
     * @param  
     * @param  
     */
    rotate(vertices: Array<Matter$Vector>, angle: number, point: Matter$Vector): void;

    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method  scale
     * @param  
     * @param  
     * @param  
     * @param  
     */
    scale(
        vertices: Array<Matter$Vector>,
        scaleX: number,
        scaleY: number,
        point: Matter$Vector): void;

    /**
     * Translates the set of vertices in-place.
     * @method  translate
     * @param  
     * @param  
     * @param  
     */
    translate(vertices: Array<Matter$Vector>, vector: Matter$Vector, scalar: number): void
}

declare type Matter$IWorldDefinition = {
    gravity?: Matter$Vector,
    bounds?: Matter$Bounds
} & Matter$ICompositeDefinition



/**
 * The `Matter.World` module contains methods for creating and manipulating the world composite.
 * A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
A `Matter.World` has a few additional properties including `gravity` and `bounds`.
It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
There are also a few methods here that alias those in `Matter.Composite` for easier readability.

See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
 * @class  World
 * @extends  Composite
*/
declare
export class World mixins Composite {

    /**
     * Add objects or arrays of objects of types: Body, Constraint, Composite
     * @param world 
     * @param body 
     * @returns  world
     */
    add(
        world: Matter$World,
        body: Matter$Body |
        Array<Matter$Body >
        |
        Matter$Composite |
        Array<Matter$Composite >
        |
        Matter$Constraint |
        Array<Matter$Constraint >
        |
        Matter$MouseConstraint): Matter$World;

    /**
     * An alias for Composite.addBody since World is also a Composite
     * @method  addBody
     * @param  
     * @param  
     * @return  The original world with the body added
     */
    addBody(world: Matter$World, body: Matter$Body): Matter$World;

    /**
     * An alias for Composite.add since World is also a Composite
     * @method  addComposite
     * @param  
     * @param  
     * @return  The original world with the objects from composite added
     */
    addComposite(world: Matter$World, composite: Matter$Composite): Matter$World;

    /**
     * An alias for Composite.addConstraint since World is also a Composite
     * @method  addConstraint
     * @param  
     * @param  
     * @return  The original world with the constraint added
     */
    addConstraint(world: Matter$World, constraint: Matter$Constraint): Matter$World;

    /**
     * An alias for Composite.clear since World is also a Composite
     * @method  clear
     * @param  
     * @param  
     */
    clear(world: Matter$World, keepStatic: boolean): void;

    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method  create
     * @constructor  * 
     * @param  
     * @return  A new world
     */
    create(options: Matter$IWorldDefinition): Matter$World;
    gravity: Matter$Vector;
    bounds: Matter$Bounds
}

declare
export interface Matter$ICollisionFilter {
    category: number,
        mask: number,
        group: number
}

declare
export interface Matter$IMousePoint {
    x: number,
        y: number
}

declare
export class Mouse {
    create(element: HTMLElement): Matter$Mouse;
    setElement(mouse: Matter$Mouse, element: HTMLElement): void;
    clearSourceEvents(mouse: Matter$Mouse): void;
    setOffset(mouse: Matter$Mouse, offset: Matter$Vector): void;
    setScale(mouse: Matter$Mouse, scale: Matter$Vector): void;
    element: HTMLElement;
    absolute: Matter$IMousePoint;
    position: Matter$IMousePoint;
    mousedownPosition: Matter$IMousePoint;
    mouseupPosition: Matter$IMousePoint;
    offset: Matter$IMousePoint;
    scale: Matter$IMousePoint;
    wheelDelta: number;
    button: number;
    pixelRatio: number
}

declare
export interface Matter$IEvent<T>{

    /**
     * The name of the event
     */
    name: string,

    /**
     * The source object of the event
     */
    source: T
}

declare
export type Matter$IEventComposite<T>= {

    /**
     * EventObjects (may be a single body, constraint, composite or a mixed array of these)
     */
    object: any
} & Matter$IEvent


declare
export type Matter$IEventTimestamped<T>= {

    /**
     * The engine.timing.timestamp of the event
     */
    timestamp: number
} & Matter$IEvent


declare
export type Matter$IEventCollision<T>= {

    /**
     * The collision pair
     */
    pairs: Array<Matter$IPair >
} & Matter$IEventTimestamped


declare
export class Events {

    /**
     * Fired when a body starts sleeping (where `this` is the body).
     * @event  sleepStart
     * @this  {body} The body that has started sleeping
     * @param  An event object
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Body,
        name: "sleepStart",
        callback: (e: Matter$IEvent<Matter$Body>) => void): void;

    /**
     * Fired when a body ends sleeping (where `this` is the body).
     * @event  sleepEnd
     * @this  {body} The body that has ended sleeping
     * @param  An event object
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Body,
        name: "sleepEnd",
        callback: (e: Matter$IEvent<Matter$Body>) => void): void;

    /**
     * Fired when a call to `Composite.add` is made, before objects have been added.
     * @event  beforeAdd
     * @param  An event object
     * @param  .object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeAdd",
        callback: (e: Matter$IEventComposite<Matter$Composite>) => void): void;

    /**
     * Fired when a call to `Composite.add` is made, after objects have been added.
     * @event  afterAdd
     * @param  An event object
     * @param  .object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterAdd",
        callback: (e: Matter$IEventComposite<Matter$Composite>) => void): void;

    /**
     * Fired when a call to `Composite.remove` is made, before objects have been removed.
     * @event  beforeRemove
     * @param  An event object
     * @param  .object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeRemove",
        callback: (e: Matter$IEventComposite<Matter$Composite>) => void): void;

    /**
     * Fired when a call to `Composite.remove` is made, after objects have been removed.
     * @event  afterRemove
     * @param  An event object
     * @param  .object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterRemove",
        callback: (e: Matter$IEventComposite<Matter$Composite>) => void): void;

    /**
     * Fired after engine update and all collision events
     * @event  afterUpdate
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterUpdate",
        callback: (e: Matter$IEventTimestamped<Matter$Engine>) => void): void;

    /**
     * Fired before rendering
     * @event  beforeRender
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeRender",
        callback: (e: Matter$IEventTimestamped<Matter$Render>) => void): void;

    /**
     * Fired after rendering
     * @event  afterRender
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterRender",
        callback: (e: Matter$IEventTimestamped<Matter$Render>) => void): void;

    /**
     * Fired just before an update
     * @event  beforeUpdate
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeUpdate",
        callback: (e: Matter$IEventTimestamped<Matter$Engine>) => void): void;

    /**
     * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
     * @event  collisionActive
     * @param  An event object
     * @param  .pairs List of affected pairs
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "collisionActive",
        callback: (e: Matter$IEventCollision<Matter$Engine>) => void): void;

    /**
     * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
     * @event  collisionEnd
     * @param  An event object
     * @param  .pairs List of affected pairs
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "collisionEnd",
        callback: (e: Matter$IEventCollision<Matter$Engine>) => void): void;

    /**
     * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
     * @event  collisionStart
     * @param  An event object
     * @param  .pairs List of affected pairs
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "collisionStart",
        callback: (e: Matter$IEventCollision<Matter$Engine>) => void): void;

    /**
     * Fired at the start of a tick, before any updates to the engine or timing
     * @event  beforeTick
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeTick",
        callback: (e: Matter$IEventTimestamped<Matter$Runner>) => void): void;

    /**
     * Fired after engine timing updated, but just before update
     * @event  tick
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "tick",
        callback: (e: Matter$IEventTimestamped<Matter$Runner>) => void): void;

    /**
     * Fired at the end of a tick, after engine update and after rendering
     * @event  afterTick
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterTick",
        callback: (e: Matter$IEventTimestamped<Matter$Runner>) => void): void;

    /**
     * Fired before rendering
     * @event  beforeRender
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "beforeRender",
        callback: (e: Matter$IEventTimestamped<Matter$Runner>) => void): void;

    /**
     * Fired after rendering
     * @event  afterRender
     * @param  An event object
     * @param  .timestamp The engine.timing.timestamp of the event
     * @param  .source The source object of the event
     * @param  .name The name of the event
     */
    on(
        obj: Matter$Engine,
        name: "afterRender",
        callback: (e: Matter$IEventTimestamped<Matter$Runner>) => void): void;

    /**
     * Fired when the mouse is down (or a touch has started) during the last step
     * @param obj 
     * @param name 
     * @param callback 
     */
    on(
        obj: Matter$MouseConstraint,
        name: "mousedown",
        callback: (e: any) => void): void;

    /**
     * Fired when the mouse has moved (or a touch moves) during the last step
     * @param obj 
     * @param name 
     * @param callback 
     */
    on(
        obj: Matter$MouseConstraint,
        name: "mousemove",
        callback: (e: any) => void): void;

    /**
     * Fired when the mouse is up (or a touch has ended) during the last step
     * @param obj 
     * @param name 
     * @param callback 
     */
    on(obj: Matter$MouseConstraint, name: "mouseup", callback: (e: any) => void): void;
    on(obj: any, name: string, callback: (e: any) => void): void;

    /**
     * Removes the given event callback. If no callback, clears all callbacks in eventNames. If no eventNames, clears all events.
     * @param obj 
     * @param eventName 
     * @param callback 
     */
    off(obj: any, eventName: string, callback: (e: any) => void): void;

    /**
     * Fires all the callbacks subscribed to the given object's eventName, in the order they subscribed, if any.
     * @param object 
     * @param eventNames 
     * @param event 
     */
    trigger(object: any, eventNames: string, event?: (e: any) => void): void
}