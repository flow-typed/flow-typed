/**
 * Flowtype definitions for d3-dsv
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'd3-dsv' {
    declare var loader: (delimiter: string, encoding?: string) => _d3dsv.D3Dsv;
    declare module.exports: typeof loader
}
declare module '_d3dsv' {

    /**
     * A parser and formatter for DSV (CSV and TSV) files.
     * Extracted from D3. 
     */
    declare export class D3Dsv {

        /**
         * Parses the specified string, which is the contents of a CSV file, returning an array of objects representing the parsed rows. 
         * Thestring is assumed to be RFC4180-compliant. 
        Unlike the parseRows method, this method requires that the first line of the CSV file contains a comma-separated list of column names; 
        these column names become the attributes on the returned objects. 
        Forexample, consider the following CSV file:

        Year,Make,Model,Length
        1997,Ford,E350,2.34
        2000,Mercury,Cougar,2.38

        Theresulting JavaScript array is:

        [{"Year": "1997", "Make": "Ford", "Model": "E350", "Length": "2.34"},
        {"Year": "2000", "Make": "Mercury", "Model": "Cougar", "Length": "2.38"} ]
        */
        parse<TRow>(table: string, accessor?: (row: any) => TRow): TRow[];

        /**
         * Parses the specified string, which is the contents of a CSV file, returning an array of arrays representing the parsed rows. The string is assumed to be RFC4180-compliant. Unlike the parse method, this method treats the header line as a standard row, and should be used whenever the CSV file does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file:
         * 
        1997,Ford,E350,2.34
        2000,Mercury,Cougar,2.38
        Theresulting JavaScript array is:

        [["1997", "Ford", "E350", "2.34"],
        ["2000", "Mercury", "Cougar", "2.38"] ]
        Notethat the values themselves are always strings; they will not be automatically converted to numbers. See parse for details.
        */
        parseRows<TRow>(table: string, accessor?: (row: string[]) => TRow): TRow[];

        /**
         * Converts the specified array of rows into comma-separated values format, returning a string. This operation is the reverse of parse. Each row will be separated by a newline (\n), and each column within each row will be separated by a comma (,). Values that contain either commas, double-quotes (") or newlines will be escaped using double-quotes.
         * 
        Eachrow should be an object, and all object properties will be converted into fields. For greater control over which properties are converted, convert the rows into arrays containing only the properties that should be converted and use formatRows. 
        */
        format(rows: any[]): string;

        /**
         * Converts the specified array of rows into comma-separated values format, returning a string. This operation is the reverse of parseRows. Each row will be separated by a newline (\n), and each column within each row will be separated by a comma (,). Values that contain either commas, double-quotes (") or newlines will be escaped using double-quotes. 
         */
        formatRows(rows: any[]): string
    }
}