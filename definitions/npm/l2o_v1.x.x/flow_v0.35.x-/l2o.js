/**
 * Flowtype definitions for l2o
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
export interface Ix$Disposable {
    dispose(): void
}

declare
export type Ix$Enumerator<T>= {
    moveNext(): boolean,
    getCurrent(): T
} & Ix$Disposable


declare
export interface Ix$EnumeratorStatic {
    new<T>(
            moveNext: () => boolean,
            getCurrent: () => T,
            dispose: () => void): Ix$Enumerator<T>,
        create<T>(
            moveNext: () => boolean,
            getCurrent: () => T,
            dispose?: () => void): Ix$Enumerator<T >
}

declare
var Enumerator: Ix$EnumeratorStatic;

declare
export interface Ix$EnumerableFunc<T, TResult>{
    (item: T, index: number, self: Ix$Enumerable<T>): TResult
}

declare
export type Ix$EnumerablePredicate<T>= {} & Ix$EnumerableFunc


declare
export interface Ix$Predicate<T>{
    (item: T): boolean
}

declare
export interface Ix$EqualityComparer<TFirst, TSecond>{
    (item1: TFirst, item2: TSecond): boolean
}

declare
export interface Ix$Comparer<TFirst, TSecond>{
    (item1: TFirst, item2: TSecond): number
}

declare
export interface Ix$Enumerable<T>{
    getEnumerator(): Ix$Enumerator<T>,
    aggregate<TAccumulate,
    TResult>(
        seed: TAccumulate,
        func: (
            accumulate: TAccumulate,
            current: T,
            index: number,
            self: Ix$Enumerable<T>) => TAccumulate,
        resultSelector: (accumulate: TAccumulate) => TResult): TResult,
    aggregate<TAccumulate>(
        seed: TAccumulate,
        func: (
            accumulate: TAccumulate,
            current: T,
            index: number,
            self: Ix$Enumerable<T>) => TAccumulate): TAccumulate,
    aggregate(
        func: (accumulate: T, current: T, index: number, self: Ix$Enumerable<T>) => T): T,
    reduce(
        func: (accumulate: T, current: T, index: number, self: Ix$Enumerable<T>) => T): T,
    reduce<TAccumulate>(
        func: (
            accumulate: TAccumulate,
            current: T,
            index: number,
            self: Ix$Enumerable<T>) => TAccumulate,
        seed: TAccumulate): TAccumulate,
    all(predicate: Ix$EnumerablePredicate<T>, thisArg?: any): boolean,
    every(predicate: Ix$EnumerablePredicate<T>, thisArg?: any): boolean,
    any(predicate?: Ix$EnumerablePredicate<T>, thisArg?: any): boolean,
    some(predicate?: Ix$EnumerablePredicate<T>, thisArg?: any): boolean,
    average(selector?: Ix$EnumerableFunc<T, number>): number,
    max(): T,
    max<TResult>(selector: Ix$EnumerableFunc<T, TResult>): TResult,
    min(): T,
    min<TResult>(selector: Ix$EnumerableFunc<T, TResult>): TResult,
    sum(selector?: Ix$EnumerableFunc<T, number>): number,
    concat<T>(...sources: Ix$Enumerable<T>[]): Ix$Enumerable<T>,
    contains<TValue>(value: TValue, comparer: Ix$EqualityComparer<T, TValue>): boolean,
    contains(value: T): boolean,
    count(predicate?: Ix$EnumerablePredicate<T>, thisArg?: any): number,
    defaultIfEmpty(defaultValue?: T): Ix$Enumerable<T>,
    distinct(comparer?: Ix$EqualityComparer<T, T>): Ix$Enumerable<T>,
    elementAt(index: number): T,
    elementAtOrDefault(index: number): T,
    except<TOther>(
        second: Ix$Enumerable<TOther>,
        comparer: Ix$EqualityComparer<T, TOther>): Ix$Enumerable<T>,
    except(second: Ix$Enumerable<T>): Ix$Enumerable<T>,
    first(predicate?: Ix$Predicate<T>): T,
    firstOrDefault(predicate?: Ix$Predicate<T>): T,
    last(predicate?: Ix$Predicate<T>): T,
    lastOrDefault(predicate?: Ix$Predicate<T>): T,
    single(predicate?: Ix$Predicate<T>): T,
    singleOrDefault(predicate?: Ix$Predicate<T>): T,
    forEach(action: Ix$EnumerableFunc<T, void>, thisArg?: any): void,
    groupBy<TKey,
    TElement,
    TResult>(
        keySelector: (item: T) => TKey,
        elementSelector: (item: T) => TElement,
        resultSelector: (key: TKey, values: Ix$Enumerable<TElement>) => TResult,
        comparer?: Ix$EqualityComparer<TKey, TKey>): Ix$Enumerable<TResult>,
    groupBy<TKey,
    TElement>(
        keySelector: (item: T) => TKey,
        elementSelector: (item: T) => TElement): Ix$Enumerable<Ix$Grouping<TKey,
    TElement >> ,
    groupBy<TKey>(keySelector: (item: T) => TKey): Ix$Enumerable<Ix$Grouping<TKey,
    T >> ,
    groupBy<TKey,
    TElement>(
        keySelector: (item: T) => TKey,
        elementSelector: (item: T) => TElement,
        _: boolean,
        comparer: Ix$EqualityComparer<TKey, TKey>): Ix$Enumerable<Ix$Grouping<TKey,
    TElement >> ,
    groupBy<TKey,
    TResult>(
        keySelector: (item: T) => TKey,
        _: boolean,
        resultSelector: (key: TKey, values: Ix$Enumerable<T>) => TResult,
        comparer?: Ix$EqualityComparer<TKey, TKey>): Ix$Enumerable<TResult>,
    groupBy<TKey>(
        keySelector: (item: T) => TKey,
        _: boolean,
        ___: boolean,
        comparer: Ix$EqualityComparer<TKey, TKey>): Ix$Enumerable<Ix$Grouping<TKey,
    T >> ,
    groupJoin<TInner,
    TOuterKey,
    TInnerKey,
    TResult>(
        inner: Ix$Enumerable<TInner>,
        outerKeySelector: (item: T) => TOuterKey,
        innerKeySelector: (item: TInner) => TInnerKey,
        resultSelector: (outer: T, innerSequence: Ix$Enumerable<TInner>) => TResult,
        comparer: Ix$EqualityComparer<TOuterKey, TInnerKey>): Ix$Enumerable<TResult>,
    groupJoin<TInner,
    TKey,
    TResult>(
        inner: Ix$Enumerable<TInner>,
        outerKeySelector: (item: T) => TKey,
        innerKeySelector: (item: TInner) => TKey,
        resultSelector: (outer: T, innerSequence: Ix$Enumerable<TInner>) => TResult): Ix$Enumerable<TResult>,
    join<TInner,
    TOuterKey,
    TInnerKey,
    TResult>(
        inner: Ix$Enumerable<TInner>,
        outerKeySelector: (item: T) => TOuterKey,
        innerKeySelector: (item: TInner) => TInnerKey,
        resultSelector: (outer: T, inner: TInner) => TResult,
        comparer: Ix$EqualityComparer<TOuterKey, TInnerKey>): Ix$Enumerable<TResult>,
    join<TInner,
    TKey,
    TResult>(
        inner: Ix$Enumerable<TInner>,
        outerKeySelector: (item: T) => TKey,
        innerKeySelector: (item: TInner) => TKey,
        resultSelector: (outer: T, inner: TInner) => TResult): Ix$Enumerable<TResult>,
    intersect<TSecond>(
        second: Ix$Enumerable<TSecond>,
        comparer: Ix$EqualityComparer<T, TSecond>): Ix$Enumerable<T>,
    intersect(second: Ix$Enumerable<T>): Ix$Enumerable<T>,
    union(
        second: Ix$Enumerable<T>,
        comparer?: Ix$EqualityComparer<T, T>): Ix$Enumerable<T>,
    orderBy<TKey>(
        keySelector: (item: T) => TKey,
        comparer?: Ix$Comparer<TKey, TKey>): Ix$OrderedEnumerable<T>,
    orderByDescending<TKey>(
        keySelector: (item: T) => TKey,
        comparer?: Ix$Comparer<TKey, TKey>): Ix$OrderedEnumerable<T>,
    reverse(): Ix$Enumerable<T>,
    select<TResult>(
        selector: Ix$EnumerableFunc<T, TResult>,
        thisArg?: any): Ix$Enumerable<TResult>,
    map<TResult>(
        selector: Ix$EnumerableFunc<T, TResult>,
        thisArg?: any): Ix$Enumerable<TResult>,
    selectMany<TCollection,
    TResult>(
        collectionSelector: (item: T, index: number) => Ix$Enumerable<TCollection>,
        resultSelector: (outer: T, inner: TCollection) => TResult): Ix$Enumerable<TResult>,
    selectMany<TCollection>(
        collectionSelector: (item: T, index: number) => Ix$Enumerable<TCollection>): Ix$Enumerable<TCollection>,
    sequenceEqual<TSecond>(
        second: Ix$Enumerable<TSecond>,
        comparer: Ix$EqualityComparer<T, TSecond>): boolean,
    sequenceEqual(second: Ix$Enumerable<T>): boolean,
    skip(count: number): Ix$Enumerable<T>,
    skipWhile(selector: Ix$EnumerablePredicate<T>, thisArg?: any): Ix$Enumerable<T>,
    take(count: number): Ix$Enumerable<T>,
    takeWhile(selector: Ix$EnumerablePredicate<T>, thisArg?: any): Ix$Enumerable<T>,
    toArray(): T[],
    toDictionary<TKey,
    TValue>(
        keySelector: (item: T) => TKey,
        elementSelector: (item: T) => TValue,
        comparer?: Ix$EqualityComparer<TKey, TKey>): Ix$Dictionary<TKey,
    TValue>,
    toDictionary<TKey>(keySelector: (item: T) => TKey): Ix$Dictionary<TKey,
    T>,
    toDictionary<TKey>(
        keySelector: (item: T) => TKey,
        _: boolean,
        comparer: Ix$EqualityComparer<TKey, TKey>): Ix$Dictionary<TKey,
    T>,
    toLookup<TKey,
    TValue>(
        keySelector: (item: T) => TKey,
        elementSelector: (item: T) => TValue,
        comparer?: Ix$EqualityComparer<TKey, TKey>): Ix$Lookup<TKey,
    TValue>,
    toLookup<TKey>(keySelector: (item: T) => TKey): Ix$Lookup<TKey,
    T>,
    toLookup<TKey>(
        keySelector: (item: T) => TKey,
        _: boolean,
        comparer: Ix$EqualityComparer<TKey, TKey>): Ix$Lookup<TKey,
    T>,
    where(selector: Ix$EnumerablePredicate<T>, thisArg?: any): Ix$Enumerable<T>,
    filter(selector: Ix$EnumerablePredicate<T>, thisArg?: any): Ix$Enumerable<T>,
    zip<TRight,
    TResult>(
        right: Ix$Enumerable<TRight>,
        selector: (left: T, right: TRight) => TResult): Ix$Enumerable<TResult >
}

declare
export type Ix$Grouping<TKey, T>= {
    key: TKey
} & Ix$Enumerable


declare
export type Ix$OrderedEnumerable<T>= {
    thenBy<TKey>(
        keySelector: (item: T) => TKey,
        comparer?: Ix$Comparer<TKey, TKey>): Ix$OrderedEnumerable<T>,
    thenByDescending<TKey>(
        keySelector: (item: T) => TKey,
        comparer?: Ix$Comparer<TKey, TKey>): Ix$OrderedEnumerable<T >
} & Ix$Enumerable


declare class Dictionary<TKey, TValue>{
    constructor(capacity?: number, comparer?: Ix$EqualityComparer<TKey, TKey>): this;
    toEnumerable(): Ix$Enumerable<Ix$KeyValuePair<TKey,
    TValue >> ;
    add(key: TKey, value: TValue): void;
    remove(key: TKey): boolean;
    clear(): void;
    length(): number;
    tryGetValue(key: TKey): TValue;
    get(key: TKey): TValue;
    set(key: TKey, value: TValue): void;
    getValues(): TValue[];
    has(key: TKey): boolean
}

declare
export interface Ix$KeyValuePair<TKey, TValue>{
    key: TKey,
    value: TValue
}

declare
export interface Ix$Lookup<TKey, TValue>{
    toEnumerable(): Ix$Enumerable<Ix$Grouping<TKey,
    TValue >> ,
    has(key: TKey): boolean,
    length(): number,
    get(key: TKey): Ix$Enumerable<TValue >
}

declare
export interface Ix$EnumerableStatic {
    new<T>(getEnumerator: () => Ix$Enumerator<T>): Ix$Enumerable<T>,
        create<T>(getEnumerator: () => Ix$Enumerator<T>): Ix$Enumerable<T>,
        concat<T>(...sources: Ix$Enumerable<T>[]): Ix$Enumerable<T>,
        empty<T>(): Ix$Enumerable<T>,
        fromArray<T>(array: T[]): Ix$Enumerable<T>,
        return <T>(value: T): Ix$Enumerable<T>,
            returnValue<T>(value: T): Ix$Enumerable<T>,
            range(start: number, count: number): Ix$Enumerable<number>,
            repeat<T>(value: T, repeatCount?: number): Ix$Enumerable<T>,
            sequenceEqual<TFirst, TSecond>(
                first: Ix$Enumerable<TFirst>,
                second: Ix$Enumerable<TSecond>,
                comparer: Ix$EqualityComparer<TFirst, TSecond>): boolean,
            sequenceEqual<T>(first: Ix$Enumerable<T>, second: Ix$Enumerable<T>): boolean
}

declare
var Enumerable: Ix$EnumerableStatic;
declare module 'l2o' {
    declare module.exports: typeof Ix
}