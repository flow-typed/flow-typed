// @flow
/**
 * Flowtype definitions for chai-as-promised
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'chai-as-promised' {
    declare module.exports: typeof chaiAsPromised

}
declare type Chai$Assertion = {
    eventually: Chai$PromisedAssertion,
    become(expected: any): Chai$PromisedAssertion,
    fulfilled: Chai$PromisedAssertion,
    rejected: Chai$PromisedAssertion,
    rejectedWith(expected: any, message?: string | RegExp): Chai$PromisedAssertion,
    notify(fn: Function): Chai$PromisedAssertion
} & LanguageChains & NumericComparison & TypeComparison


declare type Chai$Eventually = {
    become(expected: PromisesAPlus.Thenable<any>): Chai$PromisedAssertion,
    fulfilled: Chai$PromisedAssertion,
    rejected: Chai$PromisedAssertion,
    rejectedWith(expected: any, message?: string | RegExp): Chai$PromisedAssertion,
    notify(fn: Function): Chai$PromisedAssertion,
    not: Chai$PromisedAssertion,
    deep: Chai$PromisedDeep,
    all: Chai$PromisedKeyFilter,
    a: Chai$PromisedTypeComparison,
    an: Chai$PromisedTypeComparison,
    include: Chai$PromisedInclude,
    contain: Chai$PromisedInclude,
    ok: Chai$PromisedAssertion,
    true: Chai$PromisedAssertion,
    false: Chai$PromisedAssertion,
    null: Chai$PromisedAssertion,
    undefined: Chai$PromisedAssertion,
    exist: Chai$PromisedAssertion,
    empty: Chai$PromisedAssertion,
    arguments: Chai$PromisedAssertion,
    Arguments: Chai$PromisedAssertion,
    equal: Chai$PromisedEqual,
    equals: Chai$PromisedEqual,
    eq: Chai$PromisedEqual,
    eql: Chai$PromisedEqual,
    eqls: Chai$PromisedEqual,
    property: Chai$PromisedProperty,
    ownProperty: Chai$PromisedOwnProperty,
    haveOwnProperty: Chai$PromisedOwnProperty,
    length: Chai$PromisedLength,
    lengthOf: Chai$PromisedLength,
    match(regexp: RegExp | string, message?: string): Chai$PromisedAssertion,
    string(string: string, message?: string): Chai$PromisedAssertion,
    keys: Chai$PromisedKeys,
    key(string: string): Chai$PromisedAssertion,
    throw: Chai$PromisedThrow,
    throws: Chai$PromisedThrow,
    Throw: Chai$PromisedThrow,
    respondTo(method: string, message?: string): Chai$PromisedAssertion,
    itself: Chai$PromisedAssertion,
    satisfy(matcher: Function, message?: string): Chai$PromisedAssertion,
    closeTo(expected: number, delta: number, message?: string): Chai$PromisedAssertion,
    members: Chai$PromisedMembers
} & Chai$PromisedLanguageChains & Chai$PromisedNumericComparison & Chai$PromisedTypeComparison


declare type Chai$PromisedAssertion = {} & Chai$Eventually &


    declare interface Chai$PromisedLanguageChains {
        eventually: Chai$Eventually,
            to: Chai$PromisedAssertion,
            be: Chai$PromisedAssertion,
            been: Chai$PromisedAssertion,
            is: Chai$PromisedAssertion,
            that: Chai$PromisedAssertion,
            which: Chai$PromisedAssertion,
            and: Chai$PromisedAssertion,
            has: Chai$PromisedAssertion,
            have: Chai$PromisedAssertion,
            with: Chai$PromisedAssertion,
            at: Chai$PromisedAssertion, of: Chai$PromisedAssertion,
            same: Chai$PromisedAssertion
    }

declare interface Chai$PromisedNumericComparison {
    above: Chai$PromisedNumberComparer,
        gt: Chai$PromisedNumberComparer,
        greaterThan: Chai$PromisedNumberComparer,
        least: Chai$PromisedNumberComparer,
        gte: Chai$PromisedNumberComparer,
        below: Chai$PromisedNumberComparer,
        lt: Chai$PromisedNumberComparer,
        lessThan: Chai$PromisedNumberComparer,
        most: Chai$PromisedNumberComparer,
        lte: Chai$PromisedNumberComparer,
        within(start: number, finish: number, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedNumberComparer {
    (value: number, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedTypeComparison {
    (type: string, message?: string): Chai$PromisedAssertion,
    instanceof: Chai$PromisedInstanceOf,
        instanceOf: Chai$PromisedInstanceOf
}

declare interface Chai$PromisedInstanceOf {
    (constructor: Object, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedDeep {
    equal: Chai$PromisedEqual,
        include: Chai$PromisedInclude,
        property: Chai$PromisedProperty
}

declare interface Chai$PromisedKeyFilter {
    keys: Chai$PromisedKeys
}

declare interface Chai$PromisedEqual {
    (value: any, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedProperty {
    (name: string, value?: any, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedOwnProperty {
    (name: string, message?: string): Chai$PromisedAssertion
}

declare type Chai$PromisedLength = {
    (length: number, message?: string): Chai$PromisedAssertion
} & Chai$PromisedLanguageChains & Chai$PromisedNumericComparison


declare interface Chai$PromisedInclude {
    (value: Object, message?: string): Chai$PromisedAssertion,
    (value: string, message?: string): Chai$PromisedAssertion,
    (value: number, message?: string): Chai$PromisedAssertion,
    keys: Chai$PromisedKeys,
        members: Chai$PromisedMembers,
        all: Chai$PromisedKeyFilter
}

declare interface Chai$PromisedKeys {
    (...keys: string[]): Chai$PromisedAssertion,
    (keys: any[]): Chai$PromisedAssertion
}

declare interface Chai$PromisedThrow {
    (): Chai$PromisedAssertion,
    (expected: string, message?: string): Chai$PromisedAssertion,
    (expected: RegExp, message?: string): Chai$PromisedAssertion,
    (constructor: Error, expected?: string, message?: string): Chai$PromisedAssertion,
    (constructor: Error, expected?: RegExp, message?: string): Chai$PromisedAssertion,
    (constructor: Function, expected?: string, message?: string): Chai$PromisedAssertion,
    (constructor: Function, expected?: RegExp, message?: string): Chai$PromisedAssertion
}

declare interface Chai$PromisedMembers {
    (set: any[], message?: string): Chai$PromisedAssertion
}

declare interface Chai$Assert {
    eventually: Chai$PromisedAssert,
        isFulfilled(
            promise: PromisesAPlus.Thenable<any>,
            message?: string): PromisesAPlus.Thenable<void>,
        becomes(
            promise: PromisesAPlus.Thenable<any>,
            expected: any,
            message?: string): PromisesAPlus.Thenable<void>,
        doesNotBecome(
            promise: PromisesAPlus.Thenable<any>,
            expected: any,
            message?: string): PromisesAPlus.Thenable<void>,
        isRejected(
            promise: PromisesAPlus.Thenable<any>,
            message?: string): PromisesAPlus.Thenable<void>,
        isRejected(
            promise: PromisesAPlus.Thenable<any>,
            expected: any,
            message?: string): PromisesAPlus.Thenable<void>,
        isRejected(
            promise: PromisesAPlus.Thenable<any>,
            match: RegExp,
            message?: string): PromisesAPlus.Thenable<void>,
        notify(fn: Function): PromisesAPlus.Thenable<void >
}

declare export interface Chai$PromisedAssert {
    fail(
            actual?: any,
            expected?: any,
            msg?: string,
            operator?: string): PromisesAPlus.Thenable<void>,
        ok(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        notOk(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        equal(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        notEqual(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        strictEqual(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        notStrictEqual(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        deepEqual(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        notDeepEqual(act: any, exp: any, msg?: string): PromisesAPlus.Thenable<void>,
        isTrue(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isFalse(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNull(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotNull(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isUndefined(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isDefined(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isFunction(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotFunction(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isObject(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotObject(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isArray(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotArray(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isString(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotString(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNumber(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotNumber(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isBoolean(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        isNotBoolean(val: any, msg?: string): PromisesAPlus.Thenable<void>,
        typeOf(val: any, type: string, msg?: string): PromisesAPlus.Thenable<void>,
        notTypeOf(val: any, type: string, msg?: string): PromisesAPlus.Thenable<void>,
        instanceOf(val: any, type: Function, msg?: string): PromisesAPlus.Thenable<void>,
        notInstanceOf(val: any, type: Function, msg?: string): PromisesAPlus.Thenable<void>,
        include(exp: string, inc: any, msg?: string): PromisesAPlus.Thenable<void>,
        include(exp: any[], inc: any, msg?: string): PromisesAPlus.Thenable<void>,
        notInclude(exp: string, inc: any, msg?: string): PromisesAPlus.Thenable<void>,
        notInclude(exp: any[], inc: any, msg?: string): PromisesAPlus.Thenable<void>,
        match(exp: any, re: RegExp, msg?: string): PromisesAPlus.Thenable<void>,
        notMatch(exp: any, re: RegExp, msg?: string): PromisesAPlus.Thenable<void>,
        property(obj: Object, prop: string, msg?: string): PromisesAPlus.Thenable<void>,
        notProperty(obj: Object, prop: string, msg?: string): PromisesAPlus.Thenable<void>,
        deepProperty(obj: Object, prop: string, msg?: string): PromisesAPlus.Thenable<void>,
        notDeepProperty(obj: Object, prop: string, msg?: string): PromisesAPlus.Thenable<void>,
        propertyVal(
            obj: Object,
            prop: string,
            val: any,
            msg?: string): PromisesAPlus.Thenable<void>,
        propertyNotVal(
            obj: Object,
            prop: string,
            val: any,
            msg?: string): PromisesAPlus.Thenable<void>,
        deepPropertyVal(
            obj: Object,
            prop: string,
            val: any,
            msg?: string): PromisesAPlus.Thenable<void>,
        deepPropertyNotVal(
            obj: Object,
            prop: string,
            val: any,
            msg?: string): PromisesAPlus.Thenable<void>,
        lengthOf(exp: any, len: number, msg?: string): PromisesAPlus.Thenable<void>,
        throw (fn: Function, msg?: string): PromisesAPlus.Thenable<void>,
            throw (fn: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                throw (fn: Function, errType: Function, msg?: string): PromisesAPlus.Thenable<void>,
                    throw (fn: Function, errType: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        throws(fn: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        throws(fn: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        throws(fn: Function, errType: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        throws(fn: Function, errType: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        Throw(fn: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        Throw(fn: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        Throw(fn: Function, errType: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        Throw(fn: Function, errType: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        doesNotThrow(fn: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        doesNotThrow(fn: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        doesNotThrow(fn: Function, errType: Function, msg?: string): PromisesAPlus.Thenable<void>,
                        doesNotThrow(fn: Function, errType: Function, regExp: RegExp): PromisesAPlus.Thenable<void>,
                        operator(
                            val: any,
                            operator: string,
                            val2: any,
                            msg?: string): PromisesAPlus.Thenable<void>,
                        closeTo(
                            act: number,
                            exp: number,
                            delta: number,
                            msg?: string): PromisesAPlus.Thenable<void>,
                        sameMembers(set1: any[], set2: any[], msg?: string): PromisesAPlus.Thenable<void>,
                        includeMembers(set1: any[], set2: any[], msg?: string): PromisesAPlus.Thenable<void>,
                        ifError(val: any, msg?: string): PromisesAPlus.Thenable<void >
}