/**
 * Flowtype definitions for jpm
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'sdk/base64' {

    /**
     * Creates a base-64 encoded ASCII string from a string of binary data
     * @param data the data to encode
     * @param charset The charset of the string to encode (optional). The only accepted value is "utf-8".
    In order to encode and decode Unicode strings, the charset parameter needs to be set
    */
    declare export function encode(data: string, charset?: string): string

    /**
     * 
     * @param data the encoded data
     * @param charset 
     */
    declare export function decode(data: string, charset?: string): string
}
declare module 'sdk/clipboard' {

    /**
     * get the contents of the system clipboard
     * @param datatype [text|html|image] Retrieve the clipboard contents only if matching this type
     */
    declare export function get(datatype?: "text" | "html" | "image"): string

    /**
     * Replace the contents of the user's clipboard with the provided data
     * @param data The data to put on the clipboard
     * @param datatype [text|html|image] The type of the data
     */
    declare export function set(data: string, datatype?: "text" | "html" | "image"): void
}
declare module 'sdk/context-menu' {

    /**
     * The context determines when the menu item will be visible
     */
    declare interface Context {}
    declare export var PageContext: PageContext;
    declare type PageContext = {
        (): Object
    } & Context

    declare export var SelectionContext: SelectionContext;
    declare type SelectionContext = {
        (): Object
    } & Context

    declare export var SelectorContext: SelectorContext;
    declare type SelectorContext = {
        (selector: string): Object
    } & Context

    declare export var URLContext: URLContext;
    declare type URLContext = {
        (matchPattern: string): Object
    } & Context

    declare export var PredicateContext: PredicateContext;
    declare type PredicateContext = {
        (predicateFunction: (
            context: {
                documentType: string,
                documentURL: string,
                targetName: string,
                targetID?: string,
                isEditable: boolean,
                selectionText?: string,
                srcURL?: string,
                linkURL?: string,
                value?: string
            }) => boolean): Object
    } & Context

    declare type ItemContext = {
        add: (context: Context) => void,
        remove: (context: Context) => void
    } & Array

    declare interface Item {
        context: ItemContext,
            destroy: () => void,
            label: string,
            image: string | URL,
            data: any,
            parentMenu?: Menu,
            contentScript?: string | string[],
            contentScriptFile?: string | string[]
    }

    /**
     * 
     * @constructor  * A menu separator
     */
    declare export function Separator(): Separator
    declare interface Menu {
        addItem: (item: ItemMenuSeparator) => void,
            removeItem: (item: ItemMenuSeparator) => void,
            destroy: () => void,
            label: string,
            items: ItemMenuSeparator[],
            image: string | URL,
            context: ItemContext,
            parentMenu?: Menu,
            contentScript: string | string[],
            contentScriptFile: string | string[]
    }
    declare type ItemMenuSeparator = Item | Menu | Separator;
}
declare module 'sdk/hotkeys' {
    declare interface Hotkey {
        destroy: () => void
    }
}
declare module 'sdk/indexed-db' {
    declare module.exports: typeof IndexedImpl
}
declare module 'sdk/l10n' {

    /**
     * get the contents of the system clipboard
     * @param datatype [text|html|image] Retrieve the clipboard contents only if matching this type
     */
    declare export function get(datatype?: "text" | "html" | "image"): string
}
declare module 'sdk/notifications' {

    /**
     * 
     * @param options 
     * @param options .title A string to display as the message's title
     * @param options .text A string to display as the body of the message
     * @param options .iconURL The URL of an icon to display inside the message. It may be a remote URL, a data URI,
           or a URL returned by the {
     * @link  sdk/self} module
     * @param options .onClick A function to be called when the user clicks the message. It will be passed the value of data
     * @param options .data A string that will be passed to onClick
    */
    declare export function notify(
        options: {
            title?: string,
            text?: string,
            iconURL?: string,
            onClick?: (data: string) => any,
            data?: string
        }): void
}
declare module 'sdk/page-mod' {

    /**
     * 
     * @constructor  * 
     * @param options .include
     * @param options .contentStyle Lists stylesheets to attach, supplied as strings
     * @param options .contentStyleFile Lists stylesheets to attach, supplied in separate files
     * @param options .contentScriptOptions Defines read-only values accessible to content scripts
     * @param options .attachTo Controls whether to attach scripts to tabs that were already open when the page-mod
          was created, and whether to attach scripts to iframes as well as the topmost document
     * @param options .contentScriptWhen Controls the point during document load at which content scripts are attached
     * @param options .exclude Has the same syntax as include, but specifies the URLs to which content scripts should not
       be attached, even if they match include: so it's a way of excluding a subset of the URLs
       that include specifies. The exclude option is new in Firefox 32
     * @param options .onAttach This event is emitted when the page-mod's content scripts are attached to a document
       whose URL matches the page-mod's include pattern
     * @param options .onError This event is emitted when an uncaught runtime error occurs in one of the page-mod's content scripts
    */
    declare export function PageMod(
        options: {
            include: string | string[] | RegExp | RegExp[],
            contentScript?: string | string[],
            contentScriptFile?: string | string[],
            contentStyle?: string | string[],
            contentStyleFile?: string | string[],
            contentScriptOptions?: any,
            attachTo?: attachmentMode | attachmentMode[],
            contentScriptWhen?: "start" | "ready" | "end",
            exclude?: string | string[],
            onAttach?: (worker: FFAddonSDK$ContentWorker) => any,
            onError?: (error: Error) => any
        }): PageMod
    declare type attachmentMode = "existing" | "top" | "frame";
}
declare module 'sdk/page-worker' {

    /**
     * 
     * @constructor  * 
     * @param options .contentURL The URL of the content to load in the worker
     * @param options .contentScript A string or an array of strings containing the texts of content scripts to load.
                  Content scripts specified by this option are loaded after those specified by the
                  contentScriptFile option.
     * @param options .contentScriptFile A local file URL or an array of local file URLs of content scripts to load
                     Content scripts specified by this option are loaded before those specified
                     by the contentScript option
     * @param options .include This is useful when your page worker loads a page which will redirect to other pages.
          These define the documents to which the page-worker's content worker applies
     * @param options .contentScriptWhen When to load the content scripts
                   "start": load content scripts immediately after the document element for the page
                     is inserted into the DOM, but before the DOM content itself has been loaded
                   "ready": load content scripts once DOM content has been loaded, corresponding
                     to the DOMContentLoaded event
                   "end": load content scripts once all the content (DOM, JS, CSS, images) for the
                     page has been loaded, at the time the window.onload event fires
     * @param options .contentScriptOptions Read-only value exposed to content scripts under self.options property
    */
    declare export function Page(
        options: {
            contentURL?: string,
            contentScript?: string | string[],
            contentScriptFile?: string | string[],
            contentScriptWhen?: "start" | "ready" | "end",
            onMessage?: (message: string) => any,
            allow?: {
                script: boolean
            },
            contentScriptOptions?: any,
            include?: string | string[] | RegExp | RegExp[]
        }): PageWorker
    declare interface PageWorker {
        port: FFAddonSDK$Port,
            contentURL?: string,
            destroy: () => void,
            postMessage: (message: string) => void,
            on: (event: "message" | "error", handler: (arg?: "message" | Error) => any) => void,
            removeListener: (event: string, listener: Function) => void,
            allow?: {
                script: boolean
            },
            include?: string | string[] | RegExp | RegExp[],
            contentScriptFile?: string | string[],
            contentScript?: string | string[]
    }
}
declare module 'sdk/panel' {

    /**
     * 
     * @constructor  * 
     * @param options .contentURL The URL of the content to load in the panel. That is, they can't refer to remote scripts
     * @param options .width The width of the panel in pixels
     * @param options .height The height of the panel in pixels
     * @param options .contentScript A string or an array of strings containing the texts of content scripts to load.
                Content scripts specified by this property are loaded after those specified by the
                contentScriptFile property
     * @param options .contentScriptFile A URL or an array of URLs. The URLs point to scripts to load into the panel
     * @param options .contentScriptWhen="end"]
     * @param options .contentStyle A string or an array of strings containing the texts of stylesheets to load.
            Stylesheets specified by this property are loaded after those specified by the
            contentStyleFile property
     * @param options .contentStyleFile A URL or an array of URLs. The URLs point to CSS stylesheets to load into the panel
     * @param options .position The position of the panel. Ignored if the panel is opened by a widget.
      This may be one of three things:
       1. a toggle button. If this is supplied the panel will be shown attached to the button
       2. a widget object. If this is supplied the panel will be shown attached to the widget.
       3. an object which specifies where in the window the panel should be shown
     * @param options .focus=true] Set to false to prevent taking the focus away when the panel is shown.
        Only turn this off if necessary, to prevent accessibility issues
     * @param options .allow An optional object describing permissions for the content. It should contain a single key
    named script whose value is a boolean that indicates whether or not to execute script in the content
     * @param options .contextMenu=false] Whether to show a context menu when the user context-clicks in the panel.
             The context menu will be the same one that's displayed in web pages
    */
    declare export function Panel(
        options: {
            contentURL?: string | URL,
            width?: number,
            height?: number,
            contentScript?: string | string[],
            contentScriptFile?: string | string[],
            contentScriptWhen?: "start" | "ready" | "end",
            contentScriptOptions?: any,
            contentStyle?: string | string[],
            contentStyleFile?: string | string[],
            position?: PanelPosition,
            allow?: {
                script?: boolean
            },
            focus?: boolean,
            contextMenu?: boolean,
            onMessage?: (message: string) => any,
            onShow?: () => any,
            onHide?: () => any,
            onError?: (error: Error) => any
        }): Panel
    declare type PanelPosition = FFAddonSDK$ToggleButton | FFAddonSDK$Widget | {
        top?: number,
        right?: number,
        bottom?: number,
        left?: number
    };
}
declare module 'sdk/passwords' {

    /**
     * This function is used to retrieve a credential, or a list of credentials, stored in the Password Manager
     * @param options .onComplete The callback function that is called once the function completes successfully
     */
    declare export function search(
        options: {
            onComplete: (credentials: Credential[]) => any,
            username?: string,
            url?: string,
            password?: string,
            formSubmitURL?: string,
            realm?: string,
            usernameField?: string,
            passwordField?: string,
            onError?: (error: FFAddonSDK$NSIException) => any
        }): void

    /**
     * This function is used to store a credential in the Password Manager.
     * It takes an options object as an argument: this contains all the properties for the new credential.
    As different sorts of credentials contain different properties, the appropriate options differ depending
    on the sort of credential being stored
    */
    declare export function store(
        options: Credential & {
            onComplete?: () => any,
            onError?: (error: FFAddonSDK$NSIException) => any
        }): void

    /**
     * Removes a stored credential
     */
    declare export function remove(
        options: Credential & {
            onComplete?: () => any,
            onError?: (error: FFAddonSDK$NSIException) => any
        }): void
    declare interface Credential {
        username: string,
            password: string,
            url?: string,
            formSubmitURL?: string,
            realm?: string,
            usernameField?: string,
            passwordField?: string
    }
}
declare module 'sdk/private-browsing' {
    declare export function isPrivate(
        object: FFAddonSDK$Tab | FFAddonSDK$ContentWorker | FFAddonSDK$BrowserWindow): boolean
}
declare module 'sdk/querystring' {

    /**
     * Utility functions for working with query stringsSerializes an object containing name:value pairs into a query string
     * @param object The data to convert to a query string
     * @param separator The string to use as a separator between each name:value pair
     * @param assignment The string to use between each name and its corresponding value
     */
    declare export function stringify(object: Object, separator?: string, assignment?: string): string

    /**
     * Parse a query string into an object containing name:value pairs
     */
    declare export function parse(querystring: string, separator?: string, assignment?: string): Object

    /**
     * The escape function used by stringify to encodes a string safely matching RFC 3986 for
     * application/x-www-form-urlencoded
     */
    declare export function escape(query: string): string

    /**
     * The unescape function used by parse to decode a string safely
     */
    declare export function unescape(query: string): string
}
declare module 'sdk/request' {

    /**
     * This constructor creates a request object that can be used to make network requests
     * @param options .url This is the url to which the request will be made
     * @param options .onComplete This function will be called when the request has received a response
                (or in terms of XHR, when readyState == 4)
     * @param options .headers An unordered collection of name/value pairs representing headers to send with the request
     * @param options .content The content to send to the server. If content is a string, it should be URL-encoded
           (use encodeURIComponent). If content is an object, it should be a collection of name/value pairs.
           Nested objects & arrays should encode safely.
           For GET and HEAD requests, the query string (content) will be appended to the URL.
           For POST and PUT requests, it will be sent as the body of the request
     * @param options .contentType='application/x-www-form-urlencoded'] The type of content to send to the server
                                                   This explicitly sets the Content-Type header
     * @param options .overrideMimeType Use this string to override the MIME type returned by the server in the response's
                  Content-Type header. You can use this to treat the content as a different MIME type,
                  or to force text to be interpreted using a specific character
     * @param options .anonymous=false] If true, the request will be sent without cookies or authentication headers
     * @constructor  
    */
    declare export function Request(
        options: {
            url?: string | FFAddonSDK$SDKURL,
            onComplete?: (response: Response) => any,
            headers?: Object,
            content?: string | Object,
            contentType?: string,
            anonymous?: boolean,
            overrideMimeType?: string
        }): Request
    declare interface BaseRequest {
        get: () => void,
            post: () => void,
            head: () => void,
            put: () => void,
            delete: () => void,
            url: string | FFAddonSDK$SDKURL,
            headers: Object,
            content: string,
            contentType: string
    }
    declare type STRequest<ResponseType>= {
        response: STResponse<ResponseType >
    } & BaseRequest

    declare interface BaseResponse {
        url: string,
            text: string,
            status: number,
            statusText: string,
            headers: Object,
            anonymous: boolean
    }
    declare type Response = {
        json: Object
    } & BaseResponse

    declare interface STResponse<T>{
        json: T
    }
}
declare module 'sdk/selection' {
    declare export function on(event: "select" | "select", handler: () => any): void
    declare export function removeListener(event: "select" | "select", handler: Function): void
    declare export var text: string;
    declare export var html: string;
    declare export var isContiguous: boolean;
}
declare module 'sdk/self' {
    declare export var uri: string;
    declare export var id: string;
    declare export var name: string;
    declare export var version: string;
    declare export var loadReason: "install" |
        "enable" |
        "startup" |
        "upgrade" |
        "downgrade";
    declare export var isPrivateBrowsingSupported: boolean;

    declare var npm$namespace$data: {
            load: typeof data$load,
            url: typeof data$url,
        }
        /**
         * The data.load() method returns the contents of an embedded data file, as a string.
         * It is most useful for data that will be modified or parsed in some way, such as JSON, XML, plain text,
        or perhaps an HTML template. For data that can be displayed directly in a content frame, use data.url()
         * @param name The filename to be read, relative to the package's data directory.
        Each package that uses the self module will see its own data directory
        */
    declare export function data$load(name: string): string


    /**
     * The data.url() method returns a resource:// url that points at an embedded data file.
     * It is most useful for data that can be displayed directly in a content frame.
    The url can be passed to a content frame constructor, such as the {@link Panel}
    */
    declare export function data$url(name: string): string
}
declare module 'sdk/simple-prefs' {
    declare export function on(event: "select" | "select", handler: () => any): void
    declare export function removeListener(event: "select" | "select", handler: Function): void
    declare export var prefs: Object;
}
declare module 'sdk/simple-storage' {
    declare export var storage: any;
    declare export var quotaUsage: number;
    declare export function on(event: "select" | "select", handler: () => any): void
}
declare module 'sdk/system' {

    /**
     * Quits the host application with the specified code
     * @param code 
     */
    declare export function exit(code: number): void

    /**
     * Firefox enables you to get the path to certain "special" directories, such as the desktop or the profile directory.
     * This function exposes that functionality to add-on authors
     * @param id see [
     * @link  https://developer.mozilla.org/en-US/docs/Code_snippets/File_I_O#Getting_files_in_special_directories}
     */
    declare export function pathFor(id: string): string
    declare export var env: any;
    declare export var platform: string;
    declare export var architecture: string;
    declare export var compiler: string;
    declare export var build: string;
    declare export var id: string;
    declare export var name: string;
    declare export var version: string;
    declare export var platformVersion: string;
    declare export var vendor: string;
}
declare module 'sdk/tabs' {

    /**
     * Opens a new tab. The new tab will open in the active window or in a new window, depending on the inNewWindow option
     * @param options String URL to be opened in the new tab or an options object
     * @param options .inNewWindow=false] Determine whether the new tab should be private or not
                        If your add-on does not support private browsing this will have no effect
     * @param options .inBackground tab will be opened to the right of the active tab and will not be active
     * @param options .onOpen This event is emitted when a new tab is opened. This does not mean that the content has loaded,
          only that the browser tab itself is fully visible to the user.
          Properties relating to the tab's content (for example: title, favicon, and url) will not be
          correct at this point. If you need to access these properties, listen for the ready event.
     * @param options .onClose This event is emitted when a tab is closed. When a window is closed this event will be
          emitted for each of the open tabs in that window
     * @param options .onReady This event is emitted when the DOM for a tab's content is ready.
         It is equivalent to the DOMContentLoaded event for the given content page.
         A single tab will emit this event every time the DOM is loaded: so it will be emitted again
         if the tab's location changes or the content is reloaded.
         After this event has been emitted, all properties relating to the tab's content can be used.
    */
    declare export function open(
        options: string | {
            url: string,
            inNewWindow?: boolean,
            inBackground?: boolean,
            isPinned?: boolean,
            onOpen?: (tab: FFAddonSDK$Tab) => any,
            onClose?: (tab: FFAddonSDK$Tab) => any,
            onReady?: (tab: FFAddonSDK$Tab) => any,
            onLoad?: (tab: FFAddonSDK$Tab) => any,
            onPageShow?: (tab: FFAddonSDK$Tab) => any,
            onActivate?: (tab: FFAddonSDK$Tab) => any,
            onDeactivate?: (tab: FFAddonSDK$Tab) => any
        }): void
    declare export function on(event: "select" | "select", handler: () => any): void
    declare export var activeTab: FFAddonSDK$Tab;
    declare export var length: number;
}
declare module 'sdk/timers' {

    /**
     * Schedules callback to be called in ms milliseconds. Any additional arguments are passed straight through to the callback
     */
    declare export function setTimeout(callback: (...args: any[]) => any, timeoutMS: number): TIMEOUT_ID

    /**
     * Given an ID returned from setTimeout(), prevents the callback with the ID from being called (if it hasn't yet been called)
     */
    declare export function clearTimeout(timerID: TIMEOUT_ID): void

    /**
     * Schedules callback to be called repeatedly every ms milliseconds
     * Any additional arguments are passed straight through to the callback
     */
    declare export function setInterval(callback: (...args: any[]) => any, timeoutMS: number): INTERVAL_ID

    /**
     * Given an ID returned from setInterval(), prevents the callback with the ID from being called again
     */
    declare export function clearInterval(intervalID: INTERVAL_ID): void
    declare type TIMEOUT_ID = number;
    declare type INTERVAL_ID = number;
}
declare module 'sdk/ui/button/action' {

    /**
     * Creates an action button
     * @constructor  * 
     * @param options .id The button's ID. This is used internally to keep track of this button
        The ID must be unique within your add-on
     * @param options .label The button's human-readable label. When the button is in the toolbar,
          this appears in a tooltip, and when the button is in the menu,
          it appears underneath the button as a legend
     * @param options .icon One or more icons for the button
    */
    declare export function ActionButton(
        options: {
            id: string,
            label: string,
            icon: FFAddonSDK$Icon,
            onClick?: (state: FFAddonSDK$ActionButton) => any,
            onChange?: (state: FFAddonSDK$ActionButtonState) => any,
            disabled?: boolean,
            badge?: string | number,
            badgeColor?: string
        }): FFAddonSDK$ActionButton
}
declare module 'sdk/ui/button/toggle' {

    /**
     * Creates a toggle button
     * @constructor  * 
     * @param options .id The button's ID. This is used internally to keep track of this button
        The ID must be unique within your add-on
     * @param options .label The button's human-readable label. When the button is in the toolbar,
          this appears in a tooltip, and when the button is in the menu,
          it appears underneath the button as a legend
     * @param options .icon One or more icons for the button
    */
    declare export function ToggleButton(
        options: {
            id: string,
            label: string,
            icon: FFAddonSDK$Icon,
            onChange?: (state: FFAddonSDK$ToggleButtonState) => any,
            onClick?: (state: FFAddonSDK$ToggleButtonState) => any,
            badge?: string | number,
            badgeColor?: string,
            disabled?: boolean,
            checked?: boolean
        }): FFAddonSDK$ToggleButton
}
declare module 'sdk/ui/frame' {

    /**
     * Creates a frame. Once created, the frame needs to be added to a toolbar for it to be visible
     * @param options .url A URL pointing to the HTML file specifying the frame's content.
          The file must be bundled with the add-on under its "data" directory
     * @param options .name The frame's name. This must be unique within your add-on.
    This is used to generate an ID to to keep track of the frame. If you don't supply a name, the ID is derived from
    the frame's URL, meaning that if you don't supply a name, you may not create two frames with the same URL
     * @param options .onReady This event is emitted while a frame instance is being loaded, at the point where it becomes
    possible to interact with the frame although sub-resources may still be in the process of loading
    It's the equivalent of the point where the frame's document.readyState becomes "interactive"
     * @param options .onAttach This event is emitted whenever a new frame instance is constructed and the browser has
    started to load its document: for example, when the user opens a new browser window, if that window has a
    toolbar containing this frame. Since the event is dispatched asynchronously, the document may already be
    loaded by the time the event is received.
    At this point, you should not try to send messages to scripts hosted in the frame
    because the frame scripts may not have been loaded
     * @param options .onDetach This event is emitted when a frame instance is unloaded: for example, when the user
    closes a browser window, if that window has a toolbar containing this frame.
    After receiving this message, you ahould not attempt to communicate with the frame scripts
     * @constructor  
    */
    declare export function Frame(
        options: {
            url: string,
            name?: string,
            onMessage?: (message: FFAddonSDK$FrameEvent) => any,
            onReady?: (event: FFAddonSDK$FrameEvent) => any,
            onLoad?: (event: FFAddonSDK$FrameEvent) => any,
            onAttach?: (event: FFAddonSDK$FrameEvent) => any,
            onDetach?: (event: FFAddonSDK$FrameEvent) => any
        }): FFAddonSDK$Frame
}
declare module 'sdk/ui/toolbar' {

    /**
     * 
     * @constructor  * 
     * @param options .title The toolbar's title. This appears as the name of the toolbar in the Firefox "Toolbars" menu
    It must be unique
     * @param options .title An array of items to appear in the toolbar. Each item in items must be an action button,
    a toggle button, or a frame instance. Buttons each take up a fixed width.
    If more than one frame is supplied here, the frames each occupy an equal vertical strip of the toolbar
     * @param options .onAttach This event is emitted when the toolbar is first loaded.
    Note that since there is only one toolbar for the whole browser, opening another browser window does not
    cause this event to be emitted again. After this event the toolbar's properties are available
    */
    declare export function Toolbar(
        options: {
            title: string,
            items: ToolbarItem[],
            hidden?: boolean,
            onAttach?: (toolbar: Toolbar) => any,
            onDetach?: (toolbar: Toolbar) => any,
            onShow?: (toolbar: Toolbar) => any,
            onHide?: (toolbar: Toolbar) => any
        }): Toolbar
    declare type ToolbarItem = FFAddonSDK$Frame | FFAddonSDK$ActionButton | FFAddonSDK$ToggleButton;
}
declare module 'sdk/ui/sidebar' {

    /**
     * 
     * @constructor  * 
     * @param options .id The id of the sidebar. This is used to identify this sidebar in its chrome window. It must be unique
     */
    declare export function Sidebar(
        options: {
            id?: string,
            title: string,
            url: string,
            onShow?: () => any,
            onHide?: () => any,
            onAttach?: (worker: SidebarWorker) => any,
            onDetach?: () => any,
            onReady?: (worker: SidebarWorker) => any
        }): Sidebar
    declare interface SidebarWorker {
        port: FFAddonSDK$Port
    }
}
declare module 'sdk/url' {

    /**
     * The URL constructor creates an object that represents a URL, verifying that the provided string is a valid URL in the process.
     * Any API in the SDK which has a URL parameter will accept URL objects, not raw strings, unless otherwise noted
     * @constructor  * 
     * @param source A string to be converted into a URL. If source is not a valid URI, this constructor will throw an exception
     * @param base Used to resolve relative source URLs into absolute ones
     */
    declare export function URL(source: string, base?: string): FFAddonSDK$SDKURL

    /**
     * The DataURL constructor creates an object that represents a data: URL,
     * verifying that the provided string is a valid data: URL in the process
     * @constructor  * 
     * @param uri A string to be parsed as Data URL. If is not a valid URI, this constructor will throw an exception
     */
    declare export function DataURL(uri: string): DataURL

    /**
     * Attempts to convert the given URL to a native file path. This function will automatically attempt to resolve
     * non-file protocols, such as the resource: protocol, to their place on the file system.
    An exception is raised if the URL can't be converted; otherwise, the native file path is returned as a string
    */
    declare export function toFilename(url: FFAddonSDK$SDKURL): string

    /**
     * Converts the given native file path to a file: URL
     */
    declare export function toFileName(url: string): string

    /**
     * Checks the validity of a URI. isValidURI("http://mozilla.org") would return true,
     * whereas isValidURI("mozilla.org") would return false
     */
    declare export function isValidURI(uri: string): boolean

    /**
     * Returns the top-level domain for the given URL: that is, the highest-level domain under which individual domains may be registered
     */
    declare export function getTLD(url: string): string
}
declare module 'sdk/windows' {
    declare export var browserWindows: BrowserWindows;
    declare type BrowserWindows = {

        /**
         * Open a new window
         * @param options .isPrivate determines whether the new window should be private or not
         */
        open: (
            options: string | {
                url: string,
                isPrivate?: boolean,
                onOpen?: (window: FFAddonSDK$BrowserWindow) => any,
                onClose?: (window: FFAddonSDK$BrowserWindow) => any,
                onActivate?: (window: FFAddonSDK$BrowserWindow) => any,
                onDeactivate?: (window: FFAddonSDK$BrowserWindow) => any
            }) => FFAddonSDK$BrowserWindow,
        on: (
            event: "open" | "close" | "activate" | "deactivate",
            handler: (window: FFAddonSDK$BrowserWindow) => any) => void,
        activeWindow: FFAddonSDK$BrowserWindow
    } & Array

}

declare var npm$namespace$FFAddonSDK: {
    Frame: typeof FFAddonSDK$Frame,
    ToggleButton: typeof FFAddonSDK$ToggleButton,
    ActionButton: typeof FFAddonSDK$ActionButton,
}
declare interface FFAddonSDK$BrowserWindow {
    title: string,
        activate: () => void,
        close: (callback?: () => void) => void,
        tabs: FFAddonSDK$Tab[]
}

declare interface FFAddonSDK$SDKURL {
    scheme: string,
        userPass: string,
        host: string,
        port: string,
        path: string,
        hostname: string,
        pathname: string,
        hash: string,
        href: string,
        origin: string,
        protocol: string,
        search: string,
        toString: () => string,
        toJSON: () => string
}

declare interface FFAddonSDK$FrameEvent {
    origin: string,
        source: FFAddonSDK$Frame,
        data?: any
}


/**
 * Creates a frame. Once created, the frame needs to be added to a toolbar for it to be visible
 * @param options .url A URL pointing to the HTML file specifying the frame's content.
      The file must be bundled with the add-on under its "data" directory
 * @param options .name The frame's name. This must be unique within your add-on.
This is used to generate an ID to to keep track of the frame. If you don't supply a name, the ID is derived from
the frame's URL, meaning that if you don't supply a name, you may not create two frames with the same URL
 * @param options .onReady This event is emitted while a frame instance is being loaded, at the point where it becomes
possible to interact with the frame although sub-resources may still be in the process of loading
It's the equivalent of the point where the frame's document.readyState becomes "interactive"
 * @param options .onAttach This event is emitted whenever a new frame instance is constructed and the browser has
started to load its document: for example, when the user opens a new browser window, if that window has a
toolbar containing this frame. Since the event is dispatched asynchronously, the document may already be
loaded by the time the event is received.
At this point, you should not try to send messages to scripts hosted in the frame
because the frame scripts may not have been loaded
 * @param options .onDetach This event is emitted when a frame instance is unloaded: for example, when the user
closes a browser window, if that window has a toolbar containing this frame.
After receiving this message, you ahould not attempt to communicate with the frame scripts
 * @constructor  
*/
declare export function FFAddonSDK$Frame(
    options: {
        url: string,
        name?: string,
        onMessage?: (message: FFAddonSDK$FrameEvent) => any,
        onReady?: (event: FFAddonSDK$FrameEvent) => any,
        onLoad?: (event: FFAddonSDK$FrameEvent) => any,
        onAttach?: (event: FFAddonSDK$FrameEvent) => any,
        onDetach?: (event: FFAddonSDK$FrameEvent) => any
    }): FFAddonSDK$Frame

declare type FFAddonSDK$Icon = string | {
    16?: string,
    32?: string,
    64?: string
};

declare interface FFAddonSDK$ToggleButtonState {
    id: string,
        label: string,
        badge: string,
        checked: boolean,
        disabled: boolean
}


/**
 * Creates a toggle button
 * @constructor  * 
 * @param options .id The button's ID. This is used internally to keep track of this button
    The ID must be unique within your add-on
 * @param options .label The button's human-readable label. When the button is in the toolbar,
      this appears in a tooltip, and when the button is in the menu,
      it appears underneath the button as a legend
 * @param options .icon One or more icons for the button
*/
declare export function FFAddonSDK$ToggleButton(
    options: {
        id: string,
        label: string,
        icon: FFAddonSDK$Icon,
        onChange?: (state: FFAddonSDK$ToggleButtonState) => any,
        onClick?: (state: FFAddonSDK$ToggleButtonState) => any,
        badge?: string | number,
        badgeColor?: string,
        disabled?: boolean,
        checked?: boolean
    }): FFAddonSDK$ToggleButton

declare interface FFAddonSDK$ActionButtonState {
    id: string,
        label: string,
        disabled: boolean,
        icon: FFAddonSDK$Icon,
        badge: string | number,
        badgeColor: string
}


/**
 * Creates an action button
 * @constructor  * 
 * @param options .id The button's ID. This is used internally to keep track of this button
    The ID must be unique within your add-on
 * @param options .label The button's human-readable label. When the button is in the toolbar,
      this appears in a tooltip, and when the button is in the menu,
      it appears underneath the button as a legend
 * @param options .icon One or more icons for the button
*/
declare export function FFAddonSDK$ActionButton(
    options: {
        id: string,
        label: string,
        icon: FFAddonSDK$Icon,
        onClick?: (state: FFAddonSDK$ActionButton) => any,
        onChange?: (state: FFAddonSDK$ActionButtonState) => any,
        disabled?: boolean,
        badge?: string | number,
        badgeColor?: string
    }): FFAddonSDK$ActionButton

declare interface FFAddonSDK$Tab {
    title: string,
        url: string,
        id: string,
        favicon: string,
        contentType: string,
        index: number,
        isPinned: boolean,
        window: FFAddonSDK$BrowserWindow,
        readyState: "uninitialized" | "loading" | "interactive" | "complete",
        on: (
            event: "ready" |
            "load" |
            "pageshow" |
            "activate" |
            "deactivate" |
            "close",
            handler: (tab: FFAddonSDK$Tab) => any) => void,
        attach: (
            options: {
                contentScript?: string | string[],
                contentScriptFile?: string | string[],
                contentScriptOptions?: Object,
                onMessage?: (message: string) => any,
                onError?: (error: Error) => any
            }) => FFAddonSDK$ContentWorker,
        activate: () => void,
        pin: () => void,
        unpin: () => void,
        close: (afterClose?: () => any) => void,
        reload: () => void,
        getThumbnail: () => string
}


/**
 * The SDK port API
 * @see  [port API]{
 * @link  https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/using_port}
 */
declare interface FFAddonSDK$Port {
    emit: (event: string, data?: any) => void,
        on: (event: string, handler: (data?: any) => any) => void
}

declare interface FFAddonSDK$ContentWorker {
    new(
        options: {
            window: Window,
            contentScript?: string | string[],
            contentScriptFile?: string | string[],
            onMessage: (data?: any) => any,
            onError: (data?: any) => any
        }): FFAddonSDK$ContentWorker,
    url: URL,
        port: FFAddonSDK$Port,
        tab: FFAddonSDK$Tab,
        on: (event: "detach" | "message" | "error", handler: () => any) => void,
        postMessage: (data?: any) => void,
        destroy: () => void
}

declare interface FFAddonSDK$Widget {}


/**
 * 
 * @see  [nsIException]{
 * @link  https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIException}
 */
declare interface FFAddonSDK$NSIException {
    lineNumber: number,
        columnNumber: number,
        data: any,
        filename: string,
        inner?: FFAddonSDK$NSIException,
        location?: any,
        message: string,
        name: string,
        result: any,
        toString: () => string
}