// @flow
/**
 * Flowtype definitions for ckeditor
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$CKEDITOR: {
    add: typeof CKEDITOR$add,
    addCss: typeof CKEDITOR$addCss,
    addTemplate: typeof CKEDITOR$addTemplate,
    appendTo: typeof CKEDITOR$appendTo,
    domReady: typeof CKEDITOR$domReady,
    dialogCommand: typeof CKEDITOR$dialogCommand,
    editorConfig: typeof CKEDITOR$editorConfig,
    getCss: typeof CKEDITOR$getCss,
    getTemplate: typeof CKEDITOR$getTemplate,
    getUrl: typeof CKEDITOR$getUrl,
    inline: typeof CKEDITOR$inline,
    inlineAll: typeof CKEDITOR$inlineAll,
    loadFullCore: typeof CKEDITOR$loadFullCore,
    replace: typeof CKEDITOR$replace,
    replaceAll: typeof CKEDITOR$replaceAll,
}
declare var disableAutoInline: boolean;

declare var disableObjectResizing: boolean;

declare var replaceClass: string;

declare var skinName: string;

declare var ALT: number;

declare var CTRL: number;

declare var DIALOG_RESIZE_BOTH: number;

declare var DIALOG_RESIZE_HEIGHT: number;

declare var DIALOG_RESIZE_NONE: number;

declare var DIALOG_RESIZE_WIDTH: number;

declare var ELEMENT_MODE_APPENDTO: number;

declare var ELEMENT_MODE_INLINE: number;

declare var ELEMENT_MODE_NONE: number;

declare var ELEMENT_MODE_REPLACE: number;

declare var END: number;

declare var ENTER_BR: number;

declare var ENTER_P: number;

declare var EVENT_PHASE_AT_TARGET: number;

declare var EVENT_PHASE_BUBBLING: number;

declare var EVENT_PHASE_CAPTURING: number;

declare var LINEUTILS_AFTER: number;

declare var LINEUTILS_BEFORE: number;

declare var LINEUTIS_INSIDE: number;

declare var NODE_COMMENT: number;

declare var NODE_DOCUMENT: number;

declare var NODE_DOCUMENT_FRAGMENT: number;

declare var NODE_ELEMENT: number;

declare var NODE_TEXT: number;

declare var SELECTION_ELEMENT: number;

declare var SELECTION_NONE: number;

declare var SELECTION_TEXT: number;

declare var SHIFT: number;

declare var SHRINK_ELEMENT: number;

declare var SHRINK_TEXT: number;

declare var START: number;

declare var TRISTATE_DISABLED: number;

declare var TRISTATE_OFF: number;

declare var TRISTATE_ON: number;

declare var UI_BUTTON: string;

declare var UI_MENUBUTTON: string;

declare var UI_PANEL: string;

declare var UI_PANELBUTTON: string;

declare var UI_RICHCOMBO: string;

declare var UI_SEPARATOR: string;

declare var basePath: string;

declare var currentInstance: CKEDITOR$editor;

declare var document: dom$document;

declare var env: CKEDITOR$environmentConfig;

declare var instances: CKEDITOR$editor[];

declare var loadFullCoreTimeout: number;

declare var revision: string;

declare var rnd: number;

declare var status: string;

declare var timestamp: string;

declare var version: string;

declare var config: CKEDITOR$config;

declare function CKEDITOR$add(editor: CKEDITOR$editor): void

declare function CKEDITOR$addCss(css: string): void

declare function CKEDITOR$addTemplate(name: string, source: string): CKEDITOR$template

declare function CKEDITOR$appendTo(element: string, config?: CKEDITOR$config, data?: string): CKEDITOR$editor

declare function CKEDITOR$domReady(): void

declare function CKEDITOR$dialogCommand(dialogName: string): void

declare function CKEDITOR$editorConfig(config: CKEDITOR$config): void

declare function CKEDITOR$getCss(): string

declare function CKEDITOR$getTemplate(name: string): CKEDITOR$template

declare function CKEDITOR$getUrl(resource: string): string

declare function CKEDITOR$inline(element: string, instanceConfig?: CKEDITOR$config): CKEDITOR$editor

declare function CKEDITOR$inlineAll(): void

declare function CKEDITOR$loadFullCore(): void

declare function CKEDITOR$replace(
    element: string | HTMLTextAreaElement,
    config?: CKEDITOR$config): CKEDITOR$editor

declare function CKEDITOR$replaceAll(className?: string): void

declare class comment {
    type: number;
    constructor(comment: string, ownerDocument?: dom$document): this;
    constructor(comment: Object, ownerDocument?: dom$document): this;
    getOuterHtml(): string
}

declare class document mixins domObject {
    type: number;
    constructor(domDocument: Object): this;
    appendStyleSheet(cssFileUrl: string): void;
    appendStyleText(cssStyleText: string): Object;
    createElement(
        name: string,
        attribsAndStyles?: {
            attributes: Object,
            styles: Object
        }): htmlParser$element;
    createText(text: string): htmlParser$element;
    find(selector: string): dom$nodeList;
    findOne(selector: string): htmlParser$element;
    focus(): void;
    getActive(): htmlParser$element;
    getBody(): htmlParser$element;
    getByAddress(address: any[], normalized?: boolean): htmlParser$node;
    getById(elementId: string): htmlParser$element;
    getDocumentElement(): htmlParser$element;
    getElementsByTag(tagName: string): dom$nodeList;
    getHead(): htmlParser$element;
    getSelection(): dom$selection;
    getWindow(): dom$window;
    write(html: string): void
}

declare class documentFragment {
    type: number;
    constructor(nodeOrDoc: Object): this;
    insertAfterNode(node: htmlParser$node): void
}

declare class domObject mixins event {
    $: HTMLElement;
    constructor(nativeDomObject: Object): this;
    clearCustomData(): void;
    equals(object: any): boolean;
    getCustomData(key: string): any;
    getPrivate(): any;
    getUniqueId(): number;
    removeAllListeners(): void;
    removeCustomData(key: string): Object;
    setCustomData(key: string, value: Object): dom$domObject
}

declare class element mixins node {
    type: number;
    constructor(element: string, ownerDocument?: dom$document): this;
    constructor(element: HTMLElement, ownerDocument?: dom$document): this;
    addClass(className: string): void;
    append(node: htmlParser$node, toStart?: boolean): htmlParser$node;
    append(node: string, toStart?: boolean): htmlParser$node;
    appendBogus(force: boolean): void;
    appendHtml(html: string): void;
    appendText(text: string): htmlParser$node;
    breakParent(parent: dom$element): void;
    contains(node: htmlParser$node): boolean;
    copyAttributes(dest: dom$element, skipAttributes: Object): void;
    data(name: string): string;
    data(name: string, value: string): void;
    data(name: string, value: boolean): void;
    disableContextMenu(): void;
    find(selector: string): dom$nodeList;
    findOne(selector: string): dom$element;
    focus(defer?: boolean): void;
    focusNext(ignoreChildren?: boolean, indexToUse?: number): void;
    focusPrevious(ignoreChildren?: boolean, indexToUse?: number): void;
    forEach(
        callback: (node: htmlParser$node) => void,
        type?: number,
        skipRoot?: boolean): void;
    getAttribute(name: string): string;
    getBogus(): Object;
    getChild(indices: number): htmlParser$node;
    getChild(indices: number[]): htmlParser$node;
    getChildCount(): number;
    getChildren(): dom$nodeList;
    getClientRect(): any;
    getComputedStyle(propertyName: string): string;
    getDirection(useComputed: boolean): string;
    getDocumentPosition(refDocument: dom$document): dom$position;
    getDtd(): any;
    getEditor(): CKEDITOR$editor;
    getElementsByTag(tagName: string): dom$nodeList;
    getFirst(evaluator?: Function): htmlParser$node;
    getFrameDocument(): dom$document;
    getHtml(): string;
    getId(): string;
    getLast(evaluator?: Function): htmlParser$node;
    getName(): string;
    getNameAtt(): string;
    getOuterHtml(): string;
    getPositionedAncestor(): dom$element;
    getSize(type: string, isBorderBox: boolean): void;
    getStyle(name: string): string;
    getTabIndex(): number;
    getText(): string;
    getValue(): string;
    getWindow(): dom$window;
    hasAttributes(): boolean;
    hasAttribute(name: string): boolean;
    hasClass(className: string): boolean;
    hide(): void;
    is(...name: string[]): boolean;
    is(name: any): boolean;
    isBlockBoundary(customNodeNames: Object): boolean;
    isEditable(textCursor?: boolean): boolean;
    isEmptyInlineRemoveable(): boolean;
    isIdentical(otherElement: dom$element): boolean;
    isVisible(): boolean;
    mergeSiblings(inlineOnly?: boolean): void;
    moveChildren(target: dom$element, toStart?: boolean): void;
    removeAttribute(name: string): void;
    removeAttributes(attributes?: string[]): void;
    removeClass(className: string): void;
    removeStyle(name: string): void;
    renameNode(newTag: string): void;
    scrollIntoParent(parent: dom$element, alignToTop: boolean, hscroll: boolean): void;
    scrollIntoParent(parent: dom$window, alignToTop: boolean, hscroll: boolean): void;
    scrollIntoView(alignToTop?: boolean): void;
    setAttribute(name: string, value: string): dom$element;
    setAttributes(attributesPairs: Object): dom$element;
    setHtml(html: string): string;
    setOpacity(opacity: number): void;
    setSize(type: string, size: number, isBorderBox: boolean): void;
    setState(state: number, base?: Object, useAria?: Object): void;
    setStyle(name: string, value: string): dom$element;
    setStyles(stylesPair: Object): dom$element;
    setText(text: string): string;
    setValue(value: string): dom$element;
    show(): void;
    unselectable(): void;
    clearAllMarkers(database: Object): Object;
    clearMarkers(database: Object, element: Object, removeFromDatabase: Object): void;
    createFromHtml(html: string): dom$element;
    get(element: string): dom$element;
    get(element: any): dom$element;
    setMarker(database: Object, element: Object, name: Object, value: Object): dom$domObject
}

declare class elementPath {
    constructor(startNode: dom$element, root: dom$element): this;
    block: dom$element;
    blockLimit: dom$element;
    root: dom$element;
    elements: dom$element[];
    compare(otherPath: dom$elementPath): boolean;
    contains(query: string, excludeRoot: boolean, fromTop: boolean): dom$element;
    contains(query: string[], excludeRoot: boolean, fromTop: boolean): dom$element;
    contains(
        query: (element: dom$element) => boolean,
        excludeRoot: boolean,
        fromTop: boolean): dom$element;
    contains(query: Object, excludeRoot: boolean, fromTop: boolean): dom$element;
    contains(query: dom$element, excludeRoot: boolean, fromTop: boolean): dom$element;
    isContextFor(tag: string): boolean;
    direction(): string
}

declare class range {
    constructor(root: dom$element): this;
    constructor(root: dom$document): this;
    startContainer: any;
    startOffset: number;
    endContainer: any;
    endOffset: number;
    collapsed: boolean;
    isDocRoot: boolean;
    document: dom$document;
    root: dom$element;
    clone(): dom$range;
    collapse(toStart?: boolean): boolean;
    cloneContents(): dom$documentFragment;
    deleteContents(mergeThen?: boolean): void;
    extractContents(mergeThen?: boolean): dom$documentFragment;
    createBookmark(serializable: boolean): Object;
    createBookmark2(normalized: boolean): Object;
    createIterator(): dom$iterator;
    moveToBookmark(bookmark: Object): void;
    getBoundaryNodes(): {
        startNode: htmlParser$node,
        endNode: htmlParser$node
    };
    getCommonAncestor(includeSelf: boolean, ignoreTextNode: boolean): dom$element;
    optimize(): void;
    optimizeBookmark(): void;
    trim(ignoreStart?: boolean, ignoreEnd?: boolean): void;
    enlarge(unit: number, excludeBrs?: boolean): void;
    shrink(mode: number, selectContents: boolean): void;
    insertNode(node: htmlParser$node): void;
    moveToPosition(node: htmlParser$node, position: Object): void;
    moveToRange(range: dom$range): void;
    selectNodeContents(node: htmlParser$node): void;
    setStart(startNode: htmlParser$node, startOffset: number): void;
    setEnd(endNode: htmlParser$node, endOffset: number): void;
    setStartAfter(node: htmlParser$node): void;
    setStartBefore(node: htmlParser$node): void;
    setStartAt(node: htmlParser$node, position: number): void;
    setEndAt(node: htmlParser$node, position: number): void;
    fixBlock(isStart: boolean, blockTag: Object): Object;
    splitBlock(blockTag: Object): Object;
    splitElement(toSplit: dom$element): dom$element;
    removeEmptyBlocksAtEnd(atEnd: boolean): void;
    startPath(): dom$elementPath;
    endPath(): dom$elementPath;
    checkBoundaryOfElement(element: dom$element, checkType: number): boolean;
    checkStartOfBlock(): boolean;
    checkEndOfBlock(): boolean;
    getPreviousNode(evaluator: Function, guard: Function, boundary: dom$element): dom$element;
    getNextNode(evaluator: Function, guard: Function, boundary: dom$element): dom$element;
    checkReadOnly(): boolean;
    moveToElementEditablePosition(element: dom$element, isMoveToEnd: boolean): boolean;
    movetoClosestEditablePosition(element: dom$element, isMoveToEnd: boolean): boolean;
    moveToElementEditStart(target: Object): boolean;
    moveToElementEditEnd(target: Object): boolean;
    getEnclosedNode(): htmlParser$node;
    getTouchedStartNode(): htmlParser$node;
    getTouchedEndNode(): htmlParser$node;
    getNextEditableNode(): Object;
    getPreviousEditableNode(): Object;
    scrollIntoView(): void
}

declare interface dom$rangeListIterator {}

declare class selection {
    document: dom$document;
    isFake: boolean;
    isLocked: boolean;
    rev: number;
    root: dom$element;
    constructor(target: dom$document): this;
    constructor(target: dom$element): this;
    constructor(target: dom$selection): this;
    createBookmarks(serializable: Object): any[];
    createBookmarks2(normalized?: Object): any[];
    fake(element: dom$element): void;
    getCommonAncestor(): dom$element;
    getNative(): Object;
    getRanges(onlyEditables?: boolean): any[];
    getSelectedElement(): dom$element;
    getSelectedText(): string;
    getStartElement(): dom$element;
    getType(): number;
    isHidden(): boolean;
    lock(): void;
    removeAllRanges(): void;
    reset(): void;
    scrollIntoView(): void;
    selectBookmarks(bookmarks: any[]): dom$selection;
    selectElement(element: dom$element): void;
    selectRanges(ranges: any[]): void;
    unlock(restore: Object): void
}

declare class rangeList {
    constructor(ranges: dom$range[]): this;
    constructor(range: dom$range): this;
    createIterator(): dom$rangeListIterator;
    createBokmark(serializable: boolean): Object[];
    createBookmark2(normalized: boolean): Object[];
    moveToBookmark(bookmarks: Object[]): void
}

declare class iterator {
    constructor(range: dom$range): this;
    getNextParagraph(blockTag?: string): dom$element;
    activeFilter: htmlParser$filter;
    enforceRealBlocks: boolean;
    enlargeBr: boolean;
    filter: htmlParser$filter
}

declare class node mixins domObject {
    constructor(domNode: Node): this;
    appendTo(element: dom$element): dom$element;
    clone(includeChildren: boolean, cloneId: boolean): dom$node;
    hasPrevious(): boolean;
    hasNext(): boolean;
    insertAfter(node: dom$node): dom$node;
    insertBefore(node: dom$node): dom$node;
    insertBeforeMe(node: dom$node): dom$node;
    getAddress(normalized: boolean): Object[];
    getDocument(): dom$document;
    getIndex(normalized?: boolean): number;
    getNextSourceNode(startFromSibling: Object, nodeType: Object, guard: Object): void;
    getPreviousSourceNode(startFromSibling: Object, nodeType: Object, guard: Object): void;
    getPrevious(evaluator?: Function): dom$node;
    getNext(evaluator?: Function): dom$node;
    getParent(allowFragmentParent?: boolean): dom$element;
    getParents(closerFirst?: boolean): dom$node[];
    getCommonAncestor(node: Object): void;
    getPosition(otherNode: Object): void;
    getAscendant(reference: string, includeSelf?: boolean): dom$node;
    hasAscendant(name: Object, includeSelf: any): boolean;
    move(preserveChildren?: boolean): dom$node;
    replace(nodeToReplace: dom$node): void;
    trim(): void;
    ltrim(): void;
    rtrim(): void;
    isReadOnly(): boolean
}

declare class nodeList {
    constructor(nativeList: Object): this;
    count(): number;
    getItem(index: number): dom$node
}

declare class event {
    constructor(domEvent: Event): this;
    getKey(): number;
    getKeystroke(): number;
    preventDefault(stopPropagation: boolean): void;
    stopPropagation(): void;
    getTarget(): dom$node;
    getPhase(): number;
    getPhaseOffset(): dom$position;
    on(
        eventName: string,
        listenerFunction: (eventInfo: CKEDITOR$eventInfo) => void,
        scopeObj?: Object,
        listenerData?: Object,
        priority?: number): Object
}

declare interface dom$position {
    x: number,
        y: number
}

declare interface dom$widthAndHeight {
    width: number,
        height: number
}

declare class text mixins node {
    constructor(text: Text, ownerDocument?: dom$document): this;
    constructor(text: string, ownerDocument?: dom$document): this;
    type: number;
    getLength(): number;
    getText(): string;
    setText(text: string): void;
    split(offset: number): dom$text;
    substring(indexA: number, indexB: number): void
}

declare class window mixins domObject {
    constructor(domWindow: Object): this;
    focus(): void;
    getViewPaneSize(): dom$widthAndHeight;
    getScrollPosition(): dom$position;
    getFrame(): dom$element
}

declare class walker {
    constructor(range: dom$range): this;
    end(): void;
    next(): dom$node;
    previous(): dom$node;
    checkForward(): boolean;
    checkBackward(): boolean;
    lastForward(): dom$node;
    lastBackward(): dom$node;
    reset(): void;
    blockBoundary(customNodeNames: Object): Function;
    listItemBoundary(): Function;
    bookmark(contentOnly?: boolean, isReject?: boolean): Function;
    whitespaces(isReject?: boolean): Function;
    invisible(isReject?: boolean): Function;
    nodeType(type: number, isReject?: boolean): Function;
    bogus(isReject?: boolean): Function;
    temp(isReject?: boolean): Function;
    ignored(isReject?: boolean): Function;
    editable(isReject?: boolean): Function
}


declare var npm$namespace$ajax: {
    load: typeof ajax$load,
    loadXml: typeof ajax$loadXml,
}
declare function ajax$load(url: string, callback?: Function): string

declare function ajax$loadXml(url: string, callback?: Function): CKEDITOR$xml

declare interface CKEDITOR$xml {}

declare class command mixins event {
    contextSensitive: boolean;
    editorFocus: boolean;
    modes: any;
    previousState: number;
    state: number;
    uiItems: any[];
    constructor(editor: CKEDITOR$editor, commandDefinition: CKEDITOR$commandDefinition): this;
    checkAllowed(noCache: boolean): boolean;
    disable(): void;
    enable(): void;
    exec(data?: Object): boolean;
    refresh(editor: CKEDITOR$editor, path: dom$elementPath): void;
    setState(newState: number): boolean;
    toggleState(): void
}

declare class focusManager {
    currentActive: dom$domObject;
    hasFocus: boolean;
    constructor(editor: CKEDITOR$editor): this;
    focus(currentActive?: dom$element): void;
    lock(): void;
    unlock(): void;
    blur(noDelay?: boolean): void;
    add(element: dom$element, isCapture: boolean): void;
    remove(element: dom$element): void
}

declare interface CKEDITOR$keystrokeHandler {}

declare interface CKEDITOR$toolbarGroups {
    name?: string,
        groups?: string[]
}

declare interface config$styleObject {
    name?: string,
        element: string,
        attributes?: Object,
        styles?: Object,
        overrides?: Object
}

declare interface CKEDITOR$config {
    allowedContent?: boolean | string | Object | CKEDITOR$style,
        autoEmbed_widget?: string | Function,
        autoGrow_bottomSpace?: number,
        autoGrow_maxHeight?: number,
        autoGrow_minHeight?: number,
        autoGrow_onStartup?: boolean,
        autoUpdateElement?: boolean,
        baseFloatZIndex?: number,
        baseHref?: string,
        basicEntities?: boolean,
        blockedKeystrokes?: number[],
        bodyClass?: string,
        bodyId?: string,
        browserContextMenuOnCtrl?: boolean,
        clipboard_defaultContentType?: string,
        codeSnippet_codeClass?: string,
        codeSnippet_languages?: Object,
        coceSnippet_theme?: string,
        colorButton_backStyle?: config$styleObject,
        colorButton_colors?: string,
        colorButton_enableMore?: boolean,
        colorButton_foreStyle?: config$styleObject,
        contentsCss?: string | string[],
        contentsLangDirection?: string,
        contentsLanguage?: string,
        coreStyles_bold?: config$styleObject,
        coreStyles_italic?: config$styleObject,
        coreStyles_strike?: config$styleObject,
        coreStyles_subscript?: config$styleObject,
        coreStyles_superscript?: config$styleObject,
        coreStyles_underline?: config$styleObject,
        customConfig?: string,
        dataIndentationChars?: string,
        defaultLanguage?: string,
        devtools_styles?: string,
        devtools_textCallback?: Function,
        dialog_backgroundCoverColor?: string,
        dialog_backgroundCoverOpacity?: number,
        dialog_buttonsOrder?: string,
        dialog_magnetDistance?: number,
        dialog_noConfirmCancel?: boolean,
        dialog_startupFocusTab?: boolean,
        disableNativeSpellChecker?: boolean,
        disableNativeTableHandles?: boolean,
        disableNativeObjectResizing?: boolean,
        disableNativeReadonlySTyling?: boolean,
        disallowedContent?: string | Object,
        div_wrapTable?: boolean,
        docType?: string,
        emailProtection?: string,
        embed_provider?: string,
        enableTabKeyTools?: boolean,
        enterMode?: number,
        entities?: boolean,
        entities_additional?: string,
        entities_greek?: boolean,
        entities_latin?: boolean,
        entities_processNumerical?: boolean | string,
        extraAllowedContent?: string | Object,
        extraPlugins?: string,
        fileTools_defaultFileName?: string,
        filebrowserBrowseUrl?: string,
        filebrowserFlashBrowseUrl?: string,
        filebrowserFlashUploadUrl?: string,
        filebrowserImageBrowseLinkUrl?: string,
        filebrowserImageBrowseUrl?: string,
        filebrowserImageUploadUrl?: string,
        filebrowserUploadUrl?: string,
        filebrowserWindowFeatures?: string,
        filebrowserWindowHeight?: number | string,
        filebrowserWindowWidth?: number | string,
        fillEmptyBlocks?: boolean | Function,
        find_highlight?: config$styleObject,
        flashAddEmbedTag?: boolean,
        flashConvertOnEdit?: boolean,
        flashEmbedTagOnly?: boolean,
        floatSpaceDockedOffsetX?: number,
        floatSpaceDockedOffsetY?: number,
        floatSpacePinnedOffsetX?: number,
        floatSpacePinnedOffsetY?: number,
        floatSpacePreferRight?: boolean,
        fontSize_defaultLabel?: string,
        fontSize_sizes?: string,
        fontSize_style?: config$styleObject,
        font_defaultLabel?: string,
        font_names?: string,
        font_style?: config$styleObject,
        forceEnterMode?: boolean,
        forcePasteAsPlainText?: boolean,
        forceSimpleAmpersand?: boolean,
        format_address?: config$styleObject,
        format_div?: config$styleObject,
        format_h1?: config$styleObject,
        format_h2?: config$styleObject,
        format_h3?: config$styleObject,
        format_h4?: config$styleObject,
        format_h5?: config$styleObject,
        format_h6?: config$styleObject,
        format_p?: config$styleObject,
        format_pre?: config$styleObject,
        format_tags?: string,
        fullPage?: boolean,
        grayt_autoStartup?: boolean,
        height?: string | number,
        htmlEncodeOutput?: boolean,
        ignoreEmptyParagraph?: boolean,
        image2_alignClasses?: string[],
        image2_captionedClass?: string,
        image2_disableResizer?: boolean,
        image2_prefillDimensions?: boolean,
        imageUploadUrl?: string,
        image_prefillDimensions?: boolean,
        image_previewText?: string,
        image_removeLinkByEmptyUrl?: boolean,
        indentClasses?: string[],
        indentOffset?: number,
        indentUnit?: string,
        jqueryOverrideVal?: boolean,
        justifyClasses?: string[],
        keystrokes?: any[],
        language?: string,
        language_list?: string[],
        linkJavaScriptLinksAllowed?: boolean,
        linkShowAdvancedTab?: boolean,
        linkShowTargetTab?: boolean,
        magicline_color?: string,
        magicline_everywhere?: boolean,
        magicline_holdDistance?: number,
        magicline_keystrokeNext?: number,
        magicline_keystrokePrevious?: number,
        magicline_tabuList?: number,
        magicline_triggerOffset?: number,
        mathJaxLib?: string,
        menu_groups?: string,
        menu_subMenuDelay?: string,
        newpage_html?: string,
        notification_duration?: number,
        on?: editor$eventObject,
        pasteFilter?: string,
        pasteFromWordCleanupFile?: string,
        pasteFromWordNumberedHeadingToList?: boolean,
        pasteFromWordPromptCleanup?: boolean,
        pasteFromWordRemoveFontStyles?: boolean,
        pasteFromWorkRemoveStyles?: boolean,
        plugins?: string,
        protectedSource?: RegExp[],
        readOnly?: boolean,
        removeButtons?: string,
        removeDialogTabs?: string,
        removeFormatAttributes?: string,
        removeFormatTags?: string,
        removePlugins?: string,
        resize_dir?: string,
        resize_enabled?: boolean,
        resize_maxHeight?: number,
        resize_maxWidth?: number,
        resize_minHeight?: number,
        resize_minWidth?: number,
        scayt_autoStartup?: boolean,
        scayt_contextCommands?: string,
        scayt_contextMenuItemsOrder?: string,
        scayt_customDictionaryIds?: string,
        scayt_customerId?: string,
        scayt_disableOptionsStorage?: string | string[],
        scayt_elementsToIgnore?: string,
        scayt_handleCheckDirty?: string,
        scayt_handleUndoRedo?: string,
        scayt_ignoreAllCapsWords?: boolean,
        scayt_ignoreDomainNames?: boolean,
        scayt_ignoreWordsWithMixedCases?: boolean,
        scayt_ignoreWordsWithNumbers?: boolean,
        scayt_inlineModeImmediateMarkup?: boolean,
        scayt_maxSuggestions?: number,
        scayt_minWordLength?: number,
        scayt_moreSuggestions?: string,
        scayt_multiLanguageMode?: boolean,
        scayt_multiLanguageStyles?: Object,
        scayt_sLang?: string,
        scayt_serviceHost?: string,
        scayt_servicePath?: string,
        scayt_servicePort?: string,
        scayt_serviceProtocol?: string,
        scayt_srcUrl?: string,
        scayt_uiTabs?: string,
        scayt_userDictionaryName?: string,
        sharedSpaces?: Object,
        shiftEnterMode?: number,
        skin?: string,
        smiley_columns?: number,
        smiley_descriptions?: string[],
        smiley_images?: string[],
        smiley_path?: string,
        sourceAreaTabSize?: number,
        specialChars?: any[],
        startupFocus?: boolean,
        startupMode?: string,
        startupOutlineBlocks?: boolean,
        startupShowBorders?: boolean,
        stylesSet?: string | boolean | config$styleObject[],
        stylesheetParser_skipSelectors?: RegExp,
        stylesheetParser_validSelectors?: RegExp,
        tabIndex?: number,
        tabSpaces?: number,
        templates?: string,
        templates_files?: Object,
        templates_replaceContent?: boolean,
        title?: string | boolean,
        toolbar?: string | (string | string[])[],
        toolbarCanCollapse?: boolean,
        toolbarGroupCycling?: boolean,
        toolbarGroups?: CKEDITOR$toolbarGroups[],
        toolbarLocation?: string,
        toolbarStartupExpanded?: boolean,
        uiColor?: string,
        undoStackSize?: number,
        uploadUrl?: string,
        useComputedState?: boolean,
        width?: string | number,
        wsc_cmd?: string,
        wsc_customDictionaryIds?: string,
        wsc_customLoaderScript?: string,
        wsc_customerId?: string,
        wsc_lang?: string,
        wsc_userDictionaryName?: string
}

declare interface CKEDITOR$feature {}

declare interface CKEDITOR$style {}

declare interface CKEDITOR$editable {}

declare class menu {
    constructor(): this;
    add(item: any): void;
    addListener(
        listenerFn: (
            startElement: dom$element,
            selection: dom$selection,
            path: dom$elementPath) => any): void;
    hide(returnFocus?: boolean): void;
    removeAll(): void;
    show(
        offsetParent: dom$element,
        corner?: number,
        offsetX?: number,
        offsetY?: number): void
}


declare var npm$namespace$plugins: {
    add: typeof plugins$add,
    addExternal: typeof plugins$addExternal,
    get: typeof plugins$get,
    getFilePath: typeof plugins$getFilePath,
    getPath: typeof plugins$getPath,
    load: typeof plugins$load,
    setLang: typeof plugins$setLang,
}
declare class contextMenu mixins menu {
    constructor(editor: CKEDITOR$editor): this;
    addTarget(element: dom$element, nativeContextMenuOnCtrl?: boolean): void;
    open(
        offsetParent: dom$element,
        corner?: number,
        offsetX?: number,
        offsetY?: number): void
}


declare var npm$namespace$link: {
    getEditorAnchors: typeof link$getEditorAnchors,
    getSelectedLink: typeof link$getSelectedLink,
    tryRestoreFakeAnchor: typeof link$tryRestoreFakeAnchor,
}
declare var emptyAnchorFix: boolean;

declare var fakeAnchor: boolean;

declare var synAnchorSelector: boolean;

declare function link$getEditorAnchors(editor: CKEDITOR$editor): dom$element[]

declare function link$getSelectedLink(editor: CKEDITOR$editor): dom$elementPath

declare function link$tryRestoreFakeAnchor(editor: CKEDITOR$editor, element: dom$element): dom$element

declare interface nestedEditable$definition {
    allowedContent?: any,
        pathName?: string,
        selector?: string
}

declare class nestedEditable mixins undefined.element {
    editor: CKEDITOR$editor;
    enterMode: number;
    filter: CKEDITOR$filter;
    shiftEnterMode: number;
    constructor(editor: CKEDITOR$editor, element: undefined.element, config: {
        filter?: CKEDITOR$filter
    }): this;
    getData(): string;
    setData(data: string): void
}

declare interface widget$definition {
    allowedContent?: any,
        pathName?: string,
        selector?: string
}

declare class repository {
    add(name: string, widgetDef: undefined.definition): void;
    addUpcastCallback(callback: Function): void;
    capture(): void;
    checkSelection(): void;
    checkWidgets(options?: {
        initOnlyNew?: boolean,
        focusInited?: boolean
    }): void;
    define(name: string, meta?: {
        errorProof?: boolean
    }): void;
    del(widget: undefined.widget): void;
    destroy(widget: undefined.widget, offline?: boolean): void;
    destroyAll(offline?: boolean): void;
    finalizeCreation(container: any): void;
    fire(eventName: string, data: Object, editor: CKEDITOR$editor): any;
    getByElement(element: any, checkWrapperOnly: boolean): undefined.widget;
    hasListeners(eventName: string): boolean;
    initOn(
        element: any,
        widgetDef?: undefined.definition,
        startupData?: Object): undefined.widget;
    initOnAll(container?: any): undefined.widget[];
    on(
        eventName: string,
        listenerFunction: Function,
        scopeObj?: Object,
        listenerData?: Object,
        priority?: number): any;
    once(): void;
    parseElementClasses(classes: string): any;
    removeAllListeners(eventName: string, listenerFunction: Function): void;
    wrapElement(element: any, widgetName?: string): any
}

declare class widget mixins undefined.definition {
    allowedContent: any;
    button: string;
    contentForms: any;
    contentTransformations: any;
    data: any;
    dataReady: boolean;
    defaults: any;
    definition: undefined.definition;
    dialog: string;
    downcast: string | Function;
    downcasts: any;
    draggable: boolean;
    editables: any;
    editor: CKEDITOR$editor;
    element: undefined.element;
    focusedEditable: undefined.nestedEditable;
    id: number;
    init: Function;
    inited: boolean;
    inline: boolean;
    insert: Function;
    mask: boolean;
    name: string;
    parts: any;
    pathName: string;
    ready: boolean;
    repository: undefined.repository;
    requiredContent: string | CKEDITOR$style;
    styleToAllowedContentRules: Function;
    styleableElements: string;
    template: CKEDITOR$template;
    upcast: string | Function;
    upcastPriority: number;
    upcasts: any;
    wrapper: undefined.element;
    constructor(widgetsRepo: undefined.repository, id: number, element: undefined.element, widgetDef: undefined.definition, starupData?: Object): this;
    addClass(className: string): void;
    applyStyle(style: CKEDITOR$style): void;
    capture(): void;
    checkStyleActive(style: CKEDITOR$style): boolean;
    define(name: string, meta: {
        errorProof?: boolean
    }): void;
    destroy(offline?: boolean): void;
    destroyEditable(editableName: string, offline?: boolean): void;
    edit(): boolean;
    fire(eventName: string, data?: Object, editor?: CKEDITOR$editor): any;
    fireOnce(eventName: string, data?: Object, editor?: CKEDITOR$editor): any;
    focus(): void;
    getClasses(): any;
    hasClass(className: string, Whether: boolean): void;
    hasListeners(eventName: string): boolean;
    initEditable(editableName: string, definition: undefined.definition): boolean;
    isInited(): boolean;
    isReady(): boolean;
    on(
        eventName: string,
        listenerFunction: Function,
        scopeObj?: Object,
        listenerData?: Object,
        priority?: number): any;
    once(): void;
    removeAllListeners(): void;
    removeClass(className: string): void;
    removeListener(eventName: string, listenerFunction: Function): void;
    removeStyle(style: CKEDITOR$style): void;
    setData(keyOrData: string | Object, value: Object): undefined.widget;
    setFocused(selected: boolean): undefined.widget;
    setSelected(selected: boolean): undefined.widget;
    toFeature(): CKEDITOR$feature;
    updateDragHandlerPosition(): void
}

declare interface plugins$IPluginDefinition {
    hidpi?: boolean,
        lang?: string | string[],
        requires?: string | string[],
        afterInit(editor: CKEDITOR$editor): any,
        beforeInit(editor: CKEDITOR$editor): any,
        init(editor: CKEDITOR$editor): any,
        onLoad(): any,
        icons?: string
}

declare function plugins$add(editor: CKEDITOR$editor): void

declare function plugins$addExternal(name: string, path: string, fileName: string): void

declare function plugins$get(name: string): any

declare function plugins$getFilePath(name: string): string

declare function plugins$getPath(name: string): string

declare function plugins$load(url: string, callback?: Function): string

declare function plugins$setLang(pluginName: string, languageCode: string, languageEntries: any): void

declare interface CKEDITOR$IMenuItemDefinition {
    label: string,
        command: string,
        group: string,
        order: number
}

declare class editor mixins event {
    activeEnterMode: number;
    activeFilter: htmlParser$filter;
    activeShiftEnterMode: number;
    blockless: boolean;
    config: CKEDITOR$config;
    container: dom$element;
    contextMenu: plugins$contextMenu;
    dataProcessor: CKEDITOR$dataProcessor;
    document: dom$document;
    element: dom$element;
    elementMode: number;
    enterMode: number;
    filter: htmlParser$filter;
    focusManager: CKEDITOR$focusManager;
    id: string;
    keystrokeHandler: CKEDITOR$keystrokeHandler;
    lang: any;
    langCode: string;
    mode: string;
    name: string;
    plugins: any;
    readOnly: boolean;
    shiftEnterMode: number;
    status: string;
    tabIndex: number;
    templates: any;
    title: any;
    toolbar: any;
    ui: CKEDITOR$ui;
    widgets: undefined.repository;
    window: dom$window;
    constructor(instanceConfig?: Object, element?: dom$element, mode?: number): this;
    addCommand(commandName: string, commandDefinition: CKEDITOR$commandDefinition): void;
    addFeature(feature: CKEDITOR$feature): boolean;
    addMenuGroup(name: string, order?: number): void;
    addMenuItem(name: string, definition?: CKEDITOR$IMenuItemDefinition): void;
    addMenuItems(definitions: {
        [id: string]: CKEDITOR$IMenuItemDefinition
    }): void;
    addMode(mode: string, exec: () => void): void;
    addRemoveFormatFilter(func: Function): void;
    applyStyle(style: CKEDITOR$style): void;
    attachStyleStateChange(style: CKEDITOR$style, callback: Function): void;
    checkDirty(): boolean;
    commands: any;
    createFakeElement(
        realElement: Object,
        className: Object,
        realElementType: Object,
        isResizable: Object): void;
    createFakeParserElement(
        realElement: Object,
        className: Object,
        realElementType: Object,
        isResizable: Object): void;
    createRange(): dom$range;
    destroy(noUpdate?: boolean): void;
    editable(elementOrEditable: dom$element): void;
    editable(elementOrEditable: CKEDITOR$editable): void;
    elementPath(startNode?: dom$node): dom$elementPath;
    execCommand(commandName: string, data?: Object): boolean;
    focus(): void;
    forceNextSelectionCheck(): void;
    getClipboardData(options: Object, callback: Function): void;
    getColorFromDialog(callback: Function, scope?: Object): void;
    getCommand(commandName: string): CKEDITOR$command;
    getData(noEvents?: Object): string;
    getMenuItem(name: string): Object;
    getResizable(forContents: boolean): dom$element;
    getSelection(forceRealSelection?: boolean): dom$selection;
    getSnapshot(): string;
    getStylesSet(callback: Function): void;
    getUiColor(): string;
    insertElement(element: dom$element): void;
    insertHtml(html: string, mode?: string): void;
    insertText(text: string): void;
    loadSnapshot(snapshot: Object): void;
    lockSelection(sel?: dom$selection): boolean;
    openDialog(dialogName: string, callback: Function): CKEDITOR$dialog;
    popup(url: string, width?: number, height?: number, options?: string): void;
    popup(url: string, width?: string, height?: number, options?: string): void;
    popup(url: string, width?: number, height?: string, options?: string): void;
    popup(url: string, width?: string, height?: string, options?: string): void;
    removeMenuItem(name: string): void;
    removeStyle(style: CKEDITOR$style): void;
    resetDirty(): void;
    resetUndo(): void;
    resize(
        width: number,
        height: number,
        isContentHeight?: boolean,
        resizeInner?: boolean): void;
    resize(
        width: string,
        height: number,
        isContentHeight?: boolean,
        resizeInner?: boolean): void;
    resize(
        width: number,
        height: string,
        isContentHeight?: boolean,
        resizeInner?: boolean): void;
    resize(
        width: string,
        height: string,
        isContentHeight?: boolean,
        resizeInner?: boolean): void;
    restoreRealElement(fakeElement: Object): dom$element;
    selectionChange(checkNow?: boolean): void;
    setActiveEnterMode(enterMode: number, shiftEnterMode: number): void;
    setActiveFilter(filter: htmlParser$filter): void;
    setData(
        data: string,
        options?: {
            internal?: boolean,
            callback?: Function,
            noSnapshot?: boolean
        }): void;
    setKeystroke(keystroke: number, behavior?: string): void;
    setKeystroke(keystroke: any[], behavior?: string): void;
    setKeystroke(keystroke: number, behavior?: boolean): void;
    setKeystroke(keystroke: any[], behavior?: boolean): void;
    setMode(newMode: string, callback: Function): void;
    setReadOnly(isReadOnly?: boolean): void;
    setUiColor(color: string): void;
    unlockSelection(restore?: boolean): void;
    updateElement(): void
}

declare interface editor$eventObject {
    activeEnterModeChange?: (evt: CKEDITOR$eventInfo) => void,
        activeFilterChange?: (evt: CKEDITOR$eventInfo) => void,
        afterCommandExec?: (evt: CKEDITOR$eventInfo) => void,
        afterInsertHtml?: (evt: CKEDITOR$eventInfo) => void,
        afterPaste?: (evt: CKEDITOR$eventInfo) => void,
        afterSetData?: (evt: CKEDITOR$eventInfo) => void,
        afterUndoImage?: (evt: CKEDITOR$eventInfo) => void,
        ariaEditorHelpLabel?: (evt: CKEDITOR$eventInfo) => void,
        ariaWidget?: (evt: CKEDITOR$eventInfo) => void,
        autogrow?: (evt: CKEDITOR$eventInfo) => void,
        beforeCommandExec?: (evt: CKEDITOR$eventInfo) => void,
        beforeGetData?: (evt: CKEDITOR$eventInfo) => void,
        beforeModuleUnload?: (evt: CKEDITOR$eventInfo) => void,
        beforeSetMode?: (evt: CKEDITOR$eventInfo) => void,
        blur?: (evt: CKEDITOR$eventInfo) => void,
        change?: (evt: CKEDITOR$eventInfo) => void,
        configLoaded?: (evt: CKEDITOR$eventInfo) => void,
        contentDirChanged?: (evt: CKEDITOR$eventInfo) => void,
        contentDom?: (evt: CKEDITOR$eventInfo) => void,
        contentDomInvalidated?: (evt: CKEDITOR$eventInfo) => void,
        contentDomUnload?: (evt: CKEDITOR$eventInfo) => void,
        customConfigLoaded?: (evt: CKEDITOR$eventInfo) => void,
        dataFiltered?: (evt: CKEDITOR$eventInfo) => void,
        dataReady?: (evt: CKEDITOR$eventInfo) => void,
        destroy?: (evt: CKEDITOR$eventInfo) => void,
        dialogHide?: (evt: CKEDITOR$eventInfo) => void,
        dialogShow?: (evt: CKEDITOR$eventInfo) => void,
        dirChanged?: (evt: CKEDITOR$eventInfo) => void,
        doubleckick?: (evt: CKEDITOR$eventInfo) => void,
        dragend?: (evt: CKEDITOR$eventInfo) => void,
        dragstart?: (evt: CKEDITOR$eventInfo) => void,
        drop?: (evt: CKEDITOR$eventInfo) => void,
        elementsPathUpdate?: (evt: CKEDITOR$eventInfo) => void,
        fileUploadRequest?: (evt: CKEDITOR$eventInfo) => void,
        fileUploadResponse?: (evt: CKEDITOR$eventInfo) => void,
        floatingSpaceLayout?: (evt: CKEDITOR$eventInfo) => void,
        focus?: (evt: CKEDITOR$eventInfo) => void,
        getData?: (evt: CKEDITOR$eventInfo) => void,
        getSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        insertElement?: (evt: CKEDITOR$eventInfo) => void,
        insertHtml?: (evt: CKEDITOR$eventInfo) => void,
        insertText?: (evt: CKEDITOR$eventInfo) => void,
        insanceReady?: (evt: CKEDITOR$eventInfo) => void,
        key?: (evt: CKEDITOR$eventInfo) => void,
        langLoaded?: (evt: CKEDITOR$eventInfo) => void,
        loadSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        loaded?: (evt: CKEDITOR$eventInfo) => void,
        lockSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        maximize?: (evt: CKEDITOR$eventInfo) => void,
        menuShow?: (evt: CKEDITOR$eventInfo) => void,
        mode?: (evt: CKEDITOR$eventInfo) => void,
        notificationHide?: (evt: CKEDITOR$eventInfo) => void,
        notificationShow?: (evt: CKEDITOR$eventInfo) => void,
        notificationUpdate?: (evt: CKEDITOR$eventInfo) => void,
        paste?: (evt: CKEDITOR$eventInfo) => void,
        pluginsLoaded?: (evt: CKEDITOR$eventInfo) => void,
        readOnly?: (evt: CKEDITOR$eventInfo) => void,
        removeFormatCleanup?: (evt: CKEDITOR$eventInfo) => void,
        required?: (evt: CKEDITOR$eventInfo) => void,
        resize?: (evt: CKEDITOR$eventInfo) => void,
        save?: (evt: CKEDITOR$eventInfo) => void,
        saveSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        selectionChange?: (evt: CKEDITOR$eventInfo) => void,
        setData?: (evt: CKEDITOR$eventInfo) => void,
        stylesSet?: (evt: CKEDITOR$eventInfo) => void,
        template?: (evt: CKEDITOR$eventInfo) => void,
        toDataFormat?: (evt: CKEDITOR$eventInfo) => void,
        toHtml?: (evt: CKEDITOR$eventInfo) => void,
        unlockSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        updateSnapshot?: (evt: CKEDITOR$eventInfo) => void,
        widgetDefinition?: (evt: CKEDITOR$eventInfo) => void
}

declare interface CKEDITOR$eventInfo {
    data: any,
        editor: CKEDITOR$editor,
        listenerData: any,
        name: string,
        sender: any,
        cancel(): void,
        removeListener(): void,
        stop(): void
}

declare class filter {}

declare interface CKEDITOR$buttonDefinition {
    label: string,
        command: string,
        toolbar: string
}

declare interface CKEDITOR$template {}

declare interface CKEDITOR$dataProcessor {
    toDataFormat(html: string, fixForBody: string): void,
        toHtml(data: string, fixForBody?: string): void
}

declare class htmlDataProcessor {
    dataFilter: htmlParser$filter;
    htmlFilter: htmlParser$filter;
    writer: htmlParser$basicWriter;
    constructor(editor: CKEDITOR$editor): this;
    toDataFormat(html: string, options?: Object): string;
    toHtml(data: string, options?: Object): string
}

declare class event {
    constructor(): this;
    useCapture: boolean;
    capture(): void;
    define(name: string, meta: Object): void;
    fire(eventName: string, data?: Object, editor?: CKEDITOR$editor): any;
    fireOnce(eventName: string, data?: Object, editor?: CKEDITOR$editor): any;
    hasListeners(eventName: string): boolean;
    on(
        eventName: string,
        listenerFunction: (eventInfo: CKEDITOR$eventInfo) => void,
        scopeObj?: Object,
        listenerData?: Object,
        priority?: number): void;
    once(
        eventName: string,
        listenerFunction: (eventInfo: CKEDITOR$eventInfo) => void,
        scopeObj?: Object,
        listenerData?: Object,
        priority?: number): void;
    removeAllListeners(): void;
    removeListener(
        eventName: string,
        listenerFunction: (eventInfo: CKEDITOR$eventInfo) => void): void;
    implementOn(targetObject: Object): void
}

declare interface CKEDITOR$commandDefinition {
    async?: boolean,
    canUndo?: boolean,
        context?: boolean,
        contextSensitive?: boolean,
        editorFocus?: boolean,
        modes?: Object,
        startDisabled?: boolean,
        exec(editor: CKEDITOR$editor, data?: Object): boolean,
        refresh(editor: CKEDITOR$editor, path: dom$elementPath): void
}

declare class dtd {}

declare class ui mixins event {
    constructor(editor: CKEDITOR$editor): this;
    add(name: string, type: Object, definition: Object): void;
    addButton(name: string, definition: CKEDITOR$buttonDefinition): void;
    addHandler(type: Object, handler: Object): void
}

declare class environmentConfig {
    air: boolean;
    chrome: boolean;
    cssClass: string;
    edge: boolean;
    gecko: boolean;
    hc: boolean;
    hidpi: boolean;
    iOS: boolean;
    ie: boolean;
    isCompatible: boolean;
    mac: boolean;
    needsBrFiller: boolean;
    needsNbspFiller: boolean;
    quirks: boolean;
    safari: boolean;
    version: number;
    webkit: boolean;
    secure(): boolean
}

declare class uiElement {
    eventProcessors: any;
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[], nodeNameArg?: Function | string, stylesArg?: Function | Object, attributesArg?: Function | Object, contentsArg?: Function | string): this;
    accessKeyDown(dialog: CKEDITOR$dialog, key: string): void;
    accessKeyUp(dialog: CKEDITOR$dialog, key: string): void;
    disable(): void;
    enable(): void;
    focus(): undefined.uiElement;
    getDialog(): CKEDITOR$dialog;
    getElement(): undefined.element;
    getInputElement(): undefined.element;
    getValue(): any;
    isChanged(): boolean;
    isEnabled(): boolean;
    isFocusable(): boolean;
    isVisible(): boolean;
    registerEvents(definition: undefined.uiElement): undefined.uiElement;
    selectParentTab(): undefined.uiElement;
    setValue(value: Object, noChangeEvent: boolean): undefined.uiElement
}

declare class button mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    accessKeyDown(): void;
    accessKeyUp(): void;
    click(): any
}

declare class checkbox mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    accessKeyUp(): void;
    getInputElement(): undefined.element;
    getValue(): boolean;
    setValue(checked: boolean, noChangeEvent: boolean): any
}

declare class fieldset mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, childObjList: any[], childHtmlList: any[], htmlList: any[], elementDefinition: undefined.uiElement): this
}

declare class file mixins undefined.labeledElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    getAction(): string;
    getInputElement(): undefined.element;
    registerEvents(definition: Object): undefined.file;
    reset(): void;
    setInitValue(): void;
    submit(): undefined.file
}

declare class fileButton mixins undefined.button {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this
}

declare class hbox mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, childObjList: any[], childHtmlList: any[], htmlList: any[], elementDefinition: undefined.uiElement): this;
    getChild(indices: number): undefined.uiElement;
    getChild(indices: number[]): undefined.uiElement[]
}

declare class html mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this
}

declare class iframeElement mixins uiElement {}

declare class labeledElement mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[], contentHtml: Function): this;
    getLabel(): string;
    setlabel(label: string): undefined.labeledElement
}

declare class radio mixins undefined.labeledElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    accessKeyUp(): void;
    getValue(): string;
    setValue(value: string, noChangeEvent: boolean): any
}

declare class select mixins uiElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    add(label: string, value?: string, indexedDB?: number): undefined.select;
    clear(): undefined.select;
    getInputElement(): undefined.element;
    remove(index: number): undefined.select
}

declare class textarea mixins undefined.labeledElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this
}

declare class textInput mixins undefined.labeledElement {
    constructor(dialog: CKEDITOR$dialog, elementDefinition: undefined.uiElement, htmlList: any[]): this;
    accessKeyUp(): void;
    focus(): any;
    getDirectionMarker(): string;
    getInputElement(): undefined.element;
    getValue(): string;
    select(): void;
    setDirectionMarker(dir: string): void;
    setValue(value: string, noChangeEvent: boolean): undefined.textInput
}

declare class dialog {
    state: number;
    constructor(editor: Object, dialogName: string): this;
    addFocusable(element: undefined.element, index?: number): void;
    addPage(contents: Object): void;
    click(id: string): Object;
    commitContent(): void;
    diableButton(id: string): void;
    enableButton(id: string): void;
    foreach(fn: Function): CKEDITOR$dialog;
    getButton(id: string): undefined.button;
    getContentElement(pageId: string, elementId: string): undefined.uiElement;
    getElement(): undefined.element;
    getName(): string;
    getPageCount(): number;
    getParentEditor(): CKEDITOR$editor;
    getPosition(): Object;
    getSelectedElement(): undefined.element;
    getSize(): Object;
    getValueOf(pageId: string, elementId: string): Object;
    hide(): void;
    hidePage(id: string): void;
    layout(): void;
    move(x: number, y: number, save: boolean): void;
    reset(): CKEDITOR$dialog;
    resize(width: number, height: number): void;
    selectPage(id: string): void;
    setState(state: number): void;
    setValueOf(pageId: string, elementId: string, value: Object): void;
    setupContent(): void;
    show(): void;
    showPage(id: string): void;
    updateStyle(): void
}


declare var npm$namespace$dialog: {
    add: typeof dialog$add,
    addIframe: typeof dialog$addIframe,
    addUIElement: typeof dialog$addUIElement,
    cancelButton: typeof dialog$cancelButton,
    exists: typeof dialog$exists,
    getCurrent: typeof dialog$getCurrent,
    isTabEnabled: typeof dialog$isTabEnabled,
    okButton: typeof dialog$okButton,
}
declare type definition$button = {
    disabled?: boolean,
    label?: string
} & dialog$uiElement


declare type definition$checkbox = {
    default?: string,
    label?: string,
    validate?: Function
} & dialog$uiElement


declare interface definition$content {
    accessKey?: string,
        elements?: undefined.uiElement[],
        id?: string,
        label?: string,
        title?: string
}

declare type definition$file = {
    action?: string,
    size?: string,
    validate?: Function
} & dialog$labeledElement


declare type definition$fileButton = {
    filebrowser?: string,
    for?: string,
    label?: string,
    styles?: string
} & dialog$uiElement


declare type definition$hbox = {
    children?: undefined.uiElement[],
    height?: number,
    padding?: number,
    validate?: Function,
    widths?: number[]
} & dialog$uiElement


declare type definition$html = {
    html?: string
} & dialog$uiElement


declare type definition$labeledElement = {
    controlStyle?: string,
    inputStyle?: string,
    label?: string,
    labelLayout?: string,
    labelStyle?: string,
    widths?: number[]
} & dialog$uiElement


declare type definition$radio = {
    default?: string,
    items?: string[] | (string[])[],
    validate?: Function
} & definition$labeledElement


declare type definition$select = {
    default?: string,
    items?: string[] | (string[])[],
    multiple?: boolean,
    size?: number,
    validate?: Function
} & definition$labeledElement


declare type definition$textarea = {
    bidi?: boolean,
    cols?: number,
    default?: string,
    rows?: number,
    validate?: Function
} & definition$labeledElement


declare type definition$textInput = {
    bidi?: boolean,
    default?: string,
    maxLength?: number,
    size?: number,
    validate?: Function
} & definition$labeledElement


declare interface definition$uiElement {
    align?: string,
        className?: string,
        commit?: (widget: undefined.widget) => void,
        id?: string,
        onHide?: (elem: undefined.uiElement) => void,
        onLoad?: (elem: undefined.uiElement) => void,
        onShow?: (elem: undefined.uiElement) => void,
        requiredcontent?: string | Object | CKEDITOR$style,
        setup?: (widget: undefined.widget) => void,
        style?: string,
        title?: string,
        type?: string
}

declare type definition$vbox = {
    children?: undefined.uiElement[],
    expand?: boolean,
    heights?: number[],
    padding?: number,
    styles?: string,
    width?: number[]
} & definition$uiElement


declare interface dialog$IDialogDefinition {
    buttons?: undefined.button[],
        contents?: undefined.content[],
        height?: number,
        minHeight?: number,
        minWidth?: number,
        onCancel?: Function,
        onLoad?: Function,
        onOk?: Function,
        onShow?: Function,
        resizable?: number,
        title?: string,
        width?: number
}

declare function dialog$add(editor: CKEDITOR$editor): void

declare function dialog$addIframe(
    name: string,
    title: string,
    minWidth: number,
    minHeight: number,
    onContentLoad?: Function,
    userDefinition?: Object): void

declare function dialog$addUIElement(typeName: string, builder: Function): void

declare function dialog$cancelButton(): void

declare function dialog$exists(name: string | number): void

declare function dialog$getCurrent(): void

declare function dialog$isTabEnabled(editor: CKEDITOR$editor, dialogName: string, tabName: string): boolean

declare function dialog$okButton(): void

declare class basicWriter {
    constructor(): this;
    openTag(tagName: string, attributes: Object): void;
    openTagClose(tagName: string, isSelfClose: boolean): void;
    attribute(attName: string, attValue: string): void;
    closeTag(tagName: string): void;
    text(text: string): void;
    comment(comment: string): void;
    write(data: string): void;
    reset(): void;
    getHtml(reset: boolean): string
}

declare class node {
    constructor(): this;
    remove(preserveChildren?: boolean): htmlParser$node;
    replaceWith(node: htmlParser$node): void;
    insertAfter(node: htmlParser$node): void;
    insertBefore(node: htmlParser$node): void;
    getAscendant(condition: string): dom$element;
    getAscendant(condition: Object): dom$element;
    getAscendant(condition: Function): dom$element;
    wrapWith(wrapper: dom$element): dom$element;
    getIndex(): number
}

declare class filter {
    constructor(rules?: htmlParser$filterRulesDefinition): this;
    id: number;
    elementNameRules: htmlParser$filterRulesGroup;
    attributeNameRules: htmlParser$filterRulesGroup;
    elementsRules: any;
    attributesRules: any;
    textRules: htmlParser$filterRulesGroup;
    commentRules: htmlParser$filterRulesGroup;
    rootRules: htmlParser$filterRulesGroup;
    addRules(rules: htmlParser$filterRulesDefinition, options?: number): void;
    addRules(
        rules: htmlParser$filterRulesDefinition,
        options?: {
            priority?: number,
            applyToAll?: boolean
        }): void;
    applyTo(node: htmlParser$node): void
}

declare interface htmlParser$filterRulesDefinition {}

declare class filterRulesGroup {
    rules: Object[];
    add(rule: Function, priority: number, options: Object): void;
    add(rule: Object[], priority: number, options: Object): void;
    addMany(rules: Object[], priority: number, options: Object): void;
    findIndex(priority: number): number;
    exec(currentValue: Object): any;
    execOnName(currentName: string): string
}

declare class cdata mixins node {
    constructor(value: string): this;
    type: number;
    writeHtml(writer: htmlParser$basicWriter): void
}

declare class comment mixins node {
    constructor(value: string): this;
    type: number;
    filter(filter: htmlParser$filter): boolean;
    writeHtml(writer: htmlParser$basicWriter, filter: htmlParser$filter): void
}

declare class element mixins node {
    constructor(name: string, attributes: Object): this;
    name: string;
    attributes: any;
    children: any[];
    type: number;
    add(node: htmlParser$node): number;
    clone(): htmlParser$element;
    filter(filter: htmlParser$filter): boolean;
    filterChildren(filter: htmlParser$filter): void;
    writeHtml(writer: htmlParser$basicWriter, filter: htmlParser$filter): void;
    writeChildrenHtml(writer: htmlParser$basicWriter, filter: htmlParser$filter): void;
    replaceWithChildren(): void;
    forEach(callback: (node: htmlParser$node, type?: number) => boolean): void;
    getFirst(condition: string): htmlParser$node;
    getFirst(condition: Object): htmlParser$node;
    getFirst(condition: Function): htmlParser$node;
    getHtml(): string;
    setHtml(html: string): void;
    getOuterHtml(): string;
    split(index: number): htmlParser$element;
    removeClass(className: string): void;
    hasClass(className: string): boolean
}

declare class fragment {
    constructor(): this;
    children: any[];
    parent: any;
    type: number;
    fromHtml(fragmentHtml: string, parent?: htmlParser$element, fixingBlock?: string): void;
    fromHtml(fragmentHtml: string, parent?: string, fixingBlock?: string): void;
    fromHtml(fragmentHtml: string, parent?: htmlParser$element, fixingBlock?: boolean): void;
    fromHtml(fragmentHtml: string, parent?: string, fixingBlock?: boolean): void;
    add(node: htmlParser$node, index?: number): void;
    filter(filter: htmlParser$filter): void;
    filterChildren(filter: htmlParser$filter, filterRoot?: boolean): void;
    writeHtml(writer: htmlParser$basicWriter, filter?: htmlParser$filter): void;
    writeChildrenHtml(
        writer: htmlParser$basicWriter,
        filter?: htmlParser$filter,
        filterRoot?: boolean): void;
    forEach(
        callback: (node: htmlParser$node, type?: number) => boolean,
        type?: number,
        skipRoot?: boolean): void
}

declare class cssStyle {
    constructor(element: htmlParser$element): this;
    constructor(styleText: string): this;
    populate(obj: htmlParser$element): void;
    populate(obj: dom$element): void;
    populate(obj: Object): void
}

declare class text mixins node {
    constructor(value: string): this;
    type: number;
    filter(filter: htmlParser$filter): boolean;
    writeHtml(writer: htmlParser$basicWriter, filter?: htmlParser$filter): void
}

declare class htmlWriter mixins htmlParser$basicWriter {
    indentationChars: string;
    lineBreakChars: string;
    selfClosingEnd: string;
    indentation(): void;
    lineBreak(): void;
    setRules(tagName: string, rules: Object): void
}


declare var npm$namespace$tools: {
    enableHtml5Elements: typeof tools$enableHtml5Elements,
}
declare var callFunction: Function;

declare function tools$enableHtml5Elements(doc: Object, withAppend?: Boolean): void


declare var npm$namespace$lang: {
    load: typeof lang$load,
    detect: typeof lang$detect,
}
declare var languages: any;

declare var rtl: any;

declare function lang$load(url: string, callback?: Function): string

declare function lang$detect(defaultLanguage: string, probeLanguage: string): string