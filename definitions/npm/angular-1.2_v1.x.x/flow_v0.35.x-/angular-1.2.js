/**
 * Flowtype definitions for angular-1.2
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
var angular: ng$IAngularStatic;
declare interface Function {
    $inject?: string[]
}
declare interface ng$IServiceProviderClass {
    new(...args: any[]): ng$IServiceProvider
}

declare interface ng$IServiceProviderFactory {
    (...args: any[]): ng$IServiceProvider
}

declare interface ng$IServiceProvider {
    $get: any
}

declare interface ng$IAngularStatic {
    bind(context: any, fn: Function, ...args: any[]): Function,
        bootstrap(element: string, modules?: any[]): auto.IInjectorService,
        bootstrap(element: JQuery, modules?: any[]): auto.IInjectorService,
        bootstrap(element: Element, modules?: any[]): auto.IInjectorService,
        bootstrap(element: Document, modules?: any[]): auto.IInjectorService,
        copy(source: any, destination?: any): any,
        element: ng$IAugmentedJQueryStatic,
        equals(value1: any, value2: any): boolean,
        extend(destination: any, ...sources: any[]): any,

        /**
         * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
         * 
        It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
         * @param obj Object to iterate over.
         * @param iterator Iterator function.
         * @param context Object to become context (this) for the iterator function.
        */
        forEach<T>(obj: T[], iterator: (value: T, key: number) => any, context?: any): any,

        /**
         * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
         * 
        It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
         * @param obj Object to iterate over.
         * @param iterator Iterator function.
         * @param context Object to become context (this) for the iterator function.
        */
        forEach<T>(
            obj: {
                [index: string]: T
            },
            iterator: (value: T, key: string) => any,
            context?: any): any,

        /**
         * Invokes the iterator function once for each item in obj collection, which can be either an object or an array. The iterator function is invoked with iterator(value, key), where value is the value of an object property or an array element and key is the object property key or array element index. Specifying a context for the function is optional.
         * 
        It is worth noting that .forEach does not iterate over inherited properties because it filters using the hasOwnProperty method.
         * @param obj Object to iterate over.
         * @param iterator Iterator function.
         * @param context Object to become context (this) for the iterator function.
        */
        forEach(obj: any, iterator: (value: any, key: any) => any, context?: any): any,
        fromJson(json: string): any,
        identity(arg?: any): any,
        injector(modules?: any[]): auto.IInjectorService,
        isArray(value: any): boolean,
        isDate(value: any): boolean,
        isDefined(value: any): boolean,
        isElement(value: any): boolean,
        isFunction(value: any): boolean,
        isNumber(value: any): boolean,
        isObject(value: any): boolean,
        isString(value: any): boolean,
        isUndefined(value: any): boolean,
        lowercase(str: string): string,

        /**
         * The angular.module is a global place for creating, registering and retrieving Angular modules. All modules (angular core or 3rd party) that should be available to an application must be registered using this mechanism.
         * 
        When passed two or more arguments, a new module is created. If passed only one argument, an existing module (the name passed as the first argument to module) is retrieved.
         * @param name The name of the module to create or retrieve.
         * @param requires The names of modules this module depends on. If specified then new module is being created. If unspecified then the module is being retrieved for further configuration.
         * @param configFn Optional configuration function for the module.
        */
        module(name: string, requires?: string[], configFn?: Function): ng$IModule,
        noop(...args: any[]): void,
        toJson(obj: any, pretty?: boolean): string,
        uppercase(str: string): string,
        version: {
            full: string,
            major: number,
            minor: number,
            dot: number,
            codename: string
        }
}

declare interface ng$IModule {
    animation(name: string, animationFactory: Function): ng$IModule,
        animation(name: string, inlineAnnotatedFunction: any[]): ng$IModule,
        animation(object: Object): ng$IModule,

        /**
         * Use this method to register work which needs to be performed on module loading.
         * @param configFn Execute this function on module load. Useful for service configuration.
         */
        config(configFn: Function): ng$IModule,

        /**
         * Use this method to register work which needs to be performed on module loading.
         * @param inlineAnnotatedFunction Execute this function on module load. Useful for service configuration.
         */
        config(inlineAnnotatedFunction: any[]): ng$IModule,

        /**
         * Register a constant service, such as a string, a number, an array, an object or a function, with the $injector. Unlike value it can be injected into a module configuration function (see config) and it cannot be overridden by an Angular decorator.
         * @param name The name of the constant.
         * @param value The constant value.
         */
        constant(name: string, value: any): ng$IModule,
        constant(object: Object): ng$IModule,

        /**
         * The $controller service is used by Angular to create new controllers.
         * 
        This provider allows controller registration via the register method.
         * @param name Controller name, or an object map of controllers where the keys are the names and the values are the constructors.
         * @param controllerConstructor Controller constructor fn (optionally decorated with DI annotations in the array notation).
        */
        controller(name: string, controllerConstructor: Function): ng$IModule,

        /**
         * The $controller service is used by Angular to create new controllers.
         * 
        This provider allows controller registration via the register method.
         * @param name Controller name, or an object map of controllers where the keys are the names and the values are the constructors.
         * @param controllerConstructor Controller constructor fn (optionally decorated with DI annotations in the array notation).
        */
        controller(name: string, inlineAnnotatedConstructor: any[]): ng$IModule,
        controller(object: Object): ng$IModule,
        directive(name: string, directiveFactory: ng$IDirectiveFactory): ng$IModule,
        directive(name: string, inlineAnnotatedFunction: any[]): ng$IModule,
        directive(object: Object): ng$IModule,

        /**
         * Register a service factory, which will be called to return the service instance. This is short for registering a service where its provider consists of only a $get property, which is the given service factory function. You should use $provide.factory(getFn) if you do not need to configure your service in a provider.
         * @param name The name of the instance.
         * @param $getFn The $getFn for the instance creation. Internally this is a short hand for $provide.provider(name, {$get: $getFn}).
         */
        factory(name: string, $getFn: Function): ng$IModule,

        /**
         * Register a service factory, which will be called to return the service instance. This is short for registering a service where its provider consists of only a $get property, which is the given service factory function. You should use $provide.factory(getFn) if you do not need to configure your service in a provider.
         * @param name The name of the instance.
         * @param inlineAnnotatedFunction The $getFn for the instance creation. Internally this is a short hand for $provide.provider(name, {$get: $getFn}).
         */
        factory(name: string, inlineAnnotatedFunction: any[]): ng$IModule,
        factory(object: Object): ng$IModule,
        filter(name: string, filterFactoryFunction: Function): ng$IModule,
        filter(name: string, inlineAnnotatedFunction: any[]): ng$IModule,
        filter(object: Object): ng$IModule,
        provider(name: string, serviceProviderFactory: ng$IServiceProviderFactory): ng$IModule,
        provider(name: string, serviceProviderConstructor: ng$IServiceProviderClass): ng$IModule,
        provider(name: string, inlineAnnotatedConstructor: any[]): ng$IModule,
        provider(name: string, providerObject: ng$IServiceProvider): ng$IModule,
        provider(object: Object): ng$IModule,

        /**
         * Run blocks are the closest thing in Angular to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the service have been configured and the injector has been created. Run blocks typically contain code which is hard to unit-test, and for this reason should be declared in isolated modules, so that they can be ignored in the unit-tests.
         */
        run(initializationFunction: Function): ng$IModule,

        /**
         * Run blocks are the closest thing in Angular to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the service have been configured and the injector has been created. Run blocks typically contain code which is hard to unit-test, and for this reason should be declared in isolated modules, so that they can be ignored in the unit-tests.
         */
        run(inlineAnnotatedFunction: any[]): ng$IModule,
        service(name: string, serviceConstructor: Function): ng$IModule,
        service(name: string, inlineAnnotatedConstructor: any[]): ng$IModule,
        service(object: Object): ng$IModule,

        /**
         * Register a value service with the $injector, such as a string, a number, an array, an object or a function. This is short for registering a service where its provider's $get property is a factory function that takes no arguments and returns the value service.
         * 
        Value services are similar to constant services, except that they cannot be injected into a module configuration function (see config) but they can be overridden by an Angular decorator.
         * @param name The name of the instance.
         * @param value The value.
        */
        value(name: string, value: any): ng$IModule,
        value(object: Object): ng$IModule,
        name: string,
        requires: string[]
}

declare interface ng$IAttributes {
    [name: string]: any,
    $addClass(classVal: string): void,
        $removeClass(classVal: string): void,
        $set(key: string, value: any): void,
        $observe(name: string, fn: (value?: any) => any): Function,
        $attr: Object
}


/**
 * form.FormController - type in module ng
 * see https://docs.angularjs.org/api/ng/type/form.FormController
 */
declare interface ng$IFormController {
    [name: string]: any,
    $pristine: boolean,
        $dirty: boolean,
        $valid: boolean,
        $invalid: boolean,
        $error: any,
        $addControl(control: ng$INgModelController): void,
        $removeControl(control: ng$INgModelController): void,
        $setValidity(
            validationErrorKey: string,
            isValid: boolean,
            control: ng$INgModelController): void,
        $setDirty(): void,
        $setPristine(): void
}

declare interface ng$INgModelController {
    $render(): void,
        $setValidity(validationErrorKey: string, isValid: boolean): void,
        $setViewValue(value: any): void,
        $viewValue: any,
        $modelValue: any,
        $parsers: ng$IModelParser[],
        $formatters: ng$IModelFormatter[],
        $viewChangeListeners: ng$IModelViewChangeListener[],
        $error: any,
        $pristine: boolean,
        $dirty: boolean,
        $valid: boolean,
        $invalid: boolean
}

declare interface ng$IModelParser {
    (value: any): any
}

declare interface ng$IModelFormatter {
    (value: any): any
}

declare interface ng$IModelViewChangeListener {
    (): void
}

declare interface ng$IRootScopeService {
    $apply(): any,
        $apply(exp: string): any,
        $apply(exp: (scope: ng$IScope) => any): any,
        $broadcast(name: string, ...args: any[]): ng$IAngularEvent,
        $destroy(): void,
        $digest(): void,
        $emit(name: string, ...args: any[]): ng$IAngularEvent,
        $eval(expression: string, args?: Object): any,
        $eval(expression: (scope: ng$IScope) => any, args?: Object): any,
        $evalAsync(expression: string): void,
        $evalAsync(expression: (scope: ng$IScope) => any): void,
        $new(isolate?: boolean): ng$IScope,
        $on(
            name: string,
            listener: (event: ng$IAngularEvent, ...args: any[]) => any): Function,
        $watch(watchExpression: string, listener?: string, objectEquality?: boolean): Function,
        $watch(
            watchExpression: string,
            listener?: (newValue: any, oldValue: any, scope: ng$IScope) => any,
            objectEquality?: boolean): Function,
        $watch(
            watchExpression: (scope: ng$IScope) => any,
            listener?: string,
            objectEquality?: boolean): Function,
        $watch(
            watchExpression: (scope: ng$IScope) => any,
            listener?: (newValue: any, oldValue: any, scope: ng$IScope) => any,
            objectEquality?: boolean): Function,
        $watchCollection(
            watchExpression: string,
            listener: (newValue: any, oldValue: any, scope: ng$IScope) => any): Function,
        $watchCollection(
            watchExpression: (scope: ng$IScope) => any,
            listener: (newValue: any, oldValue: any, scope: ng$IScope) => any): Function,
        $watchGroup(
            watchExpressions: any[],
            listener: (newValue: any, oldValue: any, scope: ng$IScope) => any): Function,
        $watchGroup(
            watchExpressions: {
                (scope: ng$IScope): any
            }[],
            listener: (newValue: any, oldValue: any, scope: ng$IScope) => any): Function,
        $parent: ng$IScope,
        $root: ng$IRootScopeService,
        this: ng$IRootScopeService,
        $id: string,
        $$isolateBindings: any,
        $$phase: any
}

declare type ng$IScope = {
    [index: string]: any
} & ng$IRootScopeService


declare interface ng$IAngularEvent {
    targetScope: ng$IScope,
        currentScope: ng$IScope,
        name: string,
        preventDefault: Function,
        defaultPrevented: boolean,
        stopPropagation?: Function
}

declare type ng$IWindowService = {
    [key: string]: any
} & Window


declare interface ng$IBrowserService {
    [key: string]: any
}

declare interface ng$ITimeoutService {
    (func: Function, delay?: number, invokeApply?: boolean): ng$IPromise<any>,
        cancel(promise: ng$IPromise<any>): boolean
}

declare interface ng$IIntervalService {
    (func: Function, delay: number, count?: number, invokeApply?: boolean): ng$IPromise<any>,
        cancel(promise: ng$IPromise<any>): boolean
}


/**
 * The animation object which contains callback functions for each event that is expected to be animated.
 */
declare interface ng$IAnimateCallbackObject {
    eventFn(element: Node, doneFn: () => void): Function
}

declare interface ng$IFilterService {
    (name: string): Function
}

declare type ng$IFilterProvider = {
    register(name: string, filterFactory: Function): ng$IServiceProvider
} & ng$IServiceProvider


declare interface ng$ILocaleService {
    id: string,
        NUMBER_FORMATS: ng$ILocaleNumberFormatDescriptor,
        DATETIME_FORMATS: ng$ILocaleDateTimeFormatDescriptor,
        pluralCat: (num: any) => string
}

declare interface ng$ILocaleNumberFormatDescriptor {
    DECIMAL_SEP: string,
        GROUP_SEP: string,
        PATTERNS: ng$ILocaleNumberPatternDescriptor[],
        CURRENCY_SYM: string
}

declare interface ng$ILocaleNumberPatternDescriptor {
    minInt: number,
        minFrac: number,
        maxFrac: number,
        posPre: string,
        posSuf: string,
        negPre: string,
        negSuf: string,
        gSize: number,
        lgSize: number
}

declare interface ng$ILocaleDateTimeFormatDescriptor {
    MONTH: string[],
        SHORTMONTH: string[],
        DAY: string[],
        SHORTDAY: string[],
        AMPMS: string[],
        medium: string,
        short: string,
        fullDate: string,
        longDate: string,
        mediumDate: string,
        shortDate: string,
        mediumTime: string,
        shortTime: string
}

declare interface ng$ILogService {
    debug: ng$ILogCall,
        error: ng$ILogCall,
        info: ng$ILogCall,
        log: ng$ILogCall,
        warn: ng$ILogCall
}

declare interface ng$ILogProvider {
    debugEnabled(enabled: boolean): ng$ILogProvider,
        debugEnabled(): boolean
}

declare interface ng$ILogCall {
    (...args: any[]): void
}

declare interface ng$IParseService {
    (expression: string): ng$ICompiledExpression
}

declare interface ng$IParseProvider {
    logPromiseWarnings(): boolean,
        logPromiseWarnings(value: boolean): ng$IParseProvider,
        unwrapPromises(): boolean,
        unwrapPromises(value: boolean): ng$IParseProvider
}

declare interface ng$ICompiledExpression {
    (context: any, locals?: any): any,
    assign(context: any, value: any): any
}

declare interface ng$ILocationService {
    absUrl(): string,
        hash(): string,
        hash(newHash: string): ng$ILocationService,
        host(): string,
        path(): string,
        path(newPath: string): ng$ILocationService,
        port(): number,
        protocol(): string,
        replace(): ng$ILocationService,
        search(): any,
        search(parametersMap: any): ng$ILocationService,
        search(parameter: string, parameterValue: any): ng$ILocationService,
        url(): string,
        url(url: string): ng$ILocationService
}

declare type ng$ILocationProvider = {
    hashPrefix(): string,
    hashPrefix(prefix: string): ng$ILocationProvider,
    html5Mode(): boolean,
    html5Mode(active: boolean): ng$ILocationProvider
} & ng$IServiceProvider


declare type ng$IDocumentService = {} & ng$IAugmentedJQuery


declare interface ng$IExceptionHandlerService {
    (exception: Error, cause?: string): void
}

declare type ng$IRootElementService = {} & JQuery



/**
 * $q - service in module ng
 * A promise/deferred implementation inspired by Kris Kowal's Q.
See http://docs.angularjs.org/api/ng/service/$q
*/
declare interface ng$IQService {

    /**
     * Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.
     * 
    Returns a single promise that will be resolved with an array/hash of values, each value corresponding to the promise at the same index/key in the promises array/hash. If any of the promises is resolved with a rejection, this resulting promise will be rejected with the same rejection value.
     * @param promises An array or hash of promises.
    */
    all(promises: ng$IPromise<any>[]): ng$IPromise<any[]>,

        /**
         * Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.
         * 
        Returns a single promise that will be resolved with an array/hash of values, each value corresponding to the promise at the same index/key in the promises array/hash. If any of the promises is resolved with a rejection, this resulting promise will be rejected with the same rejection value.
         * @param promises An array or hash of promises.
        */
        all(
            promises: {
                [id: string]: ng$IPromise<any >
            }): ng$IPromise<{
            [id: string]: any
        }>,

        /**
         * Creates a Deferred object which represents a task which will finish in the future.
         */
        defer<T>(): ng$IDeferred<T>,

        /**
         * Creates a promise that is resolved as rejected with the specified reason. This api should be used to forward rejection in a chain of promises. If you are dealing with the last promise in a promise chain, you don't need to worry about it.
         * 
        When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of reject as the throw keyword in JavaScript. This also means that if you "catch" an error via a promise error callback and you want to forward the error to the promise derived from the current promise, you have to "rethrow" the error by returning a rejection constructed via reject.
         * @param reason Constant, message, exception or an object representing the rejection reason.
        */
        reject(reason?: any): ng$IPromise<void>,

        /**
         * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
         * @param value Value or a promise
         */
        when<T>(value: ng$IPromise<T>): ng$IPromise<T>,

        /**
         * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
         * @param value Value or a promise
         */
        when<T>(value: T): ng$IPromise<T>,

        /**
         * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise. This is useful when you are dealing with an object that might or might not be a promise, or if the promise comes from a source that can't be trusted.
         * @param value Value or a promise
         */
        when(): ng$IPromise<void >
}

declare interface ng$IPromise<T>{
    then<TResult>(
        successCallback: (promiseValue: T) => ng$IHttpPromise<TResult>,
        errorCallback?: (reason: any) => any,
        notifyCallback?: (state: any) => any): ng$IPromise<TResult>,
    then<TResult>(
        successCallback: (promiseValue: T) => ng$IPromise<TResult>,
        errorCallback?: (reason: any) => any,
        notifyCallback?: (state: any) => any): ng$IPromise<TResult>,
    then<TResult>(
        successCallback: (promiseValue: T) => TResult,
        errorCallback?: (reason: any) => TResult,
        notifyCallback?: (state: any) => any): ng$IPromise<TResult>,
    catch<TResult>(
        onRejected: (reason: any) => ng$IHttpPromise<TResult>): ng$IPromise<TResult>,
    catch<TResult>(
        onRejected: (reason: any) => ng$IPromise<TResult>): ng$IPromise<TResult>,
    catch<TResult>(onRejected: (reason: any) => TResult): ng$IPromise<TResult>,
    finally<TResult>(finallyCallback: () => any): ng$IPromise<TResult >
}

declare interface ng$IDeferred<T>{
    resolve(value?: T): void,
    reject(reason?: any): void,
    notify(state?: any): void,
    promise: ng$IPromise<T >
}

declare interface ng$IAnchorScrollService {
    (): void
}

declare type ng$IAnchorScrollProvider = {
    disableAutoScrolling(): void
} & ng$IServiceProvider


declare interface ng$ICacheFactoryService {
    (cacheId: string, optionsMap?: {
        capacity: number
    }): ng$ICacheObject,
    info(): any,
        get(cacheId: string): ng$ICacheObject
}

declare interface ng$ICacheObject {
    info(): {
            id: string,
            size: number
        },
        put(key: string, value?: any): void,
        get(key: string): any,
        remove(key: string): void,
        removeAll(): void,
        destroy(): void
}

declare interface ng$ICompileService {
    (element: string, transclude?: ng$ITranscludeFunction, maxPriority?: number): ng$ITemplateLinkingFunction,
    (element: Element, transclude?: ng$ITranscludeFunction, maxPriority?: number): ng$ITemplateLinkingFunction,
    (element: JQuery, transclude?: ng$ITranscludeFunction, maxPriority?: number): ng$ITemplateLinkingFunction
}

declare type ng$ICompileProvider = {
    directive(name: string, directiveFactory: Function): ng$ICompileProvider,
    directive(directivesMap: any): ng$ICompileProvider,
    aHrefSanitizationWhitelist(): RegExp,
    aHrefSanitizationWhitelist(regexp: RegExp): ng$ICompileProvider,
    imgSrcSanitizationWhitelist(): RegExp,
    imgSrcSanitizationWhitelist(regexp: RegExp): ng$ICompileProvider
} & ng$IServiceProvider


declare interface ng$ICloneAttachFunction {
    (clonedElement?: JQuery, scope?: ng$IScope): any
}

declare interface ng$ITemplateLinkingFunction {
    (scope: ng$IScope, cloneAttachFn?: ng$ICloneAttachFunction): ng$IAugmentedJQuery
}

declare interface ng$ITranscludeFunction {
    (scope: ng$IScope, cloneAttachFn: ng$ICloneAttachFunction): ng$IAugmentedJQuery,
    (cloneAttachFn?: ng$ICloneAttachFunction): ng$IAugmentedJQuery
}

declare interface ng$IControllerService {
    (controllerConstructor: Function, locals?: any): any,
    (controllerName: string, locals?: any): any
}

declare type ng$IControllerProvider = {
    register(name: string, controllerConstructor: Function): void,
    register(name: string, dependencyAnnotatedConstructor: any[]): void
} & ng$IServiceProvider



/**
 * HttpService
 * see http://docs.angularjs.org/api/ng/service/$http
 */
declare interface ng$IHttpService {

    /**
     * Object describing the request to be made and how it should be processed.
     */
    (config: ng$IRequestConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform GET request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param config Optional configuration object
         */
        get<T>(url: string, config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform DELETE request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param config Optional configuration object
         */
        delete<T>(url: string, config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform HEAD request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param config Optional configuration object
         */
        head<T>(url: string, config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform JSONP request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param config Optional configuration object
         */
        jsonp<T>(url: string, config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform POST request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param data Request content
         * @param config Optional configuration object
         */
        post<T>(
            url: string,
            data: any,
            config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Shortcut method to perform PUT request.
         * @param url Relative or absolute URL specifying the destination of the request
         * @param data Request content
         * @param config Optional configuration object
         */
        put<T>(
            url: string,
            data: any,
            config?: ng$IRequestShortcutConfig): ng$IHttpPromise<T>,

        /**
         * Runtime equivalent of the $httpProvider.defaults property. Allows configuration of default headers, withCredentials as well as request and response transformations.
         */
        defaults: ng$IRequestConfig,

        /**
         * Array of config objects for currently pending requests. This is primarily meant to be used for debugging purposes.
         */
        pendingRequests: any[]
}


/**
 * Object describing the request to be made and how it should be processed.
 * see http://docs.angularjs.org/api/ng/service/$http#usage
 */
declare interface ng$IRequestShortcutConfig {

    /**
     * {Object.<string|Object>}
     * Map of strings or objects which will be turned to ?key1=value1&key2=value2 after the url. If the value is not a string, it will be JSONified.
     */
    params?: any,

        /**
         * Map of strings or functions which return strings representing HTTP headers to send to the server. If the return value of a function is null, the header will not be sent.
         */
        headers?: any,

        /**
         * Name of HTTP header to populate with the XSRF token.
         */
        xsrfHeaderName?: string,

        /**
         * Name of cookie containing the XSRF token.
         */
        xsrfCookieName?: string,

        /**
         * {boolean|Cache}
         * If true, a default $http cache will be used to cache the GET request, otherwise if a cache instance built with $cacheFactory, this cache will be used for caching.
         */
        cache?: any,

        /**
         * whether to to set the withCredentials flag on the XHR object. See [requests with credentials]https://developer.mozilla.org/en/http_access_control#section_5 for more information.
         */
        withCredentials?: boolean,

        /**
         * {string|Object}
         * Data to be sent as the request message data.
         */
        data?: any,

        /**
         * {function(data, headersGetter)|Array.<function(data, headersGetter)>}
         * Transform function or an array of such functions. The transform function takes the http request body and headers and returns its transformed (typically serialized) version.
         */
        transformRequest?: any,

        /**
         * {function(data, headersGetter)|Array.<function(data, headersGetter)>}
         * Transform function or an array of such functions. The transform function takes the http response body and headers and returns its transformed (typically deserialized) version.
         */
        transformResponse?: any,

        /**
         * {number|Promise}
         * Timeout in milliseconds, or promise that should abort the request when resolved.
         */
        timeout?: any,

        /**
         * See requestType.
         */
        responseType?: string
}


/**
 * Object describing the request to be made and how it should be processed.
 * see http://docs.angularjs.org/api/ng/service/$http#usage
 */
declare type ng$IRequestConfig = {

    /**
     * HTTP method (e.g. 'GET', 'POST', etc)
     */
    method: string,

    /**
     * Absolute or relative URL of the resource that is being requested.
     */
    url: string
} & ng$IRequestShortcutConfig


declare interface ng$IHttpPromiseCallback<T>{
    (data: T, status: number, headers: (headerName: string) => string, config: ng$IRequestConfig): void
}

declare interface ng$IHttpPromiseCallbackArg<T>{
    data?: T,
    status?: number,
    headers?: (headerName: string) => string,
    config?: ng$IRequestConfig,
    statusText?: string
}

declare type ng$IHttpPromise<T>= {
    success(callback: ng$IHttpPromiseCallback<T>): ng$IHttpPromise<T>,
    error(callback: ng$IHttpPromiseCallback<any>): ng$IHttpPromise<T>,
    then<TResult>(
        successCallback: (response: ng$IHttpPromiseCallbackArg<T>) => ng$IPromise<TResult>,
        errorCallback?: (response: ng$IHttpPromiseCallbackArg<any>) => any): ng$IPromise<TResult>,
    then<TResult>(
        successCallback: (response: ng$IHttpPromiseCallbackArg<T>) => TResult,
        errorCallback?: (response: ng$IHttpPromiseCallbackArg<any>) => any): ng$IPromise<TResult >
} & ng$IPromise


declare type ng$IHttpProvider = {
    defaults: ng$IRequestConfig,
    interceptors: any[],
    responseInterceptors: any[]
} & ng$IServiceProvider


declare interface ng$IHttpBackendService {
    (method: string, url: string, post?: any, callback?: Function, headers?: any, timeout?: number, withCredentials?: boolean): void
}

declare interface ng$IInterpolateService {
    (text: string, mustHaveExpression?: boolean): ng$IInterpolationFunction,
    endSymbol(): string,
        startSymbol(): string
}

declare interface ng$IInterpolationFunction {
    (context: any): string
}

declare type ng$IInterpolateProvider = {
    startSymbol(): string,
    startSymbol(value: string): ng$IInterpolateProvider,
    endSymbol(): string,
    endSymbol(value: string): ng$IInterpolateProvider
} & ng$IServiceProvider


declare type ng$ITemplateCacheService = {} & ng$ICacheObject


declare interface ng$ISCEService {
    getTrusted(type: string, mayBeTrusted: any): any,
        getTrustedCss(value: any): any,
        getTrustedHtml(value: any): any,
        getTrustedJs(value: any): any,
        getTrustedResourceUrl(value: any): any,
        getTrustedUrl(value: any): any,
        parse(type: string, expression: string): (context: any, locals: any) => any,
        parseAsCss(expression: string): (context: any, locals: any) => any,
        parseAsHtml(expression: string): (context: any, locals: any) => any,
        parseAsJs(expression: string): (context: any, locals: any) => any,
        parseAsResourceUrl(expression: string): (context: any, locals: any) => any,
        parseAsUrl(expression: string): (context: any, locals: any) => any,
        trustAs(type: string, value: any): any,
        trustAsHtml(value: any): any,
        trustAsJs(value: any): any,
        trustAsResourceUrl(value: any): any,
        trustAsUrl(value: any): any,
        isEnabled(): boolean
}

declare type ng$ISCEProvider = {
    enabled(value: boolean): void
} & ng$IServiceProvider


declare interface ng$ISCEDelegateService {
    getTrusted(type: string, mayBeTrusted: any): any,
        trustAs(type: string, value: any): any,
        valueOf(value: any): any
}

declare type ng$ISCEDelegateProvider = {
    resourceUrlBlacklist(blacklist: any[]): void,
    resourceUrlWhitelist(whitelist: any[]): void
} & ng$IServiceProvider


declare interface ng$IDirectiveFactory {
    (...args: any[]): ng$IDirective
}

declare interface ng$IDirectiveLinkFn {
    (scope: ng$IScope, instanceElement: ng$IAugmentedJQuery, instanceAttributes: ng$IAttributes, controller: any, transclude: ng$ITranscludeFunction): void
}

declare interface ng$IDirectivePrePost {
    pre?: ng$IDirectiveLinkFn,
        post?: ng$IDirectiveLinkFn
}

declare interface ng$IDirectiveCompileFn {
    (templateElement: ng$IAugmentedJQuery, templateAttributes: ng$IAttributes, transclude: ng$ITranscludeFunction): ng$IDirectivePrePost
}

declare interface ng$IDirective {
    compile?: ng$IDirectiveCompileFn,
        controller?: any,
        controllerAs?: string,
        link?: ng$IDirectiveLinkFn,
        name?: string,
        priority?: number,
        replace?: boolean,
        require?: any,
        restrict?: string,
        scope?: any,
        template?: any,
        templateUrl?: any,
        terminal?: boolean,
        transclude?: any
}

declare type ng$IAugmentedJQueryStatic = {
    (selector: string, context?: any): ng$IAugmentedJQuery,
    (element: Element): ng$IAugmentedJQuery,
    (object: {}): ng$IAugmentedJQuery,
    (elementArray: Element[]): ng$IAugmentedJQuery,
    (object: JQuery): ng$IAugmentedJQuery,
    (func: Function): ng$IAugmentedJQuery,
    (array: any[]): ng$IAugmentedJQuery,
    (): ng$IAugmentedJQuery
} & JQueryStatic


declare type ng$IAugmentedJQuery = {
    find(selector: string): ng$IAugmentedJQuery,
    find(element: any): ng$IAugmentedJQuery,
    find(obj: JQuery): ng$IAugmentedJQuery,
    controller(name: string): any,
    injector(): any,
    scope(): ng$IScope,
    isolateScope(): ng$IScope,
    inheritedData(key: string, value: any): JQuery,
    inheritedData(obj: {
        [key: string]: any
    }): JQuery,
    inheritedData(key?: string): any
} & JQuery


declare interface ng$IAnimateService {
    addClass(element: JQuery, className: string, done?: Function): void,
        enter(element: JQuery, parent: JQuery, after: JQuery, done?: Function): void,
        leave(element: JQuery, done?: Function): void,
        move(element: JQuery, parent: JQuery, after: JQuery, done?: Function): void,
        removeClass(element: JQuery, className: string, done?: Function): void
}

declare module 'auto' {
    declare interface IInjectorService {
        annotate(fn: Function): string[],
            annotate(inlineAnnotatedFunction: any[]): string[],
            get(name: string): any,
            has(name: string): boolean,
            instantiate(typeConstructor: Function, locals?: any): any,
            invoke(inlineAnnotatedFunction: any[]): any,
            invoke(func: Function, context?: any, locals?: any): any
    }
    declare interface IProvideService {

        /**
         * Register a constant service, such as a string, a number, an array, an object or a function, with the $injector. Unlike value it can be injected into a module configuration function (see config) and it cannot be overridden by an Angular decorator.
         * @param name The name of the constant.
         * @param value The constant value.
         */
        constant(name: string, value: any): void,

            /**
             * Register a service decorator with the $injector. A service decorator intercepts the creation of a service, allowing it to override or modify the behaviour of the service. The object returned by the decorator may be the original service, or a new service object which replaces or wraps and delegates to the original service.
             * @param name The name of the service to decorate.
             * @param decorator This function will be invoked when the service needs to be instantiated and should return the decorated service instance. The function is called using the injector.invoke method and is therefore fully injectable. Local injection arguments:

            $delegate - The original service instance, which can be monkey patched, configured, decorated or delegated to.
            */
            decorator(name: string, decorator: Function): void,

            /**
             * Register a service decorator with the $injector. A service decorator intercepts the creation of a service, allowing it to override or modify the behaviour of the service. The object returned by the decorator may be the original service, or a new service object which replaces or wraps and delegates to the original service.
             * @param name The name of the service to decorate.
             * @param inlineAnnotatedFunction This function will be invoked when the service needs to be instantiated and should return the decorated service instance. The function is called using the injector.invoke method and is therefore fully injectable. Local injection arguments:

            $delegate - The original service instance, which can be monkey patched, configured, decorated or delegated to.
            */
            decorator(name: string, inlineAnnotatedFunction: any[]): void,
            factory(name: string, serviceFactoryFunction: Function): ng$IServiceProvider,
            factory(name: string, inlineAnnotatedFunction: any[]): ng$IServiceProvider,
            provider(name: string, provider: ng$IServiceProvider): ng$IServiceProvider,
            provider(name: string, serviceProviderConstructor: Function): ng$IServiceProvider,
            service(name: string, constructor: Function): ng$IServiceProvider,
            value(name: string, value: any): ng$IServiceProvider
    }
}