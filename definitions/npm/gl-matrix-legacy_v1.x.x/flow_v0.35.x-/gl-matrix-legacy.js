/**
 * Flowtype definitions for gl-matrix-legacy
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface GLM$IArray {
    [index: number]: number
}
declare var npm$namespace$glMatrix: {
        toRadian: typeof glMatrix$toRadian,
    }
    /**
     * Convert Degree To Radian
     * @param a Angle in Degrees
     */
declare export function glMatrix$toRadian(a: number): number
declare var npm$namespace$vec2: {
        create: typeof vec2$create,
        clone: typeof vec2$clone,
        fromValues: typeof vec2$fromValues,
        copy: typeof vec2$copy,
        set: typeof vec2$set,
        add: typeof vec2$add,
        subtract: typeof vec2$subtract,
        sub: typeof vec2$sub,
        multiply: typeof vec2$multiply,
        mul: typeof vec2$mul,
        divide: typeof vec2$divide,
        div: typeof vec2$div,
        min: typeof vec2$min,
        max: typeof vec2$max,
        scale: typeof vec2$scale,
        scaleAndAdd: typeof vec2$scaleAndAdd,
        distance: typeof vec2$distance,
        dist: typeof vec2$dist,
        squaredDistance: typeof vec2$squaredDistance,
        sqrDist: typeof vec2$sqrDist,
        length: typeof vec2$length,
        len: typeof vec2$len,
        squaredLength: typeof vec2$squaredLength,
        sqrLen: typeof vec2$sqrLen,
        negate: typeof vec2$negate,
        inverse: typeof vec2$inverse,
        normalize: typeof vec2$normalize,
        dot: typeof vec2$dot,
        cross: typeof vec2$cross,
        lerp: typeof vec2$lerp,
        random: typeof vec2$random,
        transformMat2: typeof vec2$transformMat2,
        transformMat2d: typeof vec2$transformMat2d,
        transformMat3: typeof vec2$transformMat3,
        transformMat4: typeof vec2$transformMat4,
        forEach: typeof vec2$forEach,
        str: typeof vec2$str,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function vec2$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function vec2$clone(a: GLM$IArray): GLM$IArray


/**
 * Creates a new vec2 initialized with the given values
 * @param x X component
 * @param y Y component
 * @returns  a new 2D vector
 */
declare export function vec2$fromValues(x: number, y: number): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function vec2$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set the components of a vec2 to the given values
 * @param out the receiving vector
 * @param x X component
 * @param y Y component
 * @returns  out
 */
declare export function vec2$set(out: GLM$IArray, x: number, y: number): GLM$IArray


/**
 * Adds two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$add(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$subtract(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$sub(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$divide(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$div(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the minimum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$min(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the maximum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$max(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function vec2$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Adds two vec2's after scaling the second operand by a scalar value
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param scale the amount to scale b by before adding
 * @returns  out
 */
declare export function vec2$scaleAndAdd(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, scale: number): GLM$IArray


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec2$distance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec2$dist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec2$squaredDistance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec2$sqrDist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec2$length(a: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec2$len(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec2$squaredLength(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec2$sqrLen(a: GLM$IArray): number


/**
 * Negates the components of a vec2
 * @param out the receiving vector
 * @param a vector to negate
 * @returns  out
 */
declare export function vec2$negate(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Returns the inverse of the components of a vec2
 * @param out the receiving vector
 * @param a vector to invert
 * @returns  out
 */
declare export function vec2$inverse(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Normalize a vec2
 * @param out the receiving vector
 * @param a vector to normalize
 * @returns  out
 */
declare export function vec2$normalize(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the dot product of two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  dot product of a and b
 */
declare export function vec2$dot(a: GLM$IArray, b: GLM$IArray): number


/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec2$cross(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Performs a linear interpolation between two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param t interpolation amount between the two inputs
 * @returns  out
 */
declare export function vec2$lerp(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, t: number): GLM$IArray


/**
 * Generates a random unit vector
 * @param out the receiving vector
 * @returns  out
 */
declare export function vec2$random(out: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat2
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
 */
declare export function vec2$transformMat2(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat2d
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
 */
declare export function vec2$transformMat2d(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
 */
declare export function vec2$transformMat3(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
4th vector component is implicitly '1'
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
*/
declare export function vec2$transformMat4(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Perform some operation over an array of vec2s.
 * @param a the array of vectors to iterate over
 * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param offset Number of elements to skip at the beginning of the array
 * @param count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param fn Function to call for each vector in the array
 * @param arg additional argument to pass to fn
 * @returns  a
 */
declare export function vec2$forEach(
    a: GLM$IArray,
    stride: number,
    offset: number,
    count: number,
    fn: (a: GLM$IArray, b: GLM$IArray, arg: any) => void,
    arg: any): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function vec2$str(a: GLM$IArray): string
declare var npm$namespace$vec3: {
        create: typeof vec3$create,
        clone: typeof vec3$clone,
        fromValues: typeof vec3$fromValues,
        copy: typeof vec3$copy,
        set: typeof vec3$set,
        add: typeof vec3$add,
        subtract: typeof vec3$subtract,
        sub: typeof vec3$sub,
        multiply: typeof vec3$multiply,
        mul: typeof vec3$mul,
        divide: typeof vec3$divide,
        div: typeof vec3$div,
        min: typeof vec3$min,
        max: typeof vec3$max,
        scale: typeof vec3$scale,
        scaleAndAdd: typeof vec3$scaleAndAdd,
        distance: typeof vec3$distance,
        dist: typeof vec3$dist,
        squaredDistance: typeof vec3$squaredDistance,
        sqrDist: typeof vec3$sqrDist,
        length: typeof vec3$length,
        len: typeof vec3$len,
        squaredLength: typeof vec3$squaredLength,
        sqrLen: typeof vec3$sqrLen,
        negate: typeof vec3$negate,
        inverse: typeof vec3$inverse,
        normalize: typeof vec3$normalize,
        dot: typeof vec3$dot,
        cross: typeof vec3$cross,
        lerp: typeof vec3$lerp,
        random: typeof vec3$random,
        rotateX: typeof vec3$rotateX,
        rotateY: typeof vec3$rotateY,
        rotateZ: typeof vec3$rotateZ,
        transformMat3: typeof vec3$transformMat3,
        transformMat4: typeof vec3$transformMat4,
        transformQuat: typeof vec3$transformQuat,
        forEach: typeof vec3$forEach,
        angle: typeof vec3$angle,
        str: typeof vec3$str,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function vec3$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function vec3$clone(a: GLM$IArray): GLM$IArray


/**
 * Creates a new vec2 initialized with the given values
 * @param x X component
 * @param y Y component
 * @returns  a new 2D vector
 */
declare export function vec3$fromValues(x: number, y: number): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function vec3$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set the components of a vec2 to the given values
 * @param out the receiving vector
 * @param x X component
 * @param y Y component
 * @returns  out
 */
declare export function vec3$set(out: GLM$IArray, x: number, y: number): GLM$IArray


/**
 * Adds two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$add(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$subtract(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$sub(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$divide(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$div(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the minimum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$min(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the maximum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$max(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function vec3$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Adds two vec2's after scaling the second operand by a scalar value
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param scale the amount to scale b by before adding
 * @returns  out
 */
declare export function vec3$scaleAndAdd(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, scale: number): GLM$IArray


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec3$distance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec3$dist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec3$squaredDistance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec3$sqrDist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec3$length(a: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec3$len(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec3$squaredLength(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec3$sqrLen(a: GLM$IArray): number


/**
 * Negates the components of a vec2
 * @param out the receiving vector
 * @param a vector to negate
 * @returns  out
 */
declare export function vec3$negate(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Returns the inverse of the components of a vec2
 * @param out the receiving vector
 * @param a vector to invert
 * @returns  out
 */
declare export function vec3$inverse(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Normalize a vec2
 * @param out the receiving vector
 * @param a vector to normalize
 * @returns  out
 */
declare export function vec3$normalize(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the dot product of two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  dot product of a and b
 */
declare export function vec3$dot(a: GLM$IArray, b: GLM$IArray): number


/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec3$cross(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Performs a linear interpolation between two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param t interpolation amount between the two inputs
 * @returns  out
 */
declare export function vec3$lerp(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, t: number): GLM$IArray


/**
 * Generates a random unit vector
 * @param out the receiving vector
 * @returns  out
 */
declare export function vec3$random(out: GLM$IArray): GLM$IArray


/**
 * Rotate a 3D vector around the x-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function vec3$rotateX(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the y-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function vec3$rotateY(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the z-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function vec3$rotateZ(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
 */
declare export function vec3$transformMat3(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
4th vector component is implicitly '1'
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
*/
declare export function vec3$transformMat4(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec3 with a quat
 * @param out the receiving vector
 * @param a the vector to transform
 * @param q quaternion to transform with
 * @returns  out
 */
declare export function vec3$transformQuat(out: GLM$IArray, a: GLM$IArray, q: GLM$IArray): GLM$IArray


/**
 * Perform some operation over an array of vec2s.
 * @param a the array of vectors to iterate over
 * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param offset Number of elements to skip at the beginning of the array
 * @param count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param fn Function to call for each vector in the array
 * @param arg additional argument to pass to fn
 * @returns  a
 */
declare export function vec3$forEach(
    a: GLM$IArray,
    stride: number,
    offset: number,
    count: number,
    fn: (a: GLM$IArray, b: GLM$IArray, arg: any) => void,
    arg: any): GLM$IArray


/**
 * Get the angle between two 3D vectors
 * @param a The first operand
 * @param b The second operand
 * @returns  The angle in radians
 */
declare export function vec3$angle(a: GLM$IArray, b: GLM$IArray): number


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function vec3$str(a: GLM$IArray): string
declare var npm$namespace$vec4: {
        create: typeof vec4$create,
        clone: typeof vec4$clone,
        fromValues: typeof vec4$fromValues,
        copy: typeof vec4$copy,
        set: typeof vec4$set,
        add: typeof vec4$add,
        subtract: typeof vec4$subtract,
        sub: typeof vec4$sub,
        multiply: typeof vec4$multiply,
        mul: typeof vec4$mul,
        divide: typeof vec4$divide,
        div: typeof vec4$div,
        min: typeof vec4$min,
        max: typeof vec4$max,
        scale: typeof vec4$scale,
        scaleAndAdd: typeof vec4$scaleAndAdd,
        distance: typeof vec4$distance,
        dist: typeof vec4$dist,
        squaredDistance: typeof vec4$squaredDistance,
        sqrDist: typeof vec4$sqrDist,
        length: typeof vec4$length,
        len: typeof vec4$len,
        squaredLength: typeof vec4$squaredLength,
        sqrLen: typeof vec4$sqrLen,
        negate: typeof vec4$negate,
        inverse: typeof vec4$inverse,
        normalize: typeof vec4$normalize,
        dot: typeof vec4$dot,
        lerp: typeof vec4$lerp,
        random: typeof vec4$random,
        transformMat4: typeof vec4$transformMat4,
        transformQuat: typeof vec4$transformQuat,
        forEach: typeof vec4$forEach,
        str: typeof vec4$str,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function vec4$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function vec4$clone(a: GLM$IArray): GLM$IArray


/**
 * Creates a new vec2 initialized with the given values
 * @param x X component
 * @param y Y component
 * @returns  a new 2D vector
 */
declare export function vec4$fromValues(x: number, y: number): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function vec4$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set the components of a vec2 to the given values
 * @param out the receiving vector
 * @param x X component
 * @param y Y component
 * @returns  out
 */
declare export function vec4$set(out: GLM$IArray, x: number, y: number): GLM$IArray


/**
 * Adds two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$add(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$subtract(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Subtracts vector b from vector a
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$sub(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$divide(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Divides two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$div(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the minimum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$min(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns the maximum of two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function vec4$max(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function vec4$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Adds two vec2's after scaling the second operand by a scalar value
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param scale the amount to scale b by before adding
 * @returns  out
 */
declare export function vec4$scaleAndAdd(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, scale: number): GLM$IArray


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec4$distance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  distance between a and b
 */
declare export function vec4$dist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec4$squaredDistance(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the squared euclidian distance between two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  squared distance between a and b
 */
declare export function vec4$sqrDist(a: GLM$IArray, b: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec4$length(a: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function vec4$len(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec4$squaredLength(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function vec4$sqrLen(a: GLM$IArray): number


/**
 * Negates the components of a vec2
 * @param out the receiving vector
 * @param a vector to negate
 * @returns  out
 */
declare export function vec4$negate(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Returns the inverse of the components of a vec2
 * @param out the receiving vector
 * @param a vector to invert
 * @returns  out
 */
declare export function vec4$inverse(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Normalize a vec2
 * @param out the receiving vector
 * @param a vector to normalize
 * @returns  out
 */
declare export function vec4$normalize(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the dot product of two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  dot product of a and b
 */
declare export function vec4$dot(a: GLM$IArray, b: GLM$IArray): number


/**
 * Performs a linear interpolation between two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param t interpolation amount between the two inputs
 * @returns  out
 */
declare export function vec4$lerp(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, t: number): GLM$IArray


/**
 * Generates a random unit vector
 * @param out the receiving vector
 * @returns  out
 */
declare export function vec4$random(out: GLM$IArray): GLM$IArray


/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
4th vector component is implicitly '1'
 * @param out the receiving vector
 * @param a the vector to transform
 * @param m matrix to transform with
 * @returns  out
*/
declare export function vec4$transformMat4(out: GLM$IArray, a: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Transforms the vec3 with a quat
 * @param out the receiving vector
 * @param a the vector to transform
 * @param q quaternion to transform with
 * @returns  out
 */
declare export function vec4$transformQuat(out: GLM$IArray, a: GLM$IArray, q: GLM$IArray): GLM$IArray


/**
 * Perform some operation over an array of vec2s.
 * @param a the array of vectors to iterate over
 * @param stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param offset Number of elements to skip at the beginning of the array
 * @param count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param fn Function to call for each vector in the array
 * @param arg additional argument to pass to fn
 * @returns  a
 */
declare export function vec4$forEach(
    a: GLM$IArray,
    stride: number,
    offset: number,
    count: number,
    fn: (a: GLM$IArray, b: GLM$IArray, arg: any) => void,
    arg: any): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function vec4$str(a: GLM$IArray): string
declare var npm$namespace$mat2: {
        create: typeof mat2$create,
        clone: typeof mat2$clone,
        copy: typeof mat2$copy,
        identity: typeof mat2$identity,
        transpose: typeof mat2$transpose,
        invert: typeof mat2$invert,
        adjoint: typeof mat2$adjoint,
        determinant: typeof mat2$determinant,
        multiply: typeof mat2$multiply,
        mul: typeof mat2$mul,
        rotate: typeof mat2$rotate,
        scale: typeof mat2$scale,
        str: typeof mat2$str,
        frob: typeof mat2$frob,
        LDU: typeof mat2$LDU,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function mat2$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function mat2$clone(a: GLM$IArray): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function mat2$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set a mat2 to the identity matrix
 * @param out the receiving matrix
 * @returns  out
 */
declare export function mat2$identity(out: GLM$IArray): GLM$IArray


/**
 * Transpose the values of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat2$transpose(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Inverts a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat2$invert(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the adjugate of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat2$adjoint(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the determinant of a mat2
 * @param a the source matrix
 * @returns  determinant of a
 */
declare export function mat2$determinant(a: GLM$IArray): number


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat2$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat2$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Rotates a mat2 by the given angle
 * @param out the receiving matrix
 * @param a the matrix to rotate
 * @param rad the angle to rotate the matrix by
 * @returns  out
 */
declare export function mat2$rotate(out: GLM$IArray, a: GLM$IArray, rad: number): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function mat2$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function mat2$str(a: GLM$IArray): string


/**
 * Returns Frobenius norm of a mat2
 * @param a the matrix to calculate Frobenius norm of
 * @returns  Frobenius norm
 */
declare export function mat2$frob(a: GLM$IArray): number


/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param L the lower triangular matrix
 * @param D the diagonal matrix
 * @param U the upper triangular matrix
 * @param a the input matrix to factorize
 */
declare export function mat2$LDU(L: GLM$IArray, D: GLM$IArray, U: GLM$IArray, a: GLM$IArray): GLM$IArray
declare var npm$namespace$mat2d: {
        create: typeof mat2d$create,
        clone: typeof mat2d$clone,
        copy: typeof mat2d$copy,
        identity: typeof mat2d$identity,
        invert: typeof mat2d$invert,
        determinant: typeof mat2d$determinant,
        multiply: typeof mat2d$multiply,
        mul: typeof mat2d$mul,
        rotate: typeof mat2d$rotate,
        scale: typeof mat2d$scale,
        translate: typeof mat2d$translate,
        str: typeof mat2d$str,
        frob: typeof mat2d$frob,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function mat2d$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function mat2d$clone(a: GLM$IArray): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function mat2d$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set a mat2 to the identity matrix
 * @param out the receiving matrix
 * @returns  out
 */
declare export function mat2d$identity(out: GLM$IArray): GLM$IArray


/**
 * Inverts a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat2d$invert(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the determinant of a mat2
 * @param a the source matrix
 * @returns  determinant of a
 */
declare export function mat2d$determinant(a: GLM$IArray): number


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat2d$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat2d$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Rotates a mat2 by the given angle
 * @param out the receiving matrix
 * @param a the matrix to rotate
 * @param rad the angle to rotate the matrix by
 * @returns  out
 */
declare export function mat2d$rotate(out: GLM$IArray, a: GLM$IArray, rad: number): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function mat2d$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Translates the mat2d by the dimensions in the given vec2
 * @param out the receiving matrix
 * @param a the matrix to translate
 * @param v the vec2 to translate the matrix by
 * @returns  out
 */
declare export function mat2d$translate(out: GLM$IArray, a: GLM$IArray, v: GLM$IArray): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function mat2d$str(a: GLM$IArray): string


/**
 * Returns Frobenius norm of a mat2
 * @param a the matrix to calculate Frobenius norm of
 * @returns  Frobenius norm
 */
declare export function mat2d$frob(a: GLM$IArray): number
declare var npm$namespace$mat3: {
        create: typeof mat3$create,
        clone: typeof mat3$clone,
        copy: typeof mat3$copy,
        identity: typeof mat3$identity,
        transpose: typeof mat3$transpose,
        invert: typeof mat3$invert,
        adjoint: typeof mat3$adjoint,
        determinant: typeof mat3$determinant,
        multiply: typeof mat3$multiply,
        mul: typeof mat3$mul,
        str: typeof mat3$str,
        frob: typeof mat3$frob,
        normalFromMat4: typeof mat3$normalFromMat4,
        fromQuat: typeof mat3$fromQuat,
        fromMat4: typeof mat3$fromMat4,
        scale: typeof mat3$scale,
        fromMat2d: typeof mat3$fromMat2d,
        translate: typeof mat3$translate,
        rotate: typeof mat3$rotate,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function mat3$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function mat3$clone(a: GLM$IArray): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function mat3$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set a mat2 to the identity matrix
 * @param out the receiving matrix
 * @returns  out
 */
declare export function mat3$identity(out: GLM$IArray): GLM$IArray


/**
 * Transpose the values of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat3$transpose(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Inverts a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat3$invert(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the adjugate of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat3$adjoint(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the determinant of a mat2
 * @param a the source matrix
 * @returns  determinant of a
 */
declare export function mat3$determinant(a: GLM$IArray): number


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat3$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat3$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function mat3$str(a: GLM$IArray): string


/**
 * Returns Frobenius norm of a mat2
 * @param a the matrix to calculate Frobenius norm of
 * @returns  Frobenius norm
 */
declare export function mat3$frob(a: GLM$IArray): number


/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 * @param out mat3 receiving operation result
 * @param a Mat4 to derive the normal matrix from
 * @returns  out
 */
declare export function mat3$normalFromMat4(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates a 3x3 matrix from the given quaternion
 * @param out mat3 receiving operation result
 * @param q Quaternion to create matrix from
 * @returns  out
 */
declare export function mat3$fromQuat(out: GLM$IArray, q: GLM$IArray): GLM$IArray


/**
 * Copies the upper-left 3x3 values into the given mat3.
 * @param out the receiving 3x3 matrix
 * @param a the source 4x4 matrix
 * @returns  out
 */
declare export function mat3$fromMat4(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function mat3$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Copies the values from a mat2d into a mat3
 * @param out the receiving matrix
 * @param  the matrix to copy
 * @returns  out
 */
declare export function mat3$fromMat2d(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Translates the mat2d by the dimensions in the given vec2
 * @param out the receiving matrix
 * @param a the matrix to translate
 * @param v the vec2 to translate the matrix by
 * @returns  out
 */
declare export function mat3$translate(out: GLM$IArray, a: GLM$IArray, v: GLM$IArray): GLM$IArray


/**
 * Rotates a mat2 by the given angle
 * @param out the receiving matrix
 * @param a the matrix to rotate
 * @param rad the angle to rotate the matrix by
 * @returns  out
 */
declare export function mat3$rotate(out: GLM$IArray, a: GLM$IArray, rad: number): GLM$IArray
declare var npm$namespace$mat4: {
        create: typeof mat4$create,
        clone: typeof mat4$clone,
        copy: typeof mat4$copy,
        identity: typeof mat4$identity,
        transpose: typeof mat4$transpose,
        invert: typeof mat4$invert,
        adjoint: typeof mat4$adjoint,
        determinant: typeof mat4$determinant,
        multiply: typeof mat4$multiply,
        mul: typeof mat4$mul,
        translate: typeof mat4$translate,
        scale: typeof mat4$scale,
        rotate: typeof mat4$rotate,
        rotateX: typeof mat4$rotateX,
        rotateY: typeof mat4$rotateY,
        rotateZ: typeof mat4$rotateZ,
        frustum: typeof mat4$frustum,
        perspective: typeof mat4$perspective,
        ortho: typeof mat4$ortho,
        lookAt: typeof mat4$lookAt,
        str: typeof mat4$str,
        frob: typeof mat4$frob,
        fromRotationTranslation: typeof mat4$fromRotationTranslation,
        fromRotationTranslationScale: typeof mat4$fromRotationTranslationScale,
        fromQuat: typeof mat4$fromQuat,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function mat4$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function mat4$clone(a: GLM$IArray): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function mat4$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set a mat2 to the identity matrix
 * @param out the receiving matrix
 * @returns  out
 */
declare export function mat4$identity(out: GLM$IArray): GLM$IArray


/**
 * Transpose the values of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat4$transpose(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Inverts a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat4$invert(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the adjugate of a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function mat4$adjoint(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the determinant of a mat2
 * @param a the source matrix
 * @returns  determinant of a
 */
declare export function mat4$determinant(a: GLM$IArray): number


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat4$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function mat4$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Translates the mat2d by the dimensions in the given vec2
 * @param out the receiving matrix
 * @param a the matrix to translate
 * @param v the vec2 to translate the matrix by
 * @returns  out
 */
declare export function mat4$translate(out: GLM$IArray, a: GLM$IArray, v: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function mat4$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Rotates a mat2 by the given angle
 * @param out the receiving matrix
 * @param a the matrix to rotate
 * @param rad the angle to rotate the matrix by
 * @returns  out
 */
declare export function mat4$rotate(out: GLM$IArray, a: GLM$IArray, rad: number): GLM$IArray


/**
 * Rotate a 3D vector around the x-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function mat4$rotateX(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the y-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function mat4$rotateY(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the z-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function mat4$rotateZ(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Generates a frustum matrix with the given bounds
 * @param out mat4 frustum matrix will be written into
 * @param left Left bound of the frustum
 * @param right Right bound of the frustum
 * @param bottom Bottom bound of the frustum
 * @param top Top bound of the frustum
 * @param near Near bound of the frustum
 * @param far Far bound of the frustum
 * @returns  out
 */
declare export function mat4$frustum(
    out: GLM$IArray,
    left: number,
    right: number,
    bottom: number,
    top: number,
    near: number,
    far: number): GLM$IArray


/**
 * Generates a perspective projection matrix with the given bounds
 * @param out mat4 frustum matrix will be written into
 * @param fovy Vertical field of view in radians
 * @param aspect Aspect ratio. typically viewport width/height
 * @param near Near bound of the frustum
 * @param far Far bound of the frustum
 * @returns  out
 */
declare export function mat4$perspective(
    out: GLM$IArray,
    fovy: number,
    aspect: number,
    near: number,
    far: number): GLM$IArray


/**
 * Generates a orthogonal projection matrix with the given bounds
 * @param out mat4 frustum matrix will be written into
 * @param left Left bound of the frustum
 * @param right Right bound of the frustum
 * @param bottom Bottom bound of the frustum
 * @param top Top bound of the frustum
 * @param near Near bound of the frustum
 * @param far Far bound of the frustum
 * @returns  out
 */
declare export function mat4$ortho(
    out: GLM$IArray,
    left: number,
    right: number,
    bottom: number,
    top: number,
    near: number,
    far: number): GLM$IArray


/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 * @param out mat4 frustum matrix will be written into
 * @param eye Position of the viewer
 * @param center Point the viewer is looking at
 * @param up vec3 pointing up
 * @returns  out
 */
declare export function mat4$lookAt(
    out: GLM$IArray,
    eye: GLM$IArray,
    center: GLM$IArray,
    up: GLM$IArray): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function mat4$str(a: GLM$IArray): string


/**
 * Returns Frobenius norm of a mat2
 * @param a the matrix to calculate Frobenius norm of
 * @returns  Frobenius norm
 */
declare export function mat4$frob(a: GLM$IArray): number


/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):

     mat4.identity(dest);
     mat4.translate(dest, vec);
     var quatMat = mat4.create();
     quat4.toMat4(quat, quatMat);
     mat4.multiply(dest, quatMat);
 * @param out mat4 receiving operation result
 * @param q Rotation quaternion
 * @param v Translation vector
 * @returns  out
*/
declare export function mat4$fromRotationTranslation(out: GLM$IArray, q: GLM$IArray, v: GLM$IArray): GLM$IArray


/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale.
 * 
This is equivalent to (but much faster than):

     mat4.identity(dest); 
     mat4.translate(dest, vec); 
     var quatMat = mat4.create(); 
     quat4.toMat4(quat, quatMat); 
     mat4.multiply(dest, quatMat); 
     mat4.scale(dest, scale)
 * @param out mat4 receiving operation result
 * @param q Rotation quaternion
 * @param v Translation vector
 * @param s Scale vector
 * @returns  out
*/
declare export function mat4$fromRotationTranslationScale(out: GLM$IArray, q: GLM$IArray, v: GLM$IArray, s: GLM$IArray): GLM$IArray


/**
 * Calculates a 3x3 matrix from the given quaternion
 * @param out mat3 receiving operation result
 * @param q Quaternion to create matrix from
 * @returns  out
 */
declare export function mat4$fromQuat(out: GLM$IArray, q: GLM$IArray): GLM$IArray
declare var npm$namespace$quat: {
        create: typeof quat$create,
        clone: typeof quat$clone,
        fromValues: typeof quat$fromValues,
        copy: typeof quat$copy,
        set: typeof quat$set,
        identity: typeof quat$identity,
        setAxisAngle: typeof quat$setAxisAngle,
        add: typeof quat$add,
        multiply: typeof quat$multiply,
        mul: typeof quat$mul,
        scale: typeof quat$scale,
        length: typeof quat$length,
        len: typeof quat$len,
        squaredLength: typeof quat$squaredLength,
        sqrLen: typeof quat$sqrLen,
        normalize: typeof quat$normalize,
        dot: typeof quat$dot,
        lerp: typeof quat$lerp,
        slerp: typeof quat$slerp,
        invert: typeof quat$invert,
        conjugate: typeof quat$conjugate,
        str: typeof quat$str,
        rotateX: typeof quat$rotateX,
        rotateY: typeof quat$rotateY,
        rotateZ: typeof quat$rotateZ,
        fromMat3: typeof quat$fromMat3,
        setAxes: typeof quat$setAxes,
        rotationTo: typeof quat$rotationTo,
        calculateW: typeof quat$calculateW,
    }
    /**
     * Creates a new, empty vec2
     * @returns  a new 2D vector
     */
declare export function quat$create(): GLM$IArray


/**
 * Creates a new vec2 initialized with values from an existing vector
 * @param a a vector to clone
 * @returns  a new 2D vector
 */
declare export function quat$clone(a: GLM$IArray): GLM$IArray


/**
 * Creates a new vec2 initialized with the given values
 * @param x X component
 * @param y Y component
 * @returns  a new 2D vector
 */
declare export function quat$fromValues(x: number, y: number): GLM$IArray


/**
 * Copy the values from one vec2 to another
 * @param out the receiving vector
 * @param a the source vector
 * @returns  out
 */
declare export function quat$copy(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Set the components of a vec2 to the given values
 * @param out the receiving vector
 * @param x X component
 * @param y Y component
 * @returns  out
 */
declare export function quat$set(out: GLM$IArray, x: number, y: number): GLM$IArray


/**
 * Set a mat2 to the identity matrix
 * @param out the receiving matrix
 * @returns  out
 */
declare export function quat$identity(out: GLM$IArray): GLM$IArray


/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 * @param out the receiving quaternion
 * @param axis the axis around which to rotate
 * @param rad the angle in radians
 * @returns  out
 */
declare export function quat$setAxisAngle(out: GLM$IArray, axis: GLM$IArray, rad: number): GLM$IArray


/**
 * Adds two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function quat$add(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function quat$multiply(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Multiplies two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @returns  out
 */
declare export function quat$mul(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Scales a vec2 by a scalar number
 * @param out the receiving vector
 * @param a the vector to scale
 * @param b amount to scale the vector by
 * @returns  out
 */
declare export function quat$scale(out: GLM$IArray, a: GLM$IArray, b: number): GLM$IArray


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function quat$length(a: GLM$IArray): number


/**
 * Calculates the length of a vec2
 * @param a vector to calculate length of
 * @returns  length of a
 */
declare export function quat$len(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function quat$squaredLength(a: GLM$IArray): number


/**
 * Calculates the squared length of a vec2
 * @param a vector to calculate squared length of
 * @returns  squared length of a
 */
declare export function quat$sqrLen(a: GLM$IArray): number


/**
 * Normalize a vec2
 * @param out the receiving vector
 * @param a vector to normalize
 * @returns  out
 */
declare export function quat$normalize(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the dot product of two vec2's
 * @param a the first operand
 * @param b the second operand
 * @returns  dot product of a and b
 */
declare export function quat$dot(a: GLM$IArray, b: GLM$IArray): number


/**
 * Performs a linear interpolation between two vec2's
 * @param out the receiving vector
 * @param a the first operand
 * @param b the second operand
 * @param t interpolation amount between the two inputs
 * @returns  out
 */
declare export function quat$lerp(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, t: number): GLM$IArray


/**
 * Performs a spherical linear interpolation between two quat
 * @param out the receiving quaternion
 * @param a the first operand
 * @param b the second operand
 * @param t interpolation amount between the two inputs
 * @returns  out
 */
declare export function quat$slerp(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, t: number): GLM$IArray


/**
 * Inverts a mat2
 * @param out the receiving matrix
 * @param a the source matrix
 * @returns  out
 */
declare export function quat$invert(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 * @param out the receiving quaternion
 * @param a quat to calculate conjugate of
 * @returns  out
 */
declare export function quat$conjugate(out: GLM$IArray, a: GLM$IArray): GLM$IArray


/**
 * Returns a string representation of a vector
 * @param vec vector to represent as a string
 * @returns  string representation of the vector
 */
declare export function quat$str(a: GLM$IArray): string


/**
 * Rotate a 3D vector around the x-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function quat$rotateX(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the y-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function quat$rotateY(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Rotate a 3D vector around the z-axis
 * @param out The receiving vec3
 * @param a The vec3 point to rotate
 * @param b The origin of the rotation
 * @param c The angle of rotation
 * @returns  out
 */
declare export function quat$rotateZ(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray, c: number): GLM$IArray


/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 * 
NOTE: The resultant quaternion is not normalized, so you should be sure
to renormalize the quaternion yourself where necessary.
 * @param out the receiving quaternion
 * @param m rotation matrix
 * @returns  out
 * @function  
*/
declare export function quat$fromMat3(out: GLM$IArray, m: GLM$IArray): GLM$IArray


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
perpendicular to all other specified axes.
 * @param view the vector representing the viewing direction
 * @param right the vector representing the local "right" direction
 * @param up the vector representing the local "up" direction
 * @returns  out
*/
declare export function quat$setAxes(
    out: GLM$IArray,
    view: GLM$IArray,
    right: GLM$IArray,
    up: GLM$IArray): GLM$IArray


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.

Both vectors are assumed to be unit length.
 * @param out the receiving quaternion.
 * @param a the initial vector
 * @param b the destination vector
 * @returns  out
*/
declare export function quat$rotationTo(out: GLM$IArray, a: GLM$IArray, b: GLM$IArray): GLM$IArray


/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
Any existing W component will be ignored.
 * @param out the receiving quaternion
 * @param a quat to calculate W component of
 * @returns  out
*/
declare export function quat$calculateW(out: GLM$IArray, a: GLM$IArray): GLM$IArray