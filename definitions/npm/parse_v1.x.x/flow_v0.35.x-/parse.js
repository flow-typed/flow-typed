// @flow
/**
 * Flowtype definitions for parse
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$Parse: {
    initialize: typeof Parse$initialize,
}
declare var applicationId: string;

declare var javaScriptKey: string;

declare var masterKey: string;

declare var serverURL: string;

declare var VERSION: string;

declare interface Parse$SuccessOption {
    success?: Function
}

declare interface Parse$ErrorOption {
    error?: Function
}

declare type Parse$SuccessFailureOptions = {} & Parse$SuccessOption & Parse$ErrorOption


declare interface Parse$SessionTokenOption {
    sessionToken?: string
}

declare interface Parse$WaitOption {

    /**
     * Set to true to wait for the server to confirm success
     * before triggering an event.
     */
    wait?: boolean
}

declare interface Parse$UseMasterKeyOption {

    /**
     * In Cloud Code and Node only, causes the Master Key to be used for this request.
     */
    useMasterKey?: boolean
}

declare type Parse$ScopeOptions = {} & Parse$SessionTokenOption & Parse$UseMasterKeyOption


declare interface Parse$SilentOption {

    /**
     * Set to true to avoid firing the event.
     */
    silent?: boolean
}


/**
 * A Promise is returned by async methods as a hook to provide callbacks to be
 * called when the async task is fulfilled.

<p>Typical usage would be like:<pre>
    query.find().then(function(results) {
      results[0].set("foo", "bar");
      return results[0].saveAsync();
    }).then(function(result) {
      console.log("Updated " + result.id);
    });
</pre></p>
 * @see  Parse.Promise.prototype.then
 * @class  
*/
declare interface Parse$IPromise<T>{
    then<U>(
        resolvedCallback: (...values: T[]) => Parse$IPromise<U>,
        rejectedCallback?: (reason: any) => Parse$IPromise<U>): Parse$IPromise<U>,
    then<U>(
        resolvedCallback: (...values: T[]) => U,
        rejectedCallback?: (reason: any) => Parse$IPromise<U>): Parse$IPromise<U>,
    then<U>(
        resolvedCallback: (...values: T[]) => U,
        rejectedCallback?: (reason: any) => U): Parse$IPromise<U >
}

declare class Promise<T>mixins IPromise<T>{
    as<U>(resolvedValue: U): Parse$Promise<U>;
    error<U,
    V>(error: U): Parse$Promise<V>;
    is(possiblePromise: any): Boolean;
    when(promises: Parse$IPromise<any>[]): Parse$Promise<any>;
    when(...promises: Parse$IPromise<any>[]): Parse$Promise<any>;
    always(callback: Function): Parse$Promise<T>;
    done(callback: Function): Parse$Promise<T>;
    fail(callback: Function): Parse$Promise<T>;
    reject(error: any): void;
    resolve(result: any): void;
    then<U>(
        resolvedCallback: (...values: T[]) => Parse$IPromise<U>,
        rejectedCallback?: (reason: any) => Parse$IPromise<U>): Parse$IPromise<U>;
    then<U>(
        resolvedCallback: (...values: T[]) => U,
        rejectedCallback?: (reason: any) => Parse$IPromise<U>): Parse$IPromise<U>;
    then<U>(
        resolvedCallback: (...values: T[]) => U,
        rejectedCallback?: (reason: any) => U): Parse$IPromise<U >
}

declare interface Parse$IBaseObject {
    toJSON(): any
}

declare class BaseObject mixins IBaseObject {
    toJSON(): any
}


/**
 * Creates a new ACL.
 * If no argument is given, the ACL has no permissions for anyone.
If the argument is a Parse.User, the ACL will have read and write
   permission for only that user.
If the argument is any other JSON object, that object will be interpretted
   as a serialized ACL created with toJSON().
 * @see  Parse.Object#setACL
 * @class  *
<p>An ACL, or Access Control List can be added to any
<code>Parse.Object</code> to restrict access to only a subset of users
of your application.</p>
*/
declare class ACL mixins BaseObject {
    permissionsById: any;
    constructor(arg1?: any): this;
    setPublicReadAccess(allowed: boolean): void;
    getPublicReadAccess(): boolean;
    setPublicWriteAccess(allowed: boolean): void;
    getPublicWriteAccess(): boolean;
    setReadAccess(userId: Parse$User, allowed: boolean): void;
    getReadAccess(userId: Parse$User): boolean;
    setReadAccess(userId: string, allowed: boolean): void;
    getReadAccess(userId: string): boolean;
    setRoleReadAccess(role: Parse$Role, allowed: boolean): void;
    setRoleReadAccess(role: string, allowed: boolean): void;
    getRoleReadAccess(role: Parse$Role): boolean;
    getRoleReadAccess(role: string): boolean;
    setRoleWriteAccess(role: Parse$Role, allowed: boolean): void;
    setRoleWriteAccess(role: string, allowed: boolean): void;
    getRoleWriteAccess(role: Parse$Role): boolean;
    getRoleWriteAccess(role: string): boolean;
    setWriteAccess(userId: Parse$User, allowed: boolean): void;
    setWriteAccess(userId: string, allowed: boolean): void;
    getWriteAccess(userId: Parse$User): boolean;
    getWriteAccess(userId: string): boolean
}


/**
 * A Parse.File is a local representation of a file that is saved to the Parse
 * cloud.
 * @class  * 
 * @param name The file's name. This will be prefixed by a unique
value once the file has finished saving. The file name must begin with
an alphanumeric character, and consist of alphanumeric characters,
periods, spaces, underscores, or dashes.
 * @param data The data for the file, as either:
1. an Array of byte value Numbers, or
2. an Object like { base64: "..." } with a base64-encoded String.
3. a File object selected with a file upload control. (3) only works
in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.
For example:<pre>
var fileUploadControl = $("#profilePhotoFileUpload")[0];
if (fileUploadControl.files.length>0) {
var file = fileUploadControl.files[0];
var name = "photo.jpg";
var parseFile = new Parse.File(name, file);
parseFile.save().then(function() {
// The file has been saved to Parse.
}, function(error) {
// The file either could not be read, or could not be saved to Parse.
});
}</pre>
 * @param type Optional Content-Type header to use for the file. If
this is omitted, the content type will be inferred from the name's
extension.
*/
declare class File {
    constructor(name: string, data: any, type?: string): this;
    name(): string;
    url(): string;
    save<T>(options?: Parse$SuccessFailureOptions): Parse$Promise<T >
}


/**
 * Creates a new GeoPoint with any of the following forms:<br>
 *    <pre>
   new GeoPoint(otherGeoPoint)
   new GeoPoint(30, 30)
   new GeoPoint([30, 30])
   new GeoPoint({latitude: 30, longitude: 30})
   new GeoPoint()  // defaults to (0, 0)
   </pre>
 * @class  *
<p>Represents a latitude / longitude point that may be associated
with a key in a ParseObject or used as a reference point for geo queries.
This allows proximity-based queries on the key.</p>

<p>Only one key in a class may contain a GeoPoint.</p>

<p>Example:<pre>
var point = new Parse.GeoPoint(30.0, -20.0);
var object = new Parse.Object("PlaceObject");
object.set("location", point);
object.save();</pre></p>
*/
declare class GeoPoint mixins BaseObject {
    latitude: number;
    longitude: number;
    constructor(arg1?: any, arg2?: any): this;
    current(options?: Parse$SuccessFailureOptions): Parse$GeoPoint;
    radiansTo(point: Parse$GeoPoint): number;
    kilometersTo(point: Parse$GeoPoint): number;
    milesTo(point: Parse$GeoPoint): number
}


/**
 * History serves as a global router (per frame) to handle hashchange
 * events or pushState, match the appropriate route, and trigger
callbacks. You shouldn't ever have to create one of these yourself
â€” you should use the reference to <code>Parse.history</code>
that will be created for you automatically if you make use of
Routers with routes.
 * @class  *
<p>A fork of Backbone.History, provided for your convenience.  If you
use this class, you must also include jQuery, or another library
that provides a jQuery-compatible $ function.  For more information,
see the <a href="http://documentcloud.github.com/backbone/#History">
Backbone documentation</a>.</p>
<p><strong><em>Available in the client SDK only.</em></strong></p>
*/
declare class History {
    handlers: any[];
    interval: number;
    fragment: string;
    checkUrl(e?: any): void;
    getFragment(fragment?: string, forcePushState?: boolean): string;
    getHash(windowOverride: Window): string;
    loadUrl(fragmentOverride: any): boolean;
    navigate(fragment: string, options?: any): any;
    route(route: any, callback: Function): void;
    start(options: any): boolean;
    stop(): void
}


/**
 * A class that is used to access all of the children of a many-to-many relationship.
 * Each instance of Parse.Relation is associated with a particular parent object and key.
 */
declare class Relation mixins BaseObject {
    parent: Parse$Object;
    key: string;
    targetClassName: string;
    constructor(parent?: Parse$Object, key?: string): this;
    add(object: Parse$Object): void;
    query(): Parse$Query;
    remove(object: Parse$Object): void
}


/**
 * Creates a new model with defined attributes. A client id (cid) is
 * automatically generated and assigned for you.

<p>You won't normally call this method directly.  It is recommended that
you use a subclass of <code>Parse.Object</code> instead, created by calling
<code>extend</code>.</p>

<p>However, if you don't want to use a subclass, or aren't sure which
subclass is appropriate, you can use this form:<pre>
     var object = new Parse.Object("ClassName");
</pre>
That is basically equivalent to:<pre>
     var MyClass = Parse.Object.extend("ClassName");
     var object = new MyClass();
</pre></p>
 * @param  The initial set of data to store in the object.
 * @param  A set of Backbone-like options for creating the
object.  The only option currently supported is "collection".
 * @see  Parse.Object.extend
 * @class  *
<p>The fundamental unit of Parse data, which implements the Backbone Model
interface.</p>
*/
declare class Object mixins BaseObject {
    id: string;
    createdAt: Date;
    updatedAt: Date;
    attributes: any;
    cid: string;
    changed: boolean;
    className: string;
    constructor(className?: string, options?: any): this;
    constructor(attributes?: string[], options?: any): this;
    extend(className: string, protoProps?: any, classProps?: any): any;
    fetchAll<T>(
        list: Parse$Object[],
        options: Parse$SuccessFailureOptions): Parse$Promise<T>;
    fetchAllIfNeeded<T>(
        list: Parse$Object[],
        options: Parse$SuccessFailureOptions): Parse$Promise<T>;
    destroyAll<T>(list: Parse$Object[], options?: Object$DestroyAllOptions): Parse$Promise<T>;
    saveAll<T>(list: T[], options?: Object$SaveAllOptions): Parse$Promise<T[]>;
    registerSubclass<T>(className: string, clazz: (options?: any) => T): void;
    initialize(): void;
    add(attr: string, item: any): Parse$Object;
    addUnique(attr: string, item: any): any;
    change(options: any): Parse$Object;
    changedAttributes(diff: any): boolean;
    clear(options: any): any;
    clone(): Parse$Object;
    destroy<T>(options?: Object$DestroyOptions): Parse$Promise<T>;
    dirty(attr: String): boolean;
    dirtyKeys(): string[];
    escape(attr: string): string;
    existed(): boolean;
    fetch<T>(options?: Object$FetchOptions): Parse$Promise<T>;
    get(attr: string): any;
    getACL(): Parse$ACL;
    has(attr: string): boolean;
    hasChanged(attr: string): boolean;
    increment(attr: string, amount?: number): any;
    isValid(): boolean;
    op(attr: string): any;
    previous(attr: string): any;
    previousAttributes(): any;
    relation(attr: string): Parse$Relation;
    remove(attr: string, item: any): any;
    save<T>(
        attrs?: {
            [key: string]: any
        },
        options?: Object$SaveOptions): Parse$Promise<T>;
    save<T>(key: string, value: any, options?: Object$SaveOptions): Parse$Promise<T>;
    set(key: string, value: any, options?: Object$SetOptions): boolean;
    setACL(acl: Parse$ACL, options?: Parse$SuccessFailureOptions): boolean;
    unset(attr: string, options?: any): any;
    validate(attrs: any, options?: Parse$SuccessFailureOptions): boolean
}

declare type Object$DestroyOptions = {} & Parse$SuccessFailureOptions & Parse$WaitOption & Parse$ScopeOptions


declare type Object$DestroyAllOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Object$FetchOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Object$SaveOptions = {} & Parse$SuccessFailureOptions & Parse$SilentOption & Parse$ScopeOptions & Parse$WaitOption


declare type Object$SaveAllOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Object$SetOptions = {
    promise?: any
} & Parse$ErrorOption & Parse$SilentOption



/**
 * Every Parse application installed on a device registered for
 * push notifications has an associated Installation object.
 */
declare class Installation mixins Object {
    badge: any;
    channels: string[];
    timeZone: any;
    deviceType: string;
    pushType: string;
    installationId: string;
    deviceToken: string;
    channelUris: string;
    appName: string;
    appVersion: string;
    parseVersion: string;
    appIdentifier: string
}


/**
 * Creates a new instance with the given models and options.  Typically, you
 * will not call this method directly, but will instead make a subclass using
<code>Parse.Collection.extend</code>.
 * @param  An array of instances of <code>Parse.Object</code>.
 * @param  An optional object with Backbone-style options.
Valid options are:<ul>
<li>model: The Parse.Object subclass that this collection contains.
<li>query: An instance of Parse.Query to use when fetching items.
<li>comparator: A string property name or function to sort by.
</ul>
 * @see  Parse.Collection.extend
 * @class  *
<p>Provides a standard collection class for our sets of models, ordered
or unordered.  For more information, see the
<a href="http://documentcloud.github.com/backbone/#Collection">Backbone
documentation</a>.</p>
*/
declare class Collection<T>mixins Events, IBaseObject {
    model: Parse$Object;
    models: Parse$Object[];
    query: Parse$Query;
    comparator: (object: Parse$Object) => any;
    constructor(models?: Parse$Object[], options?: Collection$Options): this;
    extend(instanceProps: any, classProps: any): any;
    initialize(): void;
    add(models: any[], options?: Collection$AddOptions): Parse$Collection<T>;
    at(index: number): Parse$Object;
    chain(): _Chain<Parse$Collection<T >> ;
    fetch(options?: Collection$FetchOptions): Parse$Promise<T>;
    create(model: Parse$Object, options?: Collection$CreateOptions): Parse$Object;
    get(id: string): Parse$Object;
    getByCid(cid: any): any;
    pluck(attr: string): any[];
    remove(model: any, options?: Collection$RemoveOptions): Parse$Collection<T>;
    remove(models: any[], options?: Collection$RemoveOptions): Parse$Collection<T>;
    reset(models: any[], options?: Collection$ResetOptions): Parse$Collection<T>;
    sort(options?: Collection$SortOptions): Parse$Collection<T>;
    toJSON(): any
}

declare interface Collection$Options {
    model?: Parse$Object,
        query?: Parse$Query,
        comparator?: string
}

declare type Collection$AddOptions = {

    /**
     * The index at which to add the models.
     */
    at?: number
} & Parse$SilentOption


declare type Collection$CreateOptions = {} & Parse$SuccessFailureOptions & Parse$WaitOption & Parse$SilentOption & Parse$ScopeOptions


declare type Collection$FetchOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Collection$RemoveOptions = {} & Parse$SilentOption


declare type Collection$ResetOptions = {} & Parse$SilentOption


declare type Collection$SortOptions = {} & Parse$SilentOption



/**
 * 
 * @class  *
<p>Parse.Events is a fork of Backbone's Events module, provided for your
convenience.</p>

<p>A module that can be mixed in to any object in order to provide
it with custom events. You may bind callback functions to an event
with `on`, or remove these functions with `off`.
Triggering an event fires all callbacks in the order that `on` was
called.

<pre>
var object = {};
_.extend(object, Parse.Events);
object.on('expand', function(){ alert('expanded'); });
object.trigger('expand');</pre></p>

<p>For more information, see the
<a href="http://documentcloud.github.com/backbone/#Events">Backbone
documentation</a>.</p>
*/
declare class Events {
    off(events: string[], callback?: Function, context?: any): Parse$Events;
    on(events: string[], callback?: Function, context?: any): Parse$Events;
    trigger(events: string[]): Parse$Events;
    bind(): Parse$Events;
    unbind(): Parse$Events;
    on(eventName: string, callback?: Function, context?: any): Parse$Events;
    off(eventName?: string, callback?: Function, context?: any): Parse$Events;
    trigger(eventName: string, ...args: any[]): Parse$Events;
    bind(eventName: string, callback: Function, context?: any): Parse$Events;
    unbind(eventName?: string, callback?: Function, context?: any): Parse$Events
}


/**
 * Creates a new parse Parse.Query for the given Parse.Object subclass.
 * @param objectClass -
An instance of a subclass of Parse.Object, or a Parse className string.
 * @class  *
<p>Parse.Query defines a query that is used to fetch Parse.Objects. The
most common use case is finding all objects that match a query through the
<code>find</code> method. For example, this sample code fetches all objects
of class <code>MyClass</code>. It calls a different function depending on
whether the fetch succeeded or not.

<pre>
var query = new Parse.Query(MyClass);
query.find({
success: function(results) {
// results is an array of Parse.Object.
},

error: function(error) {
// error is an instance of Parse.Error.
}
});</pre></p>

<p>A Parse.Query can also be used to retrieve a single object whose id is
known, through the get method. For example, this sample code fetches an
object of class <code>MyClass</code> and id <code>myId</code>. It calls a
different function depending on whether the fetch succeeded or not.

<pre>
var query = new Parse.Query(MyClass);
query.get(myId, {
success: function(object) {
// object is an instance of Parse.Object.
},

error: function(object, error) {
// error is an instance of Parse.Error.
}
});</pre></p>

<p>A Parse.Query can also be used to count the number of objects that match
the query without retrieving all of those objects. For example, this
sample code counts the number of objects of the class <code>MyClass</code>
<pre>
var query = new Parse.Query(MyClass);
query.count({
success: function(number) {
// There are number instances of MyClass.
},

error: function(error) {
// error is an instance of Parse.Error.
}
});</pre></p>
*/
declare class Query mixins BaseObject {
    objectClass: any;
    className: string;
    constructor(objectClass: any): this;
    or(...var_args: Parse$Query[]): Parse$Query;
    addAscending(key: string): Parse$Query;
    addAscending(key: string[]): Parse$Query;
    addDescending(key: string): Parse$Query;
    addDescending(key: string[]): Parse$Query;
    ascending(key: string): Parse$Query;
    ascending(key: string[]): Parse$Query;
    collection(
        items?: Parse$Object[],
        options?: Collection$Options): Parse$Collection<Parse$Object>;
    containedIn(key: string, values: any[]): Parse$Query;
    contains(key: string, substring: string): Parse$Query;
    containsAll(key: string, values: any[]): Parse$Query;
    count<T>(options?: Query$CountOptions): Parse$Promise<T>;
    descending(key: string): Parse$Query;
    descending(key: string[]): Parse$Query;
    doesNotExist(key: string): Parse$Query;
    doesNotMatchKeyInQuery(key: string, queryKey: string, query: Parse$Query): Parse$Query;
    doesNotMatchQuery(key: string, query: Parse$Query): Parse$Query;
    each<T>(callback: Function, options?: Query$EachOptions): Parse$Promise<T>;
    endsWith(key: string, suffix: string): Parse$Query;
    equalTo(key: string, value: any): Parse$Query;
    exists(key: string): Parse$Query;
    find<T>(options?: Query$FindOptions): Parse$Promise<T[]>;
    first<T>(options?: Query$FirstOptions): Parse$Promise<T>;
    get(objectId: string, options?: Query$GetOptions): Parse$Promise<any>;
    greaterThan(key: string, value: any): Parse$Query;
    greaterThanOrEqualTo(key: string, value: any): Parse$Query;
    include(key: string): Parse$Query;
    include(keys: string[]): Parse$Query;
    lessThan(key: string, value: any): Parse$Query;
    lessThanOrEqualTo(key: string, value: any): Parse$Query;
    limit(n: number): Parse$Query;
    matches(key: string, regex: RegExp, modifiers: any): Parse$Query;
    matchesKeyInQuery(key: string, queryKey: string, query: Parse$Query): Parse$Query;
    matchesQuery(key: string, query: Parse$Query): Parse$Query;
    near(key: string, point: Parse$GeoPoint): Parse$Query;
    notContainedIn(key: string, values: any[]): Parse$Query;
    notEqualTo(key: string, value: any): Parse$Query;
    select(...keys: string[]): Parse$Query;
    skip(n: number): Parse$Query;
    startsWith(key: string, prefix: string): Parse$Query;
    withinGeoBox(key: string, southwest: Parse$GeoPoint, northeast: Parse$GeoPoint): Parse$Query;
    withinKilometers(key: string, point: Parse$GeoPoint, maxDistance: number): Parse$Query;
    withinMiles(key: string, point: Parse$GeoPoint, maxDistance: number): Parse$Query;
    withinRadians(key: string, point: Parse$GeoPoint, maxDistance: number): Parse$Query
}

declare type Query$EachOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Query$CountOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Query$FindOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Query$FirstOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare type Query$GetOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions



/**
 * Represents a Role on the Parse server. Roles represent groupings of
 * Users for the purposes of granting permissions (e.g. specifying an ACL
for an Object). Roles are specified by their sets of child users and
child roles, all of which are granted any permissions that the parent
role has.

<p>Roles must have a name (which cannot be changed after creation of the
role), and must specify an ACL.</p>
 * @class  * A Parse.Role is a local representation of a role persisted to the Parse
cloud.
*/
declare class Role mixins Object {
    constructor(name: string, acl: Parse$ACL): this;
    getRoles(): Parse$Relation;
    getUsers(): Parse$Relation;
    getName(): string;
    setName(name: string, options?: Parse$SuccessFailureOptions): any
}

declare class Config mixins Object {
    get(options?: Parse$SuccessFailureOptions): Parse$Promise<Parse$Config>;
    current(): Parse$Config;
    get(attr: string): any;
    escape(attr: string): any
}

declare class Session mixins Object {
    current(): Parse$Promise<Parse$Session>;
    getSessionToken(): string;
    isCurrentSessionRevocable(): boolean
}


/**
 * Routers map faux-URLs to actions, and fire events when routes are
 * matched. Creating a new one sets its `routes` hash, if not set statically.
 * @class  *
<p>A fork of Backbone.Router, provided for your convenience.
For more information, see the
<a href="http://documentcloud.github.com/backbone/#Router">Backbone
documentation</a>.</p>
<p><strong><em>Available in the client SDK only.</em></strong></p>
*/
declare class Router mixins Events {
    routes: Router$RouteMap;
    constructor(options?: Router$Options): this;
    extend(instanceProps: any, classProps: any): any;
    initialize(): void;
    navigate(fragment: string, options?: Router$NavigateOptions): Parse$Router;
    navigate(fragment: string, trigger?: boolean): Parse$Router;
    route(route: string, name: string, callback: Function): Parse$Router
}

declare interface Router$Options {
    model?: Parse$Object,
        query?: Parse$Query,
        comparator?: string
}

declare interface Router$RouteMap {
    [url: string]: string
}

declare interface Router$NavigateOptions {
    trigger?: boolean
}


/**
 * 
 * @class  *
<p>A Parse.User object is a local representation of a user persisted to the
Parse cloud. This class is a subclass of a Parse.Object, and retains the
same functionality of a Parse.Object, but also extends it with various
user specific methods, like authentication, signing up, and validation of
uniqueness.</p>
*/
declare class User mixins Object {
    current(): Parse$User;
    signUp<T>(
        username: string,
        password: string,
        attrs: any,
        options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    logIn<T>(
        username: string,
        password: string,
        options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    logOut<T>(): Parse$Promise<T>;
    allowCustomUserClass(isAllowed: boolean): void;
    become<T>(
        sessionToken: string,
        options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    requestPasswordReset<T>(email: string, options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    extend(protoProps?: any, classProps?: any): any;
    signUp<T>(attrs: any, options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    logIn<T>(options?: Parse$SuccessFailureOptions): Parse$Promise<T>;
    authenticated(): boolean;
    isCurrent(): boolean;
    getEmail(): string;
    setEmail(email: string, options: Parse$SuccessFailureOptions): boolean;
    getUsername(): string;
    setUsername(username: string, options?: Parse$SuccessFailureOptions): boolean;
    setPassword(password: string, options?: Parse$SuccessFailureOptions): boolean;
    getSessionToken(): string
}


/**
 * Creating a Parse.View creates its initial element outside of the DOM,
 * if an existing element is not provided...
 * @class  *
<p>A fork of Backbone.View, provided for your convenience.  If you use this
class, you must also include jQuery, or another library that provides a
jQuery-compatible $ function.  For more information, see the
<a href="http://documentcloud.github.com/backbone/#View">Backbone
documentation</a>.</p>
<p><strong><em>Available in the client SDK only.</em></strong></p>
*/
declare class View<T>mixins Events {
    model: any;
    collection: any;
    id: string;
    cid: string;
    className: string;
    tagName: string;
    el: any;
    $el: JQuery;
    attributes: any;
    constructor(options?: View$Options): this;
    extend(properties: any, classProperties?: any): any;
    $(selector?: string): JQuery;
    setElement(element: HTMLElement, delegate?: boolean): Parse$View<T>;
    setElement(element: JQuery, delegate?: boolean): Parse$View<T>;
    render(): Parse$View<T>;
    remove(): Parse$View<T>;
    make(tagName: any, attributes?: View$Attribute[], content?: any): any;
    delegateEvents(events?: any): any;
    undelegateEvents(): any
}

declare interface View$Options {
    model?: Parse$Object,
        query?: Parse$Query,
        comparator?: string
}

declare interface View$Attribute {
    [attributeName: string]: string | number | boolean
}


declare var npm$namespace$Analytics: {
    track: typeof Analytics$track,
}
declare function Analytics$track<T>(name: string, dimensions: any): Parse$Promise<T >


    declare var npm$namespace$FacebookUtils: {
    init: typeof FacebookUtils$init,
    isLinked: typeof FacebookUtils$isLinked,
    link: typeof FacebookUtils$link,
    logIn: typeof FacebookUtils$logIn,
    unlink: typeof FacebookUtils$unlink,
}
declare function FacebookUtils$init(options?: any): void

declare function FacebookUtils$isLinked(user: Parse$User): boolean

declare function FacebookUtils$link(
    user: Parse$User,
    permissions: any,
    options?: Parse$SuccessFailureOptions): void

declare function FacebookUtils$logIn(permissions: any, options?: Parse$SuccessFailureOptions): void

declare function FacebookUtils$unlink(user: Parse$User, options?: Parse$SuccessFailureOptions): void


declare var npm$namespace$Cloud: {
    afterDelete: typeof Cloud$afterDelete,
    afterSave: typeof Cloud$afterSave,
    beforeDelete: typeof Cloud$beforeDelete,
    beforeSave: typeof Cloud$beforeSave,
    define: typeof Cloud$define,
    httpRequest: typeof Cloud$httpRequest,
    job: typeof Cloud$job,
    run: typeof Cloud$run,
    useMasterKey: typeof Cloud$useMasterKey,
}
declare interface Cloud$CookieOptions {
    domain?: string,
        expires?: Date,
        httpOnly?: boolean,
        maxAge?: number,
        path?: string,
        secure?: boolean
}

declare interface Cloud$HttpResponse {
    buffer?: Buffer,
        cookies?: any,
        data?: any,
        headers?: any,
        status?: number,
        text?: string
}

declare interface Cloud$JobRequest {
    params: any
}

declare interface Cloud$JobStatus {
    error?: (response: any) => void,
        message?: (response: any) => void,
        success?: (response: any) => void
}

declare interface Cloud$FunctionRequest {
    installationId?: String,
        master?: boolean,
        params?: any,
        user?: Parse$User
}

declare interface Cloud$FunctionResponse {
    success?: (response: any) => void,
        error?: (response: any) => void
}

declare interface Cloud$Cookie {
    name?: string,
        options?: Cloud$CookieOptions,
        value?: string
}

declare type Cloud$SaveRequest = {
    object: Parse$Object
} & Cloud$FunctionRequest


declare type Cloud$AfterSaveRequest = {} & Cloud$SaveRequest


declare type Cloud$AfterDeleteRequest = {} & Cloud$FunctionRequest


declare type Cloud$BeforeDeleteRequest = {} & Cloud$FunctionRequest


declare type Cloud$BeforeDeleteResponse = {} & Cloud$FunctionResponse


declare type Cloud$BeforeSaveRequest = {} & Cloud$SaveRequest


declare type Cloud$BeforeSaveResponse = {
    success?: () => void
} & Cloud$FunctionResponse


declare function Cloud$afterDelete(arg1: any, func?: (request: Cloud$AfterDeleteRequest) => void): void

declare function Cloud$afterSave(arg1: any, func?: (request: Cloud$AfterSaveRequest) => void): void

declare function Cloud$beforeDelete(
    arg1: any,
    func?: (
        request: Cloud$BeforeDeleteRequest,
        response: Cloud$BeforeDeleteResponse) => void): void

declare function Cloud$beforeSave(
    arg1: any,
    func?: (request: Cloud$BeforeSaveRequest, response: Cloud$BeforeSaveResponse) => void): void

declare function Cloud$define(
    name: string,
    func?: (request: Cloud$FunctionRequest, response: Cloud$FunctionResponse) => void): void

declare function Cloud$httpRequest(options: Cloud$HTTPOptions): Parse$Promise<Cloud$HttpResponse >

    declare function Cloud$job(
    name: string,
    func?: (request: Cloud$JobRequest, status: Cloud$JobStatus) => void): Cloud$HttpResponse

declare function Cloud$run<T>(name: string, data?: any, options?: Cloud$RunOptions): Parse$Promise<T >

    declare function Cloud$useMasterKey(): void

declare type Cloud$RunOptions = {} & Parse$SuccessFailureOptions & Parse$ScopeOptions


declare var HTTPOptions: () => Cloud$HTTPOptions;

declare type Cloud$HTTPOptions = {

    /**
     * The body of the request.
     * If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json.
    You can also set this to a Buffer object to send raw bytes.
    If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
    */
    body?: string | Buffer | Parse$Object,

    /**
     * Defaults to 'false'.
     */
    followRedirects?: boolean,

    /**
     * The headers for the request.
     */
    headers?: {
        [headerName: string]: string | number | boolean
    },

    /**
     * The method of the request (i.e GET, POST, etc).
     */
    method?: string,

    /**
     * The query portion of the url.
     */
    params?: any,

    /**
     * The url to send the request to.
     */
    url: string
} & Cloud$FunctionResponse


declare class Error {
    code: ErrorCode;
    message: string;
    constructor(code: ErrorCode, message: string): this
}

declare type Op$BaseOperation = {
    objects(): any[]
} & Parse$IBaseObject


declare type Op$Add = {} & Op$BaseOperation


declare type Op$AddUnique = {} & Op$BaseOperation


declare type Op$Increment = {
    amount: number
} & Parse$IBaseObject


declare type Op$Relation = {
    added(): Parse$Object[],
    removed: Parse$Object[]
} & Parse$IBaseObject


declare type Op$Set = {
    value(): any
} & Parse$IBaseObject


declare type Op$Unset = {} & Parse$IBaseObject



declare var npm$namespace$Push: {
    send: typeof Push$send,
}
declare function Push$send<T>(data: Push$PushData, options?: Push$SendOptions): Parse$Promise<T >

    declare interface Push$PushData {
        channels?: string[],
            push_time?: Date,
            expiration_time?: Date,
            expiration_interval?: number,
            where?: Parse$Query,
            data?: any,
            alert?: string,
            badge?: string,
            sound?: string,
            title?: string
    }

declare type Push$SendOptions = {
    success?: () => void,
    error?: (error: Parse$Error) => void
} & Parse$UseMasterKeyOption



/**
 * Call this method first to set up your authentication tokens for Parse.
 * You can get your keys from the Data Browser on parse.com.
 * @param  Your Parse Application ID.
 * @param  (optional) Your Parse JavaScript Key (Not needed for parse-server)
 * @param  (optional) Your Parse Master Key. (Node.js only!)
 */
declare function Parse$initialize(applicationId: string, javaScriptKey?: string, masterKey?: string): voiddeclare module 'parse/node' {
    declare module.exports: typeof Parse
}
declare module 'parse' {

    declare module.exports: typeof parse
}