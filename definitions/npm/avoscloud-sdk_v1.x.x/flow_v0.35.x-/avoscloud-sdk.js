// @flow
/**
 * Flowtype definitions for avoscloud-sdk
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'avoscloud-sdk' {

    declare     var npm$namespace$AV: {
        initialize: typeof AV$initialize,
    }
    declare     var applicationId: string;

    declare     var applicationKey: string;

    declare     var masterKey: string;

    declare interface AV$SuccessOption {
        success?: Function
    }

    declare interface AV$ErrorOption {
        error?: Function
    }

    declare type AV$SuccessFailureOptions = {} & AV$SuccessOption & AV$ErrorOption


    declare interface AV$WaitOption {

        /**
         * Set to true to wait for the server to confirm success
         * before triggering an event.
         */
        wait?: boolean
    }

    declare interface AV$UseMasterKeyOption {

        /**
         * In Cloud Code and Node only, causes the Master Key to be used for this request.
         */
        useMasterKey?: boolean
    }

    declare interface AV$SilentOption {

        /**
         * Set to true to avoid firing the event.
         */
        silent?: boolean
    }


    /**
     * A Promise is returned by async methods as a hook to provide callbacks to be
     * called when the async task is fulfilled.

    <p>Typical usage would be like:<pre>
        query.find().then(function(results) {
          results[0].set("foo", "bar");
          return results[0].saveAsync();
        }).then(function(result) {
          console.log("Updated " + result.id);
        });
    </pre></p>
     * @see  AV.Promise.prototype.then
     * @class  
    */
    declare interface AV$IPromise<T>{
        then<U>(
            resolvedCallback: (value: T) => AV$IPromise<U>,
            rejectedCallback?: (reason: any) => AV$IPromise<U>): AV$IPromise<T>,
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => AV$IPromise<U>): AV$IPromise<U>,
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => U): AV$IPromise<U >
    }

    declare class Promise<T>{
        as<U>(resolvedValue: U): AV$Promise<U>;
        error<U>(error: U): AV$Promise<U>;
        is(possiblePromise: any): Boolean;
        when(promises: AV$Promise<any>[]): AV$Promise<any>;
        always(callback: Function): AV$Promise<T>;
        done(callback: Function): AV$Promise<T>;
        fail(callback: Function): AV$Promise<T>;
        reject(error: any): void;
        resolve(result: any): void;
        then<U>(
            resolvedCallback: (value: T) => AV$Promise<U>,
            rejectedCallback?: (reason: any) => AV$Promise<U>): AV$IPromise<T>;
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => AV$IPromise<U>): AV$IPromise<T>;
        then<U>(
            resolvedCallback: (value: T) => U,
            rejectedCallback?: (reason: any) => U): AV$IPromise<T >
    }

    declare interface AV$IBaseObject {
        toJSON(): any
    }

    declare class BaseObject mixins IBaseObject {
        toJSON(): any
    }


    /**
     * Creates a new ACL.
     * If no argument is given, the ACL has no permissions for anyone.
    If the argument is a AV.User, the ACL will have read and write
       permission for only that user.
    If the argument is any other JSON object, that object will be interpretted
       as a serialized ACL created with toJSON().
     * @see  AV.Object#setACL
     * @class  *
    <p>An ACL, or Access Control List can be added to any
    <code>AV.Object</code> to restrict access to only a subset of users
    of your application.</p>
    */
    declare class ACL mixins BaseObject {
        permissionsById: any;
        constructor(arg1?: any): this;
        setPublicReadAccess(allowed: boolean): void;
        getPublicReadAccess(): boolean;
        setPublicWriteAccess(allowed: boolean): void;
        getPublicWriteAccess(): boolean;
        setReadAccess(userId: AV$User, allowed: boolean): void;
        getReadAccess(userId: AV$User): boolean;
        setReadAccess(userId: string, allowed: boolean): void;
        getReadAccess(userId: string): boolean;
        setRoleReadAccess(role: AV$Role, allowed: boolean): void;
        setRoleReadAccess(role: string, allowed: boolean): void;
        getRoleReadAccess(role: AV$Role): boolean;
        getRoleReadAccess(role: string): boolean;
        setRoleWriteAccess(role: AV$Role, allowed: boolean): void;
        setRoleWriteAccess(role: string, allowed: boolean): void;
        getRoleWriteAccess(role: AV$Role): boolean;
        getRoleWriteAccess(role: string): boolean;
        setWriteAccess(userId: AV$User, allowed: boolean): void;
        setWriteAccess(userId: string, allowed: boolean): void;
        getWriteAccess(userId: AV$User): boolean;
        getWriteAccess(userId: string): boolean
    }


    /**
     * A AV.File is a local representation of a file that is saved to the AV
     * cloud.
     * @class  * 
     * @param name The file's name. This will be prefixed by a unique
    value once the file has finished saving. The file name must begin with
    an alphanumeric character, and consist of alphanumeric characters,
    periods, spaces, underscores, or dashes.
     * @param data The data for the file, as either:
    1. an Array of byte value Numbers, or
    2. an Object like { base64: "..." } with a base64-encoded String.
    3. a File object selected with a file upload control. (3) only works
    in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.
    For example:<pre>
    var fileUploadControl = $("#profilePhotoFileUpload")[0];
    if (fileUploadControl.files.length>0) {
    var file = fileUploadControl.files[0];
    var name = "photo.jpg";
    var AVFile = new AV.File(name, file);
    AVFile.save().then(function() {
    // The file has been saved to AV.
    }, function(error) {
    // The file either could not be read, or could not be saved to AV.
    });
    }</pre>
     * @param type Optional Content-Type header to use for the file. If
    this is omitted, the content type will be inferred from the name's
    extension.
    */
    declare class File {
        constructor(name: string, data: any, type?: string): this;
        name(): string;
        url(): string;
        save<T>(options?: AV$SuccessFailureOptions): AV$Promise<T >
    }


    /**
     * Creates a new GeoPoint with any of the following forms:<br>
     *    <pre>
       new GeoPoint(otherGeoPoint)
       new GeoPoint(30, 30)
       new GeoPoint([30, 30])
       new GeoPoint({latitude: 30, longitude: 30})
       new GeoPoint()  // defaults to (0, 0)
       </pre>
     * @class  *
    <p>Represents a latitude / longitude point that may be associated
    with a key in a AVObject or used as a reference point for geo queries.
    This allows proximity-based queries on the key.</p>

    <p>Only one key in a class may contain a GeoPoint.</p>

    <p>Example:<pre>
    var point = new AV.GeoPoint(30.0, -20.0);
    var object = new AV.Object("PlaceObject");
    object.set("location", point);
    object.save();</pre></p>
    */
    declare class GeoPoint mixins BaseObject {
        latitude: number;
        longitude: number;
        constructor(arg1?: any, arg2?: any): this;
        current(options?: AV$SuccessFailureOptions): AV$GeoPoint;
        radiansTo(point: AV$GeoPoint): number;
        kilometersTo(point: AV$GeoPoint): number;
        milesTo(point: AV$GeoPoint): number
    }


    /**
     * A class that is used to access all of the children of a many-to-many relationship.
     * Each instance of AV.Relation is associated with a particular parent object and key.
     */
    declare class Relation mixins BaseObject {
        parent: AV$Object;
        key: string;
        targetClassName: string;
        constructor(parent?: AV$Object, key?: string): this;
        add(object: AV$Object): void;
        query(): AV$Query;
        remove(object: AV$Object): void
    }


    /**
     * Creates a new model with defined attributes. A client id (cid) is
     * automatically generated and assigned for you.

    <p>You won't normally call this method directly.  It is recommended that
    you use a subclass of <code>AV.Object</code> instead, created by calling
    <code>extend</code>.</p>

    <p>However, if you don't want to use a subclass, or aren't sure which
    subclass is appropriate, you can use this form:<pre>
         var object = new AV.Object("ClassName");
    </pre>
    That is basically equivalent to:<pre>
         var MyClass = AV.Object.extend("ClassName");
         var object = new MyClass();
    </pre></p>
     * @param  The initial set of data to store in the object.
     * @param  A set of Backbone-like options for creating the
    object.  The only option currently supported is "collection".
     * @see  AV.Object.extend
     * @class  *
    <p>The fundamental unit of AV data, which implements the Backbone Model
    interface.</p>
    */
    declare class Object mixins BaseObject {
        id: any;
        createdAt: any;
        updatedAt: any;
        attributes: any;
        cid: string;
        changed: boolean;
        className: string;
        constructor(className?: string, options?: any): this;
        constructor(attributes?: string[], options?: any): this;
        extend(className: string, protoProps?: any, classProps?: any): any;
        fetchAll<T>(list: AV$Object[], options: AV$SuccessFailureOptions): AV$Promise<T>;
        fetchAllIfNeeded<T>(list: AV$Object[], options: AV$SuccessFailureOptions): AV$Promise<T>;
        destroyAll<T>(list: AV$Object[], options?: Object$DestroyAllOptions): AV$Promise<T>;
        saveAll<T>(list: AV$Object[], options?: Object$SaveAllOptions): AV$Promise<T>;
        initialize(): void;
        add(attr: string, item: any): AV$Object;
        addUnique(attr: string, item: any): any;
        change(options: any): AV$Object;
        changedAttributes(diff: any): boolean;
        clear(options: any): any;
        clone(): AV$Object;
        destroy<T>(options?: Object$DestroyOptions): AV$Promise<T>;
        dirty(attr: String): boolean;
        dirtyKeys(): string[];
        escape(attr: string): string;
        existed(): boolean;
        fetch<T>(options?: Object$FetchOptions): AV$Promise<T>;
        get(attr: string): any;
        getACL(): AV$ACL;
        getObjectId(): string;
        has(attr: string): boolean;
        hasChanged(attr: string): boolean;
        increment(attr: string, amount?: number): any;
        isValid(): boolean;
        op(attr: string): any;
        previous(attr: string): any;
        previousAttributes(): any;
        relation(attr: string): AV$Relation;
        remove(attr: string, item: any): any;
        save<T>(options?: Object$SaveOptions, arg2?: any, arg3?: any): AV$Promise<T>;
        set(key: string, value: any, options?: Object$SetOptions): boolean;
        setACL(acl: AV$ACL, options?: AV$SuccessFailureOptions): boolean;
        unset(attr: string, options?: any): any;
        validate(attrs: any, options?: AV$SuccessFailureOptions): boolean
    }

    declare type Object$DestroyOptions = {} & AV$SuccessFailureOptions & AV$WaitOption & AV$UseMasterKeyOption


    declare type Object$DestroyAllOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$FetchOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$SaveOptions = {} & AV$SuccessFailureOptions & AV$SilentOption & AV$UseMasterKeyOption & AV$WaitOption


    declare type Object$SaveAllOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Object$SetOptions = {
        promise?: any
    } & AV$ErrorOption & AV$SilentOption



    /**
     * Every AV application installed on a device registered for
     * push notifications has an associated Installation object.
     */
    declare class Installation mixins Object {
        badge: any;
        channels: string[];
        timeZone: any;
        deviceType: string;
        pushType: string;
        installationId: string;
        deviceToken: string;
        channelUris: string;
        appName: string;
        appVersion: string;
        AVVersion: string;
        appIdentifier: string
    }


    /**
     * Creates a new instance with the given models and options.  Typically, you
     * will not call this method directly, but will instead make a subclass using
    <code>AV.Collection.extend</code>.
     * @param  An array of instances of <code>AV.Object</code>.
     * @param  An optional object with Backbone-style options.
    Valid options are:<ul>
    <li>model: The AV.Object subclass that this collection contains.
    <li>query: An instance of AV.Query to use when fetching items.
    <li>comparator: A string property name or function to sort by.
    </ul>
     * @see  AV.Collection.extend
     * @class  *
    <p>Provides a standard collection class for our sets of models, ordered
    or unordered.  For more information, see the
    <a href="http://documentcloud.github.com/backbone/#Collection">Backbone
    documentation</a>.</p>
    */
    declare class Collection<T>mixins Events, IBaseObject {
        model: AV$Object;
        models: AV$Object[];
        query: AV$Query;
        comparator: (object: AV$Object) => any;
        constructor(models?: AV$Object[], options?: Collection$Options): this;
        extend(instanceProps: any, classProps: any): any;
        initialize(): void;
        add(models: any[], options?: Collection$AddOptions): AV$Collection<T>;
        at(index: number): AV$Object;
        fetch(options?: Collection$FetchOptions): AV$Promise<T>;
        create(model: AV$Object, options?: Collection$CreateOptions): AV$Object;
        get(id: string): AV$Object;
        getByCid(cid: any): any;
        pluck(attr: string): any[];
        remove(model: any, options?: Collection$RemoveOptions): AV$Collection<T>;
        remove(models: any[], options?: Collection$RemoveOptions): AV$Collection<T>;
        reset(models: any[], options?: Collection$ResetOptions): AV$Collection<T>;
        sort(options?: Collection$SortOptions): AV$Collection<T>;
        toJSON(): any
    }

    declare interface Collection$Options {
        model?: AV$Object,
            query?: AV$Query,
            comparator?: string
    }

    declare type Collection$AddOptions = {

        /**
         * The index at which to add the models.
         */
        at?: number
    } & AV$SilentOption


    declare type Collection$CreateOptions = {} & AV$SuccessFailureOptions & AV$WaitOption & AV$SilentOption & AV$UseMasterKeyOption


    declare type Collection$FetchOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Collection$RemoveOptions = {} & AV$SilentOption


    declare type Collection$ResetOptions = {} & AV$SilentOption


    declare type Collection$SortOptions = {} & AV$SilentOption



    /**
     * 
     * @class  *
    <p>AV.Events is a fork of Backbone's Events module, provided for your
    convenience.</p>

    <p>A module that can be mixed in to any object in order to provide
    it with custom events. You may bind callback functions to an event
    with `on`, or remove these functions with `off`.
    Triggering an event fires all callbacks in the order that `on` was
    called.

    <pre>
    var object = {};
    _.extend(object, AV.Events);
    object.on('expand', function(){ alert('expanded'); });
    object.trigger('expand');</pre></p>

    <p>For more information, see the
    <a href="http://documentcloud.github.com/backbone/#Events">Backbone
    documentation</a>.</p>
    */
    declare class Events {
        off(events: string[], callback?: Function, context?: any): AV$Events;
        on(events: string[], callback?: Function, context?: any): AV$Events;
        trigger(events: string[]): AV$Events;
        bind(): AV$Events;
        unbind(): AV$Events;
        on(eventName: string, callback?: Function, context?: any): AV$Events;
        off(eventName?: string, callback?: Function, context?: any): AV$Events;
        trigger(eventName: string, ...args: any[]): AV$Events;
        bind(eventName: string, callback: Function, context?: any): AV$Events;
        unbind(eventName?: string, callback?: Function, context?: any): AV$Events
    }


    /**
     * Creates a new AV AV.Query for the given AV.Object subclass.
     * @param objectClass -
    An instance of a subclass of AV.Object, or a AV className string.
     * @class  *
    <p>AV.Query defines a query that is used to fetch AV.Objects. The
    most common use case is finding all objects that match a query through the
    <code>find</code> method. For example, this sample code fetches all objects
    of class <code>MyClass</code>. It calls a different function depending on
    whether the fetch succeeded or not.

    <pre>
    var query = new AV.Query(MyClass);
    query.find({
    success: function(results) {
    // results is an array of AV.Object.
    },

    error: function(error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>

    <p>A AV.Query can also be used to retrieve a single object whose id is
    known, through the get method. For example, this sample code fetches an
    object of class <code>MyClass</code> and id <code>myId</code>. It calls a
    different function depending on whether the fetch succeeded or not.

    <pre>
    var query = new AV.Query(MyClass);
    query.get(myId, {
    success: function(object) {
    // object is an instance of AV.Object.
    },

    error: function(object, error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>

    <p>A AV.Query can also be used to count the number of objects that match
    the query without retrieving all of those objects. For example, this
    sample code counts the number of objects of the class <code>MyClass</code>
    <pre>
    var query = new AV.Query(MyClass);
    query.count({
    success: function(number) {
    // There are number instances of MyClass.
    },

    error: function(error) {
    // error is an instance of AV.Error.
    }
    });</pre></p>
    */
    declare class Query mixins BaseObject {
        objectClass: any;
        className: string;
        constructor(objectClass: any): this;
        and(...var_args: AV$Query[]): AV$Query;
        or(...var_args: AV$Query[]): AV$Query;
        addAscending(key: string): AV$Query;
        addAscending(key: string[]): AV$Query;
        addDescending(key: string): AV$Query;
        addDescending(key: string[]): AV$Query;
        ascending(key: string): AV$Query;
        ascending(key: string[]): AV$Query;
        collection(items?: AV$Object[], options?: Collection$Options): AV$Collection<AV$Object>;
        containedIn(key: string, values: any[]): AV$Query;
        contains(key: string, substring: string): AV$Query;
        containsAll(key: string, values: any[]): AV$Query;
        count<T>(options?: Query$CountOptions): AV$Promise<T>;
        descending(key: string): AV$Query;
        descending(key: string[]): AV$Query;
        doesNotExist(key: string): AV$Query;
        doesNotMatchKeyInQuery(key: string, queryKey: string, query: AV$Query): AV$Query;
        doesNotMatchQuery(key: string, query: AV$Query): AV$Query;
        each<T>(callback: Function, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        endsWith(key: string, suffix: string): AV$Query;
        equalTo(key: string, value: any): AV$Query;
        exists(key: string): AV$Query;
        find<T>(options?: Query$FindOptions): AV$Promise<T>;
        first<T>(options?: Query$FirstOptions): AV$Promise<T>;
        get(objectId: string, options?: Query$GetOptions): AV$Promise<any>;
        greaterThan(key: string, value: any): AV$Query;
        greaterThanOrEqualTo(key: string, value: any): AV$Query;
        include(key: string): AV$Query;
        include(keys: string[]): AV$Query;
        lessThan(key: string, value: any): AV$Query;
        lessThanOrEqualTo(key: string, value: any): AV$Query;
        limit(n: number): AV$Query;
        matches(key: string, regex: RegExp, modifiers: any): AV$Query;
        matchesKeyInQuery(key: string, queryKey: string, query: AV$Query): AV$Query;
        matchesQuery(key: string, query: AV$Query): AV$Query;
        near(key: string, point: AV$GeoPoint): AV$Query;
        notContainedIn(key: string, values: any[]): AV$Query;
        notEqualTo(key: string, value: any): AV$Query;
        select(...keys: string[]): AV$Query;
        skip(n: number): AV$Query;
        startsWith(key: string, prefix: string): AV$Query;
        withinGeoBox(key: string, southwest: AV$GeoPoint, northeast: AV$GeoPoint): AV$Query;
        withinKilometers(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query;
        withinMiles(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query;
        withinRadians(key: string, point: AV$GeoPoint, maxDistance: number): AV$Query
    }

    declare type Query$CountOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$FindOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$FirstOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption


    declare type Query$GetOptions = {} & AV$SuccessFailureOptions & AV$UseMasterKeyOption



    /**
     * Represents a Role on the AV server. Roles represent groupings of
     * Users for the purposes of granting permissions (e.g. specifying an ACL
    for an Object). Roles are specified by their sets of child users and
    child roles, all of which are granted any permissions that the parent
    role has.

    <p>Roles must have a name (which cannot be changed after creation of the
    role), and must specify an ACL.</p>
     * @class  * A AV.Role is a local representation of a role persisted to the AV
    cloud.
    */
    declare class Role mixins Object {
        constructor(name: string, acl: AV$ACL): this;
        getRoles(): AV$Relation;
        getUsers(): AV$Relation;
        getName(): string;
        setName(name: string, options?: AV$SuccessFailureOptions): any
    }


    /**
     * 
     * @class  *
    <p>A AV.User object is a local representation of a user persisted to the
    AV cloud. This class is a subclass of a AV.Object, and retains the
    same functionality of a AV.Object, but also extends it with various
    user specific methods, like authentication, signing up, and validation of
    uniqueness.</p>
    */
    declare class User mixins Object {
        current(): AV$User;
        signUp<T>(
            username: string,
            password: string,
            attrs: any,
            options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logIn<T>(
            username: string,
            password: string,
            options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logOut<T>(): AV$Promise<T>;
        allowCustomUserClass(isAllowed: boolean): void;
        become<T>(sessionToken: string, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        requestPasswordReset<T>(email: string, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        signUp<T>(attrs: any, options?: AV$SuccessFailureOptions): AV$Promise<T>;
        logIn<T>(options?: AV$SuccessFailureOptions): AV$Promise<T>;
        fetch<T>(options?: AV$SuccessFailureOptions): AV$Promise<T>;
        save<T>(arg1?: any, arg2?: any, arg3?: any): AV$Promise<T>;
        authenticated(): boolean;
        isCurrent(): boolean;
        getEmail(): string;
        setEmail(email: string, options: AV$SuccessFailureOptions): boolean;
        getUsername(): string;
        setUsername(username: string, options?: AV$SuccessFailureOptions): boolean;
        setPassword(password: string, options?: AV$SuccessFailureOptions): boolean;
        getSessionToken(): string
    }


    declare     var npm$namespace$Analytics: {
        track: typeof Analytics$track,
    }
    declare     function Analytics$track<T>(name: string, dimensions: any): AV$Promise<T >

        declare class Error {
            code: ErrorCode;
            message: string;
            constructor(code: ErrorCode, message: string): this
        }

    declare type Op$BaseOperation = {
        objects(): any[]
    } & AV$IBaseObject


    declare type Op$Add = {} & Op$BaseOperation


    declare type Op$AddUnique = {} & Op$BaseOperation


    declare type Op$Increment = {
        amount: number
    } & AV$IBaseObject


    declare type Op$Relation = {
        added(): AV$Object[],
        removed: AV$Object[]
    } & AV$IBaseObject


    declare type Op$Set = {
        value(): any
    } & AV$IBaseObject


    declare type Op$Unset = {} & AV$IBaseObject



    declare     var npm$namespace$Push: {
        send: typeof Push$send,
    }
    declare     function Push$send<T>(data: Push$PushData, options?: Push$SendOptions): AV$Promise<T >

        declare interface Push$PushData {
            channels?: string[],
                push_time?: Date,
                expiration_time?: Date,
                expiration_interval?: number,
                where?: AV$Query,
                data?: any,
                alert?: string,
                badge?: string,
                sound?: string,
                title?: string
        }

    declare interface Push$SendOptions {
        success?: () => void,
            error?: (error: AV$Error) => void
    }


    /**
     * Call this method first to set up your authentication tokens for AV.
     * @param  Your Application ID.
     * @param  Your Application Key.
     * @param  (optional) Your Application Master Key. (Node.js only!)
     */
    declare     function AV$initialize(applicationId: string, applicationKey: string, masterKey?: string): void
    declare module.exports: typeof AV
}
declare module 'leanengine' {
    declare module.exports: typeof alias
}