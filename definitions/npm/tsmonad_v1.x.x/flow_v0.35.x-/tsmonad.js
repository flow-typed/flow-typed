// @flow
/**
 * Flowtype definitions for tsmonad
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$TsMonad: {
        writer: typeof TsMonad$writer,
    }
    /**
     * 
     * @name  WriterPatterns
     * @description  Define a contract to unwrap Writer object using a
    callback.
     * @see  Writer#
    */
declare interface TsMonad$WriterPatterns<S, T, U>{

    /**
     * 
     * @name  writer
     * @description  Function to handle the Writer content.
     * @type  : S[], value: T) => U}
     */
    writer: (story: S[], value: T) => U
}


/**
 * 
 * @name  writer
 * @description  Build a Writer object.
 * @function  * 
 * @param  The collection to store logs.
 * @param  The object to wrap.
 * @returns  A Writer object containing the log collection
and the wrapped value.
 * @see  Writer#
*/
declare function TsMonad$writer<S, T>(story: S[], value: T): TsMonad$Writer<S, T >


    /**
     * 
     * @name  Writer
     * @class  Allow to do computations while making sure that all the log
    values are combined into one log value that then gets attached to
    the result.
    */
    declare class Writer<S, T>mixins Monad<T>, Eq<TsMonad$Writer<S, T >> {

        /**
         * 
         * @description  Build a Writer object. For internal use only.
         * @constructor  * 
         * @methodOf  Writer#
         * @param  The collection of logs.
         * @param  The object to wrap.
         */
        constructor(story: S[], value: T): this;

        /**
         * 
         * @name  writer
         * @description  Helper function to build a Writer object.
         * @methodOf  Writer#
         * @static  * 
         * @param  The collection of logs.
         * @param  The object to wrap.
         * @returns  A Writer object containing the collection of logs
        and the wrapped value.
        */
        writer<S,
        T>(story: S[], value: T): TsMonad$Writer<S,
        T>;

        /**
         * 
         * @name  writer
         * @description  Helper function to build a Writer object with the log
        passed in input only.
         * @methodOf  Writer#
         * @static  * 
         * @param  A log to store.
         * @returns  A Writer object containing the collection of logs
        and a zeroed value.
        */
        tell<S>(s: S): TsMonad$Writer<S,
        number>;

        /**
         * 
         * @name  unit
         * @description  Wrap an object inside a Writer.
         * @public  * 
         * @methodOf  Writer#
         * @param  The object to wrap.
         * @returns  A Writer with the value wrapped inside and an
        empty collection of logs.
         * @see  Monad#unit
        */
        unit<U>(u: U): TsMonad$Writer<any,
        U>;

        /**
         * : T) => Writer<S, U>} f Function applied on the Writer content.
         * @name  bind
         * @description  Apply the function passed as parameter on the object.
         * @methodOf  Writer#
         * @public  * 
         * @returns  The result of the function f append to the
        Writer object.
         * @see  Monad#bind
        */
        bind<U>(f: (t: T) => TsMonad$Writer<S, U>): TsMonad$Writer<S,
        U>;

        /**
         * 
         * @name  of
         * @description  Alias for unit.
         * @methodOf  Writer#
         * @public  * 
         * @see  Writer#unit
         * @see  Monad#of
         */
        of:<U>(u: U) => TsMonad$Writer<any,
        U>;

        /**
         * 
         * @name  chain
         * @description  Alias for bind
         * @methodOf  Writer#
         * @public  * 
         * @see  Writer#unit
         * @see  Monad#of
         */
        chain:<U>(f: (t: T) => TsMonad$Writer<S, U>) => TsMonad$Writer<S,
        U>;

        /**
         * : T) => U} f Function applied on the wrapped value.
         * @name  fmap
         * @description  Apply the function passed as parameter on the object.
         * @methodOf  Writer#
         * @public  * 
         * @returns  The result of the function f wrapped inside
        an Writer object. It has an empty collection of logs.
         * @see  Functor#fmap
        */
        fmap<U>(f: (t: T) => U): TsMonad$Writer<S,
        U>;

        /**
         * 
         * @name  lift
         * @description  Alias for fmap
         * @methodOf  Writer#
         * @public  * 
         * @see  Writer#fmap
         * @see  Monad#of
         */
        lift:<U>(f: (t: T) => U) => TsMonad$Writer<S,
        U>;

        /**
         * 
         * @name  map
         * @description  Alias for fmap
         * @methodOf  Writer#
         * @public  * 
         * @see  Writer#fmap
         * @see  Monad#of
         */
        map:<U>(f: (t: T) => U) => TsMonad$Writer<S,
        U>;

        /**
         * 
         * @name  caseOf
         * @description  Execute a function on the Writer content. It allows to
        unwrap the object.
         * @methodOf  Writer#
         * @public  * 
         * @param  Object containing the
        functions to applied on the Writer content.
         * @return  The returned value of the function specified in the
        WriterPatterns interface.
         * @see  WriterPatterns#
        */
        caseOf<U>(patterns: TsMonad$WriterPatterns<S, T, U>): U;

        /**
         * 
         * @name  equals
         * @description  Compare the type and the content of two Writer
        objects.
         * @methodOf  Writer#
         * @public  * 
         * @param  The Writer to compare with.
         * @return  True if the collection of logs and content value
        are equals, false otherwise.
         * @see  Eq#equals
        */
        equals(other: TsMonad$Writer<S, T>): boolean
    }
declare var module: {
    exports: any,
    require(id: string): any,
    id: string,
    filename: string,
    loaded: boolean,
    parent: any,
    children: any[]
};
declare module 'tsmonad' {
    declare module.exports: typeof TsMonad
}