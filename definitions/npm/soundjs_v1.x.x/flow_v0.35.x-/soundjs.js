/**
 * Flowtype definitions for soundjs
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export class AbstractPlugin {
    create(
        src: string,
        startTime: number,
        duration: number): createjs$AbstractSoundInstance;
    getVolume(): number;
    isPreloadComplete(src: string): boolean;
    isPreloadStarted(src: string): boolean;
    isSupported(): boolean;
    preload(loader: Object): void;
    register(loadItem: string, instances: number): Object;
    removeAllSounds(src: string): void;
    removeSound(src: string): void;
    setMute(value: boolean): boolean;
    setVolume(value: number): boolean
}

declare export class AbstractSoundInstance mixins EventDispatcher {
    constructor(src: string, startTime: number, duration: number, playbackResource: Object): this;
    duration: number;
    loop: number;
    muted: boolean;
    pan: number;
    paused: boolean;
    playbackResource: Object;
    playState: string;
    position: number;
    src: string;
    uniqueId: number | string;
    volume: number;
    destroy(): void;
    getDuration(): number;
    getLoop(): number;
    getMute(): boolean;
    getPan(): number;
    getPaused(): boolean;
    getPosition(): number;
    getVolume(): number;
    play(
        interrupt?: string | Object,
        delay?: number,
        offset?: number,
        loop?: number,
        volume?: number,
        pan?: number): createjs$AbstractSoundInstance;
    setDuration(value: number): createjs$AbstractSoundInstance;
    setLoop(value: number): void;
    setMute(value: boolean): createjs$AbstractSoundInstance;
    setPan(value: number): createjs$AbstractSoundInstance;
    setPlayback(value: Object): createjs$AbstractSoundInstance;
    setPosition(value: number): createjs$AbstractSoundInstance;
    setVolume(value: number): createjs$AbstractSoundInstance;
    stop(): createjs$AbstractSoundInstance
}

declare export class FlashAudioLoader mixins AbstractLoader {
    flashId: string;
    setFlash(flash: Object): void
}

declare export class FlashAudioPlugin mixins AbstractPlugin {
    flashReady: boolean;
    showOutput: boolean;
    swfPath: string;
    isSupported(): boolean
}

declare export class FlashAudioSoundInstance mixins AbstractSoundInstance {
    constructor(src: string, startTime: number, duration: number, playbackResource: Object): this
}


/**
 * 
 * @deprecated  - use FlashAudioPlugin
 */
declare export class FlashPlugin {
    constructor(): this;
    buildDate: string;
    flashReady: boolean;
    showOutput: boolean;
    swfPath: string;
    version: string;
    create(src: string): createjs$AbstractSoundInstance;
    getVolume(): number;
    isPreloadStarted(src: string): boolean;
    isSupported(): boolean;
    preload(src: string, instance: Object): void;
    register(src: string, instances: number): Object;
    removeAllSounds(): void;
    removeSound(src: string): void;
    setMute(value: boolean): boolean;
    setVolume(value: number): boolean
}

declare export class HTMLAudioPlugin mixins AbstractPlugin {
    constructor(): this;
    defaultNumChannels: number;
    enableIOS: boolean;
    MAX_INSTANCES: number;
    isSupported(): boolean
}

declare export class HTMLAudioSoundInstance mixins AbstractSoundInstance {
    constructor(src: string, startTime: number, duration: number, playbackResource: Object): this
}

declare export class HTMLAudioTagPool {}

declare export class PlayPropsConfig {
    delay: number;
    duration: number;
    interrupt: string;
    loop: number;
    offset: number;
    pan: number;
    startTime: number;
    volume: number;
    create(value: createjs$PlayPropsConfig | any): createjs$PlayPropsConfig;
    set(props: any): createjs$PlayPropsConfig
}

declare export class Sound mixins EventDispatcher {
    activePlugin: Object;
    alternateExtensions: any[];
    defaultInterruptBehavior: string;
    EXTENSION_MAP: Object;
    INTERRUPT_ANY: string;
    INTERRUPT_EARLY: string;
    INTERRUPT_LATE: string;
    INTERRUPT_NONE: string;
    PLAY_FAILED: string;
    PLAY_FINISHED: string;
    PLAY_INITED: string;
    PLAY_INTERRUPTED: string;
    PLAY_SUCCEEDED: string;
    SUPPORTED_EXTENSIONS: string[];
    muted: boolean;
    volume: number;
    capabilities: any;
    createInstance(src: string): createjs$AbstractSoundInstance;
    getCapabilities(): Object;
    getCapability(key: string): number | boolean;
    getMute(): boolean;
    getVolume(): number;
    initializeDefaultPlugins(): boolean;
    isReady(): boolean;
    loadComplete(src: string): boolean;
    play(
        src: string,
        interrupt?: any,
        delay?: number,
        offset?: number,
        loop?: number,
        volume?: number,
        pan?: number): createjs$AbstractSoundInstance;
    registerManifest(manifest: Object[], basePath: string): Object;
    registerPlugins(plugins: any[]): boolean;
    registerSound(
        src: string | Object,
        id?: string,
        data?: number | Object,
        basePath?: string): Object;
    registerSounds(sounds: Object[], basePath?: string): Object[];
    removeAllSounds(): void;
    removeManifest(manifest: any[], basePath: string): Object;
    removeSound(src: string | Object, basePath: string): boolean;
    setMute(value: boolean): boolean;
    setVolume(value: number): void;
    stop(): void;
    addEventListener(
        type: string,
        listener: (eventObj: Object) => boolean,
        useCapture?: boolean): Function;
    addEventListener(
        type: string,
        listener: (eventObj: Object) => void,
        useCapture?: boolean): Function;
    addEventListener(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => boolean
        },
        useCapture?: boolean): Object;
    addEventListener(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => void
        },
        useCapture?: boolean): Object;
    dispatchEvent(eventObj: Object | string | Event, target?: Object): boolean;
    hasEventListener(type: string): boolean;
    off(
        type: string,
        listener: (eventObj: Object) => boolean,
        useCapture?: boolean): void;
    off(type: string, listener: (eventObj: Object) => void, useCapture?: boolean): void;
    off(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => boolean
        },
        useCapture?: boolean): void;
    off(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => void
        },
        useCapture?: boolean): void;
    off(type: string, listener: Function, useCapture?: boolean): void;
    on(
        type: string,
        listener: (eventObj: Object) => boolean,
        scope?: Object,
        once?: boolean,
        data?: any,
        useCapture?: boolean): Function;
    on(
        type: string,
        listener: (eventObj: Object) => void,
        scope?: Object,
        once?: boolean,
        data?: any,
        useCapture?: boolean): Function;
    on(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => boolean
        },
        scope?: Object,
        once?: boolean,
        data?: any,
        useCapture?: boolean): Object;
    on(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => void
        },
        scope?: Object,
        once?: boolean,
        data?: any,
        useCapture?: boolean): Object;
    removeAllEventListeners(type?: string): void;
    removeEventListener(
        type: string,
        listener: (eventObj: Object) => boolean,
        useCapture?: boolean): void;
    removeEventListener(type: string, listener: (eventObj: Object) => void, useCapture?: boolean): void;
    removeEventListener(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => boolean
        },
        useCapture?: boolean): void;
    removeEventListener(
        type: string,
        listener: {
            handleEvent: (eventObj: Object) => void
        },
        useCapture?: boolean): void;
    removeEventListener(type: string, listener: Function, useCapture?: boolean): void;
    toString(): string;
    willTrigger(type: string): boolean
}

declare export class SoundJS {
    buildDate: string;
    version: string
}

declare export class WebAudioLoader {
    context: AudioContext
}

declare export class WebAudioPlugin mixins AbstractPlugin {
    constructor(): this;
    context: AudioContext;
    context: AudioContext;
    dynamicsCompressorNode: DynamicsCompressorNode;
    gainNode: GainNode;
    isSupported(): boolean;
    playEmptySound(): void
}

declare export class WebAudioSoundInstance mixins AbstractSoundInstance {
    constructor(src: string, startTime: number, duration: number, playbackResource: Object): this;
    context: AudioContext;
    destinationNode: AudioNode;
    gainNode: GainNode;
    panNode: PannerNode;
    sourceNode: AudioNode
}