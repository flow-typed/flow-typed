/**
 * Flowtype definitions for vexflow
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
function sanitizeDuration(duration: string): string
declare
var npm$namespace$Vex: {
    L: typeof Vex$L,
    Merge: typeof Vex$Merge,
    Min: typeof Vex$Min,
    Max: typeof Vex$Max,
    RoundN: typeof Vex$RoundN,
    MidLine: typeof Vex$MidLine,
    SortAndUnique: typeof Vex$SortAndUnique,
    Contains: typeof Vex$Contains,
    getCanvasContext: typeof Vex$getCanvasContext,
    drawDot: typeof Vex$drawDot,
    BM: typeof Vex$BM,
    Inherit: typeof Vex$Inherit,
}
declare
function Vex$L(block: string, args: any[]): void

declare
function Vex$Merge<T>(destination: T, source: Object): T

declare
function Vex$Min(a: number, b: number): number

declare
function Vex$Max(a: number, b: number): number

declare
function Vex$RoundN(x: number, n: number): number

declare
function Vex$MidLine(a: number, b: number): number

declare
function Vex$SortAndUnique<T>(arr: T, cmp: Function, eq: Function): T

declare
function Vex$Contains(a: any[], obj: any): boolean

declare
function Vex$getCanvasContext(canvas_sel: string): CanvasRenderingContext2D

declare
function Vex$drawDot(ctx: Vex$IRenderContext, x: number, y: number, color?: string): void

declare
function Vex$BM(s: number, f: Function): void

declare
function Vex$Inherit<T>(child: T, parent: Object, object: Object): T

declare class RuntimeError {
    constructor(code: string, message: string): this
}

declare class RERR {
    constructor(code: string, message: string): this
}


/**
 * Helper interface for handling the different rendering contexts (i.e. CanvasContext, RaphaelContext, SVGContext). Not part of VexFlow!
 */
declare interface Vex$IRenderContext {
    clear(): void,
        setFont(family: string, size: number, weight?: number): Vex$IRenderContext,
        setRawFont(font: string): Vex$IRenderContext,
        setFillStyle(style: string): Vex$IRenderContext,
        setBackgroundFillStyle(style: string): Vex$IRenderContext,
        setStrokeStyle(style: string): Vex$IRenderContext,
        setShadowColor(color: string): Vex$IRenderContext,
        setShadowBlur(blur: string): Vex$IRenderContext,
        setLineWidth(width: number): Vex$IRenderContext,
        setLineCap(cap_type: string): Vex$IRenderContext,
        setLineDash(dash: string): Vex$IRenderContext,
        scale(x: number, y: number): Vex$IRenderContext,
        resize(width: number, height: number): Vex$IRenderContext,
        fillRect(x: number, y: number, width: number, height: number): Vex$IRenderContext,
        clearRect(x: number, y: number, width: number, height: number): Vex$IRenderContext,
        beginPath(): Vex$IRenderContext,
        moveTo(x: number, y: number): Vex$IRenderContext,
        lineTo(x: number, y: number): Vex$IRenderContext,
        bezierCurveToTo(
            x1: number,
            y1: number,
            x2: number,
            y2: number,
            x: number,
            y: number): Vex$IRenderContext,
        quadraticCurveToTo(x1: number, y1: number, x2: number, y2: number): void,
        arc(
            x: number,
            y: number,
            radius: number,
            startAngle: number,
            endAngle: number,
            antiClockwise: boolean): Vex$IRenderContext,
        glow(): Vex$IRenderContext,
        fill(): Vex$IRenderContext,
        stroke(): Vex$IRenderContext,
        closePath(): Vex$IRenderContext,
        fillText(text: string, x: number, y: number): Vex$IRenderContext,
        save(): Vex$IRenderContext,
        restore(): Vex$IRenderContext,

        /**
         * canvas returns TextMetrics, SVG returns SVGRect, Raphael returns {width : number, height : number}. Only width is used throughout VexFlow.
         */
        measureText(text: string): {
            width: number
        }
}


/**
 * Helper interface for handling the Vex.Flow.Font object in Vex.Flow.Glyph. Not part of VexFlow!
 */
declare interface Vex$IFont {
    glyphs: {
            x_min: number,
            x_max: number,
            ha: number,
            o: string[]
        }[],
        cssFontWeight: string,
        ascender: number,
        underlinePosition: number,
        cssFontStyle: string,
        boundingBox: {
            yMin: number,
            xMin: number,
            yMax: number,
            xMax: number
        },
        resolution: number,
        descender: number,
        familyName: string,
        lineHeight: number,
        underlineThickness: number,

        /**
         * This property is missing in vexflow_font.js, but present in gonville_original.js and gonville_all.js.
         */
        original_font_information?: {
            postscript_name: string,
            version_string: string,
            vendor_url: string,
            full_font_name: string,
            font_family_name: string,
            copyright: string,
            description: string,
            trademark: string,
            designer: string,
            designer_url: string,
            unique_font_identifier: string,
            license_url: string,
            license_description: string,
            manufacturer_name: string,
            font_sub_family_name: string
        }
}


declare
var npm$namespace$Flow: {
    clefProperties: typeof Flow$clefProperties,
    keyProperties: typeof Flow$keyProperties,
    integerToNote: typeof Flow$integerToNote,
    tabToGlyph: typeof Flow$tabToGlyph,
    textWidth: typeof Flow$textWidth,
    articulationCodes: typeof Flow$articulationCodes,
    accidentalCodes: typeof Flow$accidentalCodes,
    ornamentCodes: typeof Flow$ornamentCodes,
    keySignature: typeof Flow$keySignature,
    parseNoteDurationString: typeof Flow$parseNoteDurationString,
    parseNoteData: typeof Flow$parseNoteData,
    durationToFraction: typeof Flow$durationToFraction,
    durationToNumber: typeof Flow$durationToNumber,
    durationToTicks: typeof Flow$durationToTicks,
    durationToGlyph: typeof Flow$durationToGlyph,
    renderGlyph: typeof Flow$renderGlyph,
}
declare
var RESOLUTION: number;

declare
var STEM_WIDTH: number;

declare
var STEM_HEIGHT: number;

declare
var STAVE_LINE_THICKNESS: number;

declare
var TIME4_4: {
    num_beats: number,
    beat_value: number,
    resolution: number
};

declare
var unicode: {
    [name: string]: string
};

declare
function Flow$clefProperties(clef: string): {
    line_shift: number
}

declare
function Flow$keyProperties(
    key: string,
    clef: string,
    params: {
        octave_shift?: number
    }): {
    key: string,
    octave: number,
    line: number,
    int_value: number,
    accidental: string,
    code: number,
    stroke: number,
    shift_right: number,
    displaced: boolean
}

declare
function Flow$integerToNote(integer: number): string

declare
function Flow$tabToGlyph(fret: string): {
    text: string,
    code: number,
    width: number,
    shift_y: number
}

declare
function Flow$textWidth(text: string): number

declare
function Flow$articulationCodes(
    artic: string): {
    code: string,
    width: number,
    shift_right: number,
    shift_up: number,
    shift_down: number,
    between_lines: boolean
}

declare
function Flow$accidentalCodes(
    acc: string): {
    code: string,
    width: number,
    gracenote_width: number,
    shift_right: number,
    shift_down: number
}

declare
function Flow$ornamentCodes(
    acc: string): {
    code: string,
    shift_right: number,
    shift_up: number,
    shift_down: number,
    width: number
}

declare
function Flow$keySignature(spec: string): {
    type: string,
    line: number
}[]

declare
function Flow$parseNoteDurationString(durationString: string): {
    duration: string,
    dots: number,
    type: string
}

declare
function Flow$parseNoteData(
    noteData: {
        duration: string,
        dots: number,
        type: string
    }): {
    duration: string,
    type: string,
    dots: number,
    ticks: number
}

declare
function Flow$durationToFraction(duration: string): Flow$Fraction

declare
function Flow$durationToNumber(duration: string): number

declare
function Flow$durationToTicks(duration: string): number

declare
function Flow$durationToGlyph(
    duration: string,
    type: string): {
    head_width: number,
    stem: boolean,
    stem_offset: number,
    flag: boolean,
    stem_up_extension: number,
    stem_down_extension: number,
    gracenote_stem_up_extension: number,
    gracenote_stem_down_extension: number,
    tabnote_stem_up_extension: number,
    tabnote_stem_down_extension: number,
    dot_shiftY: number,
    line_above: number,
    line_below: number,
    code_head?: string,
    rest?: boolean,
    position?: string
}

declare
function Flow$renderGlyph(
    ctx: Vex$IRenderContext,
    x_pos: number,
    y_pos: number,
    point: number,
    val: string,
    nocache: boolean): void

declare
var Font: {
    glyphs: {
        x_min: number,
        x_max: number,
        ha: number,
        o: string[]
    }[],
    cssFontWeight: string,
    ascender: number,
    underlinePosition: number,
    cssFontStyle: string,
    boundingBox: {
        yMin: number,
        xMin: number,
        yMax: number,
        xMax: number
    },
    resolution: number,
    descender: number,
    familyName: string,
    lineHeight: number,
    underlineThickness: number,
    original_font_information: {
        postscript_name: string,
        version_string: string,
        vendor_url: string,
        full_font_name: string,
        font_family_name: string,
        copyright: string,
        description: string,
        trademark: string,
        designer: string,
        designer_url: string,
        unique_font_identifier: string,
        license_url: string,
        license_description: string,
        manufacturer_name: string,
        font_sub_family_name: string
    }
};

declare class Accidental mixins Modifier {
    setNote(note: Flow$Note): Flow$Modifier;
    constructor(type: string): this;
    DEBUG: boolean;
    format(
        accidentals: Flow$Accidental[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): void;
    setNote(note: Flow$StaveNote): void;
    setAsCautionary(): Flow$Accidental;
    draw(): void;
    applyAccidentals(voices: Flow$Voice[], keySignature?: string): void
}

declare
var CATEGORY: string;

declare class Annotation mixins Modifier {
    constructor(text: string): this;
    DEBUG: boolean;
    format(
        annotations: Flow$Annotation[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    setTextLine(line: number): Flow$Annotation;
    setFont(family: string, size: number, weight: string): Flow$Annotation;
    setVerticalJustification(just: Annotation$VerticalJustify): Flow$Annotation;
    getJustification(): Annotation$Justify;
    setJustification(justification: Annotation$Justify): Flow$Annotation;
    draw(): void
}

declare
var CATEGORY: string;

declare class Articulation mixins Modifier {
    constructor(type: string): this;
    DEBUG: boolean;
    format(
        articulations: Flow$Articulation[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    draw(): void
}

declare
var CATEGORY: string;

declare class BarNote mixins Note {
    DEBUG: boolean;
    getType(): Barline$type;
    setType(type: Barline$type): Flow$BarNote;
    getBoundingBox(): Flow$BoundingBox;
    addToModifierContext(): Flow$BarNote;
    preFormat(): Flow$BarNote;
    draw(): void
}



declare class Barline mixins StaveModifier {
    constructor(type: Barline$type, x: number): this;
    getCategory(): string;
    setX(x: number): Flow$Barline;
    draw(stave: Flow$Stave, x_shift?: number): void;
    drawVerticalBar(stave: Flow$Stave, x: number, double_bar?: boolean): void;
    drawVerticalEndBar(stave: Flow$Stave, x: number): void;
    drawRepeatBar(stave: Flow$Stave, x: number, begin: boolean): void
}

declare class Beam {
    constructor(notes: Flow$StemmableNote[], auto_stem?: boolean): this;
    setContext(context: Vex$IRenderContext): Flow$Beam;
    getNotes(): Flow$StemmableNote[];
    getBeamCount(): number;
    breakSecondaryAt(indices: number[]): Flow$Beam;
    getSlopeY(): number;
    calculateSlope(): void;
    applyStemExtensions(): void;
    getBeamLines(duration: string): {
        start: number,
        end: number
    }[];
    drawStems(): void;
    drawBeamLines(): void;
    preFormat(): Flow$Beam;
    postFormat(): Flow$Beam;
    draw(): boolean;
    calculateStemDirection(notes: Flow$Note): number;
    getDefaultBeamGroups(time_sig: string): Flow$Fraction[];
    applyAndGetBeams(
        voice: Flow$Voice,
        stem_direction: number,
        groups: Flow$Fraction[]): Flow$Beam[];
    generateBeams(
        notes: Flow$StemmableNote[],
        config?: {
            groups?: Flow$Fraction[],
            stem_direction?: number,
            beam_rests?: boolean,
            beam_middle_only?: boolean,
            show_stemlets?: boolean,
            maintain_stem_directions?: boolean
        }): Flow$Beam[]
}

declare class Bend mixins Modifier {
    constructor(text: string, release?: boolean, phrase?: {
        type: number,
        text: string,
        width: number
    }[]): this;
    UP: number;
    DOWN: number;
    format(
        bends: Flow$Bend[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    setXShift(value: number): void;
    setFont(font: string): Flow$Bend;
    getText(): string;
    updateWidth(): Flow$Bend;
    draw(): void
}

declare
var CATEGORY: string;

declare class BoundingBox {
    constructor(x: number, y: number, w: number, h: number): this;
    copy(that: Flow$BoundingBox): Flow$BoundingBox;
    getX(): number;
    getY(): number;
    getW(): number;
    getH(): number;
    setX(x: number): Flow$BoundingBox;
    setY(y: number): Flow$BoundingBox;
    setW(w: number): Flow$BoundingBox;
    setH(h: number): Flow$BoundingBox;
    move(x: number, y: number): void;
    clone(): Flow$BoundingBox;
    mergeWith(boundingBox: Flow$BoundingBox, ctx?: Vex$IRenderContext): Flow$BoundingBox;
    draw(ctx: Vex$IRenderContext, x: number, y: number): void
}

declare class CanvasContext mixins IRenderContext {
    setLineDash(dash: string): Flow$CanvasContext;
    scale(x: number, y: number): Flow$CanvasContext;
    resize(width: number, height: number): Flow$CanvasContext;
    fillRect(x: number, y: number, width: number, height: number): Flow$CanvasContext;
    clearRect(x: number, y: number, width: number, height: number): Flow$CanvasContext;
    beginPath(): Flow$CanvasContext;
    moveTo(x: number, y: number): Flow$CanvasContext;
    lineTo(x: number, y: number): Flow$CanvasContext;
    bezierCurveToTo(
        x1: number,
        y1: number,
        x2: number,
        y2: number,
        x: number,
        y: number): Flow$CanvasContext;
    quadraticCurveToTo(x1: number, y1: number, x2: number, y2: number): Flow$CanvasContext;
    arc(
        x: number,
        y: number,
        radius: number,
        startAngle: number,
        endAngle: number,
        antiClockwise: boolean): Flow$CanvasContext;
    glow(): Flow$CanvasContext;
    fill(): Flow$CanvasContext;
    stroke(): Flow$CanvasContext;
    closePath(): Flow$CanvasContext;
    fillText(text: string, x: number, y: number): Flow$CanvasContext;
    save(): Flow$CanvasContext;
    restore(): Flow$CanvasContext;
    constructor(context: CanvasRenderingContext2D): this;
    WIDTH: number;
    HEIGHT: number;
    clear(): void;
    setFont(family: string, size: number, weight?: number): Flow$CanvasContext;
    setRawFont(font: string): Flow$CanvasContext;
    setFillStyle(style: string): Flow$CanvasContext;
    setBackgroundFillStyle(style: string): Flow$CanvasContext;
    setStrokeStyle(style: string): Flow$CanvasContext;
    setShadowColor(style: string): Flow$CanvasContext;
    setShadowBlur(blur: string): Flow$CanvasContext;
    setLineWidth(width: number): Flow$CanvasContext;
    setLineCap(cap_type: string): Flow$CanvasContext;
    setLineDash(dash: string): void;
    scale(x: number, y: number): void;
    resize(width: number, height: number): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    clearRect(x: number, y: number, width: number, height: number): void;
    beginPath(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    bezierCurveToTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    quadraticCurveToTo(x1: number, y1: number, x: number, y: number): void;
    arc(
        x: number,
        y: number,
        radius: number,
        startAngle: number,
        endAngle: number,
        antiClockwise: boolean): void;
    glow(): void;
    fill(): void;
    stroke(): void;
    closePath(): void;
    measureText(text: string): TextMetrics;
    fillText(text: string, x: number, y: number): void;
    save(): void;
    restore(): void
}

declare class Clef mixins StaveModifier {
    addModifier(): void;
    addEndModifier(): void;
    constructor(clef: string, size?: string, annotation?: string): this;
    DEBUG: boolean;
    addModifier(stave: Flow$Stave): void;
    addEndModifier(stave: Flow$Stave): void
}

declare class ClefNote mixins Note {
    setStave(stave: Flow$Stave): Flow$Note;
    constructor(clef: string, size?: string, annotation?: string): this;
    setClef(clef: string, size?: string, annotation?: string): Flow$ClefNote;
    getClef(): string;
    setStave(stave: Flow$Stave): void;
    getBoundingBox(): Flow$BoundingBox;
    addToModifierContext(): Flow$ClefNote;
    getCategory(): string;
    preFormat(): Flow$ClefNote;
    draw(): void
}

declare class Crescendo mixins Note {
    constructor(note_struct: {
        duration: number,
        line?: number
    }): this;
    DEBUG: boolean;
    setLine(line: number): Flow$Crescendo;
    setHeight(height: number): Flow$Crescendo;
    setDecrescendo(decresc: boolean): Flow$Crescendo;
    preFormat(): Flow$Crescendo;
    draw(): void
}

declare class Curve {
    constructor(from: Flow$Note, to: Flow$Note, options?: {
        spacing?: number,
        thickness?: number,
        x_shift?: number,
        y_shift: number,
        position: Curve$Position,
        invert: boolean,
        cps?: {
            x: number,
            y: number
        }[]
    }): this;
    DEBUG: boolean;
    setContext(context: Vex$IRenderContext): Flow$Curve;
    setNotes(from: Flow$Note, to: Flow$Note): Flow$Curve;
    isPartial(): boolean;
    renderCurve(
        params: {
            first_x: number,
            first_y: number,
            last_x: number,
            last_y: number,
            direction: number
        }): void;
    draw(): boolean
}



declare class Dot mixins Modifier {
    setNote(note: Flow$Note): Flow$Dot;
    format(
        dots: number,
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): void;
    setNote(note: Flow$Note): void;
    setDotShiftY(y: number): Flow$Dot;
    draw(): void
}

declare
var CATEGORY: string;

declare class Formatter {
    DEBUG: boolean;
    FormatAndDraw(
        ctx: Vex$IRenderContext,
        stave: Flow$Stave,
        notes: Flow$Note[],
        params?: {
            auto_beam: boolean,
            align_rests: boolean
        }): Flow$BoundingBox;
    FormatAndDraw(
        ctx: Vex$IRenderContext,
        stave: Flow$Stave,
        notes: Flow$Note[],
        params?: boolean): Flow$BoundingBox;
    FormatAndDrawTab(
        ctx: Vex$IRenderContext,
        tabstave: Flow$TabStave,
        stave: Flow$Stave,
        tabnotes: Flow$TabNote[],
        notes: Flow$Note[],
        autobeam?: boolean,
        params?: {
            auto_beam: boolean,
            align_rests: boolean
        }): void;
    FormatAndDrawTab(
        ctx: Vex$IRenderContext,
        tabstave: Flow$TabStave,
        stave: Flow$Stave,
        tabnotes: Flow$TabNote[],
        notes: Flow$Note[],
        autobeam?: boolean,
        params?: boolean): void;
    AlignRestsToNotes(
        notes: Flow$Note[],
        align_all_notes?: boolean,
        align_tuplets?: boolean): Flow$Formatter;
    alignRests(voices: Flow$Voice[], align_all_notes: boolean): void;
    preCalculateMinTotalWidth(voices: Flow$Voice[]): number;
    getMinTotalWidth(): number;
    createModifierContexts(voices: Flow$Voice[]): Flow$ModifierContext[];
    createTickContexts(voices: Flow$Voice[]): Flow$TickContext[];
    preFormat(
        justifyWidth?: number,
        rendering_context?: Vex$IRenderContext,
        voices?: Flow$Voice[],
        stave?: Flow$Stave): void;
    postFormat(): Flow$Formatter;
    joinVoices(voices: Flow$Voice[]): Flow$Formatter;
    format(
        voices: Flow$Voice[],
        justifyWidth: number,
        options?: {
            align_rests?: boolean,
            context: Vex$IRenderContext
        }): Flow$Formatter;
    formatToStave(
        voices: Flow$Voice[],
        stave: Flow$Stave,
        options?: {
            align_rests?: boolean,
            context: Vex$IRenderContext
        }): Flow$Formatter
}

declare class Fraction {
    constructor(numerator: number, denominator: number): this;
    GCD(a: number, b: number): number;
    LCM(a: number, b: number): number;
    LCMM(a: number, b: number): number;
    set(numerator: number, denominator: number): Flow$Fraction;
    value(): number;
    simplify(): Flow$Fraction;
    add(param1: Flow$Fraction, param2: Flow$Fraction): Flow$Fraction;
    add(param1: number, param2: number): Flow$Fraction;
    subtract(param1: Flow$Fraction, param2: Flow$Fraction): Flow$Fraction;
    subtract(param1: number, param2: number): Flow$Fraction;
    multiply(param1: Flow$Fraction, param2: Flow$Fraction): Flow$Fraction;
    multiply(param1: number, param2: number): Flow$Fraction;
    divide(param1: Flow$Fraction, param2: Flow$Fraction): Flow$Fraction;
    divide(param1: number, param2: number): Flow$Fraction;
    equals(compare: Flow$Fraction): boolean;
    greaterThan(compare: Flow$Fraction): boolean;
    greaterThanEquals(compare: Flow$Fraction): boolean;
    lessThan(compare: Flow$Fraction): boolean;
    lessThanEquals(compare: Flow$Fraction): boolean;
    clone(): Flow$Fraction;
    copy(copy: Flow$Fraction): Flow$Fraction;
    quotient(): number;
    fraction(): number;
    abs(): Flow$Fraction;
    toString(): string;
    toSimplifiedString(): string;
    toMixedString(): string;
    parse(str: string): Flow$Fraction
}

declare class FretHandFinger mixins Modifier {
    constructor(number: number): this;
    format(
        nums: Flow$FretHandFinger[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): void;
    getNote(): Flow$Note;
    setNote(note: Flow$Note): Flow$FretHandFinger;
    getIndex(): number;
    setIndex(index: number): Flow$FretHandFinger;
    getPosition(): Modifier$Position;
    setPosition(position: Modifier$Position): Flow$FretHandFinger;
    setFretHandFinger(number: number): Flow$FretHandFinger;
    setOffsetX(x: number): Flow$FretHandFinger;
    setOffsetY(y: number): Flow$FretHandFinger;
    draw(): void
}

declare
var CATEGORY: string;

declare class GhostNote mixins StemmableNote {
    setStave(stave: Flow$Stave): Flow$Note;
    constructor(duration: string): this;
    constructor(note_struct: {
        type?: string,
        dots?: number,
        duration: string
    }): this;
    isRest(): boolean;
    setStave(stave: Flow$Stave): void;
    addToModifierContext(): Flow$GhostNote;
    preFormat(): Flow$GhostNote;
    draw(): void
}

declare class Glyph {
    constructor(code: string, point: number, options?: {
        cache?: boolean,
        font?: Vex$IFont
    }): this;
    setOptions(options: {
        cache?: boolean,
        font?: Vex$IFont
    }): void;
    setStave(stave: Flow$Stave): Flow$Glyph;
    setXShift(x_shift: number): Flow$Glyph;
    setYShift(y_shift: number): Flow$Glyph;
    setContext(context: Vex$IRenderContext): Flow$Glyph;
    getContext(): Vex$IRenderContext;
    reset(): void;
    setWidth(width: number): Flow$Glyph;
    getMetrics(): {
        x_min: number,
        x_max: number,
        width: number,
        height: number
    };
    render(ctx: Vex$IRenderContext, x_pos: number, y_pos: number): void;
    renderToStave(x: number): void;
    loadMetrics(
        font: Vex$IFont,
        code: string,
        cache: boolean): {
        x_min: number,
        x_max: number,
        ha: number,
        outline: number[]
    };
    renderOutline(
        ctx: Vex$IRenderContext,
        outline: number[],
        scale: number,
        x_pos: number,
        y_pos: number): void
}

declare class GraceNote mixins StaveNote {
    constructor(note_struct: {
        slash?: boolean,
        type?: string,
        dots?: number,
        duration: string,
        clef?: string,
        keys: string[],
        octave_shift?: number,
        auto_stem?: boolean,
        stem_direction?: number
    }): this;
    getStemExtension(): number;
    getCategory(): string;
    draw(): void
}

declare class GraceNoteGroup mixins Modifier {
    setWidth(width: number): Flow$Modifier;
    setNote(note: Flow$StaveNote): Flow$Modifier;
    constructor(grace_notes: Flow$GraceNote[], show_slur?: boolean): this;
    DEBUG: boolean;
    format(
        gracenote_groups: Flow$GraceNoteGroup[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    preFormat(): void;
    beamNotes(): Flow$GraceNoteGroup;
    setNote(note: Flow$Note): void;
    setWidth(width: number): void;
    getWidth(): number;
    setXShift(x_shift: number): void;
    draw(): void
}

declare
var CATEGORY: string;

declare class KeyManager {
    constructor(key: string): this;
    setKey(key: string): Flow$KeyManager;
    getKey(): string;
    reset(): Flow$KeyManager;
    getAccidental(key: string): {
        note: string,
        accidental: string
    };
    selectNote(note: string): {
        note: string,
        accidental: string,
        change: boolean
    }
}

declare class KeySignature mixins StaveModifier {
    addModifier(): void;
    constructor(key_spec: string): this;
    addAccToStave(
        stave: Flow$Stave,
        acc: {
            type: string,
            line: number
        },
        next?: {
            type: string,
            line: number
        }): void;
    cancelKey(spec: string): Flow$KeySignature;
    addModifier(stave: Flow$Stave): Flow$KeySignature;
    addToStave(stave: Flow$Stave, firstGlyph?: boolean): Flow$KeySignature;
    convertAccLines(clef: string, type: string): void
}

declare class Modifier {
    DEBUG: boolean;
    getCategory(): string;
    getWidth(): number;
    setWidth(width: number): Flow$Modifier;
    getNote(): Flow$Note;
    setNote(note: Flow$Note): Flow$Modifier;
    getIndex(): number;
    setIndex(index: number): Flow$Modifier;
    getContext(): Vex$IRenderContext;
    setContext(context: Vex$IRenderContext): Flow$Modifier;
    getModifierContext(): Flow$ModifierContext;
    setModifierContext(c: Flow$ModifierContext): Flow$Modifier;
    getPosition(): Modifier$Position;
    setPosition(position: Modifier$Position): Flow$Modifier;
    setTextLine(line: number): Flow$Modifier;
    setYShift(y: number): Flow$Modifier;
    setXShift(x: number): void;
    draw(): void
}

declare
var CATEGORY: string;

declare class ModifierContext {
    DEBUG: boolean;
    addModifier(modifier: Flow$Modifier): Flow$ModifierContext;
    getModifiers(type: string): Flow$Modifier[];
    getWidth(): number;
    getExtraLeftPx(): number;
    getExtraRightPx(): number;
    getState(): {
        left_shift: number,
        right_shift: number,
        text_line: number
    };
    getMetrics(): {
        width: number,
        spacing: number,
        extra_left_px: number,
        extra_right_px: number
    };
    preFormat(): void;
    postFormat(): void
}

declare class Music {
    isValidNoteValue(note: number): boolean;
    isValidIntervalValue(interval: number): boolean;
    getNoteParts(noteString: string): {
        root: string,
        accidental: string
    };
    getKeyParts(noteString: string): {
        root: string,
        accidental: string,
        type: string
    };
    getNoteValue(noteString: string): number;
    getIntervalValue(intervalString: string): number;
    getCanonicalNoteName(noteValue: number): string;
    getCanonicalIntervalName(intervalValue: number): string;
    getRelativeNoteValue(noteValue: number, intervalValue: number, direction?: number): number;
    getRelativeNoteName(root: string, noteValue: number): string;
    getScaleTones(key: string, intervals: number[]): number;
    getIntervalBetween(note1: number, note2: number, direction?: number): number;
    createScaleMap(keySignature: string): {
        [rootName: string]: string
    }
}

declare
var NUM_TONES: number;

declare
var roots: string[];

declare
var root_values: number[];

declare
var root_indices: {
    [root: string]: number
};

declare
var canonical_notes: string[];

declare
var diatonic_intervals: string[];

declare
var diatonic_accidentals: {
    [diatonic_interval: string]: {
        note: number,
        accidental: number
    }
};

declare
var intervals: {
    [interval: string]: number
};

declare
var scales: {
    [scale: string]: number[]
};

declare
var accidentals: string[];

declare
var noteValues: {
    [value: string]: {
        root_index: number,
        int_val: number
    }
};

declare class Note mixins Tickable {
    getTicks(): Flow$Fraction;
    getCenterXShift(): number;
    isCenterAligned(): boolean;
    setCenterAlignment(align_center: boolean): Flow$Note;
    getTuplet(): Flow$Tuplet;
    setTuplet(tuplet: Flow$Tuplet): Flow$Note;
    addToModifierContext(mc: Flow$ModifierContext): void;
    preFormat(): void;
    postFormat(): Flow$Note;
    getIntrinsicTicks(): Flow$Fraction;
    setIntrinsicTicks(intrinsicTicks: Flow$Fraction): void;
    getTickMultiplier(): Flow$Fraction;
    applyTickMultiplier(numerator: number, denominator: number): void;
    setDuration(duration: Flow$Fraction): void;
    constructor(note_struct: {
        type?: string,
        dots?: number,
        duration: string
    }): this;
    getPlayNote(): any;
    setPlayNote(note: any): Flow$Note;
    isRest(): boolean;
    addStroke(index: number, stroke: Flow$Stroke): Flow$Note;
    getStave(): Flow$Stave;
    setStave(stave: Flow$Stave): Flow$Note;
    getCategory(): string;
    setContext(context: Vex$IRenderContext): Flow$Note;
    getExtraLeftPx(): number;
    getExtraRightPx(): number;
    setExtraLeftPx(x: number): Flow$Note;
    setExtraRightPx(x: number): Flow$Note;
    shouldIgnoreTicks(): boolean;
    getLineNumber(): number;
    getLineForRest(): number;
    getGlyph(): Flow$Glyph;
    setYs(ys: number[]): Flow$Note;
    getYs(): number[];
    getYForTopText(text_line: number): number;
    getBoundingBox(): Flow$BoundingBox;
    getVoice(): Flow$Voice;
    setVoice(voice: Flow$Voice): Flow$Note;
    getTickContext(): Flow$TickContext;
    setTickContext(tc: Flow$TickContext): Flow$Note;
    getDuration(): string;
    isDotted(): boolean;
    hasStem(): boolean;
    getDots(): number;
    getNoteType(): string;
    setBeam(): Flow$Note;
    setModifierContext(mc: Flow$ModifierContext): Flow$Note;
    addModifier(modifier: Flow$Modifier, index?: number): Flow$Note;
    getModifierStartXY(): {
        x: number,
        y: number
    };
    getMetrics(): {
        width: number,
        noteWidth: number,
        left_shift: number,
        modLeftPx: number,
        modRightPx: number,
        extraLeftPx: number,
        extraRightPx: number
    };
    setWidth(width: number): void;
    getWidth(): number;
    setXShift(x: number): Flow$Note;
    getX(): number;
    getAbsoluteX(): number;
    setPreFormatted(value: boolean): void
}

declare
var CATEGORY: string;

declare class NoteHead mixins Note {
    constructor(head_options: {
        x?: number,
        y?: number,
        note_type?: string,
        duration: string,
        displaced?: boolean,
        stem_direction?: number,
        line: number,
        x_shift: number,
        custom_glyph_code?: string,
        style?: string,
        slashed?: boolean,
        glyph_font_scale?: number
    }): this;
    DEBUG: boolean;
    getCategory(): string;
    setContext(context: Vex$IRenderContext): Flow$NoteHead;
    getWidth(): number;
    isDisplaced(): boolean;
    getStyle(): {
        shadowColor?: string,
        shadowBlur?: string,
        fillStyle?: string,
        strokeStyle?: string
    };
    setStyle(
        style: {
            shadowColor?: string,
            shadowBlur?: string,
            fillStyle?: string,
            strokeStyle?: string
        }): Flow$NoteHead;
    getGlyph(): Flow$Glyph;
    setX(x: number): Flow$NoteHead;
    getY(): number;
    setY(y: number): Flow$NoteHead;
    getLine(): number;
    setLine(line: number): Flow$NoteHead;
    getAbsoluteX(): number;
    getBoundingBox(): Flow$BoundingBox;
    applyStyle(context: Vex$IRenderContext): Flow$NoteHead;
    setStave(stave: Flow$Stave): Flow$NoteHead;
    preFormat(): Flow$NoteHead;
    draw(): void
}

declare class Ornament mixins Modifier {
    constructor(type: string): this;
    DEBUG: boolean;
    format(
        ornaments: Flow$Ornament[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    setDelayed(delayed: boolean): Flow$Ornament;
    setUpperAccidental(acc: string): Flow$Ornament;
    setLowerAccidental(acc: string): Flow$Ornament;
    draw(): void
}

declare
var CATEGORY: string;

declare class PedalMarking {
    constructor(notes: Flow$Note[]): this;
    DEBUG: boolean;
    createSustain(notes: Flow$Note[]): Flow$PedalMarking;
    createSostenuto(notes: Flow$Note[]): Flow$PedalMarking;
    createUnaCorda(notes: Flow$Note[]): Flow$PedalMarking;
    setCustomText(depress?: string, release?: string): Flow$PedalMarking;
    setStyle(style: PedalMarking$Styles): Flow$PedalMarking;
    setLine(line: number): Flow$PedalMarking;
    setContext(context: Vex$IRenderContext): Flow$PedalMarking;
    drawBracketed(): void;
    drawText(): void;
    draw(): void
}

declare
var GLYPHS: {
    [name: string]: {
        code: string,
        x_shift: number,
        y_shift: number
    }
};

declare class RaphaelContext mixins IRenderContext {
    setLineWidth(width: number): Flow$RaphaelContext;
    glow(): Flow$RaphaelContext;
    constructor(element: HTMLElement): this;
    setFont(family: string, size: number, weight?: number): Flow$RaphaelContext;
    setRawFont(font: string): Flow$RaphaelContext;
    setFillStyle(style: string): Flow$RaphaelContext;
    setBackgroundFillStyle(style: string): Flow$RaphaelContext;
    setStrokeStyle(style: string): Flow$RaphaelContext;
    setShadowColor(style: string): Flow$RaphaelContext;
    setShadowBlur(blur: string): Flow$RaphaelContext;
    setLineWidth(width: number): void;
    setLineDash(dash: string): Flow$RaphaelContext;
    setLineCap(cap_type: string): Flow$RaphaelContext;
    scale(x: number, y: number): Flow$RaphaelContext;
    clear(): void;
    resize(width: number, height: number): Flow$RaphaelContext;
    setViewBox(viewBox: string): void;
    rect(x: number, y: number, width: number, height: number): void;
    fillRect(x: number, y: number, width: number, height: number): Flow$RaphaelContext;
    clearRect(x: number, y: number, width: number, height: number): Flow$RaphaelContext;
    beginPath(): Flow$RaphaelContext;
    moveTo(x: number, y: number): Flow$RaphaelContext;
    lineTo(x: number, y: number): Flow$RaphaelContext;
    bezierCurveToTo(
        x1: number,
        y1: number,
        x2: number,
        y2: number,
        x: number,
        y: number): Flow$RaphaelContext;
    quadraticCurveToTo(x1: number, y1: number, x: number, y: number): Flow$RaphaelContext;
    arc(
        x: number,
        y: number,
        radius: number,
        startAngle: number,
        endAngle: number,
        antiClockwise: boolean): Flow$RaphaelContext;
    glow(): {
        width: number,
        fill: boolean,
        opacity: number,
        offsetx: number,
        offsety: number,
        color: string
    };
    fill(): Flow$RaphaelContext;
    stroke(): Flow$RaphaelContext;
    closePath(): Flow$RaphaelContext;
    measureText(text: string): {
        width: number,
        height: number
    };
    fillText(text: string, x: number, y: number): Flow$RaphaelContext;
    save(): Flow$RaphaelContext;
    restore(): Flow$RaphaelContext
}

declare class Renderer {
    constructor(sel: HTMLElement, backend: Renderer$Backends): this;
    USE_CANVAS_PROXY: boolean;
    buildContext(
        sel: HTMLElement,
        backend: Renderer$Backends,
        width?: number,
        height?: number,
        background?: string): Vex$IRenderContext;
    getCanvasContext(
        sel: HTMLElement,
        backend: Renderer$Backends,
        width?: number,
        height?: number,
        background?: string): Flow$CanvasContext;
    getRaphaelContext(
        sel: HTMLElement,
        backend: Renderer$Backends,
        width?: number,
        height?: number,
        background?: string): Flow$RaphaelContext;
    getSVGContext(
        sel: HTMLElement,
        backend: Renderer$Backends,
        width?: number,
        height?: number,
        background?: string): Flow$SVGContext;
    bolsterCanvasContext(ctx: CanvasRenderingContext2D): Flow$CanvasContext;
    drawDashedLine(
        context: Vex$IRenderContext,
        fromX: number,
        fromY: number,
        toX: number,
        toY: number,
        dashPattern: number[]): void;
    resize(width: number, height: number): Flow$Renderer;
    getContext(): Vex$IRenderContext
}



declare class Repetition mixins StaveModifier {
    constructor(type: Repetition$type, x: number, y_shift: number): this;
    getCategory(): string;
    setShiftX(x: number): Flow$Repetition;
    setShiftY(y: number): Flow$Repetition;
    draw(stave: Flow$Stave, x: number): Flow$Repetition;
    drawCodaFixed(stave: Flow$Stave, x: number): Flow$Repetition;
    drawSignoFixed(stave: Flow$Stave, x: number): Flow$Repetition;
    drawSymbolText(
        stave: Flow$Stave,
        x: number,
        text: string,
        draw_coda: boolean): Flow$Repetition
}



declare class Stave {
    constructor(x: number, y: number, width: number, options?: {
        vertical_bar_width?: number,
        glyph_spacing_px?: number,
        num_lines?: number,
        fill_style?: string,
        spacing_between_lines_px?: number,
        space_above_staff_ln?: number,
        space_below_staff_ln?: number,
        top_text_position?: number
    }): this;
    resetLines(): void;
    setNoteStartX(x: number): Flow$Stave;
    getNoteStartX(): number;
    getNoteEndX(): number;
    getTieStartX(): number;
    getTieEndX(): number;
    setContext(context: Vex$IRenderContext): Flow$Stave;
    getContext(): Vex$IRenderContext;
    getX(): number;
    getNumLines(): number;
    setY(y: number): Flow$Stave;
    setWidth(width: number): Flow$Stave;
    getWidth(): number;
    setMeasure(measure: number): Flow$Stave;
    setBegBarType(type: Barline$type): Flow$Stave;
    setEndBarType(type: Barline$type): Flow$Stave;
    getModifierXShift(index: number): number;
    setRepetitionTypeLeft(type: Repetition$type, y: number): Flow$Stave;
    setRepetitionTypeRight(type: Repetition$type, y: number): Flow$Stave;
    setVoltaType(type: Volta$type, number_t: number, y: number): Flow$Stave;
    setSection(section: string, y: number): Flow$Stave;
    setTempo(
        tempo: {
            name?: string,
            duration: string,
            dots: number,
            bpm: number
        },
        y: number): Flow$Stave;
    setText(
        text: string,
        position: Modifier$Position,
        options?: {
            shift_x?: number,
            shift_y?: number,
            justification?: TextNote$Justification
        }): Flow$Stave;
    getHeight(): number;
    getSpacingBetweenLines(): number;
    getBoundingBix(): Flow$BoundingBox;
    getBottomY(): number;
    getBottomLineY(): number;
    getYForLine(line: number): number;
    getYForTopText(line?: number): number;
    getYForBottomText(line?: number): number;
    getYForNote(line?: number): number;
    getYForGlyphs(): number;
    addGlyph(glypg: Flow$Glyph): Flow$Stave;
    addEndGlyph(glypg: Flow$Glyph): Flow$Stave;
    addModifier(modifier: Flow$StaveModifier): Flow$Stave;
    addEndModifier(modifier: Flow$StaveModifier): Flow$Stave;
    addKeySignature(keySpec: string): Flow$Stave;
    addClef(clef: string, size?: string, annotation?: string): Flow$Stave;
    addEndClef(clef: string, size?: string, annotation?: string): Flow$Stave;
    addTimeSignature(timeSpec: string, customPadding?: number): void;
    addTrebleGlyph(): Flow$Stave;
    draw(): void;
    drawVertical(x: number, isDouble: boolean): void;
    drawVerticalFixed(x: number, isDouble: boolean): void;
    drawVerticalBar(x: number): void;
    drawVerticalBarFixed(x: number): void;
    getConfigForLines(): {
        visible: boolean
    }[];
    setConfigForLine(line_number: number, line_config: {
        visible: boolean
    }): Flow$Stave;
    setConfigForLines(lines_configuration: {
        visible: boolean
    }[]): Flow$Stave
}

declare class StaveConnector {
    constructor(top_stave: Flow$Stave, bottom_stave: Flow$Stave): this;
    setContext(ctx: Vex$IRenderContext): Flow$StaveConnector;
    setType(type: StaveConnector$type): Flow$StaveConnector;
    setText(
        text: string,
        text_options?: {
            shift_x?: number,
            shift_y?: number
        }): Flow$StaveConnector;
    setFont(font: {
        family?: string,
        size?: number,
        weight?: string
    }): void;
    setXShift(x_shift: number): Flow$StaveConnector;
    draw(): void;
    drawBoldDoubleLine(
        ctx: Object,
        type: StaveConnector$type,
        topX: number,
        topY: number,
        botY: number): void
}



declare class StaveHairpin {
    constructor(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note
    }, type: StaveHairpin$type): this;
    FormatByTicksAndDraw(
        ctx: Vex$IRenderContext,
        formatter: Flow$Formatter,
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note
        },
        type: StaveHairpin$type,
        position: Modifier$Position,
        options?: {
            height: number,
            y_shift: number,
            left_shift_ticks: number,
            right_shift_ticks: number
        }): void;
    setContext(context: Vex$IRenderContext): Flow$StaveHairpin;
    setPosition(position: Modifier$Position): Flow$StaveHairpin;
    setRenderOptions(
        options: {
            height?: number,
            y_shift: number,
            left_shift_px: number,
            right_shift_px: number
        }): Flow$StaveHairpin;
    setNotes(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note
    }): Flow$StaveHairpin;
    renderHairpin(
        params: {
            first_x: number,
            last_x: number,
            first_y: number,
            last_y: number,
            staff_height: number
        }): void;
    draw(): boolean
}



declare class StaveLine {
    constructor(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note,
        first_indices: number[],
        last_indices: number[]
    }): this;
    setContext(context: Object): Flow$StaveLine;
    setFont(font: {
        family: string,
        size: number,
        weight: string
    }): Flow$StaveLine;
    setText(text: string): Flow$StaveLine;
    setNotes(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices?: number[],
            last_indices?: number[]
        }): Flow$StaveLine;
    applyLineStyle(): void;
    applyFontStyle(): void;
    draw(): Flow$StaveLine;
    render_options: {
        padding_left: number,
        padding_right: number,
        line_width: number,
        line_dash: number[],
        rounded_end: boolean,
        color: string,
        draw_start_arrow: boolean,
        draw_end_arrow: boolean,
        arrowhead_length: number,
        arrowhead_angle: number,
        text_position_vertical: StaveLine$TextVerticalPosition,
        text_justification: StaveLine$TextJustification
    }
}



declare class StaveModifier {
    getCategory(): string;
    makeSpacer(
        padding: number): {
        getContext: Function,
        setStave: Function,
        renderToStave: Function,
        getMetrics: Function
    };
    placeGlyphOnLine(glyph: Flow$Glyph, stave: Flow$Stave, line: number): void;
    setPadding(padding: number): void;
    addToStave(stave: Flow$Stave, firstGlyph: boolean): Flow$StaveModifier;
    addToStaveEnd(stave: Flow$Stave, firstGlyph: boolean): Flow$StaveModifier;
    addModifier(): void;
    addEndModifier(): void
}

declare class StaveNote mixins StemmableNote {
    buildStem(): Flow$StemmableNote;
    setStave(stave: Flow$Stave): Flow$Note;
    addModifier(modifier: Flow$Modifier, index?: number): Flow$Note;
    getModifierStartXY(): {
        x: number,
        y: number
    };
    getDots(): number;
    constructor(note_struct: {
        type?: string,
        dots?: number,
        duration: string,
        clef?: string,
        keys: string[],
        octave_shift?: number,
        auto_stem?: boolean,
        stem_direction?: number
    }): this;
    DEBUG: boolean;
    format(
        notes: Flow$StaveNote[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    formatByY(
        notes: Flow$StaveNote[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): void;
    postFormat(notes: Flow$StaveNote[]): boolean;
    buildStem(): void;
    buildNoteHeads(): void;
    autoStem(): void;
    calculateKeyProps(): void;
    getBoundingBox(): Flow$BoundingBox;
    getLineNumber(): number;
    isRest(): boolean;
    isChord(): boolean;
    hasStem(): boolean;
    getYForTopText(text_line: number): number;
    getYForBottomText(text_line: number): number;
    setStave(stave: Flow$Stave): Flow$StaveNote;
    getKeys(): string[];
    getKeyProps(): {
        key: string,
        octave: number,
        line: number,
        int_value: number,
        accidental: string,
        code: number,
        stroke: number,
        shift_right: number,
        displaced: boolean
    }[];
    isDisplaced(): boolean;
    setNoteDisplaced(displaced: boolean): Flow$StaveNote;
    getTieRightX(): number;
    getTieLeftX(): number;
    getLineForRest(): number;
    getModifierStartXY(position: Modifier$Position, index: number): {
        x: number,
        y: number
    };
    setStyle(
        style: {
            shadowColor?: string,
            shadowBlur?: string,
            fillStyle?: string,
            strokeStyle?: string
        }): void;
    setKeyStyle(
        index: number,
        style: {
            shadowColor?: string,
            shadowBlur?: string,
            fillStyle?: string,
            strokeStyle?: string
        }): Flow$StaveNote;
    setKeyLine(index: number, line: number): Flow$StaveNote;
    getKeyLine(index: number): number;
    addToModifierContext(mContext: Flow$ModifierContext): Flow$StaveNote;
    addModifier(index: number, modifier: Flow$Modifier): Flow$StaveNote;
    addAccidental(index: number, accidental: Flow$Accidental): Flow$StaveNote;
    addArticulation(index: number, articulation: Flow$Articulation): Flow$StaveNote;
    addAnnotation(index: number, annotation: Flow$Annotation): Flow$StaveNote;
    addDot(index: number): Flow$StaveNote;
    addDotToAll(): Flow$StaveNote;
    getAccidentals(): Flow$Accidental[];
    getDots(): Flow$Dot[];
    getVoiceShiftWidth(): number;
    calcExtraPx(): void;
    preFormat(): void;
    getNoteHeadBounds(): {
        y_top: number,
        y_bottom: number,
        highest_line: number,
        lowest_line: number
    };
    getNoteHeadBeginX(): number;
    getNoteHeadEndX(): number;
    drawLedgerLines(): void;
    drawModifiers(): void;
    drawFlag(): void;
    drawNoteHeads(): void;
    drawStem(
        struct: {
            x_begin?: number,
            x_end?: number,
            y_top?: number,
            y_bottom?: number,
            y_extend?: number,
            stem_extension?: number,
            stem_direction?: number
        }): void;
    draw(): void
}

declare
var STEM_UP: number;

declare
var STEM_DOWN: number;

declare
var CATEGORY: string;

declare class StaveSection mixins Modifier {
    draw(): void;
    constructor(section: string, x: number, shift_y: number): this;
    getCategory(): string;
    setStaveSection(section: string): Flow$StaveSection;
    setShiftX(x: number): Flow$StaveSection;
    setShiftY(y: number): Flow$StaveSection;
    draw(stave: Flow$Stave, shift_x: number): Flow$StaveSection
}

declare class StaveTempo mixins StaveModifier {
    constructor(tempo: {
        name?: string,
        duration: string,
        dots: number,
        bpm: number
    }, x: number, shift_y: number): this;
    getCategory(): string;
    setTempo(
        tempo: {
            name?: string,
            duration: string,
            dots: number,
            bpm: number
        }): Flow$StaveTempo;
    setShiftX(x: number): Flow$StaveTempo;
    setShiftY(y: number): Flow$StaveTempo;
    draw(stave: Flow$Stave, shift_x: number): Flow$StaveTempo
}

declare class StaveText mixins Modifier {
    draw(): void;
    constructor(text: string, position: Modifier$Position, options?: {
        shift_x?: number,
        shift_y?: number,
        justification?: TextNote$Justification
    }): this;
    getCategory(): string;
    setStaveText(text: string): Flow$StaveText;
    setShiftX(x: number): Flow$StaveText;
    setShiftY(y: number): Flow$StaveText;
    setFont(font: {
        family?: string,
        size?: number,
        weight?: number
    }): void;
    setText(text: string): void;
    draw(stave: Flow$Stave): Flow$StaveText
}

declare class StaveTie {
    constructor(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note,
        first_indices: number[],
        last_indices: number[]
    }, text?: string): this;
    setContext(context: Vex$IRenderContext): Flow$StaveTie;
    setFont(font: {
        family: string,
        size: number,
        weight: string
    }): Flow$StaveTie;
    setNotes(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices: number[],
            last_indices: number[]
        }): Flow$StaveTie;
    isPartial(): boolean;
    renderTie(
        params: {
            first_ys: number[],
            last_ys: number[],
            last_x_px: number,
            first_x_px: number,
            direction: number
        }): void;
    renderText(first_x_px: number, last_x_px: number): void;
    draw(): boolean
}

declare class Stem {
    constructor(options: {
        x_begin?: number,
        x_end?: number,
        y_top?: number,
        y_bottom?: number,
        y_extend?: number,
        stem_extension?: number,
        stem_direction?: number
    }): this;
    DEBUG: boolean;
    setNoteHeadXBounds(x_begin: number, x_end: number): Flow$Stem;
    setDirection(direction: number): void;
    setExtension(extension: number): void;
    setYBounds(y_top: number, y_bottom: number): void;
    getCategory(): string;
    setContext(context: Vex$IRenderContext): Flow$Stem;
    getHeight(): number;
    getBoundingBox(): Flow$BoundingBox;
    getExtents(): {
        topY: number,
        baseY: number
    };
    setStyle(
        style: {
            shadowColor?: string,
            shadowBlur?: string,
            fillStyle?: string,
            strokeStyle?: string
        }): void;
    getStyle(): {
        shadowColor?: string,
        shadowBlur?: string,
        fillStyle?: string,
        strokeStyle?: string
    };
    applyStyle(context: Vex$IRenderContext): Flow$Stem;
    draw(): void;
    hide: boolean
}

declare
var UP: number;

declare
var DOWN: number;

declare class StemmableNote mixins Note {
    setBeam(): Flow$Note;
    constructor(note_struct: {
        type?: string,
        dots?: number,
        duration: string
    }): this;
    DEBUG: boolean;
    getStem(): Flow$Stem;
    setStem(stem: Flow$Stem): Flow$StemmableNote;
    buildStem(): Flow$StemmableNote;
    getStemLength(): number;
    getBeamCount(): number;
    getStemMinumumLength(): number;
    getStemDirection(): number;
    setStemDirection(direction: number): Flow$StemmableNote;
    getStemX(): number;
    getCenterGlyphX(): number;
    getStemExtension(): number;
    setStemLength(): number;
    getStemExtents(): {
        topY: number,
        baseY: number
    };
    setBeam(beam: Flow$Beam): Flow$StemmableNote;
    getYForTopText(text_line: number): number;
    getYForBottomText(text_line: number): number;
    postFormat(): Flow$StemmableNote;
    drawStem(
        stem_struct: {
            x_begin?: number,
            x_end?: number,
            y_top?: number,
            y_bottom?: number,
            y_extend?: number,
            stem_extension?: number,
            stem_direction?: number
        }): void
}

declare class StringNumber mixins Modifier {
    setNote(note: Flow$Note): Flow$StringNumber;
    constructor(number: number): this;
    format(
        nums: Flow$StringNumber[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    getNote(): Flow$Note;
    setNote(note: Flow$StemmableNote): Flow$StringNumber;
    getIndex(): number;
    setIndex(index: number): Flow$StringNumber;
    setLineEndType(leg: Renderer$LineEndType): Flow$StringNumber;
    getPosition(): Modifier$Position;
    setPosition(position: Modifier$Position): Flow$StringNumber;
    setStringNumber(number: number): Flow$StringNumber;
    setOffsetX(x: number): Flow$StringNumber;
    setOffsetY(y: number): Flow$StringNumber;
    setLastNote(note: Flow$StemmableNote): Flow$StringNumber;
    setDashed(dashed: boolean): Flow$StringNumber;
    draw(): void
}

declare
var CATEGORY: string;

declare class Stroke mixins Modifier {
    constructor(type: Stroke$Type, options: {
        all_voices?: boolean
    }): this;
    format(
        strokes: Flow$Stroke[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        }): boolean;
    getPosition(): Modifier$Position;
    addEndNote(note: Flow$Note): Flow$Stroke;
    draw(): void
}

declare
var CATEGORY: string;

declare class SVGContext mixins IRenderContext {
    constructor(element: HTMLElement): this;
    iePolyfill(): boolean;
    setFont(family: string, size: number, weight?: number): Flow$SVGContext;
    setRawFont(font: string): Flow$SVGContext;
    setFillStyle(style: string): Flow$SVGContext;
    setBackgroundFillStyle(style: string): Flow$SVGContext;
    setStrokeStyle(style: string): Flow$SVGContext;
    setShadowColor(style: string): Flow$SVGContext;
    setShadowBlur(blur: string): Flow$SVGContext;
    setLineWidth(width: number): Flow$SVGContext;
    setLineDash(dash: string): Flow$SVGContext;
    setLineCap(cap_type: string): Flow$SVGContext;
    resize(width: number, height: number): Flow$SVGContext;
    scale(x: number, y: number): Flow$SVGContext;
    setViewBox(xMin: number, yMin: number, width: number, height: number): void;
    clear(): void;
    rect(x: number, y: number, width: number, height: number): Flow$SVGContext;
    fillRect(x: number, y: number, width: number, height: number): Flow$SVGContext;
    clearRect(x: number, y: number, width: number, height: number): Flow$SVGContext;
    beginPath(): Flow$SVGContext;
    moveTo(x: number, y: number): Flow$SVGContext;
    lineTo(x: number, y: number): Flow$SVGContext;
    bezierCurveToTo(
        x1: number,
        y1: number,
        x2: number,
        y2: number,
        x: number,
        y: number): Flow$SVGContext;
    quadraticCurveToTo(x1: number, y1: number, x: number, y: number): Flow$SVGContext;
    arc(
        x: number,
        y: number,
        radius: number,
        startAngle: number,
        endAngle: number,
        antiClockwise: boolean): Flow$SVGContext;
    closePath(): Flow$SVGContext;
    glow(): Flow$SVGContext;
    fill(): Flow$SVGContext;
    stroke(): Flow$SVGContext;
    measureText(text: string): SVGRect;
    ieMeasureTextFix(
        bbox: SVGRect,
        text: string): {
        x: number,
        y: number,
        width: number,
        height: number
    };
    fillText(text: string, x: number, y: number): Flow$SVGContext;
    save(): Flow$SVGContext;
    restore(): Flow$SVGContext
}

declare class TabNote mixins StemmableNote {
    setStave(stave: Flow$Stave): Flow$Note;
    getModifierStartXY(): {
        x: number,
        y: number
    };
    constructor(tab_struct: {
        positions: {
            str: number,
            fret: number
        }[],
        type?: string,
        dots?: number,
        duration: string,
        stem_direction?: boolean
    }, draw_stem?: boolean): this;
    getCategory(): string;
    setGhost(ghost: boolean): Flow$TabNote;
    hasStem(): boolean;
    getStemExtension(): number;
    addDot(): Flow$TabNote;
    updateWidth(): void;
    setStave(stave: Flow$Stave): Flow$TabNote;
    getPositions(): {
        str: number,
        fret: number
    }[];
    addToModifierContext(mc: Flow$ModifierContext): Flow$TabNote;
    getTieRightX(): number;
    getTieLeftX(): number;
    getModifierStartXY(position: Modifier$Position, index: number): {
        x: number,
        y: number
    };
    getLineForRest(): number;
    preFormat(): void;
    getStemX(): number;
    getStemY(): number;
    getStemExtents(): {
        topY: number,
        baseY: number
    };
    drawFlag(): void;
    drawModifiers(): void;
    drawStemThrough(): void;
    draw(): void
}

declare class TabSlide mixins TabTie {
    constructor(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note,
        first_indices: number[],
        last_indices: number[]
    }, direction?: number): this;
    createSlideUp(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices: number[],
            last_indices: number[]
        }): Flow$TabSlide;
    createSlideDown(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices: number[],
            last_indices: number[]
        }): Flow$TabSlide;
    renderTie(
        params: {
            first_ys: number[],
            last_ys: number[],
            last_x_px: number,
            first_x_px: number,
            direction: number
        }): void
}

declare
var SLIDE_UP: number;

declare
var SLIDE_DOWN: number;

declare class TabStave mixins Stave {
    constructor(x: number, y: number, width: number, options?: {
        vertical_bar_width?: number,
        glyph_spacing_px?: number,
        num_lines?: number,
        fill_style?: string,
        spacing_between_lines_px?: number,
        space_above_staff_ln?: number,
        space_below_staff_ln?: number,
        top_text_position?: number
    }): this;
    getYForGlyphs(): number;
    addTabGlyph(): Flow$TabStave
}

declare class TabTie mixins StaveTie {
    constructor(notes: {
        first_note: Flow$Note,
        last_note: Flow$Note,
        first_indices: number[],
        last_indices: number[]
    }, text?: string): this;
    createHammeron(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices: number[],
            last_indices: number[]
        }): Flow$TabTie;
    createPulloff(
        notes: {
            first_note: Flow$Note,
            last_note: Flow$Note,
            first_indices: number[],
            last_indices: number[]
        }): Flow$TabTie;
    draw(): boolean
}

declare class TextBracket {
    constructor(bracket_data: {
        start: Flow$Note,
        stop: Flow$Note,
        text?: string,
        superscript?: string,
        position?: TextBracket$Positions
    }): this;
    DEBUG: boolean;
    applyStyle(context: Vex$IRenderContext): Flow$TextBracket;
    setDashed(dashed: boolean, dash?: number[]): Flow$TextBracket;
    setFont(font: {
        family: string,
        size: number,
        weight: string
    }): Flow$TextBracket;
    setContext(context: Vex$IRenderContext): Flow$TextBracket;
    setLine(line: number): Flow$TextBracket;
    draw(): void
}



declare class TextDynamics mixins Note {
    constructor(text_struct: {
        duration: string,
        text: string,
        line?: number
    }): this;
    DEBUG: boolean;
    setLine(line: number): Flow$TextDynamics;
    preFormat(): Flow$TextDynamics;
    draw(): void
}

declare class TextNote mixins Note {
    constructor(text_struct: {
        duration: string,
        text?: string,
        superscript?: boolean,
        subscript?: boolean,
        glyph?: string,
        font?: {
            family: string,
            size: number,
            weight: string
        },
        line?: number,
        smooth?: boolean,
        ignore_ticks?: boolean
    }): this;
    setJustification(just: TextNote$Justification): Flow$TextNote;
    setLine(line: number): Flow$TextNote;
    preFormat(): void;
    draw(): void
}

declare
var GLYPHS: {
    [name: string]: {
        code: string,
        point: number,
        x_shift: number,
        y_shift: number
    }
};

declare interface Flow$Tickable {
    setContext(context: Vex$IRenderContext): void,
        getBoundingBox(): Flow$BoundingBox,
        getTicks(): Flow$Fraction,
        shouldIgnoreTicks(): boolean,
        getWidth(): number,
        setXShift(x: number): Flow$Tickable,
        getCenterXShift(): number,
        isCenterAligned(): boolean,
        setCenterAlignment(align_center: boolean): Flow$Tickable,
        getVoice(): Flow$Voice,
        setVoice(voice: Flow$Voice): void,
        getTuplet(): Flow$Tuplet,
        setTuplet(tuplet: Flow$Tuplet): Flow$Tickable,
        addToModifierContext(mc: Flow$ModifierContext): void,
        addModifier(mod: Flow$Modifier): Flow$Tickable,
        setTickContext(tc: Flow$TickContext): void,
        preFormat(): void,
        postFormat(): Flow$Tickable,
        getIntrinsicTicks(): Flow$Fraction,
        setIntrinsicTicks(intrinsicTicks: Flow$Fraction): void,
        getTickMultiplier(): Flow$Fraction,
        applyTickMultiplier(numerator: number, denominator: number): void,
        setDuration(duration: Flow$Fraction): void
}

declare class TickContext {
    setContext(context: Vex$IRenderContext): void;
    getContext(): Vex$IRenderContext;
    shouldIgnoreTicks(): boolean;
    getWidth(): number;
    getX(): number;
    setX(x: number): Flow$TickContext;
    getPixelsUsed(): number;
    setPixelsUsed(pixelsUsed: number): Flow$TickContext;
    setPadding(padding: number): Flow$TickContext;
    getMaxTicks(): number;
    getMinTicks(): number;
    getTickables(): Flow$Tickable[];
    getCenterAlignedTickables(): Flow$Tickable[];
    getMetrics(): {
        width: number,
        notePx: number,
        extraLeftPx: number,
        extraRightPx: number
    };
    getCurrentTick(): Flow$Fraction;
    setCurrentTick(tick: Flow$Fraction): void;
    getExtraPx(): {
        left: number,
        right: number,
        extraLeft: number,
        extraRight: number
    };
    addTickable(tickable: Flow$Tickable): Flow$TickContext;
    preFormat(): Flow$TickContext;
    postFormat(): Flow$TickContext;
    getNextContext(tContext: Flow$TickContext): Flow$TickContext
}

declare class TimeSignature mixins StaveModifier {
    addModifier(): void;
    addEndModifier(): void;
    constructor(timeSpec: string, customPadding?: number): this;
    parseTimeSpec(timeSpec: string): {
        num: number,
        glyph: Flow$Glyph
    };
    makeTimeSignatureGlyph(topNums: number[], botNums: number[]): Flow$Glyph;
    getTimeSig(): {
        num: number,
        glyph: Flow$Glyph
    };
    addModifier(stave: Flow$Stave): void;
    addEndModifier(stave: Flow$Stave): void
}

declare
var glyphs: {
    [name: string]: {
        code: string,
        point: number,
        line: number
    }
};

declare class TimeSigNote mixins Note {
    setStave(stave: Flow$Stave): Flow$Note;
    constructor(timeSpec: string, customPadding: number): this;
    setStave(stave: Flow$Stave): void;
    getBoundingBox(): Flow$BoundingBox;
    addToModifierContext(): Flow$TimeSigNote;
    preFormat(): Flow$TimeSigNote;
    draw(): void
}

declare class Tremolo mixins Modifier {
    constructor(num: number): this;
    getCategory(): string;
    draw(): void
}

declare class Tuning {
    constructor(tuningString?: string): this;
    noteToInteger(noteString: string): number;
    setTuning(tuningString: string): void;
    getValueForString(stringNum: string): number;
    getValueForFret(fretNum: string, stringNum: string): number;
    getNoteForFret(fretNum: string, stringNum: string): string
}

declare
var names: {
    [name: string]: string
};

declare class Tuplet {
    constructor(notes: Flow$StaveNote[], options: {
        num_notes?: number,
        beats_occupied?: number
    }): this;
    attach(): void;
    detach(): void;
    setContext(context: Vex$IRenderContext): Flow$Tuplet;
    setBracketed(bracketed: boolean): Flow$Tuplet;
    setRatioed(ratioed: boolean): Flow$Tuplet;
    setTupletLocation(location: number): Flow$Tuplet;
    getNotes(): Flow$StaveNote[];
    getNoteCount(): number;
    getBeatsOccupied(): number;
    setBeatsOccupied(beats: number): void;
    resolveGlyphs(): void;
    draw(): void
}

declare
var LOCATION_TOP: number;

declare
var LOCATION_BOTTOM: number;

declare class Vibrato mixins Modifier {
    format(
        vibratos: Flow$Vibrato[],
        state: {
            left_shift: number,
            right_shift: number,
            text_line: number
        },
        context: Flow$ModifierContext): boolean;
    setHarsh(harsh: boolean): Flow$Vibrato;
    setVibratoWidth(width: number): Flow$Vibrato;
    draw(): void
}

declare
var CATEGORY: string;

declare class Voice {
    constructor(time: {
        num_beats?: number,
        beat_value?: number,
        resolution?: number
    }): this;
    getTotalTicks(): Flow$Fraction;
    getTicksUsed(): Flow$Fraction;
    getLargestTickWidth(): number;
    getSmallestTickCount(): Flow$Fraction;
    getTickables(): Flow$Tickable[];
    getMode(): number;
    setMode(mode: number): Flow$Voice;
    getResolutionMultiplier(): number;
    getActualResolution(): number;
    setStave(stave: Flow$Stave): Flow$Voice;
    getBoundingBox(): Flow$BoundingBox;
    getVoiceGroup(): Flow$VoiceGroup;
    setVoiceGroup(g: Flow$VoiceGroup): Flow$Voice;
    setStrict(strict: boolean): Flow$Voice;
    isComplete(): boolean;
    addTickable(tickable: Flow$Tickable): Flow$Voice;
    addTickables(tickables: Flow$Tickable[]): Flow$Voice;
    preFormat(): Flow$Voice;
    draw(context: Vex$IRenderContext, stave?: Flow$Stave): void
}



declare class VoiceGroup {
    getVoices(): Flow$Voice[];
    getModifierContexts(): Flow$ModifierContext[];
    addVoice(voice: Flow$Voice): void
}

declare class Volta mixins StaveModifier {
    constructor(type: Volta$type, number: number, x: number, y_shift: number): this;
    getCategory(): string;
    setShiftY(y: number): Flow$Volta;
    draw(stave: Flow$Stave, x: number): Flow$Volta
}

declare module 'vexflow' {
    declare module.exports: typeof Vex
}