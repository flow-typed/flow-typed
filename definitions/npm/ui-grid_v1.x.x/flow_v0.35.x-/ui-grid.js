// @flow
/**
 * Flowtype definitions for ui-grid
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export interface uiGrid$IUiGridConstants {
    LOG_DEBUG_MESSAGES: boolean,
        LOG_WARN_MESSAGES: boolean,
        LOG_ERROR_MESSAGES: boolean,
        CUSTOM_FILTERS: RegExp,
        COL_FIELD: RegExp,
        MODEL_COL_FIELD: RegExp,
        TOOLTIP: RegExp,
        DISPLAY_CELL_TEMPLATE: RegExp,
        TEMPLATE_REGEXP: RegExp,
        FUNC_REGEXP: RegExp,
        DOT_REGEXP: RegExp,
        APOS_REGEXP: RegExp,
        BRACKET_REGEXP: RegExp,
        COL_CLASS_PREFIX: string,
        events: {
            GRID_SCROLL: string,
            COLUMN_MENU_SHOWN: string,
            ITEM_DRAGGING: string,
            COLUMN_HEADER_CLICK: string
        },
        keymap: {
            TAB: number,
            STRG: number,
            CAPSLOCK: number,
            CTRL: number,
            CTRLRIGHT: number,
            CTRLR: number,
            SHIFT: number,
            RETURN: number,
            ENTER: number,
            BACKSPACE: number,
            BCKSP: number,
            ALT: number,
            ALTR: number,
            ALTRIGHT: number,
            SPACE: number,
            WIN: number,
            MAC: number,
            FN: number,
            PG_UP: number,
            PG_DOWN: number,
            UP: number,
            DOWN: number,
            LEFT: number,
            RIGHT: number,
            ESC: number,
            DEL: number,
            F1: number,
            F2: number,
            F3: number,
            F4: number,
            F5: number,
            F6: number,
            F7: number,
            F8: number,
            F9: number,
            F10: number,
            F11: number,
            F12: number
        },
        ASC: string,
        DESC: string,
        filter: {
            STARTS_WITH: number,
            ENDS_WITH: number,
            EXACT: number,
            CONTAINS: number,
            GREATER_THAN: number,
            GREATER_THAN_OR_EQUAL: number,
            LESS_THAN: number,
            LESS_THAN_OR_EQUAL: number,
            NOT_EQUAL: number,
            SELECT: string,
            INPUT: string
        },
        scrollDirection: {
            UP: string,
            DOWN: string,
            LEFT: string,
            RIGHT: string,
            NONE: string
        },
        aggregationTypes: {
            sum: number,
            count: number,
            avg: number,
            min: number,
            max: number
        },
        CURRENCY_SYMBOLS: Array<string>,
        dataChange: {
            ALL: string,
            EDIT: string,
            ROW: string,
            COLUMN: string,
            OPTIONS: string
        },
        scrollbars: {
            NEVER: number,
            ALWAYS: number
        }
}

declare export type uiGrid$IGridInstance = uiGrid$IGridInstanceOf<any>;

declare export interface uiGrid$IGridInstanceOf<TEntity>{

    /**
     * adds a row header column to the grid
     * @param  The column definition
     */
    addRowHeaderColumn(colDef: uiGrid$IColumnDefOf<TEntity>): void,

    /**
     * uses the first row of data to assign colDef.type for any types not defined.
     */
    assignTypes(): void,

    /**
     * Populates columnDefs from the provided data
     * @param  function to be called
     */
    buildColumnDefsFromData(rowBuilder: uiGrid$IRowBuilder<TEntity>): void,

    /**
     * creates GridColumn objects from the columnDefinition.
     * Calls each registered columnBuilder to further process the column
     * @param  An object containing options to use when building columns
    * orderByColumnDefs: defaults to false.  When true, buildColumns will order existing columns
    according to the order within the column definitions
     * @returns  A promise to load any needed column resources
    */
    buildColumns(options: uiGrid$IBuildColumnsOptions): ng.IPromise<any>,

    /**
     * calls each styleComputation function
     */
    buildStyles(): void,

    /**
     * Calls the callbacks based on the type of data change that has occurred.
     * Always calls the ALL callbacks, calls the ROW, EDIT, COLUMN and OPTIONS callbacks
    if the event type is matching, or if the type is ALL.
     * @param  the type of event that occurred - one of the uiGridConstants.dataChange values
    (ALL, ROW, EDIT, COLUMN, OPTIONS
    */
    callDataChangeCallbacks(type: number): void,

    /**
     * Clears all filters and optionally refreshes the visible rows.
     * @param  Refresh the rows?
     * @param  Clear conditions?
     * @param  Clear flags?
     * @returns  <any>} If refreshRows is true, returns a promise of the rows refreshing
     */
    clearAllFilters(
        refreshRows: boolean,
        clearConditions: boolean,
        clearFlags: boolean): ng.IPromise<any>,

    /**
     * refreshes the grid when a column refresh is notified, which triggers handling of the visible flag.
     * This is called on uiGridConstants.dataChange.COLUMN, and is registered as a dataChangeCallback in grid.js
     * @param  column name
     */
    columnRefreshCallback(name: string): void,

    /**
     * creates the left render container if it doesn't already exist
     */
    createLeftContainer(): void,

    /**
     * creates the right render container if it doesn't already exist
     */
    createRightContainer(): void,

    /**
     * sets isScrollingHorizontally to true and sets it to false in a debounced function
     */
    flagScrollingHorizontally(): void,

    /**
     * sets isScrollingVertically to true and sets it to false in a debounced function
     */
    flagScrollingVertically(): void,

    /**
     * Gets the displayed value of a cell after applying any the cellFilter
     * @param  Row to access
     * @param  Column to access
     * @returns  Cell display value
     */
    getCellDisplayValue(row: uiGrid$IGridRowOf<TEntity>, col: uiGrid$IGridColumnOf<TEntity>): string,

    /**
     * Gets the displayed value of a cell
     * @param  Row to access
     * @param  Column to access
     * @returns  Cell value
     */
    getCellValue(row: uiGrid$IGridRowOf<TEntity>, col: uiGrid$IGridColumnOf<TEntity>): any,

    /**
     * returns a grid colDef for the column name
     * @param  Column name
     * @returns  The column definition
     */
    getColDef(name: string): uiGrid$IColumnDefOf<TEntity>,

    /**
     * returns a grid column by name
     * @param  Column name
     * @returns  The column
     */
    getColumn(name: string): uiGrid$IGridColumnOf<TEntity>,

    /**
     * Return the columns that the grid is currently being sorted by
     * @returns  the columns that the grid is currently being sorted by
     */
    getColumnSorting(): Array<uiGrid$IGridColumnOf<TEntity >> ,

    /**
     * Returns the $parse-able accessor for a column within its $scope
     * @param  Column object
     * @returns  $parse-able accessor for a column within its $scope
     */
    getGridQualifiedColField(col: uiGrid$IGridColumnOf<TEntity>): string,

    /**
     * returns all columns except for rowHeader columns
     * @returns  All data columns
     */
    getOnlyDataColumns(): Array<uiGrid$IGridColumnOf<TEntity >> ,

    /**
     * returns the GridRow that contains the rowEntity
     * @param  the gridOptionms.data array element instance
     * @param  The rows to look in.  if not provided then it looks in grid.rows
     */
    getRow(
        rowEntity: TEntity,
        rows?: Array<uiGrid$IGridRowOf<TEntity >> ): uiGrid$IGridRowOf<TEntity>,

    /**
     * Triggered when the browser window resizes; automatically resizes the grid
     * @param  Resize event
     */
    handleWindowResize($event: ng.IAngularEvent): void,

    /**
     * returns true if leftContainer exists
     * @returns  container exists?
     */
    hasLeftContainer(): boolean,

    /**
     * returns true if rightContainer exists
     * @returns  container exists?
     */
    hasRightContainer(): boolean,

    /**
     * returns true if leftContainer has columns
     * @returns  container has columns
     */
    hasLeftContainerColumns(): boolean,

    /**
     * returns true if rightContainer has columns
     * @returns  container has columns
     */
    hasRightContainerColumns(): boolean,

    /**
     * Is grid right to left
     * @returns  true if grid is RTL
     */
    isRTL(): boolean,

    /**
     * Checks if column is a row header
     * @param  The column
     * @returns  true if the column is a row header
     */
    isRowHeaderColumn(column: uiGrid$IGridColumnOf<TEntity>): boolean,

    /**
     * creates or removes GridRow objects from the newRawData array.  Calls each registered
     * rowBuilder to further process the row

    This method aims to achieve three things:
    1. the resulting rows array is in the same order as the newRawData, we'll call
    rowsProcessors immediately after to sort the data anyway
    2. if we have row hashing available, we try to use the rowHash to find the row
    3. no memory leaks - rows that are no longer in newRawData need to be garbage collected

    The basic logic flow makes use of the newRawData, oldRows and oldHash, and creates
    the newRows and newHash

    Rows are identified using the hashKey if configured.  If not configured, then rows
    are identified using the gridOptions.rowEquality function
     * @param  The new grid data
     * @return  <any>} Promise which resolves when the rows have been created or removed
    */
    modifyRows(newRawData: Array<TEntity>): ng.IPromise<any>,

    /**
     * Notify the grid that a data or config change has occurred,
     * where that change isn't something the grid was otherwise noticing.  This
    might be particularly relevant where you've changed values within the data
    and you'd like cell classes to be re-evaluated, or changed config within
    the columnDef and you'd like headerCellClasses to be re-evaluated.
     * @param  one of the uiGridConstants.dataChange values [ALL, ROW, EDIT, COLUMN], which tells
    us which refreshes to fire
    */
    notifyDataChange(type: string): void,

    /**
     * precompiles all cell templates
     */
    precompileCellTemplates(): void,

    /**
     * processes all RowBuilders for the gridRow
     * @param  reference to gridRow
     * @returns  the gridRow with all additional behavior added
     */
    processRowBuilders(gridRow: uiGrid$IGridRowOf<TEntity>): uiGrid$IGridRowOf<TEntity>,

    /**
     * calls the row processors, specifically
     * intended to reset the sorting when an edit is called,
    registered as a dataChangeCallback on uiGridConstants.dataChange.EDIT
     * @param  column name
    */
    processRowsCallback(name: string): void,

    /**
     * queues a grid refresh, a way of debouncing all the refreshes we might otherwise issue
     */
    queueGridRefresh(): void,

    /**
     * queues a grid refreshCanvas, a way of debouncing all the refreshes we might otherwise issue
     */
    queueRefresh(): void,

    /**
     * Redraw the rows and columns based on our current scroll position
     * @param  Optional to indicate rows are added and the scroll percentage must be
    recalculated
    */
    redrawCanvas(rowsAdded?: boolean): void,

    /**
     * Refresh the rendered grid on screen.
     * The refresh method re-runs both the columnProcessors and the
    rowProcessors, as well as calling refreshCanvas to update all
    the grid sizing.  In general you should prefer to use queueGridRefresh
    instead, which is basically a debounced version of refresh.

    If you only want to resize the grid, not regenerate all the rows
    and columns, you should consider directly calling refreshCanvas instead.
     * @param  Optional flag for refreshing when the number of rows has changed
    */
    refresh(rowsAltered?: boolean): void,

    /**
     * Builds all styles and recalculates much of the grid sizing
     * @param  optional parameter.  Use TBD
     * @returns  <any>} promise that is resolved when the canvas
    has been refreshed
    */
    refreshCanvas(buildStyles?: boolean): ng.IPromise<any>,

    /**
     * Refresh the rendered rows on screen?  Note: not functional at present
     * @returns  <any>} promise that is resolved when render completes?
     */
    refreshRows(): ng.IPromise<any>,

    /**
     * When the build creates columns from column definitions, the columnbuilders will be called to add
     * additional properties to the column.
     * @param  function to be called
     */
    registerColumnBuilder(columnBuilder: uiGrid$IColumnBuilder<TEntity>): void,

    /**
     * Register a "columns processor" function. When the columns are updated,
     * the grid calls each registered "columns processor", which has a chance
    to alter the set of columns, as long as the count is not modified.
     * @param  column processor function, which
    is run in the context of the grid (i.e. this for the function will be the grid), and
    which must return an updated renderedColumnsToProcess which can be passed to the next processor
    in the chain
     * @param  the priority of this processor.  In general we try to do them in 100s to leave room
    for other people to inject columns processors at intermediate priorities.
    Lower priority columnsProcessors run earlier.priority
    */
    registerColumnsProcessor(columnProcessor: uiGrid$IColumnProcessor<TEntity>, priority: number): void,

    /**
     * When a data change occurs, the data change callbacks of the specified type
     * will be called.  The rules are:

    - when the data watch fires, that is considered a ROW change (the data watch only notices
       added or removed rows)
    - when the api is called to inform us of a change, the declared type of that change is used
    - when a cell edit completes, the EDIT callbacks are triggered
    - when the columnDef watch fires, the COLUMN callbacks are triggered
    - when the options watch fires, the OPTIONS callbacks are triggered

    For a given event:
    - ALL calls ROW, EDIT, COLUMN, OPTIONS and ALL callbacks
    - ROW calls ROW and ALL callbacks
    - EDIT calls EDIT and ALL callbacks
    - COLUMN calls COLUMN and ALL callbacks
    - OPTIONS calls OPTIONS and ALL callbacks: IGridInstance) => void} callback function to be called
     * @param  the types of data change you want to be informed of.  Values from
    the uiGridConstants.dataChange values ( ALL, EDIT, ROW, COLUMN, OPTIONS ).  Optional and defaults to
    ALL
     * @returns  deregister function - a function that can be called to deregister this callback
    */
    registerDataChangeCallback(
        callback: (grid: uiGrid$IGridInstanceOf<TEntity>) => void,
        types?: Array<string>): Function,

    /**
     * When the build creates rows from gridOptions.data, the rowBuilders will be called to add
     * additional properties to the row.
     * @param  Function to be called
     */
    registerRowBuilder(rowBuilder: uiGrid$IRowBuilder<TEntity>): void,

    /**
     * Register a "rows processor" function. When the rows are updated,
     * the grid calls each registered "rows processor", which has a chance
    to alter the set of rows (sorting, etc) as long as the count is not
    modified.
     * @param  rows processor function, which
    is run in the context of the grid (i.e. this for the function will be the grid), and must
    return the updated rows list, which is passed to the next processor in the chain
     * @param  the priority of this processor.
    In general we try to do them in 100s to leave room for other people to inject rows processors at
    intermediate priorities.  Lower priority rowsProcessors run earlier. At present all rows visible
    is running at 50, filter is running at 100, sort is at 200, grouping at 400, selectable rows at
    500, pagination at 900 (pagination will generally want to be last)
    */
    registerRowsProcessor(rowProcessor: uiGrid$IRowProcessor<TEntity>, priority: number): void,

    /**
     * registered a styleComputation function
     * 
    If the function returns a value it will be appended into the grid's `<style>` block
     * @param  function
    */
    registerStyleComputation(styleComputation: ($scope: ng.IScope) => string): void,

    /**
     * Remove a registered rows processor
     * @param  processor function
     */
    removeRowsProcessor(rows: uiGrid$IRowProcessor<TEntity>): void,

    /**
     * Return the columns that the grid is currently being sorted by
     * @param  Optional GridColumn to exclude from having its sorting reset
     */
    resetColumnSorting(excludedColumn: uiGrid$IGridColumnOf<TEntity>): void,

    /**
     * Scroll the grid such that the specified
     * row and column is in view
     * @param  gridOptions.data[] array element to make visible
     * @param  to make visible
     * @returns  <any>} a promise that is resolved after any scrolling is finished
     */
    scrollTo(rowEntity?: TEntity, colDef?: uiGrid$IColumnDefOf<TEntity>): ng.IPromise<any>,

    /**
     * Scrolls the grid to make a certain row and column combo visible,
     * in the case that it is not completely visible on the screen already.
     * @param  row to make visible
     * @param  column to make visible
     * @returns  <any>} a promise that is resolved when scrolling is complete
     */
    scrollToIfNecessary(
        gridRow: uiGrid$IGridRowOf<TEntity>,
        gridCol: uiGrid$IGridColumnOf<TEntity>): ng.IPromise<any>,

    /**
     * Set the sorting on a given column, optionally resetting any existing sorting on the Grid.
     * Emits the sortChanged event whenever the sort criteria are changed.
     * @param  Column to set the sorting on
     * @param  Direction to sort by,
    either descending or ascending.  If not provided, the column will iterate through the sort
    directions: ascending, descending, unsorted.
     * @param  Add this column to the sorting. If not provided or set to `false`, the Grid will
    reset any existing sorting and sort by this column only
     * @returns  <IGridColumn>} A resolved promise that supplies the column.
    */
    sortColumn(
        column: uiGrid$IGridColumnOf<TEntity>,
        direction?: string,
        add?: boolean): ng.IPromise<uiGrid$IGridColumnOf<TEntity >> ,

    /**
     * flags all render containers to update their canvas height
     */
    updateCanvasHeight(): void,

    /**
     * recalculates the footer height,
     * registered as a dataChangeCallback on uiGridConstants.dataChange.OPTIONS
     * @param  column name
     */
    updateFooterHeightCallback(name: string): void,

    /**
     * reference to the application scope (the parent scope of the ui-grid element). Assigned in ui-grid controller
     * use gridOptions.appScopeProvider to override the default assignment of $scope.$parent with any reference
     */
    appScope?: ng.IScope,

    /**
     * returns an array of columns in the grid
     */
    columns: Array<uiGrid$IGridColumn>,

    /**
     * returns the total column footer height
     */
    columnFooterHeight?: number,

    /**
     * returns the total footer height gridFooter + columnFooter
     */
    footerHeight?: number,

    /**
     * returns or sets grid height in pixels
     */
    gridHeight?: number,

    /**
     * set to true when Grid is scrolling horizontally. Set to false via debounced method
     */
    isScrollingHorizontally?: boolean,

    /**
     * set to true when Grid is scrolling vertically. Set to false via debounced method
     */
    isScrollingVertically?: boolean,

    /**
     * set one of the uiGridConstants.scrollDirection values (UP, DOWN, LEFT, RIGHT, NONE),
     * which tells us which direction we are scrolling. Set to NONE via debounced method
     */
    scrollDirection?: number
}

declare export interface uiGrid$IBuildColumnsOptions {
    orderByColumnDefs?: boolean
}

declare export interface uiGrid$IStyleComputation {
    ($scope: ng.IScope): string
}

declare export interface uiGrid$IColumnBuilder<TEntity>{
    (colDef: uiGrid$IColumnDefOf<TEntity>, col: uiGrid$IGridColumnOf<TEntity>, gridOptions: uiGrid$IGridOptionsOf<TEntity>): void
}

declare export interface uiGrid$IRowBuilder<TEntity>{
    (row: uiGrid$IGridRowOf<TEntity>, gridOptions: uiGrid$IGridOptionsOf<TEntity>): void
}

declare export interface uiGrid$IRowProcessor<TEntity>{
    (renderedRowsToProcess: Array<uiGrid$IGridRowOf<TEntity >> , columns: Array<uiGrid$IGridColumnOf<TEntity >> ): Array<uiGrid$IGridRowOf<TEntity >>
}

declare export interface uiGrid$IColumnProcessor<TEntity>{
    (renderedColumnsToProcess: Array<uiGrid$IGridColumnOf<TEntity >> , rows: Array<uiGrid$IGridRowOf<TEntity >> ): Array<uiGrid$IGridColumnOf<TEntity >>
}

declare export type uiGrid$IGridOptions = uiGrid$IGridOptionsOf<any>;

declare export type uiGrid$IGridOptionsOf<TEntity>= {

        /**
         * Default time in milliseconds to throttle aggregation calcuations, defaults to 500ms
         */
        aggregationCalcThrottle?: number,

        /**
         * by default, the parent scope of the ui-grid element will be assigned to grid.appScope
         * this property allows you to assign any reference you want to grid.appScope
         */
        appScopeProvider?: ng.IScope | Object,

        /**
         * Array of columnDef objects.  Only required property is name.
         */
        columnDefs?: Array<uiGrid$IColumnDefOf<TEntity >> ,

        /**
         * The height of the footer rows (column footer and grid footer) in pixels
         */
        columnFooterHeight?: number,

        /**
         * Turn virtualization on when number of columns goes over this number, defaults to 10
         * @default  10
         */
        columnVirtualizationThreshold?: number,

        /**
         * (mandatory) Array of data to be rendered into the grid, providing the data source or data binding for
         * the grid.

        Most commonly the data is an array of objects, where each object has a number of attributes.
        Each attribute automatically becomes a column in your grid.  This array could, for example, be sourced from
        an angularJS $resource query request.  The array can also contain complex objects, refer the binding tutorial
        for examples of that.

        The most flexible usage is to set your data on $scope:

        `$scope.data = data;`

        And then direct the grid to resolve whatever is in $scope.data:

        `$scope.gridOptions.data = 'data';`

        This is the most flexible approach as it allows you to replace $scope.data whenever you feel like it without
        getting pointer issues.

        Alternatively you can directly set the data array:

        `$scope.gridOptions.data = [ ];`
        or

        `$http.get('/data/100.json')
        .success(function(data) {
           $scope.myData = data;
           $scope.gridOptions.data = $scope.myData;
          });`

        Where you do this, you need to take care in updating the data - you can't just update `$scope.myData` to some
        other array, you need to update $scope.gridOptions.data to point to that new array as well.
        */
        data?: Array<TEntity>| string,

        /**
         * True by default. When enabled, this setting displays a column
         * menu within each column.
         * @default  true
         */
        enableColumnMenus?: boolean,

        /**
         * False by default. When enabled, this setting adds filter
         * boxes to each column header, allowing filtering within the column for the entire grid.
        Filtering can then be disabled on individual columns using the columnDefs.
         * @default  false
        */
        enableFiltering?: boolean,

        /**
         * False by default. When enabled, this adds a settings icon in the top right of the grid,
         * which floats above the column header. The menu by default gives access to show/hide columns,
        but can be customized to show additional actions.
         * @default  false
        */
        enableGridMenu?: boolean,

        /**
         * uiGridConstants.scrollbars.ALWAYS by default. This settings controls the horizontal scrollbar for the grid.
         * Supported values: uiGridConstants.scrollbars.ALWAYS, uiGridConstants.scrollbars.NEVER
         * @default  1
         */
        enableHorizontalScrollbar?: boolean | number,

        /**
         * True by default. When enabled, a newly initialized grid will check to see if it is tall enough to display
         * at least one row of data.  If the grid is not tall enough, it will resize the DOM element to display
        minRowsToShow number of rows.
         * @default  true
        */
        enableMinHeightCheck?: boolean,

        /**
         * True by default. When enabled, this setting allows uiGrid to add
         * `$$hashKey`-type properties (similar to Angular) to elements in the `data` array. This allows
        the grid to maintain state while vastly speeding up the process of altering `data` by
        adding/moving/removing rows.

        Note that this DOES add properties to your data that you may not want, but they are stripped out when
        using `angular.toJson()`. IF you do not want this at all you can disable this setting but you will take a
        performance hit if you are using large numbers of rows
        and are altering the data set often.
         * @default  true
        */
        enableRowHashing?: boolean,

        /**
         * True by default. When enabled, this setting adds sort
         * widgets to the column headers, allowing sorting of the data for the entire grid.
        Sorting can then be disabled on individual columns using the columnDefs.
         * @default  true
        */
        enableSorting?: boolean,

        /**
         * uiGridConstants.scrollbars.ALWAYS by default. This settings controls the vertical scrollbar for the grid.
         * Supported values: uiGridConstants.scrollbars.ALWAYS, uiGridConstants.scrollbars.NEVER
         * @default  1
         */
        enableVerticalScrollbar?: boolean | number,

        /**
         * Extra columns to to render outside of the viewport, which helps with smoothness of scrolling.
         * Defaults to 4
         * @default  4
         */
        excessColumns?: number,

        /**
         * Extra rows to to render outside of the viewport, which helps with smoothness of scrolling.
         * Defaults to 4
         * @default  4
         */
        excessRows?: number,

        /**
         * Array of property names in data to ignore when auto-generating column names.  Provides the
         * inverse of columnDefs - columnDefs is a list of columns to include, excludeProperties is a list of columns
        to exclude.

        If columnDefs is defined, this will be ignored.

        Defaults to ['$$hashKey']
        */
        excludeProperties?: Array<string>,

        /**
         * Set to true if your columns are all related directly to fields in a flat object structure - i.e.
         * each of your columns associate directly with a propery one each of the entities in your data array.

        In that situation we can avoid all the logic associated with complex binding to functions or to properties
        of sub-objects, which can provide a significant speed improvement with large data sets, with filtering and
        with sorting.

        By default false
         * @default  false
        */
        flatEntityAccess?: boolean,

        /**
         * (optional) ui-grid/ui-grid-footer by default.  This footer shows the per-column
         * aggregation totals.
        When provided, this setting uses a custom footer template. Can be set to either the name of a template
        file 'footer_template.html', inline html
        <pre>'<div class="ui-grid-bottom-panel" style="text-align: center">I am a Custom Grid Footer</div>'</pre>,
        or the id of a precompiled template (TBD how to use this).  Refer to the custom footer tutorial for more
        information.
         * @default  'ui-grid/ui-grid-footer'
        */
        footerTemplate?: string,

        /**
         * (optional) ui-grid/ui-grid-grid-footer by default. This template by default shows the
         * total items at the bottom of the grid, and the selected items if selection is enabled.
         * @default  'ui-grid/ui-grid-grid-footer'
         */
        gridFooterTemplate?: string,

        /**
         * Null by default. When provided, this setting uses a custom header
         * template, rather than the default template. Can be set to either the name of a template file:
        <pre>  $scope.gridOptions.headerTemplate = 'header_template.html';</pre>
        inline html
        <pre>  $scope.gridOptions.headerTemplate = '<div class="ui-grid-top-panel" style="text-align: center">
             I am a Custom Grid Header</div>'</pre>
        or the id of a precompiled template (TBD how to use this).
        </br>Refer to the custom header tutorial for more information.
        If you want no header at all, you can set to an empty div:
        <pre>  $scope.gridOptions.headerTemplate = '<div></div>';</pre>

        If you want to only have a static header, then you can set to static content.  If
        you want to tailor the existing column headers, then you should look at the
        current 'ui-grid-header.html' template in github as your starting point.
         * @default  null
        */
        headerTemplate?: string,

        /**
         * Defaults to 4
         * @default  4
         */
        horizontalScrollThreshold?: number,

        /**
         * Number of rows from the end of the dataset
         * at which infinite scroll will trigger a request
        for more data
         * @default  20
        */
        infiniteScrollRowsFromEnd?: number,

        /**
         * Inform the grid of whether there are rows
         * to load when scrolling up
         * @default  false
         */
        infiniteScrollUp?: boolean,

        /**
         * Inform the grid of whether there are rows
         * to load scrolling down
         * @default  true
         */
        infiniteScrollDown?: boolean,

        /**
         * Defaults to 200
         * @default  200
         */
        maxVisibleColumnCount?: number,

        /**
         * Minimum number of rows to show when the grid doesn't have a defined height. Defaults to "10".
         * @default  10
         */
        minRowsToShow?: number,

        /**
         * Columns can't be smaller than this, defaults to 10 pixels
         * @default  10
         */
        minimumColumnSize?: number,

        /**
         * A callback that returns the gridApi once the grid is instantiated, which is
         * then used to interact with the grid programatically.

        Note that the gridApi.core.renderingComplete event is identical to this
        callback, but has the advantage that it can be called from multiple places
        if needed
         * @param  
        */
        onRegisterApi?: (gridApi: uiGrid$IGridApiOf<TEntity>) => void,

        /**
         * The height of the row in pixels, defaults to 30
         * @default  30
         */
        rowHeight?: number,

        /**
         * 'ui-grid/ui-grid-row' by default. When provided, this setting uses a
         * custom row template.  Can be set to either the name of a template file:
        <pre> $scope.gridOptions.rowTemplate = 'row_template.html';</pre>
        inline html
        <pre>  $scope.gridOptions.rowTemplate =
        '<div style="background-color: aquamarine"
               ng-click="grid.appScope.fnOne(row)"
               ng-repeat="col in colContainer.renderedColumns track by col.colDef.name"
               class="ui-grid-cell" ui-grid-cell></div>';</pre>
        or the id of a precompiled template (TBD how to use this) can be provided.
        </br>Refer to the custom row template tutorial for more information.
         * @default  'ui-grid/ui-grid-row'
        */
        rowTemplate?: string,

        /**
         * Default time in milliseconds to debounce scroll events, defaults to 300ms
         * @default  300
         */
        scrollDebounce?: number,

        /**
         * Defaults to 4
         * @default  4
         */
        scrollThreshold?: number,

        /**
         * Whether or not to show the column footer, defaults to false
         * The column footer displays column aggregates
         * @default  false
         */
        showColumnFooter?: boolean,

        /**
         * Whether or not to show the footer, defaults to false
         * The footer display Total Rows and Visible Rows (filtered rows)
         * @default  false
         */
        showGridFooter?: boolean,

        /**
         * True by default. When set to false, this setting will replace the
         * standard header template with '<div></div>', resulting in no header being shown.
         * @default  true
         */
        showHeader?: boolean,

        /**
         * Turn virtualization on when number of data elements goes over this number, defaults to 20
         * @default  20
         */
        virtualizationThreshold?: number,

        /**
         * Disables client side filtering. When true, handle the filterChanged event and set data,
         * defaults to false
         * @default  false
         */
        useExternalFiltering?: boolean,

        /**
         * Disables client side sorting. When true, handle the sortChanged event and do the sorting there
         * @default  false
         */
        useExternalSorting?: boolean,

        /**
         * Default time in milliseconds to throttle scroll events to, defaults to 70ms
         * @default  70
         */
        wheelScrollThrottle?: number,

        /**
         * This function returns the identity value uniquely identifying this row,
         * if one is not present it does not set it.

        By default it returns the `$$hashKey` property but can be overridden to use any property
        or set of properties you want.
         * @param  The row for which you want the unique id
         * @returns  row uid
        */
        getRowIdentity(row: uiGrid$IGridRowOf<TEntity>): any,

        /**
         * By default, rows are compared using object equality.  This option can be overridden
         * to compare on any data item property or function
         * @param  First Data Item to compare
         * @param  Second Data Item to compare
         */
        rowEquality(entityA: TEntity, entityB: TEntity): boolean,

        /**
         * This function is used to get and, if necessary, set the value uniquely identifying this row
         * (i.e. if an identity is not present it will set one).

        By default it returns the `$$hashKey` property if it exists. If it doesn't it uses gridUtil.nextUid()
        to generate one
        */
        rowIdentity(row: uiGrid$IGridRowOf<TEntity>): any
    } & & & & & & & & & & & & & & & &


    declare export interface uiGrid$IGridCoreApi<TEntity>{

    /**
     * adds a row header column to the grid
     * @param  Column Definition
     */
    addRowHeaderColumn(column: uiGrid$IColumnDefOf<TEntity>): void,

    /**
     * add items to the grid menu.  Used by features
     * to add their menu items if they are enabled, can also be used by
    end users to add menu items.  This method has the advantage of allowing
    remove again, which can simplify management of which items are included
    in the menu when.  (Noting that in most cases the shown and active functions
    provide a better way to handle visibility of menu items)
     * @param  the grid on which we are acting
     * @param  menu items in the format as described in the tutorial, with
    the added note that if you want to use remove you must also specify an `id` field,
    which is provided when you want to remove an item.  The id should be unique.
    */
    addToGridMenu(grid: uiGrid$IGridInstanceOf<TEntity>, items: Array<uiGrid$IMenuItem>): void,

    /**
     * Clears all filters and optionally refreshes the visible rows.
     * @param  Defaults to true.
     * @param  Defaults to false.
     * @param  Defaults to false.
     * @returns  <any>} If `refreshRows` is true, returns a promise of the rows refreshing.
     */
    clearAllFilters(
        refreshRows?: boolean,
        clearConditions?: boolean,
        clearFlags?: boolean): ng.IPromise<Array<uiGrid$IGridRowOf<TEntity >>> ,

    /**
     * Clears any override on visibility for the row so that it returns to
     * using normal filtering and other visibility calculations.
    If the row is currently invisible then sets it to visible and calls
    both grid refresh and emits the rowsVisibleChanged event
    TODO: if a filter is active then we can't just set it to visible?
     * @param  gridOptions.data[] array instance
    */
    clearRowInvisible(rowEntity: TEntity): void,

    /**
     * Returns all visible rows
     * @param  the grid you want to get visible rows from
     * @returns  an array of gridRow
     */
    getVisibleRows(grid: uiGrid$IGridInstanceOf<TEntity>): Array<uiGrid$IGridRowOf<TEntity >> ,

    /**
     * Trigger a grid resize, normally this would be picked
     * up by a watch on window size, but in some circumstances it is necessary
    to call this manually
     * @returns  <any>} promise that is resolved when render completes?
    */
    handleWindowResize(): void,

    /**
     * Notify the grid that a data or config change has occurred,
     * where that change isn't something the grid was otherwise noticing.  This
    might be particularly relevant where you've changed values within the data
    and you'd like cell classes to be re-evaluated, or changed config within
    the columnDef and you'd like headerCellClasses to be re-evaluated.
     * @param  one of the
    uiGridConstants.dataChange values (ALL, ROW, EDIT, COLUMN), which tells
    us which refreshes to fire.
    */
    notifyDataChange(type: string): void,

    /**
     * Refresh the rendered grid on screen.
     * @param  Optional flag for refreshing when the number of rows has changed.
     */
    refresh(rowsAltered?: boolean): ng.IPromise<any>,

    /**
     * Refresh the rendered rows on screen?  Note: not functional at present
     * @returns  <any>} promise that is resolved when render completes?
     */
    refreshRows(): ng.IPromise<boolean>,

    /**
     * Register a "columns processor" function. When the columns are updated,
     * the grid calls each registered "columns processor", which has a chance
    to alter the set of columns as long as the count is not
    modified.
     * @param  columns processor function, which
    is run in the context of the grid (i.e. this for the function will be the grid), and must
    return the updated columns list, which is passed to the next processor in the chain
     * @param  the priority of this processor.  In general we try to do them in 100s to leave room
    for other people to inject columns processors at intermediate priorities.  Lower priority
    columnsProcessors run earlier.

    At present allRowsVisible is running at 50, filter is running at 100, sort is at 200, grouping at 400,
    selectable rows at 500, pagination at 900 (pagination will generally want to be last)
    */
    registerColumnsProcessor(processorFunction: uiGrid$IColumnProcessor<TEntity>, priority: number): void,

    /**
     * Register a "rows processor" function. When the rows are updated,
     * the grid calls each registered "rows processor", which has a chance
    to alter the set of rows (sorting, etc) as long as the count is not
    modified.
     * @param  rows processor function, which
    is run in the context of the grid (i.e. this for the function will be the grid), and must
    return the updated rows list, which is passed to the next processor in the chain
     * @param  the priority of this processor.  In general we try to do them in 100s to leave room
    for other people to inject rows processors at intermediate priorities.  Lower priority rowsProcessors
    run earlier.

    At present all rows visible is running at 50, filter is running at 100, sort is at 200, grouping at 400,
    selectable rows at 500, pagination at 900 (pagination will generally want to be last)
    */
    registerRowsProcessor(rowProcessor: uiGrid$IRowProcessor<TEntity>, priority: number): void,

    /**
     * Scroll the grid such that the specified
     * row and column is in view
     * @param  gridOptions.data[] array instance to make visible
     * @param  to make visible
     * @returns  <any>} a promise that is resolved after any scrolling is finished
     */
    scrollTo(entity: TEntity, colDef: uiGrid$IColumnDefOf<TEntity>): void,

    /**
     * Scrolls the grid to make a certain row and column combo visible,
     * in the case that it is not completely visible on the screen already.
     * @param  row to make visible
     * @param  column to make visible
     * @returns  <any>} a promise that is resolved when scrolling is complete
     */
    scrollToIfNecessary(
        gridRow: uiGrid$IGridRowOf<TEntity>,
        gridCol: uiGrid$IGridColumnOf<TEntity>): void,

    /**
     * A null handling method that can be used when building custom sort
     * functions
     * @param  Sort value a
     * @param  Sort value b
     * @returns  null if there were no nulls/undefineds, otherwise returns
    a sort value that should be passed back from the sort function
    */
    sortHandleNulls(a: any, b: any): number,

    /**
     * queues a grid refresh, a way of debouncing all the refreshes we might otherwise issue
     */
    queueGridRefresh(): void,

    /**
     * queues a grid refreshCanvas, a way of debouncing all the refreshes we might otherwise issue
     */
    queueRefresh(): void,
    on: {

        /**
         * is raised when the canvas height has changed
         * @param  Grid scope
         * @param  Callback
         */
        canvasHeightChanged: (scope: ng.IScope, handler: uiGrid$canvasHeightChangedHandler) => void,

        /**
         * The visibility of a column has changed, the column itself is passed out as a parameter of the event
         * @param  The scope of the controller. This is used to deregister this event when the
        scope is destroyed
         * @param  Will be called when the event is emited.
        The function passes back the GridCol that has changed
        */
        columnVisibilityChanged: (
            scope: ng.IScope,
            callBack: uiGrid$columnVisibilityChangedHandler<TEntity>) => void,

        /**
         * is raised after the filter is changed.
         * The nature of the watch expression doesn't allow notification of what changed,
        so the receiver of this event will need to re-extract the filter conditions from the columns.
         * @param  Grid scope
         * @param  Callback
        */
        filterChanged: (scope: ng.IScope, handler: uiGrid$filterChangedHandler<TEntity>) => void,

        /**
         * is raised after the cache of visible rows is changed
         * @param  Grid scope
         * @param  callback
         */
        rowsRendered: (scope: ng.IScope, handler: uiGrid$rowsRenderedHandler<TEntity>) => void,

        /**
         * is raised after the rows that are visible change.
         * The filtering is zero-based, so it isn't possible to say which rows changed
        (unlike in the selection feature). We can plausibly know which row was changed when setRowInvisible is
        called, but in that situation the user already knows which row they changed.
        When a filter runs we don't know what changed, and that is the one that would have been useful.
         * @param  Grid scope
         * @param  callback
        */
        rowsVisibleChanged: (scope: ng.IScope, handler: uiGrid$rowsVisibleChangedHandler<TEntity>) => void,

        /**
         * is raised when scroll begins. Is throttled, so won't be raised too frequently
         * @param  Grid scope
         * @param  callback
         */
        scrollBegin: (scope: ng.IScope, handler: uiGrid$scrollBeginHandler) => void,

        /**
         * is raised when scroll has finished. Is throttled, so won't be raised too frequently
         * @param  Grid scope
         * @param  callback
         */
        scrollEnd: (scope: ng.IScope, handler: uiGrid$scrollEndHandler) => void,

        /**
         * is raised after the sort criteria on one or more columns have changed
         * @param  Grid scope
         * @param  callback
         */
        sortChanged: (scope: ng.IScope, handler: uiGrid$sortChangedHandler<TEntity>) => void
    }
}

declare export interface uiGrid$columnVisibilityChangedHandler<TEntity>{

    /**
     * Column visibility changed event handler
     * @param  Ui Grid column
     */
    (column: uiGrid$IGridColumnOf<TEntity>): void
}

declare export interface uiGrid$canvasHeightChangedHandler {

    /**
     * Canvas height changed callback
     * @param  old Height
     * @param  new Height
     */
    (oldHeight: number, newHeight: number): void
}

declare export interface uiGrid$filterChangedHandler<TEntity>{

    /**
     * Filter changed event callback
     * @param  grid api
     */
    (gridApi: uiGrid$IGridApiOf<TEntity>): void
}

declare export interface uiGrid$rowsRenderedHandler<TEntity>{

    /**
     * Rows rendered event callback
     * @param  Grid api object
     */
    (gridApi: uiGrid$IGridApiOf<TEntity>): void
}

declare export interface uiGrid$rowsVisibleChangedHandler<TEntity>{

    /**
     * Rows visible changed event callback
     * @param  grid api object
     */
    (gridApi: uiGrid$IGridApiOf<TEntity>): void
}

declare export interface uiGrid$scrollBeginHandler {

    /**
     * Scroll begin event callback
     * @param  Mouse scroll event
     */
    (scrollEvent: JQueryMouseEventObject): void
}

declare export interface uiGrid$scrollEndHandler {

    /**
     * Scroll end event callback
     * @param  Mouse scroll event
     */
    (scrollEvent: JQueryMouseEventObject): void
}

declare export interface uiGrid$sortChangedHandler<TEntity>{

    /**
     * Sort change event callback
     * @param  instance
     * @param  of gridColumns that have sorting on them, sorted in priority order
     */
    (grid: uiGrid$IGridInstanceOf<TEntity>, columns: Array<uiGrid$IGridColumnOf<TEntity >> ): void
}

declare module 'cellNav' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Cell Nav related grid row
     */
    declare     export interface IGridRow {

        /**
         * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
         * Group header rows, for example, would set this to false.
        Defaults to true
        */
        allowCellFocus?: boolean
    }
    declare     export interface ICellNavApi<TEntity>{

        /**
         * Gets the currently selected rows and columns.  array is empty if no selection has occurred
         * @returns  an array containing the current selection
         */
        getCurrentSelection(): Array<IRowCol<TEntity >> ,

        /**
         * Gets the current focused cell.  value is null if no selection has occurred
         * @returns  the current (or last if Grid does not have focus) focused row and column
         */
        getFocusedCell(): IRowCol<TEntity>,

        /**
         * Gets the index of the passed rowCol.  Returns -1 if the RowCol isn't selected
         * @param rowCol 
         * @returns  the index in the order in which the RowCol was selected
         */
        rowColSelectIndex(rowCol: IRowCol<TEntity>): number,

        /**
         * Brings the specified row and column into view, and sets focus to that cell
         * @param  gridOptions.data[] array instance to make visible and set focus
         * @param  Column definition to make visible and set focus
         */
        scrollToFocus(rowEntity: TEntity, colDef: uiGrid$IColumnDef): ng.IPromise<any>,
        on: {

            /**
             * raised when the active cell is changed
             * @param  The grid scope
             * @param  Callback
             */
            navigate: (scope: ng.IScope, handler: navigateHandler<TEntity>) => void,

            /**
             * viewportKeyDown is raised when the viewPort receives a keyDown event.
             * Cells never get focus in uiGrid due to the difficulties of setting focus on a cell that is
            not visible in the viewport. Use this event whenever you need a keydown event on a cell.
             * @param  The grid scope
             * @param  Callback
            */
            viewportKeyDown: (scope: ng.IScope, handler: viewportKeyDownHandler<TEntity>) => void,

            /**
             * viewportKeyPress is raised when the viewPort receives a keyPress event.
             * Cells never get focus in uiGrid due to the difficulties of setting focus on a cell that is
            not visible in the viewport. Use this event whenever you need a keypress event on a cell.
             * @param  The grid scope
             * @param  Callback
            */
            viewportKeyPress: (scope: ng.IScope, handler: viewportKeyPressHandler<TEntity>) => void
        }
    }
    declare     export interface navigateHandler<TEntity>{

        /**
         * Callback for navigate event
         * @param  New position
         * @param  Old position
         */
        (newRowCol: IRowCol<TEntity>, oldRowCol: IRowCol<TEntity>): void
    }
    declare     export interface viewportKeyDownHandler<TEntity>{

        /**
         * Callback for viewport key down event
         * @param  Keydown event
         * @param  Current row Col position
         */
        (event: JQueryKeyEventObject, rowCol: IRowCol<TEntity>): void
    }
    declare     export interface viewportKeyPressHandler<TEntity>{

        /**
         * Callback for viewport key press event
         * @param  Keypress event
         * @param  Current row Col position
         */
        (event: JQueryKeyEventObject, rowCol: IRowCol<TEntity>): void
    }
    declare     export interface IRowColConstructor<TEntity>{
        new(
            row: uiGrid$IGridRowOf<TEntity>,
            col: uiGrid$IGridColumnOf<TEntity>): IRowCol<TEntity >
    }

    /**
     * A row and column pair that represents the intersection of these two entities
     */
    declare     export interface IRowCol<TEntity>{
        row: uiGrid$IGridRowOf<TEntity>,
        col: uiGrid$IGridColumnOf<TEntity>,

        /**
         * Gets the intersection of where the row and column meet
         * @returns  The value from the grid data that this RowCol points to.  If the column has a cellFilter this
        will NOT return the filtered value.
        */
        getIntersectionValueRaw(): String | Number | Object,

        /**
         * Gets the intersection of where the row and column meet.
         * @returns  The value from the grid data that this RowCol points to.  If the column has a cellFilter this
        will also apply the filter to it and return the value that the filter displays
        */
        getIntersectionValueFiltered(): String | Number | Object
    }

    /**
     * constants available in cellNav
     */
    declare     export interface IUiGridCellNavConstants {
        FEATURE_NAME: string,
            CELL_NAV_EVENT: string,
            direction: {
                LEFT: number,
                RIGHT: number,
                UP: number,
                DOWN: number,
                PG_UP: number,
                PG_DOWN: number
            },
            EVENT_TYPE: {
                KEYDOWN: number,
                CLICK: number,
                CLEAR: number
            }
    }
}


declare module 'edit' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export interface IEditDropdown {
        id: number | string,
            value: any
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Cell Nav related grid row
     */
    declare     export interface IGridRow {

        /**
         * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
         * Group header rows, for example, would set this to false.
        Defaults to true
        */
        allowCellFocus?: boolean
    }

    /**
     * Public Api for edit feature
     */
    declare     export interface IGridEditApi<TEntity>{
        on: {

            /**
             * raised when cell editing is complete
             * @param scope The grid scope
             * @param  Callback
             */
            afterCellEdit: (scope: ng.IScope, handler: afterCellEditHandler<TEntity>) => void,

            /**
             * raised when cell editing starts on a cell
             * @param scope The grid scope
             * @param  Callback
             */
            beginCellEdit: (scope: ng.IScope, handler: beginCellEditHandler<TEntity>) => void,

            /**
             * raised when cell editing is cancelled on a cell
             * @param scope The grid scope
             * @param  Callback
             */
            cancelCellEdit: (scope: ng.IScope, handler: cancelCellEditHandler<TEntity>) => void
        }
    }
    declare     export interface afterCellEditHandler<TEntity>{

        /**
         * raised when cell editing is complete
         * @param  the options.data element that was edited
         * @param  The column that was edited
         * @param  New Value
         * @param  Old Value
         */
        (rowEntity: TEntity, colDef: uiGrid$IColumnDef<TEntity>, newValue: any, oldValue: any): void
    }

    /**
     * raised when cell editing starts on a cell
     * @param  the options.data element that was edited
     * @param  The column that was edited
     * @param  the event that triggered the edit. Useful to prevent losing
    keystrokes on some complex editors
    */
    declare     export interface beginCellEditHandler<TEntity>{
        (rowEntity: TEntity, colDef: uiGrid$IColumnDef<TEntity>, triggerEvent: JQueryEventObject): void
    }

    /**
     * raised when cell editing is cancelled on a cell
     * @param  the options.data element that was edited
     * @param  The column that was edited
     */
    declare     export interface cancelCellEditHandler<TEntity>{
        (rowEntity: TEntity, colDef: uiGrid$IColumnDef<TEntity>): void
    }

    /**
     * constants available in edit module
     */
    declare     export interface IUiGridEditConstants {
        EDITABLE_CELL_TEMPLATE: string,
            EDITABLE_CELL_DIRECTIVE: string,
            events: {
                BEGIN_CELL_EDIT: string,
                END_CELL_EDIT: string,
                CANCEL_CELL_EDIT: string
            }
    }
}


declare module 'expandable' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Public Api for expandable feature
     */
    declare     export interface IGridExpandableApi<TEntity>{

        /**
         * Collapse all subgrids.
         */
        collapseAllRows(): void,

        /**
         * expand all subgrids
         */
        expandAllRows(): void,

        /**
         * Toggle all subgrids
         */
        toggleAllRows(): void,

        /**
         * Toggle a specific row
         * @param  The data entity for the row you want to expand
         */
        toggleRowExpansion(rowEntity: TEntity): void,
        on: {

            /**
             * raised when cell editing is complete
             * @param  
             * @param  
             */
            rowExpandedStateChanged: (scope: ng.IScope, handler: rowExpandedStateChangedHandler<TEntity>) => void
        }
    }
    declare     export interface rowExpandedStateChangedHandler<TEntity>{

        /**
         * Raised when cell editing is complete
         * @param  The row that was expanded
         */
        (row: uiGrid$IGridRowOf<TEntity>): void
    }

    /**
     * Cell Nav related grid row
     */
    declare     export interface IGridRow {

        /**
         * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
         * Group header rows, for example, would set this to false.
        Defaults to true
        */
        allowCellFocus?: boolean
    }
}


declare module 'exporter' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Cell Nav related grid row
     */
    declare     export interface IGridRow {

        /**
         * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
         * Group header rows, for example, would set this to false.
        Defaults to true
        */
        allowCellFocus?: boolean
    }

    /**
     * Public Api for exporter feature
     */
    declare     export interface IGridExporterApi {

        /**
         * Exports rows from the grid in csv format, the data exported is selected based on the provided options
         * @param  which rows to export, valid values are uiGridExporterConstants.ALL,
        uiGridExporterConstants.VISIBLE, uiGridExporterConstants.SELECTED
         * @param  which columns to export, valid values are uiGridExporterConstants.ALL,
        uiGridExporterConstants.VISIBLE
        */
        csvExport(rowTypes: string, colTypes: string): void,

            /**
             * Exports rows from the grid in pdf format, the data exported is selected based on the provided options
             * Note that this function has a dependency on pdfMake, all going well this has been installed for you. The
            resulting pdf opens in a new browser window.
             * @param  which rows to export, valid values are uiGridExporterConstants.ALL,
            uiGridExporterConstants.VISIBLE, uiGridExporterConstants.SELECTED
             * @param  which columns to export, valid values are uiGridExporterConstants.ALL,
            uiGridExporterConstants.VISIBLE
            */
            pdfExport(rowTypes: string, colTypes: string): void
    }

    /**
     * constants available in exporter module
     */
    declare     export interface IUiGridExporterConstants {
        featureName: string,

            /**
             * export all data, including data not visible.  Can be set for either rowTypes or colTypes 
             */
            ALL: string,

            /**
             * export only visible data, including data not visible.  Can be set for either rowTypes or colTypes 
             */
            VISIBLE: string,

            /**
             * Export all data, including data not visible.
             * Can be set only for rowTypes, selection of only some columns is not supported
             */
            SELECTED: string,
            CSV_CONTENT: string,
            BUTTON_LABEL: string,
            FILE_NAME: string
    }
}


declare module 'grouping' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Public Api for grouping feature
     */
    declare     export interface IGridGroupingApi<TEntity>{

        /**
         * Sets the aggregation type on a column.
         * If the column is currently grouped then it removes the grouping first.
        If the aggregationDef is null then will result in the aggregation being removed.
         * @param  The name of the column we want to aggregate
         * @param  aggregationDef one of the recognised types from uiGridGroupingConstants or
        a custom aggregation function.
         * @param  The label to use for aggregation
        */
        aggregateColumn(columnName: string, or: string | Function, aggregationLabel?: string): void,

        /**
         * Clear any grouped columns and any aggregations.
         * Doesn't remove sorting, as we don't know whether that sorting was added by grouping or was there
        beforehand
        */
        clearGrouping(): void,

        /**
         * Get the grouping configuration for this grid, used by the saveState feature.
         * Adds expandedState to the information provided by the internal getGrouping,
        and removes any aggregations that have a source of grouping
        (i.e. will be automatically reapplied when we regroup the column)
         * @param  whether or not to return the expanded state
        */
        getGrouping(getExpanded: boolean): IGridGroupingConfiguration,

        /**
         * Adds this column to the existing grouping, at the end of the priority order.
         * If the column doesn't have a sort, adds one, by default ASC.
        This column will move to the left of any non-group columns.
        The move is handled in a columnProcessor, so it gets called as part of refresh.
         * @param  the name of the column we want to group
        */
        groupColumn(columnName: string): void,

        /**
         * Set the grouping configuration for this grid, used by the saveState feature,
         * but can also be used by any user to specify a combined grouping and aggregation configuration
         * @param  The config to apply, in the format provided out by getGrouping
         */
        setGrouping(config: IGridGroupingConfiguration): void,

        /**
         * Removes the groupPriority from this column.
         * If the column was previously aggregated the aggregation will come back. The sort will remain.

        This column will move to the right of any other group columns, the move is handled in a columnProcessor,
        so it gets called as part of refresh
         * @param  the name of the column to ungroup
        */
        ungroupColumn(columnName: string): void,
        on: {

            /**
             * raised whenever aggregation is changed, added or removed from a column
             * @param  Grid Scope
             * @param  Callback method
             */
            aggregationChanged: (scope: ng.IScope, handler: aggregationChangedHandler<TEntity>) => void,

            /**
             * raised whenever the grouped columns change
             * @param  Grid Scope
             * @param  Callback method
             */
            groupingChanged: (scope: ng.IScope, handler: groupingChangedHandler<TEntity>) => void
        }
    }

    /**
     * Grid grouping configuration for the grid.  Used by the saveState feature
     */
    declare     export interface IGridGroupingConfiguration {

        /**
         * GroupArray.  Sorted by groupPriority
         */
        grouping: Array<IGripGroup>,

            /**
             * Array of aggregation objects
             */
            treeAggregations: Array<IGridTreeAggregations>,

            /**
             * Hash of currently expanded nodes
             */
            expandedState?: IGridExpandedHash
    }
    declare     export interface IGripGroup {
        field: string,
            colName: string,
            groupPriority: number
    }
    declare     export interface IGridTreeAggregations {
        field: string,
            colName: string,
            aggregation: string
    }

    /**
     * Recursive hash of the currently expanded and collapsed nodes.
     */
    declare     export interface IGridExpandedHash {
        [key: string]: IGridExpandedHash | string
    }
    declare     export interface aggregationChangedHandler<TEntity>{

        /**
         * raised whenever aggregation is changed, added or removed from a column
         * @param  the column which on which aggregation changed.
        The aggregation type is available as col.treeAggregation.type
        */
        (col: uiGrid$IGridColumnOf<TEntity>): void
    }
    declare     export interface groupingChangedHandler<TEntity>{

        /**
         * raised whenever the grouped columns changes
         * @param  the column which on which grouping changed.
        The new grouping is available as col.grouping
        */
        (col: uiGrid$IGridColumnOf<TEntity>): void
    }

    /**
     * Constants available in grouping module including all constants declared in the treeBase module.
     * These are manually copied as there isn't an easy way to include constants in another constants file, and we
    don't want to make users include treeBase.
    */
    declare type IUiGridGroupingConstants = {
        featureName: string
    } & uiGrid$ISharedTreeConstants

}


declare module 'importer' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Public Api for importer feature
     */
    declare     export interface IGridImporterApi {

        /**
         * Imports a file into the grid using the file object provided. Bypasses the grid menu
         * @param  The file we want to import as a javascript File object
         */
        importFile(fileObject: File): void
    }

    /**
     * constants available in importer module
     */
    declare     export interface IUiGridImporterConstants {
        featureName: string
    }
}


declare module 'infiniteScroll' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Public API for infinite scroll feature
     */
    declare     export interface IGridInfiniteScrollApi<TEntity>{

        /**
         * Call this function when you have loaded the additional data requested.
         * You should set scrollUp and scrollDown to indicate whether there are still more pages in each direction.

        If you call dataLoaded without first calling saveScrollPercentage, then we will scroll the user to the
        start of the newly loaded data.  This usually makes scrolling smooth, but be jumpy with large
        infiniteScrollRowsFromEnd values, and on variable speed internet connections.
        Using saveScrollPercentage as demonstrated in the tutorial should give a smoother scrolling experience
        for users.

        See infinite_scroll tutorial for example of usage
         * @param  if set to false flags that there are no more pages upwards, so don't fire any
        more infinite scroll events upward
         * @param  if set to false flags that there are no more pages downwards, so don't fire
        any more infinite scroll events downward
         * @returns  <any>} a promise that is resolved when the grid scrolling is fully adjusted.
        If you're planning to remove pages, you should wait on this promise first, or you'll break the
        scroll positioning
        */
        dataLoaded(scrollUp: boolean, scrollDown: boolean): ng.IPromise<any>,

        /**
         * Adjusts the scroll position after you've removed data at the bottom
         * @param  flag that there are pages upwards, fire infinite scroll events upward
         * @param  flag that there are pages downwards, so fire infinite scroll events downward
         * @returns  <any>} A promise that is resolved when scrolling finishes
         */
        dataRemovedBottom(scrollUp: boolean, scrollDown: boolean): ng.IPromise<any>,

        /**
         * Adjusts the scroll position after you've removed data at the bottom.
         * You should have called saveScrollPercentage before you remove the data,
        and if you're doing this in response to a needMoreData you should wait
        until the promise from loadData has resolved before you start removing data
         * @param  the grid we're working on
         * @param  flag that there are pages upwards, fire infinite scroll events upward
         * @param  flag that there are pages downwards, so fire infinite scroll events downward
         * @returns  <any>} A promise that is resolved when scrolling finishes
        */
        dataRemovedBottom(
            grid: uiGrid$IGridInstanceOf<TEntity>,
            scrollUp: boolean,
            scrollDown: boolean): ng.IPromise<any>,

        /**
         * Adjusts the scroll position after you've removed data at the bottom
         * @param  flag that there are pages upwards, fire infinite scroll events upward
         * @param  flag that there are pages downwards, so fire infinite scroll events downward
         * @returns  <any>} A promise that is resolved when scrolling finishes
         */
        dataRemovedTop(scrollUp: boolean, scrollDown: boolean): ng.IPromise<any>,

        /**
         * Adjusts the scroll position after you've removed data at the bottom.
         * You should have called saveScrollPercentage before you remove the data,
        and if you're doing this in response to a needMoreData you should wait
        until the promise from loadData has resolved before you start removing data
         * @param  the grid we're working on
         * @param  flag that there are pages upwards, fire infinite scroll events upward
         * @param  flag that there are pages downwards, so fire infinite scroll events downward
         * @returns  <any>} A promise that is resolved when scrolling finishes
        */
        dataRemovedTop(
            grid: uiGrid$IGridInstanceOf<TEntity>,
            scrollUp: boolean,
            scrollDown: boolean): ng.IPromise<any>,

        /**
         * Call this function when you have taken some action that makes the current scroll position invalid.
         * For example, if you're using external sorting and you've resorted then you might reset the scroll,
        or if you've otherwise substantially changed the data, perhaps you've reused an
        existing grid for a new data set

        You must tell us whether there is data upwards or downwards after the reset
         * @param  flag that there are pages upwards, fire infinite scroll events upward
         * @param  flag that there are pages downwards, so fire infinite scroll events downward
         * @returns  <any>} A promise that is resolved when scrolling finishes
        */
        resetScroll(scrollUp: boolean, scrollDown: boolean): ng.IPromise<any>,

        /**
         * Saves the scroll percentage and number of visible rows before you adjust the data,
         * used if you're subsequently going to call dataRemovedTop or dataRemovedBottom
         */
        saveScrollPercentage(): void,
        on: {

            /**
             * This event fires when scroll reaches bottom percentage of grid and needs to load data
             */
            needLoadMoreData: Function,

            /**
             * This event fires when scroll reaches top percentage of grid and needs to load data
             */
            needLoadMoreDataTop: Function
        }
    }
}


declare module 'moveColumns' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridMoveColumnsApi {

        /**
         * Method can be used to change column position
         * @param  Original column position as a 0 indexed integer
         * @param  New column position as a 0 indexed integer
         */
        moveColumn(originalPosition: number, newPosition: number): void,
            on: {

                /**
                 * Raised when a column is moved
                 * @param  Grid Scope
                 * @param  Callback Function
                 */
                columnPositionChanged?: (scope: ng.IScope, handler: columnPositionChangedHandler) => void
            }
    }
    declare     export interface columnPositionChangedHandler {
        (colDef: uiGrid$IColumnDef, originalPosition: number, finalPosition: number): void
    }
}


declare module 'pagination' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridPaginationApi {

        /**
         * Get the current page
         * @returns  the number of the current page
         */
        getPage(): number,

            /**
             * Get the total number of pages
             * @returns  the total number of pages
             */
            getTotalPages(): number,

            /**
             * Moves to the next page if possible
             */
            nextPage(): void,

            /**
             * Moves to the previous page if we're not on the first page.
             */
            previousPage(): void,

            /**
             * Moves to the requested page
             * @param  The number of the page that should be displayed
             */
            seek(page: number): void,
            on: {

                /**
                 * This event fires when the pageSize or currentPage changes
                 * @param  The grid scope
                 * @param  Callback
                 */
                paginationChanged: (scope: ng.IScope, handler: paginationChangedHandler) => void
            }
    }

    /**
     * The callback for paginationChanged
     * @param  requested page number
     * @param  requested page size
     */
    declare     export interface paginationChangedHandler {
        (newPage: number, pageSize: number): void
    }
}


declare module 'pinning' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridPinningApi<TEntity>{

        /**
         * Pin column left, right, or none
         * @param  The column being pinned
         * @param  One of the recognized container types from uiGridPinningConstants
         */
        pinColumn(col: uiGrid$IGridColumnOf<TEntity>, container: string): void,

        /**
         * raised when column pin state has changed
         * @param  The grid scope
         * @param  Callback
         */
        columnPin: (scope: ng.IScope, handler: columnPinHandler) => void
    }
    declare     export interface columnPinHandler {

        /**
         * Callback to columnPin event
         * @param  The column that was changed
         * @param  The render container the column is in.  Options:
         * uiGridPinningConstants.container.LEFT
         * uiGridPinningConstants.container.RIGHT,
         * uiGridPinningConstants.container.NONE
         */
        (colDef: uiGrid$IColumnDef, container: string): void
    }
    declare     export interface IUiGridPinningConstants {
        container: {
            LEFT: string,
            RIGHT: string,
            NONE: string
        }
    }
}


declare module 'resizeColumns' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Public Api for column resize feature
     */
    declare     export interface IGridResizeColumnsApi {
        on: {

            /**
             * Raised when column is resized
             * @param  Grid Scope
             * @param  Callback
             */
            columnSizeChanged: (scope: ng.IScope, handler: columnSizeChangedHandler) => void
        }
    }
    declare     export interface columnSizeChangedHandler {

        /**
         * Callback when column size is changed
         * @param  The column that was resized
         * @param  The change in the size of the column
         */
        (colDef: uiGrid$IColumnDef, delta: number): void
    }
}


declare module 'rowEdit' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridRowEditApi<TEntity>{

        /**
         * Triggers a save event for all currently dirty rows.
         * Could be used where user presses a save button or navigates away from the page
         * @param  The grid
         * @returns  <Array<any>>} a promise that represents the aggregate of all of the individual save
        promises.  i.e. it will be resolved when all the individual save promises have been resolved.
        */
        flushDirtyRows(grid?: uiGrid$IGridInstanceOf<TEntity>): ng.IPromise<Array<any >> ,

        /**
         * Returns all currently dirty rows
         * @param  The target grid
         * @returns  An array of gridRows that are currently dirty
         */
        getDirtyRows(grid?: uiGrid$IGridInstanceOf<TEntity>): Array<uiGrid$IGridRowOf<TEntity >> ,

        /**
         * Returns all currently errored rows
         * @param  The target grid
         * @returns  An array of gridRows that are currently in error
         */
        getErrorRows(grid?: uiGrid$IGridInstanceOf<TEntity>): Array<uiGrid$IGridRowOf<TEntity >> ,

        /**
         * Sets each of the rows passed in dataRows to be clean,
         * removing them from the dirty cache and the error cache,
        and clearing the error flag and the dirty flag
         * @param  the data entities for which the gridRows should be set clean
        */
        setRowsClean(dataRows: Array<TEntity>): void,

        /**
         * Sets each of the rows passed in dataRows to be dirty,
         * Note that if you have only just inserted the rows into your data,
        you will need to wait for a $digest cycle before the gridRows are present.  As a result, this is often
        wrapped with $interval or $timeout.
         * @param  the data entities for which the gridRows should be set dirty
        */
        setRowsDirty(dataRows: Array<TEntity>): void,

        /**
         * Sets the promise associated with the row save, mandatory that the saveRow event handler calls this method
         * somewhere before returning<any>} savePromise A promise that will be resolved when the save is successful, or
              rejected if the save fails
         * @param  A data row from the grid for which a save has been initiated
        */
        setSavePromise(rowEntity: Object, savePromise: ng.IPromise<any>): void,
        on: {

            /**
             * Raised when a row is ready for saving.
             * Once your row has saved you may need to use angular.extend to update the data entity
            with any changed data from your save.
            i.e. lock version information, or last update time/user information

            Your method should call setSavePromise somewhere in the body before returning control.
            The feature will then wait, with the gridRow greyed out whilst this promise is being resolved.
             * @param  The grid scope
             * @param  Callback
            */
            saveRow: (scope: ng.IScope, handler: saveRowHandler<TEntity>) => void
        }
    }
    declare     export interface saveRowHandler<TEntity>{

        /**
         * Callback method for save row
         * @param  The options.data element that was edited
         */
        (rowEntity: TEntity): void
    }
}


declare module 'saveState' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridSaveStateApi {

        /**
         * Restores the provided state into the grid
         * @param  A scope we can broadcast on
         * @param  The state that should ve restored into the grid
         */
        restore($scope: ng.IScope, state: IGridSavedState): void,

            /**
             * Packages the current state of the grid into an object, and provides it to the user for saving
             * @returns  Current grid state as a POJO
             */
            save(): IGridSavedState
    }
    declare     export interface IGridSavedState {
        columns?: Array<ISavedColumn>,
            scrollFocus?: ISavedScrollFocus,
            selection: Array<IRowVal>,
            grouping: grouping.IGridGroupingConfiguration,
            treeView: treeBase.ITreeState
    }
    declare interface ISavedColumn {
        name: string,
            visible?: boolean,
            width?: number,
            sort?: uiGrid$ISortInfo,
            filters?: Array<uiGrid$IFilterOptions>,
            pinned?: string
    }
    declare interface ISavedScrollFocus {
        focus?: boolean,
            colName?: string,
            rowVal?: IRowVal
    }
    declare interface IRowVal {
        identity: boolean,
            row: number | any
    }
}


declare module 'selection' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;

    /**
     * Cell Nav related grid row
     */
    declare     export interface IGridRow {

        /**
         * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
         * Group header rows, for example, would set this to false.
        Defaults to true
        */
        allowCellFocus?: boolean
    }

    /**
     * Public Api for selection feature
     */
    declare     export interface IGridSelectionApi<TEntity>{

        /**
         * Unselects All Rows
         * @param  object if raised from event
         */
        clearSelectedRows(event?: ng.IAngularEvent): void,

        /**
         * Returns whether or not the selectAll checkbox is currently ticked.
         * The grid doesn't automatically select rows when you add extra data -
        so when you add data you need to explicitly check whether the selectAll is set,
        and then call setVisible rows if it is
         * @returns  Whether or not selectAll checkbox is ticked
        */
        getSelectAllState(): boolean,

        /**
         * returns all selected rows as gridRows
         * @returns  The selected rows
         */
        getSelectedGridRows(): Array<uiGrid$IGridRowOf<TEntity >> ,

        /**
         * Gets selected rows as entities
         * @returns  Selected row entities
         */
        getSelectedRows(): Array<TEntity>,

        /**
         * Selects all rows.  Does nothing if multiselect = false
         * @param  object if raised from event
         */
        selectAllRows(event?: ng.IAngularEvent): void,

        /**
         * Selects all visible rows.  Does nothing if multiselect = false
         * @param  object if raised from event
         */
        selectAllVisibleRows(event?: ng.IAngularEvent): void,

        /**
         * Select row by data
         * @param  gridOptions.data[] array value
         * @param  object if raised from event
         */
        selectRow(rowEntity: TEntity, event?: ng.IAngularEvent): void,

        /**
         * Select the specified row by visible index
         * (i.e. if you specify row 0 you'll get the first visible row selected).

        In this context visible means of those rows that are theoretically visible (i.e. not filtered),
        rather than rows currently rendered on the screen.
         * @param  Index within rowsVisible array
         * @param  object if raised from event
        */
        selectRowByVisibleIndex(index: number, event?: ng.IAngularEvent): void,

        /**
         * Sets the current gridOption.modifierKeysToMultiSelect to true or false
         * @param  true to only allow multiple rows when using ctrlKey or shiftKey is used
         */
        setModifierKeysToMultiSelect(multiSelect: boolean): void,

        /**
         * Sets the current gridOption.multiSelect to true or false
         * @param  true to allow multiple rows
         */
        setMultiSelect(multiSelect: boolean): void,

        /**
         * Toggles data row as selected or unselected
         * @param  gridOptions.data[] array value
         * @param  object if raised from event
         */
        toggleRowSelection(rowEntity: TEntity, event?: ng.IAngularEvent): void,

        /**
         * UnSelect the data row
         * @param  gridOptions.data[] array value
         * @param  object if raised from event
         */
        unSelectRow(rowEntity: TEntity, event?: ng.IAngularEvent): void,
        on: {

            /**
             * is raised after the row.isSelected state is changed
             * @param  grid scope
             * @param  callback
             */
            rowSelectionChanged: (scope: ng.IScope, handler: rowSelectionChangedHandler<TEntity>) => void,

            /**
             * is raised after the row.isSelected state is changed in bulk,
             * if the enableSelectionBatchEvent option is set to true (which it is by default).
            This allows more efficient processing of bulk events.
             * @param  grid scope
             * @param  callback
            */
            rowSelectionChangedBatch: (scope: ng.IScope, handler: rowSelectionChangedBatchHandler<TEntity>) => void
        }
    }
    declare     export interface rowSelectionChangedHandler<TEntity>{

        /**
         * Callback for row selection changed
         * @param  The selected rows
         * @param  object if raised from event
         */
        (row: uiGrid$IGridRowOf<TEntity>, event?: ng.IAngularEvent): void
    }
    declare     export interface rowSelectionChangedBatchHandler<TEntity>{

        /**
         * Callback for row selection changed batch
         * @param  The selected rows
         * @param  object if raised from event
         */
        (row: Array<uiGrid$IGridRowOf<TEntity >> , event?: ng.IAngularEvent): void
    }
}


declare module 'treeBase' {

    /**
     * Column Definitions for cellNav feature, these are available to be set using the ui-grid
     * gridOptions.columnDefs
     */
    declare     export interface IColumnDef {

        /**
         * Enable focus on a cell within this column.
         * Defaults to true
         * @default  true
         */
        allowCellFocus?: boolean
    }
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export interface IGridTreeBaseCustomAggregation<TEntity>{
        label: string,
        aggregationFn: (
            aggregation: IGridTreeBaseAggregationObject,
            fieldValue: any,
            numValue: number,
            row?: uiGrid$IGridRowOf<TEntity>) => void,
        finalizerFn?: (aggregation: IGridTreeBaseAggregationObject) => void
    }
    declare     export interface IGridTreeBaseAggregationObject {
        count: number,
            sum: number,
            value: number,
            rendered?: string
    }
    declare     export interface IGridTreeBaseApi<TEntity>{

        /**
         * Collapse all tree rows
         */
        collapseAllRows(): void,

        /**
         * collapse the specified row. When you expand the row again, all grandchildren will retain their state
         * @param  The row to collapse
         */
        collapseRow(row: uiGrid$IGridRowOf<TEntity>): void,

        /**
         * collapse all children of the specified row. When you expand the row again, all grandchildren will be
         * collapsed
         * @param  The row to collapse children of
         */
        collapseRowChildren(row: uiGrid$IGridRowOf<TEntity>): void,

        /**
         * Expands all tree rows
         */
        expandAllRows(): void,

        /**
         * Expand the immediate children of the specified row
         * @param  The row to expand
         */
        expandRow(row: uiGrid$IGridRowOf<TEntity>): void,

        /**
         * Get the children of the specified row
         * @param  The row you want the children of
         * @returns  Array<IGridRow> Array of children rows
         */
        getRowChildren(row: uiGrid$IGridRowOf<TEntity>): Array<uiGrid$IGridRowOf<TEntity >> ,

        /**
         * Get the tree state for this grid, used by the saveState feature Returned treeState as an object
         * ```{ expandedState: { uid: 'expanded', uid: 'collapsed' } }```
        where expandedState is a hash of row uid and the current expanded state
         * @returns  tree state
        NOTE this is an incomplete feature in uiGrid
        */
        getTreeState(): ITreeState,

        /**
         * Set the expanded states of the tree
         * @param  The config you want to apply, in the format provided by getTreeState
         */
        setTreeState(config: ITreeState): void,

        /**
         * call expand if row is collapsed, and collapse if it is expanded
         * @param  The row to toggle
         */
        toggleRowTreeState(row: uiGrid$IGridRowOf<TEntity>): void,
        on: {

            /**
             * Raised when a row is collapsed.  Doesn't really have a purpose at the moment.  Included for symmetry
             * @param  Grid scope
             * @param  Callback
             */
            rowCollapsed: (scope: ng.IScope, handler: rowCollapsedHandler<TEntity>) => void,

            /**
             * Raised whenever a row is expanded.
             * 
            If you are dynamically rendering your tree,
            in your callback you can retrieve the children of this row and load them into the grid data.

            When the data is loaded, the grid will automatically refresh to show these new rows.
             * @param  Grid Scope
             * @param  Callback
            */
            rowExpanded: (scope: ng.IScope, handler: rowExpandedHandler<TEntity>) => void
        }
    }
    declare     export interface ITreeState {
        expandedState: {
            [index: string]: string
        }
    }
    declare     export interface rowCollapsedHandler<TEntity>{

        /**
         * Row Collapsed callback
         * @param  The row that was collapsed.  You can also retrieve the grid from this row with
        row.grid
        */
        (row: uiGrid$IGridRowOf<TEntity>): void
    }
    declare     export interface rowExpandedHandler<TEntity>{

        /**
         * Row Expanded callback
         * @param  The row that was expanded.  You can also retrieve the grid from this row with
        row.grid
        */
        (row: uiGrid$IGridRowOf<TEntity>): void
    }

    /**
     * Constants available in treeBase module.
     * 
    These constants are manually copied into grouping and treeView,
    as I haven't found a way to simply include them,
    and it's not worth investing time in for something that changes very infrequently.
    */
    declare     export type IUiGridTreeBaseConstants = {
        featureName: string
    } & uiGrid$ISharedTreeConstants

}


declare module 'treeView' {
    declare     export type IGridOptions = uiGrid$IGridOptionsOf<any>;
    declare     export type IUiGridTreeViewConstants = {
        featureName: string
    } & uiGrid$ISharedTreeConstants

}


declare export interface uiGrid$ISharedTreeConstants {
    rowHeaderColName: string,
        EXPANDED: string,
        COLLAPSED: string,
        aggregation: {
            COUNT: string,
            SUM: string,
            MAX: string,
            MIN: string,
            AVG: string
        }
}

declare export interface uiGrid$IGridApiConstructor<TEntity>{
    new(grid: uiGrid$IGridInstanceOf<TEntity>): uiGrid$IGridApiOf<TEntity >
}

declare export type uiGrid$IGridApi = uiGrid$IGridApiOf<any>;

declare export interface uiGrid$IGridApiOf<TEntity>{

    /**
     * Registers a new event for the given feature. The event will get a .raise and .on prepended to it
     * 
    .raise.eventName() - takes no arguments

    .on.eventName(scope, callBackFn, _this)
    scope - a scope reference to add a deregister call to the scopes .$on('destroy').
    Scope is optional and can be a null value, but in this case you must deregister it yourself via the returned
    deregister function
    callBackFn - The function to call
    _this - optional this context variable for callbackFn. If omitted, grid.api will be used for the context

    .on.eventName returns a dereg function that will remove the listener. It's not necessary to use it as the
    listener will be removed when the scope is destroyed.
     * @param featureName name of the feature that raises the event
     * @param eventName name of the event
    */
    registerEvent(featureName: string, eventName: string): void,

    /**
     * Registers features and events from a simple objectMap.
     * eventObjectMap must be in this format (multiple features allowed)
     * @param eventObjectMap map of feature/event names
     */
    registerEventsFromObject(eventObjectMap: any): void,

    /**
     * Registers a new event for the given feature
     * @param featureName name of the feature
     * @param methodName name of the method
     * @param callBackFn function to execute
     * @param _this binds to callBackFn. Defaults to gridApi.grid
     */
    registerMethod(
        featureName: string,
        methodName: string,
        callBackFn: Function,
        _this: any): void,

    /**
     * Registers features and methods from a simple objectMap.
     * eventObjectMap must be in this format (multiple features allowed)
    {featureName: { methodNameOne:function(args){}, methodNameTwo:function(args){} }
     * @param eventObjectMap map of feature/event names
     * @param _this binds this to _this for all functions. Defaults to gridApi.grid
    */
    registerMethodsFromObject(eventObjectMap: any, _this: any): void,

    /**
     * Used to execute a function while disabling the specified event listeners.
     * Disables the listenerFunctions, executes the callbackFn, and then enables the listenerFunctions again
     * @param listenerFuncs listenerFunc or array of listenerFuncs to suppress.
    These must be the same functions that were used in the .on.eventName method
     * @param callBackFn function to execute
    */
    suppressEvents(listenerFuncs: Function | Array<Function>, callBackFn: Function): void,

    /**
     * Core Api
     */
    core: uiGrid$IGridCoreApi<TEntity>,

    /**
     * Cell Nav Api
     */
    cellNav: cellNav.ICellNavApi<TEntity>,

    /**
     * Move Columns Api
     */
    colMovable: moveColumns.IGridMoveColumnsApi,

    /**
     * Grid row resizable Api
     */
    colResizable: resizeColumns.IGridResizeColumnsApi,

    /**
     * Edit Api
     */
    edit: edit.IGridEditApi<TEntity>,

    /**
     * Expandable Api
     */
    expandable: expandable.IGridExpandableApi<TEntity>,

    /**
     * Exporter Api
     */
    exporter: exporter.IGridExporterApi,

    /**
     * Grouping Api
     */
    grouping: grouping.IGridGroupingApi<TEntity>,

    /**
     * Importer Api
     */
    importer: importer.IGridImporterApi,

    /**
     * Infinite Scroll Api
     */
    infiniteScroll: infiniteScroll.IGridInfiniteScrollApi<TEntity>,

    /**
     * Pagination Api
     */
    pagination: pagination.IGridPaginationApi,

    /**
     * Pinning Api
     */
    pinning: pinning.IGridPinningApi<TEntity>,

    /**
     * Grid Row Edit Api
     */
    rowEdit: rowEdit.IGridRowEditApi<TEntity>,

    /**
     * Grid Save State Api
     */
    saveState: saveState.IGridSaveStateApi,

    /**
     * Selection Api
     */
    selection: selection.IGridSelectionApi<TEntity>,

    /**
     * Tree Base Api
     */
    treeBase: treeBase.IGridTreeBaseApi<TEntity>,

    /**
     * A grid instance is made available in the gridApi.
     */
    grid: uiGrid$IGridInstanceOf<TEntity >
}

declare export interface uiGrid$IGridRowConstructor<TEntity>{

    /**
     * GridRow is the viewModel for one logical row on the grid.
     * A grid Row is not necessarily a one-to-one relation to gridOptions.data.
     * @param entity the array item from GridOptions.data
     * @param index the current position of the row in the array
     * @param reference to the parent grid
     */
    new(
        entity: TEntity,
        index: number,
        reference: uiGrid$IGridInstanceOf<TEntity>): uiGrid$IGridRowOf<TEntity >
}


/**
 * Cell Nav related grid row
 */
declare export interface uiGrid$IGridRow {

    /**
     * Enable focus on a cell within this row. If set to false then no cells in this row can be focused
     * Group header rows, for example, would set this to false.
    Defaults to true
    */
    allowCellFocus?: boolean
}

declare export type uiGrid$IGridRowOf<TEntity>= {

        /**
         * A reference to an item in gridOptions.data[] 
         */
        entity: TEntity,

        /**
         * A reference back to the grid 
         */
        grid: uiGrid$IGridInstanceOf<TEntity>,

        /**
         * height of each individual row. changing the height will flag all
         * row renderContainers to recalculate their canvas height
         */
        height: number,

        /**
         * uniqueId of row 
         */
        uid: string,

        /**
         * if true, row will be rendered 
         */
        visible: boolean,

        /**
         * If set to false, then don't export this row,
         * notwithstanding visible or other settings
        Defaults to true
         * @default  true
        */
        exporterEnableExporting: boolean,

        /**
         * Clears an override on the row that forces it to always be invisible.
         * Emits the rowsVisibleChanged event if it changed the row visibility.

        This method can be called from the api, passing in the gridRow we want altered.
        It should really work by calling gridRow.clearRowInvisible,
        but that's not the way I coded it, and too late to change now.
        Changed to just call the internal function row.clearThisRowInvisible().
         * @param row the row we want to clear the invisible flag
        */
        clearRowInvisible(row: uiGrid$IGridRowOf<TEntity>): void,

        /**
         * Clears any override on the row visibility, returning it to normal visibility calculations.
         * Emits the rowsVisibleChanged event
         * @param reason the reason (usually the module) for the row to be invisible. E.g. grouping, user, filter
         * @param fromRowsProcessor whether we were called from a rowsProcessor, passed through to evaluateRowVisibility
         */
        clearRowInvisible(reason: string, fromRowsProcessor: boolean): void,

        /**
         * Determines whether the row should be visible based on invisibleReason,
         * and if it changes the row visibility, then emits the rowsVisibleChanged event.
        Queues a grid refresh, but doesn't call it directly to avoid hitting lots of
        grid refreshes.
        */
        evaluateRowVisibility(fromRowProcessor: boolean): void,

        /**
         * returns the qualified field name minus the row path ie: entity.fieldA
         * @param col column instance
         * @returns  resulting name that can be evaluated against a row
         */
        getEntityQualifiedColField(col: uiGrid$IGridColumnOf<TEntity>): string,

        /**
         * returns the qualified field name as it exists on scope ie: row.entity.fieldA
         * @param col column instance
         * @returns  resulting name that can be evaluated on scope
         */
        getQualifiedColField(col: uiGrid$IGridColumnOf<TEntity>): string,

        /**
         * Sets an override on the row that forces it to always be invisible.
         * Emits the rowsVisibleChanged event if it changed the row visibility.
        This method can be called from the api, passing in the gridRow we want altered.
        It should really work by calling gridRow.setRowInvisible,
        but that's not the way I coded it, and too late to change now.
        Changed to just call the internal function row.setThisRowInvisible().
         * @param row the row we want to set to invisible
        */
        setRowInvisible(row: uiGrid$IGridRowOf<TEntity>): void,

        /**
         * Sets an override on the row that forces it to always be invisible.
         * Emits the rowsVisibleChanged event if it changed the row visibility
         * @param reason the reason (usually the module) for the row to be invisible. E.g. grouping, user, filter
         * @param fromRowsProcessor whether we were called from a rowsProcessor, passed through to evaluateRowVisibility
         */
        setThisRowInvisible(reason: string, fromRowsProcessor: boolean): void
    } & & & & &


    declare export interface uiGrid$IGridColumnConstructor<TEntity>{

    /**
     * Represents the viewModel for each column.
     * Any state or methods needed for a Grid Column are defined on this prototype
     * @param gridCol Column definition
     * @param index the current position of the column in the array
     * @param grid reference to the grid
     */
    new(
        gridCol: uiGrid$IColumnDefOf<TEntity>,
        index: number,
        grid: uiGrid$IGridInstanceOf<TEntity>): uiGrid$IGridColumnOf<TEntity >
}

declare export type uiGrid$IGridColumn = uiGrid$IGridColumnOf<any>;

declare export interface uiGrid$IGridColumnOf<TEntity>{

    /**
     * Column definition 
     */
    colDef: uiGrid$IColumnDefOf<TEntity>,

    /**
     * Column name that will be shown in the header.
     * If displayName is not provided then one is generated using the name.
     */
    displayName?: string,

    /**
     * field must be provided if you wish to bind to a property in the data source.
     * Should be an angular expression that evaluates against grid.options.data array element.
    Can be a complex expression: employee.address.city, or can be a function: employee.getFullAddress().
    See the angular docs on binding expressions.
    */
    field?: string,

    /**
     * Filter on this column 
     */
    filter?: uiGrid$IFilterOptions,

    /**
     * Filters for this column. Includes 'term' property bound to filter input elements 
     */
    filters?: Array<uiGrid$IFilterOptions>,

    /**
     * Reference to grid containing the column 
     */
    grid: uiGrid$IGridInstanceOf<TEntity>,
    name?: string,

    /**
     * Sort on this column 
     */
    sort?: uiGrid$ISortInfo,

    /**
     * Algorithm to use for sorting this column. Takes 'a' and 'b' parameters
     * like any normal sorting function with additional 'rowA', 'rowB', and 'direction'
    parameters that are the row objects and the current direction of the sort
    respectively.
    */
    sortingAlgorithm?: (
        a: any,
        b: any,
        rowA: uiGrid$IGridRowOf<TEntity>,
        rowB: uiGrid$IGridRowOf<TEntity>,
        direction: string) => number,

    /**
     * Column width 
     */
    width: number,

    /**
     * Initializes a column
     * @param colDef the column def to associate with this column
     * @param uid The unique and immutable uid we'd like to allocate to this column
     * @param grid the grid we'd like to create this column in
     */
    GridColumn(
        colDef: uiGrid$IColumnDefOf<TEntity>,
        uid: number,
        grid: uiGrid$IGridInstanceOf<TEntity>): void,

    /**
     * Gets the aggregation label from colDef.aggregationLabel if specified or by using i18n,
     * including deciding whether or not to display based on colDef.aggregationHideLabel.
     * @param label the i18n lookup value to use for the column label
     */
    getAggregationText(label: string): void,

    /**
     * gets the aggregation value based on the aggregation type for this column.
     * Debounced using scrollDebounce option setting
     */
    getAggregationValue(): string,

    /**
     * Returns the class name for the column
     * @param prefixDot if true, will return .className instead of className
     */
    getColClass(prefixDot: boolean): string,

    /**
     * Returns the class definition for th column 
     */
    getColClassDefinition(): string,

    /**
     * Returns the render container object that this column belongs to.
     * Columns will be default be in the body render container
    if they aren't allocated to one specifically.
    */
    getRenderContainer(): any,

    /**
     * Hides the column by setting colDef.visible = false 
     */
    hideColumn(): void,

    /**
     * Returns true if column is in the left render container 
     */
    isPinnedLeft(): boolean,

    /**
     * Returns true if column is in the right render container 
     */
    isPinnedRight(): boolean,

    /**
     * Sets a property on the column using the passed in columnDef,
     * and setting the defaultValue if the value cannot be found on the colDef
     * @param colDef the column def to look in for the property value
     * @param propName the property name we'd like to set
     * @param defaultValue the value to use if the colDef doesn't provide the setting
     */
    setPropertyOrDefault(
        colDef: uiGrid$IColumnDefOf<TEntity>,
        propName: string,
        defaultValue: any): void,

    /**
     * Makes the column visible by setting colDef.visible = true 
     */
    showColumn(): void,

    /**
     * Moves settings from the columnDef down onto the column, and sets properties as appropriate
     * @param colDef the column def to look in for property value
     * @param isNew whether the column is being newly created, if not we're updating an existing
    column, and some items such as the sort shouldn't be copied down
    */
    updateColumnDef(colDef: uiGrid$IColumnDefOf<TEntity>, isNew: boolean): void
}


/**
 * Column Definitions for cellNav feature, these are available to be set using the ui-grid
 * gridOptions.columnDefs
 */
declare export interface uiGrid$IColumnDef {

    /**
     * Enable focus on a cell within this column.
     * Defaults to true
     * @default  true
     */
    allowCellFocus?: boolean
}

declare export type uiGrid$IColumnDefOf<TEntity>= {

        /**
         * defaults to false
         * if set to true hides the label text in the aggregation footer, so only the value is displayed.
         */
        aggregationHideLabel?: boolean,

        /**
         * The aggregation that you'd like to show in the columnFooter for this column.
         * Valid values are in uiGridConstants, and currently include:
        uiGridConstants.aggregationTypes.count, uiGridConstants.aggregationTypes.sum,
        uiGridConstants.aggregationTypes.avg, uiGridConstants.aggregationTypes.min,
        uiGridConstants.aggregationTypes.max.

        You can also provide a function as the aggregation type,
        in this case your function needs to accept the full set of visible rows,
        and return a value that should be shown
        */
        aggregationType?: number | Function,

        /**
         * cellClass can be a string specifying the class to append to a cell
         * or it can be a function(row,rowRenderIndex, col, colRenderIndex)
        that returns a class name
        */
        cellClass?: string | uiGrid$ICellClassGetter<TEntity>,

        /**
         * cellFilter is a filter to apply to the content of each cell 
         */
        cellFilter?: string,

        /**
         * a custom template for each cell in this column.
         * The default is ui-grid/uiGridCell.
        If you are using the cellNav feature,
        this template must contain a div that can receive focus.
        */
        cellTemplate?: string,

        /**
         * Whether or not to show a tooltip when a user hovers over the cell.
         * If set to false, no tooltip.
        If true, the cell value is shown in the tooltip (useful if you have long values in your cells),
        if a function then that function is called passing in the row and the col cellTooltip(row, col)
        and the return value is shown in the tooltip,
        if it is a static string then displays that static string.
        Defaults to false
         * @default  false
        */
        cellTooltip?: boolean | string | uiGrid$ICellTooltipGetter<TEntity>,

        /**
         * Column name that will be shown in the header.
         * If displayName is not provided then one is generated using the name.
         */
        displayName?: string,

        /**
         * if column menus are enabled, controls the column menus for this specific column
         * (i.e. if gridOptions.enableColumnMenus, then you can control column menus using this option.
        If gridOptions.enableColumnMenus === false then you get no column menus irrespective of the value of this
        option
        ). Defaults to true.
         * @default  true
        */
        enableColumnMenu?: boolean,

        /**
         * Override for column menus everywhere - if set to false then you get no column menus.
         * Defaults to true
         * @default  true
         */
        enableColumnMenus?: boolean,

        /**
         * turn off filtering for an individual column, where you've turned on filtering for the overall grid 
         */
        enableFiltering?: boolean,

        /**
         * When set to false, this setting prevents a user from hiding the column using the column menu or the grid
         * menu.
         * @default  true
         */
        enableHiding?: boolean,

        /**
         * When enabled, this setting adds sort widgets to the column header, allowing sorting of the data in the
         * individual column.
         * @default  true
         */
        enableSorting?: boolean,

        /**
         * field must be provided if you wish to bind to a property in the data source.
         * Should be an angular expression that evaluates against grid.options.data array element
        Can be a complex expression: employee.address.city, or can be a function: employee.getFullAddress().
        See the angular docs on binding expressions.
        */
        field?: string,

        /**
         * Specify a single filter field on this column.
         * A filter consists of a condition, a term, and a placeholder:
         */
        filter?: uiGrid$IFilterOptions,

        /**
         * 
         * @default  false
        When true uiGrid will apply the cellFilter before applying search filters
        */
        filterCellFiltered?: boolean,

        /**
         * a custom template for the filter input. The default is ui-grid/ui-grid-filter
         */
        filterHeaderTemplate?: string,

        /**
         * Specify multiple filter fields 
         */
        filters?: Array<uiGrid$IFilterOptions>,

        /**
         * footerCellClass can be a string specifying the class to append to a cell or it can be
         * a function(row,rowRenderIndex, col, colRenderIndex) that returns a class name
         */
        footerCellClass?: string | uiGrid$IHeaderFooterCellClassGetter<TEntity>,

        /**
         * footerCellFilter is a filter to apply to the content of the column footer 
         */
        footerCellFilter?: string,

        /**
         * a custom template for the footer for this column. The default is ui-grid/uiGridFooterCell 
         */
        footerCellTemplate?: string,

        /**
         * headerCellClass can be a string specifying the class to append to a cell or it can be
         * a function(row,rowRenderIndex, col, colRenderIndex) that returns a class name
         */
        headerCellClass?: string | uiGrid$IHeaderFooterCellClassGetter<TEntity>,

        /**
         * headerCellFilter is a filter to apply to the content of the column header 
         */
        headerCellFilter?: string,

        /**
         * a custom template for the header for this column. The default is ui-grid/uiGridHeaderCell 
         */
        headerCellTemplate?: string,

        /**
         * Whether or not to show a tooltip when a user hovers over the header cell.
         * If set to false, no tooltip.
        If true, the displayName is shown in the tooltip
        (useful if you have long values in your headers),
        if a function then that function is called passing in the row and the col
        headerTooltip( col ), and the return value is shown in the tooltip,
        if a static string then shows that static string.
         * @default  false
        */
        headerTooltip?: boolean | string | uiGrid$IHeaderTooltipGetter<TEntity>,

        /**
         * sets the maximum column width 
         */
        maxWidth?: number,

        /**
         * used to add menu items to a column. Refer to the tutorial on this functionality 
         */
        menuItems?: Array<uiGrid$IMenuItem>,

        /**
         * Sets the minimum column width 
         */
        minWidth?: number,

        /**
         * (mandatory) each column should have a name,
         * although for backward compatibility with 2.x name can be omitted if field is present
         */
        name?: string,

        /**
         * An object of sort information 
         */
        sort?: uiGrid$ISortInfo,

        /**
         * 
         * @default  false
        When true uiGrid will apply the cellFilter before sorting the data
        Note that when using this option uiGrid will assume that the displayed value is a string,
        and use the sortAlpha sortFn.
        It is possible to return a non-string value from an angularjs filter,
        in which case you should define a sortingAlgorithm for the column
        which handles the returned type.
        You may specify one of the sortingAlgorithms found in the rowSorter service.
        */
        sortCellFiltered?: boolean,

        /**
         * (optional) An array of sort directions, specifying the order that they should cycle through as
         *  the user repeatedly clicks on the column heading. The default is [null, uiGridConstants.ASC, uiGridConstants.DESC].
         Null refers to the unsorted state. This does not affect the initial sort direction; use the sort property for that.
         If suppressRemoveSort is also set, the unsorted state will be skipped even if it is listed here. Each direction may
         not appear in the list more than once (e.g. [ASC, DESC, DESC] is not allowed), and the list may not be empty.
        */
        sortDirectionCycle?: Array<uiGrid$IUiGridConstants>,

        /**
         * Algorithm to use for sorting this column. Takes 'a' and 'b' parameters
         * like any normal sorting function with additional 'rowA', 'rowB', and 'direction'
        parameters that are the row objects and the current direction of the sort
        respectively.
        */
        sortingAlgorithm?: (
            a: any,
            b: any,
            rowA: uiGrid$IGridRowOf<TEntity>,
            rowB: uiGrid$IGridRowOf<TEntity>,
            direction: string) => number,

        /**
         * When enabled, this setting hides the removeSort option in the menu,
         * and prevents users from manually removing the sort
         * @default  false
         */
        suppressRemoveSort?: boolean,

        /**
         * the type of the column, used in sorting. If not provided then the grid will guess the type.
         * Add this only if the grid guessing is not to your satisfaction.
        Note that if you choose date, your dates should be in a javascript date type
        One of:
        'string', 'boolean', 'number', 'date', 'object', 'numberStr'
        */
        type?: string,

        /**
         * sets whether or not the column is visible
         * @default  true
         */
        visible?: boolean,

        /**
         * sets the column width.  Can be either a number or a percentage, or an  for auto.
         */
        width?: number | string
    } & & & & & & & &


    declare export interface uiGrid$ICellClassGetter<TEntity>{
    (grid?: uiGrid$IGridInstanceOf<TEntity>, gridRow?: uiGrid$IGridRowOf<TEntity>, gridCol?: uiGrid$IGridColumnOf<TEntity>, rowRenderIndex?: number, colRenderIndex?: number): string
}

declare export interface uiGrid$ICellTooltipGetter<TEntity>{
    (gridRow: uiGrid$IGridRowOf<TEntity>, gridCol: uiGrid$IGridColumnOf<TEntity>): string
}

declare export interface uiGrid$IHeaderTooltipGetter<TEntity>{
    (gridCol: uiGrid$IGridColumnOf<TEntity>): string
}

declare export interface uiGrid$IHeaderFooterCellClassGetter<TEntity>{
    (grid: uiGrid$IGridInstanceOf<TEntity>, gridRow: uiGrid$IGridRowOf<TEntity>, gridCol: uiGrid$IGridColumnOf<TEntity>, rowRenderIndex: number, colRenderIndex: number): string
}

declare export interface uiGrid$IMenuItem {

    /**
     * controls the title that is displayed in the menu 
     */
    title?: string,

        /**
         * the icon shown alongside that title 
         */
        icon?: string,

        /**
         * the method to call when the menu is clicked 
         */
        action?: ($event: ng.IAngularEvent) => void,

        /**
         * a function to evaluate to determine whether or not to show the item 
         */
        shown?: () => boolean,

        /**
         * a function to evaluate to determine whether or not the item is currently selected 
         */
        active?: () => boolean,

        /**
         * context to pass to the action function, available in this.context in your handler 
         */
        context?: any,

        /**
         * if set to true, the menu should stay open after the action, defaults to false 
         */
        leaveOpen?: boolean
}

declare export interface uiGrid$ISortInfo {
    direction?: string,
        ignoreSort?: boolean,
        priority?: number
}

declare export interface uiGrid$IFilterOptions {

    /**
     * condition defines how rows are chosen as matching the filter term.
     * This can be set to one of the constants in uiGridConstants.filter,
    or you can supply a custom filter function that gets passed the
    following arguments: [searchTerm, cellValue, row, column].
    */
    condition?: number | ((
            searchTerm: string,
            cellValue: any,
            row: uiGrid$IGridRow,
            column: uiGrid$IGridColumn) => boolean),

        /**
         * If set, the filter field will be pre-populated with this value
         */
        term?: string,

        /**
         * String that will be set to the <input>.placeholder attribute 
         */
        placeholder?: string,

        /**
         * String that will be set to the <input>.ariaLabel attribute. This is what is read as a label to screen reader users.
         */
        ariaLabel?: string,

        /**
         * set this to true if you have defined a custom function in condition,
         * and your custom function doesn't require a term
        (so it can run even when the term is null)
        */
        noTerm?: boolean,

        /**
         * only flag currently available is caseSensitive, set to false if you don't want case sensitive matching
         */
        flags?: uiGrid$IFilterFlags,

        /**
         * defaults to uiGridConstants.filter.INPUT, which gives a text box. If set to uiGridConstants.filter.SELECT
         * then a select box will be shown with options selectOptions
         */
        type?: number | string,

        /**
         * options in the format [{ value: 1, label: 'male' }]. No i18n filter is provided, you need to perform the i18n
         * on the values before you provide them
         */
        selectOptions?: Array<uiGrid$ISelectOption>,

        /**
         * If set to true then the 'x' button that cancels/clears the filter will not be shown.
         * @default  false
         */
        disableCancelFilterButton?: boolean
}

declare export interface uiGrid$ISelectOption {
    value: number | string,
        label: string
}

declare export interface uiGrid$IFilterFlags {
    caseSensitive?: boolean
}
declare module 'angular-ui-grid' {
    declare module.exports: typeof uiGrid
}