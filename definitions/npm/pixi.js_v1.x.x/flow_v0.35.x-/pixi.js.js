/**
 * Flowtype definitions for pixi.js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare class PIXI {
    VERSION: string;
    PI_2: number;
    RAD_TO_DEG: number;
    DEG_TO_RAD: number;
    TARGET_FPMS: number;
    RENDERER_TYPE: {
        UNKNOWN: number,
        WEBGL: number,
        CANVAS: number
    };
    BLEND_MODES: {
        NORMAL: number,
        ADD: number,
        MULTIPLY: number,
        SCREEN: number,
        OVERLAY: number,
        DARKEN: number,
        LIGHTEN: number,
        COLOR_DODGE: number,
        COLOR_BURN: number,
        HARD_LIGHT: number,
        SOFT_LIGHT: number,
        DIFFERENCE: number,
        EXCLUSION: number,
        HUE: number,
        SATURATION: number,
        COLOR: number,
        LUMINOSITY: number
    };
    DRAW_MODES: {
        POINTS: number,
        LINES: number,
        LINE_LOOP: number,
        LINE_STRIP: number,
        TRIANGLES: number,
        TRIANGLE_STRIP: number,
        TRIANGLE_FAN: number
    };
    SCALE_MODES: {
        DEFAULT: number,
        LINEAR: number,
        NEAREST: number
    };
    RETINA_PREFIX: string;
    RESOLUTION: number;
    FILTER_RESOLUTION: number;
    DEFAULT_RENDER_OPTIONS: {
        view: HTMLCanvasElement,
        resolution: number,
        antialias: boolean,
        forceFXAA: boolean,
        autoResize: boolean,
        transparent: boolean,
        backgroundColor: number,
        clearBeforeRender: boolean,
        preserveDrawingBuffer: boolean,
        roundPixels: boolean
    };
    SHAPES: {
        POLY: number,
        RECT: number,
        CIRC: number,
        ELIP: number,
        RREC: number
    };
    SPRITE_BATCH_SIZE: number
}
declare var npm$namespace$PIXI: {
    autoDetectRenderer: typeof PIXI$autoDetectRenderer,
}
declare export function PIXI$autoDetectRenderer(
    width: number,
    height: number,
    options?: PIXI$RendererOptions,
    noWebGL?: boolean): PIXI$WebGLRenderer | PIXI$CanvasRenderer

declare export var loader: undefined.Loader;

declare export class EventEmitter {
    listeners(event: string): Function[];
    emit(event: string, ...args: any[]): boolean;
    on(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    once(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    removeListener(event: string, fn?: Function, context?: any, once?: boolean): PIXI$EventEmitter;
    removeAllListeners(event?: string): PIXI$EventEmitter;
    off(event: string, fn?: Function, context?: any, once?: boolean): PIXI$EventEmitter;
    addListener(event: string, fn: Function, context?: any): PIXI$EventEmitter
}

declare export class DisplayObject mixins EventEmitter, interaction.InteractiveTarget {
    _originalRenderWebGL: PIXI$WebGLRenderer;
    _originalRenderCanvas: PIXI$CanvasRenderer;
    _originalUpdateTransform: boolean;
    _originalHitTest: any;
    _cachedSprite: any;
    _originalDestroy: any;
    cacheAsBitmap: boolean;
    _renderCachedWebGL(renderer: PIXI$WebGLRenderer): void;
    _initCachedDisplayObject(renderer: PIXI$WebGLRenderer): void;
    _renderCachedCanvas(renderer: PIXI$CanvasRenderer): void;
    _initCachedDisplayObjectCanvas(renderer: PIXI$CanvasRenderer): void;
    _getCachedBounds(): PIXI$Rectangle;
    _destroyCachedDisplayObject(): void;
    _cacheAsBitmapDestroy(): void;
    _sr: number;
    _cr: number;
    _bounds: PIXI$Rectangle;
    _currentBounds: PIXI$Rectangle;
    _mask: PIXI$Rectangle;
    _cachedObject: any;
    updateTransform(): void;
    position: PIXI$Point;
    scale: PIXI$Point;
    pivot: PIXI$Point;
    rotation: number;
    renderable: boolean;
    alpha: number;
    visible: boolean;
    parent: PIXI$Container;
    worldAlpha: number;
    worldTransform: PIXI$Matrix;
    filterArea: PIXI$Rectangle;
    x: number;
    y: number;
    worldVisible: boolean;
    mask: PIXI$Graphics | PIXI$Sprite;
    filters: PIXI$AbstractFilter[];
    name: string;
    getBounds(matrix?: PIXI$Matrix): PIXI$Rectangle;
    getLocalBounds(): PIXI$Rectangle;
    toGlobal(position: PIXI$Point): PIXI$Point;
    toLocal(position: PIXI$Point, from?: PIXI$DisplayObject): PIXI$Point;
    generateTexture(
        renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer,
        scaleMode: number,
        resolution: number): PIXI$Texture;
    setParent(container: PIXI$Container): PIXI$Container;
    setTransform(
        x?: number,
        y?: number,
        scaleX?: number,
        scaleY?: number,
        rotation?: number,
        skewX?: number,
        skewY?: number,
        pivotX?: number,
        pivotY?: number): PIXI$DisplayObject;
    destroy(): void;
    getChildByName(name: string): PIXI$DisplayObject;
    getGlobalPosition(point: PIXI$Point): PIXI$Point;
    interactive: boolean;
    buttonMode: boolean;
    interactiveChildren: boolean;
    defaultCursor: string;
    hitArea: PIXI$HitArea;
    on(
        event: "click",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mousedown",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mouseout",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mouseover",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mouseup",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mouseclick",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "mouseupoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "rightclick",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "rightdown",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "rightup",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "rightupoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "tap",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "touchend",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "touchendoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "touchmove",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "touchstart",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    once(
        event: "click",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mousedown",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mouseout",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mouseover",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mouseup",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mouseclick",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "mouseupoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "rightclick",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "rightdown",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "rightup",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "rightupoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "tap",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "touchend",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "touchendoutside",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "touchmove",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "touchstart",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(event: string, fn: Function, context?: any): PIXI$EventEmitter
}

declare export class Container mixins DisplayObject {
    _renderWebGL(renderer: PIXI$WebGLRenderer): void;
    _renderCanvas(renderer: PIXI$CanvasRenderer): void;
    onChildrenChange: () => void;
    children: PIXI$DisplayObject[];
    width: number;
    height: number;
    addChild(...child: PIXI$DisplayObject[]): PIXI$DisplayObject;
    addChildAt(child: PIXI$DisplayObject, index: number): PIXI$DisplayObject;
    swapChildren(child: PIXI$DisplayObject, child2: PIXI$DisplayObject): void;
    getChildIndex(child: PIXI$DisplayObject): number;
    setChildIndex(child: PIXI$DisplayObject, index: number): void;
    getChildAt(index: number): PIXI$DisplayObject;
    removeChild(child: PIXI$DisplayObject): PIXI$DisplayObject;
    removeChildAt(index: number): PIXI$DisplayObject;
    removeChildren(beginIndex?: number, endIndex?: number): PIXI$DisplayObject[];
    destroy(destroyChildren?: boolean): void;
    generateTexture(
        renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer,
        resolution?: number,
        scaleMode?: number): PIXI$Texture;
    renderWebGL(renderer: PIXI$WebGLRenderer): void;
    renderCanvas(renderer: PIXI$CanvasRenderer): void;
    once(
        event: "added",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    once(
        event: "removed",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    once(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    on(
        event: "added",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    on(
        event: "removed",
        fn: (event: interaction.InteractionEvent) => void,
        context?: any): PIXI$EventEmitter;
    on(event: string, fn: Function, context?: any): PIXI$EventEmitter
}

declare export class GraphicsData {
    constructor(lineWidth: number, lineColor: number, lineAlpha: number, fillColor: number, fillAlpha: number, fill: boolean, shape: PIXI$Circle | PIXI$Rectangle | PIXI$Ellipse | PIXI$Polygon): this;
    lineWidth: number;
    lineColor: number;
    lineAlpha: number;
    fillColor: number;
    fillAlpha: number;
    fill: boolean;
    shape: PIXI$Circle | PIXI$Rectangle | PIXI$Ellipse | PIXI$Polygon;
    type: number;
    clone(): PIXI$GraphicsData;
    _lineTint: number;
    _fillTint: number
}

declare export class Graphics mixins Container {
    boundsDirty: boolean;
    dirty: boolean;
    glDirty: boolean;
    fillAlpha: number;
    lineWidth: number;
    lineColor: number;
    tint: number;
    blendMode: number;
    isMask: boolean;
    boundsPadding: number;
    clone(): PIXI$Graphics;
    lineStyle(lineWidth?: number, color?: number, alpha?: number): PIXI$Graphics;
    moveTo(x: number, y: number): PIXI$Graphics;
    lineTo(x: number, y: number): PIXI$Graphics;
    quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): PIXI$Graphics;
    bezierCurveTo(
        cpX: number,
        cpY: number,
        cpX2: number,
        cpY2: number,
        toX: number,
        toY: number): PIXI$Graphics;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): PIXI$Graphics;
    arc(
        cx: number,
        cy: number,
        radius: number,
        startAngle: number,
        endAngle: number,
        anticlockwise?: boolean): PIXI$Graphics;
    beginFill(color: number, alpha?: number): PIXI$Graphics;
    endFill(): PIXI$Graphics;
    drawRect(x: number, y: number, width: number, height: number): PIXI$Graphics;
    drawRoundedRect(
        x: number,
        y: number,
        width: number,
        height: number,
        radius: number): PIXI$Graphics;
    drawCircle(x: number, y: number, radius: number): PIXI$Graphics;
    drawEllipse(x: number, y: number, width: number, height: number): PIXI$Graphics;
    drawPolygon(path: number[] | PIXI$Point[]): PIXI$Graphics;
    clear(): PIXI$Graphics;
    generateTexture(
        renderer: PIXI$WebGLRenderer | PIXI$CanvasRenderer,
        resolution?: number,
        scaleMode?: number): PIXI$Texture;
    getBounds(matrix?: PIXI$Matrix): PIXI$Rectangle;
    containsPoint(point: PIXI$Point): boolean;
    updateLocalBounds(): void;
    drawShape(
        shape: PIXI$Circle | PIXI$Rectangle | PIXI$Ellipse | PIXI$Polygon): PIXI$GraphicsData
}

declare export type PIXI$GraphicsRenderer = {} & PIXI$ObjectRenderer


declare export interface PIXI$WebGLGraphicsData {}

declare export class Point {
    x: number;
    y: number;
    constructor(x?: number, y?: number): this;
    clone(): PIXI$Point;
    copy(p: PIXI$Point): void;
    equals(p: PIXI$Point): boolean;
    set(x?: number, y?: number): void
}

declare export class Matrix {
    a: number;
    b: number;
    c: number;
    d: number;
    tx: number;
    ty: number;
    fromArray(array: number[]): void;
    toArray(transpose?: boolean, out?: number[]): number[];
    apply(pos: PIXI$Point, newPos?: PIXI$Point): PIXI$Point;
    applyInverse(pos: PIXI$Point, newPos?: PIXI$Point): PIXI$Point;
    translate(x: number, y: number): PIXI$Matrix;
    scale(x: number, y: number): PIXI$Matrix;
    rotate(angle: number): PIXI$Matrix;
    append(matrix: PIXI$Matrix): PIXI$Matrix;
    prepend(matrix: PIXI$Matrix): PIXI$Matrix;
    invert(): PIXI$Matrix;
    identity(): PIXI$Matrix;
    clone(): PIXI$Matrix;
    copy(matrix: PIXI$Matrix): PIXI$Matrix;
    set(
        a: number,
        b: number,
        c: number,
        d: number,
        tx: number,
        ty: number): PIXI$Matrix;
    setTransform(
        a: number,
        b: number,
        c: number,
        d: number,
        sr: number,
        cr: number,
        cy: number,
        sy: number,
        nsx: number,
        cs: number): PIXI$Matrix;
    IDENTITY: PIXI$Matrix;
    TEMP_MATRIX: PIXI$Matrix
}

declare export interface PIXI$HitArea {
    contains(x: number, y: number): boolean
}

declare export class Circle mixins HitArea {
    constructor(x?: number, y?: number, radius?: number): this;
    x: number;
    y: number;
    radius: number;
    type: number;
    clone(): PIXI$Circle;
    contains(x: number, y: number): boolean;
    getBounds(): PIXI$Rectangle
}

declare export class Ellipse mixins HitArea {
    constructor(x?: number, y?: number, width?: number, height?: number): this;
    x: number;
    y: number;
    width: number;
    height: number;
    type: number;
    clone(): PIXI$Ellipse;
    contains(x: number, y: number): boolean;
    getBounds(): PIXI$Rectangle
}

declare export class Polygon mixins HitArea {
    constructor(points: PIXI$Point[]): this;
    constructor(points: number[]): this;
    constructor(...points: PIXI$Point[]): this;
    constructor(...points: number[]): this;
    closed: boolean;
    points: number[];
    type: number;
    clone(): PIXI$Polygon;
    contains(x: number, y: number): boolean
}

declare export class Rectangle mixins HitArea {
    constructor(x?: number, y?: number, width?: number, height?: number): this;
    x: number;
    y: number;
    width: number;
    height: number;
    type: number;
    EMPTY: PIXI$Rectangle;
    clone(): PIXI$Rectangle;
    contains(x: number, y: number): boolean
}

declare export class RoundedRectangle mixins HitArea {
    constructor(x?: number, y?: number, width?: number, height?: number, radius?: number): this;
    x: number;
    y: number;
    width: number;
    height: number;
    radius: number;
    type: number;
    EMPTY: PIXI$Rectangle;
    clone(): PIXI$Rectangle;
    contains(x: number, y: number): boolean
}

declare export interface PIXI$ParticleContainerProperties {
    scale?: boolean,
        position?: boolean,
        rotation?: boolean,
        uvs?: boolean,
        alpha?: boolean
}

declare export class ParticleContainer mixins Container {
    constructor(size?: number, properties?: PIXI$ParticleContainerProperties, batchSize?: number): this;
    _maxSize: number;
    _batchSize: number;
    _properties: boolean[];
    _buffers: WebGLBuffer[];
    _bufferToUpdate: number;
    onChildrenChange: (smallestChildIndex?: number) => void;
    interactiveChildren: boolean;
    blendMode: number;
    roundPixels: boolean;
    setProperties(properties: PIXI$ParticleContainerProperties): void
}

declare export interface PIXI$ParticleBuffer {
    gl: WebGLRenderingContext,
        vertSize: number,
        vertByteSize: number,
        size: number,
        dynamicProperties: any[],
        staticProperties: any[],
        staticStride: number,
        staticBuffer: any,
        staticData: any,
        dynamicStride: number,
        dynamicBuffer: any,
        dynamicData: any,
        initBuffers(): void,
        bind(): void,
        destroy(): void
}

declare export interface PIXI$ParticleRenderer {}

declare export interface PIXI$ParticleShader {}

declare export interface PIXI$RendererOptions {
    view?: HTMLCanvasElement,
        transparent?: boolean,
        antialias?: boolean,
        autoResize?: boolean,
        resolution?: number,
        clearBeforeRendering?: boolean,
        preserveDrawingBuffer?: boolean,
        forceFXAA?: boolean,
        roundPixels?: boolean,
        backgroundColor?: number
}

declare export class SystemRenderer mixins EventEmitter {
    _backgroundColor: number;
    _backgroundColorRgb: number[];
    _backgroundColorString: string;
    _tempDisplayObjectParent: any;
    _lastObjectRendered: PIXI$DisplayObject;
    constructor(system: string, width?: number, height?: number, options?: PIXI$RendererOptions): this;
    type: number;
    width: number;
    height: number;
    view: HTMLCanvasElement;
    resolution: number;
    transparent: boolean;
    autoResize: boolean;
    blendModes: any;
    preserveDrawingBuffer: boolean;
    clearBeforeRender: boolean;
    roundPixels: boolean;
    backgroundColor: number;
    render(object: PIXI$DisplayObject): void;
    resize(width: number, height: number): void;
    destroy(removeView?: boolean): void
}

declare export class CanvasRenderer mixins SystemRenderer {
    renderDisplayObject(displayObject: PIXI$DisplayObject, context: CanvasRenderingContext2D): void;
    _mapBlendModes(): void;
    constructor(width?: number, height?: number, options?: PIXI$RendererOptions): this;
    context: CanvasRenderingContext2D;
    refresh: boolean;
    maskManager: PIXI$CanvasMaskManager;
    roundPixels: boolean;
    smoothProperty: string;
    render(object: PIXI$DisplayObject): void;
    resize(w: number, h: number): void
}

declare export class CanvasBuffer {
    clear(): void;
    constructor(width: number, height: number): this;
    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    width: number;
    height: number;
    resize(width: number, height: number): void;
    destroy(): void
}

declare export class CanvasGraphics {
    renderGraphicsMask(graphics: PIXI$Graphics, context: CanvasRenderingContext2D): void;
    updateGraphicsTint(graphics: PIXI$Graphics): void;
    renderGraphics(graphics: PIXI$Graphics, context: CanvasRenderingContext2D): void
}

declare export class CanvasMaskManager {
    pushMask(maskData: any, renderer: PIXI$WebGLRenderer | PIXI$CanvasRenderer): void;
    popMask(renderer: PIXI$WebGLRenderer | PIXI$CanvasRenderer): void;
    destroy(): void
}

declare export class CanvasTinter {
    getTintedTexture(sprite: PIXI$DisplayObject, color: number): HTMLCanvasElement;
    tintWithMultiply(texture: PIXI$Texture, color: number, canvas: HTMLDivElement): void;
    tintWithOverlay(texture: PIXI$Texture, color: number, canvas: HTMLCanvasElement): void;
    tintWithPerPixel(texture: PIXI$Texture, color: number, canvas: HTMLCanvasElement): void;
    roundColor(color: number): number;
    cacheStepsPerColorChannel: number;
    convertTintToImage: boolean;
    vanUseMultiply: boolean;
    tintMethod: Function
}

declare export class WebGLRenderer mixins SystemRenderer {
    _useFXAA: boolean;
    _FXAAFilter: filters$FXAAFilter;
    _contextOptions: {
        alpha: boolean,
        antiAlias: boolean,
        premultipliedAlpha: boolean,
        stencil: boolean,
        preseveDrawingBuffer: boolean
    };
    _renderTargetStack: PIXI$RenderTarget[];
    _initContext(): void;
    _createContext(): void;
    handleContextLost: (event: WebGLContextEvent) => void;
    _mapGlModes(): void;
    _managedTextures: PIXI$Texture[];
    constructor(width?: number, height?: number, options?: PIXI$RendererOptions): this;
    drawCount: number;
    shaderManager: PIXI$ShaderManager;
    maskManager: PIXI$MaskManager;
    stencilManager: PIXI$StencilManager;
    filterManager: PIXI$FilterManager;
    blendModeManager: PIXI$BlendModeManager;
    currentRenderTarget: PIXI$RenderTarget;
    currentRenderer: PIXI$ObjectRenderer;
    render(object: PIXI$DisplayObject): void;
    renderDisplayObject(
        displayObject: PIXI$DisplayObject,
        renderTarget: PIXI$RenderTarget,
        clear: boolean): void;
    setObjectRenderer(objectRenderer: PIXI$ObjectRenderer): void;
    setRenderTarget(renderTarget: PIXI$RenderTarget): void;
    updateTexture(texture: PIXI$BaseTexture | PIXI$Texture): PIXI$BaseTexture | PIXI$Texture;
    destroyTexture(texture: PIXI$BaseTexture | PIXI$Texture, _skipRemove?: boolean): void
}

declare export class AbstractFilter {
    vertexSrc: string[];
    fragmentSrc: string[];
    constructor(vertexSrc?: string | string[], fragmentSrc?: string | string[], uniforms?: any): this;
    uniforms: any;
    padding: number;
    getShader(renderer: PIXI$WebGLRenderer): PIXI$Shader;
    applyFilter(
        renderer: PIXI$WebGLRenderer,
        input: PIXI$RenderTarget,
        output: PIXI$RenderTarget,
        clear?: boolean): void;
    syncUniform(uniform: WebGLUniformLocation): void
}

declare export class SpriteMaskFilter mixins AbstractFilter {
    constructor(sprite: PIXI$Sprite): this;
    maskSprite: PIXI$Sprite;
    maskMatrix: PIXI$Matrix;
    applyFilter(
        renderer: WebGLRenderbuffer,
        input: PIXI$RenderTarget,
        output: PIXI$RenderTarget): void;
    map: PIXI$Texture;
    offset: PIXI$Point
}

declare export class BlendModeManager mixins WebGLManager {
    constructor(renderer: PIXI$WebGLRenderer): this;
    setBlendMode(blendMode: number): boolean
}

declare export class FilterManager mixins WebGLManager {
    constructor(renderer: PIXI$WebGLRenderer): this;
    filterStack: any[];
    renderer: PIXI$WebGLRenderer;
    texturePool: any[];
    onContextChange: () => void;
    setFilterStack(filterStack: any[]): void;
    pushFilter(target: PIXI$RenderTarget, filters: any[]): void;
    popFilter(): PIXI$AbstractFilter;
    getRenderTarget(clear?: boolean): PIXI$RenderTarget;
    returnRenderTarget(renderTarget: PIXI$RenderTarget): void;
    applyFilter(
        shader: PIXI$Shader | PIXI$AbstractFilter,
        inputTarget: PIXI$RenderTarget,
        outputTarget: PIXI$RenderTarget,
        clear?: boolean): void;
    calculateMappedMatrix(
        filterArea: PIXI$Rectangle,
        sprite: PIXI$Sprite,
        outputMatrix?: PIXI$Matrix): PIXI$Matrix;
    capFilterArea(filterArea: PIXI$Rectangle): void;
    resize(width: number, height: number): void;
    destroy(): void
}

declare export class MaskManager mixins WebGLManager {
    stencilStack: PIXI$StencilMaskStack;
    reverse: boolean;
    count: number;
    alphaMaskPool: any[];
    pushMask(target: PIXI$RenderTarget, maskData: any): void;
    popMask(target: PIXI$RenderTarget, maskData: any): void;
    pushSpriteMask(target: PIXI$RenderTarget, maskData: any): void;
    popSpriteMask(): void;
    pushStencilMask(target: PIXI$RenderTarget, maskData: any): void;
    popStencilMask(target: PIXI$RenderTarget, maskData: any): void
}

declare export class ShaderManager mixins WebGLManager {
    _currentId: number;
    currentShader: PIXI$Shader;
    constructor(renderer: PIXI$WebGLRenderer): this;
    maxAttibs: number;
    attribState: any[];
    tempAttribState: any[];
    stack: any[];
    setAttribs(attribs: any[]): void;
    setShader(shader: PIXI$Shader): boolean;
    destroy(): void
}

declare export class StencilManager mixins WebGLManager {
    constructor(renderer: PIXI$WebGLRenderer): this;
    setMaskStack(stencilMaskStack: PIXI$StencilMaskStack): void;
    pushStencil(graphics: PIXI$Graphics, webGLData: PIXI$WebGLGraphicsData): void;
    bindGraphics(graphics: PIXI$Graphics, webGLData: PIXI$WebGLGraphicsData): void;
    popStencil(graphics: PIXI$Graphics, webGLData: PIXI$WebGLGraphicsData): void;
    destroy(): void;
    pushMask(maskData: any[]): void;
    popMask(maskData: any[]): void
}

declare export class WebGLManager {
    onContextChange: () => void;
    constructor(renderer: PIXI$WebGLRenderer): this;
    renderer: PIXI$WebGLRenderer;
    destroy(): void
}

declare export class Shader {
    attributes: any;
    textureCount: number;
    uniforms: any;
    _glCompile(type: any, src: any): PIXI$Shader;
    constructor(shaderManager: PIXI$ShaderManager, vertexSrc: string, fragmentSrc: string, uniforms: any, attributes: any): this;
    uuid: number;
    gl: WebGLRenderingContext;
    shaderManager: PIXI$ShaderManager;
    program: WebGLProgram;
    vertexSrc: string;
    fragmentSrc: string;
    init(): void;
    cacheUniformLocations(keys: string[]): void;
    cacheAttributeLocations(keys: string[]): void;
    compile(): WebGLProgram;
    syncUniform(uniform: any): void;
    syncUniforms(): void;
    initSampler2D(uniform: any): void;
    destroy(): void
}

declare export class ComplexPrimitiveShader mixins Shader {
    constructor(shaderManager: PIXI$ShaderManager): this
}

declare export class PrimitiveShader mixins Shader {
    constructor(shaderManager: PIXI$ShaderManager): this
}

declare export class TextureShader mixins Shader {
    constructor(shaderManager: PIXI$ShaderManager, vertexSrc?: string, fragmentSrc?: string, customUniforms?: any, customAttributes?: any): this
}

declare export interface PIXI$StencilMaskStack {
    stencilStack: any[],
        reverse: boolean,
        count: number
}

declare export class ObjectRenderer mixins WebGLManager {
    start(): void;
    stop(): void;
    flush(): void;
    render(object?: any): void
}

declare export class RenderTarget {
    constructor(gl: WebGLRenderingContext, width: number, height: number, scaleMode: number, resolution: number, root: boolean): this;
    gl: WebGLRenderingContext;
    frameBuffer: WebGLFramebuffer;
    texture: PIXI$Texture;
    size: PIXI$Rectangle;
    resolution: number;
    projectionMatrix: PIXI$Matrix;
    transform: PIXI$Matrix;
    frame: PIXI$Rectangle;
    stencilBuffer: WebGLRenderbuffer;
    stencilMaskStack: PIXI$StencilMaskStack;
    filterStack: any[];
    scaleMode: number;
    root: boolean;
    clear(bind?: boolean): void;
    attachStencilBuffer(): void;
    activate(): void;
    calculateProjection(protectionFrame: PIXI$Matrix): void;
    resize(width: number, height: number): void;
    destroy(): void
}

declare export interface PIXI$Quad {
    gl: WebGLRenderingContext,
        vertices: number[],
        uvs: number[],
        colors: number[],
        indices: number[],
        vertexBuffer: WebGLBuffer,
        indexBuffer: WebGLBuffer,
        map(rect: PIXI$Rectangle, rect2: PIXI$Rectangle): void,
        upload(): void,
        destroy(): void
}

declare export class Sprite mixins Container {
    fromFrame(frameId: string): PIXI$Sprite;
    fromImage(imageId: string, crossorigin?: boolean, scaleMode?: number): PIXI$Sprite;
    _texture: PIXI$Texture;
    _width: number;
    _height: number;
    cachedTint: number;
    _onTextureUpdate(): void;
    constructor(texture?: PIXI$Texture): this;
    anchor: PIXI$Point;
    tint: number;
    blendMode: number;
    shader: PIXI$Shader | PIXI$AbstractFilter;
    texture: PIXI$Texture;
    width: number;
    height: number;
    getBounds(matrix?: PIXI$Matrix): PIXI$Rectangle;
    getLocalBounds(): PIXI$Rectangle;
    containsPoint(point: PIXI$Point): boolean;
    destroy(destroyTexture?: boolean, destroyBaseTexture?: boolean): void
}

declare export class SpriteRenderer mixins ObjectRenderer {
    renderBatch(texture: PIXI$Texture, size: number, startIndex: number): void;
    vertSize: number;
    vertByteSize: number;
    size: number;
    vertices: number[];
    positions: number[];
    colors: number[];
    indices: number[];
    currentBatchSize: number;
    sprites: PIXI$Sprite[];
    shader: PIXI$Shader | PIXI$AbstractFilter;
    render(sprite: PIXI$Sprite): void;
    flush(): void;
    start(): void;
    destroy(): void
}

declare export interface PIXI$TextStyle {
    font?: string,
        fill?: string | number,
        align?: string,
        stroke?: string | number,
        strokeThickness?: number,
        wordWrap?: boolean,
        wordWrapWidth?: number,
        lineHeight?: number,
        dropShadow?: boolean,
        dropShadowColor?: string | number,
        dropShadowAngle?: number,
        dropShadowDistance?: number,
        padding?: number,
        textBaseline?: string,
        lineJoin?: string,
        miterLimit?: number
}

declare export class Text mixins Sprite {
    fontPropertiesCache: any;
    fontPropertiesCanvas: HTMLCanvasElement;
    fontPropertiesContext: CanvasRenderingContext2D;
    _text: string;
    _style: PIXI$TextStyle;
    updateText(): void;
    updateTexture(): void;
    determineFontProperties(fontStyle: PIXI$TextStyle): PIXI$TextStyle;
    wordWrap(text: string): boolean;
    constructor(text?: string, style?: PIXI$TextStyle, resolution?: number): this;
    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    dirty: boolean;
    resolution: number;
    text: string;
    style: PIXI$TextStyle;
    width: number;
    height: number
}

declare export class BaseTexture mixins EventEmitter {
    fromImage(imageUrl: string, crossorigin?: boolean, scaleMode?: number): PIXI$BaseTexture;
    fromCanvas(canvas: HTMLCanvasElement, scaleMode?: number): PIXI$BaseTexture;
    _glTextures: any;
    _sourceLoaded(): void;
    constructor(source: HTMLImageElement | HTMLCanvasElement, scaleMode?: number, resolution?: number): this;
    uuid: number;
    resolution: number;
    width: number;
    height: number;
    realWidth: number;
    realHeight: number;
    scaleMode: number;
    hasLoaded: boolean;
    isLoading: boolean;
    source: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;
    premultipliedAlpha: boolean;
    imageUrl: string;
    isPowerOfTwo: boolean;
    mipmap: boolean;
    update(): void;
    loadSource(source: HTMLImageElement | HTMLCanvasElement): void;
    destroy(): void;
    dispose(): void;
    updateSourceImage(newSrc: string): void;
    on(
        event: "dispose",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "error",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "loaded",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    on(
        event: "update",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    on(event: string, fn: Function, context?: any): PIXI$EventEmitter;
    once(
        event: "dispose",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "error",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "loaded",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    once(
        event: "update",
        fn: (baseTexture: PIXI$BaseTexture) => void,
        context?: any): PIXI$EventEmitter;
    once(event: string, fn: Function, context?: any): PIXI$EventEmitter
}

declare export class RenderTexture mixins Texture {
    renderWebGL(
        displayObject: PIXI$DisplayObject,
        matrix?: PIXI$Matrix,
        clear?: boolean,
        updateTransform?: boolean): void;
    renderCanvas(
        displayObject: PIXI$DisplayObject,
        matrix?: PIXI$Matrix,
        clear?: boolean,
        updateTransform?: boolean): void;
    constructor(renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer, width?: number, height?: number, scaleMode?: number, resolution?: number): this;
    width: number;
    height: number;
    resolution: number;
    renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer;
    valid: boolean;
    render(
        displayObject: PIXI$DisplayObject,
        matrix?: PIXI$Matrix,
        clear?: boolean,
        updateTransform?: boolean): void;
    resize(width: number, height: number, updateBase?: boolean): void;
    clear(): void;
    destroy(): void;
    getImage(): HTMLImageElement;
    getPixels(): number[];
    getPixel(x: number, y: number): number[];
    getBase64(): string;
    getCanvas(): HTMLCanvasElement
}

declare export class Texture mixins BaseTexture {
    fromImage(imageUrl: string, crossOrigin?: boolean, scaleMode?: number): PIXI$Texture;
    fromFrame(frameId: string): PIXI$Texture;
    fromCanvas(canvas: HTMLCanvasElement, scaleMode?: number): PIXI$Texture;
    fromVideo(video: HTMLVideoElement | string, scaleMode?: number): PIXI$Texture;
    fromVideoUrl(videoUrl: string, scaleMode?: number): PIXI$Texture;
    addTextureToCache(texture: PIXI$Texture, id: string): void;
    removeTextureFromCache(id: string): PIXI$Texture;
    EMPTY: PIXI$Texture;
    _frame: PIXI$Rectangle;
    _uvs: PIXI$TextureUvs;
    onBaseTextureUpdated(baseTexture: PIXI$BaseTexture): void;
    onBaseTextureLoaded(baseTexture: PIXI$BaseTexture): void;
    _updateUvs(): void;
    constructor(baseTexture: PIXI$BaseTexture, frame?: PIXI$Rectangle, crop?: PIXI$Rectangle, trim?: PIXI$Rectangle, rotate?: boolean): this;
    noFrame: boolean;
    baseTexture: PIXI$BaseTexture;
    trim: PIXI$Rectangle;
    valid: boolean;
    requiresUpdate: boolean;
    width: number;
    height: number;
    crop: PIXI$Rectangle;
    rotate: boolean;
    frame: PIXI$Rectangle;
    update(): void;
    destroy(destroyBase?: boolean): void;
    clone(): PIXI$Texture
}

declare export class TextureUvs {
    x0: number;
    y0: number;
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    x3: number;
    y3: number;
    set(frame: PIXI$Rectangle, baseFrame: PIXI$Rectangle, rotate: boolean): void
}

declare export class VideoBaseTexture mixins BaseTexture {
    fromVideo(video: HTMLVideoElement, scaleMode?: number): PIXI$VideoBaseTexture;
    fromUrl(videoSrc: string | any | string[] | any[]): PIXI$VideoBaseTexture;
    _loaded: boolean;
    _onUpdate(): void;
    _onPlayStart(): void;
    _onPlayStop(): void;
    _onCanPlay(): void;
    constructor(source: HTMLVideoElement, scaleMode?: number): this;
    autoUpdate: boolean;
    destroy(): void
}

declare export class utils {
    uuid(): number;
    hex2rgb(hex: number, out?: number[]): number[];
    hex2string(hex: number): string;
    rgb2hex(rgb: Number[]): number;
    canUseNewCanvasBlendModel(): boolean;
    getNextPowerOfTwo(number: number): number;
    isPowerOfTwo(width: number, height: number): boolean;
    getResolutionOfUrl(url: string): number;
    sayHello(type: string): void;
    isWebGLSupported(): boolean;
    sign(n: number): number;
    TextureCache: any;
    BaseTextureCache: any
}

declare module 'extras' {
    declare export interface BitmapTextStyle {
        font?: string | {
                name?: string,
                size?: number
            },
            align?: string,
            tint?: number
    }
    declare export class BitmapText mixins Container {
        fonts: any;
        _glyphs: PIXI$Sprite[];
        _font: string | {
            tint: number,
            align: string,
            name: string,
            size: number
        };
        _text: string;
        updateText(): void;
        constructor(text: string, style?: BitmapTextStyle): this;
        textWidth: number;
        textHeight: number;
        maxWidth: number;
        maxLineHeight: number;
        dirty: boolean;
        tint: number;
        align: string;
        font: string | {
            tint: number,
            align: string,
            name: string,
            size: number
        };
        text: string
    }
    declare export class MovieClip mixins Sprite {
        fromFrames(frame: string[]): MovieClip;
        fromImages(images: string[]): MovieClip;
        _textures: PIXI$Texture[];
        _durations: number[];
        _currentTime: number;
        update(deltaTime: number): void;
        constructor(textures: PIXI$Texture[]): this;
        animationSpeed: number;
        loop: boolean;
        onComplete: () => void;
        currentFrame: number;
        playing: boolean;
        totalFrames: number;
        textures: PIXI$Texture[];
        stop(): void;
        play(): void;
        gotoAndStop(frameName: number): void;
        gotoAndPlay(frameName: number): void;
        destroy(): void
    }
    declare export class TilingSprite mixins Sprite {
        fromFrame(frameId: string): PIXI$Sprite;
        fromImage(imageId: string, crossorigin?: boolean, scaleMode?: number): PIXI$Sprite;
        fromFrame(frameId: string, width?: number, height?: number): TilingSprite;
        fromImage(
            imageId: string,
            width?: number,
            height?: number,
            crossorigin?: boolean,
            scaleMode?: number): TilingSprite;
        _tileScaleOffset: PIXI$Point;
        _tilingTexture: boolean;
        _refreshTexture: boolean;
        _uvs: PIXI$TextureUvs[];
        constructor(texture: PIXI$Texture, width: number, height: number): this;
        tileScale: PIXI$Point;
        tilePosition: PIXI$Point;
        width: number;
        height: number;
        originalTexture: PIXI$Texture;
        getBounds(): PIXI$Rectangle;
        generateTilingTexture(
            renderer: PIXI$WebGLRenderer | PIXI$CanvasRenderer,
            texture: PIXI$Texture,
            forcePowerOfTwo?: boolean): PIXI$Texture;
        containsPoint(point: PIXI$Point): boolean;
        destroy(): void
    }
}


declare export class AsciiFilter mixins AbstractFilter {
    size: number
}

declare export class BloomFilter mixins AbstractFilter {
    blur: number;
    blurX: number;
    blurY: number
}

declare export class BlurFilter mixins AbstractFilter {
    blurXFilter: filters$BlurXFilter;
    blurYFilter: filters$BlurYFilter;
    blur: number;
    passes: number;
    blurX: number;
    blurY: number
}

declare export class BlurXFilter mixins AbstractFilter {
    passes: number;
    strength: number;
    blur: number
}

declare export class BlurYFilter mixins AbstractFilter {
    passes: number;
    strength: number;
    blur: number
}

declare export class SmartBlurFilter mixins AbstractFilter {}

declare export class ColorMatrixFilter mixins AbstractFilter {
    _loadMatrix(matrix: number[], multiply: boolean): void;
    _multiply(out: number[], a: number[], b: number[]): void;
    _colorMatrix(matrix: number[]): void;
    matrix: number[];
    brightness(b: number, multiply?: boolean): void;
    greyscale(scale: number, multiply?: boolean): void;
    blackAndWhite(multiply?: boolean): void;
    hue(rotation: number, multiply?: boolean): void;
    contrast(amount: number, multiply?: boolean): void;
    saturate(amount: number, multiply?: boolean): void;
    desaturate(multiply?: boolean): void;
    negative(multiply?: boolean): void;
    sepia(multiply?: boolean): void;
    technicolor(multiply?: boolean): void;
    polaroid(multiply?: boolean): void;
    toBGR(multiply?: boolean): void;
    kodachrome(multiply?: boolean): void;
    browni(multiply?: boolean): void;
    vintage(multiply?: boolean): void;
    colorTone(
        desaturation: number,
        toned: number,
        lightColor: string,
        darkColor: string,
        multiply?: boolean): void;
    night(intensity: number, multiply?: boolean): void;
    predator(amount: number, multiply?: boolean): void;
    lsd(multiply?: boolean): void;
    reset(): void
}

declare export class ColorStepFilter mixins AbstractFilter {
    step: number
}

declare export class ConvolutionFilter mixins AbstractFilter {
    constructor(matrix: number[], width: number, height: number): this;
    matrix: number[];
    width: number;
    height: number
}

declare export class CrossHatchFilter mixins AbstractFilter {}

declare export class DisplacementFilter mixins AbstractFilter {
    constructor(sprite: PIXI$Sprite, scale?: number): this;
    map: PIXI$Texture;
    scale: PIXI$Point
}

declare export class DotScreenFilter mixins AbstractFilter {
    scale: number;
    angle: number
}

declare export class BlurYTintFilter mixins AbstractFilter {
    blur: number
}

declare export class DropShadowFilter mixins AbstractFilter {
    blur: number;
    blurX: number;
    blurY: number;
    color: number;
    alpha: number;
    distance: number;
    angle: number
}

declare export class GrayFilter mixins AbstractFilter {
    gray: number
}

declare export class InvertFilter mixins AbstractFilter {
    invert: number
}

declare export class NoiseFilter mixins AbstractFilter {
    noise: number
}

declare export class PixelateFilter mixins AbstractFilter {
    size: PIXI$Point
}

declare export class RGBSplitFilter mixins AbstractFilter {
    red: number;
    green: number;
    blue: number
}

declare export class SepiaFilter mixins AbstractFilter {
    sepia: number
}

declare export class ShockwaveFilter mixins AbstractFilter {
    center: number[];
    params: any;
    time: number
}

declare export class TiltShiftAxisFilter mixins AbstractFilter {
    blur: number;
    gradientBlur: number;
    start: number;
    end: number;
    updateDelta(): void
}

declare export class TiltShiftFilter mixins AbstractFilter {
    blur: number;
    gradientBlur: number;
    start: number;
    end: number
}

declare export class TiltShiftXFilter mixins AbstractFilter {
    updateDelta(): void
}

declare export class TiltShiftYFilter mixins AbstractFilter {
    updateDelta(): void
}

declare export class TwistFilter mixins AbstractFilter {
    offset: PIXI$Point;
    radius: number;
    angle: number
}

declare export class FXAAFilter mixins AbstractFilter {
    applyFilter(
        renderer: PIXI$WebGLRenderer,
        input: PIXI$RenderTarget,
        output: PIXI$RenderTarget): void
}

declare module 'interaction' {
    declare export interface InteractionEvent {
        stopped: boolean,
            target: any,
            type: string,
            data: InteractionData,
            stopPropagation(): void
    }
    declare export class InteractionData {
        global: PIXI$Point;
        target: PIXI$DisplayObject;
        originalEvent: Event;
        identifier: number;
        getLocalPosition(
            displayObject: PIXI$DisplayObject,
            point?: PIXI$Point,
            globalPos?: PIXI$Point): PIXI$Point
    }
    declare export class InteractionManager {
        interactionDOMElement: HTMLElement;
        eventsAdded: boolean;
        _tempPoint: PIXI$Point;
        setTargetElement(element: HTMLElement, resolution: number): void;
        addEvents(): void;
        removeEvents(): void;
        dispatchEvent(displayObject: PIXI$DisplayObject, eventString: string, eventData: any): void;
        onMouseDown: (event: Event) => void;
        processMouseDown: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        onMouseUp: (event: Event) => void;
        processMouseUp: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        onMouseMove: (event: Event) => void;
        processMouseMove: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        onMouseOut: (event: Event) => void;
        processMouseOverOut: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        onTouchStart: (event: Event) => void;
        processTouchStart: (DisplayObject: PIXI$DisplayObject, hit: boolean) => void;
        onTouchEnd: (event: Event) => void;
        processTouchEnd: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        onTouchMove: (event: Event) => void;
        processTouchMove: (displayObject: PIXI$DisplayObject, hit: boolean) => void;
        getTouchData(touchEvent: InteractionData): InteractionData;
        returnTouchData(touchData: InteractionData): void;
        constructor(renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer, options?: {
            autoPreventDefault?: boolean,
            interactionFrequence?: number
        }): this;
        renderer: PIXI$CanvasRenderer | PIXI$WebGLRenderer;
        autoPreventDefault: boolean;
        interactionFrequency: number;
        mouse: InteractionData;
        eventData: {
            stopped: boolean,
            target: any,
            type: any,
            data: InteractionData
        };
        interactiveDataPool: InteractionData[];
        last: number;
        currentCursorStyle: string;
        resolution: number;
        update(deltaTime: number): void;
        mapPositionToPoint(point: PIXI$Point, x: number, y: number): void;
        processInteractive(
            point: PIXI$Point,
            displayObject: PIXI$DisplayObject,
            func: (displayObject: PIXI$DisplayObject, hit: boolean) => void,
            hitTest: boolean,
            interactive: boolean): boolean;
        destroy(): void
    }
    declare export interface InteractiveTarget {
        interactive: boolean,
            buttonMode: boolean,
            interactiveChildren: boolean,
            defaultCursor: string,
            hitArea: PIXI$HitArea
    }
}


declare module 'loaders' {
    declare export interface LoaderOptions {
        crossOrigin?: boolean,
            loadType?: number,
            xhrType?: string
    }
    declare export interface ResourceDictionary {
        [index: string]: undefined.Resource
    }
    declare export class Loader mixins EventEmitter {
        constructor(baseUrl?: string, concurrency?: number): this;
        baseUrl: string;
        progress: number;
        loading: boolean;
        resources: ResourceDictionary;
        add(name: string, url: string, options?: LoaderOptions, cb?: () => void): Loader;
        add(url: string, options?: LoaderOptions, cb?: () => void): Loader;
        add(obj: any, options?: LoaderOptions, cb?: () => void): Loader;
        on(
            event: "complete",
            fn: (loader: loaders.Loader, object: any) => void,
            context?: any): PIXI$EventEmitter;
        on(
            event: "error",
            fn: (error: Error, loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        on(
            event: "load",
            fn: (loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        on(
            event: "progress",
            fn: (loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        on(
            event: "start",
            fn: (loader: loaders.Loader) => void,
            context?: any): PIXI$EventEmitter;
        on(event: string, fn: Function, context?: any): PIXI$EventEmitter;
        once(
            event: "complete",
            fn: (loader: loaders.Loader, object: any) => void,
            context?: any): PIXI$EventEmitter;
        once(
            event: "error",
            fn: (error: Error, loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        once(
            event: "load",
            fn: (loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        once(
            event: "progress",
            fn: (loader: loaders.Loader, resource: Resource) => void,
            context?: any): PIXI$EventEmitter;
        once(
            event: "start",
            fn: (loader: loaders.Loader) => void,
            context?: any): PIXI$EventEmitter;
        once(event: string, fn: Function, context?: any): PIXI$EventEmitter;
        before(fn: Function): Loader;
        pre(fn: Function): Loader;
        after(fn: Function): Loader;
        use(fn: Function): Loader;
        reset(): void;
        load(cb?: (loader: loaders.Loader, object: any) => void): Loader
    }
    declare export class Resource mixins EventEmitter {
        LOAD_TYPE: {
            XHR: number,
            IMAGE: number,
            AUDIO: number,
            VIDEO: number
        };
        XHR_READ_STATE: {
            UNSENT: number,
            OPENED: number,
            HEADERS_RECIEVED: number,
            LOADING: number,
            DONE: number
        };
        XHR_RESPONSE_TYPE: {
            DEFAULT: number,
            BUFFER: number,
            BLOB: number,
            DOCUMENT: number,
            JSON: number,
            TEXT: number
        };
        constructor(name?: string, url?: string | string[], options?: LoaderOptions): this;
        name: string;
        texture: PIXI$Texture;
        textures: PIXI$Texture[];
        url: string;
        data: any;
        crossOrigin: string;
        loadType: number;
        xhrType: string;
        error: Error;
        xhr: XMLHttpRequest;
        complete(): void;
        load(cb?: () => void): void
    }
}


declare module 'mesh' {
    declare export class Mesh mixins Container {
        DRAW_MODES: {
            TRIANGLE_MESH: number,
            TRIANGLES: number
        };
        constructor(texture: PIXI$Texture, vertices?: number[], uvs?: number[], indices?: number[], drawMode?: number): this;
        texture: PIXI$Texture;
        uvs: number[];
        vertices: number[];
        indices: number[];
        dirty: boolean;
        blendMode: number;
        canvasPadding: number;
        drawMode: number;
        shader: PIXI$Shader | PIXI$AbstractFilter;
        getBounds(matrix?: PIXI$Matrix): PIXI$Rectangle;
        containsPoint(point: PIXI$Point): boolean;
        _texture: PIXI$Texture;
        _renderCanvasTriangleMesh(context: CanvasRenderingContext2D): void;
        _renderCanvasTriangles(context: CanvasRenderingContext2D): void;
        _renderCanvasDrawTriangle(
            context: CanvasRenderingContext2D,
            vertices: number,
            uvs: number,
            index0: number,
            index1: number,
            index2: number): void;
        renderMeshFlat(Mesh: Mesh): void;
        _onTextureUpdate(): void
    }
    declare export class Rope mixins Mesh {
        _ready: boolean;
        getTextureUvs(): PIXI$TextureUvs;
        constructor(texture: PIXI$Texture, points: PIXI$Point[]): this;
        points: PIXI$Point[];
        colors: number[];
        refresh(): void
    }
    declare export class Plane mixins Mesh {
        segmentsX: number;
        segmentsY: number;
        constructor(texture: PIXI$Texture, segmentsX?: number, segmentsY?: number): this
    }
    declare export class MeshRenderer mixins ObjectRenderer {
        _initWebGL(mesh: Mesh): void;
        indices: number[];
        constructor(renderer: PIXI$WebGLRenderer): this;
        render(mesh: Mesh): void;
        flush(): void;
        start(): void;
        destroy(): void
    }
    declare export type MeshShader = {} & PIXI$Shader

}


declare export var shared: ticker$Ticker;

declare export class Ticker {
    _tick(time: number): void;
    _emitter: PIXI$EventEmitter;
    _requestId: number;
    _maxElapsedMS: number;
    _requestIfNeeded(): void;
    _cancelIfNeeded(): void;
    _startIfPossible(): void;
    autoStart: boolean;
    deltaTime: number;
    elapsedMS: number;
    lastTime: number;
    speed: number;
    started: boolean;
    FPS: number;
    minFPS: number;
    add(fn: (deltaTime: number) => void, context?: any): ticker$Ticker;
    addOnce(fn: (deltaTime: number) => void, context?: any): ticker$Ticker;
    remove(fn: (deltaTime: number) => void, context?: any): ticker$Ticker;
    start(): void;
    stop(): void;
    update(): void
}
declare module 'pixi.js' {
    declare module.exports: typeof PIXI
}