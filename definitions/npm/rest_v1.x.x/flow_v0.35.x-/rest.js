// @flow
/**
 * Flowtype definitions for rest
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'rest' {
    declare     function rest(path: string): rest$ResponsePromise

    declare     var npm$namespace$rest: {
        setDefaultClient: typeof rest$setDefaultClient,
        getDefaultClient: typeof rest$getDefaultClient,
        resetDefaultClient: typeof rest$resetDefaultClient,
        wrap: typeof rest$wrap,
    }
    declare     export function rest$setDefaultClient(client: rest$Client): void

    declare     export function rest$getDefaultClient(): rest$Client

    declare     export function rest$resetDefaultClient(): void

    declare     export function rest$wrap<T>(interceptor: rest$Interceptor<T>, config?: T): rest$Client

    declare     export interface rest$Request {
        method?: string,
            path?: string,
            params?: any,
            headers?: any,
            entity?: any
    }

    declare     export interface rest$Status {
        code: number,
            text?: string
    }

    declare     export interface rest$Headers {
        [index: string]: any
    }

    declare     export interface rest$Response {
        request: rest$Request,
            raw: any,
            status: rest$Status,
            headers: rest$Headers,
            entity: any
    }

    declare     export type rest$ResponsePromise = {
        entity(): when.Promise<any>,
        status(): when.Promise<number>,
        headers(): when.Promise<rest$Headers>,
        header(headerName: string): when.Promise<any >
    }

    declare     export interface rest$Interceptor<T>{
        (parent?: rest$Client, config?: T): rest$Client
    }

    declare     export interface rest$Client {
        (path: string): rest$ResponsePromise,
        (request: rest$Request): rest$ResponsePromise,
        skip(): rest$Client,
            wrap<T>(interceptor: rest$Interceptor<T>, config?: T): rest$Client
    }

    declare     export interface rest$Meta {
        client: rest$Client,
            arguments: any
    }
}
declare module 'rest/interceptor' {
    declare module.exports: typeof interceptor
    declare interface interceptor$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
}
declare module 'rest/interceptor/defaultRequest' {
    declare     var defaultRequest: rest$Interceptor<defaultRequest$Config>;
    declare interface defaultRequest$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof defaultRequest
}
declare module 'rest/interceptor/hateoas' {
    declare     var hateoas: rest$Interceptor<hateoas$Config>;
    declare interface hateoas$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof hateoas
}
declare module 'rest/interceptor/location' {
    declare     var location: rest$Interceptor<location$Config>;
    declare interface location$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof location
}
declare module 'rest/interceptor/mime' {
    declare     var mime: rest$Interceptor<mime$Config>;
    declare interface mime$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof mime
}
declare module 'rest/interceptor/pathPrefix' {
    declare     var pathPrefix: rest$Interceptor<pathPrefix$Config>;
    declare interface pathPrefix$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof pathPrefix
}
declare module 'rest/interceptor/basicAuth' {
    declare     var basicAuth: rest$Interceptor<basicAuth$Config>;
    declare interface basicAuth$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof basicAuth
}
declare module 'rest/interceptor/oAuth' {
    declare     var oAuth: rest$Interceptor<oAuth$Config>;
    declare interface oAuth$DismissWindow {
        (): void
    }

    declare interface oAuth$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof oAuth
}
declare module 'rest/interceptor/csrf' {
    declare     var csrf: rest$Interceptor<csrf$Config>;
    declare interface csrf$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof csrf
}
declare module 'rest/interceptor/errorCode' {
    declare     var errorCode: rest$Interceptor<errorCode$Config>;
    declare interface errorCode$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof errorCode
}
declare module 'rest/interceptor/retry' {
    declare     var retry: rest$Interceptor<retry$Config>;
    declare interface retry$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof retry
}
declare module 'rest/interceptor/template' {
    declare     var template: rest$Interceptor<template$Config>;
    declare interface template$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof template
}
declare module 'rest/interceptor/timeout' {
    declare     var timeout: rest$Interceptor<timeout$Config>;
    declare interface timeout$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof timeout
}
declare module 'rest/interceptor/jsonp' {
    declare     var jsonp: rest$Interceptor<jsonp$Config>;
    declare interface jsonp$Config<T, U>{
        init?: (config: T) => U,
        request?: (
            request: rest$Request,
            config: U,
            meta: rest$Meta) => rest$Request | when.Promise<rest$Request>,
        response?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        success?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response>,
        error?: (
            response: rest$Response,
            config: U,
            meta: rest$Meta) => rest$Response | when.Promise<rest$Response >
    }
    declare module.exports: typeof jsonp
}
declare module 'rest/interceptor/ie/xdomain' {
    declare     var xdomain: rest$Interceptor<{}>;
    declare module.exports: typeof xdomain
}
declare module 'rest/interceptor/ie/xhr' {
    declare     var xhr: rest$Interceptor<{}>;
    declare module.exports: typeof xhr
}
declare module 'rest/mime/registry' {
    declare     var registry: registry$Registry;
    declare interface registry$MIMEConverter {
        read(value: string): any | when.Promise<any>,
            write(value: any): string | when.Promise<string >
    }

    declare interface registry$Registry {
        lookup(mimeType: string): when.Promise<registry$MIMEConverter>,
            register(mimeType: string, converter: registry$MIMEConverter): void
    }
    declare module.exports: typeof registry
}
declare module 'rest/client/xhr' {
    declare     var xhr: rest$Client;
    declare module.exports: typeof xhr
}
declare module 'rest/client/node' {
    declare     var node: rest$Client;
    declare module.exports: typeof node
}
declare module 'rest/client/jsonp' {
    declare     var jsonp: rest$Client;
    declare module.exports: typeof jsonp
}
declare module 'rest/client/xdr' {
    declare     var xdr: rest$Client;
    declare module.exports: typeof xdr
}