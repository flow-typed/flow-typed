/**
 * Flowtype definitions for jasmine
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
function describe(description: string, specDefinitions: () => void): voiddeclare
function fdescribe(description: string, specDefinitions: () => void): voiddeclare
function xdescribe(description: string, specDefinitions: () => void): voiddeclare
function it(expectation: string, assertion?: () => void, timeout?: number): voiddeclare
function fit(expectation: string, assertion?: () => void, timeout?: number): voiddeclare
function xit(expectation: string, assertion?: () => void, timeout?: number): void
/**
 * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending. 
 */
declare
function pending(reason?: string): voiddeclare
function beforeEach(action: () => void, timeout?: number): voiddeclare
function afterEach(action: () => void, timeout?: number): voiddeclare
function beforeAll(action: () => void, timeout?: number): voiddeclare
function afterAll(action: () => void, timeout?: number): voiddeclare
function expect(spy: Function): jasmine$Matchersdeclare
function fail(e?: any): void
/**
 * Action method that should be called when the async work is complete 
 */
declare type DoneFn = {
    (): void,

    /**
     * fails the spec and indicates that it has completed. If the message is an Error, Error.message is used 
     */
    fail: (message?: Error | string) => void
} & Function
declare
function spyOn(object: any, method: string): jasmine$Spydeclare
function runs(asyncMethod: Function): voiddeclare
function waitsFor(latchMethod: () => boolean, failureMessage?: string, timeout?: number): voiddeclare
function waits(timeout?: number): void
declare
var npm$namespace$jasmine: {
    any: typeof jasmine$any,
    anything: typeof jasmine$anything,
    arrayContaining: typeof jasmine$arrayContaining,
    objectContaining: typeof jasmine$objectContaining,
    createSpy: typeof jasmine$createSpy,
    createSpyObj: typeof jasmine$createSpyObj,
    pp: typeof jasmine$pp,
    getEnv: typeof jasmine$getEnv,
    addCustomEqualityTester: typeof jasmine$addCustomEqualityTester,
    addMatchers: typeof jasmine$addMatchers,
    stringMatching: typeof jasmine$stringMatching,
    formatErrorMsg: typeof jasmine$formatErrorMsg,
}
declare
var clock: () => jasmine$Clock;

declare
function jasmine$any(aclass: any): jasmine$Any

declare
function jasmine$anything(): jasmine$Any

declare
function jasmine$arrayContaining(sample: any[]): jasmine$ArrayContaining

declare
function jasmine$objectContaining(sample: any): jasmine$ObjectContaining

declare
function jasmine$createSpy(name: string, originalFn?: Function): jasmine$Spy

declare
function jasmine$createSpyObj(baseName: string, methodNames: any[]): any

declare
function jasmine$pp(value: any): string

declare
function jasmine$getEnv(): jasmine$Env

declare
function jasmine$addCustomEqualityTester(equalityTester: jasmine$CustomEqualityTester): void

declare
function jasmine$addMatchers(matchers: jasmine$CustomMatcherFactories): void

declare
function jasmine$stringMatching(str: string): jasmine$Any

declare
function jasmine$formatErrorMsg(domain: string, usage: string): (msg: string) => string

declare interface jasmine$Any {
    new(expectedClass: any): any,
    jasmineMatches(other: any): boolean,
        jasmineToString(): string
}

declare interface jasmine$ArrayLike<T>{
    length: number,
    [n: number]: T
}

declare interface jasmine$ArrayContaining {
    new(sample: any[]): any,
    asymmetricMatch(other: any): boolean,
        jasmineToString(): string
}

declare interface jasmine$ObjectContaining {
    new(sample: any): any,
    jasmineMatches(other: any, mismatchKeys: any[], mismatchValues: any[]): boolean,
        jasmineToString(): string
}

declare interface jasmine$Block {
    new(env: jasmine$Env, func: jasmine$SpecFunction, spec: jasmine$Spec): any,
    execute(onComplete: () => void): void
}

declare type jasmine$WaitsBlock = {
    new(env: jasmine$Env, timeout: number, spec: jasmine$Spec): any
} & jasmine$Block


declare type jasmine$WaitsForBlock = {
    new(
        env: jasmine$Env,
        timeout: number,
        latchFunction: jasmine$SpecFunction,
        message: string,
        spec: jasmine$Spec): any
} & jasmine$Block


declare interface jasmine$Clock {
    install(): void,
        uninstall(): void,

        /**
         * Calls to any registered callback are triggered when the clock is ticked forward via the jasmine.clock().tick function, which takes a number of milliseconds. 
         */
        tick(ms: number): void,
        mockDate(date?: Date): void,
        withMock(func: () => void): void
}

declare interface jasmine$CustomEqualityTester {
    (first: any, second: any): boolean
}

declare interface jasmine$CustomMatcher {
    compare<T>(actual: T, expected: T): jasmine$CustomMatcherResult,
        compare(actual: any, expected: any): jasmine$CustomMatcherResult
}

declare interface jasmine$CustomMatcherFactory {
    (util: jasmine$MatchersUtil, customEqualityTesters: Array<jasmine$CustomEqualityTester>): jasmine$CustomMatcher
}

declare interface jasmine$CustomMatcherFactories {
    [index: string]: jasmine$CustomMatcherFactory
}

declare interface jasmine$CustomMatcherResult {
    pass: boolean,
        message?: string
}

declare interface jasmine$MatchersUtil {
    equals(a: any, b: any, customTesters?: Array<jasmine$CustomEqualityTester>): boolean,
        contains<T>(
            haystack: jasmine$ArrayLike<T>| string,
            needle: any,
            customTesters?: Array<jasmine$CustomEqualityTester>): boolean,
        buildFailureMessage(
            matcherName: string,
            isNot: boolean,
            actual: any,
            ...expected: Array<any>): string
}

declare interface jasmine$Env {
    setTimeout: any,
        clearTimeout: void,
        setInterval: any,
        clearInterval: void,
        updateInterval: number,
        currentSpec: jasmine$Spec,
        matchersClass: jasmine$Matchers,
        version(): any,
        versionString(): string,
        nextSpecId(): number,
        addReporter(reporter: jasmine$Reporter): void,
        addReporter(reporter: jasmine$CustomReporter): void,
        execute(): void,
        describe(description: string, specDefinitions: () => void): jasmine$Suite,
        beforeEach(beforeEachFunction: () => void): void,
        beforeAll(beforeAllFunction: () => void): void,
        currentRunner(): jasmine$Runner,
        afterEach(afterEachFunction: () => void): void,
        afterAll(afterAllFunction: () => void): void,
        xdescribe(desc: string, specDefinitions: () => void): jasmine$XSuite,
        it(description: string, func: () => void): jasmine$Spec,
        xit(desc: string, func: () => void): jasmine$XSpec,
        compareRegExps_(
            a: RegExp,
            b: RegExp,
            mismatchKeys: string[],
            mismatchValues: string[]): boolean,
        compareObjects_(a: any, b: any, mismatchKeys: string[], mismatchValues: string[]): boolean,
        equals_(a: any, b: any, mismatchKeys: string[], mismatchValues: string[]): boolean,
        contains_(haystack: any, needle: any): boolean,
        addCustomEqualityTester(equalityTester: jasmine$CustomEqualityTester): void,
        addMatchers(matchers: jasmine$CustomMatcherFactories): void,
        specFilter(spec: jasmine$Spec): boolean,
        throwOnExpectationFailure(value: boolean): void,
        seed(seed: string | number): string | number,
        provideFallbackReporter(reporter: jasmine$Reporter): void,
        throwingExpectationFailures(): boolean,
        allowRespy(allow: boolean): void,
        randomTests(): boolean,
        randomizeTests(b: boolean): void
}

declare interface jasmine$FakeTimer {
    new(): any,
    reset(): void,
        tick(millis: number): void,
        runFunctionsWithinRange(oldMillis: number, nowMillis: number): void,
        scheduleFunction(
            timeoutKey: any,
            funcToCall: () => void,
            millis: number,
            recurring: boolean): void
}

declare interface jasmine$HtmlReporter {
    new(): any
}

declare interface jasmine$HtmlSpecFilter {
    new(): any
}

declare interface jasmine$Result {
    type: string
}

declare type jasmine$NestedResults = {
    description: string,
    totalCount: number,
    passedCount: number,
    failedCount: number,
    skipped: boolean,
    rollupCounts(result: jasmine$NestedResults): void,
    log(values: any): void,
    getItems(): jasmine$Result[],
    addResult(result: jasmine$Result): void,
    passed(): boolean
} & jasmine$Result


declare type jasmine$MessageResult = {
    values: any,
    trace: jasmine$Trace
} & jasmine$Result


declare type jasmine$ExpectationResult = {
    matcherName: string,
    passed(): boolean,
    expected: any,
    actual: any,
    message: string,
    trace: jasmine$Trace
} & jasmine$Result


declare interface jasmine$Order {
    new(options: {
        random: boolean,
        seed: string
    }): any,
    random: boolean,
        seed: string,
        sort<T>(items: T[]): T[]
}

declare class ExpectationFailed mixins Error {
    constructor(): this;
    stack: any
}

declare interface jasmine$TreeProcessor {
    new(attrs: any): any,
    execute: (done: Function) => void,
        processTree(): any
}

declare interface jasmine$Trace {
    name: string,
        message: string,
        stack: any
}

declare interface jasmine$PrettyPrinter {
    new(): any,
    format(value: any): void,
        iterateObject(obj: any, fn: (property: string, isGetter: boolean) => void): void,
        emitScalar(value: any): void,
        emitString(value: string): void,
        emitArray(array: any[]): void,
        emitObject(obj: any): void,
        append(value: any): void
}

declare type jasmine$StringPrettyPrinter = {} & jasmine$PrettyPrinter


declare interface jasmine$Queue {
    new(env: any): any,
    env: jasmine$Env,
        ensured: boolean[],
        blocks: jasmine$Block[],
        running: boolean,
        index: number,
        offset: number,
        abort: boolean,
        addBefore(block: jasmine$Block, ensure?: boolean): void,
        add(block: any, ensure?: boolean): void,
        insertNext(block: any, ensure?: boolean): void,
        start(onComplete?: () => void): void,
        isRunning(): boolean,
        next_(): void,
        results(): jasmine$NestedResults
}

declare interface jasmine$Matchers {
    new(env: jasmine$Env, actual: any, spec: jasmine$Env, isNot?: boolean): any,
    env: jasmine$Env,
        actual: any,
        spec: jasmine$Env,
        isNot?: boolean,
        message(): any,
        toBe(expected: any, expectationFailOutput?: any): boolean,
        toEqual(expected: any, expectationFailOutput?: any): boolean,
        toMatch(expected: string | RegExp, expectationFailOutput?: any): boolean,
        toBeDefined(expectationFailOutput?: any): boolean,
        toBeUndefined(expectationFailOutput?: any): boolean,
        toBeNull(expectationFailOutput?: any): boolean,
        toBeNaN(): boolean,
        toBeTruthy(expectationFailOutput?: any): boolean,
        toBeFalsy(expectationFailOutput?: any): boolean,
        toHaveBeenCalled(): boolean,
        toHaveBeenCalledWith(...params: any[]): boolean,
        toHaveBeenCalledTimes(expected: number): boolean,
        toContain(expected: any, expectationFailOutput?: any): boolean,
        toBeLessThan(expected: number, expectationFailOutput?: any): boolean,
        toBeLessThanOrEqual(expected: number, expectationFailOutput?: any): boolean,
        toBeGreaterThan(expected: number, expectationFailOutput?: any): boolean,
        toBeGreaterThanOrEqual(expected: number, expectationFailOutput?: any): boolean,
        toBeCloseTo(expected: number, precision?: any, expectationFailOutput?: any): boolean,
        toThrow(expected?: any): boolean,
        toThrowError(message?: string | RegExp): boolean,
        toThrowError(expected?: (...args: any[]) => Error, message?: string | RegExp): boolean,
        not: jasmine$Matchers,
        Any: jasmine$Any
}

declare interface jasmine$Reporter {
    reportRunnerStarting(runner: jasmine$Runner): void,
        reportRunnerResults(runner: jasmine$Runner): void,
        reportSuiteResults(suite: jasmine$Suite): void,
        reportSpecStarting(spec: jasmine$Spec): void,
        reportSpecResults(spec: jasmine$Spec): void,
        log(str: string): void
}

declare type jasmine$MultiReporter = {
    addReporter(reporter: jasmine$Reporter): void
} & jasmine$Reporter


declare interface jasmine$SuiteInfo {
    totalSpecsDefined: number
}

declare interface jasmine$CustomReportExpectation {
    matcherName: string,
        message: string,
        passed: boolean,
        stack: string
}

declare type jasmine$FailedExpectation = {
    actual: string,
    expected: string
} & jasmine$CustomReportExpectation


declare type jasmine$PassedExpectation = {} & jasmine$CustomReportExpectation


declare interface jasmine$CustomReporterResult {
    description: string,
        failedExpectations?: jasmine$FailedExpectation[],
        fullName: string,
        id: string,
        passedExpectations?: jasmine$PassedExpectation[],
        pendingReason?: string,
        status?: string
}

declare interface jasmine$CustomReporter {
    jasmineStarted(suiteInfo: jasmine$SuiteInfo): void,
        suiteStarted(result: jasmine$CustomReporterResult): void,
        specStarted(result: jasmine$CustomReporterResult): void,
        specDone(result: jasmine$CustomReporterResult): void,
        suiteDone(result: jasmine$CustomReporterResult): void,
        jasmineDone(): any
}

declare interface jasmine$Runner {
    new(env: jasmine$Env): any,
    execute(): void,
        beforeEach(beforeEachFunction: jasmine$SpecFunction): void,
        afterEach(afterEachFunction: jasmine$SpecFunction): void,
        beforeAll(beforeAllFunction: jasmine$SpecFunction): void,
        afterAll(afterAllFunction: jasmine$SpecFunction): void,
        finishCallback(): void,
        addSuite(suite: jasmine$Suite): void,
        add(block: jasmine$Block): void,
        specs(): jasmine$Spec[],
        suites(): jasmine$Suite[],
        topLevelSuites(): jasmine$Suite[],
        results(): jasmine$NestedResults
}

declare interface jasmine$SpecFunction {
    (spec?: jasmine$Spec): void
}

declare interface jasmine$SuiteOrSpec {
    id: number,
        env: jasmine$Env,
        description: string,
        queue: jasmine$Queue
}

declare type jasmine$Spec = {
    new(env: jasmine$Env, suite: jasmine$Suite, description: string): any,
    suite: jasmine$Suite,
    afterCallbacks: jasmine$SpecFunction[],
    spies_: jasmine$Spy[],
    results_: jasmine$NestedResults,
    matchersClass: jasmine$Matchers,
    getFullName(): string,
    results(): jasmine$NestedResults,
    log(arguments: any): any,
    runs(func: jasmine$SpecFunction): jasmine$Spec,
    addToQueue(block: jasmine$Block): void,
    addMatcherResult(result: jasmine$Result): void,
    getResult(): any,
    expect(actual: any): any,
    waits(timeout: number): jasmine$Spec,
    waitsFor(
        latchFunction: jasmine$SpecFunction,
        timeoutMessage?: string,
        timeout?: number): jasmine$Spec,
    fail(e?: any): void,
    getMatchersClass_(): jasmine$Matchers,
    addMatchers(matchersPrototype: jasmine$CustomMatcherFactories): void,
    finishCallback(): void,
    finish(onComplete?: () => void): void,
    after(doAfter: jasmine$SpecFunction): void,
    execute(onComplete?: () => void, enabled?: boolean): any,
    addBeforesAndAftersToQueue(): void,
    explodes(): void,
    spyOn(obj: any, methodName: string, ignoreMethodDoesntExist: boolean): jasmine$Spy,
    removeAllSpies(): void,
    throwOnExpectationFailure: boolean
} & jasmine$SuiteOrSpec


declare interface jasmine$XSpec {
    id: number,
        runs(): void
}

declare type jasmine$Suite = {
    new(
        env: jasmine$Env,
        description: string,
        specDefinitions: () => void,
        parentSuite: jasmine$Suite): any,
    parentSuite: jasmine$Suite,
    getFullName(): string,
    finish(onComplete?: () => void): void,
    beforeEach(beforeEachFunction: jasmine$SpecFunction): void,
    afterEach(afterEachFunction: jasmine$SpecFunction): void,
    beforeAll(beforeAllFunction: jasmine$SpecFunction): void,
    afterAll(afterAllFunction: jasmine$SpecFunction): void,
    results(): jasmine$NestedResults,
    add(suiteOrSpec: jasmine$SuiteOrSpec): void,
    specs(): jasmine$Spec[],
    suites(): jasmine$Suite[],
    children(): any[],
    execute(onComplete?: () => void): void
} & jasmine$SuiteOrSpec


declare interface jasmine$XSuite {
    execute(): void
}

declare interface jasmine$Spy {
    (...params: any[]): any,
    identity: string,
        and: jasmine$SpyAnd,
        calls: jasmine$Calls,
        mostRecentCall: {
            args: any[]
        },
        argsForCall: any[],
        wasCalled: boolean
}

declare interface jasmine$SpyAnd {

    /**
     * By chaining the spy with and.callThrough, the spy will still track all calls to it but in addition it will delegate to the actual implementation. 
     */
    callThrough(): jasmine$Spy,

        /**
         * By chaining the spy with and.returnValue, all calls to the function will return a specific value. 
         */
        returnValue(val: any): jasmine$Spy,

        /**
         * By chaining the spy with and.returnValues, all calls to the function will return specific values in order until it reaches the end of the return values list. 
         */
        returnValues(...values: any[]): jasmine$Spy,

        /**
         * By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied function. 
         */
        callFake(fn: Function): jasmine$Spy,

        /**
         * By chaining the spy with and.throwError, all calls to the spy will throw the specified value. 
         */
        throwError(msg: string): jasmine$Spy,

        /**
         * When a calling strategy is used for a spy, the original stubbing behavior can be returned at any time with and.stub. 
         */
        stub(): jasmine$Spy
}

declare interface jasmine$Calls {

    /**
     * By chaining the spy with calls.any(), will return false if the spy has not been called at all, and then true once at least one call happens. 
     */
    any(): boolean,

        /**
         * By chaining the spy with calls.count(), will return the number of times the spy was called 
         */
        count(): number,

        /**
         * By chaining the spy with calls.argsFor(), will return the arguments passed to call number index 
         */
        argsFor(index: number): any[],

        /**
         * By chaining the spy with calls.allArgs(), will return the arguments to all calls 
         */
        allArgs(): any[],

        /**
         * By chaining the spy with calls.all(), will return the context (the this) and arguments passed all calls 
         */
        all(): jasmine$CallInfo[],

        /**
         * By chaining the spy with calls.mostRecent(), will return the context (the this) and arguments for the most recent call 
         */
        mostRecent(): jasmine$CallInfo,

        /**
         * By chaining the spy with calls.first(), will return the context (the this) and arguments for the first call 
         */
        first(): jasmine$CallInfo,

        /**
         * By chaining the spy with calls.reset(), will clears all tracking for a spy 
         */
        reset(): void
}

declare interface jasmine$CallInfo {

    /**
     * The context (the this) for the call 
     */
    object: any,

        /**
         * All arguments passed to the call 
         */
        args: any[],

        /**
         * The return value of the call 
         */
        returnValue: any
}

declare interface jasmine$Util {
    inherit(childClass: Function, parentClass: Function): any,
        formatException(e: any): any,
        htmlEscape(str: string): string,
        argsToArray(args: any): any,
        extend(destination: any, source: any): any
}

declare type jasmine$JsApiReporter = {
    started: boolean,
    finished: boolean,
    result: any,
    messages: any,
    runDetails: {
        failedExpectations: jasmine$ExpectationResult[],
        order: jasmine$Order
    },
    new(): any,
    suites(): jasmine$Suite[],
    summarize_(suiteOrSpec: jasmine$SuiteOrSpec): any,
    results(): any,
    resultsForSpec(specId: any): any,
    log(str: any): any,
    resultsForSpecs(specIds: any): any,
    summarizeResult_(result: any): any
} & jasmine$Reporter


declare interface jasmine$Jasmine {
    Spec: jasmine$Spec,
        clock: jasmine$Clock,
        util: jasmine$Util
}

declare
export var HtmlReporter: jasmine$HtmlReporter;

declare
export var HtmlSpecFilter: jasmine$HtmlSpecFilter;

declare
export var DEFAULT_TIMEOUT_INTERVAL: number;