// @flow
/**
 * Flowtype definitions for analytics-node
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module '3d-bin-packing' {
    declare module.exports: typeof bws$packer
}
declare var ReactDataGrid: typeof undefined;
/**
 * <p> Cumulated lengths of current layer. </p>
 * 
<p> {@link Scrapped} represents an edge of the current layer under construction. </p>
 * @author  Bill Knechtel, <br>
Migrated and Refactored by Jeongho Nam <http://samchon.org>
*/
declare class Scrap {

    /**
     * Cumulated length on the X-axis in 3D.
     */
    cumx: number;

    /**
     * Cumulated length on the Z-axis in 3D.
     */
    cumz: number;

    /**
     * Default Constructor.
     */
    constructor(): this;

    /**
     * Initialization Constructor.
     * @param cumx Cumulated length on the x-axis.
     * @param cumz Cumulated length on the z-axis.
     */
    constructor(cumx: number, cumz: number): this
}
declare module 'packer' {

    /**
     * 
     * @brief  Packer, a solver of 3d bin packing with multiple wrappers.
     * @details  * <p> Packer is a facade class supporting packing operations in user side. You can solve a packing problem
    by constructing Packer class with {
     * @link  WrapperArray wrappers} and {
     * @link  InstanceArray instances} to
    pack and executing {
     * @link  optimize Packer.optimize()} method. </p>

    <p> In background side, deducting packing solution, those algorithms are used. </p>
    <ul>
    <li> <a href="http://betterwaysystems.github.io/packer/reference/AirForceBinPacking.pdf" target="_blank">
    Airforce Bin Packing; 3D pallet packing problem: A human intelligence-based heuristic approach </a>
    </li>
    <li> Genetic Algorithm </li>
    <li> Greedy and Back-tracking algorithm </li>
    </ul>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Packer mixins undefined.Entity {

        /**
         * Candidate wrappers who can contain instances.
         */
        wrapperArray: WrapperArray;

        /**
         * Instances trying to pack into the wrapper.
         */
        instanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param wrapperArray Candidate wrappers who can contain instances.
         * @param instanceArray Instances to be packed into some wrappers.
         */
        constructor(wrapperArray: WrapperArray, instanceArray: InstanceArray): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Get wrapperArray.
         */
        getWrapperArray(): WrapperArray;

        /**
         * Get instanceArray.
         */
        getInstanceArray(): InstanceArray;

        /**
         * <p> Deduct
         */
        optimize(): WrapperArray;

        /**
         * 
         * @brief  Initialize sequence list (gene_array).
         * @details  * <p> Deducts initial sequence list by such assumption: </p>

        <ul>
        <li> Cost of larger wrapper is less than smaller one, within framework of price per volume unit. </li>
        <ul>
        <li> Wrapper Larger: (price: $1,000, volume: 100cm^3 -> price per volume unit: $10 / cm^3) </li>
        <li> Wrapper Smaller: (price: $700, volume: 50cm^3 -> price per volume unit: $14 / cm^3) </li>
        <li> Larger's <u>cost</u> is less than Smaller, within framework of price per volume unit </li>
        </ul>
        </ul>

        <p> Method {
         * @link  initGenes initGenes()} constructs {
         * @link  WrapperGroup WrapperGroups} corresponding
        with the {
         * @link  wrapperArray} and allocates {
         * @link  instanceArray instances} to a {
         * @link  WrapperGroup},
        has the smallest <u>cost</u> between containbles. </p>

        <p> After executing packing solution by {
         * @link  WrapperGroup.optimize WrapperGroup.optimize()}, trying to
        {
         * @link  repack re-pack} each {
         * @link  WrapperGroup} to another type of {
         * @link  Wrapper}, deducts the best
        solution between them. It's the initial sequence list of genetic algorithm. </p>
         * @return  Initial sequence list.
        */
        initGenes(): GAWrapperArray;

        /**
         * Try to repack each wrappers to another type.
         * @param $wrappers Wrappers to repack.
         * @return  Re-packed wrappers.
         */
        repack($wrappers: WrapperArray): WrapperArray;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * Bridge of {@link Packer} for {@link InstanceForm repeated instances}.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class PackerForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Initializer Constructor.
         * @param instanceFormArray Form of Instances to pack.
         * @param wrapperArray Type of Wrappers to be used.
         */
        constructor(instanceFormArray: InstanceFormArray, wrapperArray: WrapperArray): this;
        construct(xml: undefined.XML): void;
        optimize(): WrapperArray;
        getInstanceFormArray(): InstanceFormArray;
        getWrapperArray(): WrapperArray;
        TAG(): string;
        toXML(): undefined.XML;
        toPacker(): Packer
    }

    /**
     * An array of {@link InstanceForm} objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceFormArray mixins undefined.EntityArrayCollection<InstanceForm>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createChild(xml: undefined.XML): InstanceForm;
        TAG(): string;
        CHILD_TAG(): string;

        /**
         * Convert {@link InstanceForm} objects to {@link InstanceArray}.
         * @return  An array of instance containing repeated instances in {
         * @link  InstanceForm} objects.
         */
        toInstanceArray(): InstanceArray
    }

    /**
     * <p> A repeated Instance. </p>
     * 
    <p> InstanceForm is an utility class for repeated {@link Instance}. It is designed for shrinking
    volume of network message I/O by storing {@link count repeated count}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class InstanceForm mixins undefined.Entity {

        /**
         * Default Constructor.
         */
        constructor(instance?: boxologic$Instance, count?: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;
        key(): any;
        getInstance(): boxologic$Instance;
        getCount(): number;
        setCount(val: number): void;
        $name: string;
        $width: string;
        $height: string;
        $length: string;
        $count: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Repeated {@link instance} to {@link InstanceArray}.
         * @details  * <p> Contains the {
         * @link  instance repeated instance} to an {
         * @link  InstanceArray} to make
        {
         * @link  instance} to participate in the packing process. The returned {
         * @link  InstanceArray} will be
        registered on {
         * @link  Packer.instanceArray}.
         * @return  An array of instance containing repeated {
         * @link  instance}.
        */
        toInstanceArray(): InstanceArray
    }
    declare class WrapperArray mixins undefined.EntityArrayCollection<Wrapper>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrapper;

        /**
         * Get (calculate) price.
         */
        getPrice(): number;

        /**
         * Get (calculate) utilization rate.
         */
        getUtilization(): number;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }
    declare class GAWrapperArray mixins WrapperArray {
        instanceArray: InstanceArray;
        result: std.HashMap<string,
        WrapperGroup>;

        /**
         * Construct from instances.
         * @param instanceArray Instances to be wrapped.
         */
        constructor(instanceArray: InstanceArray): this;

        /**
         * 
         * @brief  Copy Constructor.
         */
        constructor(genes: GAWrapperArray): this;

        /**
         * 
         * @brief  Get optimization result.
         * @return  result map.
         */
        getResult(): std.HashMap<string,
        WrapperGroup>;
        less(obj: GAWrapperArray): boolean
    }

    /**
     * An interface of physical 3D-instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare type Instance = {

        /**
         * Get name.
         */
        getName(): string,

        /**
         * Get width, length on the X-axis in 3D.
         */
        getWidth(): number,

        /**
         * Get height, length on the Y-axis in 3D.
         */
        getHeight(): number,

        /**
         * Get length, length on the Z-axis in 3D.
         */
        getLength(): number,

        /**
         * Get (calculate) volume.
         * @return  width x height x length
         */
        getVolume(): number,

        /**
         * Set name.
         */
        setName(val: string): void,

        /**
         * Set width, length on the X-axis in 3D.
         */
        setWidth(val: number): void,

        /**
         * Set height, length on the Y-axis in 3D.
         */
        setHeight(val: number): void,

        /**
         * Set length, length on the Z-axis in 3D.
         */
        setLength(val: number): void,

        /**
         * <p> A type, identifier of derived class. </p>
         * 
        <h4> Derived types </h4>
        <ul>
        <li> {@link Product product} </li>
        <li> {@link Wrapper wrapper} </li>
        <ul>
        */
        TYPE(): string
    }

    /**
     * An array of Instance objects.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class InstanceArray mixins undefined.EntityArray<boxologic$Instance>{

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): boxologic$Instance;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string
    }

    /**
     * A product.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Product mixins undefined.Entity, Instance {

        /**
         * <p> Name, key of the Product. </p>
         * 
        <p> The name must be unique because a name identifies a {@link Product}. </p>
        */
        name: string;

        /**
         * Width of the Product, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Product, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Product, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Construct from members.
         * @param name Name, identifier of the Product.
         * @param width Width, length on the X-axis in 3D.
         * @param height Height, length on the Y-axis in 3D.
         * @param length Length, length on the Z-axis in 3D.
         */
        constructor(name: string, width: number, height: number, length: number): this;

        /**
         * Key of a Product is its name.
         */
        key(): any;

        /**
         * 
         * @inheritdoc  
         */
        getName(): string;

        /**
         * 
         * @inheritdoc  
         */
        getWidth(): number;

        /**
         * 
         * @inheritdoc  
         */
        getHeight(): number;

        /**
         * 
         * @inheritdoc  
         */
        getLength(): number;

        /**
         * 
         * @inheritdoc  
         */
        getVolume(): number;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML
    }

    /**
     * <p> Wrap represents an act wrap(ping). </p>
     * 
    <p> {@link Wrap} is a class represents an act wrapping an {@link Instance} to an {@link Wrapper}.
    To represent the relationship, Wrap uses Bridge and Capsular patterns to links and intermediates
    relationship between Wrapper and Instance. </p>

    <p> Wrap also helps packing optimization and 3d-visualization with its own members
    {
     * @link  orientation} and position variables {
     * @link  x}, {
     * @link  y} and {
     * @link  z}. </p>
     * @author  Jeongho Nam <http://samchon.org>
    */
    declare class Wrap mixins undefined.Entity {

        /**
         * A wrapper wrapping the {@link instance}.
         */
        wrapper: Wrapper;

        /**
         * An instance wrapped into the {@link wrapper}.
         */
        instance: boxologic$Instance;

        /**
         * Coordinate-X of the instance placement in the wrapper.
         */
        x: number;

        /**
         * Coordinate-Y of the instance placement in the wrapper.
         */
        y: number;

        /**
         * Coordinate-Z of the instance placement in the wrapper.
         */
        z: number;

        /**
         * Placement orientation of wrapped {@link instance}.
         */
        orientation: number;

        /**
         * 
         */
        color: number;

        /**
         * Construct from a Wrapper.
         * @param wrapper A wrapper who will contain an instance.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from a Wrapper and Instance with its position and default orientation 1.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number): this;

        /**
         * Construct from a Wrapper and Instance with its position and orientation.
         * @param wrapper A wrapper who contains the instance.
         * @param instance An instance contained into the wrapper.
         * @param x Coordinate-X of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param y Coordinate-Y of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param z Coordinate-Z of the {
         * @link  instance} placement in the {
         * @link  wrapper}.
         * @param orientation Placement orientation of wrapped {
         * @link  instance}.
         */
        constructor(wrapper: Wrapper, instance: boxologic$Instance, x: number, y: number, z: number, orientation: number): this;

        /**
         * 
         * @inheritdoc  
         */
        construct(xml: undefined.XML): void;

        /**
         * Factory method of wrapped Instance.
         * @param type Type of contained Instance's type.
         */
        createInstance(type: string): boxologic$Instance;

        /**
         * Set orientation.
         * @param orientation Orientation code (1 to 6).
         */
        setOrientation(orientation: number): void;

        /**
         * Set position.
         * @param x Coordinate-X of the instance placement in the wrapper.
         * @param y Coordinate-Y of the instance placement in the wrapper.
         * @param z Coordinate-Z of the instance placement in the wrapper.
         */
        setPosition(x: number, y: number, z: number): void;

        /**
         * 
         * @brief  Estimate orientation by given size.
         * @param width Width by placement.
         * @param height Height by placement.
         * @param length Length by placement.
         */
        estimateOrientation(width: number, height: number, length: number): void;

        /**
         * 
         * @brief  Orientation change is occured in level of the packer.
         * @details  orientation Packer's new orientation.
         */
        changeWrapperOrientation(orientation: number): void;

        /**
         * Get wrapper.
         */
        getWrapper(): Wrapper;

        /**
         * Get instance.
         */
        getInstance(): boxologic$Instance;

        /**
         * Get x.
         */
        getX(): number;

        /**
         * Get y.
         */
        getY(): number;

        /**
         * Get z.
         */
        getZ(): number;

        /**
         * Get orientation.
         */
        getOrientation(): number;

        /**
         * Get width.
         */
        getWidth(): number;

        /**
         * Get height.
         */
        getHeight(): number;

        /**
         * Get length.
         */
        getLength(): number;

        /**
         * Get volume.
         */
        getVolume(): number;
        $instanceName: string;
        $layoutScale: string;
        $position: string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * 
         * @param geometry 
         * @return  A shape and its boundary lines as 3D-objects.
         */
        toDisplayObjects(geometry: THREE$Geometry): std.Vector<THREE$Object3D >
    }

    /**
     * A wrapper wrapping instances.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class Wrapper mixins undefined.EntityDeque<Wrap>, Instance {

        /**
         * <p> Name, key of the Wrapper. </p>
         * 
        <p> The name represents a type of Wrapper and identifies the Wrapper. </p>
        */
        name: string;

        /**
         * Price, cost of using an Wrapper.
         */
        price: number;

        /**
         * Width of the Wrapper, length on the X-axis in 3D.
         */
        width: number;

        /**
         * Height of the Wrapper, length on the Y-axis in 3D.
         */
        height: number;

        /**
         * Length of the Wrapper, length on the Z-axis in 3D.
         */
        length: number;

        /**
         * <p> Thickness, margin of a Wrapper causes shrinkness of containable volume. </p>
         * 
        <p> The thickness reduces each dimension's containable size (dimension - 2thickness),
        so finally, it reduces total containable volume (-8  thickness^3). </p>
        */
        thickness: number;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapper: Wrapper): this;

        /**
         * Construct from members.
         * @param name Name, identifier of a Wrapper.
         * @param price Price, issued cost for a type of the Wrapper.
         * @param width Width, dimensional length on the X-axis in 3D.
         * @param height Height, dimensional length on the Y-axis in 3D.
         * @param length Length, dimensional length on the Z-axis in 3D.
         * @param thickness A thickness causes shrinkness on containable volume.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;
        construct(xml: undefined.XML): void;

        /**
         * 
         * @inheritdoc  
         */
        createChild(xml: undefined.XML): Wrap;

        /**
         * Key of a Wrapper is its name.
         */
        key(): any;

        /**
         * Get name.
         */
        getName(): string;

        /**
         * Get price.
         */
        getPrice(): number;

        /**
         * Get width, length on X-axis in 3D.
         */
        getWidth(): number;

        /**
         * Get height, length on Y-axis in 3D.
         */
        getHeight(): number;

        /**
         * Get length, length on Z-axis in 3D.
         */
        getLength(): number;

        /**
         * Get thickness.
         */
        getThickness(): number;

        /**
         * <p> Get (calculate) containable width, length on the X-axis in 3D. </p>
         * 
        <p> Calculates containable width considering the {@link thickness}. </p>
         * @return  width - (2 x thickness)
        */
        getContainableWidth(): number;

        /**
         * <p> Get (calculate) containable height, length on the Y-axis in 3D. </p>
         * 
        <p> Calculates containable height considering the {@link thickness}. </p>
         * @return  height - (2 x thickness)
        */
        getContainableHeight(): number;

        /**
         * <p> Get (calculate) containable length, length on the Z-axis in 3D. </p>
         * 
        <p> Calculates containable length considering the {@link thickness}. </p>
         * @return  length - (2 x thickness)
        */
        getContainableLength(): number;

        /**
         * <p> Get (calculate) volume. </p>
         * 
        <h4> Notice </h4>
        <p> If {@link thickness} of the Wrapper is not 0, the volume does not mean containable volume.
        In that case, use {@link containableVolume} instead. </p>
         * @return  width x height x length
        */
        getVolume(): number;

        /**
         * <p> Get (calculate) containable volume. </p>
         * 
        <p> Calculates containable volume considering the {@link thickness}. </p>
         * @return  volume - {(2 x thickness) ^ 3}
        */
        getContainableVolume(): number;

        /**
         * Get utilization ratio of containable volume.
         * @return  utilization ratio.
         */
        getUtilization(): number;
        equal_to(obj: Wrapper): boolean;

        /**
         * <p> Wrapper is enough greater? </p>
         * 
        <p> Test whether the Wrapper is enough greater than an Instance to contain. </p>
         * @param instance An Instance to test.
         * @return  Enough greater or not.
        */
        containable(instance: boxologic$Instance): boolean;

        /**
         * 
         * @inheritdoc  
         */
        setName(val: string): void;

        /**
         * Set price.
         */
        setPrice(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setWidth(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setHeight(val: number): void;

        /**
         * 
         * @inheritdoc  
         */
        setLength(val: number): void;

        /**
         * Set thickness.
         */
        setThickness(val: number): void;
        $name: string;
        $price: string;
        $width: string;
        $height: string;
        $length: string;
        $thickness: string;
        $scale: string;
        $spaceUtilization: string;

        /**
         * 
         * @inheritdoc  
         */
        TYPE(): string;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        CHILD_TAG(): string;

        /**
         * 
         * @inheritdoc  
         */
        toXML(): undefined.XML;

        /**
         * <p> Convert to a canvas containing 3D elements. </p>
         * @param endIndex 
         * @return  A 3D-canvans printing the Wrapper and its children {
         * @link  Wrap wrapped}
        {
         * @link  Instance instances} with those boundary lines.
        */
        toCanvas(endIndex?: number): HTMLCanvasElement
    }

    /**
     * A group of {@link Wrapper Wrappers} with same type.
     * @author  Jeongho Nam <http://samchon.org>
     */
    declare class WrapperGroup mixins WrapperArray {

        /**
         * <p> A sample, standard of the WrapperGroup. </p>
         * 
        <p> The sample represents what type of Wrappers are grouped into the WrapperGroup. </p>
        */
        sample: Wrapper;

        /**
         * Allocated instances.
         */
        allocatedInstanceArray: InstanceArray;

        /**
         * Default Constructor.
         */
        constructor(): this;

        /**
         * Copy Constructor.
         */
        constructor(wrapperGroup: WrapperGroup): this;

        /**
         * Construct from a sample.
         * @param sample A sample, standard of the WrapperGroup.
         */
        constructor(sample: Wrapper): this;

        /**
         * Construct from members of the {@link sample}.
         * @param name Name, identifier of the sample.
         * @param price Price, issued cost for a type of the sample.
         * @param width Width, dimensional length on the X-axis in 3D, of the sample.
         * @param height Height, dimensional length on the Y-axis in 3D, of the sample.
         * @param length Length, dimensional length on the Z-axis in 3D, of the sample.
         * @param thickness A thickness, causes shrinkness on containable volume, of the sample.
         */
        constructor(name: string, price: number, width: number, height: number, length: number, thickness: number): this;

        /**
         * Key of a WrapperGroup is dependent on its sample.
         */
        key(): any;

        /**
         * Get sample.
         */
        getSample(): Wrapper;

        /**
         * Get allocated instances.
         */
        getAllocatedInstanceArray(): InstanceArray;

        /**
         * Get (calculate) price.
         * @return  (Price of the sample) x (numbers of children Wrappers)
         */
        getPrice(): number;

        /**
         * 
         * @inheritdoc  
         */
        getUtilization(): number;

        /**
         * <p> Allocate instance(s) to the WrapperGroup. </p>
         * 
        <p> Inspect the instance is enough small to be wrapped into an empty wrapper. If the instance
        is enough small, registers the instance (or repeated instances) to the {@link reserveds} and
        returns <code>true</code>. If the instance is too large to be capsuled, returns <code>false</code>. </p>

        <h4>Note</h4>
        <p> The word <u>the instance is enough small to be wrapped into the empty wrapper</u> means
        the instance can be contained into an empty, a new wrapper contaning nothing literally. </p>

        <p> In the method allocate(), it doesn't consider how many instances are wrapped into ordinary
        wrapper and how much volumes are consumed.  </p>
         * @param instance An Instance to allocate.
         * @param n Repeating number of the <i>instance</i>.
         * @return  Whether the instance is enough small to be wrapped into a (new) wrapper
        of same type with the sample.
        */
        allocate(instance: boxologic$Instance, n?: number): boolean;

        /**
         * <p> Run optimization in level of the group. </p>
         * 
        <p> The optimization routine begins by creating a {@link Wrapper} like the {@link sample}. Then
        try to pack {@link allocatedInstanceArray allocated instances} to the {@link Wrapper} as a lot as
        possible. If there're some {@link Wrappers} can't be packed by overloading, then create a new
        {
         * @link  Wrapper} again and try to pack {
         * @link  allocatedInstanceArray instances} again, too. </p>

        <p> Repeats those steps until all {
         * @link  alloctedInstanceArray instances} are {
         * @link  Wrap packed}
        so that there's not any {
         * @link  Instance instance} left. </p>

        <h4> Warning </h4>
        <p> When call this {
         * @link  optimize optimize()} method, ordinary children {
         * @link  Wrapper} objects
        in the {
         * @link  WrapperGroup} will be substituted with the newly optimized {
         * @link  Wrapper} objects. </p>
        */
        optimize(): void;

        /**
         * 
         * @inheritdoc  
         */
        TAG(): string
    }
    declare class Editor<T>mixins React.Component<{
        dataProvider: undefined.EntityArrayCollection<T >
    }, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        createColumns(): AdazzleReactDataGrid.Column[];
        render(): JSX.Element
    }
    declare type ItemEditorProps = {
        application: PackerApplication,
        instances: InstanceFormArray,
        wrappers: WrapperArray
    }
    declare class ItemEditor mixins React.Component<ItemEditorProps, {}>{
        render(): JSX.Element
    }
    declare class InstanceEditor mixins Editor<InstanceForm>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class WrapperEditor mixins Editor<Wrapper>{
        createColumns(): AdazzleReactDataGrid.Column[]
    }
    declare class PackerApplication mixins React.Component<{}, {}>{

        /**
         * Default Constructor.
         */
        constructor(): this;
        pack(): void;
        drawWrapper(wrapper: Wrapper, index?: number): void;
        render(): JSX.Element;
        main(): void
    }
    declare class ResultViewer mixins React.Component<WrapperViewerProps, {}>{
        drawWrapper(wrapper: Wrapper, index?: number): void;
        refresh(): void;
        render(): JSX.Element
    }
    declare type WrapperViewerProps = {
        application: PackerApplication,
        wrappers: WrapperArray
    }
}
declare class TabNavigator mixins React.Component<flex$TabNavigatorProps, flex$TabNavigatorProps>{
    render(): JSX.Element
}

declare class NavigatorContent mixins React.Component<flex$NavigatorContentProps, flex$NavigatorContentProps>{
    render(): JSX.Element
}

declare type flex$TabNavigatorProps = {
    selectedIndex?: number,
    style?: React.CSSProperties
}

declare type flex$NavigatorContentProps = {
    label: string
}
declare module 'MD5' {
    declare     var VERSION: string;
    declare     var BY_ASCII: number;
    declare     var BY_UTF16: number;
    declare     function calc(str: string, option?: number): string
}

/**
 * 
 * @summary  Interface for "saveAs" function.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface FileSaver {
    (data: Blob, filename: string, disableAutoBOM?: boolean): void
}
declare var saveAs: FileSaver;
declare module 'file-saver' {
    declare     var fileSaver: {
        saveAs: typeof saveAs
    };
    declare module.exports: typeof fileSaver
}
declare interface FinchCallback {
    (bindings?: any, childCallback?: () => void): any
}
declare interface ExpandedCallback {
    setup?: FinchCallback,
        load?: FinchCallback,
        unload?: FinchCallback,
        teardown?: FinchCallback
}
declare interface ObserveCallback {
    (...args: any[]): string
}
declare interface FinchOptions {
    CoerceParameterTypes?: boolean
}
declare interface FinchStatic {
    route(route: string, callback: FinchCallback): void,
        route(route: string, callbacks: ExpandedCallback): void,
        call(uri: string): void,
        observe(argN: string[], callback: (params: ObserveCallback) => void): void,
        observe(callback: (params: ObserveCallback) => void): void,
        observe(...args: any[]): void,
        navigate(uri: string, queryParams?: any, doUpdate?: boolean): void,
        navigate(uri: string, doUpdate: boolean): void,
        navigate(queryParams: any, doUpdate?: boolean): void,
        listen(): boolean,
        ignore(): boolean,
        abort(): void,
        options(options: FinchOptions): void
}
declare var Finch: FinchStatic;
declare module 'finch' {
    declare module.exports: typeof Finch
}
declare interface HeadroomOptions {
    offset?: number,
        tolerance?: any,
        classes?: {
            initial?: string,
            notBottom?: string,
            notTop?: string,
            pinned?: string,
            top?: string,
            unpinned?: string
        },
        scroller?: Element,
        onPin?: () => void,
        onUnPin?: () => void,
        onTop?: () => void,
        onNotTop?: () => void
}
declare class Headroom {
    constructor(element: CSG$Node, options?: HeadroomOptions): this;
    constructor(element: Element, options?: HeadroomOptions): this;
    init: () => void
}
declare interface HubSpotPaceInterfaces$PaceOptions {

    /**
     * How long should it take for the bar to animate to a new point after receiving it
     */
    catchupTime?: number,

        /**
         * How quickly should the bar be moving before it has any progress info from a new source in %/ms
         */
        initialRate?: number,

        /**
         * What is the minimum amount of time the bar should be on the screen. Irrespective of this number, the bar will always be on screen for 33  (100 / maxProgressPerFrame) + ghostTime ms.
         */
        minTime?: number,

        /**
         * What is the minimum amount of time the bar should sit after the last update before disappearing
         */
        ghostTime?: number,

        /**
         * Its easy for a bunch of the bar to be eaten in the first few frames before we know how much there is to load. This limits how much of the bar can be used per frame
         */
        maxProgressPerFrame?: number,

        /**
         * This tweaks the animation easing
         */
        easeFactor?: number,

        /**
         * Should pace automatically start when the page is loaded, or should it wait for `start` to be called? Always false if pace is loaded with AMD or CommonJS.
         */
        startOnPageLoad?: boolean,

        /**
         * Should we restart the browser when pushState or replaceState is called?  (Generally means ajax navigation has occured)
         */
        restartOnPushState?: boolean,

        /**
         * Should we show the progress bar for every ajax request (not just regular or ajax-y page navigation)? Set to false to disable. If so, how many ms does the request have to be running for before we show the progress?
         */
        restartOnRequestAfter?: boolean | number,

        /**
         * What element should the pace element be appended to on the page?
         */
        target?: string,
        document?: boolean | string,
        elements?: boolean | HubSpotPaceInterfaces$PaceElementsOptions,
        eventLag?: boolean | HubSpotPaceInterfaces$PaceEventLagOptions,
        ajax?: boolean | HubSpotPaceInterfaces$PaceAjaxOptions
}

declare interface HubSpotPaceInterfaces$PaceElementsOptions {

    /**
     * How frequently in ms should we check for the elements being tested for using the element monitor?
     */
    checkInterval?: number,

        /**
         * What elements should we wait for before deciding the page is fully loaded (not required)
         */
        selectors?: string[]
}

declare interface HubSpotPaceInterfaces$PaceEventLagOptions {

    /**
     * When we first start measuring event lag, not much is going on in the browser yet, so it's not uncommon for the numbers to be abnormally low for the first few samples. This configures how many samples we need before we consider a low number to mean completion.
     */
    minSamples?: number,

        /**
         * How many samples should we average to decide what the current lag is?
         */
        sampleCount?: number,

        /**
         * Above how many ms of lag is the CPU considered busy?
         */
        lagThreshold?: number
}

declare interface HubSpotPaceInterfaces$PaceAjaxOptions {

    /**
     * Which HTTP methods should we track?
     */
    trackMethods?: string[],

        /**
         * Should we track web socket connections?
         */
        trackWebSockets?: boolean,

        /**
         * A list of regular expressions or substrings of URLS we should ignore (for both tracking and restarting)
         */
        ignoreURLs?: (string | RegExp)[]
}

declare interface HubSpotPaceInterfaces$Pace {
    options: HubSpotPaceInterfaces$PaceOptions,
        start(options?: HubSpotPaceInterfaces$PaceOptions): void,
        restart(): void,
        stop(): void,
        track(fn: () => void, ...args: any[]): void,
        ignore(fn: () => void, ...args: any[]): void,
        on(event: string, handler: (...args: any[]) => void, context?: any): void,
        off(event: string, handler?: (...args: any[]) => void): void,
        once(event: string, handler: (...args: any[]) => void, context?: any): void
}
declare var pace: HubSpotPaceInterfaces$Pace;
declare module 'HubSpot-pace' {
    declare module.exports: typeof pace
}
declare module 'JSONStream' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export function parse(pattern: any): NodeJS$ReadWriteStream
    declare     export function stringify(): NodeJS$ReadWriteStream
    declare     export function stringifyObject(): NodeJS$ReadWriteStream
}

declare var npm$namespace$THREE: {
    OrbitControls: typeof THREE$OrbitControls,
    SpriteCanvasMaterial: typeof THREE$SpriteCanvasMaterial,
    RenderableObject: typeof THREE$RenderableObject,
    RenderableFace: typeof THREE$RenderableFace,
    RenderableVertex: typeof THREE$RenderableVertex,
    RenderableLine: typeof THREE$RenderableLine,
    RenderableSprite: typeof THREE$RenderableSprite,
    Projector: typeof THREE$Projector,
}
declare var CSG: {
    fromCSG: (
        csg: CSG,
        defaultColor: any) => {
        colorMesh: Mesh,
        wireframe: Mesh,
        boundLen: number
    },
    getGeometryVertex: (geometry: any, vertex_position: any) => number
};

declare function THREE$OrbitControls(object: any, domElement: any): void

declare function THREE$SpriteCanvasMaterial(parameters?: any): void

declare interface THREE$ICanvasRendererOptions {
    canvas?: HTMLCanvasElement,
        alpha?: boolean
}

declare class CanvasRenderer mixins Renderer {
    domElement: HTMLCanvasElement;
    constructor(parameters: THREE$ICanvasRendererOptions): this;
    supportsVertexTextures(): void;
    setFaceCulling: () => void;
    getPixelRatio(): number;
    setPixelRatio(value: any): void;
    setSize(width: any, height: any, updateStyle: any): void;
    setViewport(x: any, y: any, width: any, height: any): void;
    setScissor(): void;
    enableScissorTest(): void;
    setClearColor(color: any, alpha: any): void;
    setClearColorHex(hex: any, alpha: any): void;
    getClearColor(): Color;
    getClearAlpha(): number;
    getMaxAnisotropy(): number;
    clear(): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    render(
        scene: Scene,
        camera: Camera,
        renderTarget?: RenderTarget,
        forceClear?: boolean): void;
    calculateLights(): void;
    calculateLight(position: any, normal: any, color: any): void;
    renderSprite(v1: any, element: any, material: any): void;
    renderLine(v1: any, v2: any, element: any, material: any): void;
    renderFace3(
        v1: any,
        v2: any,
        v3: any,
        uv1: any,
        uv2: any,
        uv3: any,
        element: any,
        material: any): void;
    drawTriangle(x0: any, y0: any, x1: any, y1: any, x2: any, y2: any): void;
    strokePath(color: any, linewidth: any, linecap: any, linejoin: any): void;
    fillPath(color: any): void;
    onTextureUpdate(event: any): void;
    textureToPattern(texture: any): void;
    patternPath(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        texture: any): void;
    clipImage(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        image: any): void;
    expand(v1: any, v2: any, pixels: any): void;
    setOpacity(value: any): void;
    setBlending(value: any): void;
    setLineWidth(value: any): void;
    setLineCap(value: any): void;
    setLineJoin(value: any): void;
    setStrokeStyle(value: any): void;
    setFillStyle(value: any): void;
    setLineDash(value: any): void
}

declare function THREE$RenderableObject(): void

declare function THREE$RenderableFace(): void

declare function THREE$RenderableVertex(): void

declare function THREE$RenderableLine(): void

declare function THREE$RenderableSprite(): void

declare function THREE$Projector(): void
declare var npm$namespace$OpenJsCad: {
    makeAbsoluteUrl: typeof OpenJsCad$makeAbsoluteUrl,
    isChrome: typeof OpenJsCad$isChrome,
    runMainInWorker: typeof OpenJsCad$runMainInWorker,
    expandResultObjectArray: typeof OpenJsCad$expandResultObjectArray,
    checkResult: typeof OpenJsCad$checkResult,
    resultToCompactBinary: typeof OpenJsCad$resultToCompactBinary,
    resultFromCompactBinary: typeof OpenJsCad$resultFromCompactBinary,
    parseJsCadScriptSync: typeof OpenJsCad$parseJsCadScriptSync,
    parseJsCadScriptASync: typeof OpenJsCad$parseJsCadScriptASync,
    getWindowURL: typeof OpenJsCad$getWindowURL,
    textToBlobUrl: typeof OpenJsCad$textToBlobUrl,
    revokeBlobUrl: typeof OpenJsCad$revokeBlobUrl,
    FileSystemApiErrorHandler: typeof OpenJsCad$FileSystemApiErrorHandler,
    AlertUserOfUncaughtExceptions: typeof OpenJsCad$AlertUserOfUncaughtExceptions,
    getParamDefinitions: typeof OpenJsCad$getParamDefinitions,
}
declare interface OpenJsCad$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare var log: OpenJsCad$ILog;

declare interface OpenJsCad$IViewerOptions {
    drawLines?: boolean,
        drawFaces?: boolean,
        color?: number[],
        bgColor?: number,
        noWebGL?: boolean
}

declare type OpenJsCad$ProcessorOptions = {
    verbose?: boolean,
    viewerwidth?: number,
    viewerheight?: number,
    viewerheightratio?: number
} & OpenJsCad$IViewerOptions


declare class Viewer {
    constructor(containerElm: any, size: any, options: OpenJsCad$IViewerOptions): this;
    createScene(drawAxes: any, axLen: any): void;
    createCamera(): void;
    createControls(canvas: any): void;
    webGLAvailable(): boolean;
    createRenderer(bool_noWebGL: any): void;
    render(): void;
    animate(): void;
    cancelAnimate(): void;
    refreshRenderer(bool_noWebGL: any): void;
    drawAxes(axLen: any): void;
    setCsg(csg: any, resetZoom: any): void;
    applyDrawOptions(): void;
    clear(): void;
    getUserMeshes(str?: any): THREE$Object3D[];
    resetZoom(r: any): void;
    parseSizeParams(): void;
    handleResize(): void
}

declare function OpenJsCad$makeAbsoluteUrl(url: any, baseurl: any): any

declare function OpenJsCad$isChrome(): boolean

declare function OpenJsCad$runMainInWorker(mainParameters: any): void

declare function OpenJsCad$expandResultObjectArray(result: any): any

declare function OpenJsCad$checkResult(result: any): void

declare function OpenJsCad$resultToCompactBinary(resultin: any): any

declare function OpenJsCad$resultFromCompactBinary(resultin: any): any

declare function OpenJsCad$parseJsCadScriptSync(script: any, mainParameters: any, debugging: any): any

declare function OpenJsCad$parseJsCadScriptASync(script: any, mainParameters: any, options: any, callback: any): Worker

declare function OpenJsCad$getWindowURL(): URL

declare function OpenJsCad$textToBlobUrl(txt: any): string

declare function OpenJsCad$revokeBlobUrl(url: any): void

declare function OpenJsCad$FileSystemApiErrorHandler(fileError: any, operation: any): void

declare function OpenJsCad$AlertUserOfUncaughtExceptions(): void

declare function OpenJsCad$getParamDefinitions(script: any): any[]

declare interface OpenJsCad$EventHandler {
    (ev?: Event): any
}


/**
 * options parameter:
 * - drawLines: display wireframe lines
- drawFaces: display surfaces
- bgColor: canvas background color
- color: object color
- viewerwidth, viewerheight: set rendering size. Works with any css unit.
     viewerheight can also be specified as a ratio to width, ie number e (0, 1]
- noWebGL: force render without webGL
- verbose: show additional info (currently only time used for rendering)
*/
declare interface OpenJsCad$ViewerSize {
    widthDefault: string,
        heightDefault: string,
        width: number,
        height: number,
        heightratio: number
}

declare class Processor {
    constructor(containerdiv: HTMLDivElement, options?: OpenJsCad$ProcessorOptions, onchange?: OpenJsCad$EventHandler): this;
    convertToSolid(obj: any): any;
    cleanOption(option: any, deflt: any): any;
    toggleDrawOption(str: any): boolean;
    setDrawOption(str: any, bool: any): void;
    handleResize(): void;
    createElements(): void;
    getFilenameForRenderedObject(): string;
    setRenderedObjects(obj: any): void;
    setSelectedObjectIndex(index: number): void;
    selectedFormat(): any;
    selectedFormatInfo(): any;
    updateDownloadLink(): void;
    clearViewer(): void;
    abort(): void;
    enableItems(): void;
    setOpenJsCadPath(path: string): void;
    addLibrary(lib: any): void;
    setError(txt: string): void;
    setDebugging(debugging: boolean): void;
    setJsCad(script: string, filename?: string): void;
    getParamValues(): {};
    rebuildSolid(): void;
    hasSolid(): boolean;
    isProcessing(): boolean;
    clearOutputFile(): void;
    generateOutputFile(): void;
    currentObjectToBlob(): any;
    supportedFormatsForCurrentObject(): string[];
    formatInfo(format: any): any;
    downloadLinkTextForCurrentObject(): string;
    generateOutputFileBlobUrl(): void;
    generateOutputFileFileSystem(): void;
    createParamControls(): void
}
declare interface Window {
    Worker: Worker,
        webkitURL: URL,
        requestFileSystem: any,
        webkitRequestFileSystem: any
}
declare interface IAMFStringOptions {
    unit: string
}
declare class CxG {
    toStlString(): string;
    toStlBinary(): void;
    toAMFString(AMFStringOptions?: IAMFStringOptions): void;
    getBounds(): CxG[];
    transform(matrix4x4: CSG$Matrix4x4): CxG;
    mirrored(plane: CSG$Plane): CxG;
    mirroredX(): CxG;
    mirroredY(): CxG;
    mirroredZ(): CxG;
    translate(v: number[]): CxG;
    translate(v: CSG$Vector3D): CxG;
    scale(f: CSG$Vector3D): CxG;
    rotateX(deg: number): CxG;
    rotateY(deg: number): CxG;
    rotateZ(deg: number): CxG;
    rotate(rotationCenter: CSG$Vector3D, rotationAxis: CSG$Vector3D, degrees: number): CxG;
    rotateEulerAngles(alpha: number, beta: number, gamma: number, position: number[]): CxG
}
declare interface ICenter {
    center(cAxes: string[]): CxG
}
declare class CSG mixins CxG, ICenter {
    polygons: CSG$Polygon[];
    properties: CSG$Properties;
    isCanonicalized: boolean;
    isRetesselated: boolean;
    cachedBoundingBox: CSG$Vector3D[];
    defaultResolution2D: number;
    defaultResolution3D: number;
    fromPolygons(polygons: CSG$Polygon[]): CSG;
    fromSlices(options: any): CSG;
    fromObject(obj: any): CSG;
    fromCompactBinary(bin: any): CSG;
    toPolygons(): CSG$Polygon[];
    union(csg: CSG[]): CSG;
    union(csg: CSG): CSG;
    unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    unionForNonIntersecting(csg: CSG): CSG;
    subtract(csg: CSG[]): CSG;
    subtract(csg: CSG): CSG;
    subtractSub(csg: CSG, retesselate: boolean, canonicalize: boolean): CSG;
    intersect(csg: CSG[]): CSG;
    intersect(csg: CSG): CSG;
    intersectSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    invert(): CSG;
    transform1(matrix4x4: CSG$Matrix4x4): CSG;
    transform(matrix4x4: CSG$Matrix4x4): CSG;
    toString(): string;
    expand(radius: number, resolution: number): CSG;
    contract(radius: number, resolution: number): CSG;
    stretchAtPlane(normal: number[], point: number[], length: number): CSG;
    expandedShell(radius: number, resolution: number, unionWithThis: boolean): CSG;
    canonicalized(): CSG;
    reTesselated(): CSG;
    getBounds(): CSG$Vector3D[];
    mayOverlap(csg: CSG): boolean;
    cutByPlane(plane: CSG$Plane): CSG;
    connectTo(
        myConnector: CSG$Connector,
        otherConnector: CSG$Connector,
        mirror: boolean,
        normalrotation: number): CSG;
    setShared(shared: undefined.Shared): CSG;
    setColor(args: any): CSG;
    toCompactBinary(): {
        class: string,
        numPolygons: number,
        numVerticesPerPolygon: Uint32Array,
        polygonPlaneIndexes: Uint32Array,
        polygonSharedIndexes: Uint32Array,
        polygonVertices: Uint32Array,
        vertexData: Float64Array,
        planeData: Float64Array,
        shared: undefined.Shared[]
    };
    toPointCloud(cuberadius: any): CSG;
    getTransformationAndInverseTransformationToFlatLying(): any;
    getTransformationToFlatLying(): any;
    lieFlat(): CSG;
    projectToOrthoNormalBasis(orthobasis: CSG$OrthoNormalBasis): CAG;
    sectionCut(orthobasis: CSG$OrthoNormalBasis): CAG;
    fixTJunctions(): CSG;
    toTriangles(): any[];
    getFeatures(features: any): any;
    center(cAxes: string[]): CxG;
    toX3D(): Blob;
    toStlBinary(): Blob;
    toStlString(): string;
    toAMFString(m: IAMFStringOptions): Blob
}
declare class Polygon2D mixins CAG {
    constructor(points: CSG$Vector2D[]): this
}
declare class CAG mixins CxG, ICenter {
    sides: CAG$Side[];
    isCanonicalized: boolean;
    constructor(): this;
    fromSides(sides: CAG$Side[]): CAG;
    fromPoints(points: CSG$Vector2D[]): CAG;
    fromPointsNoCheck(points: CSG$Vector2D[]): CAG;
    fromFakeCSG(csg: CSG): CAG;
    linesIntersect(
        p0start: CSG$Vector2D,
        p0end: CSG$Vector2D,
        p1start: CSG$Vector2D,
        p1end: CSG$Vector2D): boolean;
    circle(options: CSG$ICircleOptions): CAG;
    rectangle(options: CSG$IRectangleOptions): CAG;
    roundedRectangle(options: any): CAG;
    fromCompactBinary(bin: any): CAG;
    toString(): string;
    _toCSGWall(z0: any, z1: any): CSG;
    _toVector3DPairs(m: CSG$Matrix4x4): CSG$Vector3D[][];
    _toPlanePolygons(options: any): CSG$Polygon[];
    _toWallPolygons(options: any): any[];
    union(cag: CAG[]): CAG;
    union(cag: CAG): CAG;
    subtract(cag: CAG[]): CAG;
    subtract(cag: CAG): CAG;
    intersect(cag: CAG[]): CAG;
    intersect(cag: CAG): CAG;
    transform(matrix4x4: CSG$Matrix4x4): CAG;
    area(): number;
    flipped(): CAG;
    getBounds(): CSG$Vector2D[];
    isSelfIntersecting(): boolean;
    expandedShell(radius: number, resolution: number): CAG;
    expand(radius: number, resolution: number): CAG;
    contract(radius: number, resolution: number): CAG;
    extrudeInOrthonormalBasis(orthonormalbasis: CSG$OrthoNormalBasis, depth: number, options?: any): CSG;
    extrudeInPlane(axis1: any, axis2: any, depth: any, options: any): CSG;
    extrude(options: CAG_extrude_options): CSG;
    rotateExtrude(options: any): CSG;
    check(): void;
    canonicalized(): CAG;
    toCompactBinary(): {
        class: string,
        sideVertexIndices: Uint32Array,
        vertexData: Float64Array
    };
    getOutlinePaths(): CSG$Path2D[];
    overCutInsideCorners(cutterradius: any): CAG;
    center(cAxes: string[]): CxG;
    toDxf(): Blob;
    PathsToDxf(paths: CSG$Path2D[]): Blob
}
declare class Vertex {
    pos: CSG$Vector2D;
    tag: number;
    constructor(pos: CSG$Vector2D): this;
    toString(): string;
    getTag(): number
}

declare class Side mixins CxG {
    vertex0: CAG$Vertex;
    vertex1: CAG$Vertex;
    tag: number;
    constructor(vertex0: CAG$Vertex, vertex1: CAG$Vertex): this;
    _fromFakePolygon(polygon: CSG$Polygon): CAG$Side;
    toString(): string;
    toPolygon3D(z0: any, z1: any): CSG$Polygon;
    transform(matrix4x4: CSG$Matrix4x4): CAG$Side;
    flipped(): CAG$Side;
    direction(): CSG$Vector2D;
    getTag(): number;
    lengthSquared(): number;
    length(): number
}

declare class fuzzyCAGFactory {
    vertexfactory: CSG$fuzzyFactory;
    constructor(): this;
    getVertex(sourcevertex: CAG$Vertex): CAG$Vertex;
    getSide(sourceside: CAG$Side): CAG$Side;
    getCAG(sourcecag: CAG): CAG
}
declare interface CAG_extrude_options {
    offset?: number[],
        twistangle?: number,
        twiststeps?: number
}
/**
 * The PayPalItem class defines an optional itemization for a payment.
 * @see  https://developer.paypal.com/docs/api/#item-object for more details.
 */
declare class PayPalItem {

    /**
     * 
     * @param name Name of the item. 127 characters max.
     * @param quantity Number of units. 10 characters max.
     * @param price Unit price for this item 10 characters max.
    May be negative for "coupon" etc.
     * @param currency ISO standard currency code.
     * @param sku The stock keeping unit for this item. 50 characters max (optional).
    */
    constructor(name: string, quantity: number, price: string, currency: string, sku?: string): this;

    /**
     * Name of the item. 127 characters max.
     */
    name: string;

    /**
     * Number of units. 10 characters max.
     */
    quantity: number;

    /**
     * Unit price for this item 10 characters max.
     * May be negative for "coupon" etc.
     */
    price: string;

    /**
     * ISO standard currency code.
     */
    currency: string;

    /**
     * The stock keeping unit for this item. 50 characters max (optional).
     */
    sku: string
}
/**
 * The PayPalPaymentDetails class defines optional amount details.
 * @see  https://developer.paypal.com/webapps/developer/docs/api/#details-object for more details.
 */
declare class PayPalPaymentDetails {

    /**
     * 
     * @param subtotal Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     * @param shipping Amount charged for shipping. 10 characters max with support for 2 decimal places.
     * @param tax Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    constructor(subtotal: string, shipping: string, tax: string): this;

    /**
     * Sub-total (amount) of items being paid for. 10 characters max with support for 2 decimal places.
     */
    subtotal: string;

    /**
     * Amount charged for shipping. 10 characters max with support for 2 decimal places.
     */
    shipping: string;

    /**
     * Amount charged for tax. 10 characters max with support for 2 decimal places.
     */
    tax: string
}
/**
 * Convenience constructor. Returns a PayPalPayment with the specified amount, currency code, and short description.
 */
declare class PayPalPayment {

    /**
     * 
     * @param amount The amount of the payment.
     * @param currencyCode The ISO 4217 currency for the payment.
     * @param shortDescription A short descripton of the payment.
     * @param intent "Sale" for an immediate payment.
    "Auth" for payment authorization only, to be captured separately at a later time.
     "Order" for taking an order, with authorization and capture to be done separately at a later time.
     * @param details PayPalPaymentDetails object (optional).
    */
    constructor(amount: string, currency: string, shortDescription: string, intent: string, details?: PayPalPaymentDetails): this;

    /**
     * The amount of the payment.
     */
    amount: string;

    /**
     * The ISO 4217 currency for the payment.
     */
    currency: string;

    /**
     * A short descripton of the payment.
     */
    shortDescription: string;

    /**
     *  "Sale" for an immediate payment.
     * "Auth" for payment authorization only, to be captured separately at a later time.
    "Order" for taking an order, with authorization and capture to be done separately at a later time.
    */
    intent: string;

    /**
     * PayPalPaymentDetails object (optional).
     */
    details: PayPalPaymentDetails;

    /**
     * Optional invoice number, for your tracking purposes. (up to 256 characters).
     */
    invoiceNumber: string;

    /**
     * Optional text, for your tracking purposes. (up to 256 characters).
     */
    custom: string;

    /**
     * Optional text which will appear on the customer's credit card statement. (up to 22 characters).
     */
    softDescriptor: string;

    /**
     * Optional Build Notation code ("BN code"), obtained from partnerprogram@paypal.com, for your tracking purposes.
     */
    bnCode: string;

    /**
     * Optional array of PayPalItem objects.
     * @see  PayPalItem
     * @note  If you provide one or more items, be sure that the various prices correctly sum to the payment `amount` or to `paymentDetails.subtotal`.
     */
    items: PayPalItem[];

    /**
     * Optional customer shipping address, if your app wishes to provide this to the SDK.
     * @note  make sure to set `payPalShippingAddressOption` in PayPalConfiguration to 1 or 3.
     */
    shippingAddress: PayPalShippingAddress
}
declare class PayPalShippingAddress {

    /**
     * 
     * @param recipientName Name of the recipient at this address. 50 characters max.
     * @param line1 Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     * @param line2 Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     * @param city City name. 50 characters max.
     * @param state 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     * @param postalCode ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     * @param countryCode 2-letter country code. 2 characters max.
     */
    constructor(recipientName: string, line1: string, line2: string, city: string, state: string, postalCode: string, countryCode: string): this;

    /**
     * Name of the recipient at this address. 50 characters max.
     */
    recipientName: string;

    /**
     * Line 1 of the address (e.g., Number, street, etc). 100 characters max.
     */
    line1: string;

    /**
     * Line 2 of the address (e.g., Suite, apt #, etc). 100 characters max. Optional.
     */
    line2: string;

    /**
     * City name. 50 characters max.
     */
    city: string;

    /**
     * 2-letter code for US states, and the equivalent for other countries. 100 characters max. Required in certain countries.
     */
    state: string;

    /**
     * ZIP code or equivalent is usually required for countries that have them. 20 characters max. Required in certain countries.
     */
    postalCode: string;

    /**
     * 2-letter country code. 2 characters max.
     */
    countryCode: string
}
declare class PayPalConfiguration {

    /**
     * 
     * @param options A set of options to use. Any options not specified will assume default values.
     */
    constructor(options?: PayPalConfigurationOptions): this;

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail: string;

    /**
     * Will be overridden by phone country code used in most recent PayPal login
     */
    defaultUserPhoneCountryCode: string;

    /**
     * Will be overridden by phone number used in most recent PayPal login.
     * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
     */
    defaultUserPhoneNumber: string;

    /**
     * Your company name, as it should be displayed to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantName: string;

    /**
     * URL of your company's privacy policy, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantPrivacyPolicyURL: string;

    /**
     * URL of your company's user agreement, which will be offered to the user
     * when requesting consent via a PayPalFuturePaymentViewController.
     */
    merchantUserAgreementURL: string;

    /**
     * If set to false, the SDK will only support paying with PayPal, not with credit cards.
     * This applies only to single payments (via PayPalPaymentViewController).
    Future payments (via PayPalFuturePaymentViewController) always use PayPal.
    Defaults to true.
    */
    acceptCreditCards: boolean;

    /**
     * For single payments, options for the shipping address.
     * 
    - 0 - PayPalShippingAddressOptionNone: no shipping address applies.

    - 1 - PayPalShippingAddressOptionProvided: shipping address will be provided by your app,
       in the shippingAddress property of PayPalPayment.

    - 2 - PayPalShippingAddressOptionPayPal: user will choose from shipping addresses on file
       for their PayPal account.

    - 3 - PayPalShippingAddressOptionBoth: user will choose from the shipping address provided by your app,
       in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

    Defaults to 0 (PayPalShippingAddressOptionNone).
    */
    payPalShippingAddressOption: number;

    /**
     * If set to true, then if the user pays via their PayPal account,
     * the SDK will remember the user's PayPal username or phone number;
    if the user pays via their credit card, then the SDK will remember
    the PayPal Vault token representing the user's credit card.

    If set to false, then any previously-remembered username, phone number, or
    credit card token will be erased, and subsequent payment information will
    not be remembered.

    Defaults to true.
    */
    rememberUser: boolean;

    /**
     * If not set, or if set to nil, defaults to the device's current language setting.
     * 
    Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
    If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
    If the library does not contain localized strings for a specified language, then will fall back to American English.

    If you specify only a language code, and that code matches the device's currently preferred language,
    then the library will attempt to use the device's current region as well.
    E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

    These localizations are currently included:
    da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
    */
    languageOrLocale: string;

    /**
     * Normally, the SDK blurs the screen when the app is backgrounded,
     * to obscure credit card or PayPal account details in the iOS-saved screenshot.
    If your app already does its own blurring upon backgrounding, you might choose to disable this.
    Defaults to false.
    */
    disableBlurWhenBackgrounding: boolean;

    /**
     * If you will present the SDK's view controller within a popover, then set this property to true.
     * Defaults to false. (iOS only)
     */
    presentingInPopover: boolean;

    /**
     * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
     * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

    This setting will have no effect if the operation mode is production.
    Defaults to false.
    */
    forceDefaultsInSandbox: boolean;

    /**
     * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPassword: string;

    /**
     * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
     */
    sandboxUserPin: string
}
/**
 * Describes the options that can be passed into the PayPalConfiguration class constructor.
 */
declare interface PayPalConfigurationOptions {

    /**
     * Will be overridden by email used in most recent PayPal login.
     */
    defaultUserEmail?: string,

        /**
         * Will be overridden by phone country code used in most recent PayPal login
         */
        defaultUserPhoneCountryCode?: string,

        /**
         * Will be overridden by phone number used in most recent PayPal login.
         * @note  If you set defaultUserPhoneNumber, be sure to also set defaultUserPhoneCountryCode.
         */
        defaultUserPhoneNumber?: string,

        /**
         * Your company name, as it should be displayed to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantName?: string,

        /**
         * URL of your company's privacy policy, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantPrivacyPolicyURL?: string,

        /**
         * URL of your company's user agreement, which will be offered to the user
         * when requesting consent via a PayPalFuturePaymentViewController.
         */
        merchantUserAgreementURL?: string,

        /**
         * If set to false, the SDK will only support paying with PayPal, not with credit cards.
         * This applies only to single payments (via PayPalPaymentViewController).
        Future payments (via PayPalFuturePaymentViewController) always use PayPal.
        Defaults to true.
        */
        acceptCreditCards?: boolean,

        /**
         * For single payments, options for the shipping address.
         * 
        - 0 - PayPalShippingAddressOptionNone?: no shipping address applies.

        - 1 - PayPalShippingAddressOptionProvided?: shipping address will be provided by your app,
           in the shippingAddress property of PayPalPayment.

        - 2 - PayPalShippingAddressOptionPayPal?: user will choose from shipping addresses on file
           for their PayPal account.

        - 3 - PayPalShippingAddressOptionBoth?: user will choose from the shipping address provided by your app,
           in the shippingAddress property of PayPalPayment, plus the shipping addresses on file for the user's PayPal account.

        Defaults to 0 (PayPalShippingAddressOptionNone).
        */
        payPalShippingAddressOption?: number,

        /**
         * If set to true, then if the user pays via their PayPal account,
         * the SDK will remember the user's PayPal username or phone number;
        if the user pays via their credit card, then the SDK will remember
        the PayPal Vault token representing the user's credit card.

        If set to false, then any previously-remembered username, phone number, or
        credit card token will be erased, and subsequent payment information will
        not be remembered.

        Defaults to true.
        */
        rememberUser?: boolean,

        /**
         * If not set, or if set to nil, defaults to the device's current language setting.
         * 
        Can be specified as a language code ("en", "fr", "zh-Hans", etc.) or as a locale ("en_AU", "fr_FR", "zh-Hant_HK", etc.).
        If the library does not contain localized strings for a specified locale, then will fall back to the language. E.g., "es_CO" -> "es".
        If the library does not contain localized strings for a specified language, then will fall back to American English.

        If you specify only a language code, and that code matches the device's currently preferred language,
        then the library will attempt to use the device's current region as well.
        E.g., specifying "en" on a device set to "English" and "United Kingdom" will result in "en_GB".

        These localizations are currently included:
        da,de,en,en_AU,en_GB,en_SV,es,es_MX,fr,he,it,ja,ko,nb,nl,pl,pt,pt_BR,ru,sv,tr,zh-Hans,zh-Hant_HK,zh-Hant_TW.
        */
        languageOrLocale?: string,

        /**
         * Normally, the SDK blurs the screen when the app is backgrounded,
         * to obscure credit card or PayPal account details in the iOS-saved screenshot.
        If your app already does its own blurring upon backgrounding, you might choose to disable this.
        Defaults to false.
        */
        disableBlurWhenBackgrounding?: boolean,

        /**
         * If you will present the SDK's view controller within a popover, then set this property to true.
         * Defaults to false. (iOS only)
         */
        presentingInPopover?: boolean,

        /**
         * Sandbox credentials can be difficult to type on a mobile device. Setting this flag to true will
         * cause the sandboxUserPassword and sandboxUserPin to always be pre-populated into login fields.

        This setting will have no effect if the operation mode is production.
        Defaults to false.
        */
        forceDefaultsInSandbox?: boolean,

        /**
         * Password to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPassword?: string,

        /**
         * PIN to use for sandbox if 'forceDefaultsInSandbox' is set.
         */
        sandboxUserPin?: string
}
declare export interface PayPalCordovaPlugin$PayPalClientIds {
    PayPalEnvironmentProduction: string,
        PayPalEnvironmentSandbox: string
}


/**
 * Represents the portion of an object that is common to all responses.
 */
declare export interface PayPalCordovaPlugin$BaseResult {
    client: PayPalCordovaPlugin$Client,
        response_type: string
}


/**
 * Represents the client portion of the response.
 */
declare export interface PayPalCordovaPlugin$Client {
    paypal_sdk_version: string,
        environment: string,
        platform: string,
        product_name: string
}


/**
 * Represents the response for a successful callback from renderSinglePaymentUI().
 */
declare export type PayPalCordovaPlugin$SinglePaymentResult = {
    response: {
        intent: string,
        id: string,
        state: string,
        authorization_id: string,
        create_time: string
    }
} & PayPalCordovaPlugin$BaseResult



/**
 * Represents the response for a successful callback from renderFuturePaymentUI().
 */
declare export type PayPalCordovaPlugin$FuturePaymentResult = {
    response: {
        code: string
    }
} & PayPalCordovaPlugin$BaseResult


declare export interface PayPalCordovaPlugin$PayPalMobileStatic {

    /**
     * Retrieve the version of the PayPal iOS SDK library. Useful when contacting support.
     * @param completionCallback a callback function accepting a string
     */
    version(completionCallback: (result: string) => void): void,

        /**
         * You MUST call this method to initialize the PayPal Mobile SDK.
         * 
        The PayPal Mobile SDK can operate in different environments to facilitate development and testing."my-client-id-for-Production",
        PayPalEnvironmentSandbox : @"my-client-id-for-Sandbox"
        }
         * @param clientIdsForEnvironments set of client ids for environments
        Example: var clientIdsForEnvironments = {
        PayPalEnvironmentProduction : 
         * @param completionCallback a callback function on success
        */
        init(
            clientIdsForEnvironments: PayPalCordovaPlugin$PayPalClientIds,
            completionCallback: () => void): void,

        /**
         * You must preconnect to PayPal to prepare the device for processing payments.
         * This improves the user experience, by making the presentation of the
        UI faster. The preconnect is valid for a limited time, so
        the recommended time to preconnect is on page load.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param configuration PayPalConfiguration object, for Future Payments merchantName, merchantPrivacyPolicyURL
        and merchantUserAgreementURL must be set be set
         * @param completionCallback a callback function on success
        */
        prepareToRender(
            environment: string,
            configuration: PayPalConfiguration,
            completionCallback: () => void): void,

        /**
         * Start PayPal UI to collect payment from the user.
         * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/ios-integration-guide/
        for more documentation of the params.
         * @param payment PayPalPayment object
         * @param completionCallback a callback function accepting a js object, called when the user has completed payment
         * @param cancelCallback a callback function accepting a reason string, called when the user cancels the payment
        */
        renderSinglePaymentUI(
            payment: PayPalPayment,
            completionCallback: (result: PayPalCordovaPlugin$SinglePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * 
         * @deprecated  * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
        from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param environment available options are "PayPalEnvironmentNoNetwork", "PayPalEnvironmentProduction" and "PayPalEnvironmentSandbox"
         * @param callback applicationCorrelationID Your server will send this to PayPal in a 'Paypal-Application-Correlation-Id' header.
        */
        applicationCorrelationIDForEnvironment(
            environment: string,
            completionCallback: (applicationCorrelationId: string) => void): void,

        /**
         * Once a user has consented to future payments, when the user subsequently initiates a PayPal payment
         * from their device to be completed by your server, PayPal uses a Correlation ID to verify that the
        payment is originating from a valid, user-consented device+application.
        This helps reduce fraud and decrease declines.
        This method MUST be called prior to initiating a pre-consented payment (a "future payment") from a mobile device.
        Pass the result to your server, to include in the payment request sent to PayPal.
        Do not otherwise cache or store this value.
         * @param callback clientMetadataID Your server will send this to PayPal in a 'PayPal-Client-Metadata-Id' header.
        */
        clientMetadataID(completionCallback: (clientMetadataId: string) => void): void,

        /**
         * Please Read Docs on Future Payments at https://github.com/paypal/PayPal-iOS-SDK#future-payments
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
         */
        renderFuturePaymentUI(
            completionCallback: (result: PayPalCordovaPlugin$FuturePaymentResult) => void,
            cancelCallback: (cancelReason: string) => void): void,

        /**
         * Please Read Docs on Profile Sharing at https://github.com/paypal/PayPal-iOS-SDK#profile-sharing
         * @param scopes scopes Set of requested scope-values. Accepted scopes are: openid, profile, address, email, phone, futurepayments and paypalattributes
        See https://developer.paypal.com/docs/integration/direct/identity/attributes/ for more details
         * @param completionCallback a callback function accepting a js object with future payment authorization
         * @param cancelCallback a callback function accepting a reason string, called when the user canceled without agreement
        */
        renderProfileSharingUI(
            scopes: string[],
            completionCallback: (result: any) => void,
            cancelCallback: (cancelReason: string) => void): void
}
declare var PayPalMobile: PayPalCordovaPlugin$PayPalMobileStatic;
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module '_debugger' {
    declare     export interface Packet {
        raw: string,
            headers: string[],
            body: Message
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
    declare     export interface RequestInfo {
        command: string,
            arguments: any
    }
    declare     export type Request = {} & Message & adal$RequestInfo

    declare     export type Event = {
        event: string,
        body?: any
    } & Message

    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare     export interface BreakpointMessageBody {
        type: string,
            target: number,
            line: number
    }
    declare     export class Protocol {
        res: Packet;
        state: string;
        execute(data: string): void;
        serialize(rq: Request): string;
        onResponse: (pkt: Packet) => void
    }
    declare     export var NO_FRAME: number;
    declare     export var port: number;
    declare     export interface ScriptDesc {
        name: string,
            id: number,
            isNative?: boolean,
            handle?: number,
            type: string,
            lineOffset?: number,
            columnOffset?: number,
            lineCount?: number
    }
    declare     export interface Breakpoint {
        id: number,
            scriptId: number,
            script: ScriptDesc,
            line: number,
            condition?: string,
            scriptReq?: string
    }
    declare     export interface RequestHandler {
        (err: boolean, body: Message, res: Packet): void,
        request_seq?: number
    }
    declare     export interface ResponseBodyHandler {
        (err: boolean, body?: any): void,
        request_seq?: number
    }
    declare     export interface ExceptionInfo {
        text: string
    }
    declare     export interface BreakResponse {
        script?: ScriptDesc,
            exception?: ExceptionInfo,
            sourceLine: number,
            sourceLineText: string,
            sourceColumn: number
    }
    declare     export function SourceInfo(body: BreakResponse): string
    declare     export type ClientInstance = {
        protocol: Protocol,
        scripts: ScriptDesc[],
        handles: ScriptDesc[],
        breakpoints: Breakpoint[],
        currentSourceLine: number,
        currentSourceColumn: number,
        currentSourceLineText: string,
        currentFrame: number,
        currentScript: string,
        connect(port: number, host: string): void,
        req(req: any, cb: RequestHandler): void,
        reqFrameEval(code: string, frame: number, cb: RequestHandler): void,
        mirrorObject(obj: any, depth: number, cb: ResponseBodyHandler): void,
        setBreakpoint(rq: BreakpointMessageBody, cb: RequestHandler): void,
        clearBreakpoint(rq: Request, cb: RequestHandler): void,
        listbreakpoints(cb: RequestHandler): void,
        reqSource(from: number, to: number, cb: RequestHandler): void,
        reqScripts(cb: any): void,
        reqContinue(cb: RequestHandler): void
    } & EventEmitter

    declare     export var Client: {
        new(): ClientInstance
    };
    declare module.exports: typeof NodeJS$_debugger
}
declare module 'abs' {
    declare module.exports: typeof Abs
}
declare module 'absolute' {
    declare module.exports: typeof absolute
}
declare interface AccWizardOptions {

    /**
     * 
     * @summary  Add next/prev buttons to panels.
     * @type  
     */
    addButtons: boolean,

        /**
         * 
         * @summary  Selector for task sidebar.
         * @type  
         */
        sidebar: string,

        /**
         * 
         * @summary  Class to indicate the active task in sidebar.
         * @type  
         */
        activeClass: string,

        /**
         * 
         * @summary  Class to indicate task is complete.
         * @type  
         */
        completedClass: string,

        /**
         * 
         * @summary  Class to indicate task is still pending.
         * @type  
         */
        todoClass: string,

        /**
         * 
         * @summary  Class for step buttons within panels.
         * @type  
         */
        stepClass: string,

        /**
         * 
         * @summary  Text for next button.
         * @type  
         */
        nextText: string,

        /**
         * 
         * @summary  Text for back button.
         * @type  
         */
        backText: string,

        /**
         * 
         * @summary  HTML input type for next button. (default: "submit")
         * @type  
         */
        nextType: string,

        /**
         * 
         * @summary  HTML input type for back button. (default: "reset")
         * @type  
         */
        backType: string,

        /**
         * 
         * @summary  Class(es) for next button.
         * @type  
         */
        nextClasses: string,

        /**
         * 
         * @summary  Class(es) for back button.
         * @type  
         */
        backClasses: string,

        /**
         * 
         * @summary  Auto-scrolling.
         * @type  
         */
        autoScrolling: boolean,

        /**
         * 
         * @summary  Function to call on next step.
         */
        onNext: Function,

        /**
         * 
         * @summary  Function to call on back up.
         */
        onBack: Function,

        /**
         * 
         * @summary  A chance to hook initialization.
         */
        onInit: Function,

        /**
         * 
         * @summary  A chance to hook destruction.
         */
        onDestroy: Function
}
/**
 * 
 * @summary  Interface for "acc-wizard" JQuery plugin.
 * @author  Cyril Schumacher
 * @version  1.0
 */
declare interface JQuery {
    accwizard(options?: AccWizardOptions): void
}
declare interface IAccountingCurrencyFormat {
    pos: string,
        neg?: string,
        zero?: string
}
declare interface IAccountingCurrencySettings<TFormat>{
    symbol?: string,
    format?: TFormat,
    decimal?: string,
    thousand?: string,
    precision?: number
}
declare interface IAccountingNumberSettings {
    precision?: number,
        thousand?: string,
        decimal?: string
}
declare interface IAccountingSettings {
    currency: IAccountingCurrencySettings<any>,
        number: IAccountingNumberSettings
}
declare interface IAccountingStatic {
    formatMoney(
            number: number,
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string,
        formatMoney(number: number, options: IAccountingCurrencySettings<string>): string,
        formatMoney(
            number: number,
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string,
        formatMoney(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatMoney(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatMoney(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatMoney(
            numbers: any[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): any[],
        formatMoney(numbers: any[], options: IAccountingCurrencySettings<string>): any[],
        formatMoney(
            numbers: any[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): any[],
        formatColumn(
            numbers: number[],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[],
        formatColumn(numbers: number[], options: IAccountingCurrencySettings<string>): string[],
        formatColumn(
            numbers: number[],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[],
        formatColumn(
            numbers: number[][],
            symbol?: string,
            precision?: number,
            thousand?: string,
            decimal?: string,
            format?: string): string[][],
        formatColumn(numbers: number[][], options: IAccountingCurrencySettings<string>): string[][],
        formatColumn(
            numbers: number[][],
            options: IAccountingCurrencySettings<IAccountingCurrencyFormat>): string[][],
        formatNumber(
            number: number,
            precision?: number,
            thousand?: string,
            decimal?: string): string,
        formatNumber(number: number, options: IAccountingNumberSettings): string,
        formatNumber(
            number: number[],
            precision?: number,
            thousand?: string,
            decimal?: string): string[],
        formatNumber(number: number[], options: IAccountingNumberSettings): string[],
        formatNumber(number: any[], precision?: number, thousand?: string, decimal?: string): any[],
        formatNumber(number: any[], options: IAccountingNumberSettings): any[],
        toFixed(number: number, precision?: number): string,
        unformat(string: string, decimal?: string): number,
        settings: IAccountingSettings
}
declare var accounting: IAccountingStatic;
declare module 'accounting' {
    declare module.exports: typeof accounting
}
declare export interface AceAjax$Delta {
    action: string,
        range: AceAjax$Range,
        text: string,
        lines: string[]
}

declare export interface AceAjax$EditorCommand {
    name: string,
        bindKey: any,
        exec: Function,
        readOnly?: boolean
}

declare export interface AceAjax$CommandManager {
    byName: any,
        commands: any,
        platform: string,
        addCommands(commands: AceAjax$EditorCommand[]): void,
        addCommand(command: AceAjax$EditorCommand): void,
        exec(name: string, editor: AceAjax$Editor, args: any): void
}

declare export interface AceAjax$Annotation {
    row: number,
        column: number,
        text: string,
        type: string
}

declare export interface AceAjax$TokenInfo {
    value: string
}

declare export interface AceAjax$Position {
    row: number,
        column: number
}

declare export interface AceAjax$KeyBinding {
    setDefaultHandler(kb: any): void,
        setKeyboardHandler(kb: any): void,
        addKeyboardHandler(kb: any, pos: any): void,
        removeKeyboardHandler(kb: any): boolean,
        getKeyboardHandler(): any,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        onTextInput(text: any): void
}

declare export interface AceAjax$TextMode {
    getTokenizer(): any,
        toggleCommentLines(state: any, doc: any, startRow: any, endRow: any): void,
        getNextLineIndent(state: any, line: any, tab: any): string,
        checkOutdent(state: any, line: any, input: any): boolean,
        autoOutdent(state: any, doc: any, row: any): void,
        createWorker(session: any): any,
        createModeDelegates(mapping: any): void,
        transformAction(state: any, action: any, editor: any, session: any, param: any): any
}


/**
 * The main class required to set up an Ace instance in the browser.
 */
declare export interface AceAjax$Ace {

    /**
     * Provides access to require in packed noconflict mode
     * @param moduleName 
     */
    require(moduleName: string): any,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: string): AceAjax$Editor,

        /**
         * Embeds the Ace editor into the DOM, at the element provided by `el`.
         * @param el Either the id of an element, or the element itself
         */
        edit(el: HTMLElement): AceAjax$Editor,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: AceAjax$Document, mode: AceAjax$TextMode): AceAjax$IEditSession,

        /**
         * Creates a new [[EditSession]], and returns the associated [[Document]].
         * @param text :textParam}
         * @param mode :modeParam}
         */
        createEditSession(text: string, mode: AceAjax$TextMode): AceAjax$IEditSession
}


/**
 * Defines the floating pointer in the document. Whenever text is inserted or deleted before the cursor, the position of the cursor is updated.
 */
declare export interface AceAjax$Anchor {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Returns an object identifying the `row` and `column` position of the current anchor.
         */
        getPosition(): AceAjax$Position,

        /**
         * Returns the current document.
         */
        getDocument(): AceAjax$Document,

        /**
         * Fires whenever the anchor position changes.
         * Both of these objects have a `row` and `column` property corresponding to the position.
        Events that can trigger this function include [[Anchor.setPosition `setPosition()`]].
         * @param e An object containing information about the anchor position. It has two properties:
        - `old`: An object describing the old Anchor position
        - `value`: An object describing the new Anchor position
        */
        onChange(e: any): void,

        /**
         * Sets the anchor position to the specified row and column. If `noClip` is `true`, the position is not clipped.
         * @param row The row index to move the anchor to
         * @param column The column index to move the anchor to
         * @param noClip Identifies if you want the position to be clipped
         */
        setPosition(row: number, column: number, noClip: boolean): void,

        /**
         * When called, the `'change'` event listener is removed.
         */
        detach(): void
}

declare var Anchor: {

    /**
     * Creates a new `Anchor` and associates it with a document.
     * @param doc The document to associate with the anchor
     * @param row The starting row position
     * @param column The starting column position
     */
    new(doc: AceAjax$Document, row: number, column: number): AceAjax$Anchor
};


/**
 * Tokenizes the current [[Document `Document`]] in the background, and caches the tokenized rows for future use.
 * If a certain row is changed, everything below that row is re-tokenized.
 */
declare export interface AceAjax$BackgroundTokenizer {
    states: any[],

        /**
         * Sets a new tokenizer for this object.
         * @param tokenizer The new tokenizer to use
         */
        setTokenizer(tokenizer: AceAjax$Tokenizer): void,

        /**
         * Sets a new document to associate with this object.
         * @param doc The new document to associate with
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Emits the `'update'` event. `firstRow` and `lastRow` are used to define the boundaries of the region to be updated.
         * @param firstRow The starting row region
         * @param lastRow The final row region
         */
        fireUpdateEvent(firstRow: number, lastRow: number): void,

        /**
         * Starts tokenizing at the row indicated.
         * @param startRow The row to start at
         */
        start(startRow: number): void,

        /**
         * Stops tokenizing.
         */
        stop(): void,

        /**
         * Gives list of tokens of the row. (tokens are cached)
         * @param row The row to get tokens at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * [Returns the state of tokenization at the end of a row.]{: #BackgroundTokenizer.getState}
         * @param row The row to get state at
         */
        getState(row: number): string
}

declare var BackgroundTokenizer: {

    /**
     * Creates a new `BackgroundTokenizer` object.
     * @param tokenizer The tokenizer to use
     * @param editor The editor to associate with
     */
    new(
        tokenizer: AceAjax$Tokenizer,
        editor: AceAjax$Editor): AceAjax$BackgroundTokenizer
};


/**
 * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s.
 * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.
 */
declare export interface AceAjax$Document {
    on(event: string, fn: (e: any) => any): void,

        /**
         * Replaces all the lines in the current `Document` with the value of `text`.
         * @param text The text to use
         */
        setValue(text: string): void,

        /**
         * Returns all the lines in the document as a single string, split by the new line character.
         */
        getValue(): string,

        /**
         * Creates a new `Anchor` to define a floating point in the document.
         * @param row The row number to use
         * @param column The column number to use
         */
        createAnchor(row: number, column: number): void,

        /**
         * Returns the newline character that's being used, depending on the value of `newLineMode`.
         */
        getNewLineCharacter(): string,

        /**
         * [Sets the new line mode.]{: #Document.setNewLineMode.desc}
         * @param newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}
         */
        getNewLineMode(): string,

        /**
         * Returns `true` if `text` is a newline character (either `\r\n`, `\r`, or `\n`).
         * @param text The text to check
         */
        isNewLine(text: string): boolean,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row index to retrieve
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns all lines in the document as string array. Warning: The caller should not modify this array!
         */
        getAllLines(): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * [Given a range within the document, this function returns all the text within that range as a single string.]{: #Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Inserts the elements in `lines` into the document, starting at the row index given by `row`. This method also triggers the `'change'` event.
         * @param row The index of the row to insert at
         * @param lines An array of strings
         */
        insertLines(row: number, lines: string[]): any,

        /**
         * Inserts a new line into the document at the current row's `position`. This method also triggers the `'change'` event.
         * @param position The position to insert at
         */
        insertNewLine(position: AceAjax$Position): any,

        /**
         * Inserts `text` into the `position` at the current row. This method also triggers the `'change'` event.
         * @param position The position to insert at
         * @param text A chunk of text
         */
        insertInLine(position: any, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Removes the specified columns from the `row`. This method also triggers the `'change'` event.
         * @param row The row to remove from
         * @param startColumn The column to start removing at
         * @param endColumn The column to stop removing at
         */
        removeInLine(row: number, startColumn: number, endColumn: number): any,

        /**
         * Removes a range of full lines. This method also triggers the `'change'` event.
         * @param firstRow The first row to be removed
         * @param lastRow The last row to be removed
         */
        removeLines(firstRow: number, lastRow: number): string[],

        /**
         * Removes the new line between `row` and the row immediately following it. This method also triggers the `'change'` event.
         * @param row The row to check
         */
        removeNewLine(row: number): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Applies all the changes previously accumulated. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        applyDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Reverts any changes previously applied. These can be either `'includeText'`, `'insertLines'`, `'removeText'`, and `'removeLines'`.
         */
        revertDeltas(deltas: AceAjax$Delta[]): void,

        /**
         * Converts an index position in a document to a `{row, column}` object.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param index An index to convert
         * @param startRow =0 The row from which to start the conversion
        */
        indexToPosition(index: number, startRow: number): AceAjax$Position,

        /**
         * Converts the `{row, column}` position in a document to the character's index.
         * Index refers to the "absolute position" of a character in the document. For example:
        ```javascript
        var x = 0; // 10 characters, plus one for newline
        var y = -1;
        ```
        Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.
         * @param pos The `{row, column}` to convert
         * @param startRow =0 The row from which to start the conversion
        */
        positionToIndex(pos: AceAjax$Position, startRow: number): number
}

declare var Document: {

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string): AceAjax$Document,

    /**
     * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.
     * @param text The starting text
     */
    new(text?: string[]): AceAjax$Document
};


/**
 * Stores all the data about [[Editor `Editor`]] state providing easy way to change editors state.
 * `EditSession` can be attached to only one [[Document `Document`]]. Same `Document` can be attached to several `EditSession`s.
 */
declare export interface AceAjax$IEditSession {
    selection: AceAjax$Selection,
        bgTokenizer: AceAjax$BackgroundTokenizer,
        doc: AceAjax$Document,
        on(event: string, fn: (e: any) => any): void,
        findMatchingBracket(position: AceAjax$Position): void,
        addFold(text: string, range: AceAjax$Range): void,
        getFoldAt(row: number, column: number): any,
        removeFold(arg: any): void,
        expandFold(arg: any): void,
        unfold(arg1: any, arg2: boolean): void,
        screenToDocumentColumn(row: number, column: number): void,
        getFoldDisplayLine(foldLine: any, docRow: number, docColumn: number): any,
        getFoldsInRange(range: AceAjax$Range): any,
        highlight(text: string): void,

        /**
         * Sets the `EditSession` to point to a new `Document`. If a `BackgroundTokenizer` exists, it also points to `doc`.
         * @param doc The new `Document` to use
         */
        setDocument(doc: AceAjax$Document): void,

        /**
         * Returns the `Document` associated with this session.
         */
        getDocument(): AceAjax$Document,

        /**
         * undefined
         * @param row The row to work with
         */
        $resetRowCache(row: number): void,

        /**
         * Sets the session text.
         * @param text The new text to place
         */
        setValue(text: string): void,
        setMode(mode: string): void,

        /**
         * Returns the current [[Document `Document`]] as a string.
         */
        getValue(): string,

        /**
         * Returns the string of the current selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:BackgroundTokenizer.getState}
         * @param row The row to start at
         */
        getState(row: number): string,

        /**
         * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
         * @param row The row to start at
         */
        getTokens(row: number): AceAjax$TokenInfo[],

        /**
         * Returns an object indicating the token at the current row. The object has two properties: `index` and `start`.
         * @param row The row number to retrieve from
         * @param column The column number to retrieve from
         */
        getTokenAt(row: number, column: number): AceAjax$TokenInfo,

        /**
         * Sets the undo manager.
         * @param undoManager The new undo manager
         */
        setUndoManager(undoManager: AceAjax$UndoManager): void,

        /**
         * Returns the current undo manager.
         */
        getUndoManager(): AceAjax$UndoManager,

        /**
         * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize `getTabSize()`]]): void; otherwise it's simply `'\t'`.
         */
        getTabString(): string,

        /**
         * Pass `true` to enable the use of soft tabs. Soft tabs means you're using spaces instead of the tab character (`'\t'`).
         * @param useSoftTabs Value indicating whether or not to use soft tabs
         */
        setUseSoftTabs(useSoftTabs: boolean): void,

        /**
         * Returns `true` if soft tabs are being used, `false` otherwise.
         */
        getUseSoftTabs(): boolean,

        /**
         * Set the number of spaces that define a soft tab; for example, passing in `4` transforms the soft tabs to be equivalent to four spaces. This function also emits the `changeTabSize` event.
         * @param tabSize The new tab size
         */
        setTabSize(tabSize: number): void,

        /**
         * Returns the current tab size.
         */
        getTabSize(): number,

        /**
         * Returns `true` if the character at the position is a soft tab.
         * @param position The position to check
         */
        isTabStop(position: any): boolean,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable.
         * If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Adds `className` to the `row`, to be used for CSS stylings and whatnot.
         * @param row The row number
         * @param className The class to add
         */
        addGutterDecoration(row: number, className: string): void,

        /**
         * Removes `className` from the `row`.
         * @param row The row number
         * @param className The class to add
         */
        removeGutterDecoration(row: number, className: string): void,

        /**
         * Returns an array of numbers, indicating which rows have breakpoints.
         */
        getBreakpoints(): number[],

        /**
         * Sets a breakpoint on every row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param rows An array of row indices
         */
        setBreakpoints(rows: any[]): void,

        /**
         * Removes all breakpoints on the rows. This function also emites the `'changeBreakpoint'` event.
         */
        clearBreakpoints(): void,

        /**
         * Sets a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         * @param className Class of the breakpoint
         */
        setBreakpoint(row: number, className: string): void,

        /**
         * Removes a breakpoint on the row number given by `rows`. This function also emites the `'changeBreakpoint'` event.
         * @param row A row index
         */
        clearBreakpoint(row: number): void,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: Function, inFront: boolean): number,

        /**
         * Adds a new marker to the given `Range`. If `inFront` is `true`, a front marker is defined, and the `'changeFrontMarker'` event fires; otherwise, the `'changeBackMarker'` event fires.
         * @param range Define the range of the marker
         * @param clazz Set the CSS class for the marker
         * @param type Identify the type of the marker
         * @param inFront Set to `true` to establish a front marker
         */
        addMarker(range: AceAjax$Range, clazz: string, type: string, inFront: boolean): number,

        /**
         * Adds a dynamic marker to the session.
         * @param marker object with update method
         * @param inFront Set to `true` to establish a front marker
         */
        addDynamicMarker(marker: any, inFront: boolean): void,

        /**
         * Removes the marker with the specified ID. If this marker was in front, the `'changeFrontMarker'` event is emitted. If the marker was in the back, the `'changeBackMarker'` event is emitted.
         * @param markerId A number representing a marker
         */
        removeMarker(markerId: number): void,

        /**
         * Returns an array containing the IDs of all the markers, either front or back.
         * @param inFront If `true`, indicates you only want front markers; `false` indicates only back markers
         */
        getMarkers(inFront: boolean): any[],

        /**
         * Sets annotations for the `EditSession`. This functions emits the `'changeAnnotation'` event.
         * @param annotations A list of annotations
         */
        setAnnotations(annotations: AceAjax$Annotation[]): void,

        /**
         * Returns the annotations for the `EditSession`.
         */
        getAnnotations(): any,

        /**
         * Clears all the annotations for this session. This function also triggers the `'changeAnnotation'` event.
         */
        clearAnnotations(): void,

        /**
         * If `text` contains either the newline (`\n`) or carriage-return ('\r') characters, `$autoNewLine` stores that value.
         * @param text A block of text
         */
        $detectNewLine(text: string): void,

        /**
         * Given a starting row and column, this method returns the `Range` of the first word boundary it finds.
         * @param row The row to start at
         * @param column The column to start at
         */
        getWordRange(row: number, column: number): AceAjax$Range,

        /**
         * Gets the range of a word, including its right whitespace.
         * @param row The row number to start from
         * @param column The column number to start from
         */
        getAWordRange(row: number, column: number): any,

        /**
         * {:Document.setNewLineMode.desc}
         * @param newLineMode :Document.setNewLineMode.param}
         */
        setNewLineMode(newLineMode: string): void,

        /**
         * Returns the current new line mode.
         */
        getNewLineMode(): string,

        /**
         * Identifies if you want to use a worker for the `EditSession`.
         * @param useWorker Set to `true` to use a worker
         */
        setUseWorker(useWorker: boolean): void,

        /**
         * Returns `true` if workers are being used.
         */
        getUseWorker(): boolean,

        /**
         * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start `BackgroundTokenizer.start ()`]] to all the rows; it also emits the `'tokenizerUpdate'` event.
         */
        onReloadTokenizer(): void,

        /**
         * Sets a new text mode for the `EditSession`. This method also emits the `'changeMode'` event. If a [[BackgroundTokenizer `BackgroundTokenizer`]] is set, the `'tokenizerUpdate'` event is also emitted.
         * @param mode Set a new text mode
         */
        $mode(mode: AceAjax$TextMode): void,

        /**
         * Returns the current text mode.
         */
        getMode(): AceAjax$TextMode,

        /**
         * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
         * @param scrollTop The new scroll top value
         */
        setScrollTop(scrollTop: number): void,

        /**
         * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
         */
        setScrollLeft(): void,

        /**
         * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the width of the screen.
         */
        getScreenWidth(): number,

        /**
         * Returns a verbatim copy of the given line as it is in the document
         * @param row The row to retrieve from
         */
        getLine(row: number): string,

        /**
         * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.
         * @param firstRow The first row index to retrieve
         * @param lastRow The final row index to retrieve
         */
        getLines(firstRow: number, lastRow: number): string[],

        /**
         * Returns the number of rows in the document.
         */
        getLength(): number,

        /**
         * {:Document.getTextRange.desc}
         * @param range The range to work with
         */
        getTextRange(range: AceAjax$Range): string,

        /**
         * Inserts a block of `text` and the indicated `position`.
         * @param position The position {row, column} to start inserting at
         * @param text A chunk of text to insert
         */
        insert(position: AceAjax$Position, text: string): any,

        /**
         * Removes the `range` from the document.
         * @param range A specified Range to remove
         */
        remove(range: AceAjax$Range): any,

        /**
         * Reverts previous changes to your document.
         * @param deltas An array of previous changes
         * @param dontSelect [If `true`, doesn't select the range of where the change occured]{: #dontSelect}
         */
        undoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Re-implements a previously undone change to your document.
         * @param deltas An array of previous changes
         * @param dontSelect :dontSelect}
         */
        redoChanges(deltas: any[], dontSelect: boolean): AceAjax$Range,

        /**
         * Enables or disables highlighting of the range where an undo occured.
         * @param enable If `true`, selects the range of the reinserted change
         */
        setUndoSelect(enable: boolean): void,

        /**
         * Replaces a range in the document with the new `text`.
         * @param range A specified Range to replace
         * @param text The new text to use as a replacement
         */
        replace(range: AceAjax$Range, text: string): any,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Indents all the rows, from `startRow` to `endRow` (inclusive), by prefixing each row with the token in `indentString`.
         * If `indentString` contains the `'\t'` character, it's replaced by whatever is defined by [[EditSession.getTabString `getTabString()`]].
         * @param startRow Starting row
         * @param endRow Ending row
         * @param indentString The indent token
         */
        indentRows(startRow: number, endRow: number, indentString: string): void,

        /**
         * Outdents all the rows defined by the `start` and `end` properties of `range`.
         * @param range A range of rows
         */
        outdentRows(range: AceAjax$Range): void,

        /**
         * Shifts all the lines in the document up one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move up
         * @param lastRow The final row to move up
         */
        moveLinesUp(firstRow: number, lastRow: number): number,

        /**
         * Shifts all the lines in the document down one, starting from `firstRow` and ending at `lastRow`.
         * @param firstRow The starting row to move down
         * @param lastRow The final row to move down
         */
        moveLinesDown(firstRow: number, lastRow: number): number,

        /**
         * Duplicates all the text between `firstRow` and `lastRow`.
         * @param firstRow The starting row to duplicate
         * @param lastRow The final row to duplicate
         */
        duplicateLines(firstRow: number, lastRow: number): number,

        /**
         * Sets whether or not line wrapping is enabled. If `useWrapMode` is different than the current value, the `'changeWrapMode'` event is emitted.
         * @param useWrapMode Enable (or disable) wrap mode
         */
        setUseWrapMode(useWrapMode: boolean): void,

        /**
         * Returns `true` if wrap mode is being used; `false` otherwise.
         */
        getUseWrapMode(): boolean,

        /**
         * Sets the boundaries of wrap. Either value can be `null` to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for `min` or `max` are different, this method also emits the `'changeWrapMode'` event.
         * @param min The minimum wrap value (the left side wrap)
         * @param max The maximum wrap value (the right side wrap)
         */
        setWrapLimitRange(min: number, max: number): void,

        /**
         * This should generally only be called by the renderer when a resize is detected.
         * @param desiredLimit The new wrap limit
         */
        adjustWrapLimit(desiredLimit: number): boolean,

        /**
         * Returns the value of wrap limit.
         */
        getWrapLimit(): number,

        /**
         * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
         * { min: wrapLimitRange_min, max: wrapLimitRange_max }
         */
        getWrapLimitRange(): any,

        /**
         * Given a string, returns an array of the display characters, including tabs and spaces.
         * @param str The string to check
         * @param offset The value to start at
         */
        $getDisplayTokens(str: string, offset: number): void,

        /**
         * Calculates the width of the string `str` on the screen while assuming that the string starts at the first column on the screen.
         * @param str The string to calculate the screen width of
         * @param maxScreenColumn 
         * @param screenColumn 
         */
        $getStringScreenWidth(str: string, maxScreenColumn: number, screenColumn: number): number[],

        /**
         * Returns number of screenrows in a wrapped line.
         * @param row The row number to check
         */
        getRowLength(row: number): number,

        /**
         * Returns the position (on screen) for the last character in the provided screen row.
         * @param screenRow The screen row to check
         */
        getScreenLastRowColumn(screenRow: number): number,

        /**
         * For the given document row and column, this returns the column position of the last screen row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumn(docRow: number, docColumn: number): number,

        /**
         * For the given document row and column, this returns the document position of the last row.
         * @param docRow 
         * @param docColumn 
         */
        getDocumentLastRowColumnPosition(docRow: number, docColumn: number): number,

        /**
         * For the given row, this returns the split data.
         */
        getRowSplitData(): string,

        /**
         * The distance to the next tab stop at the specified screen column.
         * @param screenColumn The screen column to check
         */
        getScreenTabSize(screenColumn: number): number,

        /**
         * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
         * @param screenRow The screen row to check
         * @param screenColumn The screen column to check
         */
        screenToDocumentPosition(screenRow: number, screenColumn: number): any,

        /**
         * Converts document coordinates to screen coordinates. {:conversionConsiderations}
         * @param docRow The document row to check
         * @param docColumn The document column to check
         */
        documentToScreenPosition(docRow: number, docColumn: number): any,

        /**
         * For the given document row and column, returns the screen column.
         * @param row 
         * @param docColumn 
         */
        documentToScreenColumn(row: number, docColumn: number): number,

        /**
         * For the given document row and column, returns the screen row.
         * @param docRow 
         * @param docColumn 
         */
        documentToScreenRow(docRow: number, docColumn: number): void,

        /**
         * Returns the length of the screen.
         */
        getScreenLength(): number
}

declare var EditSession: {

    /**
     * Sets up a new `EditSession` and associates it with the given `Document` and `TextMode`.
     * @param text [If `text` is a `Document`, it associates the `EditSession` with it. Otherwise, a new `Document` is created, with the initial text]{: #textParam}
     * @param mode [The inital language mode to use for the document]{: #modeParam}
     */
    new(text: string, mode?: AceAjax$TextMode): AceAjax$IEditSession,
    new(content: string, mode?: string): AceAjax$IEditSession,
    new(text: string[], mode?: string): AceAjax$IEditSession
};


/**
 * The main entry point into the Ace functionality.
 * The `Editor` manages the [[EditSession]] (which manages [[Document]]s), as well as the [[VirtualRenderer]], which draws everything to the screen.
Event sessions dealing with the mouse and keyboard are bubbled up from `Document` to the `Editor`, which decides what to do with them.
*/
declare export interface AceAjax$Editor {
    on(ev: string, callback: (e: any) => any): void,
        addEventListener(ev: "change", callback: (ev: AceAjax$EditorChangeEvent) => any): void,
        addEventListener(ev: string, callback: Function): void,
        inMultiSelectMode: boolean,
        selectMoreLines(n: number): void,
        onTextInput(text: string): void,
        onCommandKey(e: any, hashId: any, keyCode: any): void,
        commands: AceAjax$CommandManager,
        session: AceAjax$IEditSession,
        selection: AceAjax$Selection,
        renderer: AceAjax$VirtualRenderer,
        keyBinding: AceAjax$KeyBinding,
        container: HTMLElement,
        onSelectionChange(e: any): void,
        onChangeMode(e?: any): void,
        execCommand(command: string, args?: any): void,

        /**
         * Sets a Configuration Option
         */
        setOption(optionName: any, optionValue: any): void,

        /**
         * Sets Configuration Options
         */
        setOptions(keyValueTuples: any): void,

        /**
         * Get a Configuration Option
         */
        getOption(name: any): any,

        /**
         * Get Configuration Options
         */
        getOptions(): any,

        /**
         * Get rid of console warning by setting this to Infinity
         */
        $blockScrolling: number,

        /**
         * Sets a new key handler, such as "vim" or "windows".
         * @param keyboardHandler The new key handler
         */
        setKeyboardHandler(keyboardHandler: string): void,

        /**
         * Returns the keyboard handler, such as "vim" or "windows".
         */
        getKeyboardHandler(): string,

        /**
         * Sets a new editsession to use. This method also emits the `'changeSession'` event.
         * @param session The new session to use
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Returns the current session being used.
         */
        getSession(): AceAjax$IEditSession,

        /**
         * Sets the current document to `val`.
         * @param val The new value to set for the document
         * @param cursorPos Where to set the new value. `undefined` or 0 is selectAll, -1 is at the document start, and 1 is at the end
         */
        setValue(val: string, cursorPos?: number): string,

        /**
         * Returns the current session's content.
         */
        getValue(): string,

        /**
         * Returns the currently highlighted selection.
         */
        getSelection(): AceAjax$Selection,

        /**
         * {:VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         */
        resize(force?: boolean): void,

        /**
         * {:VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * {:VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * {:VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * {:VirtualRenderer.unsetStyle}
         */
        unsetStyle(): void,

        /**
         * Set a new font size (in pixels) for the editor text.
         * @param size A font size ( _e.g._ "12px")
         */
        setFontSize(size: string): void,

        /**
         * Brings the current `textInput` into focus.
         */
        focus(): void,

        /**
         * Returns `true` if the current `textInput` is in focus.
         */
        isFocused(): void,

        /**
         * Blurs the current `textInput`.
         */
        blur(): void,

        /**
         * Emitted once the editor comes into focus.
         */
        onFocus(): void,

        /**
         * Emitted once the editor has been blurred.
         */
        onBlur(): void,

        /**
         * Emitted whenever the document is changed.
         * @param e Contains a single property, `data`, which has the delta of changes
         */
        onDocumentChange(e: any): void,

        /**
         * Emitted when the selection changes.
         */
        onCursorChange(): void,

        /**
         * Returns the string of text currently highlighted.
         */
        getCopyText(): string,

        /**
         * Called whenever a text "copy" happens.
         */
        onCopy(): void,

        /**
         * Called whenever a text "cut" happens.
         */
        onCut(): void,

        /**
         * Called whenever a text "paste" happens.
         * @param text The pasted text
         */
        onPaste(text: string): void,

        /**
         * Inserts `text` into wherever the cursor is pointing.
         * @param text The new text to add
         */
        insert(text: string): void,

        /**
         * Pass in `true` to enable overwrites in your session, or `false` to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of `overwrite` changes, this function also emites the `changeOverwrite` event.
         * @param overwrite Defines wheter or not to set overwrites
         */
        setOverwrite(overwrite: boolean): void,

        /**
         * Returns `true` if overwrites are enabled; `false` otherwise.
         */
        getOverwrite(): boolean,

        /**
         * Sets the value of overwrite to the opposite of whatever it currently is.
         */
        toggleOverwrite(): void,

        /**
         * Sets how fast the mouse scrolling should do.
         * @param speed A value indicating the new speed (in milliseconds)
         */
        setScrollSpeed(speed: number): void,

        /**
         * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
         */
        getScrollSpeed(): number,

        /**
         * Sets the delay (in milliseconds) of the mouse drag.
         * @param dragDelay A value indicating the new delay
         */
        setDragDelay(dragDelay: number): void,

        /**
         * Returns the current mouse drag delay.
         */
        getDragDelay(): number,

        /**
         * Indicates how selections should occur.
         * By default, selections are set to "line". There are no other styles at the moment,
        although this code change in the future.
        This function also emits the `'changeSelectionStyle'` event.
         * @param style The new selection style
        */
        setSelectionStyle(style: string): void,

        /**
         * Returns the current selection style.
         */
        getSelectionStyle(): string,

        /**
         * Determines whether or not the current line should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the current line
         */
        setHighlightActiveLine(shouldHighlight: boolean): void,

        /**
         * Returns `true` if current lines are always highlighted.
         */
        getHighlightActiveLine(): void,

        /**
         * Determines if the currently selected word should be highlighted.
         * @param shouldHighlight Set to `true` to highlight the currently selected word
         */
        setHighlightSelectedWord(shouldHighlight: boolean): void,

        /**
         * Returns `true` if currently highlighted words are to be highlighted.
         */
        getHighlightSelectedWord(): boolean,

        /**
         * If `showInvisibiles` is set to `true`, invisible characters&mdash;like spaces or new lines&mdash;are show in the editor.
         * @param showInvisibles Specifies whether or not to show invisible characters
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns `true` if invisible characters are being shown.
         */
        getShowInvisibles(): boolean,

        /**
         * If `showPrintMargin` is set to `true`, the print margin is shown in the editor.
         * @param showPrintMargin Specifies whether or not to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns `true` if the print margin is being shown.
         */
        getShowPrintMargin(): boolean,

        /**
         * Sets the column defining where the print margin should be.
         * @param showPrintMargin Specifies the new print margin
         */
        setPrintMarginColumn(showPrintMargin: number): void,

        /**
         * Returns the column number of where the print margin is.
         */
        getPrintMarginColumn(): number,

        /**
         * If `readOnly` is true, then the editor is set to read-only mode, and none of the content can change.
         * @param readOnly Specifies whether the editor can be modified or not
         */
        setReadOnly(readOnly: boolean): void,

        /**
         * Returns `true` if the editor is set to read-only mode.
         */
        getReadOnly(): boolean,

        /**
         * Specifies whether to use behaviors or not. ["Behaviors" in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
         * @param enabled Enables or disables behaviors
         */
        setBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the behaviors are currently enabled. {:BehaviorsDef}
         */
        getBehavioursEnabled(): boolean,

        /**
         * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
         * when such a character is typed in.
         * @param enabled Enables or disables wrapping behaviors
         */
        setWrapBehavioursEnabled(enabled: boolean): void,

        /**
         * Returns `true` if the wrapping behaviors are currently enabled.
         */
        getWrapBehavioursEnabled(): void,

        /**
         * Indicates whether the fold widgets are shown or not.
         * @param show Specifies whether the fold widgets are shown
         */
        setShowFoldWidgets(show: boolean): void,

        /**
         * Returns `true` if the fold widgets are shown.
         */
        getShowFoldWidgets(): void,

        /**
         * Removes words of text from the editor. A "word" is defined as a string of characters bookended by whitespace.
         * @param dir The direction of the deletion to occur, either "left" or "right"
         */
        remove(dir: string): void,

        /**
         * Removes the word directly to the right of the current selection.
         */
        removeWordRight(): void,

        /**
         * Removes the word directly to the left of the current selection.
         */
        removeWordLeft(): void,

        /**
         * Removes all the words to the left of the current selection, until the start of the line.
         */
        removeToLineStart(): void,

        /**
         * Removes all the words to the right of the current selection, until the end of the line.
         */
        removeToLineEnd(): void,

        /**
         * Splits the line at the current selection (by inserting an `'\n'`).
         */
        splitLine(): void,

        /**
         * Transposes current line.
         */
        transposeLetters(): void,

        /**
         * Converts the current selection entirely into lowercase.
         */
        toLowerCase(): void,

        /**
         * Converts the current selection entirely into uppercase.
         */
        toUpperCase(): void,

        /**
         * Inserts an indentation into the current cursor position or indents the selected lines.
         */
        indent(): void,

        /**
         * Indents the current line.
         */
        blockIndent(): void,

        /**
         * Outdents the current line.
         */
        blockOutdent(arg?: string): void,

        /**
         * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
         */
        toggleCommentLines(): void,

        /**
         * Works like [[EditSession.getTokenAt]], except it returns a number.
         */
        getNumberAt(): number,

        /**
         * If the character before the cursor is a number, this functions changes its value by `amount`.
         * @param amount The value to change the numeral by (can be negative to decrease value)
         */
        modifyNumber(amount: number): void,

        /**
         * Removes all the lines in the current selection
         */
        removeLines(): void,

        /**
         * Shifts all the selected lines down one row.
         */
        moveLinesDown(): number,

        /**
         * Shifts all the selected lines up one row.
         */
        moveLinesUp(): number,

        /**
         * Moves a range of text from the given range to the given position. `toPosition` is an object that looks like this:
         * ```json
        { row: newRowLocation, column: newColumnLocation }
        ```
         * @param fromRange The range of text you want moved within the document
         * @param toPosition The location (row and column) where you want to move the text to
        */
        moveText(fromRange: AceAjax$Range, toPosition: any): AceAjax$Range,

        /**
         * Copies all the selected lines up one row.
         */
        copyLinesUp(): number,

        /**
         * Copies all the selected lines down one row.
         */
        copyLinesDown(): number,

        /**
         * {:VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * {:VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Indicates if the row is currently visible on the screen.
         * @param row The row to check
         */
        isRowVisible(row: number): boolean,

        /**
         * Indicates if the entire row is currently visible on the screen.
         * @param row The row to check
         */
        isRowFullyVisible(row: number): boolean,

        /**
         * Selects the text from the current position of the document until where a "page down" finishes.
         */
        selectPageDown(): void,

        /**
         * Selects the text from the current position of the document until where a "page up" finishes.
         */
        selectPageUp(): void,

        /**
         * Shifts the document to wherever "page down" is, as well as moving the cursor position.
         */
        gotoPageDown(): void,

        /**
         * Shifts the document to wherever "page up" is, as well as moving the cursor position.
         */
        gotoPageUp(): void,

        /**
         * Scrolls the document to wherever "page down" is, without changing the cursor position.
         */
        scrollPageDown(): void,

        /**
         * Scrolls the document to wherever "page up" is, without changing the cursor position.
         */
        scrollPageUp(): void,

        /**
         * Moves the editor to the specified row.
         */
        scrollToRow(): void,

        /**
         * Scrolls to a line. If `center` is `true`, it puts the line in middle of screen (or attempts to).
         * @param line The line to scroll to
         * @param center If `true`
         * @param animate If `true` animates scrolling
         * @param callback Function to be called when the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Attempts to center the current selection on the screen.
         */
        centerSelection(): void,

        /**
         * Gets the current position of the cursor.
         */
        getCursorPosition(): AceAjax$Position,

        /**
         * Returns the screen position of the cursor.
         */
        getCursorPositionScreen(): number,

        /**
         * {:Selection.getRange}
         */
        getSelectionRange(): AceAjax$Range,

        /**
         * Selects all the text in editor.
         */
        selectAll(): void,

        /**
         * {:Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        moveCursorTo(row: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the position indicated by `pos.row` and `pos.column`.
         * @param position An object with two properties, row and column
         */
        moveCursorToPosition(position: AceAjax$Position): void,

        /**
         * Moves the cursor's row and column to the next matching bracket.
         */
        jumpToMatching(): void,

        /**
         * Moves the cursor to the specified line number, and also into the indiciated column.
         * @param lineNumber The line number to go to
         * @param column A column number to go to
         * @param animate If `true` animates scolling
         */
        gotoLine(lineNumber: number, column?: number, animate?: boolean): void,

        /**
         * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
         * @param row The new row number
         * @param column The new column number
         */
        navigateTo(row: number, column: number): void,

        /**
         * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateUp(times?: number): void,

        /**
         * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateDown(times?: number): void,

        /**
         * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateLeft(times?: number): void,

        /**
         * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
         * @param times The number of times to change navigation
         */
        navigateRight(times: number): void,

        /**
         * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
         */
        navigateLineStart(): void,

        /**
         * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
         */
        navigateLineEnd(): void,

        /**
         * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
         */
        navigateFileEnd(): void,

        /**
         * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
         */
        navigateFileStart(): void,

        /**
         * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
         */
        navigateWordRight(): void,

        /**
         * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
         */
        navigateWordLeft(): void,

        /**
         * Replaces the first occurance of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replace(replacement: string, options?: any): void,

        /**
         * Replaces all occurances of `options.needle` with the value in `replacement`.
         * @param replacement The text to replace with
         * @param options The [[Search `Search`]] options to use
         */
        replaceAll(replacement: string, options?: any): void,

        /**
         * {:Search.getOptions} For more information on `options`, see [[Search `Search`]].
         */
        getLastSearchOptions(): any,

        /**
         * Attempts to find `needle` within the document. For more information on `options`, see [[Search `Search`]].
         * @param needle The text to search for (optional)
         * @param options An object defining various search properties
         * @param animate If `true` animate scrolling
         */
        find(needle: string, options?: any, animate?: boolean): void,

        /**
         * Performs another search for `needle` in the document. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findNext(options?: any, animate?: boolean): void,

        /**
         * Performs a search for `needle` backwards. For more information on `options`, see [[Search `Search`]].
         * @param options search options
         * @param animate If `true` animate scrolling
         */
        findPrevious(options?: any, animate?: boolean): void,

        /**
         * {:UndoManager.undo}
         */
        undo(): void,

        /**
         * {:UndoManager.redo}
         */
        redo(): void,

        /**
         * Cleans up the entire editor.
         */
        destroy(): void
}

declare var Editor: {

    /**
     * Creates a new `Editor` object.
     * @param renderer Associated `VirtualRenderer` that draws everything
     * @param session The `EditSession` to refer to
     */
    new(
        renderer: AceAjax$VirtualRenderer,
        session?: AceAjax$IEditSession): AceAjax$Editor
};

declare interface AceAjax$EditorChangeEvent {
    start: AceAjax$Position,
        end: AceAjax$Position,
        action: string,
        lines: any[]
}

declare export interface AceAjax$PlaceHolder {
    on(event: string, fn: (e: any) => any): void,

        /**
         * PlaceHolder.setup()
         * TODO
         */
        setup(): void,

        /**
         * PlaceHolder.showOtherMarkers()
         * TODO
         */
        showOtherMarkers(): void,

        /**
         * PlaceHolder.hideOtherMarkers()
         * Hides all over markers in the [[EditSession `EditSession`]] that are not the currently selected one.
         */
        hideOtherMarkers(): void,

        /**
         * PlaceHolder@onUpdate(e)
         * Emitted when the place holder updates.
         */
        onUpdate(): void,

        /**
         * PlaceHolder@onCursorChange(e)
         * Emitted when the cursor changes.
         */
        onCursorChange(): void,

        /**
         * PlaceHolder.detach()
         * TODO
         */
        detach(): void,

        /**
         * PlaceHolder.cancel()
         * TODO
         */
        cancel(): void
}

declare var PlaceHolder: {

    /**
     * - 
     * @param session (Document): The document to associate with the anchor
    - 
     * @param length (Number): The starting row position
    - 
     * @param pos (Number): The starting column position
    - 
     * @param others (String):
    - 
     * @param mainClass (String):
    - 
     * @param othersClass (String):
    */
    new(
        session: AceAjax$Document,
        length: number,
        pos: number,
        others: string,
        mainClass: string,
        othersClass: string): AceAjax$PlaceHolder,
    new(
        session: AceAjax$IEditSession,
        length: number,
        pos: AceAjax$Position,
        positions: AceAjax$Position[]): AceAjax$PlaceHolder
};

declare export interface AceAjax$IRangeList {
    ranges: AceAjax$Range[],
        pointIndex(pos: AceAjax$Position, startIndex?: number): void,
        addList(ranges: AceAjax$Range[]): void,
        add(ranges: AceAjax$Range): void,
        merge(): AceAjax$Range[],
        substractPoint(pos: AceAjax$Position): void
}

declare export var RangeList: {
    new(): AceAjax$IRangeList
};


/**
 * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogus to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.
 */
declare export interface AceAjax$Range {
    startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number,
        start: AceAjax$Position,
        end: AceAjax$Position,
        isEmpty(): boolean,

        /**
         * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.
         * @param range A range to check against
         */
        isEqual(range: AceAjax$Range): void,

        /**
         * Returns a string containing the range's row and column information, given like this:
         * ```
        [start.row/start.column] -> [end.row/end.column]
        ```
        */
        toString(): void,

        /**
         * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:
         * ```javascript
        this.start.row <= row <= this.end.row &&
        this.start.column <= column <= this.end.column
        ```
         * @param row A row to check for
         * @param column A column to check for
        */
        contains(row: number, column: number): boolean,

        /**
         * Compares `this` range (A) with another range (B).
         * @param range A range to compare with
         */
        compareRange(range: AceAjax$Range): number,

        /**
         * Checks the row and column points of `p` with the row and column points of the calling range.
         * @param p A point to compare with
         */
        comparePoint(p: AceAjax$Range): number,

        /**
         * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.
         * @param range A range to compare with
         */
        containsRange(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if passed in `range` intersects with the one calling this method.
         * @param range A range to compare with
         */
        intersects(range: AceAjax$Range): boolean,

        /**
         * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isEnd(row: number, column: number): boolean,

        /**
         * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        isStart(row: number, column: number): boolean,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setStart(row: number, column: number): void,

        /**
         * Sets the starting row and column for the range.
         * @param row A row point to set
         * @param column A column point to set
         */
        setEnd(row: number, column: number): void,

        /**
         * Returns `true` if the `row` and `column` are within the given range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        inside(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's starting points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideStart(row: number, column: number): boolean,

        /**
         * Returns `true` if the `row` and `column` are within the given range's ending points.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        insideEnd(row: number, column: number): boolean,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compare(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareStart(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareEnd(row: number, column: number): number,

        /**
         * Checks the row and column points with the row and column points of the calling range.
         * @param row A row point to compare with
         * @param column A column point to compare with
         */
        compareInside(row: number, column: number): number,

        /**
         * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.
         * @param firstRow The starting row
         * @param lastRow The ending row
         */
        clipRows(firstRow: number, lastRow: number): AceAjax$Range,

        /**
         * Changes the row and column points for the calling range for both the starting and ending points.
         * @param row A new row to extend to
         * @param column A new column to extend to
         */
        extend(row: number, column: number): AceAjax$Range,

        /**
         * Returns `true` if the range spans across multiple lines.
         */
        isMultiLine(): boolean,

        /**
         * Returns a duplicate of the calling range.
         */
        clone(): AceAjax$Range,

        /**
         * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.
         */
        collapseRows(): AceAjax$Range,

        /**
         * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.
         * @param session The `EditSession` to retrieve coordinates from
         */
        toScreenRange(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Creates and returns a new `Range` based on the row and column of the given parameters.
         * @param start A starting point to use
         * @param end An ending point to use
         */
        fromPoints(start: AceAjax$Range, end: AceAjax$Range): AceAjax$Range
}

declare var Range: {
    fromPoints(pos1: AceAjax$Position, pos2: AceAjax$Position): AceAjax$Range,
    new(
        startRow: number,
        startColumn: number,
        endRow: number,
        endColumn: number): AceAjax$Range
};

declare export interface AceAjax$RenderLoop {}

declare var RenderLoop: {
    new(): AceAjax$RenderLoop
};


/**
 * A set of methods for setting and retrieving the editor's scrollbar.
 */
declare export interface AceAjax$ScrollBar {

    /**
     * Emitted when the scroll bar, well, scrolls.
     * @param e Contains one property, `"data"`, which indicates the current scroll top position
     */
    onScroll(e: any): void,

        /**
         * Returns the width of the scroll bar.
         */
        getWidth(): number,

        /**
         * Sets the height of the scroll bar, in pixels.
         * @param height The new height
         */
        setHeight(height: number): void,

        /**
         * Sets the inner height of the scroll bar, in pixels.
         * @param height The new inner height
         */
        setInnerHeight(height: number): void,

        /**
         * Sets the scroll top of the scroll bar.
         * @param scrollTop The new scroll top
         */
        setScrollTop(scrollTop: number): void
}

declare var ScrollBar: {

    /**
     * Creates a new `ScrollBar`. `parent` is the owner of the scroll bar.
     * @param parent A DOM element
     */
    new(parent: HTMLElement): AceAjax$ScrollBar
};


/**
 * A class designed to handle all sorts of text searches within a [[Document `Document`]].
 */
declare export interface AceAjax$Search {

    /**
     * Sets the search options via the `options` parameter.
     * @param options An object containing all the new search properties
     */
    set(options: any): AceAjax$Search,

        /**
         * [Returns an object containing all the search options.]{: #Search.getOptions}
         */
        getOptions(): any,

        /**
         * Sets the search options via the `options` parameter.
         * @param An object containing all the search propertie
         */
        setOptions(An: any): void,

        /**
         * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        find(session: AceAjax$IEditSession): AceAjax$Range,

        /**
         * Searches for all occurances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.
         * @param session The session to search with
         */
        findAll(session: AceAjax$IEditSession): AceAjax$Range[],

        /**
         * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.
         * @param input The text to search in
         * @param replacement The replacing text
        + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>
        If `options.needle` was not found, this function returns `null`.
        */
        replace(input: string, replacement: string): string
}

declare var Search: {

    /**
     * Creates a new `Search` object. The following search options are avaliable:
     * - `needle`: The string or regular expression you're looking for
    - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.
    - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.
    - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.
    - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.
    - `range`: The [[Range]] to search within. Set this to `null` for the whole document
    - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.
    - `start`: The starting [[Range]] or cursor position to begin the search
    - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.
    */
    new(): AceAjax$Search
};


/**
 * Contains the cursor position and the text selection of an edit session.
 * The row/columns used in the selection are in document coordinates representing ths coordinates as thez appear in the document before applying soft wrap and folding.
 */
declare export interface AceAjax$Selection {
    addEventListener(ev: string, callback: Function): void,
        moveCursorWordLeft(): void,
        moveCursorWordRight(): void,
        fromOrientedRange(range: AceAjax$Range): void,
        setSelectionRange(match: any): void,
        getAllRanges(): AceAjax$Range[],
        on(event: string, fn: (e: any) => any): void,
        addRange(range: AceAjax$Range): void,

        /**
         * Returns `true` if the selection is empty.
         */
        isEmpty(): boolean,

        /**
         * Returns `true` if the selection is a multi-line.
         */
        isMultiLine(): boolean,

        /**
         * Gets the current position of the cursor.
         */
        getCursor(): AceAjax$Position,

        /**
         * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
         * @param row The new row
         * @param column The new column
         */
        setSelectionAnchor(row: number, column: number): void,

        /**
         * Returns an object containing the `row` and `column` of the calling selection anchor.
         */
        getSelectionAnchor(): any,

        /**
         * Returns an object containing the `row` and `column` of the calling selection lead.
         */
        getSelectionLead(): any,

        /**
         * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
         * @param columns The number of columns to shift by
         */
        shiftSelection(columns: number): void,

        /**
         * Returns `true` if the selection is going backwards in the document.
         */
        isBackwards(): boolean,

        /**
         * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
         */
        getRange(): AceAjax$Range,

        /**
         * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
         */
        clearSelection(): void,

        /**
         * Selects all the text in the document.
         */
        selectAll(): void,

        /**
         * Sets the selection to the provided range.
         * @param range The range of text to select
         * @param reverse Indicates if the range should go backwards (`true`) or not
         */
        setRange(range: AceAjax$Range, reverse: boolean): void,

        /**
         * Moves the selection cursor to the indicated row and column.
         * @param row The row to select to
         * @param column The column to select to
         */
        selectTo(row: number, column: number): void,

        /**
         * Moves the selection cursor to the row and column indicated by `pos`.
         * @param pos An object containing the row and column
         */
        selectToPosition(pos: any): void,

        /**
         * Moves the selection up one row.
         */
        selectUp(): void,

        /**
         * Moves the selection down one row.
         */
        selectDown(): void,

        /**
         * Moves the selection right one column.
         */
        selectRight(): void,

        /**
         * Moves the selection left one column.
         */
        selectLeft(): void,

        /**
         * Moves the selection to the beginning of the current line.
         */
        selectLineStart(): void,

        /**
         * Moves the selection to the end of the current line.
         */
        selectLineEnd(): void,

        /**
         * Moves the selection to the end of the file.
         */
        selectFileEnd(): void,

        /**
         * Moves the selection to the start of the file.
         */
        selectFileStart(): void,

        /**
         * Moves the selection to the first word on the right.
         */
        selectWordRight(): void,

        /**
         * Moves the selection to the first word on the left.
         */
        selectWordLeft(): void,

        /**
         * Moves the selection to highlight the entire word.
         */
        getWordRange(): void,

        /**
         * Selects an entire word boundary.
         */
        selectWord(): void,

        /**
         * Selects a word, including its right whitespace.
         */
        selectAWord(): void,

        /**
         * Selects the entire line.
         */
        selectLine(): void,

        /**
         * Moves the cursor up one row.
         */
        moveCursorUp(): void,

        /**
         * Moves the cursor down one row.
         */
        moveCursorDown(): void,

        /**
         * Moves the cursor left one column.
         */
        moveCursorLeft(): void,

        /**
         * Moves the cursor right one column.
         */
        moveCursorRight(): void,

        /**
         * Moves the cursor to the start of the line.
         */
        moveCursorLineStart(): void,

        /**
         * Moves the cursor to the end of the line.
         */
        moveCursorLineEnd(): void,

        /**
         * Moves the cursor to the end of the file.
         */
        moveCursorFileEnd(): void,

        /**
         * Moves the cursor to the start of the file.
         */
        moveCursorFileStart(): void,

        /**
         * Moves the cursor to the word on the right.
         */
        moveCursorLongWordRight(): void,

        /**
         * Moves the cursor to the word on the left.
         */
        moveCursorLongWordLeft(): void,

        /**
         * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document.
         * @param rows The number of rows to move by
         * @param chars The number of characters to move by
         */
        moveCursorBy(rows: number, chars: number): void,

        /**
         * Moves the selection to the position indicated by its `row` and `column`.
         * @param position The position to move to
         */
        moveCursorToPosition(position: any): void,

        /**
         * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
         */
        moveCursorTo(row: number, column: number, keepDesiredColumn?: boolean): void,

        /**
         * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
         * @param row The row to move to
         * @param column The column to move to
         * @param keepDesiredColumn :preventUpdateBool}
         */
        moveCursorToScreen(row: number, column: number, keepDesiredColumn: boolean): void
}

declare var Selection: {

    /**
     * Creates a new `Selection` object.
     * @param session The session to use
     */
    new(session: AceAjax$IEditSession): AceAjax$Selection
};

declare export interface AceAjax$Split {

    /**
     * Returns the number of splits.
     */
    getSplits(): number,

        /**
         * Returns the editor identified by the index `idx`.
         * @param idx The index of the editor you want
         */
        getEditor(idx: number): void,

        /**
         * Returns the current editor.
         */
        getCurrentEditor(): AceAjax$Editor,

        /**
         * Focuses the current editor.
         */
        focus(): void,

        /**
         * Blurs the current editor.
         */
        blur(): void,

        /**
         * Sets a theme for each of the available editors.
         * @param theme The name of the theme to set
         */
        setTheme(theme: string): void,

        /**
         * Sets the keyboard handler for the editor.
         * @param keybinding 
         */
        setKeyboardHandler(keybinding: string): void,

        /**
         * Executes `callback` on all of the available editors.
         * @param callback A callback function to execute
         * @param scope The default scope for the callback
         */
        forEach(callback: Function, scope: string): void,

        /**
         * Sets the font size, in pixels, for all the available editors.
         * @param size The new font size
         */
        setFontSize(size: number): void,

        /**
         * Sets a new [[EditSession `EditSession`]] for the indicated editor.
         * @param session The new edit session
         * @param idx The editor's index you're interested in
         */
        setSession(session: AceAjax$IEditSession, idx: number): void,

        /**
         * Returns the orientation.
         */
        getOrientation(): number,

        /**
         * Sets the orientation.
         * @param orientation The new orientation value
         */
        setOrientation(orientation: number): void,

        /**
         * Resizes the editor.
         */
        resize(): void
}

declare var Split: {
    new(): AceAjax$Split
};


/**
 * This class provides an essay way to treat the document as a stream of tokens, and provides methods to iterate over these tokens.
 */
declare export interface AceAjax$TokenIterator {

    /**
     * Tokenizes all the items from the current point to the row prior in the document.
     */
    stepBackward(): string[],

        /**
         * Tokenizes all the items from the current point until the next row in the document. If the current point is at the end of the file, this function returns `null`. Otherwise, it returns the tokenized string.
         */
        stepForward(): string,

        /**
         * Returns the current tokenized string.
         */
        getCurrentToken(): AceAjax$TokenInfo,

        /**
         * Returns the current row.
         */
        getCurrentTokenRow(): number,

        /**
         * Returns the current column.
         */
        getCurrentTokenColumn(): number
}

declare var TokenIterator: {

    /**
     * Creates a new token iterator object. The inital token index is set to the provided row and column coordinates.
     * @param session The session to associate with
     * @param initialRow The row to start the tokenizing at
     * @param initialColumn The column to start the tokenizing at
     */
    new(
        session: AceAjax$IEditSession,
        initialRow: number,
        initialColumn: number): AceAjax$TokenIterator
};


/**
 * This class takes a set of highlighting rules, and creates a tokenizer out of them. For more information, see [the wiki on extending highlighters](https://github.com/ajaxorg/ace/wiki/Creating-or-Extending-an-Edit-Mode#wiki-extendingTheHighlighter).
 */
declare export interface AceAjax$Tokenizer {

    /**
     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.
     */
    getLineTokens(): any
}

declare var Tokenizer: {

    /**
     * Constructs a new tokenizer based on the given rules and flags.
     * @param rules The highlighting rules
     * @param flag Any additional regular expression flags to pass (like "i" for case insensitive)
     */
    new(rules: any, flag: string): AceAjax$Tokenizer
};


/**
 * This object maintains the undo stack for an [[EditSession `EditSession`]].
 */
declare export interface AceAjax$UndoManager {

    /**
     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:
     * - `args[0]` is an array of deltas
    - `args[1]` is the document to associate with
     * @param options Contains additional properties
    */
    execute(options: any): void,

        /**
         * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}
         * @param dontSelect :dontSelect}
         */
        undo(dontSelect?: boolean): AceAjax$Range,

        /**
         * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}
         * @param dontSelect :dontSelect}
         */
        redo(dontSelect: boolean): void,

        /**
         * Destroys the stack of undo and redo redo operations.
         */
        reset(): void,

        /**
         * Returns `true` if there are undo operations left to perform.
         */
        hasUndo(): boolean,

        /**
         * Returns `true` if there are redo operations left to perform.
         */
        hasRedo(): boolean,

        /**
         * Returns `true` if the dirty counter is 0
         */
        isClean(): boolean,

        /**
         * Sets dirty counter to 0
         */
        markClean(): void
}

declare var UndoManager: {

    /**
     * Resets the current undo state and creates a new `UndoManager`.
     */
    new(): AceAjax$UndoManager
};


/**
 * The class that is responsible for drawing everything you see on the screen!
 */
declare export interface AceAjax$VirtualRenderer {
    scroller: any,
        characterWidth: number,
        lineHeight: number,
        screenToTextCoordinates(left: number, top: number): void,

        /**
         * Associates the renderer with an [[EditSession `EditSession`]].
         */
        setSession(session: AceAjax$IEditSession): void,

        /**
         * Triggers a partial update of the text, from the range given by the two parameters.
         * @param firstRow The first row to update
         * @param lastRow The last row to update
         */
        updateLines(firstRow: number, lastRow: number): void,

        /**
         * Triggers a full update of the text, for all the rows.
         */
        updateText(): void,

        /**
         * Triggers a full update of all the layers, for all the rows.
         * @param force If `true`, forces the changes through
         */
        updateFull(force: boolean): void,

        /**
         * Updates the font size.
         */
        updateFontSize(): void,

        /**
         * [Triggers a resize of the editor.]{: #VirtualRenderer.onResize}
         * @param force If `true`, recomputes the size, even if the height and width haven't changed
         * @param gutterWidth The width of the gutter in pixels
         * @param width The width of the editor in pixels
         * @param height The hiehgt of the editor, in pixels
         */
        onResize(force: boolean, gutterWidth: number, width: number, height: number): void,

        /**
         * Adjusts the wrap limit, which is the number of characters that can fit within the width of the edit area on screen.
         */
        adjustWrapLimit(): void,

        /**
         * Identifies whether you want to have an animated scroll or not.
         * @param shouldAnimate Set to `true` to show animated scrolls
         */
        setAnimatedScroll(shouldAnimate: boolean): void,

        /**
         * Returns whether an animated scroll happens or not.
         */
        getAnimatedScroll(): boolean,

        /**
         * Identifies whether you want to show invisible characters or not.
         * @param showInvisibles Set to `true` to show invisibles
         */
        setShowInvisibles(showInvisibles: boolean): void,

        /**
         * Returns whether invisible characters are being shown or not.
         */
        getShowInvisibles(): boolean,

        /**
         * Identifies whether you want to show the print margin or not.
         * @param showPrintMargin Set to `true` to show the print margin
         */
        setShowPrintMargin(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin is being shown or not.
         */
        getShowPrintMargin(): boolean,

        /**
         * Identifies whether you want to show the print margin column or not.
         * @param showPrintMargin Set to `true` to show the print margin column
         */
        setPrintMarginColumn(showPrintMargin: boolean): void,

        /**
         * Returns whether the print margin column is being shown or not.
         */
        getPrintMarginColumn(): boolean,

        /**
         * Returns `true` if the gutter is being shown.
         */
        getShowGutter(): boolean,

        /**
         * Identifies whether you want to show the gutter or not.
         * @param show Set to `true` to show the gutter
         */
        setShowGutter(show: boolean): void,

        /**
         * Returns the root element containing this renderer.
         */
        getContainerElement(): HTMLElement,

        /**
         * Returns the element that the mouse events are attached to
         */
        getMouseEventTarget(): HTMLElement,

        /**
         * Returns the element to which the hidden text area is added.
         */
        getTextAreaContainer(): HTMLElement,

        /**
         * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
         */
        getFirstVisibleRow(): number,

        /**
         * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getFirstFullyVisibleRow(): number,

        /**
         * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
         */
        getLastFullyVisibleRow(): number,

        /**
         * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
         */
        getLastVisibleRow(): number,

        /**
         * Sets the padding for all the layers.
         * @param padding A new padding value (in pixels)
         */
        setPadding(padding: number): void,

        /**
         * Returns whether the horizontal scrollbar is set to be always visible.
         */
        getHScrollBarAlwaysVisible(): boolean,

        /**
         * Identifies whether you want to show the horizontal scrollbar or not.
         * @param alwaysVisible Set to `true` to make the horizontal scroll bar visible
         */
        setHScrollBarAlwaysVisible(alwaysVisible: boolean): void,

        /**
         * Schedules an update to all the front markers in the document.
         */
        updateFrontMarkers(): void,

        /**
         * Schedules an update to all the back markers in the document.
         */
        updateBackMarkers(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        addGutterDecoration(): void,

        /**
         * Deprecated; (moved to [[EditSession]])
         */
        removeGutterDecoration(): void,

        /**
         * Redraw breakpoints.
         */
        updateBreakpoints(): void,

        /**
         * Sets annotations for the gutter.
         * @param annotations An array containing annotations
         */
        setAnnotations(annotations: any[]): void,

        /**
         * Updates the cursor icon.
         */
        updateCursor(): void,

        /**
         * Hides the cursor icon.
         */
        hideCursor(): void,

        /**
         * Shows the cursor icon.
         */
        showCursor(): void,

        /**
         * Scrolls the cursor into the first visibile area of the editor
         */
        scrollCursorIntoView(): void,

        /**
         * {:EditSession.getScrollTop}
         */
        getScrollTop(): number,

        /**
         * {:EditSession.getScrollLeft}
         */
        getScrollLeft(): number,

        /**
         * Returns the first visible row, regardless of whether it's fully visible or not.
         */
        getScrollTopRow(): number,

        /**
         * Returns the last visible row, regardless of whether it's fully visible or not.
         */
        getScrollBottomRow(): number,

        /**
         * Gracefully scrolls from the top of the editor to the row indicated.
         * @param row A row id
         */
        scrollToRow(row: number): void,

        /**
         * Gracefully scrolls the editor to the row indicated.
         * @param line A line number
         * @param center If `true`, centers the editor the to indicated line
         * @param animate If `true` animates scrolling
         * @param callback Function to be called after the animation has finished
         */
        scrollToLine(line: number, center: boolean, animate: boolean, callback: Function): void,

        /**
         * Scrolls the editor to the y pixel indicated.
         * @param scrollTop The position to scroll to
         */
        scrollToY(scrollTop: number): number,

        /**
         * Scrolls the editor across the x-axis to the pixel indicated.
         * @param scrollLeft The position to scroll to
         */
        scrollToX(scrollLeft: number): number,

        /**
         * Scrolls the editor across both x- and y-axes.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        scrollBy(deltaX: number, deltaY: number): void,

        /**
         * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
         * @param deltaX The x value to scroll by
         * @param deltaY The y value to scroll by
         */
        isScrollableBy(deltaX: number, deltaY: number): boolean,

        /**
         * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
         * @param row The document row position
         * @param column The document column position
         */
        textToScreenCoordinates(row: number, column: number): any,

        /**
         * Focuses the current container.
         */
        visualizeFocus(): void,

        /**
         * Blurs the current container.
         */
        visualizeBlur(): void,

        /**
         * undefined
         * @param position 
         */
        showComposition(position: number): void,

        /**
         * Sets the inner text of the current composition to `text`.
         * @param text A string of text to use
         */
        setCompositionText(text: string): void,

        /**
         * Hides the current composition.
         */
        hideComposition(): void,

        /**
         * [Sets a new theme for the editor. `theme` should exist, and be a directory path, like `ace/theme/textmate`.]{: #VirtualRenderer.setTheme}
         * @param theme The path to a theme
         */
        setTheme(theme: string): void,

        /**
         * [Returns the path of the current theme.]{: #VirtualRenderer.getTheme}
         */
        getTheme(): string,

        /**
         * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
         * @param style A class name
         */
        setStyle(style: string): void,

        /**
         * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
         * @param style A class name
         */
        unsetStyle(style: string): void,

        /**
         * Destroys the text and cursor layers for this renderer.
         */
        destroy(): void
}

declare var VirtualRenderer: {

    /**
     * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
     * @param container The root element of the editor
     * @param theme The starting theme
     */
    new(container: HTMLElement, theme?: string): AceAjax$VirtualRenderer
};
declare var ace: AceAjax$Ace;
declare module 'acl' {
    declare type strings = string | string[];
    declare type Value = string | number;
    declare type Values = Value | Value[];
    declare type Action = () => any;
    declare type Callback = (err: Error) => any;
    declare type AnyCallback = (err: Error, obj: any) => any;
    declare type AllowedCallback = (err: Error, allowed: boolean) => any;
    declare type GetUserId = (req: http.IncomingMessage, res: http.ServerResponse) => Value;
    declare interface AclStatic {
        new(backend: Backend<any>, logger: Logger, options: Option): Acl,
        new(backend: Backend<any>, logger: Logger): Acl,
        new(backend: Backend<any>): Acl,
        memoryBackend: MemoryBackendStatic
    }
    declare interface Logger {
        debug: (msg: string) => any
    }
    declare interface Acl {
        addUserRoles: (userId: Value, roles: strings, cb?: Callback) => Promise<void>,
            removeUserRoles: (userId: Value, roles: strings, cb?: Callback) => Promise<void>,
            userRoles: (userId: Value, cb?: (err: Error, roles: string[]) => any) => Promise<string[]>,
            roleUsers: (role: Value, cb?: (err: Error, users: Values) => any) => Promise<any>,
            hasRole: (
                userId: Value,
                role: string,
                cb?: (err: Error, isInRole: boolean) => any) => Promise<boolean>,
            addRoleParents: (role: string, parents: Values, cb?: Callback) => Promise<void>,
            removeRole: (role: string, cb?: Callback) => Promise<void>,
            removeResource: (resource: string, cb?: Callback) => Promise<void>,
            allow: {
                (roles: Values, resources: strings, permissions: strings, cb?: Callback): Promise<void>,
                (aclSets: AclSet | AclSet[]): Promise<void >
            },
            removeAllow: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Callback) => Promise<void>,
            removePermissions: (
                role: string,
                resources: strings,
                permissions: strings,
                cb?: Function) => Promise<void>,
            allowedPermissions: (userId: Value, resources: strings, cb?: AnyCallback) => Promise<void>,
            isAllowed: (
                userId: Value,
                resources: strings,
                permissions: strings,
                cb?: AllowedCallback) => Promise<boolean>,
            areAnyRolesAllowed: (
                roles: strings,
                resource: strings,
                permissions: strings,
                cb?: AllowedCallback) => Promise<any>,
            whatResources: (roles: strings, permissions: strings, cb?: AnyCallback) => Promise<any>,
            permittedResources: (roles: strings, permissions: strings, cb?: Function) => Promise<void>,
            middleware: (
                numPathComponents: number,
                userId: Value | GetUserId,
                actions: strings) => Promise<any >
    }
    declare interface Option {
        buckets?: BucketsOption
    }
    declare interface BucketsOption {
        meta?: string,
            parents?: string,
            permissions?: string,
            resources?: string,
            roles?: string,
            users?: string
    }
    declare interface AclSet {
        roles: strings,
            allows: AclAllow[]
    }
    declare interface AclAllow {
        resources: strings,
            permissions: strings
    }
    declare type MemoryBackend = {} & Backend

    declare interface MemoryBackendStatic {
        new(): MemoryBackend
    }
    declare interface Backend<T>{
        begin: () => T,
        end: (transaction: T, cb?: AltJS$Action) => void,
        clean: (cb?: AltJS$Action) => void,
        get: (bucket: string, key: Value, cb?: AltJS$Action) => void,
        union: (bucket: string, keys: Value[], cb?: AltJS$Action) => void,
        add: (transaction: T, bucket: string, key: Value, values: Values) => void,
        del: (transaction: T, bucket: string, keys: Value[]) => void,
        remove: (transaction: T, bucket: string, key: Value, values: Values) => void,
        endAsync: Function,
        getAsync: Function,
        cleanAsync: Function,
        unionAsync: Function
    }
    declare interface Contract {
        (args: IArguments): Contract | NoOp,
            debug: boolean,
            fulfilled: boolean,
            args: any[],
            checkedParams: string[],
            params: (...types: string[]) => Contract | NoOp,
            end: () => void
    }
    declare interface NoOp {
        params: (...types: string[]) => NoOp,
            end: () => void
    }
    declare type RedisBackend = {} & Backend

    declare interface RedisBackendStatic {
        new(redis: redis.RedisClient, prefix: string): RedisBackend,
        new(redis: redis.RedisClient): RedisBackend
    }
    declare type MongodbBackend = {} & Backend

    declare interface MongodbBackendStatic {
        new(db: mongo.Db, prefix: string, useSingle: boolean): MongodbBackend,
        new(db: mongo.Db, prefix: string): MongodbBackend,
        new(db: mongo.Db): MongodbBackend
    }
    declare     var _: AclStatic;
    declare module.exports: typeof _
}

declare var npm$namespace$acorn: {
    parse: typeof acorn$parse,
    parseExpressionAt: typeof acorn$parseExpressionAt,
    getLineInfo: typeof acorn$getLineInfo,
}
declare var version: string;

declare export function acorn$parse(pattern: any): NodeJS$ReadWriteStream

declare function acorn$parseExpressionAt(input: string, pos: number, options?: acorn$Options): ESTree.Expression

declare function acorn$getLineInfo(input: string, offset: number): ESTree.Position

declare var defaultOptions: acorn$Options;

declare interface acorn$TokenType {
    label: string,
        keyword: string,
        beforeExpr: boolean,
        startsExpr: boolean,
        isLoop: boolean,
        isAssign: boolean,
        prefix: boolean,
        postfix: boolean,
        binop: number,
        updateContext: (prevType: acorn$TokenType) => any
}

declare interface acorn$AbstractToken {
    start: number,
        end: number,
        loc: ESTree.SourceLocation,
        range: [number, number]
}

declare type acorn$Token = {
    type: acorn$TokenType,
    value: any
} & acorn$AbstractToken


declare type acorn$Comment = {
    type: string,
    value: string
} & acorn$AbstractToken


declare export interface acorn$Options {
    recurse: boolean
}
declare module 'acorn' {
    declare module.exports: typeof acorn
}
declare interface adal$Config {
    tenant?: string,
        clientId: string,
        redirectUri?: string,
        cacheLocation?: string,
        displayCall?: (urlNavigate: string) => any,
        correlationId?: string,
        loginResource?: string,
        resource?: string,
        endpoints?: any,
        extraQueryParameter?: string,
        postLogoutRedirectUri?: string
}

declare interface adal$User {
    userName: string,
        profile: any
}

declare export interface adal$RequestInfo {
    command: string,
        arguments: any
}

declare interface adal$Logging {
    log: (message: string) => void,
        level: LoggingLevel
}

declare interface adal$AuthenticationContextStatic {
    new(config: adal$Config): adal$AuthenticationContext
}

declare interface adal$AuthenticationContext {
    instance: string,
        config: adal$Config,

        /**
         * Gets initial Idtoken for the app backend
         * Saves the resulting Idtoken in localStorage.
         */
        login(): void,

        /**
         * Indicates whether login is in progress now or not.
         */
        loginInProgress(): boolean,

        /**
         * Gets token for the specified resource from local storage cache
         * @param  A URI that identifies the resource for which the token is valid.
         * @returns  token if exists and not expired or null
         */
        getCachedToken(resource: string): string,

        /**
         * Retrieves and parse idToken from localstorage
         * @returns  user object
         */
        getCachedUser(): adal$User,
        registerCallback(
            expectedState: string,
            resource: string,
            callback: (message: string, token: string) => any): void,

        /**
         * Acquire token from cache if not expired and available. Acquires token from iframe if expired.
         * @param  ResourceUri identifying the target resource
         * @param  
         */
        acquireToken(resource: string, callback: (message: string, token: string) => any): void,

        /**
         * Redirect the Browser to Azure AD Authorization endpoint
         * @param  The authorization request url
         */
        promptUser(urlNavigate: string): void,

        /**
         * Clear cache items.
         */
        clearCache(): void,

        /**
         * Clear cache items for a resource.
         */
        clearCacheForResource(resource: string): void,

        /**
         * Logout user will redirect page to logout endpoint.
         * After logout, it will redirect to post_logout page if provided.
         */
        logOut(): void,

        /**
         * Gets a user profile
         * @param  - The callback that handles the response.
         */
        getUser(callback: (message: string, user?: adal$User) => any): void,

        /**
         * Checks if hash contains access token or id token or error_description
         * @param  -  Hash passed from redirect page
         * @returns  
         */
        isCallback(hash: string): boolean,

        /**
         * Gets login error
         * @returns  error message related to login
         */
        getLoginError(): string,

        /**
         * Gets requestInfo from given hash.
         * @returns  for appropriate hash.
         */
        getRequestInfo(hash: string): adal$RequestInfo,

        /**
         * Saves token from hash that is received from redirect.
         */
        saveTokenFromHash(requestInfo: adal$RequestInfo): void,

        /**
         * Gets resource for given endpoint if mapping is provided with config.
         * @param  -  API endpoint
         * @returns  resource for this API endpoint
         */
        getResourceForEndpoint(endpoint: string): string,

        /**
         * Handles redirection after login operation. 
         * Gets access token from url and saves token to the (local/session) storage
        or saves error in case unsuccessful login.
        */
        handleWindowCallback(): void,
        log(level: number, message: string, error: any): void,
        error(message: string, error: any): void,
        warn(message: string): void,
        info(message: string): void,
        verbose(message: string): void
}
declare var AuthenticationContext: adal$AuthenticationContextStatic;
declare var Logging: adal$Logging;
declare module 'adal' {
    declare module.exports: typeof NO PRINT IMPLEMENTED: ObjectLiteralExpression
}
declare var addToHome: {

    /**
     * Shows the popup.
     * @param  Override all the compatibility checks and always show the popup.
     */
    show: (overrideChecks: boolean) => void,

    /**
     * Closes the popup. 
     */
    close: () => void,

    /**
     * Reset the local and session storages so the popup will show again (for automatic mode - has no affect if manually opening the popup). 
     */
    reset: () => void
};
declare module 'adm-zip' {
    declare module.exports: typeof AdmZip

    /**
     * The ZipEntry is more than a structure representing the entry inside the
     * zip file. Beside the normal attributes and headers a entry can have, the
    class contains a reference to the part of the file where the compressed
    data resides and decompresses it when requested. It also compresses the
    data and creates the headers required to write in the zip file.
    */
    declare interface AdmZip$IZipEntry {

        /**
         * Represents the full name and path of the file
         */
        entryName: string,
            rawEntryName: Buffer,

            /**
             * Extra data associated with this entry.
             */
            extra: Buffer,

            /**
             * Entry comment.
             */
            comment: string,
            name: string,

            /**
             * Read-Only property that indicates the type of the entry.
             */
            isDirectory: boolean,

            /**
             * Get the header associated with this ZipEntry.
             */
            header: Buffer,

            /**
             * Retrieve the compressed data for this entry. Note that this may trigger
             * compression if any properties were modified.
             */
            getCompressedData(): Buffer,

            /**
             * Asynchronously retrieve the compressed data for this entry. Note that
             * this may trigger compression if any properties were modified.
             */
            getCompressedDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: string): void,

            /**
             * Set the (uncompressed) data to be associated with this entry.
             */
            setData(value: Buffer): void,

            /**
             * Get the decompressed data associated with this entry.
             */
            getData(): Buffer,

            /**
             * Asynchronously get the decompressed data associated with this entry.
             */
            getDataAsync(callback: (data: Buffer) => void): void,

            /**
             * Returns the CEN Entry Header to be written to the output zip file, plus
             * the extra data and the entry comment.
             */
            packHeader(): Buffer,

            /**
             * Returns a nicely formatted string with the most important properties of
             * the ZipEntry.
             */
            toString(): string
    }
}
declare module 'grid' {
    declare class ColumnChangeEvent {
        constructor(type: string): this;
        toString(): string;
        withColumn(column: Column): ColumnChangeEvent;
        withColumnGroup(columnGroup: ColumnGroup): ColumnChangeEvent;
        withFromIndex(fromIndex: number): ColumnChangeEvent;
        withPinnedColumnCount(pinnedColumnCount: number): ColumnChangeEvent;
        withToIndex(toIndex: number): ColumnChangeEvent;
        getFromIndex(): number;
        getToIndex(): number;
        getPinnedColumnCount(): number;
        getType(): string;
        getColumn(): Column;
        getColumnGroup(): ColumnGroup;
        isPivotChanged(): boolean;
        isValueChanged(): boolean;
        isIndividualColumnResized(): boolean
    }
    declare class Utils {
        iterateObject(object: any, callback: (key: string, value: any) => void): void;
        cloneObject(object: any): any;
        map<TItem, TResult>(array: TItem[], callback: (item: TItem) => TResult): TResult[];
        forEach<T>(array: T[], callback: (item: T, index: number) => void): void;
        filter<T>(array: T[], callback: (item: T) => boolean): T[];
        assign(object: any, source: any): void;
        getFunctionParameters(func: any): any;
        find(collection: any, predicate: any, value: any): any;
        toStrings<T>(array: T[]): string[];
        iterateArray<T>(array: T[], callback: (item: T, index: number) => void): void;
        isNode(o: any): boolean;
        isElement(o: any): boolean;
        isNodeOrElement(o: any): boolean;
        addChangeListener(element: HTMLElement, listener: EventListener): void;
        makeNull(value: any): any;
        removeAllChildren(node: HTMLElement): void;
        removeElement(parent: HTMLElement, cssSelector: string): void;
        removeFromParent(node: Element): void;
        isVisible(element: HTMLElement): boolean;

        /**
         * loads the template and returns it as an element. makes up for no simple way in
         * the dom api to load html directly, eg we cannot do this: document.createElement(template)
         */
        loadTemplate(template: string): CSG$Node;
        querySelectorAll_addCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_removeCssClass(eParent: any, selector: string, cssClass: string): void;
        querySelectorAll_replaceCssClass(
            eParent: any,
            selector: string,
            cssClassToRemove: string,
            cssClassToAdd: string): void;
        addOrRemoveCssClass(element: HTMLElement, className: string, addOrRemove: boolean): void;
        addCssClass(element: HTMLElement, className: string): void;
        offsetHeight(element: HTMLElement): number;
        offsetWidth(element: HTMLElement): number;
        removeCssClass(element: HTMLElement, className: string): void;
        removeFromArray<T>(array: T[], object: T): void;
        defaultComparator(valueA: any, valueB: any): number;
        formatWidth(width: number | string): string;

        /**
         * Tries to use the provided renderer.
         */
        useRenderer<TParams>(
            eParent: Element,
            eRenderer: (params: TParams) => CSG$Node | string,
            params: TParams): void;

        /**
         * If icon provided, use this (either a string, or a function callback).
         * if not, then use the second parameter, which is the svgFactory function
         */
        createIcon(
            iconName: any,
            gridOptionsWrapper: any,
            colDefWrapper: any,
            svgFactoryFunc: () => CSG$Node): HTMLSpanElement;
        addStylesToElement(eElement: any, styles: any): void;
        getScrollbarWidth(): number;
        isKeyPressed(event: KeyboardEvent, keyToCheck: number): boolean;
        setVisible(element: HTMLElement, visible: boolean): void;
        isBrowserIE(): boolean;
        isBrowserSafari(): boolean
    }
    declare class Constants {
        STEP_EVERYTHING: number;
        STEP_FILTER: number;
        STEP_SORT: number;
        STEP_MAP: number;
        ASC: string;
        DESC: string;
        ROW_BUFFER_SIZE: number;
        MIN_COL_WIDTH: number;
        SUM: string;
        MIN: string;
        MAX: string;
        KEY_TAB: number;
        KEY_ENTER: number;
        KEY_BACKSPACE: number;
        KEY_DELETE: number;
        KEY_ESCAPE: number;
        KEY_SPACE: number;
        KEY_DOWN: number;
        KEY_UP: number;
        KEY_LEFT: number;
        KEY_RIGHT: number
    }
    declare class Column {
        colIdSequence: number;
        colDef: ColDef;
        actualWidth: any;
        visible: any;
        colId: any;
        pinned: boolean;
        index: number;
        aggFunc: string;
        pivotIndex: number;
        sort: string;
        sortedAt: number;
        constructor(colDef: ColDef, actualWidth: any): this;
        isGreaterThanMax(width: number): boolean;
        getMinimumWidth(): number;
        setMinimum(): void
    }
    declare class ColumnGroup {
        pinned: any;
        name: any;
        allColumns: Column[];
        displayedColumns: Column[];
        expandable: boolean;
        expanded: boolean;
        actualWidth: number;
        constructor(pinned: any, name: any): this;
        getMinimumWidth(): number;
        addColumn(column: any): void;
        calculateExpandable(): void;
        calculateActualWidth(): void;
        calculateDisplayedColumns(): void;
        addToVisibleColumns(colsToAdd: any): void
    }
    declare class GridOptionsWrapper {
        init(gridOptions: GridOptions, eventService: EventService): void;
        isRowSelection(): boolean;
        isRowDeselection(): boolean;
        isRowSelectionMulti(): boolean;
        getContext(): any;
        isVirtualPaging(): boolean;
        isShowToolPanel(): boolean;
        isToolPanelSuppressPivot(): boolean;
        isToolPanelSuppressValues(): boolean;
        isRowsAlreadyGrouped(): boolean;
        isGroupSelectsChildren(): boolean;
        isGroupHidePivotColumns(): boolean;
        isGroupIncludeFooter(): boolean;
        isGroupSuppressBlankHeader(): boolean;
        isSuppressRowClickSelection(): boolean;
        isSuppressCellSelection(): boolean;
        isSuppressMultiSort(): boolean;
        isGroupSuppressAutoColumn(): boolean;
        isForPrint(): boolean;
        isSuppressHorizontalScroll(): boolean;
        isUnSortIcon(): boolean;
        isSuppressMenuHide(): boolean;
        getRowStyle(): any;
        getRowClass(): any;
        getRowStyleFunc(): any;
        getRowClassFunc(): any;
        getHeaderCellRenderer(): any;
        getApi(): GridApi;
        isEnableColResize(): boolean;
        isSingleClickEdit(): boolean;
        getGroupDefaultExpanded(): any;
        getGroupKeys(): string[];
        getGroupAggFunction(): (nodes: any[]) => any;
        getGroupAggFields(): string[];
        getRowData(): any[];
        isGroupUseEntireRow(): boolean;
        getGroupColumnDef(): any;
        isGroupSuppressRow(): boolean;
        isAngularCompileRows(): boolean;
        isAngularCompileFilters(): boolean;
        isAngularCompileHeaders(): boolean;
        isDebug(): boolean;
        getColumnDefs(): any[];
        getDatasource(): any;
        getRowBuffer(): number;
        isEnableSorting(): boolean;
        isEnableCellExpressions(): boolean;
        isEnableServerSideSorting(): boolean;
        isEnableFilter(): boolean;
        isEnableServerSideFilter(): boolean;
        isSuppressScrollLag(): boolean;
        getIcons(): any;
        getIsScrollLag(): () => boolean;
        getSortingOrder(): string[];
        getSlaveGrids(): GridOptions[];
        getGroupRowRenderer(): Object | Function;
        getRowHeight(): number;
        getHeaderHeight(): number;
        setHeaderHeight(headerHeight: number): void;
        isGroupHeaders(): boolean;
        setGroupHeaders(groupHeaders: boolean): void;
        getFloatingTopRowData(): any[];
        setFloatingTopRowData(rows: any[]): void;
        getFloatingBottomRowData(): any[];
        setFloatingBottomRowData(rows: any[]): void;
        isExternalFilterPresent(): boolean;
        doesExternalFilterPass(node: RowNode): boolean;
        getGroupRowInnerRenderer(): (params: any) => void;
        getColWidth(): number;
        getPinnedColCount(): number;
        getLocaleTextFunc(): Function;
        globalEventHandler(eventName: string, event?: any): void
    }
    declare class LoggerFactory {
        init(gridOptionsWrapper: GridOptionsWrapper): void;
        create(name: string): Logger
    }
    declare class Logger {
        constructor(name: string, logging: boolean): this;
        log(message: string): void
    }
    declare class Events {

        /**
         * A new set of columns has been entered, everything has potentially changed. 
         */
        EVENT_COLUMN_EVERYTHING_CHANGED: string;

        /**
         * A pivot column was added, removed or order changed. 
         */
        EVENT_COLUMN_PIVOT_CHANGE: string;

        /**
         * A value column was added, removed or agg function was changed. 
         */
        EVENT_COLUMN_VALUE_CHANGE: string;

        /**
         * A column was moved 
         */
        EVENT_COLUMN_MOVED: string;

        /**
         * One or more columns was shown / hidden 
         */
        EVENT_COLUMN_VISIBLE: string;

        /**
         * A column group was opened / closed 
         */
        EVENT_COLUMN_GROUP_OPENED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_RESIZED: string;

        /**
         * One or more columns was resized. If just one, the column in the event is set. 
         */
        EVENT_COLUMN_PINNED_COUNT_CHANGED: string;
        EVENT_MODEL_UPDATED: string;
        EVENT_CELL_CLICKED: string;
        EVENT_CELL_DOUBLE_CLICKED: string;
        EVENT_CELL_CONTEXT_MENU: string;
        EVENT_CELL_VALUE_CHANGED: string;
        EVENT_CELL_FOCUSED: string;
        EVENT_ROW_SELECTED: string;
        EVENT_SELECTION_CHANGED: string;
        EVENT_BEFORE_FILTER_CHANGED: string;
        EVENT_AFTER_FILTER_CHANGED: string;
        EVENT_FILTER_MODIFIED: string;
        EVENT_BEFORE_SORT_CHANGED: string;
        EVENT_AFTER_SORT_CHANGED: string;
        EVENT_VIRTUAL_ROW_REMOVED: string;
        EVENT_ROW_CLICKED: string;
        EVENT_READY: string
    }
    declare class EventService {
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        dispatchEvent(eventType: string, event?: any): void
    }
    declare class MasterSlaveService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            loggerFactory: LoggerFactory,
            eventService: EventService): void;
        fireHorizontalScrollEvent(horizontalScroll: number): void;
        onScrollEvent(horizontalScroll: number): void;
        onColumnEvent(event: ColumnChangeEvent): void
    }
    declare class ColumnApi {
        constructor(_columnController: ColumnController): this;
        sizeColumnsToFit(gridWidth: any): void;
        hideColumns(colIds: any, hide: any): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        getColumnGroup(name: string): ColumnGroup;
        getDisplayNameForCol(column: any): string;
        getColumn(key: any): Column;
        setState(columnState: any): void;
        getState(): [any];
        isPinning(): boolean;
        getVisibleColAfter(col: Column): Column;
        getVisibleColBefore(col: Column): Column;
        setColumnVisible(column: Column, visible: boolean): void;
        getAllColumns(): Column[];
        getDisplayedColumns(): Column[];
        getPivotedColumns(): Column[];
        getValueColumns(): Column[];
        moveColumn(fromIndex: number, toIndex: number): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        setColumnAggFunction(column: Column, aggFunc: string): void;
        setColumnWidth(column: Column, newWidth: number): void;
        removeValueColumn(column: Column): void;
        addValueColumn(column: Column): void;
        removePivotColumn(column: Column): void;
        setPinnedColumnCount(count: number): void;
        addPivotColumn(column: Column): void;
        getHeaderGroups(): ColumnGroup[];
        hideColumn(colId: any, hide: any): void
    }
    declare class ColumnController {
        constructor(): this;
        init(
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            valueService: ValueService,
            masterSlaveController: MasterSlaveService,
            eventService: EventService): void;
        getColumnApi(): ColumnApi;
        isSetupComplete(): boolean;
        getHeaderGroups(): ColumnGroup[];
        getPinnedContainerWidth(): number;
        addPivotColumn(column: Column): void;
        setPinnedColumnCount(count: number): void;
        removePivotColumn(column: Column): void;
        addValueColumn(column: Column): void;
        removeValueColumn(column: Column): void;
        setColumnWidth(column: Column, newWidth: number): void;
        setColumnAggFunction(column: Column, aggFunc: string): void;
        movePivotColumn(fromIndex: number, toIndex: number): void;
        moveColumn(fromIndex: number, toIndex: number): void;
        getBodyContainerWidth(): number;
        getValueColumns(): Column[];
        getPivotedColumns(): Column[];
        getDisplayedColumns(): Column[];
        getAllColumns(): Column[];
        setColumnVisible(column: Column, visible: boolean): void;
        getVisibleColBefore(col: any): Column;
        getVisibleColAfter(col: Column): Column;
        isPinning(): boolean;
        getState(): [any];
        setState(columnState: any): void;
        getColumns(keys: any[]): Column[];
        getColumn(key: any): Column;
        getDisplayNameForCol(column: any): string;
        getColumnGroup(name: string): ColumnGroup;
        onColumnsChanged(): void;
        columnGroupOpened(group: ColumnGroup, newValue: boolean): void;
        hideColumns(colIds: any, hide: any): void;
        sizeColumnsToFit(gridWidth: any): void
    }
    declare interface CsvExportParams {
        skipHeader?: boolean,
            skipFooters?: boolean,
            skipGroups?: boolean,
            fileName?: string
    }
    declare class CsvCreator {
        constructor(rowController: InMemoryRowController, columnController: ColumnController, grid: Grid, valueService: ValueService): this;
        exportDataAsCsv(params?: CsvExportParams): void;
        getDataAsCsv(params?: CsvExportParams): string
    }
    declare class ExpressionService {
        init(loggerFactory: LoggerFactory): void;
        evaluate(expression: string, params: any): any
    }
    declare interface TextAndNumberFilterParameters {

        /**
         * What to do when new rows are loaded. The default is to reset the filter, to keep it in line with 'set' filters. If you want to keep the selection, then set this value to 'keep'. 
         */
        newRowsAction?: string
    }
    declare class TextFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare class NumberFilter mixins Filter {
        init(params: any): void;
        onNewRowsLoaded(): void;
        afterGuiAttached(): void;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        isFilterActive(): boolean
    }
    declare interface ColDef {

        /**
         * If sorting by default, set it here. Set to 'asc' or 'desc' 
         */
        sort?: string,

            /**
             * If sorting more than one column by default, the milliseconds when this column was sorted, so we know what order to sort the columns in. 
             */
            sortedAt?: number,

            /**
             * The sort order, provide an array with any of the following in any order ['asc','desc',null] 
             */
            sortingOrder?: string[],

            /**
             * The name to render in the column header 
             */
            headerName: string,

            /**
             * The field of the row to get the cells data from 
             */
            field: string,

            /**
             * Expression or function to get the cells value. 
             */
            headerValueGetter?: string | Function,

            /**
             * The unique ID to give the column. This is optional. If missing, the ID will default to the field. If both field and colId are missing, a unique ID will be generated.
             * This ID is used to identify the column in the API for sorting, filtering etc. 
             */
            colId?: string,

            /**
             * Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,
             * however we want all default values to be false and we want columns to be visible by default. 
             */
            hide?: boolean,

            /**
             * Tooltip for the column header 
             */
            headerTooltip?: string,

            /**
             * Expression or function to get the cells value. 
             */
            valueGetter?: string | Function,

            /**
             * To provide custom rendering to the header. 
             */
            headerCellRenderer?: Function | Object,

            /**
             * CSS class for the header 
             */
            headerClass?: string | string[] | ((params: any) => string | string[]),

            /**
             * Initial width, in pixels, of the cell 
             */
            width?: number,

            /**
             * Min width, in pixels, of the cell 
             */
            minWidth?: number,

            /**
             * Max width, in pixels, of the cell 
             */
            maxWidth?: number,

            /**
             * Class to use for the cell. Can be string, array of strings, or function. 
             */
            cellClass?: string | string[] | ((cellClassParams: any) => string | string[]),

            /**
             * An object of css values. Or a function returning an object of css values. 
             */
            cellStyle?: {} | ((params: any) => {}),

            /**
             * A function for rendering a cell. 
             */
            cellRenderer?: Function | {},

            /**
             * A function for rendering a floating cell. 
             */
            floatingCellRenderer?: Function | {},

            /**
             * Name of function to use for aggregation. One of [sum,min,max]. 
             */
            aggFunc?: string,

            /**
             * Comparator function for custom sorting. 
             */
            comparator?: Function,

            /**
             * Set to true to render a selection checkbox in the column. 
             */
            checkboxSelection?: boolean,

            /**
             * Set to true if no menu should be shown for this column header. 
             */
            suppressMenu?: boolean,

            /**
             * Set to true if no sorting should be done for this column. 
             */
            suppressSorting?: boolean,

            /**
             * Set to true if you want the unsorted icon to be shown when no sort is applied to this column. 
             */
            unSortIcon?: boolean,

            /**
             * Set to true if you want this columns width to be fixed during 'size to fit' operation. 
             */
            suppressSizeToFit?: boolean,

            /**
             * Set to true if you do not want this column to be resizable by dragging it's edge. 
             */
            suppressResize?: boolean,

            /**
             * If grouping columns, the group this column belongs to. 
             */
            headerGroup?: string,

            /**
             * Whether to show the column when the group is open / closed. 
             */
            headerGroupShow?: string,

            /**
             * Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable. 
             */
            editable?: boolean | (Function),

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            newValueHandler?: Function,

            /**
             * If true, this cell gets refreshed when api.softRefreshView() gets called. 
             */
            volatile?: boolean,

            /**
             * Cell template to use for cell. Useful for AngularJS cells. 
             */
            template?: string,

            /**
             * Cell template URL to load template from to use for cell. Useful for AngularJS cells. 
             */
            templateUrl?: string,

            /**
             * one of the built in filter names: [set, number, text], or a filter function
             */
            filter?: string | Function,

            /**
             * The filter params are specific to each filter! 
             */
            filterParams?: SetFilterParameters | TextAndNumberFilterParameters,

            /**
             * Rules for applying css classes 
             */
            cellClassRules?: {
                [cssClassName: string]: (Function | string)
            },

            /**
             * Callbacks for editing.See editing section for further details. 
             */
            onCellValueChanged?: Function,

            /**
             * Function callback, gets called when a cell is clicked. 
             */
            onCellClicked?: Function,

            /**
             * Function callback, gets called when a cell is double clicked. 
             */
            onCellDoubleClicked?: Function,

            /**
             * Function callback, gets called when a cell is right clicked. 
             */
            onCellContextMenu?: Function
    }
    declare class SetFilterModel {
        constructor(colDef: ColDef, rowModel: any, valueGetter: any, doesRowPassOtherFilters: any): this;
        refreshAfterNewRowsLoaded(keepSelection: any, isSelectAll: boolean): void;
        refreshAfterAnyFilterChanged(): void;
        setMiniFilter(newMiniFilter: any): boolean;
        getMiniFilter(): any;
        getDisplayedValueCount(): any;
        getDisplayedValue(index: any): any;
        selectEverything(): void;
        isFilterActive(): boolean;
        selectNothing(): void;
        getUniqueValueCount(): any;
        getUniqueValue(index: any): any;
        unselectValue(value: any): void;
        selectValue(value: any): void;
        isValueSelected(value: any): boolean;
        isEverythingSelected(): boolean;
        isNothingSelected(): boolean;
        getModel(): any;
        setModel(model: any, isSelectAll: boolean): void
    }
    declare interface SetFilterParameters {

        /**
         * Same as cell renderer for grid (you can use the same one in both locations). Setting it separatly here allows for the value to be rendered differently in the filter. 
         */
        cellRenderer?: Function,

            /**
             * The height of the cell. 
             */
            cellHeight?: number,

            /**
             * The values to display in the filter. 
             */
            values?: any,

            /**
             * What to do when new rows are loaded. The default is to reset the filter, as the set of values to select from can have changed. If you want to keep the selection, then set this value to 'keep'. 
             */
            newRowsAction?: string,

            /**
             * If true, the filter will not remove items that are no longer availabe due to other filters. 
             */
            suppressRemoveEntries?: boolean
    }
    declare class SetFilter mixins Filter {
        init(params: any): void;
        afterGuiAttached(): void;
        isFilterActive(): boolean;
        doesFilterPass(node: any): boolean;
        getGui(): any;
        onNewRowsLoaded(): void;
        onAnyFilterChanged(): void;
        getApi(): any
    }
    declare class PopupService {
        init(ePopupParent: any): void;
        positionPopup(eventSource: any, ePopup: any, minWidth: any): void;
        addAsModalPopup(eChild: any, closeOnEsc: boolean): (event: any) => void
    }
    declare interface RowNode {

        /**
         * Unique ID for the node. Can be though of as the index of the row in the original list,
         * however exceptions apply so don't depend on uniqueness. 
         */
        id?: number,

            /**
             * The user provided data 
             */
            data?: any,

            /**
             * The parent node to this node, or empty if top level 
             */
            parent?: RowNode,

            /**
             * How many levels this node is from the top 
             */
            level?: number,

            /**
             * True if this node is a group node (ie has children) 
             */
            group?: boolean,

            /**
             * True if this is the first child in this group 
             */
            firstChild?: boolean,

            /**
             * True if this is the last child in this group 
             */
            lastChild?: boolean,

            /**
             * The index of this node in the group 
             */
            childIndex?: number,

            /**
             * True if this row is a floating row 
             */
            floating?: boolean,

            /**
             * True if this row is a floating top row 
             */
            floatingTop?: boolean,

            /**
             * True if this row is a floating bottom row 
             */
            floatingBottom?: boolean,

            /**
             * If using quick filter, stores a string representation of the row for searching against 
             */
            quickFilterAggregateText?: string,

            /**
             * Groups only - True if row is a footer. Footers  have group = true and footer = true 
             */
            footer?: boolean,

            /**
             * Groups only - Children of this group 
             */
            children?: RowNode[],

            /**
             * Groups only - The field we are pivoting on eg Country
             */
            field?: string,

            /**
             * Groups only - The key for the pivot eg Ireland, UK, USA 
             */
            key?: any,

            /**
             * Groups only - Filtered children of this group 
             */
            childrenAfterFilter?: RowNode[],

            /**
             * Groups only - Sorted children of this group 
             */
            childrenAfterSort?: RowNode[],

            /**
             * Groups only - Number of children and grand children 
             */
            allChildrenCount?: number,

            /**
             * Groups only - True if group is expanded, otherwise false 
             */
            expanded?: boolean,

            /**
             * Groups only - If doing footers, reference to the footer node for this group 
             */
            sibling?: RowNode,

            /**
             * Not to be used, internal temporary map used by the grid when creating groups 
             */
            _childrenMap?: {}
    }
    declare class FilterManager {
        init(
            grid: Grid,
            gridOptionsWrapper: GridOptionsWrapper,
            $compile: any,
            $scope: any,
            columnController: ColumnController,
            popupService: PopupService,
            valueService: ValueService): void;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        setRowModel(rowModel: any): void;
        isAdvancedFilterPresent(): boolean;
        isAnyFilterPresent(): boolean;
        isFilterPresentForCol(colId: any): any;
        setQuickFilter(newFilter: any): boolean;
        onFilterChanged(): void;
        isQuickFilterPresent(): boolean;
        doesRowPassOtherFilters(filterToSkip: any, node: any): boolean;
        doesRowPassFilter(node: any, filterToSkip?: any): boolean;
        refreshDisplayedValues(): void;
        onNewRowsLoaded(): void;
        getFilterApi(column: Column): any;
        showFilter(column: Column, eventSource: any): void
    }
    declare class TemplateService {
        templateCache: any;
        waitingCallbacks: any;
        $scope: any;
        init($scope: any): void;
        getTemplate(url: any, callback: any): any;
        handleHttpResult(httpResult: any, url: any): void
    }
    declare class SelectionRendererFactory {
        init(angularGrid: any, selectionController: any): void;
        createSelectionCheckbox(node: any, rowIndex: any): HTMLInputElement
    }
    declare class RenderedCell {
        constructor(isFirstColumn: any, column: any, $compile: any, rowRenderer: RowRenderer, gridOptionsWrapper: GridOptionsWrapper, expressionService: ExpressionService, selectionRendererFactory: SelectionRendererFactory, selectionController: SelectionController, templateService: TemplateService, cellRendererMap: {
            [key: string]: any
        }, node: any, rowIndex: number, scope: any, columnController: ColumnController, valueService: ValueService, eventService: EventService): this;
        getColumn(): Column;
        getVGridCell(): undefined.VHtmlElement;
        startEditing(key?: number): void;
        focusCell(forceBrowserFocus: boolean): void;
        createParams(): any;
        createEvent(event: any, eventSource: any): any;
        isCellEditable(): any;
        createSelectionCheckbox(): void;
        setSelected(state: boolean): void;
        isVolatile(): boolean;
        refreshCell(): void
    }
    declare class RenderedRow {
        vPinnedRow: any;
        vBodyRow: any;
        constructor(gridOptionsWrapper: GridOptionsWrapper, valueService: ValueService, parentScope: any, angularGrid: Grid, columnController: ColumnController, expressionService: ExpressionService, cellRendererMap: {
            [key: string]: any
        }, selectionRendererFactory: SelectionRendererFactory, $compile: any, templateService: TemplateService, selectionController: SelectionController, rowRenderer: RowRenderer, eBodyContainer: HTMLElement, ePinnedContainer: HTMLElement, node: any, rowIndex: number, eventService: EventService): this;
        onRowSelected(selected: boolean): void;
        softRefresh(): void;
        getRenderedCellForColumn(column: Column): RenderedCell;
        getCellForCol(column: Column): any;
        destroy(): void;
        isDataInList(rows: any[]): boolean;
        isNodeInList(nodes: RowNode[]): boolean;
        isGroup(): boolean;
        setMainRowWidth(width: number): void;
        getRowNode(): any;
        getRowIndex(): any;
        refreshCells(colIds: string[]): void
    }
    declare class SvgFactory {
        theInstance: SvgFactory;
        getInstance(): SvgFactory;
        createFilterSvg(): Element;
        createColumnShowingSvg(): Element;
        createColumnHiddenSvg(): Element;
        createMenuSvg(): Element;
        createArrowUpSvg(): Element;
        createArrowLeftSvg(): Element;
        createArrowDownSvg(): Element;
        createArrowRightSvg(): Element;
        createSmallArrowDownSvg(): Element;
        createArrowUpDownSvg(): Element
    }
    declare     function groupCellRendererFactory(
        gridOptionsWrapper: GridOptionsWrapper,
        selectionRendererFactory: SelectionRendererFactory,
        expressionService: ExpressionService): (params: any) => HTMLSpanElement
    declare class RowRenderer {
        init(
            columnModel: any,
            gridOptionsWrapper: GridOptionsWrapper,
            gridPanel: GridPanel,
            angularGrid: Grid,
            selectionRendererFactory: SelectionRendererFactory,
            $compile: any,
            $scope: any,
            selectionController: SelectionController,
            expressionService: ExpressionService,
            templateService: TemplateService,
            valueService: ValueService,
            eventService: EventService): void;
        setRowModel(rowModel: any): void;
        onIndividualColumnResized(column: Column): void;
        setMainRowWidths(): void;
        refreshAllFloatingRows(): void;
        refreshView(refreshFromIndex?: any): void;
        softRefreshView(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshGroupRows(): void;
        drawVirtualRows(): void;
        getFirstVirtualRenderedRow(): number;
        getLastVirtualRenderedRow(): number;
        getRenderedNodes(): any[];
        getIndexOfRenderedNode(node: any): number;
        navigateToNextCell(key: any, rowIndex: number, column: Column): void;
        onRowSelected(rowIndex: number, selected: boolean): void;
        focusCell(
            eCell: any,
            rowIndex: number,
            colIndex: number,
            colDef: ColDef,
            forceBrowserFocus: any): void;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        startEditingNextCell(rowIndex: any, column: any, shiftKey: any): void
    }
    declare class SelectionController {
        init(
            angularGrid: Grid,
            gridPanel: GridPanel,
            gridOptionsWrapper: GridOptionsWrapper,
            $scope: any,
            rowRenderer: RowRenderer,
            eventService: EventService): void;
        getSelectedNodesById(): any;
        getSelectedRows(): any;
        getSelectedNodes(): any;
        getBestCostNodeSelection(): any;
        setRowModel(rowModel: any): void;
        deselectAll(): void;
        selectAll(): void;
        selectNode(node: any, tryMulti: any, suppressEvents?: any): void;
        deselectIndex(rowIndex: any): void;
        deselectNode(node: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents?: any): void;
        isNodeSelected(node: any): boolean
    }
    declare class RenderedHeaderElement {
        constructor(eRoot: HTMLElement): this;
        getERoot(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: Column): void;
        addDragHandler(eDraggableElement: any): void;
        stopDragging(listenersToRemove: any): void
    }
    declare class RenderedHeaderCell mixins RenderedHeaderElement {
        constructor(column: Column, parentGroup: RenderedHeaderGroupCell, gridOptionsWrapper: GridOptionsWrapper, parentScope: any, filterManager: FilterManager, columnController: ColumnController, $compile: any, angularGrid: Grid, eRoot: HTMLElement): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onDragStart(): void;
        onDragging(dragChange: number): void;
        onIndividualColumnResized(column: Column): void
    }
    declare class RenderedHeaderGroupCell mixins RenderedHeaderElement {
        constructor(columnGroup: ColumnGroup, gridOptionsWrapper: GridOptionsWrapper, columnController: ColumnController, eRoot: HTMLElement, angularGrid: Grid, parentScope: any, filterManager: FilterManager, $compile: any): this;
        getGui(): HTMLElement;
        destroy(): void;
        refreshFilterIcon(): void;
        refreshSortIcon(): void;
        onIndividualColumnResized(column: Column): void;
        onDragStart(): void;
        onDragging(dragChange: any): void
    }
    declare class HeaderRenderer {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            gridPanel: GridPanel,
            angularGrid: Grid,
            filterManager: FilterManager,
            $scope: any,
            $compile: any): void;
        refreshHeader(): void;
        updateSortIcons(): void;
        updateFilterIcons(): void;
        onIndividualColumnResized(column: Column): void
    }
    declare class GroupCreator {
        init(valueService: ValueService): void;
        group(rowNodes: RowNode[], groupedCols: Column[], expandByDefault: any): RowNode[];
        isExpanded(expandByDefault: any, level: any): boolean
    }
    declare class InMemoryRowController {
        constructor(): this;
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnController: ColumnController,
            angularGrid: any,
            filterManager: FilterManager,
            $scope: any,
            groupCreator: GroupCreator,
            valueService: ValueService,
            eventService: EventService): void;
        getModel(): any;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        updateModel(step: any): void;
        doAggregate(): void;
        expandOrCollapseAll(expand: boolean, rowNodes: RowNode[]): void;
        onPivotChanged(): void;
        setAllRows(rows: RowNode[], firstId?: number): void
    }
    declare class VirtualPageRowController {
        rowRenderer: any;
        datasourceVersion: any;
        gridOptionsWrapper: any;
        angularGrid: any;
        datasource: any;
        virtualRowCount: any;
        foundMaxRow: any;
        pageCache: any;
        pageCacheSize: any;
        pageLoadsInProgress: any;
        pageLoadsQueued: any;
        pageAccessTimes: any;
        accessTime: any;
        maxConcurrentDatasourceRequests: any;
        maxPagesInCache: any;
        pageSize: any;
        overflowSize: any;
        init(rowRenderer: any, gridOptionsWrapper: any, angularGrid: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        createNodesFromRows(pageNumber: any, rows: any): any;
        removeFromLoading(pageNumber: any): void;
        pageLoadFailed(pageNumber: any): void;
        pageLoaded(pageNumber: any, rows: any, lastRow: any): void;
        putPageIntoCacheAndPurge(pageNumber: any, rows: any): void;
        checkMaxRowAndInformRowRenderer(pageNumber: any, lastRow: any): void;
        isPageAlreadyLoading(pageNumber: any): boolean;
        doLoadOrQueue(pageNumber: any): void;
        addToQueueAndPurgeQueue(pageNumber: any): void;
        findLeastRecentlyAccessedPage(pageIndexes: any): number;
        checkQueueForNextLoad(): void;
        loadPage(pageNumber: any): void;
        requestIsDaemon(datasourceVersionCopy: any): boolean;
        getVirtualRow(rowIndex: any): any;
        forEachNode(callback: any): void;
        getModel(): {
            getVirtualRow: (index: any) => any,
            getVirtualRowCount: () => any,
            forEachInMemory: (callback: any) => void,
            forEachNode: (callback: any) => void,
            forEachNodeAfterFilter: (callback: any) => void,
            forEachNodeAfterFilterAndSort: (callback: any) => void
        }
    }
    declare class PaginationController {
        eGui: any;
        btNext: any;
        btPrevious: any;
        btFirst: any;
        btLast: any;
        lbCurrent: any;
        lbTotal: any;
        lbRecordCount: any;
        lbFirstRowOnPage: any;
        lbLastRowOnPage: any;
        ePageRowSummaryPanel: any;
        angularGrid: any;
        callVersion: any;
        gridOptionsWrapper: any;
        datasource: any;
        pageSize: any;
        rowCount: any;
        foundMaxRow: any;
        totalPages: any;
        currentPage: any;
        init(angularGrid: any, gridOptionsWrapper: any): void;
        setDatasource(datasource: any): void;
        reset(): void;
        setTotalLabels(): void;
        calculateTotalPages(): void;
        pageLoaded(rows: any, lastRowIndex: any): void;
        updateRowLabels(): void;
        loadPage(): void;
        isCallDaemon(versionCopy: any): boolean;
        onBtNext(): void;
        onBtPrevious(): void;
        onBtFirst(): void;
        onBtLast(): void;
        isZeroPagesToDisplay(): boolean;
        enableOrDisableButtons(): void;
        createTemplate(): string;
        getGui(): any;
        setupComponents(): void
    }
    declare class BorderLayout {
        constructor(params: any): this;
        addSizeChangeListener(listener: Function): void;
        fireSizeChanged(): void;
        getGui(): any;
        doLayout(): boolean;
        getCentreHeight(): number;
        setEastVisible(visible: any): void;
        setOverlayVisible(visible: any): void;
        setSouthVisible(visible: any): void
    }
    declare class GridPanel {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            columnModel: ColumnController,
            rowRenderer: RowRenderer,
            masterSlaveService: MasterSlaveService): void;
        getLayout(): BorderLayout;
        getPinnedFloatingTop(): HTMLElement;
        getFloatingTopContainer(): HTMLElement;
        getPinnedFloatingBottom(): HTMLElement;
        getFloatingBottomContainer(): HTMLElement;
        ensureIndexVisible(index: any): void;
        ensureColIndexVisible(index: any): void;
        showLoading(loading: any): void;
        getWidthForSizeColsToFit(): number;
        setRowModel(rowModel: any): void;
        getBodyContainer(): HTMLElement;
        getBodyViewport(): HTMLElement;
        getPinnedColsContainer(): HTMLElement;
        getHeaderContainer(): HTMLElement;
        getRoot(): HTMLElement;
        getPinnedHeader(): HTMLElement;
        getRowsParent(): HTMLElement[];
        setBodyContainerWidth(): void;
        setPinnedColContainerWidth(): void;
        showPinnedColContainersIfNeeded(): void;
        onBodyHeightChange(): void;
        setHorizontalScrollPosition(hScrollPosition: number): void
    }
    declare class DragAndDropService {
        theInstance: DragAndDropService;
        getInstance(): DragAndDropService;
        dragItem: any;
        constructor(): this;
        stopDragging(): void;
        setDragCssClasses(eListItem: any, dragging: any): void;
        addDragSource(eDragSource: any, dragSourceCallback: any): void;
        onMouseDownDragSource(eDragSource: any, dragSourceCallback: any): void;
        addDropTarget(eDropTarget: any, dropTargetCallback: any): void
    }
    declare class AgList {
        constructor(): this;
        setReadOnly(readOnly: boolean): void;
        setEmptyMessage(emptyMessage: any): void;
        getUniqueId(): any;
        addStyles(styles: any): void;
        addCssClass(cssClass: any): void;
        addDragSource(dragSource: any): void;
        addModelChangedListener(listener: Function): void;
        addItemSelectedListener(listener: any): void;
        addItemMovedListener(listener: any): void;
        addBeforeDropListener(listener: any): void;
        setModel(model: any): void;
        getModel(): any;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        getGui(): any
    }
    declare class ColumnSelectionPanel {
        layout: any;
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        getDragSource(): any;
        getGui(): any
    }
    declare class GroupSelectionPanel {
        gridOptionsWrapper: any;
        columnController: ColumnController;
        inMemoryRowController: any;
        cColumnList: any;
        layout: any;
        constructor(columnController: ColumnController, inMemoryRowController: any, gridOptionsWrapper: GridOptionsWrapper, eventService: EventService): this;
        addDragSource(dragSource: any): void
    }
    declare class AgDropdownList {
        constructor(popupService: PopupService): this;
        setWidth(width: any): void;
        addItemSelectedListener(listener: any): void;
        fireItemSelected(item: any): void;
        setupComponents(): void;
        itemSelected(item: any): void;
        onClick(): void;
        getGui(): any;
        setSelected(item: any): void;
        setCellRenderer(cellRenderer: any): void;
        refreshView(): void;
        setModel(model: any): void
    }
    declare class ValuesSelectionPanel {
        constructor(columnController: ColumnController, gridOptionsWrapper: GridOptionsWrapper, popupService: PopupService, eventService: EventService): this;
        getLayout(): any;
        addDragSource(dragSource: any): void
    }
    declare class VerticalStack {
        isLayoutPanel: any;
        childPanels: any;
        eGui: any;
        constructor(): this;
        addPanel(panel: any, height: any): void;
        getGui(): any;
        doLayout(): void
    }
    declare class ToolPanel {
        layout: any;
        constructor(): this;
        init(
            columnController: any,
            inMemoryRowController: any,
            gridOptionsWrapper: GridOptionsWrapper,
            popupService: PopupService,
            eventService: EventService): void
    }
    declare interface GridOptions {
        virtualPaging?: boolean,
            toolPanelSuppressPivot?: boolean,
            toolPanelSuppressValues?: boolean,
            rowsAlreadyGrouped?: boolean,
            suppressRowClickSelection?: boolean,
            suppressCellSelection?: boolean,
            sortingOrder?: string[],
            suppressMultiSort?: boolean,
            suppressHorizontalScroll?: boolean,
            unSortIcon?: boolean,
            rowHeight?: number,
            rowBuffer?: number,
            enableColResize?: boolean,
            enableCellExpressions?: boolean,
            enableSorting?: boolean,
            enableServerSideSorting?: boolean,
            enableFilter?: boolean,
            enableServerSideFilter?: boolean,
            colWidth?: number,
            suppressMenuHide?: boolean,
            singleClickEdit?: boolean,
            debug?: boolean,
            icons?: any,
            angularCompileRows?: boolean,
            angularCompileFilters?: boolean,
            angularCompileHeaders?: boolean,
            localeText?: any,
            localeTextFunc?: Function,
            suppressScrollLag?: boolean,
            groupSuppressAutoColumn?: boolean,
            groupSelectsChildren?: boolean,
            groupHidePivotColumns?: boolean,
            groupIncludeFooter?: boolean,
            groupUseEntireRow?: boolean,
            groupSuppressRow?: boolean,
            groupSuppressBlankHeader?: boolean,
            forPrint?: boolean,
            groupColumnDef?: any,
            context?: any,
            rowStyle?: any,
            rowClass?: any,
            groupDefaultExpanded?: any,
            slaveGrids?: GridOptions[],
            rowSelection?: string,
            rowDeselection?: boolean,
            rowData?: any[],
            floatingTopRowData?: any[],
            floatingBottomRowData?: any[],
            showToolPanel?: boolean,
            groupKeys?: string[],
            groupAggFields?: string[],
            columnDefs?: any[],
            datasource?: any,
            pinnedColumnCount?: number,
            groupHeaders?: boolean,
            headerHeight?: number,
            groupRowInnerRenderer(params: any): void,
            groupRowRenderer?: Function | Object,
            isScrollLag(): boolean,
            isExternalFilterPresent(): boolean,
            doesExternalFilterPass(node: RowNode): boolean,
            getRowStyle?: any,
            getRowClass?: any,
            headerCellRenderer?: any,
            groupAggFunction(nodes: any[]): any,
            onReady(api: any): void,
            onModelUpdated(): void,
            onCellClicked(params: any): void,
            onCellDoubleClicked(params: any): void,
            onCellContextMenu(params: any): void,
            onCellValueChanged(params: any): void,
            onCellFocused(params: any): void,
            onRowSelected(params: any): void,
            onSelectionChanged(): void,
            onBeforeFilterChanged(): void,
            onAfterFilterChanged(): void,
            onFilterModified(): void,
            onBeforeSortChanged(): void,
            onAfterSortChanged(): void,
            onVirtualRowRemoved(params: any): void,
            onRowClicked(params: any): void,
            api?: GridApi,
            columnApi?: ColumnApi
    }
    declare class GridApi {
        constructor(grid: Grid, rowRenderer: RowRenderer, headerRenderer: HeaderRenderer, filterManager: FilterManager, columnController: ColumnController, inMemoryRowController: InMemoryRowController, selectionController: SelectionController, gridOptionsWrapper: GridOptionsWrapper, gridPanel: GridPanel, valueService: ValueService, masterSlaveService: MasterSlaveService, eventService: EventService): this;

        /**
         * Used internally by grid. Not intended to be used by the client. Interface may change between releases. 
         */
        ___getMasterSlaveService(): MasterSlaveService;
        getDataAsCsv(params?: CsvExportParams): string;
        exportDataAsCsv(params?: CsvExportParams): void;
        setDatasource(datasource: any): void;
        onNewDatasource(): void;
        setRowData(rowData: any): void;
        setRows(rows: any): void;
        onNewRows(): void;
        setFloatingTopRowData(rows: any[]): void;
        setFloatingBottomRowData(rows: any[]): void;
        onNewCols(): void;
        setColumnDefs(colDefs: ColDef[]): void;
        unselectAll(): void;
        refreshRows(rowNodes: RowNode[]): void;
        refreshCells(rowNodes: RowNode[], colIds: string[]): void;
        rowDataChanged(rows: any): void;
        refreshView(): void;
        softRefreshView(): void;
        refreshGroupRows(): void;
        refreshHeader(): void;
        isAnyFilterPresent(): boolean;
        isAdvancedFilterPresent(): boolean;
        isQuickFilterPresent(): boolean;
        getModel(): any;
        onGroupExpandedOrCollapsed(refreshFromIndex: any): void;
        expandAll(): void;
        collapseAll(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        setQuickFilter(newFilter: any): void;
        selectIndex(index: any, tryMulti: any, suppressEvents: any): void;
        deselectIndex(index: any): void;
        selectNode(node: any, tryMulti: any, suppressEvents: any): void;
        deselectNode(node: any): void;
        selectAll(): void;
        deselectAll(): void;
        recomputeAggregates(): void;
        sizeColumnsToFit(): void;
        showLoading(show: any): void;
        isNodeSelected(node: any): boolean;
        getSelectedNodesById(): {
            [nodeId: number]: RowNode
        };
        getSelectedNodes(): RowNode[];
        getSelectedRows(): any[];
        getBestCostNodeSelection(): any;
        getRenderedNodes(): any[];
        ensureColIndexVisible(index: any): void;
        ensureIndexVisible(index: any): void;
        ensureNodeVisible(comparator: any): void;
        forEachInMemory(callback: Function): void;
        forEachNode(callback: Function): void;
        forEachNodeAfterFilter(callback: Function): void;
        forEachNodeAfterFilterAndSort(callback: Function): void;
        getFilterApiForColDef(colDef: any): any;
        getFilterApi(key: any): any;
        getColumnDef(key: any): ColDef;
        onFilterChanged(): void;
        setSortModel(sortModel: any): void;
        getSortModel(): any;
        setFilterModel(model: any): void;
        getFilterModel(): any;
        getFocusedCell(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        setHeaderHeight(headerHeight: number): void;
        setGroupHeaders(groupHeaders: boolean): void;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        hideColumn(colId: any, hide: any): void;
        hideColumns(colIds: any, hide: any): void;
        getColumnState(): [any];
        setColumnState(state: any): void;
        doLayout(): void;
        getValue(colDef: ColDef, data: any, node: any): any;
        addEventListener(eventType: string, listener: Function): void;
        addGlobalListener(listener: Function): void;
        removeEventListener(eventType: string, listener: Function): void;
        removeGlobalListener(listener: Function): void;
        refreshPivot(): void
    }
    declare class ValueService {
        init(
            gridOptionsWrapper: GridOptionsWrapper,
            expressionService: ExpressionService,
            columnController: ColumnController): void;
        getValue(colDef: ColDef, data: any, node: any): any
    }
    declare class Grid {
        constructor(eGridDiv: any, gridOptions: any, globalEventListener?: Function, $scope?: any, $compile?: any, quickFilterOnScope?: any): this;
        getRowModel(): any;
        refreshPivot(): void;
        getEventService(): EventService;
        showToolPanel(show: any): void;
        isToolPanelShowing(): boolean;
        isUsingInMemoryModel(): boolean;
        setDatasource(datasource?: any): void;
        setFinished(): void;
        onQuickFilterChanged(newFilter: any): void;
        onFilterModified(): void;
        onFilterChanged(): void;
        onRowClicked(event: any, rowIndex: any, node: any): void;
        showLoadingPanel(show: any): void;
        updateModelAndRefresh(step: any, refreshFromIndex?: any): void;
        setRows(rows?: any, firstId?: any): void;
        ensureNodeVisible(comparator: any): void;
        getFilterModel(): any;
        setFocusedCell(rowIndex: any, colIndex: any): void;
        getSortModel(): any;
        setSortModel(sortModel: any): void;
        onSortingChanged(): void;
        addVirtualRowListener(rowIndex: any, callback: any): void;
        onVirtualRowSelected(rowIndex: any, selected: any): void;
        onVirtualRowRemoved(rowIndex: any): void;
        setColumnDefs(colDefs?: ColDef[]): void;
        updateBodyContainerWidthAfterColResize(): void;
        updatePinnedColContainerWidthAfterColResize(): void;
        doLayout(): void
    }
    declare class ComponentUtil {
        SIMPLE_PROPERTIES: string[];
        SIMPLE_NUMBER_PROPERTIES: string[];
        SIMPLE_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_NUMBER_PROPERTIES: string[];
        WITH_IMPACT_BOOLEAN_PROPERTIES: string[];
        WITH_IMPACT_OTHER_PROPERTIES: string[];
        CALLBACKS: string[];
        ALL_PROPERTIES: string[];
        copyAttributesToGridOptions(gridOptions: GridOptions, component: any): GridOptions;
        processOnChange(changes: any, gridOptions: GridOptions, component: any): void;
        toBoolean(value: any): boolean;
        toNumber(value: any): number
    }
    declare class AgGridNg2 {
        modelUpdated: any;
        cellClicked: any;
        cellDoubleClicked: any;
        cellContextMenu: any;
        cellValueChanged: any;
        cellFocused: any;
        rowSelected: any;
        selectionChanged: any;
        beforeFilterChanged: any;
        afterFilterChanged: any;
        filterModified: any;
        beforeSortChanged: any;
        afterSortChanged: any;
        virtualRowRemoved: any;
        rowClicked: any;
        ready: any;
        columnEverythingChanged: any;
        columnPivotChanged: any;
        columnValueChanged: any;
        columnMoved: any;
        columnVisible: any;
        columnGroupOpened: any;
        columnResized: any;
        columnPinnedCountChanged: any;
        virtualPaging: boolean;
        toolPanelSuppressPivot: boolean;
        toolPanelSuppressValues: boolean;
        rowsAlreadyGrouped: boolean;
        suppressRowClickSelection: boolean;
        suppressCellSelection: boolean;
        sortingOrder: string[];
        suppressMultiSort: boolean;
        suppressHorizontalScroll: boolean;
        unSortIcon: boolean;
        rowHeight: number;
        rowBuffer: number;
        enableColResize: boolean;
        enableCellExpressions: boolean;
        enableSorting: boolean;
        enableServerSideSorting: boolean;
        enableFilter: boolean;
        enableServerSideFilter: boolean;
        colWidth: number;
        suppressMenuHide: boolean;
        debug: boolean;
        icons: any;
        angularCompileRows: boolean;
        angularCompileFilters: boolean;
        angularCompileHeaders: boolean;
        localeText: any;
        localeTextFunc: Function;
        groupSuppressAutoColumn: boolean;
        groupSelectsChildren: boolean;
        groupHidePivotColumns: boolean;
        groupIncludeFooter: boolean;
        groupUseEntireRow: boolean;
        groupSuppressRow: boolean;
        groupSuppressBlankHeader: boolean;
        groupColumnDef: any;
        forPrint: boolean;
        context: any;
        rowStyle: any;
        rowClass: any;
        headerCellRenderer: any;
        groupDefaultExpanded: any;
        slaveGrids: GridOptions[];
        rowSelection: string;
        rowDeselection: boolean;
        rowData: any[];
        floatingTopRowData: any[];
        floatingBottomRowData: any[];
        showToolPanel: boolean;
        groupKeys: string[];
        groupAggFunction: (nodes: any[]) => void;
        groupAggFields: string[];
        columnDefs: any[];
        datasource: any;
        pinnedColumnCount: number;
        quickFilterText: string;
        groupHeaders: boolean;
        headerHeight: number;
        constructor(elementDef: any): this;
        onInit(): void;
        onChange(changes: any): void
    }
    declare interface Filter {
        getGui(): any,
            isFilterActive(): boolean,
            doesFilterPass(params: any): boolean,
            afterGuiAttached(params?: {
                hidePopup?: Function
            }): void,
            onNewRowsLoaded(): void
    }
}
declare var exports: any;
declare var module: any;
declare module 'agenda' {


    declare type Callback = (err: Error) => any;
    declare interface ResultCallback<T>{
        (err?: Error, result?: T): void
    }
    declare module.exports: typeof Agenda

    /**
     * Agenda Configuration.
     */
    declare interface Agenda$AgendaConfiguration {

        /**
         * Sets the interval with which the queue is checked. A number in milliseconds or a frequency string.
         */
        processEvery?: string | number,

            /**
             * Takes a number which specifies the default number of a specific job that can be running at any given moment.
             * By default it is 5.
             */
            defaultConcurrency?: number,

            /**
             * Takes a number which specifies the max number of jobs that can be running at any given moment. By default it
             * is 20.
             */
            maxConcurrency?: number,

            /**
             * Takes a number which specifies the default number of a specific job that can be locked at any given moment.
             * By default it is 0 for no max.
             */
            defaultLockLimit?: number,

            /**
             * Takes a number shich specifies the max number jobs that can be locked at any given moment. By default it is
             * 0 for no max.
             */
            lockLimit?: number,

            /**
             * Takes a number which specifies the default lock lifetime in milliseconds. By default it is 10 minutes. This
             * can be overridden by specifying the lockLifetime option to a defined job.
             */
            defaultLockLifetime?: number,

            /**
             * Specifies that Agenda should be initialized using and existing MongoDB connection.
             */
            mongo?: {

                /**
                 * The MongoDB database connection to use.
                 */
                db: Db,

                /**
                 * The name of the collection to use.
                 */
                collection?: string
            },

            /**
             * Specifies that Agenda should connect to MongoDB.
             */
            db?: {

                /**
                 * The connection URL.
                 */
                address: string,

                /**
                 * The name of the collection to use.
                 */
                collection?: string,

                /**
                 * Connection options to pass to MongoDB.
                 */
                options?: any
            }
    }


    /**
     * The database record associated with a job.
     */
    declare interface Agenda$JobAttributes {

        /**
         * The record identity.
         */
        _id: ObjectID,

            /**
             * The name of the job.
             */
            name: string,

            /**
             * The type of the job (single|normal).
             */
            type: string,

            /**
             * The job details.
             */
            data: {
                [name: string]: any
            },

            /**
             * The priority of the job.
             */
            priority: number,

            /**
             * How often the job is repeated using a human-readable or cron format.
             */
            repeatInterval: string | number,

            /**
             * The timezone that conforms to [moment-timezone](http://momentjs.com/timezone/).
             */
            repeatTimezone: string,

            /**
             * Date/time the job was las modified.
             */
            lastModifiedBy: string,

            /**
             * Date/time the job will run next.
             */
            nextRunAt: Date,

            /**
             * Date/time the job was locked.
             */
            lockedAt: Date,

            /**
             * Date/time the job was last run.
             */
            lastRunAt: Date,

            /**
             * Date/time the job last finished running.
             */
            lastFinishedAt: Date,

            /**
             * The reason the job failed.
             */
            failReason: string,

            /**
             * The number of times the job has failed.
             */
            failCount: number,

            /**
             * The date/time the job last failed.
             */
            failedAt: Date,

            /**
             * Job's state
             */
            disabled: boolean
    }


    /**
     * A scheduled job.
     */
    declare interface Agenda$Job {

        /**
         * The database record associated with the job.
         */
        attrs: Agenda$JobAttributes,

            /**
             * Specifies an interval on which the job should repeat.
             * @param interval A human-readable format String, a cron format String, or a Number.
             * @param options An optional argument that can include a timezone field. The timezone should be a string as
            accepted by moment-timezone and is considered when using an interval in the cron string format.
            */
            repeatEvery(interval: string | number, options?: {
                timezone?: string
            }): Agenda$Job,

            /**
             * Specifies a time when the job should repeat. [Possible values](https://github.com/matthewmueller/date#examples).
             * @param time 
             */
            repeatAt(time: string): Agenda$Job,

            /**
             * Disables the job.
             */
            disable(): Agenda$Job,

            /**
             * Enables the job.
             */
            enable(): Agenda$Job,

            /**
             * Ensure that only one instance of this job exists with the specified properties
             * @param value The properties associated with the job that must be unqiue.
             * @param opts 
             */
            unique(value: any, opts?: {
                insertOnly?: boolean
            }): Agenda$Job,

            /**
             * Specifies the next time at which the job should run.
             * @param time The next time at which the job should run.
             */
            schedule(time: string | Date): Agenda$Job,

            /**
             * Specifies the priority weighting of the job.
             * @param value The priority of the job (lowest|low|normal|high|highest|number).
             */
            priority(value: string | number): Agenda$Job,

            /**
             * Sets job.attrs.failedAt to now, and sets job.attrs.failReason to reason.
             * @param reason A message or Error object that indicates why the job failed.
             */
            fail(reason: string | Error): Agenda$Job,

            /**
             * Runs the given job and calls callback(err, job) upon completion. Normally you never need to call this manually
             * @param cb Called when the job is completed.
             */
            run(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Returns true if the job is running; otherwise, returns false.
             */
            isRunning(): boolean,

            /**
             * Saves the job into the database.
             * @param cb Called when the job is saved.
             */
            save(cb?: ResultCallback<Agenda$Job>): Agenda$Job,

            /**
             * Removes the job from the database and cancels the job.
             * @param cb Called after the job has beeb removed from the database.
             */
            remove(cb?: Callback): void,

            /**
             * Resets the lock on the job. Useful to indicate that the job hasn't timed out when you have very long running
             * jobs.
             * @param cb Called after the job has been saved to the database.
             */
            touch(cb?: Callback): void,

            /**
             * Calculates next time the job should run
             */
            computeNextRunAt(): Agenda$Job
    }

    declare interface Agenda$JobOptions {

        /**
         * Maximum number of that job that can be running at once (per instance of agenda)
         */
        concurrency?: number,

            /**
             * Maximum number of that job that can be locked at once (per instance of agenda)
             */
            lockLimit?: number,

            /**
             * Interval in ms of how long the job stays locked for (see multiple job processors for more info). A job will
             * automatically unlock if done() is called.
             */
            lockLifetime?: number,

            /**
             * (lowest|low|normal|high|highest|number) specifies the priority of the job. Higher priority jobs will run
             * first.
             */
            priority?: string | number
    }
}
declare module 'ajv' {
    declare module.exports: typeof Ajv
    declare type Ajv$AjvOptions = {
        v5?: boolean,
        allErrors?: boolean,
        verbose?: boolean,
        jsonPointers?: boolean,
        uniqueItems?: boolean,
        unicode?: boolean,
        format?: string,
        formats?: any,
        schemas?: any,
        missingRefs?: boolean,
        loadSchema(uri: string, callback: (error: Error, body: any) => void): void,
        removeAdditional?: boolean,
        useDefaults?: boolean,
        coerceTypes?: boolean,
        async?: any,
        transpile?: string,
        meta?: boolean,
        validateSchema?: boolean,
        addUsedSchema?: boolean,
        inlineRefs?: boolean,
        passContext?: boolean,
        loopRequired?: number,
        ownProperties?: boolean,
        multipleOfPrecision?: boolean | number,
        errorDataPath?: string,
        messages?: boolean,
        beautify?: boolean,
        cache?: any
    };

    declare type Ajv$AjvValidate = ((data: any) => boolean | PromiseLike<boolean>) & {
        errors: Ajv$ValidationError[]
    };

    declare type Ajv$AjxKeywordDefinition = {
        async?: boolean,
        type: string,
        compile?: (
            schema: any,
            parentsSchema: any) => ((data: any) => boolean | PromiseLike<boolean>),
        validate?: (schema: any, data: any) => boolean
    };

    declare type Ajv$ValidationError = {
        keyword: string,
        dataPath: string,
        schemaPath: string,
        params: any,
        message: string,
        schema: any,
        parentSchema: any,
        data: any
    };
}
declare var alertify: alertify$IAlertifyStatic;
declare interface alertify$IAlertifyStatic {

    /**
     * Create an alert dialog box
     * @param message The message passed from the callee
     * @param fn Callback function
     * @param cssClass Class(es) to append to dialog box
     * @return  alertify (ie this)
     * @since  0.0.1
     */
    alert(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Create a confirm dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param cssClass Class(es) to append to dialog box
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        confirm(message: string, fn?: Function, cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Extend the log method to create custom methods
         * @param type Custom method name
         * @return  function for logging
         * @since  0.0.1
         */
        extend(type: string): (message: string, wait?: number) => alertify$IAlertifyStatic,

        /**
         * Initialize Alertify and create the 2 main elements.
         * Initialization will happen automatically on the first
        use of alert, confirm, prompt or log.
         * @since  0.0.1
        */
        init(): void,

        /**
         * Show a new log message box
         * @param message The message passed from the callee
         * @param type Optional type of log message
         * @param wait Optional time (in ms) to wait before auto-hiding
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        log(message: string, type?: string, wait?: number): alertify$IAlertifyStatic,

        /**
         * Create a prompt dialog box
         * @param message The message passed from the callee
         * @param fn Callback function
         * @param placeholder Default value for prompt input
         * @param cssClass Class(es) to append to dialog
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        prompt(
            message: string,
            fn?: Function,
            placeholder?: string,
            cssClass?: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        success(message: string): alertify$IAlertifyStatic,

        /**
         * Shorthand for log messages
         * @param message The message passed from the callee
         * @return  alertify (ie this)
         * @since  0.0.1
         */
        error(message: string): alertify$IAlertifyStatic,

        /**
         * Used to set alertify properties
         * @param Properties 
         * @since  0.2.11
         */
        set(args: alertify$IProperties): void,

        /**
         * The labels used for dialog buttons
         */
        labels: alertify$ILabels,

        /**
         * Attaches alertify.error to window.onerror method
         * @since  0.3.8
         */
        debug(): void
}


/**
 * Properties for alertify.set function
 */
declare interface alertify$IProperties {

    /**
     * Default value for milliseconds display of log messages 
     */
    delay?: number,

        /**
         * Default values for display of labels 
         */
        labels?: alertify$ILabels,

        /**
         * Default button for focus 
         */
        buttonFocus?: string,

        /**
         * Should buttons be displayed in reverse order 
         */
        buttonReverse?: boolean
}


/**
 * Labels for altertify.set function 
 */
declare interface alertify$ILabels {
    ok?: string,
        cancel?: string
}
declare module 'alexa-sdk' {
    declare     export function handler(event: RequestBody, context: Context, callback?: Function): AlexaObject
    declare     export function CreateStateHandler(state: string, obj: any): any
    declare     export var StateString: string;
    declare interface AlexaObject {
        _event: any,
            _context: any,
            _callback: any,
            state: any,
            appId: any,
            response: any,
            dynamoDBTableName: any,
            saveBeforeResponse: boolean,
            registerHandlers: (...handlers: Handlers[]) => any,
            execute: () => void
    }
    declare interface Handlers {
        [intent: string]: () => void
    }
    declare interface Handler {
        on: any,
            emit(event: string, ...args: any[]): boolean,
            emitWithState: any,
            state: any,
            handler: any,
            event: RequestBody,
            attributes: any,
            context: any,
            name: any,
            isOverriden: any
    }
    declare interface Context {
        callbackWaitsForEmptyEventLoop: boolean,
            logGroupName: string,
            logStreamName: string,
            functionName: string,
            memoryLimitInMB: string,
            functionVersion: string,
            invokeid: string,
            awsRequestId: string
    }
    declare interface RequestBody {
        version: string,
            session: Session,
            request: LaunchRequest | IntentRequest | SessionEndedRequest
    }
    declare interface Session {
        new: boolean,
        sessionId: string,
            attributes: any,
            application: SessionApplication,
            user: SessionUser
    }
    declare interface SessionApplication {
        applicationId: string
    }
    declare interface SessionUser {
        userId: string,
            accessToken: string
    }
    declare type LaunchRequest = {} & IRequest

    declare type IntentRequest = {
        intent: Intent
    } & IRequest

    declare interface Intent {
        name: string,
            slots: any
    }
    declare type SessionEndedRequest = {
        reason: string
    } & IRequest

    declare interface IRequest {
        type: "LaunchRequest" | "IntentRequest" | "SessionEndedRequest",
            requestId: string,
            timeStamp: string
    }
    declare interface ResponseBody {
        version: string,
            sessionAttributes?: any,
            response: Response
    }
    declare     export type Response = {
        request_seq: number,
        success: boolean,

        /**
         * Contains error message if success === false. 
         */
        message?: string,

        /**
         * Contains message body if success === true. 
         */
        body?: any
    } & Message

    declare interface OutputSpeech {
        type: "PlainText" | "SSML",
            text?: string,
            ssml?: string
    }
    declare interface Card {
        type: "Simple" | "Standard" | "LinkAccount",
            title?: string,
            content?: string,
            text?: string,
            image?: Image
    }
    declare interface Image {
        smallImageUrl: string,
            largeImageUrl: string
    }
    declare interface Reprompt {
        outputSpeech: OutputSpeech
    }
}
declare interface AlgoliaResponse {

    /**
     * Contains all the hits matching the query
     * https://github.com/algolia/algoliasearch-client-js#response-format
     */
    hits: any[],

        /**
         * Current page
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        page: number,

        /**
         * Number of total hits matching the query
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        nbHits: number,

        /**
         * Number of pages
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        nbPage: number,

        /**
         * Number of hits per pages
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        hitsPerPage: number,

        /**
         * Engine processing time (excluding network transfer)
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        processingTimeMS: number,

        /**
         * Query used to perform the search
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        query: string,

        /**
         * GET parameters used to perform the search
         * https://github.com/algolia/algoliasearch-client-js#response-format
         */
        params: string
}
declare interface AlgoliaClient {

    /**
     * Initialization of the index
     * @param name : index name
    return algolia index object
    https://github.com/algolia/algoliasearch-client-js#init-index---initindex
    */
    initIndex(name: string): AlgoliaIndex,

        /**
         * Query on multiple index
         * @param queries index name, query and query parameters
         * @param cb callback(err, res)
        https://github.com/algolia/algoliasearch-client-js#multiple-queries---multiplequeries
        */
        search(
            queries: {
                indexName: string,
                query: string,
                options: AlgoliaQueryParameters
            },
            cb: (err: Error, res: any) => void): void,

        /**
         * Query on multiple index
         * @param queries index name, query and query parameters
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#multiple-queries---multiplequeries
        */
        search(
            queries: {
                indexName: string,
                query: string,
                options: AlgoliaQueryParameters
            }): Promise<AlgoliaResponse>,

        /**
         * clear browser cache
         * https://github.com/algolia/algoliasearch-client-js#cache
         */
        clearCache(): void,

        /**
         * kill alive connections
         * https://github.com/algolia/algoliasearch-client-js#keep-alive
         */
        destroy(): void,

        /**
         * List all your indices along with their associated information (number of entries, disk size, etc.)
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#list-indices---listindexes
        */
        listIndexes(cb: (err: Error, res: any) => void): void,

        /**
         * List all your indices along with their associated information (number of entries, disk size, etc.)
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#list-indices---listindexes
        */
        listIndexes(): Promise<any>,

        /**
         * Delete a specific index
         * @param name 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-index---deleteindex
        */
        deleteIndex(name: string, cb: (err: Error, res: any) => void): void,

        /**
         * Delete a specific index
         * @param name return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-index---deleteindex
        */
        deleteIndex(name: string): Promise<any>,

        /**
         * Copy an  index from a specific index to a new one
         * @param from origin index
         * @param to destination index
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#copy-index---copyindex
        */
        copyIndex(from: string, to: string, cb: (err: Error, res: any) => void): void,

        /**
         * Copy an  index from a specific index to a new one
         * @param from origin index
         * @param to destination index
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#copy-index---copyindex
        */
        copyIndex(from: string, to: string): Promise<any>,

        /**
         * Move index to a new one (and will overwrite the original one)
         * @param from origin index
         * @param to destination index
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#move-index---moveindex
        */
        moveIndex(from: string, to: string, cb: (err: Error, res: any) => void): void,

        /**
         * Move index to a new one (and will overwrite the original one)
         * @param from origin index
         * @param to destination index
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#move-index---moveindex
        */
        moveIndex(from: string, to: string): Promise<any>,

        /**
         * Generate a public API key
         * @param key api key
         * @param filters https://github.com/algolia/algoliasearch-client-js#generate-key---generatesecuredapikey
         */
        generateSecuredApiKey(key: string, filters: AlgoliaSecuredApiOptions): void,

        /**
         * Perform multiple operations with one API call to reduce latency
         * @param action 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
        */
        batch(action: AlgoliaAction, cb: (err: Error, res: any) => void): void,

        /**
         * Perform multiple operations with one API call to reduce latency
         * @param action return {Promise}
        https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
        */
        batch(action: AlgoliaAction): Promise<any>,

        /**
         * Lists global API Keys
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        listUserKeys(cb: (err: Error, res: any) => void): void,

        /**
         * Lists global API Keys
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        listUserKeys(): Promise<any>,

        /**
         * Add global API Keys
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Add global API Keys
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[]): Promise<any>,

        /**
         * Add global API Key
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: Error, res: any) => void): void,

        /**
         * Add global API Key
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], options: AlgoliaUserKeyOptions): Promise<any>,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Update global API key
         * @param key 
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[]): Promise<any>,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(
            key: string,
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: Error, res: any) => void): void,

        /**
         * Update global API key
         * @param key 
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], options: AlgoliaUserKeyOptions): Promise<any>,

        /**
         * Gets the rights of a global key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        getUserKeyACL(key: string, cb: (err: Error, res: any) => void): void,

        /**
         * Gets the rights of a global key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        getUserKeyACL(key: string): Promise<any>,

        /**
         * Deletes a global key
         * @param key 
         * @param cb (err,res)
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string, cb: (err: Error, res: any) => void): void,

        /**
         * Deletes a global key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string): Promise<any>,

        /**
         * Get 1000 last events
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        getLogs(options: LogsOptions, cb: (err: Error, res: any) => void): void,

        /**
         * Get 1000 last events
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        getLogs(options: LogsOptions): Promise<any >
}
/**
 * Interface for the index algolia object
 */
declare interface AlgoliaIndex {

    /**
     * Gets a specific object
     * @param objectID 
     * @param cb (err, res)
    https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
    */
    getObject(objectID: string, cb: (err: Error, res: any) => void): void,

        /**
         * Gets specific attributes from an object
         * @param objectID 
         * @param attributes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(
            objectID: string,
            attributes: string[],
            cb: (err: Error, res: any) => void): void,

        /**
         * Gets a list of objects
         * @param objectIDs 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObjects(objectIDs: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Add a specific object
         * @param object without objectID
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, cb: (err: Error, res: any) => void): void,

        /**
         * Add a list of objects
         * @param object with objectID
         * @param objectID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, objectID: string, cb: (err: Error, res: any) => void): void,

        /**
         * Add list of objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObjects(objects: [{}], cb: (err: Error, res: any) => void): void,

        /**
         * Add or replace a specific object
         * @param object 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObject(object: {}, cb: (err: Error, res: any) => void): void,

        /**
         * Add or replace several objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObjects(objects: [{}], cb: (err: Error, res: any) => void): void,

        /**
         * Update parameters of a specific object
         * @param object 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObject(object: {}, cb: (err: Error, res: any) => void): void,

        /**
         * Update parameters of a list of objects
         * @param objects 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObjects(objects: [{}], cb: (err: Error, res: any) => void): void,

        /**
         * Delete a specific object
         * @param objectID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObject(objectID: string, cb: (err: Error, res: any) => void): void,

        /**
         * Delete a list of objects
         * @param objectIDs 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObjects(objectIDs: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, cb: (err: Error, res: any) => void): void,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param params of the object
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, params: {}, cb: (err: Error, res: any) => void): void,

        /**
         * Wait for an indexing task to be compete
         * @param taskID 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#wait-for-operations---waittask
        */
        waitTask(taskID: number, cb: (err: Error, res: any) => void): void,

        /**
         * Get an index settings
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-settings---getsettings
        */
        getSettings(cb: (err: Error, res: any) => void): void,

        /**
         * Set an index settings
         * @param settings 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#set-settings---setsettings
        */
        setSettings(settings: AlgoliaIndexSettings, cb: (err: Error, res: any) => void): void,

        /**
         * Clear cache of an index
         * https://github.com/algolia/algoliasearch-client-js#cache
         */
        clearCache(): void,

        /**
         * Clear an index content
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#clear-index---clearindex
        */
        clearIndex(cb: (err: Error, res: any) => void): void,

        /**
         * Save a synonym object
         * @param synonym 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        saveSynonym(
            synonym: AlgoliaSynonym,
            option: SynonymOption,
            cb: (err: Error, res: any) => void): void,

        /**
         * Save a synonym object
         * @param synonyms 
         * @param options 
         * @param cb (err, res)
         */
        batchSynonyms(
            synonyms: AlgoliaSynonym[],
            options: SynonymOption,
            cb: (err: Error, res: any) => void): void,

        /**
         * Delete a specific synonym
         * @param identifier 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
        */
        deleteSynonym(
            identifier: string,
            options: SynonymOption,
            cb: (err: Error, res: any) => void): void,

        /**
         * Clear all synonyms of an index
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#clear-all-synonyms---clearsynonyms
        */
        clearSynonyms(options: SynonymOption, cb: (err: Error, res: any) => void): void,

        /**
         * Get a specific synonym
         * @param identifier 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-synonym---getsynonym
        */
        getSynonym(identifier: string, cb: (err: Error, res: any) => void): void,

        /**
         * Search a synonyms
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        searchSynonyms(options: SearchSynonymOptions, cb: (err: Error, res: any) => void): void,

        /**
         * List index user keys
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#list-api-keys---listapikeys
        */
        listUserKeys(cb: (err: Error, res: any) => void): void,

        /**
         * Add key for this index
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Add key for this index
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: Error, res: any) => void): void,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], cb: (err: Error, res: any) => void): void,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param options 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(
            key: string,
            scopes: string[],
            options: AlgoliaUserKeyOptions,
            cb: (err: Error, res: any) => void): void,

        /**
         * Gets the rights of an index specific key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#get-key-permissions---getuserkeyacl
        */
        getUserKeyACL(key: string, cb: (err: Error, res: any) => void): void,

        /**
         * Deletes an index specific key
         * @param key 
         * @param cb (err, res)
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string, cb: (err: Error, res: any) => void): void,

        /**
         * Gets a specific object
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(objectID: string): Promise<any>,

        /**
         * Gets specific attributes from an object
         * @param objectID 
         * @param attributes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObject(objectID: string, attributes: string[]): Promise<any>,

        /**
         * Gets a list of objects
         * @param objectIDs return {Promise}
        https://github.com/algolia/algoliasearch-client-js#find-by-ids---getobjects
        */
        getObjects(objectIDs: string[]): Promise<any>,

        /**
         * Add a specific object
         * @param object without objectID
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}): Promise<any>,

        /**
         * Add a list of objects
         * @param object with objectID
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObject(object: {}, objectID: string): Promise<any>,

        /**
         * Add list of objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-objects---addobjects
        */
        addObjects(objects: [{}]): Promise<any>,

        /**
         * Add or replace a specific object
         * @param object return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObject(object: {}): Promise<any>,

        /**
         * Add or replace several objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        saveObjects(objects: [{}]): Promise<any>,

        /**
         * Update parameters of a specific object
         * @param object return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObject(object: {}): Promise<any>,

        /**
         * Update parameters of a list of objects
         * @param objects return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-objects---saveobjects
        */
        partialUpdateObjects(objects: [{}]): Promise<any>,

        /**
         * Delete a specific object
         * @param objectID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObject(objectID: string): Promise<any>,

        /**
         * Delete a list of objects
         * @param objectIDs return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-objects---deleteobjects
        */
        deleteObjects(objectIDs: string[]): Promise<any>,

        /**
         * Delete objects that matches the query
         * @param query return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string): Promise<any>,

        /**
         * Delete objects that matches the query
         * @param query 
         * @param params of the object
        return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-by-query---deletebyquery
        */
        deleteByQuery(query: string, params: {}): Promise<any>,

        /**
         * Wait for an indexing task to be compete
         * @param taskID return {Promise}
        https://github.com/algolia/algoliasearch-client-js#wait-for-operations---waittask
        */
        waitTask(taskID: number): Promise<any>,

        /**
         * Get an index settings
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-settings---getsettings
        */
        getSettings(): Promise<any>,

        /**
         * Set an index settings
         * @param settings return {Promise}
        https://github.com/algolia/algoliasearch-client-js#set-settings---setsettings
        */
        setSettings(settings: AlgoliaIndexSettings): Promise<any>,

        /**
         * Search in an index
         * @param params query parameter
        return {Promise}
         * @param err () error callback
        https://github.com/algolia/algoliasearch-client-js#search-in-an-index---search
        */
        search(params: AlgoliaQueryParameters): Promise<any>,

        /**
         * Search in an index
         * @param params query parameter
         * @param cb (err, res)
         * @param err () error callback
        https://github.com/algolia/algoliasearch-client-js#search-in-an-index---search
        */
        search(params: AlgoliaQueryParameters, cb: (err: Error, res: any) => void): void,

        /**
         * Browse an index
         * @param query 
         * @param cb (err, content)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browse(query: string, cb: (err: Error, res: any) => void): void,

        /**
         * Browse an index
         * @param query return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browse(query: string): Promise<AlgoliaBrowseResponse>,

        /**
         * Browse an index from a cursor
         * @param cursor 
         * @param cb (err, content)
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseFrom(cursor: string, cb: (err: Error, res: any) => void): void,

        /**
         * Browse an index from a cursor
         * @param cursor return {Promise}
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseFrom(cursor: string): Promise<AlgoliaBrowseResponse>,

        /**
         * Browse an entire index
         * return Promise
        https://github.com/algolia/algoliasearch-client-js#backup--export-an-index---browse
        */
        browseAll(): Promise<AlgoliaResponse>,

        /**
         * Clear an index content
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#clear-index---clearindex
        */
        clearIndex(): Promise<any>,

        /**
         * Save a synonym object
         * @param synonym 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        saveSynonym(synonym: AlgoliaSynonym, option: SynonymOption): Promise<any>,

        /**
         * Save a synonym object
         * @param synonyms 
         * @param options return {Promise}
         */
        batchSynonyms(synonyms: AlgoliaSynonym[], options: SynonymOption): Promise<any>,

        /**
         * Delete a specific synonym
         * @param identifier 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
        */
        deleteSynonym(identifier: string, options: SynonymOption): Promise<any>,

        /**
         * Clear all synonyms of an index
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#clear-all-synonyms---clearsynonyms
        */
        clearSynonyms(options: SynonymOption): Promise<any>,

        /**
         * Get a specific synonym
         * @param identifier return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-synonym---getsynonym
        */
        getSynonym(identifier: string): Promise<any>,

        /**
         * Search a synonyms
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        searchSynonyms(options: SearchSynonymOptions): Promise<any>,

        /**
         * List index user keys
         * return {Promise}
        https://github.com/algolia/algoliasearch-client-js#list-api-keys---listapikeys
        */
        listUserKeys(): Promise<any>,

        /**
         * Add key for this index
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[]): Promise<any>,

        /**
         * Add key for this index
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
        */
        addUserKey(scopes: string[], options: AlgoliaUserKeyOptions): Promise<any>,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[]): Promise<any>,

        /**
         * Update a key for this index
         * @param key 
         * @param scopes 
         * @param options return {Promise}
        https://github.com/algolia/algoliasearch-client-js#update-user-key---updateuserkey
        */
        updateUserKey(key: string, scopes: string[], options: AlgoliaUserKeyOptions): Promise<any>,

        /**
         * Gets the rights of an index specific key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#get-key-permissions---getuserkeyacl
        */
        getUserKeyACL(key: string): Promise<any>,

        /**
         * Deletes an index specific key
         * @param key return {Promise}
        https://github.com/algolia/algoliasearch-client-js#delete-user-key---deleteuserkey
        */
        deleteUserKey(key: string): Promise<any >
}
declare interface ClientOptions {

    /**
     * Timeout for requests to our servers, in milliseconds
     * default: 15s (node), 2s (browser)
    https://github.com/algolia/algoliasearch-client-js#client-options
    */
    timeout?: number,

        /**
         * Protocol to use when communicating with algolia
         * default: current protocol(browser), https(node)
        https://github.com/algolia/algoliasearch-client-js#client-options
        */
        protocol?: string,

        /**
         * (node only) httpAgent instance to use when communicating with Algolia servers.
         * https://github.com/algolia/algoliasearch-client-js#client-options
         */
        httpAgent?: any,

        /**
         * read: array of read hosts to use to call Algolia servers, computed automatically
         * write: array of read hosts to use to call Algolia servers, computed automatically
        https://github.com/algolia/algoliasearch-client-js#client-options
        */
        hosts?: {
            read?: string[],
            write?: string[]
        }
}
declare interface LogsOptions {

    /**
     * Specify the first entry to retrieve (0-based, 0 is the most recent log entry).
     * default: 0
    https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
    */
    offset?: number,

        /**
         * Specify the maximum number of entries to retrieve starting at the offset.
         * default: 10
        maximum: 1000
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        length?: number,

        /**
         * 
         * @deprecated  * Retrieve only logs with an HTTP code different than 200 or 201
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        onlyErrors?: boolean,

        /**
         * Specify the type of logs to retrieve
         * 'query' Retrieve only the queries
        'build' Retrieve only the build operations
        'error' Retrieve only the errors (same as onlyErrors parameters)
        https://github.com/algolia/algoliasearch-client-js#get-logs---getlogs
        */
        type?: string
}
/**
 * Describe the action object used for batch operation
 */
declare interface AlgoliaAction {

    /**
     * Type of the batch action
     * values: addObject, updateObject, partialUpdateObject, partialUpdateObjectNoCreate, deleteObject
    https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
    */
    action: string,

        /**
         * Name of the index where the bact will be performed
         * https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
         */
        indexName: string,

        /**
         * Object
         * https://github.com/algolia/algoliasearch-client-js#custom-batch---batch
         */
        body: {}
}
/**
 * Describes the option used when creating user key
 */
declare interface AlgoliaUserKeyOptions {

    /**
     * Add a validity period. The key will be valid for a specific period of time (in seconds).
     * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
     */
    validity?: number,

        /**
         * Specify the maximum number of API calls allowed from an IP address per hour
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        maxQueriesPerIPPerHour?: number,

        /**
         * Specify the maximum number of hits this API key can retrieve in one call
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        maxHitsPerQuery?: boolean,

        /**
         * Specify the list of targeted indices
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        indexes?: string[],

        /**
         * Specify the list of referers
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        referers?: string[],

        /**
         * Specify the list of query parameters
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        queryParameters?: AlgoliaQueryParameters,

        /**
         * Specify a description to describe where the key is used.
         * https://github.com/algolia/algoliasearch-client-js#add-user-key---adduserkey
         */
        description?: string
}
/**
 * Describes option used when making operation on synonyms
 */
declare interface SynonymOption {

    /**
     * You can forward all settings updates to the slaves of an index
     * https://github.com/algolia/algoliasearch-client-js#slave-settings
     */
    forwardToSlaves?: boolean,

        /**
         * Replace all existing synonyms on the index with the content of the batch
         * https://github.com/algolia/algoliasearch-client-js#batch-synonyms---batchsynonyms
         */
        replaceExistingSynonyms?: boolean
}
/**
 * Describes options used when searching for synonyms
 */
declare interface SearchSynonymOptions {

    /**
     * The actual search query to find synonyms
     * https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
     */
    query?: string,

        /**
         * The page to fetch when browsing through several pages of results
         * default: 100
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        page?: number,

        /**
         * Restrict the search to a specific type of synonym
         * Use an empty string to search all types (default behavior)
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        type?: string,

        /**
         * Number of hits per page
         * default: 100
        https://github.com/algolia/algoliasearch-client-js#search-synonyms---searchsynonyms
        */
        hitsPerPage?: number
}
declare interface AlgoliaBrowseResponse {
    cursor?: string,
        hits: any[],
        params: string,
        query: string,
        processingTimeMS: number
}
/**
 * Describes a synonym object
 */
declare interface AlgoliaSynonym {

    /**
     * ObjectID of the synonym
     * https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
     */
    objectID: string,

        /**
         * Type of synonym
         * values: synonym,oneWaySynonym
        https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
        */
        type: string,

        /**
         * Values used for the synonym
         * https://github.com/algolia/algoliasearch-client-js#save-synonym---savesynonym
         */
        synonyms: string[]
}
/**
 * Describes the options used when generating new api keys
 */
declare interface AlgoliaSecuredApiOptions {

    /**
     * Filter the query with numeric, facet or/and tag filters
     * default: ""
    https://github.com/algolia/algoliasearch-client-js#filters-1
    */
    filters?: string,

        /**
         * Defines the expiration date of the API key
         * https://github.com/algolia/algoliasearch-client-js#valid-until
         */
        validUntil?: number,

        /**
         * Restricts the key to a list of index names allowed for the secured API key
         * https://github.com/algolia/algoliasearch-client-js#index-restriction
         */
        restrictIndices?: string,

        /**
         * Allows you to restrict a single user to performing a maximum of N API calls per hour
         * https://github.com/algolia/algoliasearch-client-js#user-rate-limiting
         */
        userToken?: string
}
/**
 * Describes the settings available for configure your index
 */
declare interface AlgoliaIndexSettings {

    /**
     * The list of attributes you want index
     * default: 
    https://github.com/algolia/algoliasearch-client-js#attributestoindex
    */
    attributesToIndex?: string[],

        /**
         * The list of attributes you want to use for faceting
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributesforfaceting
        */
        attributesforFaceting?: string[],

        /**
         * The list of attributes that cannot be retrieved at query time
         * default: null
        https://github.com/algolia/algoliasearch-client-js#unretrievableattributes
        */
        unretrievableAttributes?: string[],

        /**
         * A string that contains the list of attributes you want to retrieve in order to minimize the size of the JSON answer
         * default: 
        https://github.com/algolia/algoliasearch-client-js#attributestoretrieve
        */
        attributesToRetrieve?: string[],

        /**
         * Controls the way results are sorted
         * default: ['typo', 'geo', 'words', 'filters', 'proximity', 'attribute', 'exact', 'custom']
        https://github.com/algolia/algoliasearch-client-js#ranking
        */
        ranking?: string[],

        /**
         * Lets you specify part of the ranking
         * default: []
        https://github.com/algolia/algoliasearch-client-js#customranking
        */
        customRanking?: string[],

        /**
         * The list of indices on which you want to replicate all write operations
         * default: []
        https://github.com/algolia/algoliasearch-client-js#slaves
        */
        slaves?: string[],

        /**
         * Limit the number of facet values returned for each facet
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#maxvaluesperfacet
        */
        maxValuesPerFacet?: string,

        /**
         * Default list of attributes to highlight. If set to null, all indexed attributes are highlighted.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestohighlight
        */
        attributesToHighlight?: string[],

        /**
         * Default list of attributes to snippet alongside the number of words to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestosnippet
        */
        attributesToSnippet?: string[],

        /**
         * Specify the string that is inserted before the highlighted parts in the query result
         * default: <em>
        https://github.com/algolia/algoliasearch-client-js#highlightpretag
        */
        highlightPreTag?: string,

        /**
         * Specify the string that is inserted after the highlighted parts in the query result
         * default: </em>
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        highlightPostTag?: string,

        /**
         * String used as an ellipsis indicator when a snippet is truncated.
         * default: 
        https://github.com/algolia/algoliasearch-client-js#snippetellipsistext
        */
        snippetEllipsisText?: string,

        /**
         * If set to true, restrict arrays in highlights and snippets to items that matched the query at least partially else return all array items in highlights and snippets
         * default: false
        https://github.com/algolia/algoliasearch-client-js#restricthighlightandsnippetarrays
        */
        restrictHighlightAndSnippetArrays?: boolean,

        /**
         * Pagination parameter used to select the number of hits per page
         * default: 20
        https://github.com/algolia/algoliasearch-client-js#hitsperpage
        */
        hitsPerPage?: number,

        /**
         * The minimum number of characters needed to accept one typo
         * default: 4
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor1typo
        */
        minWordSizefor1Typo?: number,

        /**
         * The minimum number of characters needed to accept two typos.
         * default: 8
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        minWordSizefor2Typos?: number,

        /**
         * This option allows you to control the number of typos allowed in the result set
         * default: true
        'true' The typo tolerance is enabled and all matching hits are retrieved (default behavior).
        'false' The typo tolerance is disabled. All results with typos will be hidden.
        'min' Only keep results with the minimum number of typos. For example, if one result matches without typos, then all results with typos will be hidden.
        'strict' Hits matching with 2 typos are not retrieved if there are some matching without typos.
        https://github.com/algolia/algoliasearch-client-js#typotolerance
        */
        typoTolerance?: any,

        /**
         * If set to false, disables typo tolerance on numeric tokens (numbers).
         * default: true
        https://github.com/algolia/algoliasearch-client-js#allowtyposonnumerictokens
        */
        allowTyposOnNumericTokens?: boolean,

        /**
         * If set to true, plural won't be considered as a typo
         * default: false
        https://github.com/algolia/algoliasearch-client-js#ignoreplurals
        */
        ignorePlurals?: boolean,

        /**
         * List of attributes on which you want to disable typo tolerance
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#disabletypotoleranceonattributes
        */
        disableTypoToleranceOnAttributes?: string,

        /**
         * Specify the separators (punctuation characters) to index.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#separatorstoindex
        */
        separatorsToIndex?: string,

        /**
         * Selects how the query words are interpreted
         * default: 'prefixLast'
        'prefixAll' All query words are interpreted as prefixes. This option is not recommended.
        'prefixLast' Only the last word is interpreted as a prefix (default behavior).
        'prefixNone' No query word is interpreted as a prefix. This option is not recommended.
        https://github.com/algolia/algoliasearch-client-js#querytype
        */
        queryType?: any,

        /**
         * This option is used to select a strategy in order to avoid having an empty result page
         * default: 'none'
        'lastWords' When a query does not return any results, the last word will be added as optional
        'firstWords' When a query does not return any results, the first word will be added as optional
        'allOptional' When a query does not return any results, a second trial will be made with all words as optional
        'none' No specific processing is done when a query does not return any results
        https://github.com/algolia/algoliasearch-client-js#removewordsifnoresults
        */
        removeWordsIfNoResults?: string,

        /**
         * Enables the advanced query syntax
         * default: false
        https://github.com/algolia/algoliasearch-client-js#advancedsyntax
        */
        advancedSyntax?: boolean,

        /**
         * A string that contains the comma separated list of words that should be considered as optional when found in the query
         * default: []
        https://github.com/algolia/algoliasearch-client-js#optionalwords
        */
        optionalWords?: string[],

        /**
         * Remove stop words from the query before executing it
         * default: false
        true|false: enable or disable stop words for all 41 supported languages; or
        a list of language ISO codes (as a comma-separated string) for which stop words should be enable
        https://github.com/algolia/algoliasearch-client-js#removestopwords
        */
        removeStopWords?: string[],

        /**
         * List of attributes on which you want to disable prefix matching
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableprefixonattributes
        */
        disablePrefixOnAttributes?: string[],

        /**
         * List of attributes on which you want to disable the computation of exact criteria
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableexactonattributes
        */
        disableExactOnAttributes?: string[],

        /**
         * This parameter control how the exact ranking criterion is computed when the query contains one word
         * default: attribute
        'none': no exact on single word query
        'word': exact set to 1 if the query word is found in the record
        'attribute': exact set to 1 if there is an attribute containing a string equals to the query
        https://github.com/algolia/algoliasearch-client-js#exactonsinglewordquery
        */
        exactOnSingleWordQuery?: string,

        /**
         * Specify the list of approximation that should be considered as an exact match in the ranking formula
         * default: ['ignorePlurals', 'singleWordSynonym']
        'ignorePlurals': alternative words added by the ignorePlurals feature
        'singleWordSynonym': single-word synonym (For example "NY" = "NYC")
        'multiWordsSynonym': multiple-words synonym
        https://github.com/algolia/algoliasearch-client-js#alternativesasexact
        */
        alternativesAsExact?: any,

        /**
         * The name of the attribute used for the Distinct feature
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributefordistinct
        */
        attributeForDistinct?: string,

        /**
         * If set to 1, enables the distinct feature, disabled by default, if the attributeForDistinct index setting is set.
         * https://github.com/algolia/algoliasearch-client-js#distinct
         */
        distinct?: any,

        /**
         * All numerical attributes are automatically indexed as numerical filters
         * default ''
        https://github.com/algolia/algoliasearch-client-js#numericattributestoindex
        */
        numericAttributesToIndex?: string[],

        /**
         * Allows compression of big integer arrays.
         * default: false
        https://github.com/algolia/algoliasearch-client-js#allowcompressionofintegerarray
        */
        allowCompressionOfIntegerArray?: boolean,

        /**
         * Specify alternative corrections that you want to consider.
         * default: []
        https://github.com/algolia/algoliasearch-client-js#altcorrections
        */
        altCorrections?: [{}],

        /**
         * Configure the precision of the proximity ranking criterion
         * default: 1
        https://github.com/algolia/algoliasearch-client-js#minproximity
        */
        minProximity?: number,

        /**
         * This is an advanced use-case to define a token substitutable by a list of words without having the original token searchable
         * default: ''
        https://github.com/algolia/algoliasearch-client-js#placeholders
        */
        placeholders?: any
}
declare interface AlgoliaQueryParameters {

    /**
     * Query string used to perform the search
     * default: ''
    https://github.com/algolia/algoliasearch-client-js#query
    */
    query?: string,

        /**
         * Filter the query with numeric, facet or/and tag filters
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#filters
        */
        filters?: string,

        /**
         * A string that contains the list of attributes you want to retrieve in order to minimize the size of the JSON answer.
         * default: 
        https://github.com/algolia/algoliasearch-client-js#attributestoretrieve
        */
        attributesToRetrieve?: string[],

        /**
         * List of attributes you want to use for textual search
         * default: attributeToIndex
        https://github.com/algolia/algoliasearch-client-js#restrictsearchableattributes
        */
        restrictSearchableAttributes?: string[],

        /**
         * You can use facets to retrieve only a part of your attributes declared in attributesForFaceting attributes
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#facets
        */
        facets?: string,

        /**
         * Limit the number of facet values returned for each facet.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#maxvaluesperfacet
        */
        maxValuesPerFacet?: string,

        /**
         * Default list of attributes to highlight. If set to null, all indexed attributes are highlighted.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestohighlight
        */
        attributesToHighlight?: string[],

        /**
         * Default list of attributes to snippet alongside the number of words to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#attributestosnippet
        */
        attributesToSnippet?: string[],

        /**
         * Specify the string that is inserted before the highlighted parts in the query result
         * default: <em>
        https://github.com/algolia/algoliasearch-client-js#highlightpretag
        */
        highlightPreTag?: string,

        /**
         * Specify the string that is inserted after the highlighted parts in the query result
         * default: </em>
        https://github.com/algolia/algoliasearch-client-js#highlightposttag
        */
        highlightPostTag?: string,

        /**
         * String used as an ellipsis indicator when a snippet is truncated.
         * default: 
        https://github.com/algolia/algoliasearch-client-js#snippetellipsistext
        */
        snippetEllipsisText?: string,

        /**
         * If set to true, restrict arrays in highlights and snippets to items that matched the query at least partially else return all array items in highlights and snippets
         * default: false
        https://github.com/algolia/algoliasearch-client-js#restricthighlightandsnippetarrays
        */
        restrictHighlightAndSnippetArrays?: boolean,

        /**
         * Pagination parameter used to select the number of hits per page
         * default: 20
        https://github.com/algolia/algoliasearch-client-js#hitsperpage
        */
        hitsPerPage?: number,

        /**
         * Pagination parameter used to select the page to retrieve.
         * default: 0
        https://github.com/algolia/algoliasearch-client-js#page
        */
        page?: number,

        /**
         * Offset of the first hit to return
         * default: null
        https://github.com/algolia/algoliasearch-client-js#offset
        */
        offset?: number,

        /**
         * Number of hits to return.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#length
        */
        length?: number,

        /**
         * The minimum number of characters needed to accept one typo.
         * default: 4
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor1typo
        */
        minWordSizefor1Typo?: number,

        /**
         * The minimum number of characters needed to accept two typo.
         * fault: 8
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor2typos
        */
        minWordSizefor2Typos?: number,

        /**
         * This option allows you to control the number of typos allowed in the result set:
         * default: true
        'true' The typo tolerance is enabled and all matching hits are retrieved
        'false' The typo tolerance is disabled. All results with typos will be hidden.
        'min' Only keep results with the minimum number of typos
        'strict' Hits matching with 2 typos are not retrieved if there are some matching without typos.
        https://github.com/algolia/algoliasearch-client-js#minwordsizefor2typos
        */
        typoTolerance?: boolean,

        /**
         * If set to false, disables typo tolerance on numeric tokens (numbers).
         * default:
        https://github.com/algolia/algoliasearch-client-js#allowtyposonnumerictokens
        */
        allowTyposOnNumericTokens?: boolean,

        /**
         * If set to true, plural won't be considered as a typo
         * default: false
        https://github.com/algolia/algoliasearch-client-js#ignoreplurals
        */
        ignorePlurals?: boolean,

        /**
         * List of attributes on which you want to disable typo tolerance
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#disabletypotoleranceonattributes
        */
        disableTypoToleranceOnAttributes?: string,

        /**
         * Search for entries around a given location
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#aroundlatlng
        */
        aroundLatLng?: string,

        /**
         * Search for entries around a given latitude/longitude automatically computed from user IP address.
         * default: ""
        https://github.com/algolia/algoliasearch-client-js#aroundlatlngviaip
        */
        aroundLatLngViaIP?: string,

        /**
         * Control the radius associated with a geo search. Defined in meters.
         * default: null
        You can specify aroundRadius=all if you want to compute the geo distance without filtering in a geo area
        https://github.com/algolia/algoliasearch-client-js#aroundradius
        */
        aroundRadius?: any,

        /**
         * Control the precision of a geo search
         * default: null
        https://github.com/algolia/algoliasearch-client-js#aroundprecision
        */
        aroundPrecision?: number,

        /**
         * Define the minimum radius used for a geo search when aroundRadius is not set.
         * default: null
        https://github.com/algolia/algoliasearch-client-js#minimumaroundradius
        */
        minimumAroundRadius?: number,

        /**
         * Search entries inside a given area defined by the two extreme points of a rectangle
         * default: null
        https://github.com/algolia/algoliasearch-client-js#insideboundingbox
        */
        insideBoundingBox?: string,

        /**
         * Selects how the query words are interpreted
         * default: 'prefixLast'
        'prefixAll' All query words are interpreted as prefixes. This option is not recommended.
        'prefixLast' Only the last word is interpreted as a prefix (default behavior).
        'prefixNone' No query word is interpreted as a prefix. This option is not recommended.
        https://github.com/algolia/algoliasearch-client-js#querytype
        */
        queryType?: any,

        /**
         * Search entries inside a given area defined by a set of points
         * defauly: ''
        https://github.com/algolia/algoliasearch-client-js#insidepolygon
        */
        insidePolygon?: string,

        /**
         * This option is used to select a strategy in order to avoid having an empty result page
         * default: 'none'
        'lastWords' When a query does not return any results, the last word will be added as optional
        'firstWords' When a query does not return any results, the first word will be added as optional
        'allOptional' When a query does not return any results, a second trial will be made with all words as optional
        'none' No specific processing is done when a query does not return any results
        https://github.com/algolia/algoliasearch-client-js#removewordsifnoresults
        */
        removeWordsIfNoResults?: string,

        /**
         * Enables the advanced query syntax
         * default: false
        https://github.com/algolia/algoliasearch-client-js#advancedsyntax
        */
        advancedSyntax?: boolean,

        /**
         * A string that contains the comma separated list of words that should be considered as optional when found in the query
         * default: []
        https://github.com/algolia/algoliasearch-client-js#optionalwords
        */
        optionalWords?: string[],

        /**
         * Remove stop words from the query before executing it
         * default: false
        true|false: enable or disable stop words for all 41 supported languages; or
        a list of language ISO codes (as a comma-separated string) for which stop words should be enable
        https://github.com/algolia/algoliasearch-client-js#removestopwords
        */
        removeStopWords?: string[],

        /**
         * List of attributes on which you want to disable the computation of exact criteria
         * default: []
        https://github.com/algolia/algoliasearch-client-js#disableexactonattributes
        */
        disableExactOnAttributes?: string[],

        /**
         * This parameter control how the exact ranking criterion is computed when the query contains one word
         * default: attribute
        'none': no exact on single word query
        'word': exact set to 1 if the query word is found in the record
        'attribute': exact set to 1 if there is an attribute containing a string equals to the query
        https://github.com/algolia/algoliasearch-client-js#exactonsinglewordquery
        */
        exactOnSingleWordQuery?: string,

        /**
         * Specify the list of approximation that should be considered as an exact match in the ranking formula
         * default: ['ignorePlurals', 'singleWordSynonym']
        'ignorePlurals': alternative words added by the ignorePlurals feature
        'singleWordSynonym': single-word synonym (For example "NY" = "NYC")
        'multiWordsSynonym': multiple-words synonym
        https://github.com/algolia/algoliasearch-client-js#alternativesasexact
        */
        alternativesAsExact?: any,

        /**
         * If set to 1, enables the distinct feature, disabled by default, if the attributeForDistinct index setting is set.
         * https://github.com/algolia/algoliasearch-client-js#distinct
         */
        distinct?: any,

        /**
         * If set to true, the result hits will contain ranking information in the _rankingInfo attribute.
         * default: false
        https://github.com/algolia/algoliasearch-client-js#getrankinginfo
        */
        getRankingInfo?: boolean,

        /**
         * All numerical attributes are automatically indexed as numerical filters
         * default: ''
        https://github.com/algolia/algoliasearch-client-js#numericattributestoindex
        */
        numericAttributesToIndex?: string[],

        /**
         * 
         * @deprecated  please use filters instead
        A string that contains the comma separated list of numeric filters you want to apply.
        https://github.com/algolia/algoliasearch-client-js#numericfilters-deprecated
        */
        numericFilters?: string[],

        /**
         * 
         * @deprecated  * Filter the query by a set of tags.
        https://github.com/algolia/algoliasearch-client-js#tagfilters-deprecated
        */
        tagFilters?: string,

        /**
         * 
         * @deprecated  * Filter the query by a set of facets.
        https://github.com/algolia/algoliasearch-client-js#facetfilters-deprecated
        */
        facetFilters?: string,

        /**
         * If set to false, this query will not be taken into account in the analytics feature.
         * default true
        https://github.com/algolia/algoliasearch-client-js#analytics
        */
        analytics?: boolean,

        /**
         * If set, tag your query with the specified identifiers
         * default: null
        https://github.com/algolia/algoliasearch-client-js#analyticstags
        */
        analyticsTags?: string[],

        /**
         * If set to false, the search will not use the synonyms defined for the targeted index.
         * default: true
        https://github.com/algolia/algoliasearch-client-js#synonyms
        */
        synonyms?: boolean,

        /**
         * If set to false, words matched via synonym expansion will not be replaced by the matched synonym in the highlighted result.
         * default: true
        https://github.com/algolia/algoliasearch-client-js#replacesynonymsinhighlight
        */
        replaceSynonymsInHighlight?: boolean,

        /**
         * Configure the precision of the proximity ranking criterion
         * default: 1
        https://github.com/algolia/algoliasearch-client-js#minproximity
        */
        minProximity?: number
}
declare module 'algoliasearch' {
    declare module.exports: typeof algoliasearch
}
declare interface AltJS$StoreReduce {
    action: any,
        data: any
}

declare export interface AltJS$StoreModel<S>{
    bindAction(action: AltJS$Action<any>, handler: AltJS$ActionHandler): void,
    bindActions(actions: AltJS$ActionsClass): void,
    exportPublicMethods(exportConfig: any): void,
    bindListeners(config: {
        [methodName: string]: AltJS$Action<any>| AltJS$Actions
    }): void,
    exportAsync(source: AltJS$Source): void,
    registerAsync(datasource: AltJS$Source): void,
    setState(state: S): void,
    setState(stateFn: (currentState: S, nextState: S) => S): void,
    getState(): S,
    waitFor(store: AltJS$AltStore<any>): void,
    onSerialize(fn: (data: any) => any): void,
    onDeserialize(fn: (data: any) => any): void,
    on(event: AltJS$lifeCycleEvents, callback: () => any): void,
    emitChange(): void,
    waitFor(storeOrStores: AltJS$AltStore<any>| Array<AltJS$AltStore<any >> ): void,
    otherwise(data: any, action: AltJS$Action<any>): void,
    observe(alt: AltJS$Alt): any,
    reduce(state: any, config: AltJS$StoreReduce): Object,
    preventDefault(): void,
    afterEach(payload: Object, state: Object): void,
    beforeEach(payload: Object, state: Object): void,
    dispatcher?: any,
    getInstance(): AltJS$AltStore<S>,
    alt?: AltJS$Alt,
    displayName?: string
}

declare export type AltJS$Source = {
    [name: string]: () => AltJS$SourceModel<any >
};

declare export interface AltJS$SourceModel<S>{
    local(state: any, ...args: any[]): any,
    remote(state: any, ...args: any[]): Promise<S>,
    shouldFetch(fetchFn: (...args: Array<any>) => boolean): void,
    loading?: (args: any) => void,
    success?: (state: S) => void,
    error?: (args: any) => void,
    interceptResponse(response: any, action: AltJS$Action<any>, ...args: Array<any>): any
}

declare export interface AltJS$AltStore<S>{
    getState(): S,
    listen(handler: (state: S) => any): () => void,
    unlisten(handler: (state: S) => any): void,
    emitChange(): void
}

declare export type AltJS$Actions = {
    [action: string]: AltJS$Action<any >
};

declare type AltJS$Action = () => any;

declare export interface AltJS$ActionsClass {
    generateActions(...action: Array<string>): void,
        dispatch(...payload: Array<any>): void,
        actions?: AltJS$Actions
}

declare type AltJS$StateTransform = (store: AltJS$StoreModel<any>) => AltJS$AltStore<any>;

declare interface AltJS$AltConfig {
    dispatcher?: any,
        serialize?: (serializeFn: (data: Object) => string) => void,
        deserialize?: (deserializeFn: (serialData: string) => Object) => void,
        storeTransforms?: Array<AltJS$StateTransform>,
        batchingFunction?: (callback: (...data: Array<any>) => any) => void
}

declare class Alt {
    constructor(config?: AltJS$AltConfig): this;
    actions: AltJS$Actions;
    bootstrap(jsonData: string): void;
    takeSnapshot(...storeNames: Array<string>): string;
    flush(): Object;
    recycle(...stores: Array<AltJS$AltStore<any >> ): void;
    rollback(): void;
    dispatch(action?: AltJS$Action<any>, data?: Object, details?: any): void;
    addActions(actionsName: string, ActionsClass: AltJS$ActionsClassConstructor): void;
    createActions<T>(ActionsClass: AltJS$ActionsClassConstructor, exportObj?: Object): T;
    createActions<T>(
        ActionsClass: AltJS$ActionsClassConstructor,
        exportObj?: Object,
        ...constructorArgs: Array<any>): T;
    generateActions<T>(...actions: Array<string>): T;
    getActions(actionsName: string): AltJS$Actions;
    addStore(name: string, store: AltJS$StoreModel<any>, saveStore?: boolean): void;
    createStore<S>(store: AltJS$StoreModel<S>, name?: string): AltJS$AltStore<S>;
    getStore(name: string): AltJS$AltStore<any >
}

declare export interface AltJS$AltFactory {
    new(config?: AltJS$AltConfig): AltJS$Alt
}

declare type AltJS$ActionsClassConstructor = (alt: AltJS$Alt) => AltJS$ActionsClass;

declare type AltJS$ActionHandler = (...data: Array<any>) => any;

declare type AltJS$ExportConfig = {
    [key: string]: (...args: Array<any>) => any
};
declare module 'alt/utils/chromeDebug' {
    declare module.exports: typeof chromeDebug
}
declare module 'alt/AltContainer' {
    declare interface ContainerProps {
        store?: AltJS$AltStore<any>,
            stores?: Array<AltJS$AltStore<any >> ,
            inject?: {
                [key: string]: any
            },
            actions?: {
                [key: string]: Object
            },
            render?: (...props: Array<any>) => React.ReactElement<any>,
            flux?: AltJS$Alt,
            transform?: (store: AltJS$AltStore<any>, actions: any) => any,
            shouldComponentUpdate?: (props: any) => boolean,
            component?: React.Component<any, any >
    }
    declare module.exports: typeof AltContainer
    declare     var AltContainer: React.ComponentClass<ContainerProps>;
}
declare module 'alt' {
    declare     var alt: AltJS$AltFactory;
    declare module.exports: typeof alt
}
declare module 'amazon-product-api' {
    declare interface ICredentials {
        awsId: string,
            awsSecret: string,
            awsTag: string
    }
    declare interface IAmazonProductQueryCallback {
        (err: string, results: Object[]): void
    }
    declare interface IAmazonProductClient {
        itemSearch(query: any, callback?: IAmazonProductQueryCallback): Promise<Object[]>,
            itemLookup(query: any, callback?: IAmazonProductQueryCallback): Promise<Object[]>,
            browseNodeLookup(query: any, callback?: IAmazonProductQueryCallback): Promise<Object[] >
    }
    declare     export function createClient(credentials: ICredentials): IAmazonProductClient
}

declare var npm$namespace$AmCharts: {
    clear: typeof AmCharts$clear,
    ready: typeof AmCharts$ready,
    makeChart: typeof AmCharts$makeChart,
    addInitHandler: typeof AmCharts$addInitHandler,
}
declare var baseHref: boolean;

declare var dayNames: string[];

declare var monthNames: string[];

declare var shortDayNames: string[];

declare var shortMonthNames: string[];

declare var useUTC: boolean;

declare var themes: any;


/**
 * Clears all the charts on page, removes listeners and intervals. 
 */
declare function AmCharts$clear(): void


/**
 * Handle ready event 
 */
declare function AmCharts$ready(Function: << UNKNOWN PARAM FORMAT >> ): void


/**
 * Create chart by params. 
 */
declare function AmCharts$makeChart(selector: string, params: any, delay?: number): AmCharts$AmChart


/**
 * Set a method to be called before initializing the chart.
 * When the method is called, the chart instance is passed as an attribute.
You can use this feature to preprocess chart data or do some other things you need
before initializing the chart.
 * @param  - The method to be called.
 * @param  - Which chart types should call this method. Defaults to all
if none is passed.
*/
declare function AmCharts$addInitHandler(handler: Function, types: string[]): void


/**
 * AmPieChart class creates pie/donut chart. In order to display pie chart you need to set at least three properties - dataProvider, titleField and valueField.
 * @example  var chartData = [{title:"Pie I have eaten",value:70},{title:"Pie I haven\'t eaten",value:30}];
var chart = new AmCharts.AmPieChart();
chart.valueField = "value";
chart.titleField = "title";
chart.dataProvider = chartData;
chart.write("chartdiv");
*/
declare class AmPieChart mixins AmChart {

    /**
     * Name of the field in chart's dataProvider which holds slice's alpha. 
     */
    alphaField: string;

    /**
     * Pie lean angle (for 3D effect). Valid range is 0 - 90. 
     */
    angle: number;

    /**
     * Balloon text. The following tags can be used: [[value]], [[title]], [[percents]], [[description]]. [[title]]: [[percents]]% ([[value]])\n[[description]] 
     */
    balloonText: string;

    /**
     * Read-only. Array of Slice objects. 
     */
    chartData: any[];

    /**
     * Name of the field in chart's dataProvider which holds slice's color. 
     */
    colorField: string;

    /**
     * Specifies the colors of the slices, if the slice color is not set. If there are more slices than colors in this array, the chart picks random color. ["#FF0F00", "#FF6600", "#FF9E01", "#FCD202", "#F8FF01", "#B0DE09", "#04D215", "#0D8ECF", "#0D52D1", "#2A0CD0", "#8A0CCF", "#CD0D74", "#754DEB", "#DDDDDD", "#999999", "#333333", "#000000", "#57032A", "#CA9726", "#990000", "#4B0C25"] 
     */
    colors: any[];

    /**
     * Depth of the pie (for 3D effect). 
     */
    depth3D: number;

    /**
     * Name of the field in chart's dataProvider which holds a string with description. 
     */
    descriptionField: string;

    /**
     * Example: [-0.2,0.2]. Will make slices to be filled with color gradients. 
     */
    gradientRatio: number[];

    /**
     * Opacity of the group slice. Value range is 0 - 1.
     * @default  1
     */
    groupedAlpha: number;

    /**
     * Color of the group slice. The default value is not set - this means the next available color from "colors" array will be used. 
     */
    groupedColor: string;

    /**
     * Description of the group slice. 
     */
    groupedDescription: string;

    /**
     * If this is set to true, the group slice will be pulled out when the chart loads. 
     */
    groupedPulled: boolean;

    /**
     * Title of the group slice. Other 
     */
    groupedTitle: string;

    /**
     * If there is more than one slice whose percentage of the pie is less than this number, those slices will be grouped together into one slice. This is the "other" slice. It will always be the last slice in a pie. 
     */
    groupPercent: number;

    /**
     * Slices with percent less then hideLabelsPercent won't display labels This is useful to avoid cluttering up the chart, if you have a lot of small slices. 0 means all labels will be shown. 
     */
    hideLabelsPercent: number;

    /**
     * Opacity of a hovered slice. Value range is 0 - 1.
     * @default  1
     */
    hoverAlpha: number;

    /**
     * Inner radius of the pie, in pixels or percents. 
     */
    innerRadius: any;

    /**
     * The distance between the label and the slice, in pixels. You can use negative values to put the label on the slice.
     * @default  30
     */
    labelRadius: number;

    /**
     * Name of the field in dataProvider which specifies the length of a tick. Note, the chart will not try to arrange labels automatically if this property is set. 
     */
    labelRadiusField: string;

    /**
     * Specifies whether data labels are visible.
     * @default  true
     */
    labelsEnabled: boolean;

    /**
     * Label text. The following tags can be used: [[value]], [[title]], [[percents]], [[description]]. [[title]]: [[percents]]% 
     */
    labelText: string;

    /**
     * Label tick opacity. Value range is 0 - 1. 0.2 
     */
    labelTickAlpha: number;

    /**
     * Label tick color. #000000 
     */
    labelTickColor: string;

    /**
     * Bottom margin of the chart.
     * @default  5
     */
    marginBottom: number;

    /**
     * Left margin of the chart. 
     */
    marginLeft: number;

    /**
     * Right margin of the chart. 
     */
    marginRight: number;

    /**
     * Top margin of the chart.
     * @default  5
     */
    marginTop: number;

    /**
     * Minimum radius of the pie, in pixels.
     * @default  10
     */
    minRadius: number;

    /**
     * Pie outline opacity. Value range is 0 - 1. 
     */
    outlineAlpha: number;

    /**
     * Pie outline color. #FFFFFF 
     */
    outlineColor: string;

    /**
     * Pie outline thickness.
     * @default  1
     */
    outlineThickness: number;

    /**
     * Opacity of the slices. You can set the opacity of individual slice too.
     * @default  1
     */
    pieAlpha: number;

    /**
     * Color of the first slice. All the other will be colored with darker or brighter colors. 
     */
    pieBaseColor: string;

    /**
     * Lightness increase of each subsequent slice. This is only useful if pieBaseColor is set. Use negative values for darker colors. Value range is from -255 to 255.
     * @default  30
     */
    pieBrightnessStep: number;

    /**
     * You can set fixed position of a pie center, in pixels or in percents. 
     */
    pieX: any;

    /**
     * You can set fixed position of a pie center, in pixels or in percents. 
     */
    pieY: any;

    /**
     * Name of the field in chart's dataProvider which holds a boolean value telling the chart whether this slice must be pulled or not. 
     */
    pulledField: string;

    /**
     * Pull out duration, in seconds.
     * @default  1
     */
    pullOutDuration: number;

    /**
     * Pull out effect. Possible values are ">", "<", elastic" and "bounce". bounce 
     */
    pullOutEffect: string;

    /**
     * If this is set to true, only one slice can be pulled out at a time. If the viewer clicks on a slice, any other pulled-out slice will be pulled in. 
     */
    pullOutOnlyOne: boolean;

    /**
     * Pull out radius, in pixels or percents 0.2 
     */
    pullOutRadius: any;

    /**
     * Radius of a pie, in pixels or percents. By default, radius is calculated automatically. 
     */
    radius: any;

    /**
     * Specifies whether the animation should be sequenced or all slices should appear at once. 
     */
    sequencedAnimation: boolean;

    /**
     * Initial opacity of all slices. If you set startDuration higher than 0, slices will fade in from startAlpha.
     * @default  1
     */
    startAlpha: number;

    /**
     * Angle of the first slice, in degrees. This will work properly only if "depth3D" is set to 0. If "depth3D" is greater than 0, then there can be two angles only: 90 and 270. Value range is 0-360.
     * @default  90
     */
    startAngle: number;

    /**
     * Duration of the animation, in seconds.
     * @default  1
     */
    startDuration: number;

    /**
     * Animation effect. Possible values are ">", "<", "elastic" and "bounce". bounce 
     */
    startEffect: string;

    /**
     * Radius of the positions from which the slices will fly in.
     * default 5
     */
    startRadius: any;

    /**
     * Name of the field in chart's dataProvider which holds slice's title. 
     */
    titleField: string;

    /**
     * Name of the field in chart's dataProvider which holds url which would be accessed if the user clicks on a slice. 
     */
    urlField: string;

    /**
     * If url is specified for a slice, it will be opened when user clicks on it. urlTarget specifies target of this url. Use _blank if you want url to be opened in a new window. _self 
     */
    urlTarget: string;

    /**
     * Name of the field in chart's dataProvider which holds slice's value. 
     */
    valueField: string;

    /**
     * Name of the field in chart's dataProvider which holds boolean variable defining whether this data item should have an entry in the legend. 
     */
    visibleInLegendField: string;

    /**
     * You can trigger the animation of the pie chart. 
     */
    animateAgain(): void;

    /**
     * You can trigger the click on a slice from outside. index - the number of a slice or Slice object. 
     */
    clickSlice(index: number): void;

    /**
     * Hides slice. index - the number of a slice or Slice object. 
     */
    hideSlice(index: number): void;

    /**
     * You can simulate roll-out of a slice from outside. index - the number of a slice or Slice object. 
     */
    rollOutSlice(index: number): void;

    /**
     * You can simulate roll-over a slice from outside. index - the number of a slice or Slice object. 
     */
    rollOverSlice(index: number): void;

    /**
     * Shows slice. index - the number of a slice or Slice object. 
     */
    showSlice(index: number): void
}


/**
 * AmRadarChart is the class you have to use for radar and polar chart types.
 * @example  var chart;
var chartData = [
{country:"Czech Republic",litres:156.90},
{country:"Ireland",litres:131.10},
{country:"Germany",litres:115.80},
{country:"Australia",litres:109.90},
{country:"Austria",litres:108.30},
{country:"UK",litres:99.00}
];
window.onload = function() {
chart = new AmCharts.AmRadarChart();
chart.dataProvider = chartData;
chart.categoryField = "country";
chart.startDuration = 2;
var valueAxis = new AmCharts.ValueAxis();
valueAxis.axisAlpha = 0.15;
valueAxis.minimum = 0;
valueAxis.dashLength = 3;
valueAxis.axisTitleOffset = 20;
valueAxis.gridCount = 5;
chart.addValueAxis(valueAxis);
var graph = new AmCharts.AmGraph();
graph.valueField = "litres";
graph.bullet = "round";
graph.balloonText = "[[value]] litres of beer per year"
chart.addGraph(graph);
chart.write("chartdiv");
}
*/
declare class AmRadarChart mixins AmCoordinateChart {

    /**
     * Bottom margin of the chart. 
     */
    marginBottom: number;

    /**
     * Left margin of the chart. 
     */
    marginLeft: number;

    /**
     * Right margin of the chart. 
     */
    marginRight: number;

    /**
     * Top margin of the chart. 
     */
    marginTop: number;

    /**
     * Radius of a radar. 0.35 
     */
    radius: any
}


/**
 * AmXYChart is the class you have to use for XY/Bubble/Scatter chart types. The chart supports simple and logarithmic scales, it can have multiple value axes.
 * @example  var chartData = [
{x:10, y:14, value:59},
{x:5, y:3, value:50},
{x:-10, y:-3, value:19},
{x:-6, y:5, value:65},
{x:15, y:-4, value:92},
{x:13, y:1, value:8},
{x:1, y:6, value:35}
];
var chart = new AmCharts.AmXYChart();
chart.pathToImages = "../../amcharts/javascript/images/";
chart.dataProvider = chartData;
chart.marginLeft = 35;
chart.startDuration = 1.5;
var xAxis = new AmCharts.ValueAxis();
xAxis.position = "left";
xAxis.autoGridCount = true;
chart.addValueAxis(xAxis);
var yAxis = new AmCharts.ValueAxis();
yAxis.position = "bottom";
yAxis.autoGridCount = true;
chart.addValueAxis(yAxis);
var graph = new AmCharts.AmGraph();
graph.valueField = "value";
graph.xField = "x";
graph.yField = "y";
graph.lineAlpha = 0;
graph.bullet = "round";
chart.addGraph(graph);
var chartCursor = new AmCharts.ChartCursor();
chart.addChartCursor(chartCursor);
var chartScrollbar = new AmCharts.ChartScrollbar();
chartScrollbar.hideResizeGrips = false;
chart.addChartScrollbar(chartScrollbar);
chart.write("chartdiv);
*/
declare class AmXYChart mixins AmRectangularChart {

    /**
     * Specifies if Scrollbar of X axis (horizontal) should be hidden. 
     */
    hideXScrollbar: boolean;

    /**
     * Specifies if Scrollbar of Y axis (vertical) should be hidden. 
     */
    hideYScrollbar: boolean;

    /**
     * Maximum zoom factor of the chart.
     * @default  20
     */
    maxZoomFactor: number;

    /**
     * Zooms out, charts shows all available data.
     */
    zoomOut(): void
}


/**
 * Guides are straight vertical or horizontal lines or areas supported by AmSerialChart, AmXYChart and AmRadarChart. You can have guides both on value and category axes. To add/remove a guide to an axis, use axis.addGuide(guide)/axis.removeGuide(guide) methods.
 * 
Ifyoudo not set properties such as dashLength, lineAlpha, lineColor, etc - values of the axis are used.
*/
declare class Guide {

    /**
     * If you set it to true, the guide will be displayed above the graphs. 
     */
    above: boolean;

    /**
     * Radar chart only. Specifies angle at which guide should start. Affects only fills, not lines. 
     */
    angle: number;

    /**
     * Baloon fill color. 
     */
    balloonColor: string;

    /**
     * The text which will be displayed if the user rolls-over the guide. 
     */
    balloonText: string;

    /**
     * Specifies if label should be bold or not. 
     */
    boldLabel: boolean;

    /**
     * Category of the guide (in case the guide is for category axis). 
     */
    category: string;

    /**
     * Dash length. 
     */
    dashLength: number;

    /**
     * Date of the guide (in case the guide is for category axis and parseDates is set to true). 
     */
    date: Date;

    /**
     * Works if a guide is added to CategoryAxis and this axis is non-date-based. If you set it to true, the guide will start (or be placed, if it's not a fill) on the beginning of the category cell and will end at the end of toCategory cell. 
     */
    expand: boolean;

    /**
     * Fill opacity. Value range is 0 - 1. 
     */
    fillAlpha: number;

    /**
     * Fill color. 
     */
    fillColor: string;

    /**
     * Font size of guide label. 
     */
    fontSize: string;

    /**
     * Unique id of a Guide. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Specifies whether label should be placed inside or outside plot area. 
     */
    inside: boolean;

    /**
     * The label which will be displayed near the guide. 
     */
    label: string;

    /**
     * Rotation angle of a guide label. 
     */
    labelRotation: number;

    /**
     * Line opacity. 
     */
    lineAlpha: number;

    /**
     * Line color. 
     */
    lineColor: string;

    /**
     * Line thickness. 
     */
    lineThickness: number;

    /**
     * Position of guide label. Possible values are "left" or "right" for horizontal axis and "top" or "bottom" for vertical axis.  
     */
    position: string;

    /**
     * Tick length. 
     */
    tickLength: number;

    /**
     * Radar chart only. Specifies angle at which guide should end. Affects only fills, not lines. 
     */
    toAngle: number;

    /**
     * To category of the guide (in case the guide is for category axis). 
     */
    toCategory: string;

    /**
     * To date of the guide (in case the guide is for category axis and parseDates is set to true) If you have both date and toDate, the space between these two dates can be filled with color. 
     */
    toDate: Date;

    /**
     * To value of the guide (in case the guide is for value axis). 
     */
    toValue: number;

    /**
     * Value of the guide (in case the guide is for value axis). 
     */
    value: number;

    /**
     * Value axis of a guide. As you can add guides directly to the chart, you might need to specify which which value axis should be used. 
     */
    valueAxis: AmCharts$ValueAxis
}


/**
 * ImagesSettings is a class which holds common settings of all MapImage objects. 
 */
declare class ImagesSettings {

    /**
     * Opacity of the image.
     * @default  1
     */
    alpha: number;

    /**
     * Text which is displayed in a roll-over balloon. You can use the following tags: [[title]], [[description]], [[value]] and [[percent]]. [[title]] 
     */
    balloonText: string;

    /**
     * Specifies if the image's center should be placed in the provided coordinates. If false, top-left corner will be at provided coordinates.
     * @default  true
     */
    centered: boolean;

    /**
     * Color of image. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. #000000 
     */
    color: string;

    /**
     * Height of a description window. 
     */
    descriptionWindowHeight: number;

    /**
     * Width of a description window.
     * @default  250
     */
    descriptionWindowWidth: number;

    /**
     * X position of a description window. 
     */
    descriptionWindowX: number;

    /**
     * Y position of a description window. 
     */
    descriptionWindowY: number;

    /**
     * Label color. #000000 
     */
    labelColor: string;

    /**
     * Font size of a label.
     * @default  11
     */
    labelfontSize: string;

    /**
     * Position of the label. Allowed values are: left, right, top, bottom and middle. right 
     */
    labelPosition: string;

    /**
     * Label roll-over color. #00CC00 
     */
    labelRollOverColor: string;

    /**
     * Opacity of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    outlineAlpha: number;

    /**
     * Color of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    outlineColor: string;

    /**
     * Thickness of image outline. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images.
     * @default  1
     */
    outlineThickness: number;

    /**
     * Color of image when hovered. This will affect only predefined images (with "type" property set) and images with svgPath set. This property won't affect bitmap images and loaded SVG images. 
     */
    rollOverColor: string;

    /**
     * Scale of the image when hovered. Use value like 1.5 - 2 to enlarge image when user rolls-over it.
     * @default  1
     */
    rollOverScale: number;

    /**
     * Scale of the image if it is selected. Use value like 1.5 - 2 to enlarge selected image.
     * @default  1
     */
    selectedScale: number
}


/**
 * AreasSettings is a class which holds common settings of all MapArea objects. 
 */
declare class AreasSettings {

    /**
     * Opacity of areas.
     * @default  1
     */
    alpha: number;

    /**
     * Specifies if the areas should be zoomed-in when user clicks on them, event if zoom properties are not set. 
     */
    autoZoom: boolean;

    /**
     * Text which is displayed in a roll-over balloon. You can use the following tags: [[title]], [[description]], [[value]] and [[percent]] [[title]] 
     */
    balloonText: string;

    /**
     * Color of the areas. #FFCC00 
     */
    color: string;

    /**
     * Color of area with highest value. Colors for areas with values less then highest will be colored with intermediate colors between color and colorSolid. Use colorSteps property of AmMap to change the number of intermediate colors. #990000 
     */
    colorSolid: string;

    /**
     * Height of a description window. 
     */
    descriptionWindowHeight: number;

    /**
     * Width of a description window.
     * @default  250
     */
    descriptionWindowWidth: number;

    /**
     * X position of a description window. 
     */
    descriptionWindowX: number;

    /**
     * Y position of a description window. 
     */
    descriptionWindowY: number;

    /**
     * Opacity of area's outline.
     * @default  1
     */
    outlineAlpha: number;

    /**
     * Color of area's outline. #FFFFFF 
     */
    outlineColor: string;

    /**
     * Thickness of area's outline. 0.5 
     */
    outlineThickness: number;

    /**
     * Color of area when user rolls-over it. undefined 
     */
    rollOverColor: string;

    /**
     * Color of area's outline when user rolls-over it. #CC0000 
     */
    rollOverOutlineColor: string;

    /**
     * Color of area which is currently selected. #CC0000 
     */
    selectedColor: string;

    /**
     * Opacity of all areas which are in the map svg file, but not listed as areas in DataSet.
     * @default  1
     */
    unlistedAreasAlpha: number;

    /**
     * Color of all areas which are in the map svg file, but not listed as areas in DataSet. #DDDDDD 
     */
    unlistedAreasColor: string;

    /**
     * Opacity of all areas' outline which are in the map svg file, but not listed as areas in DataSet.
     * @default  1
     */
    unlistedAreasOutlineAlpha: number;

    /**
     * Color of all areas' outline which are in the map svg file, but not listed as areas in DataSet. #FFFFFF 
     */
    unlistedAreasOutlineColor: string
}


/**
 * Slice is an item of AmPieChart's chartData Array and holds all the information about the slice. When working with a pie chart, you do not create slices or change it's properties directly, instead you set array of data using dataProvider property. Consider properties of a Slice read-only - change values in chart's data provider if you need to. 
 */
declare class Slice {

    /**
     * Opacity of a slice. 
     */
    alpha: number;

    /**
     * Color of a slice. 
     */
    color: string;

    /**
     * Original object from data provider. 
     */
    dataContext: Object;

    /**
     * Slice description. 
     */
    description: string;

    /**
     * Specifies whether the slice is hidden 
     */
    hidden: boolean;

    /**
     * Percent value of a slice. 
     */
    percents: number;

    /**
     * Specifies whether the slice is pulled or not. 
     */
    pulled: boolean;

    /**
     * Slice title 
     */
    title: string;

    /**
     * Url of a slice 
     */
    url: string;

    /**
     * Value of a slice 
     */
    value: number;

    /**
     * specifies whether this slice has a legend entry 
     */
    visibleInLegend: boolean
}


/**
 * AmStockChart is a main class Stock chart. 
 */
declare class AmStockChart {

    /**
     * Specifies if animation was already played. Animation is only played once, when chart is rendered for the first time. If you want the animation to be repeated, set this property to false. 
     */
    animationPlayed: boolean;

    /**
     * Balloon object. 
     */
    balloon: AmCharts$AmBalloon;

    /**
     * Settings for category axes. 
     */
    categoryAxesSettings: AmCharts$CategoryAxesSettings;

    /**
     * Indicates if the chart is created. 
     */
    chartCreated: boolean;

    /**
     * Chart cursor settings. 
     */
    chartCursorSettings: AmCharts$ChartCursorSettings;

    /**
     * Chart scrollbar settings. 
     */
    chartScrollbarSettings: AmCharts$ChartScrollbarSettings;

    /**
     * Array of colors used by data sets if no color was set explicitly on data set itself. #FF6600, "#FCD202", "#B0DE09", "#0D8ECF", "#2A0CD0", "#CD0D74", "#CC0000", "#00CC00", "#0000CC", "#DDDDDD", "#999999", "#333333", "#990000" 
     */
    colors: any[];

    /**
     * Array of data sets selected for comparing. 
     */
    comparedDataSets: any[];

    /**
     * Array of DataSets. 
     */
    dataSets: any[];

    /**
     * DataSetSelector object. You can add it if you have more than one data set and want users to be able to select/compare them. 
     */
    dataSetSelector: AmCharts$DataSetSelector;

    /**
     * Current end date of the selected period, get only. To set start/end dates, use stockChart.zoom(startDate, endDate) method. 
     */
    endDate: Date;

    /**
     * Defines on which day week starts. 0 - Sunday, 1 - Monday..
     * @default  1 
     */
    firstDayOfWeek: number;

    /**
     * If set to true the scope of the data view will be set to the end after data update. 
     */
    glueToTheEnd: boolean;

    /**
     * Legend settings. 
     */
    legendSettings: AmCharts$LegendSettings;

    /**
     * Data set selected as main. 
     */
    mainDataSet: AmCharts$DataSet;

    /**
     * Array of StockPanels (charts). 
     */
    panels: any[];

    /**
     * Settings for stock panels. 
     */
    panelsSettings: AmCharts$PanelsSettings;

    /**
     * Period selector object. You can add it if you want user's to be able to enter date ranges or zoom chart with predefined period buttons. 
     */
    periodSelector: AmCharts$PeriodSelector;

    /**
     * Scrollbar's chart object, get only. 
     */
    scrollbarChart: AmCharts$AmSerialChart;

    /**
     * Current start date of the selected period, get only. To set start/end dates, use stockChart.zoom(startDate, endDate) method. 
     */
    startDate: Date;

    /**
     * Settings for stock events. 
     */
    stockEventsSettings: any;

    /**
     * Settings for value axes. 
     */
    valueAxesSettings: AmCharts$ValueAxesSettings;

    /**
     * read-only. Indicates current version of a script. 
     */
    version: string;

    /**
     * Specifies whether the chart should zoom-out when main data set is changed. 
     */
    zoomOutOnDataSetChange: boolean;

    /**
     * Adds panel to the stock chart. Requires stockChart.validateNow() method to be called after this action. 
     */
    addPanel(panel: AmCharts$StockPanel): void;

    /**
     * Adds panel to the stock chart at a specified index. Requires stockChart.validateNow() method to be called after this action. 
     */
    addPanelAt(panel: AmCharts$StockPanel, index: number): void;

    /**
     * Destroys chart, all timeouts and listeners. 
     */
    clear(): void;

    /**
     * Hides event bullets. 
     */
    hideStockEvents(): void;

    /**
     * Removes event listener from the object. 
     */
    removeListener(obj: any, type: string, handler: any): void;

    /**
     * Removes panel from the stock chart. Requires stockChart.validateNow() method to be called after this action. 
     */
    removePanel(panel: AmCharts$StockPanel): void;

    /**
     * Shows event bullets. 
     */
    showStockEvents(): void;

    /**
     * Method which should be called after data was changed. 
     */
    validateData(): void;

    /**
     * Method which forces the stock chart to rebuild. Should be called after properties are changed. 
     */
    validateNow(): void;

    /**
     * Zooms chart to specified dates. startDate, endDate - Date objects. 
     */
    zoom(startDate: Date, endDate: Date): void;

    /**
     * Zooms out the chart. 
     */
    zoomOut(): void;

    /**
     * Adds event listener of the type "dataUpdated" or "init" or "rendered" to the object.
     * @param type Always "dataUpdated" or "init" or "rendered".
     * @param handler If the type is "dataUpdated", dispatched when the chart was updated with new data.
    If the type is "init", dispatched when the chart is initialized for the first time. In case you want it to fire again after validateNow() method is called, set chart.chartCreated = false.
    If the type is "rendered", dispatched each when chart is rendered.
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "dataUpdated" or "init". 
                 */
                type: string,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "rollOutStockEvent" or "rollOverStockEvent" or "clickStockEvent" to the object.
     * @param type // Either "rollOutStockEvent" or "rollOverStockEvent" or "clickStockEvent".
     * @param handler If the type is "rollOutStockEvent", dispatched when the user rolls-out of the Stock event (bullet).
    If the type is "rollOverStockEvent", dispatched when the user rolls-over of the Stock event (bullet).
    If the type is "clickStockEvent", dispatched when the user clicks on the Stock event (bullet).
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "rollOverStockEvent". 
                 */
                type: string,
                eventObject: any,
                graph: AmCharts$AmGraph,
                date: Date,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "zoomed" to the object.
     * @param type Always "zoomed".
     * @param handler Dispatched when the chart is zoomed (even for the first time, when chart is initialized).
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "zoomed". 
                 */
                type: string,
                startDate: Date,
                endDate: Date,
                period: string,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Adds event listener of the type "panelRemoved" to the object.
     * @param type Always "panelRemoved".
     * @param handler Dispatched when the StockPanel is removed.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "panelRemoved". 
                 */
                type: string,
                panel: AmCharts$StockPanel,
                chart: AmCharts$AmStockChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * ValueAxesSettings settings set 's settings for all ValueAxes. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of ValueAxis class will be used. 
 */
declare class ValueAxesSettings {

    /**
     * Specifies whether number for gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. 
     */
    axisAlpha: number;

    /**
     * Axis color.  
     */
    axisColor: string;

    /**
     * Thickness of the axis. 
     */
    axisThickness: number;

    /**
     * Label color. 
     */
    color: string;

    /**
     * Length of a dash. By default, the grid line is not dashed. 
     */
    dashLength: number;

    /**
     * Fill opacity. Every second space between grid lines can be filled with color. 
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. 
     */
    fillColor: string;

    /**
     * Opacity of grid lines. 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. 
     */
    gridColor: string;

    /**
     * Approximate number of grid lines. autoGridCount should be set to false, otherwise this property will be ignored. 
     */
    gridCount: number;

    /**
     * Thickness of grid lines. 
     */
    gridThickness: number;

    /**
     * Specifies whether guide values should be included when calculating min and max of the axis. 
     */
    includeGuidesInMinMax: boolean;

    /**
     * If true, the axis will include hidden graphs when calculating min and max values. 
     */
    includeHidden: boolean;

    /**
     * Specifies whether values should be placed inside or outside plot area. In case you set this to false, you'll have to adjust marginLeft or marginRight in [[PanelsSettings]] in order labels to be visible.
     * @default  true
     */
    inside: boolean;

    /**
     * Specifies whether values on axis can only be integers or both integers and doubles. 
     */
    integersOnly: boolean;

    /**
     * Frequency at which labels should be placed.  
     */
    labelFrequency: number;

    /**
     * Specifies whether value labels are displayed. 
     */
    labelsEnabled: boolean;

    /**
     * Set to true if value axis is logarithmic, false otherwise. 
     */
    logarithmic: boolean;

    /**
     * The distance of the axis to the plot area, in pixels. Useful if you have more then one axis on the same side.  
     */
    offset: number;

    /**
     * Position of the value axis. Possible values are "left" and "right". 
     */
    position: string;

    /**
     * Set to true if value axis is reversed (smaller values on top), false otherwise. 
     */
    reversed: boolean;

    /**
     * Specifies if first label of value axis should be displayed. 
     */
    showFirstLabel: boolean;

    /**
     * Specifies if last label of value axis should be displayed. 
     */
    showLastLabel: boolean;

    /**
     * Stacking mode of the axis. Possible values are: "none", "regular", "100%", "3d". 
     */
    stackType: string;

    /**
     * Tick length. 
     */
    tickLength: number;

    /**
     * Unit which will be added to the value label.  
     */
    unit: string;

    /**
     * Position of the unit. Possible values are "left" or "right". 
     */
    unitPosition: string
}


/**
 * AmLegend is the class that displays legend of the chart. Legend to the chart should be added using chart.addLegend(legend) method.
 * @example  var chart = new AmCharts.AmSerialChart();
var legend = new AmCharts.AmLegend();
chart.addLegend(legend);
*/
declare class AmLegend {

    /**
     * Alignment of legend entries. Possible values are: "left", "center", "right". left 
     */
    align: string;

    /**
     * Used if chart is Serial or XY. In case true, margins of the legend are adjusted and made equal to chart's margins.
     * @default  true
     */
    autoMargins: boolean;

    /**
     * Opacity of legend's background. Value range is 0 - 1 
     */
    backgroundAlpha: number;

    /**
     * Background color. You should set backgroundAlpha to >0 vallue in order background to be visible. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * Opacity of chart's border. Value range is 0 - 1. 
     */
    borderAlpha: number;

    /**
     * Color of legend's border. You should set borderAlpha >0 in order border to be visible. #000000 
     */
    borderColor: string;

    /**
     * In case legend position is set to "absolute", you can set distance from bottom of the chart, in pixels.  
     */
    bottom: number;

    /**
     * Text color. Will use chart's color if not set. 
     */
    color: string;

    /**
     * This can be used by AmMap only. You can pass array of objects with title, color, markerType values, for example: [{title: "One", color: "#3366CC"},{title: "Two", color: "#FFCC33"}] 
     */
    data: any[];

    /**
     * Specifies if each of legend entry should be equal to the most wide entry. Won't look good if legend has more than one line.
     * @default  true
     */
    equalWidths: boolean;

    /**
     * Font size. Will use chart's font size if not set. 
     */
    fontSize: string;

    /**
     * Horizontal space between legend item and left/right border. 
     */
    horizontalGap: number;

    /**
     * The text which will be displayed in the legend. Tag [[title]] will be replaced with the title of the graph. [[title]] 
     */
    labelText: string;

    /**
     * In case legend position is set to "absolute", you can set distance from left side of the chart, in pixels. 
     */
    left: number;

    /**
     * Bottom margin.  
     */
    marginBottom: number;

    /**
     * Left margin. This property will be ignored if chart is Serial or XY and autoMargins property of the legend is true (default).
     * @default  20
     */
    marginLeft: number;

    /**
     * Right margin. This property will be ignored if chart is Serial or XY and autoMargins property of the legend is true (default).
     * @default  20
     */
    marginRight: number;

    /**
     * Top margin. 
     */
    marginTop: number;

    /**
     * Marker border opacity 1. 
     */
    markerBorderAlpha: number;

    /**
     * Marker border color. If not set, will use the same color as marker. 
     */
    markerBorderColor: string;

    /**
     * Thickness of the legend border. The default value (0) means the line will be a "hairline" (1 px). In case marker type is line, this style will be used for line thickness.
     * @default  1
     */
    markerBorderThickness: number;

    /**
     * The color of the disabled marker (when the graph is hidden). #AAB3B3 
     */
    markerDisabledColor: string;

    /**
     * Space between legend marker and legend text, in pixels.
     * @default  5
     */
    markerLabelGap: number;

    /**
     * Size of the legend marker (key).
     * @default  16
     */
    markerSize: number;

    /**
     * Shape of the legend marker (key). Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble", "none". square 
     */
    markerType: string;

    /**
     * Maximum number of columns in the legend. If Legend's position is set to "right" or "left", maxColumns is automatically set to 1. 
     */
    maxColumns: number;

    /**
     * Position of a legend. Possible values are: "bottom", "top", "left", "right" and "absolute". In case "absolute", you should set left and top properties too. (this setting is ignored in Stock charts). In case legend is used with AmMap, position is set to "absolute" automatically.  bottom 
     */
    position: string;

    /**
     * Specifies whether legend entries should be placed in reversed order. 
     */
    reversedOrder: boolean;

    /**
     * In case legend position is set to "absolute", you can set distance from right side of the chart, in pixels. 
     */
    right: number;

    /**
     * Legend item text color on roll-over.  #CC0000 
     */
    rollOverColor: string;

    /**
     * When you roll-over the legend entry, all other graphs can reduce their opacity, so that the graph you rolled-over would be distinguished. This style specifies the opacity of the graphs.
     * @default  1
     */
    rollOverGraphAlpha: number;

    /**
     * You can use this property to turn all the legend entries off.
     * @default  true
     */
    showEntries: boolean;

    /**
     * Horizontal space between legend items, in pixels.
     * @default  10
     */
    spacing: number;

    /**
     * Whether showing/hiding of graphs by clicking on the legend marker is enabled or not. In case legend is used with AmMap, this is set to false automatically.
     * @default  true
     */
    switchable: boolean;

    /**
     * Legend switch color. #FFFFFF 
     */
    switchColor: string;

    /**
     * Legend switch type (in case the legend is switchable). Possible values are "x" and "v". x 
     */
    switchType: string;

    /**
     * If true, clicking on the text will show/hide balloon of the graph. Otherwise it will show/hide graph/slice, if switchable is set to true.  
     */
    textClickEnabled: boolean;

    /**
     * In case legend position is set to "absolute", you can set distance from top of the chart, in pixels. 
     */
    top: number;

    /**
     * Legend markers can mirror graphs settings, displaying a line and a real bullet as in the graph itself.
     * Setthis property to true if you want to enable this feature. Note, if you set graph colors in dataProvider, they will not be reflected in the marker.
     * @default  false
     */
    useGraphSettings: boolean;

    /**
     * Specifies if legend labels should be use same color as corresponding markers. 
     */
    useMarkerColorForLabels: boolean;

    /**
     * Alignment of the value text. Possible values are "left" and "right". right 
     */
    valueAlign: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. [[value]] 
     */
    valueText: string;

    /**
     * Width of the value text.
     * @default  80
     */
    valueWidth: number;

    /**
     * Vertical space between legend items also between legend border and first and last legend row.  10 
     */
    verticalGap: number;

    /**
     * Adds event listener of the type "clickLabel" or "clickMarker" or "hideItem" to the object.
     * @param type Either "clickLabel" or "clickMarker" or "hideItem".
     * @param handler If the type is "clickLabel", dispatched when legend label is clicked.
    If the type is "clickMarker", dispatched when legend marker is clicked.
    If the type is "hideItem", dispatched when user clicks on a legend item marker and hides corresponding object.
    If the type is "rollOutItem", dispatched when user rolls-out of the legend item label (or whole item, if switchable is set to false).
    If the type if "rollOverItem", dispatched when user rolls-over the legend item label (or whole item, if switchable is set to false).
    If the type is "rollOutMarker", dispatched when user clicks out of a legend item marker and shows corresponding object.
    If the type if "rollOverMarker", dispatched when user clicks on a legend item marker and shows corresponding object.Adds event listener of the type "showItem" to the object.
     * @param type Always "showItem".
     * @param handler 
    */
    addListener(
        type: string,
        handler: (e: {
            type: string,
            dataItem: Object,
            chart: AmCharts$AmChart
        }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * StockLegend is a legend of StockPanel. 
 */
declare class StockLegend mixins AmLegend {

    /**
     * The text which will be displayed in the value portion of the legend when graph is comparable and at least one dataSet is selected for comparing. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents.value/open/close/low/high]], [[description]]. [[percents.value]]% 
     */
    valueTextComparing: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]].  [[value]] 
     */
    valueTextRegular: string
}


/**
 * StockPanel class creates stock panels (charts). AmStockChart can have multiple Stock panels. 
 */
declare class StockPanel mixins AmSerialChart {

    /**
     * Specifies whether x button will be displayed near the panel. This button allows turning panel off. 
     */
    allowTurningOff: boolean;

    /**
     * If true, drawing icons will be displayed in top-right corner. 
     */
    drawingIconsEnabled: boolean;

    /**
     * Specifies on which value axis user can draw trend lines. Set drawingIconsEnabled to true if you want drawing icons to be visible. First value axis will be used if not set here. 
     */
    drawOnAxis: AmCharts$ValueAxis;

    /**
     * Specifies if all trend lines should be erased when erase button is clicked. If false, trend lines can be erased one by one. 
     */
    eraseAll: boolean;

    /**
     * Size of trend line drawing icons. If you change this size, you should update icon images if you want them to look properly.
     * @default  18
     */
    iconSize: number;

    /**
     * Relative height of panel. Possible values 0 - 100. 
     */
    percentHeight: number;

    /**
     * Specifies when values should be recalculated to percents. Possible values are: "never", "always", "whenComparing".  whenComparing 
     */
    recalculateToPercents: string;

    /**
     * Specifies whether this panel will show category axis.
     * @default  true
     */
    showCategoryAxis: boolean;

    /**
     * 
     */
    stockGraphs: AmCharts$StockGraph[];

    /**
     * Stock chart legend. 
     */
    stockLegend: AmCharts$StockLegend;

    /**
     * Title of a panel. Note, StockLegend should be added in order title to be displayed. 
     */
    title: string;

    /**
     * Trend line opacity.
     * @default  1
     */
    trendLineAlpha: number;

    /**
     * Trend line color. #00CC00 
     */
    trendLineColor: string;

    /**
     * Trend line dash length. 
     */
    trendLineDashLength: number;

    /**
     * Trend line thickness.
     * @default  2
     */
    trendLineThickness: number;

    /**
     * Adds a graph to the panel. 
     */
    addStockGraph(graph: AmCharts$StockGraph): void;

    /**
     * Removes graph from the panel. 
     */
    removeStockGraph(graph: AmCharts$StockGraph): void
}


/**
 * AmChart is a base class of all charts. It can not be instantiated explicitly. AmCoordinateChart, AmPieChart and AmMap extend AmChart class. 
 */
declare class AmChart {

    /**
     * used when constructing a chart with a theme 
     */
    constructor(theme?: any): this;

    /**
     * Specifies, if class names should be added to chart elements. 
     */
    addClassNames: boolean;

    /**
     * Array of Labels. Example of label object, with all possible properties:
     * {"x":20,"y": 20, "text": "this is label", "align": "left", "size": 12, "color": "#CC0000", "alpha": 1, "rotation": 0, "bold": true, "url": "http://www.amcharts.com"} 
     */
    allLabels: AmCharts$Label[];

    /**
     * Set this to false if you don't want chart to resize itself whenever its parent container size changes. 
     */
    autoResize: boolean;

    /**
     * Opacity of background. Set it to >0 value if you want backgroundColor to work. However we recommend changing div's background-color style for changing background color. 
     */
    backgroundAlpha: number;

    /**
     * Background color. You should set backgroundAlpha to >0 value in order background to be visible. We recommend setting background color directly on a chart's DIV instead of using this property. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * The chart creates AmBalloon class itself. If you want to customize balloon, get balloon instance using this property, and then change balloon's properties.  AmBalloon 
     */
    balloon: AmCharts$AmBalloon;

    /**
     * Opacity of chart's border. Value range is 0 - 1. 
     */
    borderAlpha: number;

    /**
     * Color of chart's border. You should set borderAlpha >0 in order border to be visible. We recommend setting border color directly on a chart's DIV instead of using this property. #000000 
     */
    borderColor: string;

    /**
     * This prefix is added to all class names which are added to all visual elements of a chart in case addClassNames is set to true. 
     */
    classNamePrefix: string;

    /**
     * Text color. #000000 
     */
    color: string;

    /**
     * Non-commercial version only. Specifies position of link to amCharts site. Allowed values are: top-left, top-right, bottom-left and bottom-right.
     * @default  'top-left'
     */
    creditsPosition: string;

    /**
     * Array of data objects, for example: [{country:"US", value:524},{country:"UK", value:624},{country:"Lithuania", value:824}]. You can have any number of fields and use any field names. In case of AmMap, data provider should be MapData object. 
     */
    dataProvider: any[];

    /**
     * Decimal separator.
     * @Default  . 
     */
    decimalSeparator: string;

    /**
     * Using this property you can add any additional information to SVG, like SVG filters or clip paths. The structure of this object should be identical to XML structure of a object you are adding, only in JSON format. 
     */
    defs: any;

    /**
     * Export config. Specifies how export to image/data export/print/annotate menu will look and behave. You can find a lot of examples in amcharts/plugins/export folder. 
     */
    export: AmCharts$ExportSettings;

    /**
     * Font family. Verdana 
     */
    fontFamily: string;

    /**
     * Font size.
     * @default  11
     */
    fontSize: string;

    /**
     * If you set this to true, the lines of the chart will be distorted and will produce hand-drawn effect. Try to adjust chart.handDrawScatter and chart.handDrawThickness properties for a more scattered result.
     * @Default  false
     */
    handDrawn: boolean;

    /**
     * Defines by how many pixels hand-drawn line (when handDrawn is set to true) will fluctuate.
     * @Default  2
     */
    handDrawScatter: number;

    /**
     * Defines by how many pixels line thickness will fluctuate (when handDrawn is set to true).
     * @Default  1
     */
    handDrawThickness: number;

    /**
     * Time, in milliseconds after which balloon is hidden if the user rolls-out of the object. Might be useful for AmMap to avoid balloon flickering while moving mouse over the areas. Note, this is not duration of fade-out. Duration of fade-out is set in AmBalloon class.
     * @Default  150
     */
    hideBalloonTime: number;

    /**
     * Allows changing language easily.
     * Note, you should include the language.js file from amcharts/lang or ammap/lang folder and then use variable name used in this file, like chart.language = "de";
    Note, for maps this works differently - you use language only for country names, as there are no other strings in the maps application. 
    */
    language: string;

    /**
     * Legend of a chart. 
     */
    legend: AmCharts$AmLegend;

    /**
     * Reference to the div of the legend. 
     */
    legendDiv: HTMLElement;

    /**
     * You can add listeners of events using this property. Example: listeners = [{"event":"dataUpdated", "method":handleEvent}]; 
     */
    listerns: Object[];

    /**
     * This setting affects touch-screen devices only. If a chart is on a page, and panEventsEnabled are set to true, the page won't move if the user touches the chart first. If a chart is big enough and occupies all the screen of your touch device, the user wont be able to move the page at all. That's why the default value is "false". If you think that selecting/panning the chart or moving/pinching the map is a primary purpose of your users, you should set panEventsEnabled to true. 
     */
    panEventsEnabled: boolean;

    /**
     * Specifies absolute or relative path to amCharts files, i.e. "amcharts/". (where all .js files are located)
     * If relative URLs are used, they will be relative to the current web page, displaying the chart.
    You can also set path globally, using global JavaScript variable AmCharts_path. If this variable is set, and "path" is not set in chart config, the chart will assume the path from the global variable. This allows setting amCharts path globally. I.e.:
    var AmCharts_path = "/libs/amcharts/";
    "path" parameter will be used by the charts to locate it's files, like images, plugins or patterns.
    */
    path: string;

    /**
     * Specifies path to the folder where images like resize grips, lens and similar are.
     * IMPORTANT: Since V3.14.12, you should use "path" to point to amCharts directory instead. The "pathToImages" will be automatically set and does not need to be in the chart config, unless you keep your images separately from other amCharts files. 
     */
    pathToImages: string;

    /**
     * Precision of percent values. -1 means percent values won't be rounded at all and show as they are.
     * @default  2
     */
    percentPrecision: number;

    /**
     * Precision of values. -1 means values won't be rounded at all and show as they are.
     * @Default  1
     */
    precision: number;

    /**
     * Prefixes which are used to make big numbers shorter: 2M instead of 2000000, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e+3,prefix:"k"},{number:1e+6,prefix:"M"},{number:1e+9,prefix:"G"},{number:1e+12,prefix:"T"},{number:1e+15,prefix:"P"},{number:1e+18,prefix:"E"},{number:1e+21,prefix:"Z"},{number:1e+24,prefix:"Y"}] 
     */
    prefixesOfBigNumbers: any[];

    /**
     * Prefixes which are used to make small numbers shorter: 2 instead of 0.000002, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e-24, prefix:"y"},{number:1e-21, prefix:"z"},{number:1e-18, prefix:"a"},{number:1e-15, prefix:"f"},{number:1e-12, prefix:"p"},{number:1e-9, prefix:"n"},{number:1e-6, prefix:""},{number:1e-3, prefix:"m"}] 
     */
    prefixesOfSmallNumbers: any[];

    /**
     * A config object for Responsive plugin. 
     */
    responsive: any;

    /**
     * Theme of a chart. Config files of themes can be found in amcharts/themes/ folder. More info about using themes. 
     */
    theme: string;

    /**
     * Thousands separator.
     * @default  .
     */
    thousandsSeparator: string;

    /**
     * Array of Title objects. 
     */
    titles: AmCharts$Title[];

    /**
     * Type of a chart. Required when creating chart using JSON. Possible types are: serial, pie, xy, radar, funnel, gauge, map, stock. 
     */
    type: string;

    /**
     * If true, prefixes will be used for big and small numbers. You can set arrays of prefixes via prefixesOfSmallNumbers and prefixesOfBigNumbers properties. 
     */
    usePrefixes: boolean;

    /**
     * Read-only. Indicates current version of a script. 
     */
    version: string;

    /**
     * Adds a label on a chart.
     * You can use it for labeling axes, adding chart title, etc. x and y coordinates can be set in number, percent, or a number with ! in front of it - coordinate will be calculated from right or bottom instead of left or top.
    x - horizontal coordinate
    y - vertical coordinate
    text - label's text
    align - alignment (left/right/center)
    size - text size
    color - text color
    rotation - angle of rotation
    alpha - label alpha
    bold - specifies if text is bold (true/false),
    url - url
    */
    addLabel(
        x: number | string,
        y: number | string,
        text: string,
        align: string,
        size?: number,
        color?: string,
        rotation?: number,
        alpha?: number,
        bold?: boolean,
        url?: string): void;

    /**
     * Adds a legend to the chart.
     * By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter.
    (NOTE: This method will not work on StockPanel.)
     * @param legend 
     * @param legendDivId - Id of the legend div (optional).
    */
    addLegend(legend: AmCharts$AmLegend, legendDivId?: string): void;

    /**
     * Adds a legend to the chart.
     * By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter.
    (NOTE: This method will not work on StockPanel.)
     * @param legend 
     * @param legendDiv - Legend div (optional).
    */
    addLegend(legend: AmCharts$AmLegend, legendDiv: HTMLElement): void;

    /**
     * Adds title to the top of the chart. Pie, Radar positions are updated so that they won't overlap. Plot area of Serial/XY chart is also updated unless autoMargins property is set to false. You can add any number of titles - each of them will be placed in a new line. To remove titles, simply clear titles array: chart.titles = []; and call chart.validateNow() method. text - text of a title size - font size color - title color alpha - title opacity bold - boolean value indicating if title should be bold. 
     */
    addTitle(text: string, size: number, color: string, alpha: number, bold: boolean): void;

    /**
     * Clears the chart area, intervals, etc. 
     */
    clear(): void;

    /**
     * Removes all labels added to the chart. 
     */
    clearLabels(): void;

    /**
     * Use this method to force the chart to resize to it's current container size. 
     */
    invalidateSize(): void;

    /**
     * Removes chart's legend. 
     */
    removeLegend(): void;

    /**
     * This method should be called after data in your data provider changed or a new array was set to dataProvider. After calling this method the chart will parse data and redraw. 
     */
    validateData(): void;

    /**
     * This method should be called after you changed one or more properties of any class. The chart will redraw after this method is called. 
     */
    validateNow(): void;

    /**
     * Adds chart to the specified DIV.
     * @param container DIV object which will hold the chart. 
     */
    write(container: HTMLElement): void;

    /**
     * Adds chart to the specified DIV.
     * @param container Id of a DIV which will hold the chart. 
     */
    write(container: string): void;

    /**
     * Adds event listener of the type "dataUpdated" or "init" to the object.
     * @param type "dataUpdated" or "init".
     * @param handler If the type is "dataUpdated".
         Dispatched when chart is build for the first time or after validateData() method was called.
    If the type is "init".
         Dispatched when chart is build for the first time.
    */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "dataUpdated" or "init". 
                 */
                type: string,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * AmCoordinateChart is a base class of AmRectangularChart. It can not be instantiated explicitly. 
 */
declare class AmCoordinateChart mixins AmChart {

    /**
     * Read-only. Array, holding processed chart's data. 
     */
    chartData: Object[];

    /**
     * Specifies the colors of the graphs if the lineColor of a graph is not set.
     * It there are more graphs then colors in this array, the chart picks random color.
     * @default  ['#FF6600', '#FCD202', '#B0DE09', '#0D8ECF', '#2A0CD0', '#CD0D74', '#CC0000', '#00CC00', '#0000CC', '#DDDDDD', '#999999', '#333333', '#990000'] 
     */
    colors: string[];

    /**
     * The array of graphs belonging to this chart.
     * To add/remove graph use addGraph/removeGraph methods instead of adding/removing graphs directly to array.
     */
    graphs: AmCharts$AmGraph[];

    /**
     * Specifies if grid should be drawn above the graphs or below. Will not work properly with 3D charts.
     * @default  false
     */
    gridAboveGraphs: boolean;

    /**
     * Instead of adding guides to the axes, you can push all of them to this array. In case guide has category or date defined, it will automatically will be assigned to the category axis. Otherwise to first value axis, unless you specify a different valueAxis for the guide. 
     */
    guides: AmCharts$Guide[];

    /**
     * Specifies whether the animation should be sequenced or all objects should appear at once.
     * @default  true
     */
    sequencedAnimation: boolean;

    /**
     * The initial opacity of the column/line.
     * If you set startDuration to a value higher than 0, the columns/lines will fade in from startAlpha.
    Value range is 0 - 1.
     * @default  1
    */
    startAlpha: number;

    /**
     * Duration of the animation, in seconds. 
     */
    startDuration: number;

    /**
     * Animation effect.
     * Possible values are ">", "<", elastic" and "bounce".
     * @default  "elastic"
     */
    startEffect: string;

    /**
     * Target of url.
     * @default  this
     */
    urlTarget: any;

    /**
     * The array of value axes.
     * To add/remove value axis use addValueAxis/removeValueAxis methods instead of adding/removing axes directly to array.
    Chart creates one value axis automatically, so if you need only one value axis, you don't need to create it.
    */
    valueAxes: any[];

    /**
     * Adds a graph to the chart.
     */
    addGraph(graph: AmCharts$AmGraph): void;

    /**
     * Adds a legend to the chart. By default, you don't need to create div for your legend, however if you want it to be positioned in some different way, you can create div anywhere you want and pass id or reference to your div as a second parameter. (NOTE: This method will not work on StockPanel.) Adds value axis to the chart.
     * One value axis is created automatically, so if you don't want to change anything or add more value axes, you don't need to add it.
     */
    addValueAxis(axis: AmCharts$ValueAxis): void;

    /**
     * You can trigger the animation of the chart. 
     */
    animateAgain(): void;

    /**
     * AmGraph Returns graph by id. 
     */
    getGraphById(graphId: string): AmCharts$AmGraph;

    /**
     * Returns value axis by id.
     */
    getValueAxisById(axisId: string): AmCharts$ValueAxis;

    /**
     * Hide the graph (if it is visible). Usually this method is called from the Legend, when you click on the legend marker.
     */
    hideGraph(graph: AmCharts$AmGraph): void;

    /**
     * Hide value balloon of a graph. Usually this method is called from the Legend, when you click on the legend text.
     */
    hideGraphsBalloon(graph: AmCharts$AmGraph): void;

    /**
     * Highlight the graph. Usually this method is called from the Legend, when you roll-over the legend entry.
     */
    highlightGraph(graph: AmCharts$AmGraph): void;

    /**
     * Removes graph from the chart.
     */
    removeGraph(graph: AmCharts$AmGraph): void;

    /**
     * Removes value axis from the chart. When you remove value axis, all graphs assigned to this axis are also removed. 
     */
    removeValueAxis(axis: AmCharts$ValueAxis): void;

    /**
     * Show the graph (if it is hidden). Usually this method is called from the Legend, when you click on the legend marker.
     */
    showGraph(graph: AmCharts$AmGraph): void;

    /**
     * Show value balloon of a graph. Usually this method is called from the Legend, when you click on the legend text.
     */
    showGraphsBalloon(graph: AmCharts$AmGraph): void;

    /**
     * UnhighlightGraph the graph. Usually this method is called from the Legend, when you roll-out the legend entry.
     */
    unhighlightGraph(graph: AmCharts$AmGraph): void;

    /**
     * Adds event listener of the type "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem" to the object.
     * @param type Either "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem".
     * @param handler Dispatched when user clicks on the data item (column/bullet)
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Either "clickGraphItem" or "doubleClickGraphItem" or "rightClickGraphItem" or "rollOutGraphItem" or "rollOverGraphItem". 
                 */
                type: string,
                graph: AmCharts$AmGraph,
                item: AmCharts$GraphDataItem,
                index: number,
                chart: AmCharts$AmChart
            }) => void): void
}


/**
 * GraphDataItem holds all the information about the graph's data item. When working with a chart, you do not create GraphDataItem objects or change it's properties directly. GraphDataItem is passed to you by events when user interacts with data item on the chart. The list of properties below will help you to extract data item's value/coordinate/etc. 
 */
declare class GraphDataItem {

    /**
     * Opacity of the data item. 
     */
    alpha: number;

    /**
     * Bullet type. 
     */
    bullet: string;

    /**
     * Bullet size.  
     */
    bulletSize: number;

    /**
     * Category value. 
     */
    category: string;

    /**
     * Color of the data item. 
     */
    color: string;

    /**
     * Custom bullet (path to file name). 
     */
    customBullet: string;

    /**
     * Original object from data provider. 
     */
    dataContext: Object;

    /**
     * Description. 
     */
    description: string;

    /**
     * Array of colors of the data item, used by column and candlestick chart only. 
     */
    fillColors: any[];

    /**
     * Object which holds percents when recalculateToPercents is set to true. 
     */
    percents: Object;

    /**
     * SerialDataItem of this graphDataItem 
     */
    serialDataItem: AmCharts$SerialDataItem;

    /**
     * url 
     */
    url: string;

    /**
     * Object which holds values of the data item (value, open, close, low, high). 
     */
    values: Object;

    /**
     * x coordinate of the data item. 
     */
    x: number;

    /**
     * y coordinate of the data item. 
     */
    y: number
}


/**
 * SerialDataItem holds all the information about each series. When working with a chart, you do not create SerialDataItem objects or change it's properties directly. Consider properties of a SerialDataItem read-only - change values in chart's data provider if you need to. When serial chart parses dataProvider, it generates "chartData" array. Objects of this array are SerialDataItem objects. 
 */
declare class SerialDataItem {

    /**
     * You can access each GraphDataItem using this object. The data structure is: graphDataItem = serialDataItem.axes[axisId].graphs[graphId]. 
     */
    axes: Object;

    /**
     * category value. String if parseDates is false, Date if true. 
     */
    category: any;

    /**
     * Timestamp of a series date. Avalable only if parseDates property of CategoryAxis is set to true. 
     */
    time: number;

    /**
     * Coordinate (horizontal or vertical, depends on chart's rotate property) of the series. 
     */
    x: number
}

declare class CategoryAxis mixins AxisBase {

    /**
     * When parse dates is on for the category axis, the chart will try to highlight the beginning of the periods, like month, in bold. Set this to false to disable the functionality.
     * @default  true
     */
    boldPeriodBeginning: boolean;

    /**
     * Date formats of different periods. Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, WW - weeks, YYYY - years. Check this page for date formatting strings. [{period:'fff',format:'JJ:NN:SS'},{period:'ss',format:'JJ:NN:SS'},{period:'mm',format:'JJ:NN'},{period:'hh',format:'JJ:NN'},{period:'DD',format:'MMM DD'},{period:'WW',format:'MMM DD'},{period:'MM',format:'MMM'},{period:'YYYY',format:'YYYY'}] 
     */
    dateFormats: any[];

    /**
     * In case your category axis values are Date objects and parseDates is set to true, the chart will parse dates and will place your data points at irregular intervals. However if you want dates to be parsed (displayed on the axis, baloons, etc), but data points to be placed at equal intervals (omiting dates with no data), set equalSpacing to true. 
     */
    equalSpacing: boolean;

    /**
     * Field in data provider which specifies if the category value should always be shown. For example: categoryAxis.forceShowField = "forceShow"; Field in data provider which specifies if the category value should always be shown. For example: categoryAxis.forceShowField = "forceShow";
     * Andin data:
    {category:"one", forceShow:true, value:100}
    Note, this works only when parseDates is set to false.
    */
    forceShowField: string;

    /**
     * Specifies if a grid line is placed on the center of a cell or on the beginning of a cell. Possible values are: "start" and "middle" This setting doesn't work if parseDates is set to true. middle 
     */
    gridPosition: string;

    /**
     * Specifies if minor grid should be displayed.
     * NOTE: If equalSpacing is set to true, this setting will be ignored.
     * @default  false
     */
    minorGridEnabled: boolean;

    /**
     * Specifies the shortest period of your data. This should be set only if parseDates is set to "true". Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, YYYY - years. DD 
     */
    minPeriod: string;

    /**
     * In case your category axis values are Date objects, set this to true. In this case the chart will parse dates and will place your data points at irregular intervals. If you want dates to be parsed, but data points to be placed at equal intervals, set both parseDates and equalSpacing to true. 
     */
    parseDates: boolean;

    /**
     * Specifies whether the graph should start on axis or not. In case you display columns, it is recommended to set this to false. If parseDates is set to true, startOnAxis will allways be false, unless equalSpacing is set to true. 
     */
    startOnAxis: boolean;

    /**
     * Works only when parseDates is set to true and equalSpacing is false. If you set it to true, at the position where bigger period changes,
     * category axis will display date strings of bot small and big period, in two rows.
     * @default  false
     */
    twoLineMode: boolean;

    /**
     * Use line color for bullet
     * @default  false
     */
    useLineColorForBulletBorder: boolean;

    /**
     * Number returns coordinate of a category. Works only if parseDates is false. If parseDates is true, use dateToCoordinate method. category - String 
     */
    categoryToCoordinate(category: string): void;

    /**
     * date - Date object Returns Date of the coordinate, in case parseDates is set to true and equalSpacing is set to false.  coordinate - Number 
     */
    coordinateToDate(coordinate: number): void;

    /**
     * Number Returns coordinate of the date, in case parseDates is set to true. if parseDates is false, use categoryToCoordinate method. date - Date object 
     */
    dateToCoordinate(date: Date): void;

    /**
     * Number Returns index of the category which is most close to specified coordinate. x - coordinate 
     */
    xToIndex(x: number): void
}


/**
 * ChartScrollbar class displays chart scrollbar. Supported by AmSerialChart and AmXYChart.
 * @example  var chart = new AmCharts.AmSerialChart();
var chartScrollbar = new AmCharts.ChartScrollbar();
chart.addChartScrollbar(chartScrollbar);
*/
declare class ChartScrollbar {

    /**
     * Specifies whether number of gridCount is specified automatically, acoarding to the axis size. 
     */
    autoGridCount: boolean;

    /**
     * Background opacity.
     * @default  1
     */
    backgroundAlpha: number;

    /**
     * Background color of the scrollbar.
     * @default  #D4D4D4
     */
    backgroundColor: string;

    /**
     * Read-only. Category axis of the scrollbar. 
     */
    categoryAxis: AmCharts$CategoryAxis;

    /**
     * Text color. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Specifies which graph will be displayed in the scrollbar. Only Serial chart's scrollbar can display a graph. 
     */
    graph: AmCharts$AmGraph;

    /**
     * Graph fill opacity. Value range is 0 - 1.  0.1 
     */
    graphFillAlpha: number;

    /**
     * Graph fill color. #000000 
     */
    graphFillColor: string;

    /**
     * Graph line opacity. Value range is 0 - 1. 
     */
    graphLineAlpha: number;

    /**
     * Graph line color. #000000 
     */
    graphLineColor: string;

    /**
     * by default the graph type is the same as the original graph's type, however in case of candlestick or ohlc you might want to show line graph in the scrollbar. Possible values are: "line", "column", "step", "smoothedLine", "candlestick", "ohlc". 
     */
    graphType: string;

    /**
     * Grid opacity. Value range is 0 - 1. 0.7 
     */
    gridAlpha: number;

    /**
     * Grid color. #FFFFFF 
     */
    gridColor: string;

    /**
     * The number of grid lines. 
     */
    gridCount: number;

    /**
     * Specifies whether resize grips are hidden when mouse is away from the scrollbar. 
     */
    hideResizeGrips: boolean;

    /**
     * Specifies whether scrollbar has a resize feature.
     * @default  true
     */
    resizeEnabled: boolean;

    /**
     * Height (width, if chart is rotated) of a scrollbar.  20 
     */
    scrollbarHeight: number;

    /**
     * Duration of scrolling, when the user clicks on scrollbar's background, in seconds.
     * @default  2
    3
    */
    scrollDuration: number;

    /**
     * Selected backround opacity.
     * @default  1
     */
    selectedBackgroundAlpha: number;

    /**
     * Selected background color. #EFEFEF 
     */
    selectedBackgroundColor: string;

    /**
     * Selected graph's fill opacity. Value range is 0 - 1. 0.5 
     */
    selectedGraphFillAlpha: number;

    /**
     * Selected graph's fill color. #000000 
     */
    selectedGraphFillColor: string;

    /**
     * Selected graph's line opacity. Value range is 0 - 1. 
     */
    selectedGraphLineAlpha: number;

    /**
     * Selected graph's line color. #000000 
     */
    selectedGraphLineColor: string;

    /**
     * Specifies if the chart should be updated while dragging/resizing the scrollbar or only at the moment when user releases mouse button. 
     */
    updateOnReleaseOnly: boolean
}


/**
 * AmRectangularChart is a base class of AmSerialChart and AmXYChart. It can not be instantiated explicitly.
 */
declare class AmRectangularChart mixins AmCoordinateChart {

    /**
     * The angle of the 3D part of plot area. This creates a 3D effect (if the "depth3D" is>0).
     * @default  0
     */
    angle: number;

    /**
     * Space left from axis labels/title to the chart's outside border, if autoMargins set to true.
     * @default  10
     */
    autoMarginOffset: number;

    /**
     * Specifies if margins of a chart should be calculated automatically so that labels of axes would fit. The chart will adjust only margins with axes. Other margins will use values set with marginRight, marginTop, marginLeft and marginBottom properties.
     * @default  true
     */
    autoMargins: boolean;

    /**
     * Cursor of a chart. 
     */
    chartCursor: AmCharts$ChartCursor;

    /**
     * Chart scrollbar. 
     */
    chartScrollbar: AmCharts$ChartScrollbar;

    /**
     * The depth of the 3D part of plot area. This creates a 3D effect (if the "angle" is>0).
     * @default  0
     */
    depth3D: number;

    /**
     * Number of pixels between the container's bottom border and plot area. This space can be used for bottom axis' values. If autoMargin is true and bottom side has axis, this property is ignored.
     * @default  20
     */
    marginBottom: number;

    /**
     * Number of pixels between the container's left border and plot area. This space can be used for left axis' values. If autoMargin is true and left side has axis, this property is ignored.
     * @default  20
     */
    marginLeft: number;

    /**
     * Number of pixels between the container's right border and plot area. This space can be used for Right axis' values. If autoMargin is true and right side has axis, this property is ignored.
     * @default  20
     */
    marginRight: number;

    /**
     * Flag which should be set to false if you need margins to be recalculated on next chart.validateNow() call.
     * @default  false
     */
    marginsUpdated: boolean;

    /**
     * Number of pixels between the container's top border and plot area. This space can be used for top axis' values. If autoMargin is true and top side has axis, this property is ignored.
     * @default  20
     */
    marginTop: number;

    /**
     * The opacity of plot area's border. Value range is 0 - 1.
     * @default  0
     */
    plotAreaBorderAlpha: number;

    /**
     * The color of the plot area's border. Note, the it is invisible by default, as plotAreaBorderAlpha default value is 0. Set it to a value higher than 0 to make it visible.
     * @default  '#000000'
     */
    plotAreaBorderColor: string;

    /**
     * Opacity of plot area. Plural form is used to keep the same property names as our Flex charts'. Flex charts can accept array of numbers to generate gradients. Although you can set array here, only first value of this array will be used.
     * @default  0
     */
    plotAreaFillAlphas: number;

    /**
     * You can set both one color if you need a solid color or array of colors to generate gradients, for example: ["#000000", "#0000CC"]
     * @default  '#FFFFFF'
     */
    plotAreaFillColors: any;

    /**
     * If you are using gradients to fill the plot area, you can use this property to set gradient angle. The only allowed values are horizontal and vertical: 0, 90, 180, 270.
     * @default  0
     */
    plotAreaGradientAngle: number;

    /**
     * Array of trend lines added to a chart. You can add trend lines to a chart using this array or access already existing trend lines 
     */
    trendLines: AmCharts$TrendLine[];

    /**
     * Opacity of zoom-out button background.
     * @default  0
     */
    zoomOutButtonAlpha: number;

    /**
     * Zoom-out button background color.
     * @default  '#e5e5e5'
     */
    zoomOutButtonColor: string;

    /**
     * Name of zoom-out button image. In the images folder there is another lens image, called lensWhite.png. You might want to have white lens when background is dark. Or you can simply use your own image.
     * @default  lens.png
     */
    zoomOutButtonImage: string;

    /**
     * Size of zoom-out button image
     * @default  : 17
     */
    zoomOutButtonImageSize: number;

    /**
     * Padding around the text and image.
     * @default  : 8
     */
    zoomOutButtonPadding: number;

    /**
     * Opacity of zoom-out button background when mouse is over it.
     * @default  : 1
     */
    zoomOutButtonRollOverAlpha: number;

    /**
     * Text in the zoom-out button. Show all 
     */
    zoomOutText: string;

    /**
     * Adds a ChartCursor object to a chart 
     */
    addChartCursor(cursor: AmCharts$ChartCursor): void;

    /**
     * Adds a ChartScrollbar to a chart 
     */
    addChartScrollbar(scrollbar: AmCharts$ChartScrollbar): void;

    /**
     * Adds a TrendLine to a chart.
     * You should call chart.validateNow() after this method is called in order the trend line to be visible. 
     */
    addTrendLine(trendLine: AmCharts$TrendLine): void;

    /**
     * Removes cursor from the chart 
     */
    removeChartCursor(): void;

    /**
     * Removes scrollbar from the chart 
     */
    removeChartScrollbar(): void;

    /**
     * Removes a trend line from a chart.
     * You should call chart.validateNow() in order the changes to be visible. 
     */
    removeTrendLine(trendLine: AmCharts$TrendLine): void
}

declare class TrendLine {}


/**
 * ChartCursor is a class which displays a cursor which follows the mouse. In case of Serial chart it also shows value and category balloons.
 * @example  var chart = new AmCharts.AmSerialChart();
var chartCursor = new AmCharts.ChartCursor();
chart.addChartCursor(chartCursor);
*/
declare class ChartCursor {

    /**
     * Specifies if bullet for each graph will follow the cursor. 
     */
    bulletsEnabled: boolean;

    /**
     * Size of bullets, following the cursor.
     * @default  8
     */
    bulletSize: number;

    /**
     * Opacity of the category balloon.
     * @default  1
     */
    categoryBalloonAlpha: number;

    /**
     * Color of the category balloon. cursorColor is used if not set. 
     */
    categoryBalloonColor: string;

    /**
     * Category balloon date format (used only if category axis parses dates). Check this page for instructions on how to format dates. MMM DD, YYYY 
     */
    categoryBalloonDateFormat: string;

    /**
     * Specifies whether category balloon is enabled.
     * @default  true
     */
    categoryBalloonEnabled: boolean;

    /**
     * Text color. #FFFFFF 
     */
    color: string;

    /**
     * Opacity of the cursor line.  1 
     */
    cursorAlpha: number;

    /**
     * Color of the cursor line. #CC0000 
     */
    cursorColor: string;

    /**
     * Specifies where the cursor line should be placed - on the beginning of the period (day, hour, etc) or in the middle (only when parseDates property of categoryAxis is set to true). If you want the cursor to follow mouse and not to glue to the nearest data point, set "mouse" here. Possible values are: "start", "middle", "mouse". 
     */
    cursorPosition: string;

    /**
     * Specifies whether cursor is enabled.
     * @default  true
     */
    enabled: boolean;

    /**
     * If set to true, instead of a cursor line user will see a fill which width will always be equal to the width of one data item.
     * Recommend setting cursorAlpha to 0.1 or some other small number if using this feature.
     * @default  false
     */
    fullWidth: boolean;

    /**
     * If this is set to true, only one balloon at a time will be displayed. Note, this is quite CPU consuming. 
     */
    oneBalloonOnly: boolean;

    /**
     * If this is set to true, the user will be able to pan the chart (Serial only) instead of zooming. 
     */
    pan: boolean;

    /**
     * Opacity of the selection. 
     */
    selectionAlpha: number;

    /**
     * Specifies if cursor should only mark selected area but not zoom-in after user releases mouse button. 
     */
    selectWithoutZooming: boolean;

    /**
     * Specifies whether value balloons are enabled. In case they are not, the balloons might be displayed anyway, when the user rolls-over the column or bullet.
     * @default  true
     */
    valueBalloonsEnabled: boolean;

    /**
     * Specifies if the user can zoom-in the chart. If pan is set to true, zoomable is switched to false automatically.
     * @default  true
     */
    zoomable: boolean;

    /**
     * Indicates if currently user is selecting some chart area to zoom-in. 
     */
    zooming: boolean;

    /**
     * Hides cursor. 
     */
    hideCursor(): void;

    /**
     * You can force cursor to appear at specified cateogry or date. 
     */
    showCursorAt(category: string): void;

    /**
     * Adds event listener of the type "changed" to the object.
     * @param type Always "changed".
     * @param handler Dispatched when cursor position is changed. "index" is a series index over which chart cursors currently is. "zooming" specifies if user is currently zooming (is selecting) the chart. mostCloseGraph property is set only when oneBalloonOnly is set to true.
     */
    addListener(
        type: string,
        handler: (
            e: {
                type: string,
                index: number,
                zooming: boolean,
                mostCloseGraph: AmCharts$AmGraph,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Adds event listener of the type "onHideCursor" to the object.
     * @param type Always "onHideCursor".
     * @param handler Dispatched when cursor is hidden.
     */
    addListener(
        type: string,
        handler: (e: {
            type: string,
            chart: AmCharts$AmChart
        }) => void): void;

    /**
     * Adds event listener of the type "selected" or "zoomed" to the object.
     * @param type "selected" or "zoomed".
     * @param handler If the type is "selected". Dispatched if selectWithoutZooming is set to true and when user selects some period. start and end are indices or timestamp (when categoryAxis.parseDates is true) of selection start/end.
    If the type is "zoomed". Dispatched when user zooms to some period. start and end are indices or timestamp (when categoryAxis.parseDates is true) of selection start/end.
    */
    addListener(
        type: string,
        handler: (
            e: {
                type: string,
                index: number,
                zooming: boolean,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * AmSerialChart is the class you have to use for majority of chart types. The supported chart types are: line, area, column, bar, step line, smoothed line, candlestick and OHLC. The chart can be rotated by 90 degrees so the column chart becomes bar chart. The chart supports simple and logarithmic scales, it can have multiple value axes. The chart can place data points at equal intervals or can parse dates and place data points at irregular intervals.
 * @example  var chartData = [{title:"sample 1",value:130},{title:"sample 2",value:26}];
var chart = new AmCharts.AmSerialChart();
chart.categoryField = "title";
chart.dataProvider = chartData;
var graph = new AmCharts.AmGraph();
graph.valueField = "value";
graph.type = "column";
graph.fillAlphas = 1;
chart.addGraph(graph);
chart.write("chartdiv");
*/
declare class AmSerialChart mixins AmRectangularChart {

    /**
     * Date format of the graph balloon (if chart parses dates and you don't use chartCursor).
     *    
     * @default  'MMM DD, YYYY'
     */
    balloonDateFormat: string;

    /**
     * Read-only. Chart creates category axis itself. If you want to change some properties, you should get this axis from the chart and set properties to this object. 
     */
    categoryAxis: AmCharts$CategoryAxis;

    /**
     * Category field name tells the chart the name of the field in your dataProvider object which will be used for category axis values. 
     */
    categoryField: string;

    /**
     * The gap in pixels between two columns of the same category.
     * @default  5
     */
    columnSpacing: number;

    /**
     * Space between 3D stacked columns.
     * @default  0
     */
    columnSpacing3D: number;

    /**
     * Relative width of columns. Value range is 0 - 1.
     * @default  0.8
     */
    columnWidth: number;

    /**
     * Read-only. If category axis parses dates endDate indicates date to which the chart is currently displayed. 
     */
    endDate: Date;

    /**
     * Read-only. Category index to which the chart is currently displayed. 
     */
    endIndex: number;

    /**
     * Maximum number of series allowed to select. 
     */
    maxSelectedSeries: number;

    /**
     * The longest time span allowed to select (in milliseconds) for example, 259200000 will limit selection to 3 days. 
     */
    maxSelectedTime: number;

    /**
     * The shortest time span allowed to select (in milliseconds) for example, 1000 will limit selection to 1 second.
     * @default  0
     */
    minSelectedTime: number;

    /**
     * Specifies if scrolling of a chart with mouse wheel is enabled. If you press shift while rotating mouse wheel, the chart will zoom-in/out. 
     */
    mouseWheelScrollEnabled: boolean;

    /**
     * Specifies if zooming of a chart with mouse wheel is enabled. If you press shift while rotating mouse wheel, the chart will scroll. 
     */
    mouseWheelZoomEnabled: boolean;

    /**
     * If you set this to true, the chart will be rotated by 90 degrees (the columns will become bars). 
     */
    rotate: boolean;

    /**
     * Read-only. If category axis parses dates startDate indicates date from which the chart is currently displayed. 
     */
    startDate: Date;

    /**
     * Read-only. Category index from which the chart is currently displayed. 
     */
    startIndex: number;

    /**
     * Specifies if chart should zoom-out when data is updated.
     * @default  true
     */
    zoomOutOnDataUpdate: boolean;

    /**
     * Number Returns index of the specified category value. value - series (category value) which index you want to find. 
     */
    getCategoryIndexByValue(value: number): void;

    /**
     * Zooms out, charts shows all available data. 
     */
    zoomOut(): void;

    /**
     * Zooms the chart by the value of the category axis. start - category value, String \\ end - category value, String 
     */
    zoomToCategoryValues(start: Date, end: Date): void;

    /**
     * Zooms the chart from one date to another. start - start date, Date object \\ end - end date, Date object 
     */
    zoomToDates(start: Date, end: Date): void;

    /**
     * Zooms the chart by the index of the category. start - start index, Number \\ end - end index, Number 
     */
    zoomToIndexes(start: Date, end: Date): void
}

declare class PeriodSelector {

    /**
     * Date format of date input fields. Check [[http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/mx/formatters/DateFormatter.html DD-MM-YYYY 
     */
    dateFormat: string;

    /**
     * Text displayed next to "from" date input field. From: 
     */
    fromText: string;

    /**
     * Specifies if period buttons with date range bigger than available data should be hidden.
     * @default  true
     */
    hideOutOfScopePeriods: boolean;

    /**
     * Specifies whether period selector displays "from" and "to" date input fields.
     * @default  true
     */
    inputFieldsEnabled: boolean;

    /**
     * Width of date input fields, in pixels. Works only if period selector is horizontal.
     * @default  100
     */
    inputFieldWidth: number;

    /**
     * Array of predefined period objects. Period object has 4 properties - period, count, label and selected. Possible period values are: "ss" - seconds, "mm" - minutes, "hh" - hours, "DD" - days, "MM" - months and "YYYY" - years. property "count" specifies how many periods this button will select. "label" will be displayed on a button and "selected" is a boolean which specifies if this button is selected when chart is initialized or not. Example: {period:"DD", count:10, label:"10 days", selected:false}. 
     */
    periods: any[];

    /**
     * Text displayed next to predefined period buttons. Zoom: 
     */
    periodsText: string;

    /**
     * Possible values: "right", "left", "top", "bottom". bottom 
     */
    position: string;

    /**
     * Specifies whether predefined period buttons should select a period from the beginning or the end of the data. 
     */
    selectFromStart: boolean;

    /**
     * Text displayed next to "to" date input field. To: 
     */
    toText: string;

    /**
     * Width of a period selector, when position is "left" or "right".
     * @default  180
     */
    width: number;

    /**
     * Adds event listener to the object.
     * .
     * @param handler - Dispatched when dates in period selector input fields are changed or user clicks on one of the predefined period buttons. 
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always: "changed" 
                 */
                type: string,
                startDate: Date,
                endDate: Date,
                predefinedPeriod: string,
                count: number
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}


/**
 * PanelsSettings settings set's settings for all StockPanels. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of StockPanel class will be used. 
 */
declare class PanelsSettings {

    /**
     * The angle of the 3D part of plot area. This creates a 3D effect (if the "depth3D" is>0). 
     */
    angle: number;

    /**
     * Opacity of panel background. Possible values are 1 and 0. Values like 0.5 will not make it half-transparent. 
     */
    backgroundAlpha: number;

    /**
     * Background color of panels. Set backgroundAlpha to>0 value in order to make background visible. #FFFFFF 
     */
    backgroundColor: string;

    /**
     * The gap in pixels between two columns of the same category. 
     */
    columnSpacing: number;

    /**
     * Relative width of columns. Valid values 0 - 1. 
     */
    columnWidth: number;

    /**
     * The depth of the 3D part of plot area. This creates a 3D effect (if the "angle" is>0). 
     */
    depth3D: number;

    /**
     * Font family. 
     */
    fontFamily: string;

    /**
     * Font size. 
     */
    fontSize: string;

    /**
     * Number of pixels between the container's bottom border and plot area.
     * @default  1
     */
    marginBottom: number;

    /**
     * Number of pixels between the container's left border and plot area. If your left valueAxis values ar not placed inside the plot area, you should set marginLeft to 80 or some close value. 
     */
    marginLeft: number;

    /**
     * Number of pixels between the container's left border and plot area. If your right valueAxis values ar not placed inside the plot area, you should set marginRight to 80 or some close value. 
     */
    marginRight: number;

    /**
     * Number of pixels between the container's top border and plot area. 
     */
    marginTop: number;

    /**
     * Gap between panels.
     * @default  8
     */
    panelSpacing: number;

    /**
     * This setting affects touch-screen devices only. If a chart is on a page, and panEventsEnabled are set to true, the page won't move if the user touches the chart first. If a chart is big enough and occupies all the screen of your touch device, the user wont be able to move the page at all. That's why the default value is "false". If you think that selecting or or panning the chart is a primary purpose of your chart users, you should set panEventsEnabled to true. 
     */
    panEventsEnabled: boolean;

    /**
     * The opacity of plot area's border. 
     */
    plotAreaBorderAlpha: number;

    /**
     * The color of the plot area's border. 
     */
    plotAreaBorderColor: string;

    /**
     * Opacity of plot area fill. 
     */
    plotAreaFillAlphas: number;

    /**
     * Specifies the colors used to tint the background gradient fill of the plot area. String or Array of Strings 
     */
    plotAreaFillColors: any;

    /**
     * Prefixes which are used to make big numbers shorter: 2M instead of 2000000, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e+3,prefix:"k"},{number:1e+6,prefix:"M"},{number:1e+9,prefix:"G"},{number:1e+12,prefix:"T"},{number:1e+15,prefix:"P"},{number:1e+18,prefix:"E"},{number:1e+21,prefix:"Z"},{number:1e+24,prefix:"Y"}] 
     */
    prefixesOfBigNumbers: any[];

    /**
     * Prefixes which are used to make small numbers shorter: 2 instead of 0.000002, etc. Prefixes are used on value axes and in the legend. To enable prefixes, set usePrefixes property to true. [{number:1e-24, prefix:"y"},{number:1e-21, prefix:"z"},{number:1e-18, prefix:"a"},{number:1e-15, prefix:"f"},{number:1e-12, prefix:"p"},{number:1e-9, prefix:"n"},{number:1e-6, prefix:""},{number:1e-3, prefix:"m"}] 
     */
    prefixesOfSmallNumbers: any[];

    /**
     * Specifies whether the animation should be sequenced or all objects should appear at once. 
     */
    sequencedAnimation: boolean;

    /**
     * The initial opacity of the column/line. If you set startDuration to a value higher than 0, the columns/lines will fade in from startAlpha. 
     */
    startAlpha: number;

    /**
     * Duration of the animation, in seconds. 
     */
    startDuration: number;

    /**
     * Possible values are: "linear", "<", ">" "<>", "elastic", "bounce". 
     */
    startEffect: string;

    /**
     * If true, prefixes will be used for big and small numbers. 
     */
    usePrefixes: boolean
}


/**
 * DataSet is objects which holds all information about data. 
 */
declare class DataSet {

    /**
     * Category field name in your dataProvider. 
     */
    categoryField: string;

    /**
     * Color of the data set. One of colors from AmStockChart.colors array will be used if not set. 
     */
    color: string;

    /**
     * Whether this data set is selected for comparing. If you change this property, you should call stockChart.validateData() method in order the changes to be applied. 
     */
    compared: boolean;

    /**
     * Data provider of the data set. 
     */
    dataProvider: any[];

    /**
     * Array of field mappings. Field mapping is an object with fromField and toField properties. fromField is a name of your value field in dataProvider. toField might be chosen freely, it will be used to set value/open/close/high/low fields for the StockGraph. Example: {fromField:"val1", toField:"value"}. 
     */
    fieldMappings: any[];

    /**
     * Specifies whether this data set should be visible in "compare to" list.
     * @default  true
     */
    showInCompare: boolean;

    /**
     * Specifies whether this data set should be visible in "select" dropdown.
     * @default  true
     */
    showInSelect: boolean;

    /**
     * Array of StockEvent objects. 
     */
    stockEvents: AmCharts$StockEvent[];

    /**
     * DataSet title. 
     */
    title: string
}

declare class StockGraph mixins AmGraph {

    /**
     * Specifies whether this graph will be compared if some data set is selected for comparing. 
     */
    comparable: boolean;

    /**
     * Specifies a field to be used to generate comparing graph. Note, this field is not the one used in your dataProvider, but toField from FieldMapping object. 
     */
    compareField: string;

    /**
     * Balloon color of comparing graph. 
     */
    compareGraphBalloonColor: string;

    /**
     * Balloon text of comparing graph. 
     */
    compareGraphBalloonText: string;

    /**
     * Bullet of comparing graph. Possible values are: "square", "round", "line", "triangleUp", "triangleDown", "dashedLine", "bubble". 
     */
    compareGraphBullet: string;

    /**
     * Bullet size of comparing graph. 
     */
    compareGraphBulletSize: number;

    /**
     * Corner radius of comparing graph (if type is "column"). 
     */
    compareGraphCornerRadiusTop: number;

    /**
     * Dash length of compare graph. 
     */
    compareGraphDashLength: number;

    /**
     * Fill alpha of comparing graph. 
     */
    compareGraphFillAlphas: number;

    /**
     * Fill color of comparing graph. 
     */
    compareGraphFillColors: string;

    /**
     * Opacity of comparing graph line. 
     */
    compareGraphLineAlpha: number;

    /**
     * Thickness of compare graph. 
     */
    compareGraphLineThickness: number;

    /**
     * Type of comparing graph. Possible values are: "line", "column", "step", "smoothedLine." line 
     */
    compareGraphType: string;

    /**
     * Specifies if compare graph is visible in legend.
     * @default  true
     */
    compareGraphVisibleInLegend: boolean;

    /**
     * When data is grouped to periods, the graph must know which period value should be used. Possible values are: "Open", "Low", "High", "Close", "Average" and "Sum". Close 
     */
    periodValue: string;

    /**
     * Specifies whether data set color should be used as this graph's lineColor.
     * @default  true
     */
    useDataSetColors: boolean
}


/**
 * StockEvent is object which holds information about event(bullet).Values from StockEventsSettings will be used if not set.Stock event bullet's size depends on it's graphs fontSize.When user rolls - over, clicks or rolls - out of the event bullet, AmStockChart dispatches events.
 */
declare class StockEvent {

    /**
     * Opacity of bullet background.
     * @default  1
     */
    backgroundAlpha: number;

    /**
     * Color of bullet background. #DADADA 
     */
    backgroundColor: string;

    /**
     * Opacity of bullet border.
     * @default  1
     */
    borderAlpha: number;

    /**
     * Bullet border color. #888888 
     */
    borderColor: string;

    /**
     * The color of the event text. #000000 
     */
    color: string;

    /**
     * Date of an event. Must be Date object, not a string. 
     */
    date: Date;

    /**
     * graph on which event will be displayed. 
     */
    graph: AmCharts$StockGraph;

    /**
     * Roll-over background color. #CC0000 
     */
    rollOverColor: string;

    /**
     * Specifies if the event should be displayed on category axis 
     */
    showOnAxis: boolean;

    /**
     * Letter which will be displayed on the event. Not all types can display letters. "text" type can display longer texts. 
     */
    text: string;

    /**
     * Type of bullet. Possible values are: "flag", "sign", "pin", "triangleUp", "triangleDown", "triangleLeft", "triangleRight", "text", "arrowUp", "arrowDown". sign 
     */
    type: string;

    /**
     * A URL to go to when user clicks the event. 
     */
    url: string;

    /**
     * target of url, "_blank" for example. 
     */
    urlTarget: string
}


/**
 * Creates a label on the chart which can be placed anywhere, multiple can be assigned. 
 */
declare class Label {

    /**
     * 
     * @Default  'left' 
     */
    align: string;

    /**
     * 
     * @Default  1 
     */
    alpha: number;

    /**
     * Specifies if label is bold or not. 
     */
    bold: boolean;

    /**
     * Color of a label 
     */
    color: string;

    /**
     * Unique id of a Label. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Rotation angle. 
     */
    rotation: number;

    /**
     * Text size 
     */
    size: number;

    /**
     * Text of a label 
     */
    text: string;

    /**
     * URL which will be access if user clicks on a label. 
     */
    url: string;

    /**
     * X position of a label. 
     */
    x: number | string;

    /**
     * y position of a label. 
     */
    y: number | string
}


/**
 * Common settings of legends. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of StockLegend class will be used. 
 */
declare class LegendSettings {

    /**
     * Alignment of legend entries. Possible values are: "left", "right" and "center". 
     */
    align: string;

    /**
     * Specifies if each legend entry should take the same space as the longest legend entry. 
     */
    equalWidths: boolean;

    /**
     * Horizontal space between legend item and left/right border. 
     */
    horizontalGap: number;

    /**
     * The text which will be displayed in the legend. Tag [[title]] will be replaced with the title of the graph. 
     */
    labelText: string;

    /**
     * Space below the last row of the legend, in pixels. 
     */
    marginBottom: number;

    /**
     * Space above the first row of the legend, in pixels. 
     */
    marginTop: number;

    /**
     * Opacity of marker border. 
     */
    markerBorderAlpha: number;

    /**
     * Marker border color. 
     */
    markerBorderColor: string;

    /**
     * Thickness of the legend border. 
     */
    markerBorderThickness: number;

    /**
     * The color of the disabled marker (when the graph is hidden). 
     */
    markerDisabledColor: string;

    /**
     * Space between legend marker and legend text, in pixels. 
     */
    markerLabelGap: number;

    /**
     * Size of the legend marker (key). 
     */
    markerSize: number;

    /**
     * Shape of the legend marker (key). Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble", "none". 
     */
    markerType: string;

    /**
     * Specifies whether legend entries should be placed in reversed order. 
     */
    reversedOrder: boolean;

    /**
     * Legend item text color on roll-over. 
     */
    rollOverColor: string;

    /**
     * When you roll-over the legend entry, all other graphs can reduce their opacity, so that the graph you rolled-over would be distinguished. This property specifies the opacity of the graphs. 
     */
    rollOverGraphAlpha: number;

    /**
     * Whether showing/hiding of graphs by clicking on the legend marker is enabled or not. 
     */
    switchable: boolean;

    /**
     * Legend switch color. 
     */
    switchColor: string;

    /**
     * Legend switch type (in case the legend is switchable). Possible values are: "x" and "v". 
     */
    switchType: string;

    /**
     * Specifies whether the legend text is clickable or not. Clicking on legend text can show/hide value balloons if they are enabled. 
     */
    textClickEnabled: boolean;

    /**
     * Specifies if legend labels should be use same color as corresponding markers. 
     */
    useMarkerColorForLabels: boolean;

    /**
     * The text which will be displayed in the value portion of the legend when graph is comparable and at least one dataSet is selected for comparing. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. 
     */
    valueTextComparing: string;

    /**
     * The text which will be displayed in the value portion of the legend. You can use tags like [[value]], [[open]], [[high]], [[low]], [[close]], [[percents]], [[description]]. 
     */
    valueTextRegular: string;

    /**
     * Width of the value text. Increase this value if your values do not fit in the allocated space. 
     */
    valueWidth: number;

    /**
     * Vertical space between legend items, in pixels. 
     */
    verticalGap: number
}


/**
 * DataSetSelector is a tool for selecting data set's as main and for comparing with main data set. 
 */
declare class DataSetSelector {

    /**
     * Text displayed in the "compare to" combobox (when position is "top" or "bottom"). Select... 
     */
    comboBoxSelectText: string;

    /**
     * Text displayed near "compare to" list. Compare to: 
     */
    compareText: string;

    /**
     * The maximum height of the Compare to field in pixels.
     * @default  150
     */
    listHeight: number;

    /**
     * Possible values: "right", "left", "top", "bottom". "top" and "bottom" positions has a limitation - only one data set can be selected for comparing. left 
     */
    position: string;

    /**
     * Text displayed near "Select" dropDown. Select: 
     */
    selectText: string;

    /**
     * Width of a Data set selector, when position is "left" or "right".
     * @default  180
     */
    width: number
}


/**
 * AmBalloon is the class which generates balloons (datatips). Balloon follows the mouse when you roll-over the pie slice/line bullet/column/etc, chart indicator of serial charts displays value balloons and category balloon. Balloon instance is created by the chart automatically and can be accessed via "balloon" property of AmChart. Chart shows/hides and sets position for every balloon automatically, so all you need to do is to change balloon appearance, if you want to.
 * @example  var chart = new AmCharts.AmSerialChart();
// get balloon intance
var balloon = chart.balloon;
// set properties
balloon.adjustBorderColor = true;
balloon.color = "#000000";
balloon.cornerRadius = 5;
balloon.fillColor = "#FFFFFF";
*/
declare class AmBalloon {

    /**
     * If this is set to true, border color instead of background color will be changed when user rolls-over the slice, graph, etc. 
     */
    adjustBorderColor: boolean;

    /**
     * Balloon border opacity. Value range is 0 - 1.
     * @default  1
     */
    borderAlpha: number;

    /**
     * Balloon border color. #FFFFFF 
     */
    borderColor: string;

    /**
     * Balloon border thickness.
     * @default  2
     */
    borderThickness: number;

    /**
     * Color of text in the balloon. #FFFFFF 
     */
    color: string;

    /**
     * Balloon corner radius.
     * @default  6
     */
    cornerRadius: number;

    /**
     * Balloon background opacity.
     * @default  1
     */
    fillAlpha: number;

    /**
     * Balloon background color. Usually balloon background color is set by the chart. Only if "adjustBorderColor" is "true" this color will be used. #CC0000 
     */
    fillColor: string;

    /**
     * Size of text in the balloon. Chart's fontSize is used by default. 
     */
    fontSize: string;

    /**
     * Horizontal padding of the balloon.
     * @default  8
    3
    */
    horizontalPadding: number;

    /**
     * The width of the pointer (arrow) "root". Only used if cornerRadius is 0.
     * @default  10
     */
    pointerWidth: number;

    /**
     * If cornerRadius of a balloon is >0, showBullet is set to true for value balloons when ChartCursor is used. If you don't want the bullet near the balloon, set it to false: chart.balloon.showBullet = false 
     */
    showBullet: boolean;

    /**
     * Text alignment, possible values "left", "middle" and "right" middle 
     */
    textAlign: string;

    /**
     * Color of the text shadow. #000000 
     */
    textShadowColor: string;

    /**
     * Vertical padding of the balloon.
     * @default  5
     */
    verticalPadding: number;

    /**
     * Hides balloon. 
     */
    hide(): void;

    /**
     * Defines a square within which the balloon should appear. Bounds are set by chart class, you don't need to call this method yourself. 
     */
    setBounds(left: number, top: number, right: number, bottom: number): void;

    /**
     * Sets coordinates the balloon should point to. 
     */
    setPosition(x: number, y: number): void;

    /**
     * Specifies the text which should be displayed. 
     */
    show(value: string): void
}


/**
 * CategoryAxesSettings settings set's settings common for all CategoryAxes of StockPanels. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of CategoryAxis class will be used. 
 */
declare class CategoryAxesSettings {

    /**
     * Specifies whether number of gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. 
     */
    axisAlpha: number;

    /**
     * Axis color. 
     */
    axisColor: string;

    /**
     * Height of category axes. Set it to 0 if you set inside property to true.
     * @default  28
     */
    axisHeight: number;

    /**
     * Thickness of the axis. 
     */
    axisThickness: number;

    /**
     * Text color. 
     */
    color: string;

    /**
     * Length of a dash. 
     */
    dashLength: number;

    /**
     * Date formats of different periods. Possible period values: fff - milliseconds, ss - seconds, mm - minutes, hh - hours, DD - days, MM - months, WW - weeks, YYYY - years. Check this page for date formatting strings. 
     */
    dateFormats: any[];

    /**
     * If you want data points to be placed at equal intervals (omiting dates with no data), set equalSpacing to true. 
     */
    equalSpacing: boolean;

    /**
     * Fill opacity. Every second space between grid lines can be filled with fillColor. 
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. 
     */
    fillColor: string;

    /**
     * Text size. 
     */
    fontSize: string;

    /**
     * Opacity of grid lines. 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. 
     */
    gridColor: string;

    /**
     * Approximate number of grid lines. You should set autoGridCount to false in order this property not to be ignored.
     * @default  10
     */
    gridCount: number;

    /**
     * Thickness of grid lines. 
     */
    gridThickness: number;

    /**
     * Periods to which data will be gruoped in case there are more data items in the selected period than specified in maxSeries property. ["ss", "10ss", "30ss", "mm", "10mm", "30mm", "hh", "DD", "WW", "MM", "YYYY"] 
     */
    groupToPeriods: any[];

    /**
     * Specifies whether values should be placed inside or outside of plot area. 
     */
    inside: boolean;

    /**
     * Rotation angle of a label. 
     */
    labelRotation: number;

    /**
     * Maximum series shown at a time. In case there are more data points in the selection than maxSeries, the chart will group data to longer periods, for example - you have 250 days in the selection, and maxSeries is 150 - the chart will group data to weeks.
     * @default  150
     */
    maxSeries: number;

    /**
     * Specifies the shortest period of your data. fff - millisecond, ss - second, mm - minute, hh - hour, DD - day, MM - month, YYYY - year. DD 
     */
    minPeriod: string;

    /**
     * top or "bottom". 
     */
    position: string;

    /**
     * Specifies whether the graph should start on axis or not. In case you display columns, it is recommended to set this to false. startOnAxis can be set to true only if equalSpacing is set to true. 
     */
    startOnAxis: boolean;

    /**
     * Tick length. 
     */
    tickLength: number
}


/**
 * ChartCursorSettings settings set's settings for chart cursor. If you change a property after the chart is initialized, you should call stockChart.validateNow() method in order for it to work. If there is no default value specified, default value of ChartCursor class will be used. 
 */
declare class ChartCursorSettings {

    /**
     * Specifies if bullet for each graph will follow the cursor. 
     */
    bulletsEnabled: boolean;

    /**
     * Size of bullets, following the cursor. 
     */
    bulletSize: number;

    /**
     * Opacity of the category balloon. 
     */
    categoryBalloonAlpha: number;

    /**
     * Color of the category balloon. 
     */
    categoryBalloonColor: string;

    /**
     * Array of date format objects. Date format object must have "period" and "format" items. Available periods are: fff - millisecond, ss - second, mm - minute, hh - hour, DD - date, WW - week, MM - month, YYYY - year. [{period:"YYYY", format:"YYYY"}, {period:"MM", format:"MMM, YYYY"}, {period:"WW", format:"MMM DD, YYYY"}, {period:"DD", format:"MMM DD, YYYY"}, {period:"hh", format:"JJ:NN"}, {period:"mm", format:"JJ:NN"}, {period:"ss", format:"JJ:NN:SS"}, {period:"fff", format:"JJ:NN:SS"}] 
     */
    categoryBalloonDateFormats: any[];

    /**
     * Specifies whether category balloon is enabled. 
     */
    categoryBalloonEnabled: boolean;

    /**
     * Opacity of the cursor line. 
     */
    cursorAlpha: number;

    /**
     * Color of the cursor line. 
     */
    cursorColor: string;

    /**
     * Possible values: "start", "middle" and "mouse". 
     */
    cursorPosition: string;

    /**
     * Set this to "false" if you don't want chart cursor to appear in your charts.
     * @default  true
     */
    enabled: boolean;

    /**
     * If this is set to true, the user will be able to pan the chart instead of zooming. 
     */
    pan: boolean;

    /**
     * Specifies whether value balloons are enabled. In case they are not, the balloons might be displayed anyway, when the user rolls-over the column or bullet. 
     */
    valueBalloonsEnabled: boolean;

    /**
     * Specifies if the user can zoom-in the chart. If pan is set to true, zoomable is switched to false automatically. 
     */
    zoomable: boolean
}

declare class ChartScrollbarSettings {

    /**
     * Specifies whether number of gridCount is specified automatically, according to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Background opacity. 
     */
    backgroundAlpha: number;

    /**
     * Background color of the scrollbar. 
     */
    backgroundColor: string;

    /**
     * Text color. 
     */
    color: string;

    /**
     * Set false if you don't need scrollbar.
     * @default  true
     */
    enabled: boolean;

    /**
     * Font size. 
     */
    fontSize: string;

    /**
     * Specifies which graph will be displayed in the scrollbar. 
     */
    graph: AmCharts$AmGraph;

    /**
     * Graph fill opacity. 
     */
    graphFillAlpha: number;

    /**
     * Graph fill color. 
     */
    graphFillColor: string;

    /**
     * Graph line opacity. 
     */
    graphLineAlpha: number;

    /**
     * Graph line color. 
     */
    graphLineColor: string;

    /**
     * Type of chart scrollbar's graph. By default the graph type is the same as the original graph's type, however in case of candlestick or ohlc you might want to show line graph in the scrollbar. Possible values are: line, column, step, smoothedLine, candlestick, ohlc. 
     */
    graphType: string;

    /**
     * Grid opacity. 
     */
    gridAlpha: number;

    /**
     * Grid color. 
     */
    gridColor: string;

    /**
     * Grid count. You should set autoGridCount to false in order this property to work. 
     */
    gridCount: number;

    /**
     * Height of scrollbar, in pixels.
     * @default  40
     */
    height: number;

    /**
     * Specifies whether resize grips are hidden when mouse is away from the scrollbar. 
     */
    hideResizeGrips: boolean;

    /**
     * Duration of scrolling, when the user clicks on scrollbar's background, in seconds. 
     */
    scrollDuration: number;

    /**
     * Selected background opacity. 
     */
    selectedBackgroundAlpha: number;

    /**
     * Selected background color. 
     */
    selectedBackgroundColor: string;

    /**
     * Selected graph'sfill opacity. 
     */
    selectedGraphFillAlpha: number;

    /**
     * Selected graph'sfill color. 
     */
    selectedGraphFillColor: string;

    /**
     * Selected graph'sline opacity. 
     */
    selectedGraphLineAlpha: number;

    /**
     * Selected graph's line color. 
     */
    selectedGraphLineColor: string;

    /**
     * Specifies if the chart should be updated while dragging/resizing the scrollbar or only at the moment when user releases mouse button. Usefull when working with large data sets.
     * @default  true
     */
    updateOnReleaseOnly: boolean
}


/**
 * AmGraph class displays all types of graphs - line, column, step line, smoothed line, ohlc and candlestick.
 * @example  var chart = new AmCharts.AmSerialChart();
var graph = new AmCharts.AmGraph();
graph.valueField = 'value';
graph.type = 'column';
graph.fillAlphas = 1;
chart.addGraph(graph);
*/
declare class AmGraph {

    /**
     * Name of the alpha field in your dataProvider. 
     */
    alphaField: string;

    /**
     * Value balloon color. Will use graph or data item color if not set. 
     */
    balloonColor: string;

    /**
     * If you set some function, the graph will call it and pass GraphDataItem and AmGraph object to it. This function should return a string which will be displayed in a balloon.  
     */
    balloonFunction(graphDataItem: AmCharts$GraphDataItem, amGraph: AmCharts$AmGraph): string;

    /**
     * Balloon text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]] [[value]] 
     */
    balloonText: string;

    /**
     * Specifies if the line graph should be placed behind column graphs 
     */
    behindColumns: boolean;

    /**
     * Type of the bullets. Possible values are: "none", "round", "square", "triangleUp", "triangleDown", "bubble", "custom". none 
     */
    bullet: string;

    /**
     * Opacity of bullets. Value range is 0 - 1.
     * @default  1
     */
    bulletAlpha: number;

    /**
     * Bullet border opacity.
     * @default  1
     */
    bulletBorderAlpha: number;

    /**
     * Bullet border color. Will use lineColor if not set.   
     */
    bulletBorderColor: string;

    /**
     * Bullet border thickness.
     * @default  2
     */
    bulletBorderThickness: number;

    /**
     * Bullet color. Will use lineColor if not set. 
     */
    bulletColor: string;

    /**
     * Name of the bullet field in your dataProvider. 
     */
    bulletField: string;

    /**
     * Bullet offset. Distance from the actual data point to the bullet. Can be used to place custom bullets above the columns. 
     */
    bulletOffset: number;

    /**
     * Bullet size.
     * @default  8
     */
    bulletSize: number;

    /**
     * Name of the bullet size field in your dataProvider. 
     */
    bulletSizeField: string;

    /**
     * Name of the close field (used by candlesticks and ohlc) in your dataProvider. 
     */
    closeField: string;

    /**
     * Color of value labels. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Name of the color field in your dataProvider. 
     */
    colorField: string;

    /**
     * Specifies whether to connect data points if data is missing. The default value is true.
     * @default  true
     */
    connect: boolean;

    /**
     * Corner radius of column. It can be set both in pixels or in percents. The chart's depth and angle styles must be set to 0. The default value is 0. Note, cornerRadiusTop will be applied for all corners of the column, JavaScript charts do not have a possibility to set separate corner radius for top and bottom. As we want all the property names to be the same both on JS and Flex, we didn't change this too. 
     */
    cornerRadiusTop: number;

    /**
     * If bulletsEnabled of ChartCurosor is true, a bullet on each graph follows the cursor. You can set opacity of each graphs bullet. In case you want to disable these bullets for a certain graph, set opacity to 0.
     * @default  1
     */
    cursorBulletAlpha: number;

    /**
     * Path to the image of custom bullet. 
     */
    customBullet: string;

    /**
     * Name of the custom bullet field in your dataProvider. 
     */
    customBulletField: string;

    /**
     * Dash length. If you set it to a value greater than 0, the graph line will be dashed. 
     */
    dashLength: number;

    /**
     * Name of the description field in your dataProvider. 
     */
    descriptionField: string;

    /**
     * Opacity of fill. Plural form is used to keep the same property names as our Flex charts'. Flex charts can accept array of numbers to generate gradients. Although you can set array here, only first value of this array will be used. 
     */
    fillAlphas: number;

    /**
     * Fill color. Will use lineColor if not set. 
     */
    fillColors: any;

    /**
     * Name of the fill colors field in your dataProvider. 
     */
    fillColorsField: string;

    /**
     * You can set another graph here and if fillAlpha is >0, the area from this graph to fillToGraph will be filled (instead of filling the area to the X axis). 
     */
    fillToGraph: AmCharts$AmGraph;

    /**
     * Size of value labels text. Will use chart's fontSize if not set. 
     */
    fontSize: string;

    /**
     * Orientation of the gradient fills (only for "column" graph type). Possible values are "vertical" and "horizontal". vertical 
     */
    gradientOrientation: string;

    /**
     * Specifies whether the graph is hidden. Do not use this to show/hide the graph, use hideGraph(graph) and showGraph(graph) methods instead. 
     */
    hidden: boolean;

    /**
     * If there are more data points than hideBulletsCount, the bullets will not be shown. 0 means the bullets will always be visible. 
     */
    hideBulletsCount: number;

    /**
     * Name of the high field (used by candlesticks and ohlc) in your dataProvider. 
     */
    highField: string;

    /**
     * Whether to include this graph when calculating min and max value of the axis.
     * @default  true
     */
    includeInMinMax: boolean;

    /**
     * Name of label color field in data provider. 
     */
    labelColorField: string;

    /**
     * Position of value label. Possible values are: "bottom", "top", "right", "left", "inside", "middle". Sometimes position is changed by the chart, depending on a graph type, rotation, etc. top 
     */
    labelPosition: string;

    /**
     * Value label text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]]. 
     */
    labelText: string;

    /**
     * Legend marker opacity. Will use lineAlpha if not set. Value range is 0 - 1. 
     */
    legendAlpha: number;

    /**
     * Legend marker color. Will use lineColor if not set. 
     */
    legendColor: string;

    /**
     * Legend value text. You can use tags like [[value]], [[description]], [[percents]], [[open]], [[category]] You can also use custom fields from your dataProvider. If not set, uses Legend's valueText. 
     */
    legendValueText: string;

    /**
     * Opacity of the line (or column border). Value range is 0 - 1.
     * @default  1
     */
    lineAlpha: number;

    /**
     * Color of the line (or column border). If you do not set any, the color from [[AmCoordinateChart 
     */
    lineColor: string;

    /**
     * Name of the line color field (used by columns and candlesticks only) in your dataProvider. 
     */
    lineColorField: string;

    /**
     * Specifies thickness of the graph line (or column border).
     * @default  1
     */
    lineThickness: number;

    /**
     * Name of the low field (used by candlesticks and ohlc) in your dataProvider. 
     */
    lowField: string;

    /**
     * Legend marker type. You can set legend marker (key) type for individual graphs. Possible values are: "square", "circle", "line", "dashedLine", "triangleUp", "triangleDown", "bubble". 
     */
    markerType: string;

    /**
     * Specifies size of the bullet which value is the biggest (XY chart).
     * @default  50
     */
    maxBulletSize: number;

    /**
     * Specifies minimum size of the bullet (XY chart). 
     */
    minBulletSize: number;

    /**
     * If you use different colors for your negative values, a graph below zero line is filled with negativeColor. With this property you can define a different base value at which colors should be changed to negative colors. 
     */
    negativeBase: number;

    /**
     * Fill opacity of negative part of the graph. Will use fillAlphas if not set. 
     */
    negativeFillAlphas: number;

    /**
     * Fill color of negative part of the graph. Will use fillColors if not set. 
     */
    negativeFillColors: any;

    /**
     * Color of the line (or column) when the values are negative. In case the graph type is candlestick or ohlc, negativeLineColor is used when close value is less then open value. 
     */
    negativeLineColor: string;

    /**
     * Example: {precision:-1, decimalSeparator:'.', thousandsSeparator:','}. The graph uses this object's values to format the numbers. Uses chart's numberFormatter if not defined. 
     */
    numberFormatter: Object;

    /**
     * Name of the open field (used by floating columns, candlesticks and ohlc) in your dataProvider. 
     */
    openField: string;

    /**
     * Specifies where data points should be placed - on the beginning of the period (day, hour, etc) or in the middle (only when parseDates property of categoryAxis is set to true). This setting affects Serial chart only. Possible values are "start" and "middle". middle 
     */
    pointPosition: string;

    /**
     * If graph's type is column and labelText is set, graph hides labels which do not fit into the column's space. If you don't want these labels to be hidden, set this to true. 
     */
    showAllValueLabels: boolean;

    /**
     * Specifies whether the value balloon of this graph is shown when mouse is over data item or chart's indicator is over some series.
     * @default  true
     */
    showBalloon: boolean;

    /**
     * Specifies graphs value at which cursor is showed. This is only important for candlestick and ohlc charts, also if column chart has "open" value. Possible values are: "open", "close", "high", "low". close 
     */
    showBalloonAt: string;

    /**
     * If the value axis of this graph has stack types like "regular" or "100%" You can exclude this graph from stacking.
     * @default  true
     */
    stackable: boolean;

    /**
     * Graph title. 
     */
    title: string;

    /**
     * Type of the graph. Possible values are: "line", "column", "step", "smoothedLine", "candlestick", "ohlc". XY and Radar charts can only display "line" type graphs. line 
     */
    type: string;

    /**
     * Name of the url field in your dataProvider. 
     */
    urlField: string;

    /**
     * Target to open URLs in, i.e. _blank, _top, etc. 
     */
    urlTarget: string;

    /**
     * Specifies which value axis the graph will use. Will use the first value axis if not set. 
     */
    valueAxis: AmCharts$ValueAxis;

    /**
     * Name of the value field in your dataProvider. 
     */
    valueField: string;

    /**
     * Specifies whether this graph should be shown in the Legend.
     * @default  true
     */
    visibleInLegend: boolean;

    /**
     * XY chart only. A horizontal value axis object to attach graph to. 
     */
    xAxis: AmCharts$ValueAxis;

    /**
     * XY chart only. Name of the x field in your dataProvider. 
     */
    xField: string;

    /**
     * XY chart only. A vertical value axis object to attach graph to. 
     */
    yAxis: AmCharts$ValueAxis;

    /**
     * XY chart only. Name of the y field in your dataProvider. 
     */
    yField: string
}


/**
 * AxisBase is the base class for ValueAxis and CategoryAxis. It can not be instantiated explicitly. 
 */
declare class AxisBase {

    /**
     * Specifies whether number of gridCount is specified automatically, acoarding to the axis size.
     * @default  true
     */
    autoGridCount: boolean;

    /**
     * Axis opacity. Value range is 0 - 1.
     * @default  1
     */
    axisAlpha: number;

    /**
     * Axis color.  #000000 
     */
    axisColor: string;

    /**
     * Thickness of the axis.
     * @default  1
     */
    axisThickness: number;

    /**
     * Color of axis value labels. Will use chart's color if not set. 
     */
    color: string;

    /**
     * Length of a dash. 0 means line is not dashed. 
     */
    dashLength: number;

    /**
     * Fill opacity. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills.  
     */
    fillAlpha: number;

    /**
     * Fill color. Every second space between grid lines can be filled with color. Set fillAlpha to a value greater than 0 to see the fills. #FFFFFF 
     */
    fillColor: string;

    /**
     * Size of value labels text. Will use chart's fontSize if not set. 
     */
    fontSize: string;

    /**
     * Opacity of grid lines. 0.2 
     */
    gridAlpha: number;

    /**
     * Color of grid lines. #000000 
     */
    gridColor: string;

    /**
     * Number of grid lines. In case this is value axis, or your categoryAxis parses dates, the number is approximate. The default value is 5. If you set autoGridCount to true, this property is ignored.
     * @default  5
     */
    gridCount: number;

    /**
     * Thickness of grid lines.
     * @default  1
     */
    gridThickness: number;

    /**
     * The array of guides belonging to this axis. 
     */
    guides: any[];

    /**
     * If autoMargins of a chart is set to true, but you want this axis not to be measured when calculating margin, set ignoreAxisWidth to true.  
     */
    ignoreAxisWidth: boolean;

    /**
     * Specifies whether values should be placed inside or outside plot area. 
     */
    inside: boolean;

    /**
     * Frequency at which labels should be placed. Doesn't work for CategoryAxis if parseDates is set to true.
     * @default  1
     */
    labelFrequency: number;

    /**
     * Rotation angle of a label. Only horizontal axis' values can be rotated. If you set this for vertical axis, the setting will be ignored. 
     */
    labelRotation: number;

    /**
     * Specifies whether axis displays category axis' labels and value axis' values.
     * @default  true
     */
    labelsEnabled: boolean;

    /**
     * The distance of the axis to the plot area, in pixels. Negative values can also be used.  
     */
    offset: number;

    /**
     * Possible values are: "top", "bottom", "left", "right". If axis is vertical, default position is "left". If axis is horizontal, default position is "bottom".  
     */
    position: string;

    /**
     * Whether to show first axis label or not.
     * @default  true
     */
    showFirstLabel: boolean;

    /**
     * Whether to show last axis label or not.
     * @default  true
     */
    showLastLabel: boolean;

    /**
     * Length of the tick marks.
     * @default  5
     */
    tickLength: number;

    /**
     * Title of the axis. 
     */
    title: string;

    /**
     * Specifies if title should be bold or not.
     * @default  true
     */
    titleBold: boolean;

    /**
     * Color of axis title. Will use text color of chart if not set any. 
     */
    titleColor: string;

    /**
     * Font size of axis title. Will use font size of chart plus two pixels if not set any. 
     */
    titlefontSize: string;

    /**
     * Adds guide to the axis. 
     */
    addGuide(guide: AmCharts$Guide): void;

    /**
     * Removes guide from the axis. 
     */
    removeGuide(guide: AmCharts$Guide): void
}


/**
 * ValueAxis is the class which displays value axis for the chart. The chart can have any number of value axes. For Serial chart one value axis is created automatically. For XY Chart two value axes (horizontal and vertical) are created automatically. 
 */
declare class ValueAxis mixins AxisBase {

    /**
     * Radar chart only. Specifies distance from axis to the axis title (category)  10 
     */
    axisTitleOffset: number;

    /**
     * Read-only. Coordinate of the base value. 
     */
    baseCoord: number;

    /**
     * Specifies base value of the axis. 
     */
    baseValue: number;

    /**
     * If your values represents time units, and you want value axis labels to be formatted as duration, you have to set the duration unit. Possible values are: "ss", "mm", "hh" and "DD". 
     */
    duration: string;

    /**
     * If duration property is set, you can specify what string should be displayed next to day, hour, minute and second. {DD:"d. ", hh:":", mm:":",ss:""} 
     */
    durationUnits: Object;

    /**
     * Radar chart only. Possible values are: "polygons" and "circles". Set "circles" for polar charts. polygons 
     */
    gridType: string;

    /**
     * Unique id of value axis. It is not required to set it, unless you need to tell the graph which exact value axis it should use. 
     */
    id: string;

    /**
     * Specifies whether guide values should be included when calculating min and max of the axis. 
     */
    includeGuidesInMinMax: boolean;

    /**
     * If true, the axis will include hidden graphs when calculating min and max values. 
     */
    includeHidden: boolean;

    /**
     * Specifies whether values on axis can only be integers or both integers and doubles. 
     */
    integersOnly: boolean;

    /**
     * You can use this function to format Value axis labels. This function is called and these parameters are passed: labelFunction(value, valueText, valueAxis);
     * Wherevalueis numeric value, valueText is formatted string and valueAxis is a reference to valueAxis object.

    Ifaxistype is "date", labelFunction will pass different arguments:
    labelFunction(valueText, date, valueAxis)

    Yourfunction should return string.
    */
    labelFunction(value: number, valueText: string, valueAxis: AmCharts$ValueAxis): string;
    labelFunction(valueText: string, data: Date, valueAxis: AmCharts$ValueAxis): string;

    /**
     * Specifies if this value axis' scale should be logarithmic. 
     */
    logarithmic: boolean;

    /**
     * Read-only. Maximum value of the axis. 
     */
    max: number;

    /**
     * If you don't want max value to be calculated by the chart, set it using this property. This value might still be adjusted so that it would be possible to draw grid at rounded intervals. 
     */
    maximum: number;

    /**
     * If your value axis is date-based, you can specify maximum date of the axis. Can be set as date object, timestamp number or string if dataDateFormat is set. 
     */
    maximumData: Date;

    /**
     * Read-only. Minimum value of the axis. 
     */
    min: number;

    /**
     * If you don't want min value to be calculated by the chart, set it using this property. This value might still be adjusted so that it would be possible to draw grid at rounded intervals. 
     */
    minimum: number;

    /**
     * If your value axis is date-based, you can specify minimum date of the axis. Can be set as date object, timestamp number or string if dataDateFormat is set. 
     */
    minimumDate: Date;

    /**
     * If set value axis scale (min and max numbers) will be multiplied by it. I.e. if set to 1.2 the scope of values will increase by 20%. 
     */
    minMaxMultiplier: number;

    /**
     * Works with radar charts only. If you set it to middle, labels and data points will be placed in the middle between axes. 
     */
    pointPosition: string;

    /**
     * Possible values are: "top", "bottom", "left", "right". If axis is vertical, default position is "left". If axis is horizontal, default position is "bottom". 
     */
    position: string;

    /**
     * Precision (number of decimals) of values. 
     */
    precision: number;

    /**
     * Radar chart only. Specifies if categories (axes' titles) should be displayed near axes)
     * @default  true
     */
    radarCategoriesEnabled: boolean;

    /**
     * pecifies if graphs's values should be recalculated to percents. 
     */
    recalculateToPercents: boolean;

    /**
     * Specifies if value axis should be reversed (smaller values on top).  
     */
    reversed: boolean;

    /**
     * Stacking mode of the axis. Possible values are: "none", "regular", "100%", "3d". none Note, only graphs of one type will be stacked. 
     */
    stackType: string;

    /**
     * Read-only. Value difference between two grid lines. 
     */
    step: number;

    /**
     * If you set minimum and maximum for your axis, chart adjusts them so that grid would start and end on the beginning and end of plot area and grid would be at equal intervals. If you set strictMinMax to true, the chart will not adjust minimum and maximum of value axis. 
     */
    strictMinMax: boolean;

    /**
     * In case you synchronize one value axis with another, you need to set the synchronization multiplier. Use synchronizeWithAxis method to set with which axis it should be synced. 
     */
    synchronizationMultiplier: number;

    /**
     * One value axis can be synchronized with another value axis. You can use both reference to your axis or id of the axis here. You should set synchronizationMultiplyer in order for this to work. 
     */
    synchronizeWith: AmCharts$ValueAxis;

    /**
     * If this value axis is stacked and has columns, setting valueAxis.totalText = "[[total]]" will make it to display total value above the most-top column. 
     */
    totalText: string;

    /**
     * Color of total text. 
     */
    totalTextColor: string;

    /**
     * Distance from data point to total text. 
     */
    totalTextOffset: number;

    /**
     * This allows you to have logarithmic value axis and have zero values in the data. You must set it to >0 value in order to work. 
     */
    treatZeroAs: number;

    /**
     * Type of value axis. If your values in data provider are dates and you want this axis to show dates instead of numbers, set it to "date". 
     */
    type: string;

    /**
     * Unit which will be added to the value label. 
     */
    unit: string;

    /**
     * Position of the unit. Possible values are "left" and "right". right 
     */
    unitPosition: string;

    /**
     * If true, prefixes will be used for big and small numbers. You can set arrays of prefixes directly to the chart object via prefixesOfSmallNumbers and prefixesOfBigNumbers. 
     */
    usePrefixes: boolean;

    /**
     * If true, values will always be formatted using scientific notation (5e+8, 5e-8...) Otherwise only values bigger then 1e+21 and smaller then 1e-7 will be displayed in scientific notation. 
     */
    useScientificNotation: boolean;

    /**
     * Adds guide to the axis. 
     */
    addGuide(guide: AmCharts$Guide): void;

    /**
     * Adds event listener to the object.  type - string like 'axisChanged' (should be listed in 'events' section of this class or classes which extend this class). handler - function which is called when event happens 
     */
    addListener(type: string, handler: any): void;

    /**
     * Number, - value of coordinate. Returns value of the coordinate.  coordinate - y or x coordinate, in pixels. 
     */
    coordinateToValue(coordinate: number): void;

    /**
     * Number - coordinate Returns coordinate of the value in pixels. value - Number 
     */
    getCoordinate(value: number): void;

    /**
     * Removes guide from the axis.
     */
    removeGuide(guide: AmCharts$Guide): void;

    /**
     * Removes event listener from the object. 
     */
    removeListener(obj: any, type: string, handler: any): void;

    /**
     * One value axis can be synchronized with another value axis. You should set synchronizationMultiplyer in order for this to work. 
     */
    synchronizeWithAxis(axis: AmCharts$ValueAxis): void;

    /**
     * XY Chart only. Zooms-in the axis to the provided values. 
     */
    zoomToValues(startValue: number, endValue: number): void;

    /**
     * Adds event listener of the type "axisZoomed" to the object.
     * @param type Always "axisZoomed".
     * @param handler XY chart only. Dispatched when axis is zoomed.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "axisZoomed". 
                 */
                type: string,
                startValue: Date,
                endValue: Date,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Adds event listener of the type "logarithmicAxisFailed" to the object.
     * @param type Always "logarithmicAxisFailed".
     * @param handler Dispatched when valueAxis is logarithmic and values equal or less then zero were found in data.
     */
    addListener(
        type: string,
        handler: (
            e: {

                /**
                 * Always "logarithmicAxisFailed". 
                 */
                type: string,
                chart: AmCharts$AmChart
            }) => void): void;

    /**
     * Removes event listener from chart object. 
     */
    removeListener(chart: AmCharts$AmChart, type: string, handler: any): void
}

declare class Title {

    /**
     * 
     * @default  1 
     */
    alpha: number;

    /**
     * Specifies if the tile is bold or not.
     * @default  false
     */
    bold: boolean;

    /**
     * Text color of a title. 
     */
    color: string;

    /**
     * Unique id of a Title. You don't need to set it, unless you want to. 
     */
    id: string;

    /**
     * Text size 
     */
    size: number;

    /**
     * Text of a label 
     */
    text: string
}

declare class ExportSettings {
    enabled: boolean;
    libs: Object;
    menu: Object
}
declare interface amplifyRequestSettings {
    resourceId: string,
        data?: any,
        success?: (...args: any[]) => void,
        error?: (...args: any[]) => void
}
declare interface amplifyDecoder {
    (data?: any, status?: string, xhr?: JQueryXHR, success?: (...args: any[]) => void, error?: (...args: any[]) => void): void
}
declare interface amplifyDecoders {
    [decoderName: string]: amplifyDecoder,
    jsSend: amplifyDecoder
}
declare type amplifyAjaxSettings = {
    cache?: any,
    dataMap?: {} | ((data: any) => {}),
    decoder?: any
} & JQueryAjaxSettings
declare interface amplifyRequest {
    (resourceId: string, hash?: any, callback?: Function): JQueryPromise<any>,
        (settings: amplifyRequestSettings): JQueryPromise<any>,
        define(resourceId: string, requestType: string, settings?: amplifyAjaxSettings): void,
        define(resourceId: string, resource: (settings: amplifyRequestSettings) => void): void,
        decoders: amplifyDecoders,
        cache: any
}
declare interface amplifySubscribe {
    (topic: string, callback: Function): void,
    (topic: string, context: any, callback: Function, priority?: number): void,
    (topic: string, callback: Function, priority?: number): void
}
declare interface amplifyStorageTypeStore {
    (key: string, value: any, options?: any): void,
    (key: string): any,
    (): any
}
declare type amplifyStore = {
    localStorage: amplifyStorageTypeStore,
    sessionStorage: amplifyStorageTypeStore,
    globalStorage: amplifyStorageTypeStore,
    userData: amplifyStorageTypeStore,
    memory: amplifyStorageTypeStore
} & amplifyStorageTypeStore
declare interface amplifyStatic {
    subscribe: amplifySubscribe,
        unsubscribe(topic: string, callback: Function): void,
        publish(topic: string, ...args: any[]): boolean,
        store: amplifyStore,
        request: amplifyRequest
}
declare var amplify: amplifyStatic;
declare module 'amplify' {
    declare module.exports: typeof amplify
}
declare module 'amplitude' {
    declare interface Config {
        tenant?: string,
            clientId: string,
            redirectUri?: string,
            cacheLocation?: string,
            displayCall?: (urlNavigate: string) => any,
            correlationId?: string,
            loginResource?: string,
            resource?: string,
            endpoints?: any,
            extraQueryParameter?: string,
            postLogoutRedirectUri?: string
    }
    declare     export class Identify {
        set(key: string, value: any): Identify;
        setOnce(key: string, value: any): Identify;
        add(key: string, value: number): Identify;
        append(key: string, value: any): Identify;
        prepend(key: string, value: any): Identify;
        unset(key: string): Identify
    }
    declare     export function init(apiKey: string): void
    declare     export function setVersionName(version: string): void
    declare     export function setUserId(userId: string): void
    declare     export function setDeviceId(id: string): void
    declare     export function regenerateDeviceId(): void
    declare     export function identify(identify: Identify): void
    declare     export function setUserProperties(properties: Object): void
    declare     export function clearUserProperties(): void
    declare     export function setOptOut(optOut: boolean): void
    declare     export function setGroup(groupType: string, groupName: string | string[]): void
    declare     export function logEvent(event: string): void
    declare     export var options: adal$Config;
}
declare module 'amqp-rpc' {
    declare     export interface Options {
        recurse: boolean
    }
    declare     export interface CallOptions {
        correlationId?: string,
            autoDeleteCallback?: any
    }
    declare     export interface HandlerOptions {
        queueName?: string,
            durable?: boolean,
            exclusive?: boolean,
            autoDelete?: boolean
    }
    declare     export interface BroadcastOptions {
        ttl?: number,
            onResponse?: any,
            context?: any,
            onComplete?: any
    }
    declare     export interface CommandInfo {
        cmd?: string,
            exchange?: string,
            contentType?: string,
            size?: number
    }
    declare type Callback = (err: Error) => any;
    declare     export interface CallbackWithError {
        (err: any, ...args: any[]): void
    }
    declare     export function factory(opt?: acorn$Options): amqpRPC
    declare     export class amqpRPC {
        constructor(opt?: acorn$Options): this;
        generateQueueName(type: string): string;
        disconnect(): void;
        call<T>(
            cmd: string,
            params: T,
            cb?: Callback,
            context?: any,
            options?: CallOptions): string;
        on<T>(
            cmd: string,
            cb: (param?: T, cb?: Callback, info?: CommandInfo) => void,
            context?: any,
            options?: HandlerOptions): boolean;
        off(cmd: string): boolean;
        callBroadcast<T>(cmd: string, params: T, options?: BroadcastOptions): void;
        onBroadcast<T>(
            cmd: string,
            cb?: (params?: T, cb?: CallbackWithError) => void,
            context?: any,
            options?: any): boolean;
        offBroadcast(cmd: string): boolean
    }
}
declare module 'amqplib/properties' {
    declare interface Replies$Empty {}

    declare interface Replies$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Replies$PurgeQueue {
        messageCount: number
    }

    declare interface Replies$DeleteQueue {
        messageCount: number
    }

    declare interface Replies$AssertExchange {
        exchange: string
    }

    declare interface Replies$Consume {
        consumerTag: string
    }
    declare interface Options$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Options$DeleteQueue {
        messageCount: number
    }

    declare interface Options$AssertExchange {
        exchange: string
    }

    declare interface Options$DeleteExchange {
        ifUnused?: boolean
    }

    declare interface Options$Publish {
        expiration?: string,
            userId?: string,
            CC?: string | string[],
            mandatory?: boolean,
            persistent?: boolean,
            deliveryMode?: boolean | number,
            BCC?: string | string[],
            contentType?: string,
            contentEncoding?: string,
            headers?: any,
            priority?: number,
            correlationId?: string,
            replyTo?: string,
            messageId?: string,
            timestamp?: number,
            type?: string,
            appId?: string
    }

    declare interface Options$Consume {
        consumerTag: string
    }

    declare interface Options$Get {
        noAck?: boolean
    }
    declare     export interface Message {
        seq: number,
            type: string
    }
}
declare module 'amqplib' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare     function connect(url: string, socketOptions?: any): when.Promise<Connection >
}
declare module 'amqplib/callback_api' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare type ConfirmChannel = {
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        sendToQueue(
            queue: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        waitForConfirms(callback?: (err: any) => void): void
    } & Channel

    declare     function connect(url: string, socketOptions?: any): when.Promise<Connection >
}
declare interface AnalyticsNode$Integrations {
    [index: string]: boolean
}

declare export class Analytics {
    constructor(writeKey: string, opts?: {
        flushAt?: number,
        flushAfter?: number
    }): this;
    identify(
        message: {
            userId: string | number,
            traits?: Object,
            timestamp?: Date,
            context?: Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    track(
        message: {
            userId: string | number,
            event: string,
            properties?: Object,
            timestamp?: Date,
            context?: Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    page(
        message: {
            userId: string | number,
            category?: string,
            name?: string,
            properties?: Object,
            timestamp?: Date,
            context?: Object,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    alias(
        message: {
            previousId: string | number,
            userId: string | number,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    group(
        message: {
            userId: string | number,
            groupId: string | number,
            traits?: Object,
            context?: Object,
            timestamp?: Date,
            anonymous_id?: string | number,
            integrations?: AnalyticsNode$Integrations
        }): AnalyticsNode$Analytics;
    flush(
        fn?: (
            err: Error,
            batch: {
                batch: Array<{
                    type: string
                }>,
                messageId: string,
                sentAt: Date,
                timestamp: Date
            }) => void): AnalyticsNode$Analytics
}
declare module 'analytics-node' {
    declare module.exports: typeof AnalyticsNode$Analytics
}