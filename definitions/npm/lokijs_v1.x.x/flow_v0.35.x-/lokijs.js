/**
 * Flowtype definitions for lokijs
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


/**
 * LokiJS
 * A lightweight document oriented javascript database
 * @author  Joe Minichino <joe.minichino
 * @gmail  .com>Loki: The main database class
 * @constructor  * 
 * @param  - name of the file to be saved to
 * @param  - config object
 */
declare type Loki = {
    autosave: boolean,
    autosaveInterval: number,
    autosaveHandle: number,
    collections: LokiCollection<any>[],
    databaseVersion: number,
    engineVersion: number,
    ENV: string,
    events: {
        [id: string]: ((...args: any[]) => void)[]
    },
    filename: string,
    options: LokiConfigureOptions,
    persistenceAdapter: LokiPersistenceInterface,
    persistenceMethod: string,
    verbose: boolean,
    new(filename: string, options: LokiConfigureOptions): Loki,
    getIndexedAdapter(): LokiPersistenceInterface,

    /**
     * configureOptions - allows reconfiguring database options
     * @param  - configuration options to apply to loki db object
     * @param  - (optional) if this is a reconfig, don't pass this
     */
    configureOptions(options: LokiConfigureOptions, initialConfig?: boolean): void,

    /**
     * anonym() - shorthand method for quickly creating and populating an anonymous collection.
     *   This collection is not referenced internally so upon losing scope it will be garbage collected.

      Example : var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });
     * @param  - document array to initialize the anonymous collection with
     * @param  - (Optional) array of property names to index
     * @returns  New collection which you can query or chain
    */
    anonym<T>(docs: T | T[], indexesArray?: LokiCollectionOptions): LokiCollection<T>,
    addCollection<T>(name: string, options?: LokiCollectionOptions): LokiCollection<T>,
    loadCollection(collection: LokiCollection<any>): void,
    getCollection<T>(collectionName: string): LokiCollection<T>,
    listCollections(): {
        name: string,
        type: string,
        count: number
    }[],
    removeCollection(collectionName: string): void,
    getName(): string,

    /**
     * serializeReplacer - used to prevent certain properties from being serialized
     */
    serializeReplacer<T>(key: "autosaveHandle", value: T): T,
    serializeReplacer<T>(key: "persistenceAdapter", value: T): T,
    serializeReplacer<T>(key: "constraints", value: T): T,
    serializeReplacer<T>(key: string, value: T): T,
    serialize(): string,
    toJson(): string,

    /**
     * loadJSON - inflates a loki database from a serialized JSON string
     * @param  - a serialized loki database string
     * @param  - apply or override collection level settings
     */
    loadJSON(
        serializedDb: string,
        options?: {
            [collectionName: string]: {
                inflate?: (src: any, dst: any) => void,
                proto: any
            }
        }): void,

    /**
     * loadJSONObject - inflates a loki database from a JS object
     * @param  - a serialized loki database string
     * @param  - apply or override collection level settings
     */
    loadJSONObject(
        dbObject: Loki,
        options?: {
            [collectionName: string]: {
                inflate?: (src: any, dst: any) => void,
                proto: any
            }
        }): void,

    /**
     * close(callback) - emits the close event with an optional callback. Does not actually destroy the db
     * but useful from an API perspective
     */
    close(callback?: (...args: any[]) => void): void,

    /**
     * -------------------------+
     * |Changes API         |
    +--------------------------The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,
     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)generateChangesNotification() - takes all the changes stored in each
     * collection and creates a single array for the entire database. If an array of names
    of collections is passed then only the included collections will be tracked.
     * @param  array of collection names. No arg means all collections are processed.
     * @returns  array of changes
     * @see  private method createChange() in Collection
    */
    generateChangesNotification(arrayOfCollectionNames?: string[]): LokiCollectionChange[],

    /**
     * serializeChanges() - stringify changes for network transmission
     * @returns  string representation of the changes
     */
    serializeChanges(collectionNamesArray?: string[]): string,

    /**
     * clearChanges() - clears all the changes in all collections.
     */
    clearChanges(): void,

    /**
     * loadDatabase - Handles loading from file system, local storage, or adapter (indexeddb)
     *   This method utilizes loki configuration options (if provided) to determine which
      persistence method to use, or environment detection (if configuration was not provided).
     * @param  - not currently used (remove or allow overrides?)
     * @param  - (Optional) user supplied async callback / error handler
    */
    loadDatabase(
        options: {
            [collectionName: string]: {
                inflate?: (src: any, dst: any) => void,
                proto: any
            }
        },
        callback?: (err: any, data: any) => void): void,

    /**
     * saveDatabase - Handles saving to file system, local storage, or adapter (indexeddb)
     *   This method utilizes loki configuration options (if provided) to determine which
      persistence method to use, or environment detection (if configuration was not provided).
     * @param  - not currently used (remove or allow overrides?)
     * @param  - (Optional) user supplied async callback / error handler
    */
    saveDatabase(callback?: (err: any) => void): void,
    save(callback?: (err: any) => void): void,

    /**
     * deleteDatabase - Handles deleting a database from file system, local
     *   storage, or adapter (indexeddb)
      This method utilizes loki configuration options (if provided) to determine which
      persistence method to use, or environment detection (if configuration was not provided).
     * @param  - not currently used (remove or allow overrides?)
     * @param  - user supplied async callback / error handler
    */
    deleteDatabase(options: any, callback: (err: any, data: any) => void): void,

    /**
     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database
     * @returns  - true if database has changed since last autosave, false if not.
     */
    autosaveDirty(): boolean,

    /**
     * autosaveClearFlags - resets dirty flags on all collections.
     *   Called from saveDatabase() after db is saved.
     */
    autosaveClearFlags(): void,

    /**
     * autosaveEnable - begin a javascript interval to periodically save the database.
     * @param  - not currently used (remove or allow overrides?)
     * @param  - (Optional) user supplied async callback
     */
    autosaveEnable(options?: LokiConfigureOptions, callback?: (err: any) => void): void,

    /**
     * autosaveDisable - stop the autosave interval timer.
     */
    autosaveDisable(): void
} & LokiEventEmitter

/**
 * LokiEventEmitter is a minimalist version of EventEmitter. It enables any
 * constructor that inherits EventEmitter to emit events and trigger
listeners that have been added to the event through the on(event, callback) method
*/
declare interface LokiEventEmitter {

    /**
     * 
     * @prop  Events property is a hashmap, with each property being an array of callbacks
     */
    events: {
            [eventName: string]: ((...args: any[]) => void)[]
        },
        new(): LokiEventEmitter,

        /**
         * 
         * @prop  asyncListeners - boolean determines whether or not the callbacks associated with each event
        should happen in an async fashion or not
        Default is false, which means events are synchronous
        */
        asyncListeners: boolean,

        /**
         * 
         * @prop  on(eventName, listener) - adds a listener to the queue of callbacks associated to an event
         * @returns  the index of the callback in the array of listeners for a particular event
         */
        on<U>(eventName: string, listener: U): U,

        /**
         * 
         * @propt  emit(eventName, data) - emits a particular event
        with the option of passing optional parameters which are going to be processed by the callback
        provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)
         * @param  - the name of the event
         * @param  - optional object passed with the event
        */
        emit(eventName: string, data?: any): void,

        /**
         * 
         * @prop  remove() - removes the listener at position 'index' from the event 'eventName'
         */
        removeListener(eventName: string, listener: (...args: any[]) => void): void
}
/**
 * there are two build in persistence adapters for internal use
 * fs for use in Nodejs type environments
localStorage   for use in browser environment
defined as helper classes here so its easy and clean to use
*/
declare interface LokiPersistenceInterface {
    loadDatabase(dbname: string, callback: (dataOrErr: string | Error) => void): void,
        saveDatabase(
            dbname: string,
            dbstring: string,
            callback: (resOrErr: void | Error) => void): void,
        deleteDatabase(dbname: string, callback?: (resOrErr: void | Error) => void): void,
        mode?: string,
        exportDatabase(filename: string, param: any, callback?: (err: any) => void): void
}
/**
 * constructor for fs
 */
declare type LokiFsAdapter = {
    fs: any,

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param  - the filename of the database to load
     * @param  - the callback to handle the result
     */
    loadDatabase(dbname: string, callback: (err: Error, data: string) => void): void,

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param  - the filename of the database to load
     * @param  - the callback to handle the result
     */
    saveDatabase(dbname: string, dbstring: string, callback: (err: any) => void): void,

    /**
     * deleteDatabase() - delete the database file, will throw an error if the
     * file can't be deleted
     * @param  - the filename of the database to delete
     * @param  - the callback to handle the result
     */
    deleteDatabase(dbname: string, callback: (resOrErr: void | Error) => void): void
} & LokiPersistenceInterface

/**
 * constructor for local storage
 */
declare type LokiLocalStorageAdapter = {

    /**
     * loadDatabase() - Load data from localstorage
     * @param  - the name of the database to load
     * @param  - the callback to handle the result
     */
    loadDatabase(dbname: string, callback: (dataOrErr: string | Error) => void): void,

    /**
     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param  - the filename of the database to load
     * @param  - the callback to handle the result
     */
    saveDatabase(
        dbname: string,
        dbstring: string,
        callback: (resOrErr: void | Error) => void): void,

    /**
     * deleteDatabase() - delete the database from localstorage, will throw an error if it
     * can't be deleted
     * @param  - the filename of the database to delete
     * @param  - the callback to handle the result
     */
    deleteDatabase(dbname: string, callback: (resOrErr: void | Error) => void): void
} & LokiPersistenceInterface

/**
 * Resultset class allowing chainable queries.  Intended to be instanced internally.
 *   Collection.find(), Collection.where(), and Collection.chain() instantiate this.

  Example:
  mycollection.chain()
    .find({ 'doors' : 4 })
    .where(function(obj) { return obj.name === 'Toyota' })
    .data();
*/
declare interface LokiResultset<E>{
        collection: LokiCollection<E>,
        filterInitialized: boolean,
        filteredrows: string[],
        options: LokiResultsetOptions<E>,
        searchIsChained: boolean,

        /**
         * 
         * @constructor  * 
         * @param  - The collection which this Resultset will query against.
         * @param  - Object containing one or more options.
         * @param  .queryObj - Optional mongo-style query object to initialize resultset with.
         * @param  .queryFunc - Optional javascript filter function to initialize resultset with.
         * @param  .firstOnly - Optional boolean used by collection.findOne().
         */
        new<E>(
            collection: LokiCollection<E>,
            options: LokiResultsetOptions<E>): LokiResultset<E>| E[],

        /**
         * reset() - Reset the resultset to its initial state.
         * @returns  Reference to this resultset, for future chain operations.
         */
        reset(): LokiResultset<E>,

        /**
         * toJSON() - Override of toJSON to avoid circular references
         */
        toJSON(): LokiResultset<E>,

        /**
         * limit() - Allows you to limit the number of documents passed to next chain operation.
         *   A resultset copy() is made to avoid altering original resultset.
         * @param  - The number of documents to return.
         * @returns  Returns a copy of the resultset, limited by qty, for subsequent chain ops.
         */
        limit(qty: number): LokiResultset<E>,

        /**
         * offset() - Used for skipping 'pos' number of documents in the resultset.
         * @param  - Number of documents to skip; all preceding documents are filtered out.
         * @returns  Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.
         */
        offset(pos: number): LokiResultset<E>,

        /**
         * copy() - To support reuse of resultset in branched query situations.
         * @returns  Returns a copy of the resultset (set) but the underlying document references will be the same.
         */
        copy(): LokiResultset<E>,
        branch(): LokiResultset<E>,

        /**
         * transform() - executes a named collection transform or raw array of transform steps against the resultset.
         * @param transform : (Optional) name of collection transform or raw transform array
         * @param parameters : (Optional) object property hash of parameters, if the transform requires them.
         * @returns  : either (this) resultset or a clone of of this resultset (depending on steps)
         */
        transform(transform?: string | any[], parameters?: any): LokiResultset<E>,

        /**
         * sort() - User supplied compare function is provided two documents to compare. (chainable)
         *   Example:
          rslt.sort(function(obj1, obj2) {
            if (obj1.name === obj2.name) return 0;
            if (obj1.name>obj2.name) return 1;
            if (obj1.name<obj2.name) return -1;
          });
         * @param  - A javascript compare function used for sorting.
         * @returns  Reference to this resultset, sorted, for future chain operations.
        */
        sort(comparefun: (a: E, b: E) => number): LokiResultset<E>,

        /**
         * simplesort() - Simpler, loose evaluation for user to sort based on a property name. (chainable)
         * @param  - name of property to sort by.
         * @param  - (Optional) If true, the property will be sorted in descending order
         * @returns  Reference to this resultset, sorted, for future chain operations.
         */
        simplesort(propname: string, isdesc?: boolean): LokiResultset<E>,

        /**
         * compoundsort() - Allows sorting a resultset based on multiple columns.
         *   Example : rs.compoundsort(['age', 'name']); to sort by age and then name (both ascending)
          Example : rs.compoundsort(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
         * @param  - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
         * @returns  Reference to this resultset, sorted, for future chain operations.
        */
        compoundsort(properties: ([string, boolean] | [string])[]): LokiResultset<E>,

        /**
         * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.
         *   this is used for collection.find() and first find filter of resultset/dynview
          slightly different than get() binary search in that get() hones in on 1 value,
          but we have to hone in on many (range)
         * @param  - operation, such as $eq
         * @param  - name of property to calculate range for
         * @param  - value to use for range calculation.
         * @returns  [start, end] index array positions
        */
        calculateRange(op: "$eq", prop: string, val: any): [number, number],
        calculateRange(op: "$dteq", prop: string, val: any): [number, number],
        calculateRange(op: "$gt", prop: string, val: any): [number, number],
        calculateRange(op: "$gte", prop: string, val: any): [number, number],
        calculateRange(op: "$lt", prop: string, val: any): [number, number],
        calculateRange(op: "$lte", prop: string, val: any): [number, number],
        calculateRange(op: string, prop: string, val: any): [number, number],

        /**
         * findOr() - oversee the operation of OR'ed query expressions.
         *   OR'ed expression evaluation runs each expression individually against the full collection,
          and finally does a set OR on each expression's results.
          Each evaluation can utilize a binary index to prevent multiple linear array scans.
         * @param  - array of expressions
         * @returns  this resultset for further chain ops.
        */
        findOr(expressionArray: LokiQuery[]): LokiResultset<E>,
        $or(expressionArray: LokiQuery[]): LokiResultset<E>,

        /**
         * findAnd() - oversee the operation of AND'ed query expressions.
         *   AND'ed expression evaluation runs each expression progressively against the full collection,
          internally utilizing existing chained resultset functionality.
          Only the first filter can utilize a binary index.
         * @param  - array of expressions
         * @returns  this resultset for further chain ops.
        */
        findAnd(expressionArray: LokiQuery[]): LokiResultset<E>,
        $and(expressionArray: LokiQuery[]): LokiResultset<E>,

        /**
         * find() - Used for querying via a mongo-style query object.
         * @param  - A mongo-style query object used for filtering current results.
         * @param  - (Optional) Used by collection.findOne()
         * @returns  this resultset for further chain ops.
         */
        find(query: LokiQuery, firstOnly?: boolean): LokiResultset<E>,

        /**
         * where() - Used for filtering via a javascript filter function.
         * @param  - A javascript function used for filtering current results by.
         * @returns  this resultset for further chain ops.
         */
        where(fun: (obj: E) => boolean): LokiResultset<E>,

        /**
         * count() - returns the number of documents in the resultset.
         * @returns  The number of documents in the resultset.
         */
        count(): number,

        /**
         * data() - Terminates the chain and returns array of filtered documents
         * @param options : allows specifying 'forceClones' and 'forceCloneMethod' options.
        options :
        forceClones {boolean} : Allows forcing the return of cloned objects even when
        the collection is not configured for clone object.
        forceCloneMethod {string} : Allows overriding the default or collection specified cloning method.
        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'
         * @returns  Array of documents in the resultset
        */
        data(options?: {
            forceClones?: string,
            forceCloneMethod?: string
        }): E[],

        /**
         * update() - used to run an update operation on all documents currently in the resultset.
         * @param  - User supplied updateFunction(obj) will be executed for each document object.
         * @returns  this resultset for further chain ops.
         */
        update(updateFunction: (obj: E) => void): LokiResultset<E>,

        /**
         * remove() - removes all document objects which are currently in resultset from collection (as well as resultset)
         * @returns  this (empty) resultset for further chain ops.
         */
        remove(): LokiResultset<E>,

        /**
         * mapReduce() - data transformation via user supplied functions
         * @param  - this function accepts a single document for you to transform and return
         * @param  - this function accepts many (array of map outputs) and returns single value
         * @returns  The output of your reduceFunction
         */
        mapReduce<T,
        U>(
            mapFunction: (value: E, index: number, array: E[]) => T,
            reduceFunction: (array: T[]) => U): U,

        /**
         * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties
         * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key,function} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on,function} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on(optional) mapFun - A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}
         * @param  - Data array to join to.
         * @returns  A resultset with data in the format [{left: leftObj, right: rightObj}]
         */
        eqJoin<T>(
            joinData: T[] | LokiResultset<T>,
            leftJoinKey: string | ((obj: E) => string),
            rightJoinKey: string | ((obj: T) => string)): LokiResultset<{
            left: E,
            right: T
        }>,
        eqJoin<T,
        U>(
            joinData: T[] | LokiResultset<T>,
            leftJoinKey: string | ((obj: E) => string),
            rightJoinKey: string | ((obj: T) => string),
            mapFun?: (a: E, b: T) => U): LokiResultset<U>,
        map<T>(mapFun: (currentValue: E, index: number, array: E[]) => T): LokiResultset<T >
    }
    /**
     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.
     *   Collection.addDynamicView(name) instantiates this DynamicView object and notifies it
      whenever documents are add/updated/removed so it can remain up-to-date. (chainable)

      Examples:
      var mydv = mycollection.addDynamicView('test');  // default is non-persistent
      mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });
      mydv.applyFind({ 'doors' : 4 });
      var results = mydv.data();
    */
declare type LokiDynamicView<E>= {
    cachedresultset: LokiResultset<E>,
    collection: LokiCollection<E>,
    events: {
        [id: string]: ((...args: any[]) => void)[]
    },
    filterPipeline: LokiFilter<E>[],
    minRebuildInterval: number,
    name: string,
    options: LokiDynamicViewOptions,
    persistent: boolean,
    rebuildPending: boolean,
    resultset: LokiResultset<E>,
    resultdata: E[],
    resultsdirty: boolean,
    sortFunction: (a: E, b: E) => number,
    sortCriteria: ([string, boolean] | [string])[],
    sortDirty: boolean,
    sortPriority: string,

    /**
     * 
     * @constructor  * 
     * @param  - A reference to the collection to work against
     * @param  - The name of this dynamic view
     * @param  - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.
     */
    new<E>(
        collection: LokiCollection<E>,
        name: string,
        options?: LokiDynamicViewOptions): LokiDynamicView<E>,

    /**
     * rematerialize() - intended for use immediately after deserialization (loading)
     *   This will clear out and reapply filterPipeline ops, recreating the view.
      Since where filters do not persist correctly, this method allows
      restoring the view to state where user can re-apply those where filters.
     * @param  - (Optional) allows specification of 'removeWhereFilters' option
     * @returns  This dynamic view for further chained ops.
    */
    rematerialize(options?: {
        removeWhereFilters?: boolean
    }): LokiDynamicView<E>,

    /**
     * branchResultset() - Makes a copy of the internal resultset for branched queries.
     *   Unlike this dynamic view, the branched resultset will not be 'live' updated,
      so your branched query should be immediately resolved and not held for future evaluation.
     * @param  : Optional name of collection transform, or an array of transform steps
     * @param  : optional parameters (if optional transform requires them)
     * @returns  A copy of the internal resultset for branched queries.
    */
    branchResultset(transform?: string | any[], parameters?: any): LokiResultset<E>,

    /**
     * toJSON() - Override of toJSON to avoid circular references
     */
    toJSON(): LokiDynamicView<E>,

    /**
     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.
     *    Existing options should be retained.
     */
    removeFilters(): void,

    /**
     * applySort() - Used to apply a sort to the dynamic view
     * @param  - a javascript compare function used for sorting
     * @returns  this DynamicView object, for further chain ops.
     */
    applySort(comparefun: (a: E, b: E) => number): LokiDynamicView<E>,

    /**
     * applySimpleSort() - Used to specify a property used for view translation.
     * @param  - Name of property by which to sort.
     * @param  - (Optional) If true, the sort will be in descending order.
     * @returns  this DynamicView object, for further chain ops.
     */
    applySimpleSort(propname: string, isdesc?: boolean): LokiDynamicView<E>,

    /**
     * applySortCriteria() - Allows sorting a resultset based on multiple columns.
     *   Example : dv.applySortCriteria(['age', 'name']); to sort by age and then name (both ascending)
      Example : dv.applySortCriteria(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
      Example : dv.applySortCriteria(['age', true], ['name', true]); to sort by age (descending) and then by name (descending)
     * @param  - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns  Reference to this DynamicView, sorted, for future chain operations.
    */
    applySortCriteria(criteria: ([string, boolean] | [string])[]): LokiDynamicView<E>,

    /**
     * startTransaction() - marks the beginning of a transaction.
     * @returns  this DynamicView object, for further chain ops.
     */
    startTransaction(): LokiDynamicView<E>,

    /**
     * commit() - commits a transaction.
     * @returns  this DynamicView object, for further chain ops.
     */
    commit(): LokiDynamicView<E>,

    /**
     * rollback() - rolls back a transaction.
     * @returns  this DynamicView object, for further chain ops.
     */
    rollback(): LokiDynamicView<E>,

    /**
     * Implementation detail.
     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.
     * @param  - The unique ID of the filter.
     * @returns  : index of the referenced filter in the pipeline; -1 if not found.
     */
    _indexOfFilterWithId(uid: string | number): number,

    /**
     * Implementation detail.
     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.
     * @param  - The filter object. Refer to applyFilter() for extra details.
     */
    _addFilter(filter: LokiFilter<E>): void,

    /**
     * reapplyFilters() - Reapply all the filters in the current pipeline.
     * @returns  this DynamicView object, for further chain ops.
     */
    reapplyFilters(): LokiDynamicView<E>,

    /**
     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline
     * @param  - A filter object to add to the pipeline.
    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }
     * @returns  this DynamicView object, for further chain ops.
    */
    applyFilter(filter: LokiFilter<E>): LokiDynamicView<E>,

    /**
     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline
     * @param  - A mongo-style query object to apply to pipeline
     * @param  - Optional: The unique ID of this filter, to reference it in the future.
     * @returns  this DynamicView object, for further chain ops.
     */
    applyFind(query: LokiQuery, uid?: string | number): LokiDynamicView<E>,

    /**
     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline
     * @param  - A javascript filter function to apply to pipeline
     * @param  - Optional: The unique ID of this filter, to reference it in the future.
     * @returns  this DynamicView object, for further chain ops.
     */
    applyWhere(fun: (obj: E) => boolean, uid?: string | number): LokiDynamicView<E>,

    /**
     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline
     * @param  - The unique ID of the filter to be removed.
     * @returns  this DynamicView object, for further chain ops.
     */
    removeFilter(uid: string | number): LokiDynamicView<E>,

    /**
     * count() - returns the number of documents representing the current DynamicView contents.
     * @returns  The number of documents representing the current DynamicView contents.
     */
    count(): number,

    /**
     * data() - resolves and pending filtering and sorting, then returns document array as result.
     * @returns  An array of documents representing the current DynamicView contents.
     */
    data(): E[],

    /**
     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.
     *    This event will throttle and queue a single rebuild event when batches of updates affect the view.
     */
    queueRebuildEvent(): void,

    /**
     * queueSortPhase : If the view is sorted we will throttle sorting to either :
     *   (1) passive - when the user calls data(), or
      (2) active - once they stop updating and yield js thread control
    */
    queueSortPhase(): void,

    /**
     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)
     */
    performSortPhase(options?: {
        suppressRebuildEvent?: boolean
    }): void,

    /**
     * evaluateDocument() - internal method for (re)evaluating document inclusion.
     *   Called by : collection.insert() and collection.update().
     * @param  - index of document to (re)run through filter pipeline.
     * @param  - true if the document was just added to the collection.
     */
    evaluateDocument(objIndex: number, isNew?: boolean): void,

    /**
     * removeDocument() - internal function called on collection.delete()
     */
    removeDocument(objIndex: number): void,

    /**
     * mapReduce() - data transformation via user supplied functions
     * @param  - this function accepts a single document for you to transform and return
     * @param  - this function accepts many (array of map outputs) and returns single value
     * @returns  The output of your reduceFunction
     */
    mapReduce<T,
    U>(
        mapFunction: (item: E, index: number, array: E[]) => T,
        reduceFunction: (array: T[]) => U): U
} & LokiEventEmitter

/**
 * Collection class that handles documents of same type
 */
declare type LokiCollection<E>= {
    autoupdate: boolean,
    asyncListeners: boolean,
    binaryIndices: {
        [id: string]: {
            name: string,
            dirty: boolean,
            values: number[]
        }
    },
    cachedIndex: number[],
    cachedBinaryIndex: {
        [id: string]: {
            name: string,
            dirty: boolean,
            values: number[]
        }
    },
    cachedData: E[],
    changes: LokiCollectionChange[],
    cloneMethod: string,
    cloneObjects: boolean,
    console: {
        log: () => void,
        warn: () => void,
        error: () => void
    },
    constraints: {
        unique: {
            [id: string]: LokiUniqueIndex<E >
        },
        exact: {
            [id: string]: LokiExactIndex<E >
        }
    },
    data: E[],
    dirty: boolean,
    disableChangesApi: boolean,
    DynamicViews: LokiDynamicView<E>[],
    events: {
        [id: string]: ((...args: any[]) => void)[]
    },
    idIndex: number[],
    maxId: number,
    name: string,
    transactional: boolean,
    objType: string,
    transforms: {
        [id: string]: any
    },
    uniqueNames: string[],
    options: LokiCollectionOptions,
    ttl: {
        age: number,
        ttlInterval: number,
        daemon: number
    },

    /**
     * Collection class that handles documents of same type
     * @constructor  * 
     * @param  name
     * @param  of property names to be indicized
     * @param  object
     */
    new<E>(name: string, options?: LokiCollectionOptions): LokiCollection<E>,
    getChanges(): LokiCollectionChange[],
    setChangesApi(enabled: boolean): void,
    flushChanges(): void,
    observerCallback: (changes: {
        object: any
    }[]) => void,
    addAutoUpdateObserver(object: any): void,
    removeAutoUpdateObserver(object: any): void,
    addTransform(name: string, transform: any): void,
    setTransform(name: string, transform: any): void,
    removeTransform(name: string): void,
    byExample(template: any): {
        $and: any[]
    },
    findObject(template: any): E,
    findObjects(template: any): E[],
    ttlDaemonFuncGen(): () => void,
    setTTL(age: number, interval: number): void,

    /**
     * create a row filter that covers all documents in the collection
     */
    prepareFullDocIndex(): number[],

    /**
     * Ensure binary index on a certain field
     */
    ensureIndex(property: string, force?: boolean): void,
    ensureUniqueIndex(field: string): LokiUniqueIndex<E>,

    /**
     * Ensure all binary indices
     */
    ensureAllIndexes(force?: boolean): void,
    flagBinaryIndexesDirty(): void,
    flagBinaryIndexDirty(index: string): void,
    count(query?: LokiQuery): number,

    /**
     * Rebuild idIndex
     */
    ensureId(): void,

    /**
     * Rebuild idIndex async with callback - useful for background syncing with a remote server
     */
    ensureIdAsync(callback: () => void): void,

    /**
     * Each collection maintains a list of DynamicViews associated with it
     */
    addDynamicView(name: string, options?: LokiDynamicViewOptions): LokiDynamicView<E>,
    removeDynamicView(name: string): void,
    getDynamicView(name: string): LokiDynamicView<E>,

    /**
     * find and update: pass a filtering function to select elements to be updated
     * and apply the updatefunctino to those elements iteratively
     */
    findAndUpdate(filterFunction: (obj: E) => boolean, updateFunction: (obj: E) => E): void,

    /**
     * generate document method - ensure object(s) have meta properties, clone it if necessary, etc.
     * @param  : the document to be inserted (or an array of objects)
     * @returns  document or documents (if passed an array of objects)
     */
    insert(doc: E): E,
    insert(doc: E[]): E[],

    /**
     * generate document method - ensure object has meta properties, clone it if necessary, etc.
     * @param  document to be inserted
     * @returns  document or 'undefined' if there was a problem inserting it
     */
    insertOne(doc: E): E,
    clear(): void,

    /**
     * Update method
     */
    update(doc: E): E,
    update(doc: E[]): void,

    /**
     * Add object to collection
     */
    add(obj: E): E,
    removeWhere(query: ((obj: E) => boolean) | LokiQuery): void,
    removeDataOnly(): void,

    /**
     * delete wrapped
     */
    remove(doc: E): E,
    remove(doc: number): E,
    remove(doc: number[]): void,
    remove(doc: E[]): void,

    /**
     * Get by Id - faster than other methods because of the searching algorithm
     */
    get(id: number | string): E,
    get(id: number | string, returnPosition?: boolean): E | [E, number],
    by(field: string): (value: any) => E,
    by(field: string, value: string): E,

    /**
     * Find one object by index property, by property equal to value
     */
    findOne(query: LokiQuery): E,

    /**
     * Chain method, used for beginning a series of chained find() and/or view() operations
     * on a collection.
     * @param  : Ordered array of transform step objects similar to chain
     * @param  : Object containing properties representing parameters to substitute
     * @returns  : (or data array if any map or join functions where called)
     */
    chain(transform?: string | any[], parameters?: any): LokiResultset<E>,

    /**
     * Find method, api is similar to mongodb except for now it only supports one search parameter.
     * for more complex queries use view() and storeView()
     */
    find(): E[],
    find(query: LokiQuery): LokiResultset<E>,

    /**
     * Find object by unindexed field by property equal to value,
     * simply iterates and returns the first element matching the query
     */
    findOneUnindexed(prop: string, value: any): E,

    /**
     * Transaction methods start the transation 
     */
    startTransaction(): void,

    /**
     * commit the transation 
     */
    commit(): void,

    /**
     * roll back the transation 
     */
    rollback(): void,
    async(fun: () => void, callback: () => void): void,

    /**
     * Create view function - filter
     */
    where(fun: (obj: E) => boolean): LokiResultset<E>,

    /**
     * Map Reduce
     */
    mapReduce<U,
    V>(
        mapFunction: (item: E, index: number, array: E[]) => U,
        reduceFunction: (array: U[]) => V): V,

    /**
     * eqJoin - Join two collections on specified properties
     */
    eqJoin<T>(
        joinData: T[] | LokiResultset<T>,
        leftJoinProp: string | ((obj: E) => string),
        rightJoinProp: string | ((obj: T) => string)): LokiResultset<{
        left: E,
        right: T
    }>,
    eqJoin<T,
    U>(
        joinData: T[] | LokiResultset<T>,
        leftJoinProp: string | ((obj: E) => string),
        rightJoinProp: string | ((obj: T) => string),
        mapFun?: (a: E, b: T) => U): LokiResultset<U>,

    /**
     * stages: a map of uniquely identified 'stages', which hold copies of objects to be
     * manipulated without affecting the data in the original collection
     */
    stages: {
        [id: string]: any
    },

    /**
     * create a stage and/or retrieve it
     */
    getStage(name: string): E[],

    /**
     * a collection of objects recording the changes applied through a commmitStage
     */
    commitLog: {
        timestamp: number,
        message: any,
        data: E
    }[],

    /**
     * create a copy of an object and insert it into a stage
     */
    stage(stageName: string, obj: E): E,

    /**
     * re-attach all objects to the original collection, so indexes and views can be rebuilt
     * then create a message to be inserted in the commitlog
     */
    commitStage(stageName: string, message: any): void,
    no_op(): void,
    extract(field: string): any[],
    max(field: string): number,
    min(field: string): number,
    maxRecord(field: string): {
        index: number,
        value: any
    },
    minRecord(field: string): {
        index: number,
        value: any
    },
    extractNumerical(field: string): number[],
    avg(field: string): number,
    stdDev(field: string): number,
    mode(field: string): string | number,
    median(field: string): number
} & LokiEventEmitter

/**
 * comparison operators
 * a is the value in the collection
b is the query value
*/
declare interface LokiOps {
    $eq(a: any, b: any): boolean,
        $ne(a: any, b: any): boolean,
        $dteq(a: any, b: any): boolean,
        $gt(a: any, b: any): boolean,
        $gte(a: any, b: any): boolean,
        $lt(a: any, b: any): boolean,
        $lte(a: any, b: any): boolean,
        $in(a: any, b: {
            indexOf: (value: any) => boolean
        }): boolean,
        $nin(a: any, b: {
            indexOf: (value: any) => boolean
        }): boolean,
        $keyin(a: string, b: any): boolean,
        $nkeyin(a: string, b: any): boolean,
        $definedin(a: any, b: any): boolean,
        $undefinedin(a: any, b: any): boolean,
        $regex(a: any, b: RegExp | {
            test: (str: string) => boolean
        }): boolean,
        $containsString(a: string | any, b: string): boolean,
        $containsNone(a: any, b: any): boolean,
        $containsAny(a: any, b: any | any[]): boolean,
        $contains(a: any, b: any | any[]): boolean,
        $type(a: any, b: any): boolean,
        $size(a: any, b: any): boolean,
        $len(a: any, b: any): boolean,
        $not(a: any, b: any): boolean,
        $and(a: any, b: any[]): boolean,
        $or(a: any, b: any[]): boolean
}
declare interface LokiKeyValueStore<K, V>{
    keys: K[],
    values: V[],
    sort(a: any, b: any): number,
    setSort(fun: (a: K, b: K) => number): void,
    bs(): LokiBSonSort<K>,
    set(key: K, value: V): void,
    get(key: K): V
}
declare interface LokiUniqueIndex<E>{
    field: string,
    keyMap: {
        [id: string]: E
    },
    lokiMap: {
        [id: number]: any
    },
    new<E>(uniqueField: string): LokiUniqueIndex<E>,
    set(obj: E): void,
    get(key: string): E,
    byId(id: number): E,
    update(obj: E): void,
    remove(key: string): void,
    clear(): void
}
declare interface LokiExactIndex<E>{
    index: {
        [id: string]: E[]
    },
    field: string,
    new<E>(exactField: string): LokiExactIndex<E>,

    /**
     * add the value you want returned to the key in the index 
     */
    set(key: string, val: E): void,

    /**
     * remove the value from the index, if the value was the last one, remove the key 
     */
    remove(key: string, val: E): void,

    /**
     * get the values related to the key, could be more than one 
     */
    get(key: string): E[],

    /**
     * clear will zap the index 
     */
    clear(key?: any): void
}
declare interface LokiSortedIndex<K, V>{
    field: string,
    keys: K[],
    values: V[][],
    new<K,
    V>(sortedField: string): LokiSortedIndex<K,
    V>,
    sort(a: any, b: any): number,
    bs(): LokiBSonSort<any>,
    setSort(fun: (a: any, b: any) => number): void,
    set(key: K, value: V): void,
    get(key: K): V[],
    getLt(key: K): V[],
    getGt(key: K): V[],
    getAll(key: K, start: number, end: number): V[],
    getPos(key: K): {
        found: boolean,
        index: number
    },
    remove(key: K, value: V): void,
    clear(): void
}
declare interface LokiConfigureOptions {
    adapter?: LokiPersistenceInterface,
        autoload?: boolean,
        autoloadCallback?: (dataOrErr: any | Error) => void,
        autosave?: boolean,
        autosaveCallback?: (err: any) => void,
        autosaveInterval?: number,
        env?: string,
        persistenceMethod?: string,
        verbose?: boolean
}
declare interface LokiCollectionOptions {
    asyncListeners?: boolean,
        autoupdate?: boolean,
        clone?: boolean,
        cloneMethod?: string,
        disableChangesApi?: boolean,
        exact?: string[],
        indices?: string | string[],
        transactional?: boolean,
        unique?: string | string[]
}
declare interface LokiDynamicViewOptions {
    minRebuildInterval?: number,
        persistent?: boolean,
        sortPriority: string
}
declare interface LokiResultsetOptions<E>{
    firstOnly?: boolean,
    queryObj?: LokiQuery,
    queryFunc?: (item: E) => boolean
}
declare interface LokiQuery {}
declare interface LokiFilter<E>{
    type: string,
    val: LokiQuery | ((obj: E, index: number, array: E[]) => boolean),
    uid: number | string
}
declare interface LokiElementMetaData {
    created: number,
        revision: number
}
declare interface LokiCollectionChange {
    name: string,
        operation: string,
        obj: any
}
declare interface LokiBSonSort<T>{
        (fun: (a: T, b: T) => number): (array: T[], item: T) => {
            found: boolean,
            index: number
        }
    }
    /**
     * General utils, including statistical functions
     */
declare interface LokiIndexedAdapter {
    app: string,
        catalog: LokiCatalog,

        /**
         * IndexedAdapter - Loki persistence adapter class for indexedDb.
         *    This class fulfills abstract adapter interface which can be applied to other storage methods
           Utilizes the included LokiCatalog app/key/value database for actual database persistence.
         * @param  - Application name context can be used to distinguish subdomains or just 'loki'
        */
        new(appname: string): LokiIndexedAdapter,

        /**
         * checkAvailability - used to check if adapter is available
         * @returns  true if indexeddb is available, false if not.
         */
        checkAvailability(): boolean,

        /**
         * loadDatabase() - Retrieves a serialized db string from the catalog.
         * @param  - the name of the database to retrieve.
         * @param  - callback should accept string param containing serialized db string.
         */
        loadDatabase(dbname: string, callback?: (data: any) => void): void,
        loadKey(dbname: string, callback?: (data: any) => void): void,

        /**
         * saveDatabase() - Saves a serialized db to the catalog.
         * @param  - the name to give the serialized database within the catalog.
         * @param  - the serialized db string to save.
         * @param  - (Optional) callback passed obj.success with true or false
         */
        saveDatabase(dbname: string, dbstring: string, callback?: (err: Error | void) => void): void,
        saveKey(dbname: string, dbstring: string, callback?: (err: Error | void) => void): void,

        /**
         * deleteDatabase() - Deletes a serialized db from the catalog.
         * @param  - the name of the database to delete from the catalog.
         */
        deleteDatabase(dbname: string): void,
        deleteKey(dbname: string): void,

        /**
         * getDatabaseList() - Retrieves object array of catalog entries for current app.
         * @param  - should accept array of database names in the catalog for current app.
         */
        getDatabaseList(callback: (names: string[]) => void): void,
        getKeyList(callback: (names: string[]) => void): void,

        /**
         * getCatalogSummary - allows retrieval of list of all keys in catalog along with size
         * @param  - (Optional) callback to accept result array.
         */
        getCatalogSummary(callback: (entries: {
            app: string,
            key: string,
            size: number
        }) => void): void
}
/**
 * LokiCatalog - underlying App/Key/Value catalog persistence
 * This non-interface class implements the actual persistence.
Used by the IndexedAdapter class.
*/
declare interface LokiCatalog {
    db: IDBDatabase,
        new(callback: (cat: LokiCatalog) => void): LokiCatalog,
        initializeLokiCatalog(callback: (cat: LokiCatalog) => void): void,
        getAppKey(app: string, key: string, callback: (resObj: any) => void): void,
        getAppKeyById<T>(id: any, callback: (result: any, data: T) => void, data: T): void,
        setAppKey(
            app: string,
            key: string,
            val: any,
            callback: (res: {
                success: boolean
            }) => void): void,
        deleteAppKey(id: any, callback: (res: {
            success: boolean
        }) => void): void,
        getAppKeys(app: string, callback: (data: any[]) => void): void,
        getAllKeys(callback: (data: any[]) => void): void
}
/**
 * 
 * @file  lokiCryptedFileAdapter.js
 * @author  Hans Klunder <Hans.Klunder
 * @bigfoot  .com>require libs 
 */
declare interface LokiCryptedFileAdapter {
    secret: string,

        /**
         * The constructor is automatically called on `require` , see examples below
         * @constructor  
         */
        new(): LokiCryptedFileAdapter,

        /**
         * setSecret() - set the secret to be used during encryption and decryption
         * @param  - the secret to be used
         */
        setSecret(secret: string): void,

        /**
         * loadDatabase() - Retrieves a serialized db string from the catalog.
         * @example  // LOAD
        var cryptedFileAdapter = require('./lokiCryptedFileAdapter');
        cryptedFileAdapter.setSecret('mySecret'); // you should change 'mySecret' to something supplied by the user
        var db = new loki('test.crypted', { adapter: cryptedFileAdapter }); //you can use any name, not just '*.crypted'
        db.loadDatabase(function(result) {
        console.log('done');
        });
         * @param  - the name of the database to retrieve.
         * @param  - callback should accept string param containing serialized db string.
        */
        loadDatabase(dbname: string, callback: (decryptedDataOrErr: string | any) => void): void,

        /**
         * 
         * @example  // SAVE : will save database in 'test.crypted'
        var cryptedFileAdapter = require('./lokiCryptedFileAdapter');
        cryptedFileAdapter.setSecret('mySecret'); // you should change 'mySecret' to something supplied by the user
        var loki=require('lokijs');
        var db = new loki('test.crypted',{ adapter: cryptedFileAdapter }); //you can use any name, not just '*.crypted'
        var coll = db.addCollection('testColl');
        coll.insert({test: 'val'});
        db.saveDatabase();  // could pass callback if needed for async complete
         * @example  // if you have the krypt module installed you can use:
        krypt --decrypt test.crypted --secret mySecret
        to view the contents of the database
        saveDatabase() - Saves a serialized db to the catalog.
         * @param  - the name to give the serialized database within the catalog.
         * @param  - the serialized db string to save.
         * @param  - (Optional) callback passed obj.success with true or false
        */
        saveDatabase(dbname: string, dbstring: string, callback: (err: any) => void): void
}
declare interface LokiCryptedFileAdapterEncryptResult {
    cipher: string,
        keyDerivation: string,
        keyLength: number,
        iterations: number,
        iv: string,
        salt: string,
        value: string
}
/**
 * LokiJS JquerySyncAdapter
 * A remote sync adapter example for LokiJS
 * @author  Joe Minichino <joe.minichino
 * @gmail  .com>this adapter assumes an object options is passed,
 * containing the following properties:
ajaxLib: jquery or compatible ajax library
save: { url: the url to save to, dataType [optional]: json|xml|etc., type [optional]: POST|GET|PUT}
load: { url: the url to load from, dataType [optional]: json|xml| etc., type [optional]: POST|GET|PUT }
*/
declare interface LokiJquerySyncAdapter {
    options: LokiJquerySyncAdapterOptions,
        new(options: LokiJquerySyncAdapterOptions): LokiJquerySyncAdapter,
        saveDatabase(
            name: string,
            data: any,
            callback?: (data: any, textStatus: string, xhr: XMLHttpRequest) => any): void,
        loadDatabase(
            name: string,
            callback?: (data: any, textStatus: string, xhr: XMLHttpRequest) => any): void
}
declare interface LokiJquerySyncAdapterOptions {
    ajaxLib: {
            ajax(options: any): any
        },
        save: {
            url: any,
            type?: string,
            dataType?: string
        },
        load: {
            url: any,
            type?: string,
            dataType?: string
        }
}
declare type LokiJquerySyncAdapterError = {
    name: string,
    message: any,
    new(message: any): LokiJquerySyncAdapterError
} & Error
declare
var LokiCryptedFileAdapterConstructor: {
    new(): LokiCryptedFileAdapter
};
declare module 'lokiCryptedFileAdapter' {
    declare module.exports: typeof LokiCryptedFileAdapterConstructor
}
declare
var LokiIndexedAdapterConstructor: {
    new(filename: string): LokiIndexedAdapter
};
declare module 'loki-indexed-adapter' {
    declare module.exports: typeof LokiIndexedAdapterConstructor
}
declare
var LokiConstructor: {
    new(filename: string, options?: LokiConfigureOptions): Loki,
    LokiOps: LokiOps,
    Collection: LokiCollection<any>,
    KeyValueStore: LokiKeyValueStore<any,
    any >
};
declare module 'lokijs' {
    declare module.exports: typeof LokiConstructor
}