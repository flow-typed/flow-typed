// @flow
/**
 * Flowtype definitions for box2dweb
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'Dynamics' {

    /**
     * A rigid body.
     */
    declare     export class b2Body {

        /**
         * Dynamic Body
         */
        b2_dynamicBody: number;

        /**
         * Kinematic Body
         */
        b2_kinematicBody: number;

        /**
         * Static Body
         */
        b2_staticBody: number;

        /**
         * Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. This wakes up the body.
         * @param force The world force vector, usually in Newtons (N).
         * @param point The world position of the point of application.
         */
        ApplyForce(force: undefined.b2Vec2, point: undefined.b2Vec2): void;

        /**
         * Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of application is not at the center of mass. This wakes up the body.
         * @param impules The world impulse vector, usually in N-seconds or kg-m/s.
         * @param point The world position of the point of application.
         */
        ApplyImpulse(impulse: undefined.b2Vec2, point: undefined.b2Vec2): void;

        /**
         * Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass. This wakes up the body.
         * @param torque Force applied about the z-axis (out of the screen), usually in N-m.
         */
        ApplyTorque(torque: number): void;

        /**
         * Creates a fixture and attach it to this body. Use this function if you need to set some fixture parameters, like friction. Otherwise you can create the fixture directly from a shape. If the density is non-zero, this function automatically updates the mass of the body. Contacts are not created until the next time step.
         * @warning  This function is locked during callbacks.
         * @param def The fixture definition;
         * @return  The created fixture.
         */
        CreateFixture(def: b2FixtureDef): b2Fixture;

        /**
         * Creates a fixture from a shape and attach it to this body. This is a convenience function. Use b2FixtureDef if you need to set parameters like friction, restitution, user data, or filtering. This function automatically updates the mass of the body.
         * @warning  This function is locked during callbacks.
         * @param shape The shaped of the fixture (to be cloned).
         * @param density The shape density, default is 0.0, set to zero for static bodies.
         * @return  The created fixture.
         */
        CreateFixture2(shape: undefined.b2Shape, density?: number): b2Fixture;

        /**
         * Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with this fixture. This will automatically adjust the mass of the body if the body is dynamic and the fixture has positive density. All fixtures attached to a body are implicitly destroyed when the body is destroyed.
         * @warning  This function is locked during callbacks.
         * @param fixture The fixed to be removed.
         */
        DestroyFixture(fixture: b2Fixture): void;

        /**
         * Get the angle in radians.
         * @return  The current world rotation angle in radians
         */
        GetAngle(): number;

        /**
         * Get the angular damping of the body.
         * @return  Angular damping of the body.
         */
        GetAngularDamping(): number;

        /**
         * Get the angular velocity.
         * @return  The angular velocity in radians/second.
         */
        GetAngularVelocity(): number;

        /**
         * Get the list of all contacts attached to this body.
         * @return  List of all contacts attached to this body.
         */
        GetContactList(): Contacts.b2ContactEdge;

        /**
         * Get the list of all controllers attached to this body.
         * @return  List of all controllers attached to this body.
         */
        GetControllerList(): Controllers.b2ControllerEdge;

        /**
         * Get the definition containing the body properties.
         * @note  This provides a feature specific to this port.
         * @return  The body's definition.
         */
        GetDefinition(): b2BodyDef;

        /**
         * Get the list of all fixtures attached to this body.
         * @return  List of all fixtures attached to this body.
         */
        GetFixtureList(): b2Fixture;

        /**
         * Get the central rotational inertia of the body.
         * @return  The rotational inertia, usually in kg-m^2.
         */
        GetInertia(): number;

        /**
         * Get the list of all joints attached to this body.
         * @return  List of all joints attached to this body.
         */
        GetJointList(): Joints.b2JointEdge;

        /**
         * Get the linear damping of the body.
         * @return  The linear damping of the body.
         */
        GetLinearDamping(): number;

        /**
         * Get the linear velocity of the center of mass.
         * @return  The linear velocity of the center of mass.
         */
        GetLinearVelocity(): undefined.b2Vec2;

        /**
         * Get the world velocity of a local point.
         * @param localPoint Point in local coordinates.
         * @return  The world velocity of the point.
         */
        GetLinearVelocityFromLocalPoint(localPoint: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Get the world linear velocity of a world point attached to this body.
         * @param worldPoint Point in world coordinates.
         * @return  The world velocity of the point.
         */
        GetLinearVelocityFromWorldPoint(worldPoint: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Get the local position of the center of mass.
         * @return  Local position of the center of mass.
         */
        GetLocalCenter(): undefined.b2Vec2;

        /**
         * Gets a local point relative to the body's origin given a world point.
         * @param worldPoint Pointin world coordinates.
         * @return  The corresponding local point relative to the body's origin.
         */
        GetLocalPoint(worldPoint: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Gets a local vector given a world vector.
         * @param worldVector World vector.
         * @return  The corresponding local vector.
         */
        GetLocalVector(worldVector: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Get the total mass of the body.
         * @return  The body's mass, usually in kilograms (kg).
         */
        GetMass(): number;

        /**
         * Get the mass data of the body. The rotational inertial is relative to the center of mass.
         * @param data Body's mass data, this argument is `out`.
         */
        GetMassData(data: undefined.b2MassData): void;

        /**
         * Get the next body in the world's body list.
         * @return  Next body in the world's body list.
         */
        GetNext(): b2Body;

        /**
         * Get the world body origin position.
         * @return  World position of the body's origin.
         */
        GetPosition(): undefined.b2Vec2;

        /**
         * Get the body transform for the body's origin.
         * @return  World transform of the body's origin.
         */
        GetTransform(): undefined.b2Transform;

        /**
         * Get the type of this body.
         * @return  Body type as uint.
         */
        GetType(): number;

        /**
         * Get the user data pointer that was provided in the body definition.
         * @return  User's data, cast to the correct type.
         */
        GetUserData(): any;

        /**
         * Get the parent world of this body.
         * @return  Body's world.
         */
        GetWorld(): b2World;

        /**
         * Get the world position of the center of mass.
         * @return  World position of the center of mass.
         */
        GetWorldCenter(): undefined.b2Vec2;

        /**
         * Get the world coordinates of a point given the local coordinates.
         * @param localPoint Point on the body measured relative to the body's origin.
         * @return  localPoint expressed in world coordinates.
         */
        GetWorldPoint(localPoint: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Get the world coordinates of a vector given the local coordinates.
         * @param localVector Vector fixed in the body.
         * @return  localVector expressed in world coordinates.
         */
        GetWorldVector(localVector: undefined.b2Vec2): undefined.b2Vec2;

        /**
         * Get the active state of the body.
         * @return  True if the body is active, otherwise false.
         */
        IsActive(): boolean;

        /**
         * Get the sleeping state of this body.
         * @return  True if the body is awake, otherwise false.
         */
        IsAwake(): boolean;

        /**
         * Is the body treated like a bullet for continuous collision detection?
         * @return  True if the body is treated like a bullet, otherwise false.
         */
        IsBullet(): boolean;

        /**
         * Does this body have fixed rotation?
         * @return  True for fixed, otherwise false.
         */
        IsFixedRotation(): boolean;

        /**
         * Is this body allowed to sleep?
         * @return  True if the body can sleep, otherwise false.
         */
        IsSleepingAllowed(): boolean;

        /**
         * Merges another body into this. Only fixtures, mass and velocity are effected, Other properties are ignored.
         * @note  This provides a feature specific to this port.
         */
        Merge(other: b2Body): void;

        /**
         * This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need to be called unless you called SetMassData to override the mass and later you want to reset the mass.
         */
        ResetMassData(): void;

        /**
         * Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up. If you pass a flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise unaffected. You may continue to create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive body is still owned by a b2World object and remains in the body list.
         * @param flag True to activate, false to deactivate.
         */
        SetActive(flag: boolean): void;

        /**
         * Set the world body angle
         * @param angle New angle of the body.
         */
        SetAngle(angle: number): void;

        /**
         * Set the angular damping of the body.
         * @param angularDamping New angular damping value.
         */
        SetAngularDamping(angularDamping: number): void;

        /**
         * Set the angular velocity.
         * @param omega New angular velocity in radians/second.
         */
        SetAngularVelocity(omega: number): void;

        /**
         * Set the sleep state of the body. A sleeping body has vety low CPU cost.
         * @param flag True to set the body to awake, false to put it to sleep.
         */
        SetAwake(flag: boolean): void;

        /**
         * Should this body be treated like a bullet for continuous collision detection?
         * @param flag True for bullet, false for normal.
         */
        SetBullet(flag: boolean): void;

        /**
         * Set this body to have fixed rotation. This causes the mass to be reset.
         * @param fixed True for no rotation, false to allow for rotation.
         */
        SetFixedRotation(fixed: boolean): void;

        /**
         * Set the linear damping of the body.
         * @param linearDamping The new linear damping for this body.
         */
        SetLinearDamping(linearDamping: number): void;

        /**
         * Set the linear velocity of the center of mass.
         * @param v New linear velocity of the center of mass.
         */
        SetLinearVelocity(v: undefined.b2Vec2): void;

        /**
         * Set the mass properties to override the mass properties of the fixtures Note that this changes the center of mass position. Note that creating or destroying fixtures can also alter the mass. This function has no effect if the body isn't dynamic.
         * @warning  The supplied rotational inertia should be relative to the center of mass.
         * @param massData New mass data properties.
         */
        SetMassData(massData: undefined.b2MassData): void;

        /**
         * Set the world body origin position.
         * @param position New world body origin position.
         */
        SetPosition(position: undefined.b2Vec2): void;

        /**
         * Set the position of the body's origin and rotation (radians). This breaks any contacts and wakes the other bodies.
         * @param position New world body origin position.
         * @param angle New world rotation angle of the body in radians.
         */
        SetPositionAndAngle(position: undefined.b2Vec2, angle: number): void;

        /**
         * Is this body allowed to sleep
         * @param flag True if the body can sleep, false if not.
         */
        SetSleepingAllowed(flag: boolean): void;

        /**
         * Set the position of the body's origin and rotation (radians). This breaks any contacts and wakes the other bodies. Note this is less efficient than the other overload - you should use that if the angle is available.
         * @param xf Body's origin and rotation (radians).
         */
        SetTransform(xf: undefined.b2Transform): void;

        /**
         * Set the type of this body. This may alter the mass and velocity
         * @param type Type enum.
         */
        SetType(type: number): void;

        /**
         * Set the user data. Use this to store your application specific data.
         * @param data The user data for this body.
         */
        SetUserData(data: any): void;

        /**
         * Splits a body into two, preserving dynamic properties
         * @note  This provides a feature specific to this port.
         * @param callback 
         * @return  The newly created bodies from the split.
         */
        Split(callback: (fixture: b2Fixture) => boolean): b2Body
    }

    /**
     * A body definition holds all the data needed to construct a rigid body. You can safely re-use body definitions.
     */
    declare     export class b2BodyDef {

        /**
         * Does this body start out active?
         */
        active: boolean;

        /**
         * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.
         */
        allowSleep: boolean;

        /**
         * The world angle of the body in radians.
         */
        angle: number;

        /**
         * Angular damping is use to reduce the angular velocity. The damping parameter can be larger than 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is large.
         */
        angularDamping: number;

        /**
         * The angular velocity of the body.
         */
        angularVelocity: number;

        /**
         * Is this body initially awake or sleeping?
         */
        awake: boolean;

        /**
         * Is this a fast moving body that should be prevented from tunneling through other moving bodies? Note that all bodies are prevented from tunneling through static bodies.
         * @warning  You should use this flag sparingly since it increases processing time.
         */
        bullet: boolean;

        /**
         * Should this body be prevented from rotating? Useful for characters.
         */
        fixedRotation: boolean;

        /**
         * Scales the inertia tensor.
         * @warning  Experimental
         */
        inertiaScale: number;

        /**
         * Linear damping is use to reduce the linear velocity. The damping parameter can be larger than 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is large.
         */
        linearDamping: number;

        /**
         * The linear velocity of the body's origin in world co-ordinates.
         */
        linearVelocity: undefined.b2Vec2;

        /**
         * The world position of the body. Avoid creating bodies at the origin since this can lead to many overlapping shapes.
         */
        position: undefined.b2Vec2;

        /**
         * The body type: static, kinematic, or dynamic. A member of the b2BodyType class .
         * @note  If a dynamic body would have zero mass, the mass is set to one.
         */
        type: number;

        /**
         * Use this to store application specific body data.
         */
        userData: any
    }

    /**
     * Implement this class to provide collision filtering. In other words, you can implement this class if you want finer control over contact creation.
     */
    declare     export class b2ContactFilter {

        /**
         * Return true if the given fixture should be considered for ray intersection. By default, userData is cast as a b2Fixture and collision is resolved according to ShouldCollide.
         * @note  This function is not in the box2dweb.as code -- might not work.
         * @see  b2World.Raycast()
         * @see  b2ContactFilter.ShouldCollide()
         * @param userData User provided data.  Comments indicate that this might be a b2Fixture.
         * @return  True if the fixture should be considered for ray intersection, otherwise false.
         */
        RayCollide(userData: any): boolean;

        /**
         * Return true if contact calculations should be performed between these two fixtures.
         * @warning  For performance reasons this is only called when the AABBs begin to overlap.
         * @param fixtureA b2Fixture potentially colliding with fixtureB.
         * @param fixtureB b2Fixture potentially colliding with fixtureA.
         * @return  True if fixtureA and fixtureB probably collide requiring more calculations, otherwise false.
         */
        ShouldCollide(fixtureA: b2Fixture, fixtureB: b2Fixture): boolean
    }

    /**
     * Contact impulses for reporting. Impulses are used instead of forces because sub-step forces may approach infinity for rigid body collisions. These match up one-to-one with the contact points in b2Manifold.
     */
    declare     export class b2ContactImpulse {

        /**
         * Normal impulses.
         */
        normalImpulses: undefined.b2Vec2;

        /**
         * Tangent impulses.
         */
        tangentImpulses: undefined.b2Vec2
    }

    /**
     * Implement this class to get contact information. You can use these results for things like sounds and game logic. You can also get contact results by traversing the contact lists after the time step. However, you might miss some contacts because continuous physics leads to sub-stepping. Additionally you may receive multiple callbacks for the same contact in a single time step. You should strive to make your callbacks efficient because there may be many callbacks per time step.
     * @warning  You cannot create/destroy Box2D entities inside these callbacks.
     */
    declare     export class b2ContactListener {

        /**
         * Called when two fixtures begin to touch.
         * @param contact Contact point.
         */
        BeginContact(contact: Contacts.b2Contact): void;

        /**
         * Called when two fixtures cease to touch.
         * @param contact Contact point.
         */
        EndContact(contact: Contacts.b2Contact): void;

        /**
         * This lets you inspect a contact after the solver is finished. This is useful for inspecting impulses. Note: the contact manifold does not include time of impact impulses, which can be arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly in a separate data structure. Note: this is only called for contacts that are touching, solid, and awake.
         * @param contact Contact point.
         * @param impulse Contact impulse.
         */
        PostSolve(contact: Contacts.b2Contact, impulse: b2ContactImpulse): void;

        /**
         * This is called after a contact is updated. This allows you to inspect a contact before it goes to the solver. If you are careful, you can modify the contact manifold (e.g. disable contact). A copy of the old manifold is provided so that you can detect changes. Note: this is called only for awake bodies. Note: this is called even when the number of contact points is zero. Note: this is not called for sensors. Note: if you set the number of contact points to zero, you will not get an EndContact callback. However, you may get a BeginContact callback the next step.
         * @param contact Contact point.
         * @param oldManifold Old manifold.
         */
        PreSolve(contact: Contacts.b2Contact, oldManifold: undefined.b2Manifold): void
    }

    /**
     * Implement and register this class with a b2World to provide debug drawing of physics entities in your game.
     * @example  Although Box2D is a physics engine and therefore has nothing to do with drawing, Box2dFlash provides such methods for debugging which are defined in the b2DebugDraw class. In Box2dWeb, a b2DebugDraw takes a canvas-context instead of a Sprite:

    var debugDraw = new Box2D.Dynamics.b2DebugDraw();
    debugDraw.SetSprite(document.GetElementsByTagName("canvas")[0].getContext("2d"));
    */
    declare     export class b2DebugDraw {

        /**
         * Draw axis aligned bounding boxes.
         */
        e_aabbBit: number;

        /**
         * Draw center of mass frame.
         */
        e_centerOfMassBit: number;

        /**
         * Draw controllers.
         */
        e_controllerBit: number;

        /**
         * Draw joint connections.
         */
        e_jointBit: number;

        /**
         * Draw broad-phase pairs.
         */
        e_pairBit: number;

        /**
         * Draw shapes.
         */
        e_shapeBit: number;

        /**
         * Constructor.
         */
        constructor(): this;

        /**
         * Append flags to the current flags.
         * @param flags Flags to add.
         */
        AppendFlags(flags: number): void;

        /**
         * Clear flags from the current flags.
         * @param flags flags to clear.
         */
        ClearFlags(flags: number): void;

        /**
         * Draw a circle.
         * @param center Circle center point.
         * @param radius Circle radius.
         * @param color Circle draw color.
         */
        DrawCircle(center: undefined.b2Vec2, radius: number, color: undefined.b2Color): void;

        /**
         * Draw a closed polygon provided in CCW order.
         * @param vertices Polygon verticies.
         * @param vertexCount Number of vertices in the polygon, usually vertices.length.
         * @param color Polygon draw color.
         */
        DrawPolygon(
            vertices: undefined.b2Vec2[],
            vertexCount: number,
            color: undefined.b2Color): void;

        /**
         * Draw a line segment.
         * @param p1 Line beginpoint.
         * @param p2 Line endpoint.
         * @param color Line color.
         */
        DrawSegment(p1: undefined.b2Vec2, p2: undefined.b2Vec2, color: undefined.b2Color): void;

        /**
         * Draw a solid circle.
         * @param center Circle center point.
         * @param radius Circle radius.
         * @param axis Circle axis.
         * @param color Circle color.
         */
        DrawSolidCircle(
            center: undefined.b2Vec2,
            radius: number,
            axis: undefined.b2Vec2,
            color: undefined.b2Color): void;

        /**
         * Draw a solid closed polygon provided in CCW order.
         * @param vertices Polygon verticies.
         * @param vertexCount Number of vertices in the polygon, usually vertices.length.
         * @param color Polygon draw color.
         */
        DrawSolidPolygon(
            vertices: undefined.b2Vec2[],
            vertexCount: number,
            color: undefined.b2Color): void;

        /**
         * Draw a transform. Choose your own length scale.
         * @param xf Transform to draw.
         */
        DrawTransform(xf: undefined.b2Transform): void;

        /**
         * Get the alpha value used for lines.
         * @return  Alpha value used for drawing lines.
         */
        GetAlpha(): number;

        /**
         * Get the draw scale.
         * @return  Draw scale ratio.
         */
        GetDrawScale(): number;

        /**
         * Get the alpha value used for fills.
         * @return  Alpha value used for drawing fills.
         */
        GetFillAlpha(): number;

        /**
         * Get the drawing flags.
         * @return  Drawing flags.
         */
        GetFlags(): number;

        /**
         * Get the line thickness.
         * @return  Line thickness.
         */
        GetLineThickness(): number;

        /**
         * Get the HTML Canvas Element for drawing.
         * @note  box2dflash uses Sprite object, box2dweb uses CanvasRenderingContext2D, that is why this function is called GetSprite().
         * @return  The HTML Canvas Element used for debug drawing.
         */
        GetSprite(): CanvasRenderingContext2D;

        /**
         * Get the scale used for drawing XForms.
         * @return  Scale for drawing transforms.
         */
        GetXFormScale(): number;

        /**
         * Set the alpha value used for lines.
         * @param alpha Alpha value for drawing lines.
         */
        SetAlpha(alpha: number): void;

        /**
         * Set the draw scale.
         * @param drawScale Draw scale ratio.
         */
        SetDrawScale(drawScale: number): void;

        /**
         * Set the alpha value used for fills.
         * @param alpha Alpha value for drawing fills.
         */
        SetFillAlpha(alpha: number): void;

        /**
         * Set the drawing flags.
         * @param flags Sets the drawing flags.
         */
        SetFlags(flags: number): void;

        /**
         * Set the line thickness.
         * @param lineThickness The new line thickness.
         */
        SetLineThickness(lineThickness: number): void;

        /**
         * Set the HTML Canvas Element for drawing.
         * @note  box2dflash uses Sprite object, box2dweb uses CanvasRenderingContext2D, that is why this function is called SetSprite().
         * @param canvas HTML Canvas Element to draw debug information to.
         */
        SetSprite(canvas: CanvasRenderingContext2D): void;

        /**
         * Set the scale used for drawing XForms.
         * @param xformScale The transform scale.
         */
        SetXFormScale(xformScale: number): void
    }

    /**
     * Joints and shapes are destroyed when their associated body is destroyed. Implement this listener so that you may nullify references to these joints and shapes.
     */
    declare     export class b2DestructionListener {

        /**
         * Called when any fixture is about to be destroyed due to the destruction of its parent body.
         * @param fixture b2Fixture being destroyed.
         */
        SayGoodbyeFixture(fixture: b2Fixture): void;

        /**
         * Called when any joint is about to be destroyed due to the destruction of one of its attached bodies.
         * @param joint b2Joint being destroyed.
         */
        SayGoodbyeJoint(joint: Joints.b2Joint): void
    }

    /**
     * This holds contact filtering data.
     */
    declare     export class b2FilterData {

        /**
         * The collision category bits. Normally you would just set one bit.
         */
        categoryBits: number;

        /**
         * Collision groups allow a certain group of objects to never collide (negative) or always collide (positive). Zero means no collision group. Non-zero group filtering always wins against the mask bits.
         */
        groupIndex: number;

        /**
         * The collision mask bits. This states the categories that this shape would accept for collision.
         */
        maskBits: number;

        /**
         * Creates a copy of the filter data.
         * @return  Copy of this filter data.
         */
        Copy(): b2FilterData
    }

    /**
     * A fixture is used to attach a shape to a body for collision detection. A fixture inherits its transform from its parent. Fixtures hold additional non-geometric data such as friction, collision filters, etc. Fixtures are created via b2Body::CreateFixture.
     * @warning  you cannot reuse fixtures.
     */
    declare     export class b2Fixture {

        /**
         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate AABB, compute it using the shape and the body transform.
         * @return  Fiture's AABB.
         */
        GetAABB(): undefined.b2AABB;

        /**
         * Get the parent body of this fixture. This is NULL if the fixture is not attached.
         * @return  The parent body.
         */
        GetBody(): b2Body;

        /**
         * Get the density of this fixture.
         * @return  Density
         */
        GetDensity(): number;

        /**
         * Get the contact filtering data.
         * @return  Filter data.
         */
        GetFilterData(): b2FilterData;

        /**
         * Get the coefficient of friction.
         * @return  Friction.
         */
        GetFriction(): number;

        /**
         * Get the mass data for this fixture. The mass data is based on the density and the shape. The rotational inertia is about the shape's origin. This operation may be expensive.
         * @param massData This is a reference to a valid b2MassData, if it is null a new b2MassData is allocated and then returned.  Default = null.
         * @return  Mass data.
         */
        GetMassData(massData?: undefined.b2MassData): undefined.b2MassData;

        /**
         * Get the next fixture in the parent body's fixture list.
         * @return  Next fixture.
         */
        GetNext(): b2Fixture;

        /**
         * Get the coefficient of restitution.
         * @return  Restitution.
         */
        GetRestitution(): number;

        /**
         * Get the child shape. You can modify the child shape, however you should not change the number of vertices because this will crash some collision caching mechanisms.
         * @return  Fixture shape.
         */
        GetShape(): undefined.b2Shape;

        /**
         * Get the type of the child shape. You can use this to down cast to the concrete shape.
         * @return  Shape type enum.
         */
        GetType(): number;

        /**
         * Get the user data that was assigned in the fixture definition. Use this to store your application specific data.
         * @return  User provided data.  Cast to your object type.
         */
        GetUserData(): any;

        /**
         * Is this fixture a sensor (non-solid)?
         * @return  True if the shape is a sensor, otherwise false.
         */
        IsSensor(): boolean;

        /**
         * Perform a ray cast against this shape.
         * @param output Ray cast results.  This argument is out.
         * @param input Ray cast input parameters.
         * @return  True if the ray hits the shape, otherwise false.
         */
        RayCast(output: undefined.b2RayCastOutput, input: undefined.b2RayCastInput): boolean;

        /**
         * Set the density of this fixture. This will _not_ automatically adjust the mass of the body. You must call b2Body::ResetMassData to update the body's mass.
         * @param density The new density.
         */
        SetDensity(density: number): void;

        /**
         * Set the contact filtering data. This will not update contacts until the next time step when either parent body is active and awake.
         * @param filter The new filter data.
         */
        SetFilterData(filter: any): void;

        /**
         * Set the coefficient of friction.
         * @param friction The new friction coefficient.
         */
        SetFriction(friction: number): void;

        /**
         * Get the coefficient of restitution.
         * @param resitution The new restitution coefficient.
         */
        SetRestitution(restitution: number): void;

        /**
         * Set if this fixture is a sensor.
         * @param sensor True to set as a sensor, false to not be a sensor.
         */
        SetSensor(sensor: boolean): void;

        /**
         * Set the user data. Use this to store your application specific data.
         * @param data User provided data.
         */
        SetUserData(data: any): void;

        /**
         * Test a point for containment in this fixture.
         * @param p Point to test against, in world coordinates.
         * @return  True if the point is in this shape, otherwise false.
         */
        TestPoint(p: undefined.b2Vec2): boolean
    }

    /**
     * A fixture definition is used to create a fixture. This class defines an abstract fixture definition. You can reuse fixture definitions safely.
     */
    declare     export class b2FixtureDef {

        /**
         * The density, usually in kg/m^2.
         */
        density: number;

        /**
         * Contact filtering data.
         */
        filter: b2FilterData;

        /**
         * The friction coefficient, usually in the range [0,1].
         */
        friction: number;

        /**
         * A sensor shape collects contact information but never generates a collision response.
         */
        isSensor: boolean;

        /**
         * The restitution (elasticity) usually in the range [0,1].
         */
        restitution: number;

        /**
         * The shape, this must be set. The shape will be cloned, so you can create the shape on the stack.
         */
        shape: undefined.b2Shape;

        /**
         * Use this to store application specific fixture data.
         */
        userData: any;

        /**
         * The constructor sets the default fixture definition values.
         */
        constructor(): this
    }

    /**
     * The world class manages all physics entities, dynamic simulation, and asynchronous queries.
     */
    declare     export class b2World {

        /**
         * Locked
         */
        e_locked: number;

        /**
         * New Fixture
         */
        e_newFixture: number;

        /**
         * Creates a new world.
         * @param gravity The world gravity vector.
         * @param doSleep Improvie performance by not simulating inactive bodies.
         */
        constructor(gravity: undefined.b2Vec2, doSleep: boolean): this;

        /**
         * Add a controller to the world list.
         * @param c Controller to add.
         * @return  Controller that was added to the world.
         */
        AddController(c: Controllers.b2Controller): Controllers.b2Controller;

        /**
         * Call this after you are done with time steps to clear the forces. You normally call this after each call to Step, unless you are performing sub-steps.
         */
        ClearForces(): void;

        /**
         * Create a rigid body given a definition. No reference to the definition is retained.
         * @param def Body's definition.
         * @return  Created rigid body.
         */
        CreateBody(def: b2BodyDef): b2Body;

        /**
         * Creates a new controller.
         * @param controller New controller.
         * @return  New controller.
         */
        CreateController(controller: Controllers.b2Controller): Controllers.b2Controller;

        /**
         * Create a joint to constrain bodies together. No reference to the definition is retained. This may cause the connected bodies to cease colliding.
         * @warning  This function is locked during callbacks.
         * @param def Joint definition.
         * @return  New created joint.
         */
        CreateJoint(def: Joints.b2JointDef): Joints.b2Joint;

        /**
         * Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during callbacks.
         * @param b Body to destroy.
         * @warning  This function is locked during callbacks.
         */
        DestroyBody(b: b2Body): void;

        /**
         * Destroy a controller given the controller instance.
         * @warning  This function is locked during callbacks.
         * @param controller Controller to destroy.
         */
        DestroyController(controller: Controllers.b2Controller): void;

        /**
         * Destroy a joint. This may cause the connected bodies to begin colliding.
         * @param j Joint to destroy.
         */
        DestroyJoint(j: Joints.b2Joint): void;

        /**
         * Call this to draw shapes and other debug draw data.
         */
        DrawDebugData(): void;

        /**
         * Get the number of bodies.
         * @return  Number of bodies in this world.
         */
        GetBodyCount(): number;

        /**
         * Get the world body list. With the returned body, use b2Body::GetNext to get the next body in the world list. A NULL body indicates the end of the list.
         * @return  The head of the world body list.
         */
        GetBodyList(): b2Body;

        /**
         * Get the number of contacts (each may have 0 or more contact points).
         * @return  Number of contacts.
         */
        GetContactCount(): number;

        /**
         * Get the world contact list. With the returned contact, use b2Contact::GetNext to get the next contact in the world list. A NULL contact indicates the end of the list.
         * @return  The head of the world contact list.
         */
        GetContactList(): Contacts.b2Contact;

        /**
         * Get the global gravity vector.
         * @return  Global gravity vector.
         */
        GetGravity(): undefined.b2Vec2;

        /**
         * The world provides a single static ground body with no collision shapes. You can use this to simplify the creation of joints and static shapes.
         * @return  The ground body.
         */
        GetGroundBody(): b2Body;

        /**
         * Get the number of joints.
         * @return  The number of joints in the world.
         */
        GetJointCount(): number;

        /**
         * Get the world joint list. With the returned joint, use b2Joint::GetNext to get the next joint in the world list. A NULL joint indicates the end of the list.
         * @return  The head of the world joint list.
         */
        GetJointList(): Joints.b2Joint;

        /**
         * Get the number of broad-phase proxies.
         * @return  Number of borad-phase proxies.
         */
        GetProxyCount(): number;

        /**
         * Is the world locked (in the middle of a time step).
         * @return  True if the world is locked and in the middle of a time step, otherwise false.
         */
        IsLocked(): boolean;

        /**
         * Query the world for all fixtures that potentially overlap the provided AABB.
         * @param callback A user implemented callback class. It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
         * @param aabb The query bounding box.
         */
        QueryAABB(callback: (fixutre: b2Fixture) => boolean, aabb: undefined.b2AABB): void;

        /**
         * Query the world for all fixtures that contain a point.
         * @note  This provides a feature specific to this port.
         * @param callback A user implemented callback class.  It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
         * @param p The query point.
         */
        QueryPoint(callback: (fixture: b2Fixture) => boolean, p: undefined.b2Vec2): void;

        /**
         * Query the world for all fixtures that precisely overlap the provided transformed shape.
         * @note  This provides a feature specific to this port.
         * @param callback A user implemented callback class.  It should match signature function Callback(fixture:b2Fixture):Boolean.  Return true to continue to the next fixture.
         * @param shape The query shape.
         * @param transform Optional transform, default = null.
         */
        QueryShape(
            callback: (fixture: b2Fixture) => boolean,
            shape: undefined.b2Shape,
            transform?: undefined.b2Transform): void;

        /**
         * Ray-cast the world for all fixtures in the path of the ray. Your callback Controls whether you get the closest point, any point, or n-points The ray-cast ignores shapes that contain the starting point.
         * @param callback A callback function which must be of signature:
        function Callback(
        fixture:b2Fixture,	// The fixture hit by the ray
        point:b2Vec2,		// The point of initial intersection
        normal:b2Vec2,		// The normal vector at the point of intersection
        fraction:Number		// The fractional length along the ray of the intersection
        ):Number
        Callback should return the new length of the ray as a fraction of the original length. By returning 0, you immediately terminate. By returning 1, you continue wiht the original ray. By returning the current fraction, you proceed to find the closest point.
         * @param point1 The ray starting point.
         * @param point2 The ray ending point.
        */
        RayCast(
            callback: (
                fixture: b2Fixture,
                point: undefined.b2Vec2,
                normal: undefined.b2Vec2,
                fraction: number) => number,
            point1: undefined.b2Vec2,
            point2: undefined.b2Vec2): void;

        /**
         * Ray-cast the world for all fixture in the path of the ray.
         * @param point1 The ray starting point.
         * @param point2 The ray ending point.
         * @return  Array of all the fixtures intersected by the ray.
         */
        RayCastAll(point1: undefined.b2Vec2, point2: undefined.b2Vec2): b2Fixture[];

        /**
         * Ray-cast the world for the first fixture in the path of the ray.
         * @param point1 The ray starting point.
         * @param point2 The ray ending point.
         * @return  First fixture intersected by the ray.
         */
        RayCastOne(point1: undefined.b2Vec2, point2: undefined.b2Vec2): b2Fixture;

        /**
         * Removes the controller from the world.
         * @param c Controller to remove.
         */
        RemoveController(c: Controllers.b2Controller): void;

        /**
         * Use the given object as a broadphase. The old broadphase will not be cleanly emptied.
         * @warning  This function is locked during callbacks.
         * @param broadphase : Broad phase implementation.
         */
        SetBroadPhase(broadPhase: undefined.IBroadPhase): void;

        /**
         * Register a contact filter to provide specific control over collision. Otherwise the default filter is used (b2_defaultFilter).
         * @param filter Contact filter'er.
         */
        SetContactFilter(filter: b2ContactFilter): void;

        /**
         * Register a contact event listener.
         * @param listener Contact event listener.
         */
        SetContactListener(listener: b2ContactListener): void;

        /**
         * Enable/disable continuous physics. For testing.
         * @param flag True for continuous physics, otherwise false.
         */
        SetContinuousPhysics(flag: boolean): void;

        /**
         * Register a routine for debug drawing. The debug draw functions are called inside the b2World::Step method, so make sure your renderer is ready to consume draw commands when you call Step().
         * @param debugDraw Debug drawing instance.
         */
        SetDebugDraw(debugDraw: b2DebugDraw): void;

        /**
         * Destruct the world. All physics entities are destroyed and all heap memory is released.
         * @param listener Destruction listener instance.
         */
        SetDestructionListener(listener: b2DestructionListener): void;

        /**
         * Change the global gravity vector.
         * @param gravity New global gravity vector.
         */
        SetGravity(gravity: undefined.b2Vec2): void;

        /**
         * Enable/disable warm starting. For testing.
         * @param flag True for warm starting, otherwise false.
         */
        SetWarmStarting(flag: boolean): void;

        /**
         * Take a time step. This performs collision detection, integration, and constraint solution.
         * @param dt The amout of time to simulate, this should not vary.
         * @param velocityIterations For the velocity constraint solver.
         * @param positionIterations For the position constraint solver.
         */
        Step(dt: number, velocityIterations: number, positionIterations: number): void;

        /**
         * Perform validation of internal data structures.
         */
        Validate(): void
    }
    declare module 'Contacts' {

        /**
         * The class manages contact between two shapes. A contact exists for each overlapping AABB in the broad-phase (except if filtered). Therefore a contact object may exist that has no contact points.
         */
        declare         export class b2Contact {

            /**
             * Constructor
             */
            constructor(): this;

            /**
             * Flag this contact for filtering. Filtering will occur the next time step.
             */
            FlagForFiltering(): void;

            /**
             * Get the first fixture in this contact.
             * @return  First fixture in this contact.
             */
            GetFixtureA(): b2Fixture;

            /**
             * Get the second fixture in this contact.
             * @return  Second fixture in this contact.
             */
            GetFixtureB(): b2Fixture;

            /**
             * Get the contact manifold. Do not modify the manifold unless you understand the internals of Box2D.
             * @return  Contact manifold.
             */
            GetManifold(): undefined.b2Manifold;

            /**
             * Get the next contact in the world's contact list.
             * @return  Next contact in the world's contact list.
             */
            GetNext(): b2Contact;

            /**
             * Get the world manifold.
             * @param worldManifold World manifold out.
             * @return  World manifold.
             */
            GetWorldManifold(worldManifold: undefined.b2WorldManifold): void;

            /**
             * Does this contact generate TOI events for continuous simulation.
             * @return  True for continous, otherwise false.
             */
            IsContinuous(): boolean;

            /**
             * Has this contact been disabled?
             * @return  True if disabled, otherwise false.
             */
            IsEnabled(): boolean;

            /**
             * Is this contact a sensor?
             * @return  True if sensor, otherwise false.
             */
            IsSensor(): boolean;

            /**
             * Is this contact touching.
             * @return  True if contact is touching, otherwise false.
             */
            IsTouching(): boolean;

            /**
             * Enable/disable this contact. This can be used inside the pre-solve contact listener. The contact is only disabled for the current time step (or sub-step in continuous collision).
             * @param flag True to enable, false to disable.
             */
            SetEnabled(flag: boolean): void;

            /**
             * Change this to be a sensor or-non-sensor contact.
             * @param sensor True to be sensor, false to not be a sensor.
             */
            SetSensor(sensor: boolean): void
        }

        /**
         * A contact edge is used to connect bodies and contacts together in a contact graph where each body is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained in each attached body. Each contact has two contact nodes, one for each attached body.
         */
        declare         export class b2ContactEdge {

            /**
             * Contact.
             */
            contact: b2Contact;

            /**
             * Next contact edge.
             */
            next: b2ContactEdge;

            /**
             * Contact body.
             */
            other: b2Body;

            /**
             * Previous contact edge.
             */
            prev: b2ContactEdge
        }

        /**
         * This structure is used to report contact point results.
         */
        declare         export class b2ContactResult {

            /**
             * The contact id identifies the features in contact.
             */
            id: undefined.b2ContactID;

            /**
             * Points from shape1 to shape2.
             */
            normal: undefined.b2Vec2;

            /**
             * The normal impulse applied to body2.
             */
            normalImpulse: number;

            /**
             * Position in world coordinates.
             */
            position: undefined.b2Vec2;

            /**
             * The first shape.
             */
            shape1: undefined.b2Shape;

            /**
             * The second shape.
             */
            shape2: undefined.b2Shape;

            /**
             * The tangent impulse applied to body2.
             */
            tangentImpulse: number
        }
    }

    declare module 'Controllers' {

        /**
         * Base class for controllers. Controllers are a convience for encapsulating common per-step functionality.
         */
        declare         export class b2Controller {

            /**
             * Body count.
             */
            m_bodyCount: number;

            /**
             * List of bodies.
             */
            m_bodyList: b2ControllerEdge;

            /**
             * Adds a body to the controller.
             * @param body Body to add.
             */
            AddBody(body: b2Body): void;

            /**
             * Removes all bodies from the controller.
             */
            Clear(): void;

            /**
             * Debug drawing.
             * @param debugDraw Handle to drawer.
             */
            Draw(debugDraw: b2DebugDraw): void;

            /**
             * Gets the body list.
             * @return  Body list.
             */
            GetBodyList(): b2ControllerEdge;

            /**
             * Gets the next controller.
             * @return  Next controller.
             */
            GetNext(): b2Controller;

            /**
             * Gets the world.
             * @return  World.
             */
            GetWorld(): b2World;

            /**
             * Removes a body from the controller.
             * @param body Body to remove from this controller.
             */
            RemoveBody(body: b2Body): void;

            /**
             * Step
             * @param step b2TimeStep -> Private internal class.  Not sure why this is exposed.
             */
            Step(step: any): void
        }

        /**
         * Controller Edge.
         */
        declare         export class b2ControllerEdge {

            /**
             * Body.
             */
            body: b2Body;

            /**
             * Provides quick access to the other end of this edge.
             */
            controller: b2Controller;

            /**
             * The next controller edge in the controller's body list.
             */
            nextBody: b2ControllerEdge;

            /**
             * The next controller edge in the body's controller list.
             */
            nextController: b2ControllerEdge;

            /**
             * The previous controller edge in the controller's body list.
             */
            prevBody: b2ControllerEdge;

            /**
             * The previous controller edge in the body's controller list.
             */
            prevController: b2ControllerEdge
        }

        /**
         * Calculates buoyancy forces for fluids in the form of a half plane.
         */
        declare         export class b2BuoyancyController mixins b2Controller {

            /**
             * Linear drag co-efficient.
             * @default  = 1
             */
            angularDrag: number;

            /**
             * The fluid density.
             * @default  = 0
             */
            density: number;

            /**
             * Gravity vector, if the world's gravity is not used.
             * @default  = null
             */
            gravity: undefined.b2Vec2;

            /**
             * Linear drag co-efficient.
             * @default  = 2
             */
            linearDrag: number;

            /**
             * The outer surface normal.
             */
            normal: undefined.b2Vec2;

            /**
             * The height of the fluid surface along the normal.
             * @default  = 0
             */
            offset: number;

            /**
             * If false, bodies are assumed to be uniformly dense, otherwise use the shapes densities.
             * @default  = false.
             */
            useDensity: boolean;

            /**
             * If true, gravity is taken from the world instead of the gravity parameter.
             * @default  = true.
             */
            useWorldGravity: boolean;

            /**
             * Fluid velocity, for drag calculations.
             */
            velocity: undefined.b2Vec2
        }

        /**
         * Applies an acceleration every frame, like gravity
         */
        declare         export class b2ConstantAccelController mixins b2Controller {

            /**
             * The acceleration to apply.
             */
            A: undefined.b2Vec2;

            /**
             * 
             * @see  b2Controller.Step
             */
            Step(step: any): void
        }

        /**
         * Applies an acceleration every frame, like gravity.
         */
        declare         export class b2ConstantForceController mixins b2Controller {

            /**
             * The acceleration to apply.
             */
            A: undefined.b2Vec2;

            /**
             * 
             * @see  b2Controller.Step
             */
            Step(step: any): void
        }

        /**
         * Applies simplified gravity between every pair of bodies.
         */
        declare         export class b2GravityController mixins b2Controller {

            /**
             * Specifies the strength of the gravitation force.
             * @default  = 1
             */
            G: number;

            /**
             * If true, gravity is proportional to r^-2, otherwise r^-1.
             */
            invSqr: boolean;

            /**
             * 
             * @see  b2Controller.Step
             */
            Step(step: any): void
        }

        /**
         * Applies top down linear damping to the controlled bodies The damping is calculated by multiplying velocity by a matrix in local co-ordinates.
         */
        declare         export class b2TensorDampingController mixins b2Controller {

            /**
             * Set this to a positive number to clamp the maximum amount of damping done.
             * @default  = 0
             */
            maxTimeStep: number;

            /**
             * Tensor to use in damping model.
             */
            T: undefined.b2Mat22;

            /**
             * Helper function to set T in a common case.
             * @param xDamping x
             * @param yDamping y
             */
            SetAxisAligned(xDamping: number, yDamping: number): void;

            /**
             * 
             * @see  b2Controller.Step
             */
            Step(step: any): void
        }
    }

    declare module 'Joints' {

        /**
         * The base joint class. Joints are used to constraint two bodies together in various fashions. Some joints also feature limits and motors.
         */
        declare         export class b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Anchor A point.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Anchor B point.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the first body attached to this joint.
             * @return  Body A.
             */
            GetBodyA(): b2Body;

            /**
             * Get the second body attached to this joint.
             * @return  Body B.
             */
            GetBodyB(): b2Body;

            /**
             * Get the next joint the world joint list.
             * @return  Next joint.
             */
            GetNext(): b2Joint;

            /**
             * Get the reaction force on body2 at the joint anchor in Newtons.
             * @param inv_dt 
             * @return  Reaction force (N)
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body2 in N.
             * @param inv_dt 
             * @return  Reaction torque (N).
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Get the type of the concrete joint.
             * @return  Joint type.
             */
            GetType(): number;

            /**
             * Get the user data pointer.
             * @return  User data.  Cast to your data type.
             */
            GetUserData(): any;

            /**
             * Short-cut function to determine if either body is inactive.
             * @return  True if active, otherwise false.
             */
            IsActive(): boolean;

            /**
             * Set the user data pointer.
             * @param data Your custom data.
             */
            SetUserData(data: any): void
        }

        /**
         * Joint definitions are used to construct joints.
         */
        declare         export class b2JointDef {

            /**
             * The first attached body.
             */
            bodyA: b2Body;

            /**
             * The second attached body.
             */
            bodyB: b2Body;

            /**
             * Set this flag to true if the attached bodies should collide.
             */
            collideConnected: boolean;

            /**
             * The joint type is set automatically for concrete joint types.
             */
            type: number;

            /**
             * Use this to attach application specific data to your joints.
             */
            userData: any;

            /**
             * Constructor.
             */
            constructor(): this
        }

        /**
         * A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two joint nodes, one for each attached body.
         */
        declare         export class b2JointEdge {

            /**
             * The joint.
             */
            joint: b2Joint;

            /**
             * The next joint edge in the body's joint list.
             */
            next: b2JointEdge;

            /**
             * Provides quick access to the other body attached.
             */
            other: b2Body;

            /**
             * The previous joint edge in the body's joint list.
             */
            prev: b2JointEdge
        }

        /**
         * A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can view this as a massless, rigid rod.
         */
        declare         export class b2DistanceJoint mixins b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Gets the damping ratio.
             * @return  Damping ratio.
             */
            GetDampingRatio(): number;

            /**
             * Gets the frequency.
             * @return  Frequency.
             */
            GetFrequency(): number;

            /**
             * Gets the length of distance between the two bodies.
             * @return  Length.
             */
            GetLength(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Sets the damping ratio.
             * @param ratio New damping ratio.
             */
            SetDampingRatio(ratio: number): void;

            /**
             * Sets the frequency.
             * @param hz New frequency (hertz).
             */
            SetFrequency(hz: number): void;

            /**
             * Sets the length of distance between the two bodies.
             * @param length New length.
             */
            SetLength(length: number): void
        }

        /**
         * Distance joint definition. This requires defining an anchor point on both bodies and the non-zero length of the distance joint. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when saving and loading a game.
         * @warning  Do not use a zero or short length.
         */
        declare         export class b2DistanceJointDef mixins b2JointDef {

            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             */
            dampingRatio: number;

            /**
             * The mass-spring-damper frequency in Hertz.
             */
            frequencyHz: number;

            /**
             * The natural length between the anchor points.
             */
            length: number;

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, anchors, and length using the world anchors.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchorA Anchor A.
             * @param anchorB Anchor B.
             */
            Initialize(
                bA: b2Body,
                bB: b2Body,
                anchorA: undefined.b2Vec2,
                anchorB: undefined.b2Vec2): void
        }

        /**
         * Friction joint. This is used for top-down friction. It provides 2D translational friction and angular friction.
         */
        declare         export class b2FrictionJoint mixins b2Joint {

            /**
             * Angular mass.
             */
            m_angularMass: number;

            /**
             * Linear mass.
             */
            m_linearMass: undefined.b2Mat22;

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Gets the max force.
             * @return  Max force.
             */
            GetMaxForce(): number;

            /**
             * Gets the max torque.
             * @return  Max torque.
             */
            GetMaxTorque(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Sets the max force.
             * @param force New max force.
             */
            SetMaxForce(force: number): void;

            /**
             * Sets the max torque.
             * @param torque New max torque.
             */
            SetMaxTorque(torque: number): void
        }

        /**
         * Friction joint defintion.
         */
        declare         export class b2FrictionJointDef mixins b2JointDef {

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The maximum force in N.
             */
            maxForce: number;

            /**
             * The maximum friction torque in N-m.
             */
            maxTorque: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchor World anchor.
             */
            Initialize(bA: b2Body, bB: b2Body, anchor: undefined.b2Vec2): void
        }

        /**
         * A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify a gear ratio to bind the motions together: coordinate1 + ratio coordinate2 = constant The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint, then the ratio will have units of length or units of 1/length.
         * @warning  The revolute and prismatic joints must be attached to fixed bodies (which must be body1 on those joints).
         */
        declare         export class b2GearJoint mixins b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the gear ratio.
             * @return  Gear ratio.
             */
            GetRatio(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Set the gear ratio.
             * @param force New gear ratio.
             */
            SetRatio(ratio: number): void
        }

        /**
         * Gear joint definition. This definition requires two existing revolute or prismatic joints (any combination will work). The provided joints must attach a dynamic body to a static body.
         */
        declare         export class b2GearJointDef mixins b2JointDef {

            /**
             * The first revolute/prismatic joint attached to the gear joint.
             */
            joint1: b2Joint;

            /**
             * The second revolute/prismatic joint attached to the gear joint.
             */
            joint2: b2Joint;

            /**
             * The gear ratio.
             */
            ratio: number;

            /**
             * Constructor.
             */
            constructor(): this
        }

        /**
         * A line joint. This joint provides one degree of freedom: translation along an axis fixed in body1. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction.
         */
        declare         export class b2LineJoint mixins b2Joint {

            /**
             * Enable/disable the joint limit.
             * @param flag True to enable, false to disable limits
             */
            EnableLimit(flag: boolean): void;

            /**
             * Enable/disable the joint motor.
             * @param flag True to enable, false to disable the motor.
             */
            EnableMotor(flag: boolean): void;

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the current joint translation speed, usually in meters per second.
             * @return  Joint speed.
             */
            GetJointSpeed(): number;

            /**
             * Get the current joint translation, usually in meters.
             * @return  Joint translation.
             */
            GetJointTranslation(): number;

            /**
             * Get the lower joint limit, usually in meters.
             * @return  Lower limit.
             */
            GetLowerLimit(): number;

            /**
             * Get the maximum motor force, usually in N.
             * @return  Max motor force.
             */
            GetMaxMotorForce(): number;

            /**
             * Get the current motor force, usually in N.
             * @return  Motor force.
             */
            GetMotorForce(): number;

            /**
             * Get the motor speed, usually in meters per second.
             * @return  Motor speed.
             */
            GetMotorSpeed(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Get the upper joint limit, usually in meters.
             * @return  Upper limit.
             */
            GetUpperLimit(): number;

            /**
             * Is the joint limit enabled?
             * @return  True if enabled otherwise false.
             */
            IsLimitEnabled(): boolean;

            /**
             * Is the joint motor enabled?
             * @return  True if enabled, otherwise false.
             */
            IsMotorEnabled(): boolean;

            /**
             * Set the joint limits, usually in meters.
             * @param lower Lower limit.
             * @param upper Upper limit.
             */
            SetLimits(lower: number, upper: number): void;

            /**
             * Set the maximum motor force, usually in N.
             * @param force New max motor force.
             */
            SetMaxMotorForce(force: number): void;

            /**
             * Set the motor speed, usually in meters per second.
             * @param speed New motor speed.
             */
            SetMotorSpeed(speed: number): void
        }

        /**
         * Line joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game.
         */
        declare         export class b2LineJointDef mixins b2JointDef {

            /**
             * Enable/disable the joint limit.
             */
            enableLimit: boolean;

            /**
             * Enable/disable the joint motor.
             */
            enableMotor: boolean;

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The local translation axis in bodyA.
             */
            localAxisA: undefined.b2Vec2;

            /**
             * The lower translation limit, usually in meters.
             */
            lowerTranslation: number;

            /**
             * The maximum motor torque, usually in N-m.
             */
            maxMotorForce: number;

            /**
             * The desired motor speed in radians per second.
             */
            motorSpeed: number;

            /**
             * The upper translation limit, usually in meters.
             */
            upperTranslation: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, anchors, and length using the world anchors.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchor Anchor.
             * @param axis Axis.
             */
            Initialize(bA: b2Body, bB: b2Body, anchor: undefined.b2Vec2, axis: undefined.b2Vec2): void
        }

        /**
         * A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces. Note: this joint is not fully documented as it is intended primarily for the testbed. See that for more instructions.
         */
        declare         export class b2MouseJoint mixins b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Gets the damping ratio.
             * @return  Damping ratio.
             */
            GetDampingRatio(): number;

            /**
             * Gets the frequency.
             * @return  Frequency.
             */
            GetFrequency(): number;

            /**
             * Gets the max force.
             * @return  Max force.
             */
            GetMaxForce(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Gets the target.
             * @return  Target.
             */
            GetTarget(): undefined.b2Vec2;

            /**
             * Sets the damping ratio.
             * @param ratio New damping ratio.
             */
            SetDampingRatio(ratio: number): void;

            /**
             * Sets the frequency.
             * @param hz New frequency (hertz).
             */
            SetFrequency(hz: number): void;

            /**
             * Sets the max force.
             * @param maxForce New max force.
             */
            SetMaxForce(maxForce: number): void;

            /**
             * Use this to update the target point.
             * @param target New target.
             */
            SetTarget(target: undefined.b2Vec2): void
        }

        /**
         * Mouse joint definition. This requires a world target point, tuning parameters, and the time step.
         */
        declare         export class b2MouseJointDef mixins b2JointDef {

            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             */
            dampingRatio: number;

            /**
             * The response speed.
             */
            frequencyHz: number;

            /**
             * The maximum constraint force that can be exerted to move the candidate body.
             */
            maxForce: number;

            /**
             * Constructor.
             */
            constructor(): this
        }

        /**
         * A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in body1. Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction.
         */
        declare         export class b2PrismaticJoint mixins b2Joint {

            /**
             * Enable/disable the joint limit.
             * @param flag True to enable, false to disable.
             */
            EnableLimit(flag: boolean): void;

            /**
             * Enable/disable the joint motor.
             * @param flag True to enable, false to disable.
             */
            EnableMotor(flag: boolean): void;

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the current joint translation speed, usually in meters per second.
             * @return  Joint speed.
             */
            GetJointSpeed(): number;

            /**
             * Get the current joint translation, usually in meters.
             * @return  Joint translation.
             */
            GetJointTranslation(): number;

            /**
             * Get the lower joint limit, usually in meters.
             * @return  Lower limit.
             */
            GetLowerLimit(): number;

            /**
             * Get the current motor force, usually in N.
             * @return  Motor force.
             */
            GetMotorForce(): number;

            /**
             * Get the motor speed, usually in meters per second.
             * @return  Motor speed.
             */
            GetMotorSpeed(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Get the upper joint limit, usually in meters.
             * @return  Upper limit.
             */
            GetUpperLimit(): number;

            /**
             * Is the joint limit enabled?
             * @return  True if enabled otherwise false.
             */
            IsLimitEnabled(): boolean;

            /**
             * Is the joint motor enabled?
             * @return  True if enabled, otherwise false.
             */
            IsMotorEnabled(): boolean;

            /**
             * Set the joint limits, usually in meters.
             * @param lower Lower limit.
             * @param upper Upper limit.
             */
            SetLimits(lower: number, upper: number): void;

            /**
             * Set the maximum motor force, usually in N.
             * @param force New max force.
             */
            SetMaxMotorForce(force: number): void;

            /**
             * Set the motor speed, usually in meters per second.
             * @param speed New motor speed.
             */
            SetMotorSpeed(speed: number): void
        }

        /**
         * Prismatic joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game.
         */
        declare         export class b2PrismaticJointDef mixins b2JointDef {

            /**
             * Enable/disable the joint limit.
             */
            enableLimit: boolean;

            /**
             * Enable/disable the joint motor.
             */
            enableMotor: boolean;

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The local translation axis in body1.
             */
            localAxisA: undefined.b2Vec2;

            /**
             * The lower translation limit, usually in meters.
             */
            lowerTranslation: number;

            /**
             * The maximum motor torque, usually in N-m.
             */
            maxMotorForce: number;

            /**
             * The desired motor speed in radians per second.
             */
            motorSpeed: number;

            /**
             * The constrained angle between the bodies: bodyB_angle - bodyA_angle.
             */
            referenceAngle: number;

            /**
             * The upper translation limit, usually in meters.
             */
            upperTranslation: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the joint.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchor Anchor.
             * @param axis Axis.
             */
            Initialize(bA: b2Body, bB: b2Body, anchor: undefined.b2Vec2, axis: undefined.b2Vec2): void
        }

        /**
         * The pulley joint is connected to two bodies and two fixed ground points. The pulley supports a ratio such that: length1 + ratio length2 <= constant Yes, the force transmitted is scaled by the ratio. The pulley also enforces a maximum length limit on both sides. This is useful to prevent one side of the pulley hitting the top.
         */
        declare         export class b2PullyJoint mixins b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the first ground anchor.
             */
            GetGroundAnchorA(): undefined.b2Vec2;

            /**
             * Get the second ground anchor.
             */
            GetGroundAnchorB(): undefined.b2Vec2;

            /**
             * Get the current length of the segment attached to body1.
             */
            GetLength1(): number;

            /**
             * Get the current length of the segment attached to body2.
             */
            GetLength2(): number;

            /**
             * Get the pulley ratio.
             */
            GetRatio(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number
        }

        /**
         * Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a pulley ratio.
         */
        declare         export class b2PullyJointDef mixins b2JointDef {

            /**
             * The first ground anchor in world coordinates. This point never moves.
             */
            groundAnchorA: undefined.b2Vec2;

            /**
             * The second ground anchor in world coordinates. This point never moves.
             */
            groundAnchorB: undefined.b2Vec2;

            /**
             * The a reference length for the segment attached to bodyA.
             */
            lengthA: number;

            /**
             * The a reference length for the segment attached to bodyB.
             */
            lengthB: number;

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The maximum length of the segment attached to bodyA.
             */
            maxLengthA: number;

            /**
             * The maximum length of the segment attached to bodyB.
             */
            maxLengthB: number;

            /**
             * The pulley ratio, used to simulate a block-and-tackle.
             */
            ratio: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, anchors, and length using the world anchors.
             * @param bA Body A.
             * @param bB Body B.
             * @param gaA Ground anchor A.
             * @param gaB Ground anchor B.
             * @param anchorA Anchor A.
             * @param anchorB Anchor B.
             */
            Initialize(
                bA: b2Body,
                bB: b2Body,
                gaA: undefined.b2Vec2,
                gaB: undefined.b2Vec2,
                anchorA: undefined.b2Vec2,
                anchorB: undefined.b2Vec2): void
        }

        /**
         * A revolute joint constrains to bodies to share a common point while they are free to rotate about the point. The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point. A maximum motor torque is provided so that infinite forces are not generated.
         */
        declare         export class b2RevoluteJoint mixins b2Joint {

            /**
             * Enable/disable the joint limit.
             * @param flag True to enable, false to disable.
             */
            EnableLimit(flag: boolean): void;

            /**
             * Enable/disable the joint motor.
             * @param flag True to enable, false to diasable.
             */
            EnableMotor(flag: boolean): void;

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the current joint angle in radians.
             * @return  Joint angle.
             */
            GetJointAngle(): number;

            /**
             * Get the current joint angle speed in radians per second.
             * @return  Joint speed.
             */
            GetJointSpeed(): number;

            /**
             * Get the lower joint limit in radians.
             * @return  Lower limit.
             */
            GetLowerLimit(): number;

            /**
             * Get the motor speed in radians per second.
             * @return  Motor speed.
             */
            GetMotorSpeed(): number;

            /**
             * Get the current motor torque, usually in N-m.
             * @return  Motor torque.
             */
            GetMotorTorque(): number;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number;

            /**
             * Get the upper joint limit in radians.
             * @return  Upper limit.
             */
            GetUpperLimit(): number;

            /**
             * Is the joint limit enabled?
             * @return  True if enabled, false if disabled.
             */
            IsLimitEnabled(): boolean;

            /**
             * Is the joint motor enabled?
             * @return  True if enabled, false if disabled.
             */
            IsMotorEnabled(): boolean;

            /**
             * Set the joint limits in radians.
             * @param lower New lower limit.
             * @param upper New upper limit.
             */
            SetLimits(lower: number, upper: number): void;

            /**
             * Set the maximum motor torque, usually in N-m.
             * @param torque New max torque.
             */
            SetMaxMotorTorque(torque: number): void;

            /**
             * Set the motor speed in radians per second.
             * @param speed New motor speed.
             */
            SetMotorSpeed(speed: number): void
        }

        /**
         * Revolute joint definition. This requires defining an anchor point where the bodies are joined. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. You also need to specify the initial relative angle for joint limits. This helps when saving and loading a game. The local anchor points are measured from the body's origin rather than the center of mass because: 1. you might not know where the center of mass will be. 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken.
         */
        declare         export class b2RevoluteJointDef mixins b2JointDef {

            /**
             * A flag to enable joint limits.
             */
            enableLimit: boolean;

            /**
             * A flag to enable the joint motor.
             */
            enableMotor: boolean;

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The lower angle for the joint limit (radians).
             */
            lowerAngle: number;

            /**
             * The maximum motor torque used to achieve the desired motor speed. Usually in N-m.
             */
            maxMotorTorque: number;

            /**
             * The desired motor speed. Usually in radians per second.
             */
            motorSpeed: number;

            /**
             * The bodyB angle minus bodyA angle in the reference state (radians).
             */
            referenceAngle: number;

            /**
             * The upper angle for the joint limit (radians).
             */
            upperAngle: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, achors, and reference angle using the world anchor.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchor Anchor.
             */
            Initialize(bA: b2Body, bB: b2Body, anchor: undefined.b2Vec2): void
        }

        /**
         * A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island constraint solver is approximate.
         */
        declare         export class b2WeldJoint mixins b2Joint {

            /**
             * Get the anchor point on bodyA in world coordinates.
             * @return  Body A anchor.
             */
            GetAnchorA(): undefined.b2Vec2;

            /**
             * Get the anchor point on bodyB in world coordinates.
             * @return  Body B anchor.
             */
            GetAnchorB(): undefined.b2Vec2;

            /**
             * Get the reaction force on body2 at the joint anchor in N.
             * @param inv_dt 
             * @return  Reaction force in N.
             */
            GetReactionForce(inv_dt: number): undefined.b2Vec2;

            /**
             * Get the reaction torque on body 2 in N.
             * @param inv_dt 
             * @return  Reaction torque in N.
             */
            GetReactionTorque(inv_dt: number): number
        }

        /**
         * Weld joint definition. You need to specify local anchor points where they are attached and the relative body angle. The position of the anchor points is important for computing the reaction torque.
         */
        declare         export class b2WeldJointDef mixins b2JointDef {

            /**
             * The local anchor point relative to body1's origin.
             */
            localAnchorA: undefined.b2Vec2;

            /**
             * The local anchor point relative to body2's origin.
             */
            localAnchorB: undefined.b2Vec2;

            /**
             * The body2 angle minus body1 angle in the reference state (radians).
             */
            referenceAngle: number;

            /**
             * Constructor.
             */
            constructor(): this;

            /**
             * Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
             * @param bA Body A.
             * @param bB Body B.
             * @param anchor Anchor.
             */
            Initialize(bA: b2Body, bB: b2Body, anchor: undefined.b2Vec2): void
        }
    }

}