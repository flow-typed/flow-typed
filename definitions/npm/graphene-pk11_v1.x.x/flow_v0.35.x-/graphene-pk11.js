// @flow
/**
 * Flowtype definitions for graphene-pk11
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'graphene-pk11' {

    declare type Handle = Buffer;
    declare type CryptoData = string | Buffer;
    declare class Pkcs11Error mixins Error {
        code: number;
        func: string;
        constructor(code: number, func: string): this
    }
    declare class BaseObject {
        lib: pkcs11.PKCS11;
        constructor(lib?: pkcs11.PKCS11): this
    }
    declare class HandleObject mixins BaseObject {

        /**
         * handle to pkcs11 object
         */
        handle: Handle;
        constructor(handle: Handle, lib: pkcs11.PKCS11): this;
        getInfo(): void
    }
    declare class Collection<T>mixins BaseObject {
        items_: Array<any>;
        classType: any;

        /**
         * returns length of collection
         */
        length: number;
        constructor(items: Array<any>, lib: pkcs11.PKCS11, classType: any): this;

        /**
         * returns item from collection by index
         * @param  of element in collection `[0..n]`
         */
        items(index: number): T
    }
    declare     function isString(v: any): boolean
    declare     function isNumber(v: any): boolean
    declare     function isBoolean(v: any): boolean
    declare     function isUndefined(v: any): boolean
    declare     function isNull(v: any): boolean
    declare     function isEmpty(v: any): boolean
    declare     function isFunction(v: any): boolean
    declare     function isObject(v: any): boolean
    declare     function isArray(v: any): boolean
    declare     function isFlag(v: any, fv: number): boolean
    declare     function dateFromString(text: string): Date
    declare class Cipher mixins BaseObject {
        session: Session;
        constructor(session: Session, alg: MechanismType, key: Key, lib: pkcs11.PKCS11): this;
        init(alg: MechanismType, key: Key): void;
        update(data: CryptoData): Buffer;
        final(): Buffer;
        once(data: CryptoData, enc: Buffer): Buffer;
        once(data: CryptoData, enc: Buffer, cb: (error: Error, data: Buffer) => void): void
    }
    declare class Decipher mixins BaseObject {
        session: Session;
        blockSize: number;
        constructor(session: Session, alg: MechanismType, key: Key, blockSize: number, lib: pkcs11.PKCS11): this;
        init(alg: MechanismType, key: Key): void;
        update(data: Buffer): Buffer;
        final(): Buffer;
        once(data: Buffer, dec: Buffer): Buffer;
        once(data: Buffer, dec: Buffer, cb: (error: Error, data: Buffer) => void): void
    }
    declare class Digest mixins BaseObject {
        session: Session;
        constructor(session: Session, alg: MechanismType, lib: pkcs11.PKCS11): this;
        init(alg: MechanismType): void;
        update(data: CryptoData): void;
        final(): Buffer;
        once(data: CryptoData): Buffer;
        once(data: CryptoData, cb: (error: Error, data: Buffer) => void): void
    }
    declare class Sign mixins BaseObject {
        session: Session;
        constructor(session: Session, alg: MechanismType, key: Key, lib: pkcs11.PKCS11): this;
        init(alg: MechanismType, key: Key): void;
        update(data: CryptoData): void;
        final(): Buffer;
        once(data: CryptoData): Buffer;
        once(data: CryptoData, cb: (error: Error, data: Buffer) => void): void
    }
    declare class Verify mixins BaseObject {
        session: Session;
        constructor(session: Session, alg: MechanismType, key: Key, lib: pkcs11.PKCS11): this;
        init(alg: MechanismType, key: Key): void;
        update(data: CryptoData): void;
        final(signature: Buffer): boolean;
        once(data: CryptoData, signature: Buffer): boolean;
        once(
            data: CryptoData,
            signature: Buffer,
            cb: (error: Error, valid: boolean) => void): void
    }
    declare interface IParams {
        toCKI(): any
    }
    declare class AesCbcParams mixins IParams, pkcs11.AesCBC {

        /**
         * initialization vector
         * - must have a fixed size of 16 bytes
         */
        iv: Buffer;

        /**
         * the data
         */
        data: Buffer;
        type: MechParams;
        constructor(iv: Buffer, data?: Buffer): this;
        toCKI(): Buffer
    }
    declare class AesCcmParams mixins IParams {

        /**
         * length of the data where 0 <= dataLength<2^8L
         */
        dataLength: number;

        /**
         * the nonce
         */
        nonce: Buffer;

        /**
         * the additional authentication data
         * - This data is authenticated but not encrypted
         */
        aad: Buffer;

        /**
         * length of authentication tag (output following cipher text) in bits.
         * - Can be any value between 0 and 128
         */
        macLength: number;
        type: MechParams;
        constructor(dataLength: number, nonce: Buffer, aad?: Buffer, macLength?: number): this;
        toCKI(): pkcs11.AesCCM
    }
    declare class AesGcmParams mixins IParams {

        /**
         * initialization vector
         * - The length of the initialization vector can be any number between 1 and 256.
        96-bit (12 byte) IV values can be processed more efficiently,
        so that length is recommended for situations in which efficiency is critical.
        */
        iv: Buffer;

        /**
         * pointer to additional authentication data.
         * This data is authenticated but not encrypted.
         */
        aad: Buffer;

        /**
         * length of authentication tag (output following cipher text) in bits.
         * Can be any value between 0 and 128. Default 128
         */
        tagBits: number;
        type: MechParams;
        constructor(iv: Buffer, aad?: Buffer, tagBits?: number): this;
        toCKI(): pkcs11.AesGCM
    }
    declare interface INamedCurve {
        name: string,
            oid: string,
            value: Buffer,
            size: number
    }
    declare class NamedCurve {
        getByName(name: string): INamedCurve;
        getByOid(oid: string): INamedCurve
    }
    declare class EcdhParams mixins IParams, pkcs11.ECDH1 {

        /**
         * key derivation function used on the shared secret value
         */
        kdf: EcKdf;

        /**
         * some data shared between the two parties
         */
        sharedData: Buffer;

        /**
         * other party's EC public key value
         */
        publicData: Buffer;
        type: MechParams;

        /**
         * Creates an instance of EcdhParams.
         * @param  key derivation function used on the shared secret value
         * @param  some data shared between the two parties
         * @param  other party's EC public key value
         */
        constructor(kdf: EcKdf, sharedData?: Buffer, publicData?: Buffer): this;
        toCKI(): pkcs11.ECDH1
    }
    declare class RsaOaepParams mixins IParams {
        hashAlgorithm: MechanismEnum;
        mgf: RsaMgf;
        source: number;
        sourceData: Buffer;
        type: MechParams;
        constructor(hashAlg?: MechanismEnum, mgf?: RsaMgf, sourceData?: Buffer): this;
        toCKI(): pkcs11.RsaOAEP
    }
    declare class RsaPssParams mixins IParams {

        /**
         * hash algorithm used in the PSS encoding;
         * - if the signature mechanism does not include message hashing,
        then this value must be the mechanism used by the application to generate
        the message hash;
        - if the signature mechanism includes hashing,
        then this value must match the hash algorithm indicated
        by the signature mechanism
        */
        hashAlgorithm: MechanismEnum;

        /**
         * mask generation function to use on the encoded block
         */
        mgf: RsaMgf;

        /**
         * length, in bytes, of the salt value used in the PSS encoding;
         * - typical values are the length of the message hash and zero
         */
        saltLength: number;
        type: MechParams;
        constructor(hashAlg?: MechanismEnum, mgf?: RsaMgf, saltLen?: number): this;
        toCKI(): pkcs11.RsaPSS
    }
    declare class SessionObject mixins HandleObject {

        /**
         * Session
         */
        session: Session;

        /**
         * gets the size of an object in bytes
         * @readonly  * 
         * @type  
         */
        size: number;
        class: ObjectClass;

        /**
         * Creates an instance of SessionObject.
         * @param  
         */
        constructor(object: SessionObject): this;

        /**
         * Creates an instance of SessionObject.
         * @param  
         * @param  
         * @param  
         */
        constructor(handle: Handle, session: Session, lib: pkcs11.PKCS11): this;
        constructor(handle: SessionObject): this;

        /**
         * copies an object, creating a new object for the copy
         * @param  template for the new object
         * @returns  
         */
        copy(template: ITemplate): SessionObject;

        /**
         * destroys an object
         */
        destroy(): void;
        getAttribute(attr: string): ITemplate;
        getAttribute(attrs: ITemplate): ITemplate;
        setAttribute(attrs: string, value: any): void;
        setAttribute(attrs: ITemplate): void;
        get(name: string): any;
        set(name: string, value: any): void;
        toType<T>(): T
    }
    declare class SessionObjectCollection mixins Collection<SessionObject>{
        session: Session;
        constructor(items: Array<Handle>, session: Session, lib: pkcs11.PKCS11, classType?: any): this;
        items(index: number): SessionObject
    }
    declare class Storage mixins SessionObject {

        /**
         * `true` if object is a token object;
         * `false` if object is a session object. Default is `false`.
         */
        token: boolean;

        /**
         * `true` if object is a private object;
         * `false` if object is a public object.
        Default value is token-specific, and may depend on the values of other attributes of the object.
        */
        private: boolean;

        /**
         * `true` if object can be modified. Default is `false`
         */
        modifiable: boolean;

        /**
         * Description of the object (default empty)
         */
        label: string
    }

    /**
     * Data objects (object class `CKO_DATA`) hold information defined by an application.
     * Other than providing access to it, Cryptoki does not attach any special meaning to a data object
     * @export  * 
     * @class  Data
     * @extends  {Storage}
     */
    declare class Data mixins Storage {

        /**
         * Description of the application that manages the object (default empty)
         * @type  
         */
        application: string;

        /**
         * DER-encoding of the object identifier indicating the data object type (default empty)
         * @type  
         */
        objectId: Buffer;

        /**
         * Value of the object (default empty)
         * @type  
         */
        value: Buffer
    }
    declare class DomainParameters mixins Storage {

        /**
         * Type of key the domain parameters can be used to generate.
         */
        keyType: KeyType;

        /**
         * `CK_TRUE` only if domain parameters were either  generated locally (i.e., on the token)
         * with a `C_GenerateKey`  created with a `C_CopyObject` call as a copy of domain parameters
        which had its `CKA_LOCAL` attribute set to `CK_TRUE`
        */
        local: boolean
    }

    /**
     * Definition for the base key object class
     * - defines the object class `CKO_PUBLIC_KEY`, `CKO_PRIVATE_KEY` and `CKO_SECRET_KEY` for type `CK_OBJECT_CLASS`
    as used in the `CKA_CLASS` attribute of objects
    */
    declare class Key mixins Storage {

        /**
         * Type of key
         * - Must be specified when object is created with `C_CreateObject`
        - Must be specified when object is unwrapped with `C_UnwrapKey`
        */
        type: KeyType;

        /**
         * Key identifier for key (default empty)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification
        of the attribute during the course of a `C_CopyObject` call.
        */
        id: Buffer;

        /**
         * Start date for the key (default empty)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification
        of the attribute during the course of a `C_CopyObject` call.
        */
        startDate: Date;

        /**
         * End date for the key (default empty)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification
        of the attribute during the course of a `C_CopyObject` call.
        */
        endDate: Date;

        /**
         * `CK_TRUE` if key supports key derivation
         * (i.e., if other keys can be derived from this one (default `CK_FALSE`)
        - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification
        of the attribute during the course of a `C_CopyObject` call.
         * @returns  boolean
        */
        derive: boolean;

        /**
         * `CK_TRUE` only if key was either  generated locally (i.e., on the token)
         * with a `C_GenerateKey` or `C_GenerateKeyPair` call  created with a `C_CopyObject` call
        as a copy of a key which had its `CKA_LOCAL` attribute set to `CK_TRUE`
        - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        local: boolean;

        /**
         * Identifier of the mechanism used to generate the key material.
         * - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        mechanism: KeyGenMechanism;
        allowedMechanisms: void
    }

    /**
     * Private key objects (object class `CKO_PRIVATE_KEY`) hold private keys
     */
    declare class PrivateKey mixins Key {

        /**
         * DER-encoding of the key subject name (default empty)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        */
        subject: Buffer;

        /**
         * `CK_TRUE` if key is sensitive
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Attribute cannot be changed once set to CK_TRUE. It becomes a read only attribute.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        sensitive: boolean;

        /**
         * `CK_TRUE` if key supports decryption
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        decrypt: boolean;

        /**
         * `CK_TRUE` if key supports signatures where the signature is an appendix to the data
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        sign: boolean;

        /**
         * `CK_TRUE` if key supports signatures where the data can be recovered from the signature
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        signRecover: boolean;

        /**
         * `CK_TRUE` if key supports unwrapping (i.e., can be used to unwrap other keys)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        unwrap: boolean;

        /**
         * `CK_TRUE` if key is extractable and can be wrapped
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Attribute cannot be changed once set to `CK_FALSE`. It becomes a read only attribute.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        extractable: boolean;

        /**
         * `CK_TRUE` if key has always had the `CKA_SENSITIVE` attribute set to `CK_TRUE`
         * - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        alwaysSensitive: boolean;

        /**
         * `CK_TRUE` if key has never had the `CKA_EXTRACTABLE` attribute set to `CK_TRUE`
         * - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        neverExtractable: boolean;

        /**
         * `CK_TRUE` if the key can only be wrapped with a wrapping key
         * that has `CKA_TRUSTED` set to `CK_TRUE`. Default is `CK_FALSE`.
        - Attribute cannot be changed once set to `CK_TRUE`. It becomes a read only attribute.
        */
        wrapTrusted: boolean;

        /**
         * For wrapping keys. The attribute template to apply to any keys unwrapped
         * using this wrapping key. Any user supplied template is applied after this template
        as if the object has already been created.
        */
        template: void;
        alwaysAuthenticate: boolean
    }

    /**
     * Public key objects (object class CKO_PUBLIC_KEY) hold public keys
     */
    declare class PublicKey mixins Key {

        /**
         * DER-encoding of the key subject name (default empty)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        */
        subject: Buffer;

        /**
         * `CK_TRUE` if key supports encryption
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        encrypt: boolean;

        /**
         * `CK_TRUE` if key supports verification where the signature is an appendix to the data
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        verify: boolean;

        /**
         * `CK_TRUE` if key supports verification where the data is recovered from the signature
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        verifyRecover: boolean;

        /**
         * `CK_TRUE` if key supports wrapping (i.e., can be used to wrap other keys)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        wrap: boolean;

        /**
         * The key can be trusted for the application that it was created.
         * - The wrapping key can be used to wrap keys with `CKA_WRAP_WITH_TRUSTED` set to `CK_TRUE`.
        - Can only be set to CK_TRUE by the SO user.
        */
        trusted: boolean;

        /**
         * For wrapping keys. The attribute template to match against any keys wrapped using this wrapping key.
         * Keys that do not match cannot be wrapped.
         */
        template: void
    }

    /**
     * Secret key objects (object class `CKO_SECRET_KEY`) hold secret keys.
     */
    declare class SecretKey mixins Key {

        /**
         * `CK_TRUE` if key is sensitive
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Attribute cannot be changed once set to `CK_TRUE`. It becomes a read only attribute.
        */
        sensitive: boolean;

        /**
         * `CK_TRUE` if key supports encryption
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        encrypt: boolean;

        /**
         * `CK_TRUE` if key supports decryption
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        decrypt: boolean;

        /**
         * `CK_TRUE` if key supports verification (i.e., of authentication codes) where the signature is an appendix to the data
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        verify: boolean;

        /**
         * `CK_TRUE` if key supports signatures (i.e., authentication codes) where the signature is an appendix to the data
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        sign: boolean;

        /**
         * `CK_TRUE` if key supports wrapping (i.e., can be used to wrap other keys)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        wrap: boolean;

        /**
         * `CK_TRUE` if key supports unwrapping (i.e., can be used to unwrap other keys)
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        unwrap: boolean;

        /**
         * `CK_TRUE` if key is extractable and can be wrapped
         * - May be modified after object is created with a `C_SetAttributeValue` call,
        or in the process of copying object with a `C_CopyObject` call.
        However, it is possible that a particular token may not permit modification of the attribute
        during the course of a `C_CopyObject` call.
        - Attribute cannot be changed once set to `CK_FALSE`. It becomes a read only attribute.
        - Default value is token-specific, and may depend on the values of other attributes.
        */
        extractable: boolean;

        /**
         * `CK_TRUE` if key has always had the `CKA_SENSITIVE` attribute set to `CK_TRUE`
         * - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        alwaysSensitive: boolean;

        /**
         * `CK_TRUE` if key has never had the `CKA_EXTRACTABLE` attribute set to `CK_TRUE`
         * - Must not be specified when object is created with `C_CreateObject`.
        - Must not be specified when object is generated with `C_GenerateKey` or `C_GenerateKeyPair`.
        - Must not be specified when object is unwrapped with `C_UnwrapKey`.
        */
        neverExtractable: boolean;

        /**
         * Key checksum
         */
        checkValue: Buffer;

        /**
         * `CK_TRUE` if the key can only be wrapped with a wrapping key
         * that has `CKA_TRUSTED` set to `CK_TRUE`. Default is `CK_FALSE`.
        - Attribute cannot be changed once set to `CK_TRUE`. It becomes a read only attribute.
        */
        wrapTrusted: boolean;

        /**
         * The wrapping key can be used to wrap keys with `CKA_WRAP_WITH_TRUSTED` set to `CK_TRUE`.
         * - Can only be set to CK_TRUE by the SO user.
         */
        trusted: boolean;

        /**
         * For wrapping keys.
         * The attribute template to match against any keys wrapped using this wrapping key.
        Keys that do not match cannot be wrapped.
        */
        wrapTemplate: void;

        /**
         * For wrapping keys.
         * The attribute template to apply to any keys unwrapped using this wrapping key.
        Any user supplied template is applied after this template as if the object has already been created.
        */
        unwrapTemplate: void
    }

    /**
     * Certificate objects (object class CKO_CERTIFICATE) hold public-key or attribute certificates
     */
    declare class Certificate mixins Storage {

        /**
         * Type of certificate
         */
        type: CertificateType;

        /**
         * The certificate can be trusted for the application that it was created.
         */
        trusted: boolean;

        /**
         * Categorization of the certificate
         */
        category: CertificateCategory;

        /**
         * Checksum
         */
        checkValue: Buffer;

        /**
         * Start date for the certificate (default empty)
         */
        startDate: Date;

        /**
         * End date for the certificate (default empty)
         */
        endDate: Date
    }

    /**
     * X.509 attribute certificate objects (certificate type `CKC_X_509_ATTR_CERT`) hold X.509 attribute certificates
     */
    declare class AttributeCertificate mixins Certificate {

        /**
         * DER-encoding of the attribute certificate's subject field.
         * This is distinct from the `CKA_SUBJECT` attribute contained in `CKC_X_509` certificates
        because the `ASN.1` syntax and encoding are different.
        - Must be specified when the object is created
        */
        owner: Buffer;

        /**
         * DER-encoding of the attribute certificate's issuer field.
         * This is distinct from the `CKA_ISSUER` attribute contained in `CKC_X_509` certificates
        because the ASN.1 syntax and encoding are different. (default empty)
        */
        issuer: Buffer;

        /**
         * DER-encoding of the certificate serial number (default empty)
         */
        serialNumber: Buffer;

        /**
         * BER-encoding of a sequence of object identifier values corresponding
         * to the attribute types contained in the certificate.
        When present, this field offers an opportunity for applications
        to search for a particular attribute certificate without fetching
        and parsing the certificate itself. (default empty)
        */
        types: Buffer;

        /**
         * BER-encoding of the certificate
         * - Must be specified when the object is created.
         */
        value: Buffer
    }

    /**
     * WTLS certificate objects (certificate type `CKC_WTLS`) hold WTLS public key certificates
     */
    declare class WtlsCertificate mixins Certificate {

        /**
         * WTLS-encoding (Identifier type) of the certificate subject
         * - Must be specified when the object is created.
        - Can only be empty if `CKA_VALUE` is empty.
        */
        subject: Buffer;

        /**
         * WTLS-encoding (Identifier type) of the certificate issuer (default empty)
         */
        issuer: Buffer;

        /**
         * Key identifier for public/private key pair (default empty)
         */
        id: Buffer;

        /**
         * WTLS-encoding of the certificate
         * - Must be specified when the object is created.
        - Must be non-empty if `CKA_URL` is empty.
        */
        value: Buffer;

        /**
         * If not empty this attribute gives the URL where the complete certificate
         * can be obtained (default empty)
        - Must be non-empty if `CKA_VALUE` is empty
        */
        url: string;

        /**
         * DER-encoding of the certificate serial number (default empty)
         */
        serialNumber: Buffer;

        /**
         * SHA-1 hash of the subject public key (default empty)
         * - Can only be empty if `CKA_URL` is empty.
         */
        subjetcKeyIdentifier: Buffer;

        /**
         * SHA-1 hash of the issuer public key (default empty)
         * - Can only be empty if `CKA_URL` is empty.
         */
        authorityKeyIdentifier: Buffer
    }

    /**
     * X.509 certificate objects (certificate type `CKC_X_509`) hold X.509 public key certificates
     */
    declare class X509Certificate mixins Certificate {

        /**
         * DER-encoding of the certificate subject name
         * - Must be specified when the object is created.
        - Must be non-empty if `CKA_URL` is empty.
        */
        subject: Buffer;

        /**
         * Key identifier for public/private key pair (default empty)
         */
        id: Buffer;

        /**
         * DER-encoding of the certificate issuer name (default empty)
         */
        issuer: Buffer;

        /**
         * HEX-encoding of the certificate serial number (default empty)
         */
        serialNumber: string;

        /**
         * BER-encoding of the certificate
         * - Must be specified when the object is created.
        - Must be non-empty if `CKA_URL` is empty.
        */
        value: Buffer;

        /**
         * If not empty this attribute gives the URL where the complete certificate
         * can be obtained (default empty)
        - Must be non-empty if `CKA_VALUE` is empty
        */
        url: string;

        /**
         * SHA-1 hash of the subject public key (default empty)
         * - Can only be empty if `CKA_URL` is empty.
         */
        subjetcKeyIdentifier: Buffer;

        /**
         * SHA-1 hash of the issuer public key (default empty)
         * - Can only be empty if `CKA_URL` is empty.
         */
        authorityKeyIdentifier: Buffer;

        /**
         * Java MIDP security domain
         */
        java: JavaMIDP
    }
    declare interface IAlgorithm {
        name: string,
            params: Buffer | IParams
    }
    declare type MechanismType = MechanismEnum | KeyGenMechanism | IAlgorithm | string;
    declare class Mechanism mixins BaseObject {
        handle: number;
        slotHandle: Handle;

        /**
         * the minimum size of the key for the mechanism
         * _whether this is measured in bits or in bytes is mechanism-dependent_
         */
        minKeySize: number;

        /**
         * the maximum size of the key for the mechanism
         * _whether this is measured in bits or in bytes is mechanism-dependent_
         */
        maxKeySize: number;

        /**
         * bit flag specifying mechanism capabilities
         */
        flags: number;

        /**
         * returns string name from MechanismEnum
         */
        name: string;
        constructor(handle: number, slotHandle: Handle, lib: pkcs11.PKCS11): this;
        getInfo(): void;
        create(alg: MechanismType): pkcs11.Mechanism;
        vendor(jsonFile: string): void;
        vendor(name: string, value: number): void
    }
    declare class MechanismCollection mixins Collection<Mechanism>{
        slotHandle: Handle;
        constructor(items: Array<number>, slotHandle: Handle, lib: pkcs11.PKCS11, classType?: typeof Mechanism): this;

        /**
         * returns item from collection by index
         * @param  of element in collection `[0..n]`
         */
        items(index: number): Mechanism
    }
    declare interface IKeyPair {
        privateKey: PrivateKey,
            publicKey: PublicKey
    }

    /**
     * provides information about a session
     * @export  * 
     * @class  Session
     * @extends  {core.HandleObject}
     */
    declare class Session mixins HandleObject {
        constructor(handle: Handle, slot: Slot, lib: pkcs11.PKCS11): this;

        /**
         * Slot
         * @type  
         */
        slot: Slot;

        /**
         * the state of the session
         * @type  
         */
        state: number;

        /**
         * bit flags that define the type of session
         * @type  
         */
        flags: number;

        /**
         * an error code defined by the cryptographic device. Used for errors not covered by Cryptoki
         * @type  
         */
        deviceError: number;
        getInfo(): void;

        /**
         * closes a session between an application and a token
         */
        close(): void;

        /**
         * initializes the normal user's PIN
         * @param  the normal user's PIN
         */
        initPin(pin: string): void;

        /**
         * modifies the PIN of the user who is logged in
         * @param  
         * @param  
         */
        setPin(oldPin: string, newPin: string): void;

        /**
         * obtains a copy of the cryptographic operations state of a session, encoded as a string of bytes
         */
        getOperationState(): Buffer;

        /**
         * restores the cryptographic operations state of a session
         * from a string of bytes obtained with getOperationState
         * @param  the saved state
         * @param  holds key which will be used for an ongoing encryption
        or decryption operation in the restored session
        (or 0 if no encryption or decryption key is needed,
        either because no such operation is ongoing in the stored session
        or because all the necessary key information is present in the saved state)
         * @param  holds a handle to the key which will be used for an ongoing signature,
        MACing, or verification operation in the restored session
        (or 0 if no such key is needed, either because no such operation is ongoing in the stored session
        or because all the necessary key information is present in the saved state)
        */
        setOperationState(state: Buffer, encryptionKey?: number, authenticationKey?: number): void;

        /**
         * logs a user into a token
         * @param  the user's PIN.
        - This standard allows PIN values to contain any valid `UTF8` character,
        but the token may impose subset restrictions
         * @param  the user type. Default is `USER`
        */
        login(pin: string, userType?: UserType): void;

        /**
         * logs a user out from a token
         */
        logout(): void;

        /**
         * creates a new object
         * - Only session objects can be created during a read-only session.
        - Only public objects can be created unless the normal user is logged in.
         * @param  the object's template
         * @returns  
        */
        create(template: ITemplate): SessionObject;

        /**
         * Copies an object, creating a new object for the copy
         * @param  the copied object
         * @param  template for new object
         * @returns  
         */
        copy(object: SessionObject, template: ITemplate): SessionObject;

        /**
         * removes all session objects matched to template
         * - if template is null, removes all session objects
        - returns a number of destroied session objects
         * @param  template
        */
        destroy(template: ITemplate): number;

        /**
         * 
         * @param  
         */
        destroy(object: SessionObject): number;
        destroy(): number;

        /**
         * removes all session objects
         * - returns a number of destroied session objects
         */
        clear(): number;

        /**
         * returns a collection of session objects mached to template
         * @param template template
         * @param callback optional callback function wich is called for each founded object
        - if callback function returns false, it breaks find function.
        */
        find(callback?: (obj: SessionObject) => any): SessionObjectCollection;
        find(
            template: ITemplate,
            callback?: (obj: SessionObject, index: number) => any): SessionObjectCollection;

        /**
         * Returns object from session by handle
         * @param  handle of object
         * @returns  T
         */
        getObject<T>(handle: Handle): T;

        /**
         * generates a secret key or set of domain parameters, creating a new object.
         * @param mechanism generation mechanism
         * @param template template for the new key or set of domain parameters
         */
        generateKey(mechanism: MechanismType, template?: ITemplate): SecretKey;
        generateKey(
            mechanism: MechanismType,
            template: ITemplate,
            callback: (err: Error, key: SecretKey) => void): void;
        generateKeyPair(
            mechanism: MechanismType,
            publicTemplate: ITemplate,
            privateTemplate: ITemplate): IKeyPair;
        generateKeyPair(
            mechanism: MechanismType,
            publicTemplate: ITemplate,
            privateTemplate: ITemplate,
            callback: (err: Error, keys: IKeyPair) => void): void;
        createSign(alg: MechanismType, key: Key): Sign;
        createVerify(alg: MechanismType, key: Key): Verify;
        createCipher(alg: MechanismType, key: Key): Cipher;
        createDecipher(alg: MechanismType, key: Key, blockSize?: number): Decipher;
        createDigest(alg: MechanismType): Digest;
        wrapKey(alg: MechanismType, wrappingKey: Key, key: Key): Buffer;
        wrapKey(
            alg: MechanismType,
            wrappingKey: Key,
            key: Key,
            callback: (err: Error, wkey: Buffer) => void): void;
        unwrapKey(
            alg: MechanismType,
            unwrappingKey: Key,
            wrappedKey: Buffer,
            template: ITemplate): Key;
        unwrapKey(
            alg: MechanismType,
            unwrappingKey: Key,
            wrappedKey: Buffer,
            template: ITemplate,
            callback: (err: Error, key: Key) => void): void;

        /**
         * derives a key from a base key, creating a new key object
         * @param  key deriv. mech
         * @param  base key
         * @param  new key template
         */
        deriveKey(alg: MechanismType, baseKey: Key, template: ITemplate): SecretKey;
        deriveKey(
            alg: MechanismType,
            baseKey: Key,
            template: ITemplate,
            callback: (err: Error, key: Key) => void): void;

        /**
         * generates random data
         * @param  \# of bytes to generate
         */
        generateRandom(size: number): Buffer
    }
    declare interface ITemplate {

        /**
         * CKA_CLASS
         */
        class?: number,

            /**
             * CKA_TOKEN
             */
            token?: boolean,

            /**
             * CKA_PRIVATE
             */
            private?: boolean,

            /**
             * CKA_LABEL
             */
            label?: string,

            /**
             * CKA_APPLICATION
             */
            application?: string,

            /**
             * CKA_VALUE
             */
            value?: Buffer,

            /**
             * CKA_OBJECT_ID
             */
            objectId?: Buffer,

            /**
             * CKA_CERTIFICATE_TYPE
             */
            certType?: number,

            /**
             * CKA_ISSUER
             */
            issuer?: Buffer,

            /**
             * CKA_SERIAL_NUMBER
             */
            serial?: Buffer,

            /**
             * CKA_AC_ISSUER
             */
            issuerAC?: Buffer,

            /**
             * CKA_OWNER
             */
            owner?: Buffer,

            /**
             * CKA_ATTR_TYPES
             */
            attrTypes?: Buffer,

            /**
             * CKA_TRUSTED
             */
            trusted?: boolean,

            /**
             * CKA_CERTIFICATE_CATEGORY
             */
            certCategory?: number,

            /**
             * CKA_JAVA_MIDP_SECURITY_DOMAIN
             */
            javaDomain?: number,

            /**
             * CKA_URL
             */
            url?: string,

            /**
             * CKA_HASH_OF_SUBJECT_PUBLIC_KEY
             */
            ski?: Buffer,

            /**
             * CKA_HASH_OF_ISSUER_PUBLIC_KEY
             */
            aki?: Buffer,

            /**
             * CKA_NAME_HASH_ALGORITHM
             */
            digestName?: number,

            /**
             * CKA_CHECK_VALUE
             */
            checkValue?: Buffer,

            /**
             * CKA_KEY_TYPE
             */
            keyType?: number,

            /**
             * CKA_SUBJECT
             */
            subject?: Buffer,

            /**
             * CKA_ID
             */
            id?: Buffer,

            /**
             * CKA_SENSITIVE
             */
            sensitive?: boolean,

            /**
             * CKA_ENCRYPT
             */
            encrypt?: boolean,

            /**
             * CKA_DECRYPT
             */
            decrypt?: boolean,

            /**
             * CKA_WRAP
             */
            wrap?: boolean,

            /**
             * CKA_UNWRAP
             */
            unwrap?: boolean,

            /**
             * CKA_SIGN
             */
            sign?: boolean,

            /**
             * CKA_SIGN_RECOVER
             */
            signRecover?: boolean,

            /**
             * CKA_VERIFY
             */
            verify?: boolean,

            /**
             * CKA_VERIFY_RECOVER
             */
            verifyRecover?: boolean,

            /**
             * CKA_DERIVE
             */
            derive?: boolean,

            /**
             * CKA_START_DATE
             */
            startDate?: Date,

            /**
             * CKA_END_DATE
             */
            endDate?: Date,

            /**
             * CKA_MODULUS
             */
            modulus?: Buffer,

            /**
             * CKA_MODULUS_BITS
             */
            modulusBits?: number,

            /**
             * CKA_PUBLIC_EXPONENT
             */
            publicExponent?: Buffer,

            /**
             * CKA_PRIVATE_EXPONEN
             */
            privateExponent?: Buffer,

            /**
             * CKA_PRIME_1
             */
            prime1?: Buffer,

            /**
             * CKA_PRIME_2
             */
            prime2?: Buffer,

            /**
             * CKA_EXPONENT_1
             */
            exp1?: Buffer,

            /**
             * CKA_EXPONENT_2
             */
            exp2?: Buffer,

            /**
             * CKA_COEFFICIEN
             */
            coefficient?: Buffer,

            /**
             * CKA_PRIME
             */
            prime?: Buffer,

            /**
             * CKA_SUBPRIME
             */
            subprime?: Buffer,

            /**
             * CKA_BASE
             */
            base?: Buffer,

            /**
             * CKA_PRIME_BITS
             */
            primeBits?: number,

            /**
             * CKA_SUBPRIME_BITS
             */
            subprimeBits?: number,

            /**
             * CKA_VALUE_BITS
             */
            valueBits?: number,

            /**
             * CKA_VALUE_LEN
             */
            valueLen?: number,

            /**
             * CKA_EXTRACTABLE
             */
            extractable?: boolean,

            /**
             * CKA_LOCAL
             */
            local?: boolean,

            /**
             * CKA_NEVER_EXTRACTABLE
             */
            neverExtractable?: boolean,

            /**
             * CKA_ALWAYS_SENSITIVE
             */
            alwaysSensitive?: boolean,

            /**
             * CKA_KEY_GEN_MECHANISM
             */
            keyGenMechanism?: number,

            /**
             * CKA_MODIFIABLE
             */
            modifiable?: boolean,

            /**
             * CKA_COPYABLE
             */
            copyable?: boolean,

            /**
             * CKA_ECDSA_PARAMS
             */
            paramsECDSA?: Buffer,
            paramsEC?: Buffer,

            /**
             * CKA_EC_POINT
             */
            pointEC?: Buffer,

            /**
             * CKA_SECONDARY_AUTH
             */
            secondaryAuth?: boolean,

            /**
             * CKA_AUTH_PIN_FLAGS
             */
            authPinFlags?: Buffer,

            /**
             * CKA_ALWAYS_AUTHENTICATE
             */
            alwaysAuth?: boolean,

            /**
             * CKA_WRAP_WITH_TRUSTED
             */
            wrapWithTrusted?: boolean,

            /**
             * CKA_WRAP_TEMPLATE
             */
            wrapTemplate?: any,

            /**
             * CKA_UNWRAP_TEMPLATE
             */
            unwrapTemplate?: any,

            /**
             * CKA_OTP_FORMAT
             */
            otpFormat?: any,

            /**
             * CKA_OTP_LENGTH
             */
            otpLength?: any,

            /**
             * CKA_OTP_TIME_INTERVAL
             */
            otpTimeInterval?: any,

            /**
             * CKA_OTP_USER_FRIENDLY_MODE
             */
            otpUserFriendlyMode?: any,

            /**
             * CKA_OTP_CHALLENGE_REQUIREMENT
             */
            otpChallengeReq?: any,

            /**
             * CKA_OTP_TIME_REQUIREMENT
             */
            otpTimeReq?: any,

            /**
             * CKA_OTP_COUNTER_REQUIREMENT
             */
            otpCounterReq?: any,

            /**
             * CKA_OTP_PIN_REQUIREMENT
             */
            otppinReq?: any,

            /**
             * CKA_OTP_COUNTER
             */
            otpCounter?: any,

            /**
             * CKA_OTP_TIME
             */
            otpTime?: any,

            /**
             * CKA_OTP_USER_IDENTIFIER
             */
            otpUserId?: any,

            /**
             * CKA_OTP_SERVICE_IDENTIFIER
             */
            otpServiceId?: any,

            /**
             * CKA_OTP_SERVICE_LOGO
             */
            otpServiceLogo?: any,

            /**
             * CKA_OTP_SERVICE_LOGO_TYPE
             */
            otpServiceLogoType?: any,

            /**
             * CKA_HW_FEATURE_TYPE
             */
            hwFeatureType?: any,

            /**
             * CKA_RESET_ON_INIT
             */
            resetOnInit?: any,

            /**
             * CKA_HAS_RESET
             */
            hasReset?: any,

            /**
             * CKA_PIXEL_X
             */
            pixelX?: any,

            /**
             * CKA_PIXEL_Y
             */
            pixelY?: any,

            /**
             * CKA_RESOLUTION
             */
            resolution?: any,

            /**
             * CKA_CHAR_ROWS
             */
            charRows?: any,

            /**
             * CKA_CHAR_COLUMNS
             */
            charCols?: any,

            /**
             * CKA_COLOR
             */
            color?: any,

            /**
             * CKA_BITS_PER_PIXEL
             */
            bitsPerPixel?: any,

            /**
             * CKA_CHAR_SETS
             */
            charSets?: any,

            /**
             * CKA_ENCODING_METHODS
             */
            encMethod?: any,

            /**
             * CKA_MIME_TYPES
             */
            mimeTypes?: any,

            /**
             * CKA_MECHANISM_TYPE
             */
            mechanismType?: any,

            /**
             * CKA_REQUIRED_CMS_ATTRIBUTES
             */
            requiredCmsAttrs?: any,

            /**
             * CKA_DEFAULT_CMS_ATTRIBUTES
             */
            defaultCmsAttrs?: any,

            /**
             * CKA_SUPPORTED_CMS_ATTRIBUTES
             */
            suportedCmsAttrs?: any,

            /**
             * CKA_ALLOWED_MECHANISMS
             */
            allowedMechanisms?: any
    }
    declare class Template {
        toPkcs11(tmpl: ITemplate): pkcs11.Attribute[];
        fromPkcs11(tmpl: pkcs11.Template): ITemplate
    }
    declare class Slot mixins HandleObject {
        slotDescription: string;
        manufacturerID: string;
        flags: number;
        hardwareVersion: pkcs11.Version;
        firmwareVersion: pkcs11.Version;
        module: Module;
        constructor(handle: Handle, module: Module, lib: pkcs11.PKCS11): this;

        /**
         * Recieve information about Slot
         * @protected  
         */
        getInfo(): void;

        /**
         * Returns information about token
         * @returns  
         */
        getToken(): Token;

        /**
         * returns list of `MechanismInfo`
         * @returns  
         */
        getMechanisms(): MechanismCollection;

        /**
         * initializes a token
         * @param  the SO's initial PIN
         * @returns  
         */
        initToken(pin: string): string;

        /**
         * opens a session between an application and a token in a particular slot
         * @param  indicates the type of session
         * @returns  
         */
        open(flags?: SessionFlag): Session;

        /**
         * closes all sessions an application has with a token
         */
        closeAll(): void
    }

    /**
     * Collection of slots
     * @export  * 
     * @class  SlotCollection
     * @extends  {core.Collection<Slot>}
     */
    declare class SlotCollection mixins Collection<Slot>{
        module: Module;
        items(index: number): Slot;
        constructor(items: Array<Buffer>, module: Module, lib: pkcs11.PKCS11, classType?: any): this
    }
    declare class Token mixins HandleObject {

        /**
         * application-defined label, assigned during token initialization.
         * - Must be padded with the blank character (' ').
        - Should __not__ be null-terminated.
        */
        label: string;

        /**
         * ID of the device manufacturer.
         * - Must be padded with the blank character (' ').
        - Should __not__ be null-terminated.
        */
        manufacturerID: string;

        /**
         * model of the device.
         * - Must be padded with the blank character (' ').
        - Should __not__ be null-terminated.
        */
        model: string;

        /**
         * character-string serial number of the device.
         * - Must be padded with the blank character (' ').
        - Should __not__ be null-terminated.
        */
        serialNumber: string;

        /**
         * bit flags indicating capabilities and status of the device
         */
        flags: number;

        /**
         * maximum number of sessions that can be opened with the token at one time by a single application
         */
        maxSessionCount: number;

        /**
         * number of sessions that this application currently has open with the token
         */
        sessionCount: number;

        /**
         * maximum number of read/write sessions that can be opened
         * with the token at one time by a single application
         */
        maxRwSessionCount: number;

        /**
         * number of read/write sessions that this application currently has open with the token
         */
        rwSessionCount: number;

        /**
         * maximum length in bytes of the PIN
         */
        maxPinLen: number;

        /**
         * minimum length in bytes of the PIN
         */
        minPinLen: number;

        /**
         * the total amount of memory on the token in bytes in which public objects may be stored
         */
        totalPublicMemory: number;

        /**
         * the amount of free (unused) memory on the token in bytes for public objects
         */
        freePublicMemory: number;

        /**
         * the total amount of memory on the token in bytes in which private objects may be stored
         */
        totalPrivateMemory: number;

        /**
         * the amount of free (unused) memory on the token in bytes for private objects
         */
        freePrivateMemory: number;

        /**
         * version number of hardware
         */
        hardwareVersion: pkcs11.Version;

        /**
         * version number of firmware
         */
        firmwareVersion: pkcs11.Version;

        /**
         * current time as a character-string of length 16,
         * represented in the format YYYYMMDDhhmmssxx
         */
        utcTime: Date;
        constructor(handle: Handle, lib: pkcs11.PKCS11): this;
        getInfo(): void
    }
    declare class Module mixins BaseObject {
        libFile: string;
        libName: string;

        /**
         * Cryptoki interface version
         */
        cryptokiVersion: pkcs11.Version;

        /**
         * blank padded manufacturer ID
         */
        manufacturerID: string;

        /**
         * must be zero
         */
        flags: number;

        /**
         * blank padded library description
         */
        libraryDescription: string;

        /**
         * version of library
         */
        libraryVersion: pkcs11.Version;
        constructor(lib: pkcs11.PKCS11): this;
        getInfo(): void;

        /**
         * initializes the Cryptoki library
         */
        initialize(): void;

        /**
         * indicates that an application is done with the Cryptoki library
         */
        finalize(): void;

        /**
         * obtains a list of slots in the system
         * @param  index of an element in collection
         * @param  only slots with tokens. Default `True`
         */
        getSlots(index: number, tokenPresent?: boolean): Slot;

        /**
         * 
         * @param  only slots with tokens. Default `True`
         */
        getSlots(tokenPresent?: boolean): SlotCollection;

        /**
         * loads pkcs11 lib
         * @param libFile path to PKCS11 library
         * @param libName name of PKCS11 library
         */
        load(libFile: string, libName?: string): Module
    }
}