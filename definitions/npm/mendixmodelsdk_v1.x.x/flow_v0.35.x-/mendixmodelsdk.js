/**
 * Flowtype definitions for mendixmodelsdk
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'mendixmodelsdk' {

    /**
     * Implementations of this interface are capable of placing a request with the Model API Server over HTTP.
     * Default implementation: {@link RestTransportation}.
     */
    declare interface transportation$ITransportation {

        /**
         * Fire off a HTTP request, with specified method, url, data, and success and failure callbacks.
         */
        request<T>(
                method: string,
                url: string,
                data: Object,
                success: common$ICallback<T>,
                failure: common$IErrorCallback): any,
            requestMultipartBinaryFileUpload<T>(
                method: string,
                url: string,
                data: Object,
                filename: string,
                success: common$ICallback<T>,
                failure: common$IErrorCallback): any,
            requestFileDownload<T>(
                method: string,
                url: string,
                success: common$ICallback<T>,
                failure: common$IErrorCallback): any
    }


    /**
     * Default implementation of {@link ITransportation} that communicates with the Model API Server over
     * HTTP using Restler.
     */
    declare class RestTransportation mixins ITransportation {
        constructor(config: configuration$ISdkConfig): this;
        request<T>(
            method: string,
            url: string,
            data: Object,
            success: common$ICallback<T>,
            failure: common$IErrorCallback): void;
        requestMultipartBinaryFileUpload<T>(
            method: string,
            url: string,
            data: Object,
            filename: string,
            success: common$ICallback<T>,
            failure: common$IErrorCallback): void;
        requestFileDownload<T>(
            method: string,
            url: string,
            success: common$ICallback<T>,
            failure: common$IErrorCallback): void
    }

    /**
     * Representation of a point.
     */
    declare interface common$IPoint {
        x: number,
            y: number
    }


    /**
     * Representation of a size, e.g. of an entity box.
     */
    declare interface common$ISize {
        width: number,
            height: number
    }


    /**
     * Representation of an RGB color.
     */
    declare interface common$IColor {
        red: number,
            green: number,
            blue: number
    }


    /**
     * Unification of the {@link IPoint} and {@link ISize} types.
     */
    declare type common$IDimension = {} & common$IPoint & common$ISize



    /**
     * Callback interface returning nothing, not even an error.
     */
    declare interface common$IVoidCallback {
        (): void
    }


    /**
     * Callback interface returning an error at most.
     */
    declare interface common$IErrorCallback {
        (err: any): void
    }


    /**
     * Callback interface returning data of some type `T`.
     */
    declare interface common$ICallback<T>{
        (data: T): void
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type projects$IProject = {
        load(): projects$Project,
        load(callback: (element: projects$Project) => void): any,
        projectDocuments: instances$IList<security$IProjectDocument>,
        modules: instances$IList<projects$IModule>,
        projectConversion: projects$IProjectConversion,
        isSystemProject: boolean
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare class Project mixins units$StructuralUnit, IProject {
        typeName: string;
        projectDocuments: instances$IList<security$ProjectDocument>;
        modules: instances$IList<projects$Module>;
        projectConversion: projects$ProjectConversion;
        isSystemProject: boolean;
        constructor(container: units$IStructuralUnit): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type projects$IProjectDocument = {
        container: projects$IProject,
        load(): security$ProjectDocument,
        load(callback: (element: security$ProjectDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectDocument mixins units$ModelUnit, IProjectDocument {
        typeName: string;
        container: projects$Project;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type projects$IFolderBase = {
        load(): projects$FolderBase,
        load(callback: (element: projects$FolderBase) => void): any,
        folders: instances$IList<projects$IFolder>,
        documents: instances$IList<enumerations$IDocument >
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class FolderBase mixins units$StructuralUnit, IFolderBase {
        typeName: string;
        folders: instances$IList<projects$Folder>;
        documents: instances$IList<enumerations$Document>;
        constructor(container: units$IStructuralUnit): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/howto50/Add+documents+to+a+module relevant section in reference guide}
     */
    declare type projects$IFolder = {
        container: projects$IFolderBase,
        load(): projects$Folder,
        load(callback: (element: projects$Folder) => void): any,
        name: string
    } & projects$IFolderBase



    /**
     * See: {@link https://world.mendix.com/display/howto50/Add+documents+to+a+module relevant section in reference guide}
     */
    declare class Folder mixins FolderBase, IFolder {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Modules relevant section in reference guide}
     */
    declare type projects$IModule = {
        container: projects$IProject,
        load(): projects$Module,
        load(callback: (element: projects$Module) => void): any,
        sortIndex: number,
        name: string,
        domainModel: domainmodels$IDomainModel,
        moduleSecurity: security$IModuleSecurity,
        fromAppStore: boolean,
        appStoreGuid: string,
        appStoreVersionGuid: string,
        appStoreVersion: string
    } & projects$IFolderBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Modules relevant section in reference guide}
     */
    declare class Module mixins FolderBase, IModule {
        typeName: string;
        container: projects$Project;
        sortIndex: number;
        name: string;
        domainModel: domainmodels$DomainModel;
        moduleSecurity: security$ModuleSecurity;
        fromAppStore: boolean;
        appStoreGuid: string;
        appStoreVersionGuid: string;
        appStoreVersion: string;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type projects$IModuleDocument = {
        container: projects$IFolderBase,
        load(): enumerations$ModuleDocument,
        load(callback: (element: enumerations$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type projects$IDocument = {
        container: projects$IFolderBase,
        load(): enumerations$Document,
        load(callback: (element: enumerations$Document) => void): any,
        name: string
    } & projects$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type projects$IOneTimeConversionMarker = {
        container: projects$IProjectConversion,
        load(): projects$OneTimeConversionMarker,
        load(callback: (element: projects$OneTimeConversionMarker) => void): any
    }

    declare class OneTimeConversionMarker mixins elements$Element, IOneTimeConversionMarker {
        typeName: string;
        container: projects$ProjectConversion;
        name: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type projects$IProjectConversion = {
        container: projects$IProject,
        load(): projects$ProjectConversion,
        load(callback: (element: projects$ProjectConversion) => void): any
    }

    declare class ProjectConversion mixins units$ModelUnit, IProjectConversion {
        typeName: string;
        container: projects$Project;
        markers: instances$IList<projects$OneTimeConversionMarker>;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class ConversionState mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Start: projects$ConversionState;
        SetAppstoreModules: projects$ConversionState;
        UpdateAppstoreModules: projects$ConversionState;
        SolveModelerErrors: projects$ConversionState;
        FixJavaCode: projects$ConversionState;
        FixIntegrationJavaCode: projects$ConversionState;
        DeployToEclipse: projects$ConversionState;
        MigrateJavaLibs: projects$ConversionState;
        RemoveUnusedJars: projects$ConversionState;
        CopyRuntimeJars: projects$ConversionState;
        Finished: projects$ConversionState
    }

    declare class HashAlgorithmType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        BCrypt: projects$HashAlgorithmType;
        SSHA256: projects$HashAlgorithmType;
        SSHA: projects$HashAlgorithmType;
        SHA256: projects$HashAlgorithmType;
        SHA1: projects$HashAlgorithmType;
        MD5: projects$HashAlgorithmType
    }

    declare class SecurityLevel mixins instances$IEnum {
        qualifiedTsTypeName: string;
        CheckNothing: projects$SecurityLevel;
        CheckFormsAndMicroflows: projects$SecurityLevel;
        CheckEverything: projects$SecurityLevel
    }

    /**
     * TODO
     */
    declare type microflows$IMicroflowAction = {
        container: microflows$IActionActivity,
        load(): microflows$MicroflowAction,
        load(callback: (element: microflows$MicroflowAction) => void): any
    }


    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MicroflowAction mixins elements$Element, IMicroflowAction {
        typeName: string;
        container: microflows$ActionActivity;
        errorHandlingType: microflows$ErrorHandlingType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: Missing in ref guide ?
     */
    declare type microflows$IAppServiceCallAction = {
        container: microflows$IActionActivity,
        load(): microflows$AppServiceCallAction,
        load(callback: (element: microflows$AppServiceCallAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * TODO: Missing in ref guide ?
     */
    declare class AppServiceCallAction mixins MicroflowAction, IAppServiceCallAction {
        typeName: string;
        container: microflows$ActionActivity;
        appServiceAction: appservices$IAppServiceAction;
        appServiceActionQualifiedName: string;
        parameterMappings: instances$IList<microflows$AppServiceCallParameterMapping>;
        useVariable: boolean;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: Missing in ref guide ?
     */
    declare type microflows$IAppServiceCallParameterMapping = {
        container: microflows$IAppServiceCallAction,
        load(): microflows$AppServiceCallParameterMapping,
        load(callback: (element: microflows$AppServiceCallParameterMapping) => void): any
    }


    /**
     * TODO: Missing in ref guide ?
     */
    declare class AppServiceCallParameterMapping mixins elements$Element, IAppServiceCallParameterMapping {
        typeName: string;
        container: microflows$AppServiceCallAction;
        parameter: appservices$IAppServiceActionParameter;
        parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Call+Web+Service relevant section in reference guide}
     */
    declare type microflows$IWebServiceCallAction = {
        container: microflows$IActionActivity,
        load(): microflows$WebServiceCallAction,
        load(callback: (element: microflows$WebServiceCallAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Call+Web+Service relevant section in reference guide}
     */
    declare class WebServiceCallAction mixins MicroflowAction, IWebServiceCallAction {
        typeName: string;
        container: microflows$ActionActivity;
        importedWebService: webservices$IImportedWebService;
        importedWebServiceQualifiedName: string;
        serviceName: string;
        operationName: string;
        useRequestTimeOut: boolean;
        timeOut: number;
        sendNullValueChoice: microflows$NullValueOption;
        requestHeaderHandling: microflows$RequestHandling;
        requestBodyHandling: microflows$RequestHandling;
        resultHandling: microflows$ResultHandling;
        httpConfiguration: microflows$HttpConfiguration;
        isValidationRequired: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IRequestHandling = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$RequestHandling,
        load(callback: (element: microflows$RequestHandling) => void): any
    }


    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class RequestHandling mixins elements$Element, IRequestHandling {
        typeName: string;
        container: microflows$WebServiceCallAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * TODO
     */
    declare type microflows$IAdvancedRequestHandling = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$AdvancedRequestHandling,
        load(callback: (element: microflows$AdvancedRequestHandling) => void): any
    } & microflows$IRequestHandling



    /**
     * TODO
     */
    declare class AdvancedRequestHandling mixins RequestHandling, IAdvancedRequestHandling {
        typeName: string;
        container: microflows$WebServiceCallAction;
        parameterMappings: instances$IList<microflows$WebServiceOperationAdvancedParameterMapping>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IHttpConfiguration = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$HttpConfiguration,
        load(callback: (element: microflows$HttpConfiguration) => void): any
    }

    declare class HttpConfiguration mixins elements$Element, IHttpConfiguration {
        typeName: string;
        container: microflows$WebServiceCallAction;
        overrideLocation: boolean;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        customLocation: string;
        useAuthentication: boolean;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        httpAuthenticationUserName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        authenticationPassword: string;
        headerEntries: instances$IList<microflows$HttpHeaderEntry>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IHttpHeaderEntry = {
        container: microflows$IHttpConfiguration,
        load(): microflows$HttpHeaderEntry,
        load(callback: (element: microflows$HttpHeaderEntry) => void): any
    }


    /**
     * TODO
     */
    declare class HttpHeaderEntry mixins elements$Element, IHttpHeaderEntry {
        typeName: string;
        container: microflows$HttpConfiguration;
        key: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IImportMappingCall = {
        container: microflows$IResultHandling,
        load(): microflows$ImportMappingCall,
        load(callback: (element: microflows$ImportMappingCall) => void): any
    }


    /**
     * TODO
     */
    declare class ImportMappingCall mixins elements$Element, IImportMappingCall {
        typeName: string;
        container: microflows$ResultHandling;
        mapping: importmappings$IImportMapping;
        mappingQualifiedName: string;
        mappingArgumentVariableName: string;
        range: microflows$Range;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Import+XML relevant section in reference guide}
     */
    declare type microflows$IImportXmlAction = {
        container: microflows$IActionActivity,
        load(): microflows$ImportXmlAction,
        load(callback: (element: microflows$ImportXmlAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Import+XML relevant section in reference guide}
     */
    declare class ImportXmlAction mixins MicroflowAction, IImportXmlAction {
        typeName: string;
        container: microflows$ActionActivity;
        xmlDocumentVariableName: string;
        resultHandling: microflows$ResultHandling;
        isValidationRequired: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IResultHandling = {
        load(): microflows$ResultHandling,
        load(callback: (element: microflows$ResultHandling) => void): any
    }


    /**
     * TODO
     */
    declare class ResultHandling mixins elements$Element, IResultHandling {
        typeName: string;
        importMappingCall: microflows$ImportMappingCall;
        storeInVariable: boolean;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ICustomRequestHandling = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$CustomRequestHandling,
        load(callback: (element: microflows$CustomRequestHandling) => void): any
    } & microflows$IRequestHandling



    /**
     * TODO
     */
    declare class CustomRequestHandling mixins RequestHandling, ICustomRequestHandling {
        typeName: string;
        container: microflows$WebServiceCallAction;
        template: microflows$StringTemplate;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IMappingRequestHandling = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$MappingRequestHandling,
        load(callback: (element: microflows$MappingRequestHandling) => void): any
    } & microflows$IRequestHandling



    /**
     * TODO
     */
    declare class MappingRequestHandling mixins RequestHandling, IMappingRequestHandling {
        typeName: string;
        container: microflows$WebServiceCallAction;
        mapping: exportmappings$IExportMapping;
        mappingQualifiedName: string;
        mappingArgumentVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ISimpleRequestHandling = {
        container: microflows$IWebServiceCallAction,
        load(): microflows$SimpleRequestHandling,
        load(callback: (element: microflows$SimpleRequestHandling) => void): any
    } & microflows$IRequestHandling



    /**
     * TODO
     */
    declare class SimpleRequestHandling mixins RequestHandling, ISimpleRequestHandling {
        typeName: string;
        container: microflows$WebServiceCallAction;
        parameterMappings: instances$IList<microflows$WebServiceOperationSimpleParameterMapping>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+XML relevant section in reference guide}
     */
    declare type microflows$IExportXmlAction = {
        container: microflows$IActionActivity,
        load(): microflows$ExportXmlAction,
        load(callback: (element: microflows$ExportXmlAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+XML relevant section in reference guide}
     */
    declare class ExportXmlAction mixins MicroflowAction, IExportXmlAction {
        typeName: string;
        container: microflows$ActionActivity;
        mapping: exportmappings$IExportMapping;
        mappingQualifiedName: string;
        mappingArgumentVariableName: string;
        outputMethod: microflows$OutputMethod;
        isValidationRequired: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IOutputMethod = {
        container: microflows$IExportXmlAction,
        load(): microflows$OutputMethod,
        load(callback: (element: microflows$OutputMethod) => void): any
    }


    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class OutputMethod mixins elements$Element, IOutputMethod {
        typeName: string;
        container: microflows$ExportXmlAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * TODO
     */
    declare type microflows$IFileDocumentExport = {
        container: microflows$IExportXmlAction,
        load(): microflows$FileDocumentExport,
        load(callback: (element: microflows$FileDocumentExport) => void): any
    } & microflows$IOutputMethod



    /**
     * TODO
     */
    declare class FileDocumentExport mixins OutputMethod, IFileDocumentExport {
        typeName: string;
        container: microflows$ExportXmlAction;
        targetDocumentVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IVariableExport = {
        container: microflows$IExportXmlAction,
        load(): microflows$VariableExport,
        load(callback: (element: microflows$VariableExport) => void): any
    } & microflows$IOutputMethod



    /**
     * TODO
     */
    declare class VariableExport mixins OutputMethod, IVariableExport {
        typeName: string;
        container: microflows$ExportXmlAction;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IWebServiceOperationAdvancedParameterMapping = {
        container: microflows$IAdvancedRequestHandling,
        load(): microflows$WebServiceOperationAdvancedParameterMapping,
        load(
            callback: (element: microflows$WebServiceOperationAdvancedParameterMapping) => void): any
    }


    /**
     * TODO
     */
    declare class WebServiceOperationAdvancedParameterMapping mixins elements$Element, IWebServiceOperationAdvancedParameterMapping {
        typeName: string;
        container: microflows$AdvancedRequestHandling;
        isChecked: boolean;
        parameterName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        mapping: exportmappings$IExportMapping;
        mappingQualifiedName: string;
        mappingArgumentVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IWebServiceOperationSimpleParameterMapping = {
        container: microflows$ISimpleRequestHandling,
        load(): microflows$WebServiceOperationSimpleParameterMapping,
        load(
            callback: (element: microflows$WebServiceOperationSimpleParameterMapping) => void): any
    }


    /**
     * TODO
     */
    declare class WebServiceOperationSimpleParameterMapping mixins elements$Element, IWebServiceOperationSimpleParameterMapping {
        typeName: string;
        container: microflows$SimpleRequestHandling;
        isChecked: boolean;
        parameterName: string;

        /**
         * The value of this property is conceptually of type Mappings$ElementPath.
         */
        parameterPath: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Close+Form relevant section in reference guide}
     */
    declare type microflows$ICloseFormAction = {
        container: microflows$IActionActivity,
        load(): microflows$CloseFormAction,
        load(callback: (element: microflows$CloseFormAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Close+Form relevant section in reference guide}
     */
    declare class CloseFormAction mixins MicroflowAction, ICloseFormAction {
        typeName: string;
        container: microflows$ActionActivity;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Download+File relevant section in reference guide}
     */
    declare type microflows$IDownloadFileAction = {
        container: microflows$IActionActivity,
        load(): microflows$DownloadFileAction,
        load(callback: (element: microflows$DownloadFileAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Download+File relevant section in reference guide}
     */
    declare class DownloadFileAction mixins MicroflowAction, IDownloadFileAction {
        typeName: string;
        container: microflows$ActionActivity;
        fileDocumentVariableName: string;
        showFileInBrowser: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IDocumentTemplateParameterMapping = {
        container: microflows$IGenerateDocumentAction,
        load(): microflows$DocumentTemplateParameterMapping,
        load(callback: (element: microflows$DocumentTemplateParameterMapping) => void): any
    }

    declare class DocumentTemplateParameterMapping mixins elements$Element, IDocumentTemplateParameterMapping {
        typeName: string;
        container: microflows$GenerateDocumentAction;
        widgetName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Generate+Document relevant section in reference guide}
     */
    declare type microflows$IGenerateDocumentAction = {
        container: microflows$IActionActivity,
        load(): microflows$GenerateDocumentAction,
        load(callback: (element: microflows$GenerateDocumentAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Generate+Document relevant section in reference guide}
     */
    declare class GenerateDocumentAction mixins MicroflowAction, IGenerateDocumentAction {
        typeName: string;
        container: microflows$ActionActivity;
        parameterMappings: instances$IList<microflows$DocumentTemplateParameterMapping>;
        fileVariableName: string;
        languageVariableName: string;
        documentType: microflows$TargetDocumentType;
        languageSetting: microflows$LanguageSettingType;
        documentTemplate: documenttemplates$IDocumentTemplate;
        documentTemplateQualifiedName: string;
        overrideTopMargin: boolean;
        overrideBottomMargin: boolean;
        overrideLeftMargin: boolean;
        overrideRightMargin: boolean;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        marginLeftInInch: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        marginRightInInch: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        marginTopInInch: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        marginBottomInInch: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Home+Page TODO: Page does not exist, should be created.}
     */
    declare type microflows$IShowHomePageAction = {
        container: microflows$IActionActivity,
        load(): microflows$ShowHomePageAction,
        load(callback: (element: microflows$ShowHomePageAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Home+Page TODO: Page does not exist, should be created.}
     */
    declare class ShowHomePageAction mixins MicroflowAction, IShowHomePageAction {
        typeName: string;
        container: microflows$ActionActivity;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Message relevant section in reference guide}
     */
    declare type microflows$IShowMessageAction = {
        container: microflows$IActionActivity,
        load(): microflows$ShowMessageAction,
        load(callback: (element: microflows$ShowMessageAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Message relevant section in reference guide}
     */
    declare class ShowMessageAction mixins MicroflowAction, IShowMessageAction {
        typeName: string;
        container: microflows$ActionActivity;
        template: microflows$TextTemplate;
        type: microflows$ShowMessageType;
        blocking: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Page relevant section in reference guide}
     */
    declare type microflows$IShowPageAction = {
        container: microflows$IActionActivity,
        load(): microflows$ShowPageAction,
        load(callback: (element: microflows$ShowPageAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Show+Page relevant section in reference guide}
     */
    declare class ShowPageAction mixins MicroflowAction, IShowPageAction {
        typeName: string;
        container: microflows$ActionActivity;
        pageSettings: pages$PageSettings;
        passedObjectVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Validation+Feedback relevant section in reference guide}
     */
    declare type microflows$IValidationFeedbackAction = {
        container: microflows$IActionActivity,
        load(): microflows$ValidationFeedbackAction,
        load(callback: (element: microflows$ValidationFeedbackAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Validation+Feedback relevant section in reference guide}
     */
    declare class ValidationFeedbackAction mixins MicroflowAction, IValidationFeedbackAction {
        typeName: string;
        container: microflows$ActionActivity;
        feedbackTemplate: microflows$TextTemplate;
        objectVariableName: string;

        /**
         * See: {@link https://world.mendix.com/display/refguide5/Validation+Feedback See 'Member' section in reference guide}
         */
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;

        /**
         * See: {@link https://world.mendix.com/display/refguide5/Validation+Feedback See 'Member' section in reference guide}
         */
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: Abstract
     */
    declare type microflows$IMicroflowObject = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$MicroflowObject,
        load(callback: (element: microflows$MicroflowObject) => void): any
    }


    /**
     * TODO: Abstract
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MicroflowObject mixins elements$Element, IMicroflowObject {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        relativeMiddlePoint: common$IPoint;
        size: common$ISize;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: abstract element
     */
    declare type microflows$IActivity = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$Activity,
        load(callback: (element: microflows$Activity) => void): any
    } & microflows$IMicroflowObject



    /**
     * TODO: abstract element
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Activity mixins MicroflowObject, IActivity {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Activities relevant section in reference guide}
     */
    declare type microflows$IActionActivity = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$ActionActivity,
        load(callback: (element: microflows$ActionActivity) => void): any
    } & microflows$IActivity



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Activities relevant section in reference guide}
     */
    declare class ActionActivity mixins Activity, IActionActivity {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        action: microflows$MicroflowAction;
        caption: string;
        autoGenerateCaption: boolean;
        backgroundColor: microflows$ActionActivityColor;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Aggregate+List relevant section in reference guide}
     */
    declare type microflows$IAggregateListAction = {
        container: microflows$IActionActivity,
        load(): microflows$AggregateListAction,
        load(callback: (element: microflows$AggregateListAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Aggregate+List relevant section in reference guide}
     */
    declare class AggregateListAction mixins MicroflowAction, IAggregateListAction {
        typeName: string;
        container: microflows$ActionActivity;
        inputListVariableName: string;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        aggregateFunction: reports$AggregateFunctionEnum;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotation relevant section in reference guide}
     */
    declare type microflows$IAnnotation = {
        container: microflows$IMicroflowObjectCollection,
        load(): domainmodels$Annotation,
        load(callback: (element: domainmodels$Annotation) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotation relevant section in reference guide}
     */
    declare class Annotation mixins MicroflowObject, IAnnotation {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        caption: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO abstract
     */
    declare type microflows$IFlow = {
        container: microflows$IMicroflowBase,
        load(): microflows$Flow,
        load(callback: (element: microflows$Flow) => void): any
    }


    /**
     * TODO abstract
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Flow mixins elements$Element, IFlow {
        typeName: string;
        container: microflows$MicroflowBase;
        origin: microflows$MicroflowObject;
        destination: microflows$MicroflowObject;
        originConnectionIndex: number;
        destinationConnectionIndex: number;
        originBezierVector: common$ISize;
        destinationBezierVector: common$ISize;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotation+Flow relevant section in reference guide}
     */
    declare type microflows$IAnnotationFlow = {
        container: microflows$IMicroflowBase,
        load(): microflows$AnnotationFlow,
        load(callback: (element: microflows$AnnotationFlow) => void): any
    } & microflows$IFlow



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotation+Flow relevant section in reference guide}
     */
    declare class AnnotationFlow mixins Flow, IAnnotationFlow {
        typeName: string;
        container: microflows$MicroflowBase;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IRetrieveSource = {
        container: microflows$IRetrieveAction,
        load(): microflows$RetrieveSource,
        load(callback: (element: microflows$RetrieveSource) => void): any
    }


    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class RetrieveSource mixins elements$Element, IRetrieveSource {
        typeName: string;
        container: microflows$RetrieveAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IAssociationRetrieveSource = {
        container: microflows$IRetrieveAction,
        load(): microflows$AssociationRetrieveSource,
        load(callback: (element: microflows$AssociationRetrieveSource) => void): any
    } & microflows$IRetrieveSource



    /**
     * TODO
     */
    declare class AssociationRetrieveSource mixins RetrieveSource, IAssociationRetrieveSource {
        typeName: string;
        container: microflows$RetrieveAction;
        startVariableName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IListOperation = {
        container: microflows$IListOperationAction,
        load(): microflows$ListOperation,
        load(callback: (element: microflows$ListOperation) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ListOperation mixins elements$Element, IListOperation {
        typeName: string;
        container: microflows$ListOperationAction;
        listVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IBinaryListOperation = {
        container: microflows$IListOperationAction,
        load(): microflows$BinaryListOperation,
        load(callback: (element: microflows$BinaryListOperation) => void): any
    } & microflows$IListOperation



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class BinaryListOperation mixins ListOperation, IBinaryListOperation {
        typeName: string;
        container: microflows$ListOperationAction;
        secondListOrObjectName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Break+Event relevant section in reference guide}
     */
    declare type microflows$IBreakEvent = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$BreakEvent,
        load(callback: (element: microflows$BreakEvent) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Break+Event relevant section in reference guide}
     */
    declare class BreakEvent mixins MicroflowObject, IBreakEvent {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ICaseValue = {
        container: microflows$ISequenceFlow,
        load(): microflows$CaseValue,
        load(callback: (element: microflows$CaseValue) => void): any
    }


    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class CaseValue mixins elements$Element, ICaseValue {
        typeName: string;
        container: microflows$SequenceFlow;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cast+Object relevant section in reference guide}
     */
    declare type microflows$ICastAction = {
        container: microflows$IActionActivity,
        load(): microflows$CastAction,
        load(callback: (element: microflows$CastAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cast+Object relevant section in reference guide}
     */
    declare class CastAction mixins MicroflowAction, ICastAction {
        typeName: string;
        container: microflows$ActionActivity;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IChangeMembersAction = {
        container: microflows$IActionActivity,
        load(): microflows$ChangeMembersAction,
        load(callback: (element: microflows$ChangeMembersAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * TODO
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ChangeMembersAction mixins MicroflowAction, IChangeMembersAction {
        typeName: string;
        container: microflows$ActionActivity;
        items: instances$IList<microflows$MemberChange>;
        refreshInClient: boolean;
        commit: microflows$CommitEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+Object relevant section in reference guide}
     */
    declare type microflows$IChangeObjectAction = {
        container: microflows$IActionActivity,
        load(): microflows$ChangeObjectAction,
        load(callback: (element: microflows$ChangeObjectAction) => void): any
    } & microflows$IChangeMembersAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+Object relevant section in reference guide}
     */
    declare class ChangeObjectAction mixins ChangeMembersAction, IChangeObjectAction {
        typeName: string;
        container: microflows$ActionActivity;
        changeVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IMemberChange = {
        container: microflows$IChangeMembersAction,
        load(): microflows$MemberChange,
        load(callback: (element: microflows$MemberChange) => void): any
    }


    /**
     * TODO
     */
    declare class MemberChange mixins elements$Element, IMemberChange {
        typeName: string;
        container: microflows$ChangeMembersAction;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        type: microflows$ChangeActionItemType;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+List relevant section in reference guide}
     */
    declare type microflows$IChangeListAction = {
        container: microflows$IActionActivity,
        load(): microflows$ChangeListAction,
        load(callback: (element: microflows$ChangeListAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+List relevant section in reference guide}
     */
    declare class ChangeListAction mixins MicroflowAction, IChangeListAction {
        typeName: string;
        container: microflows$ActionActivity;
        changeVariableName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        value: string;
        type: microflows$ChangeListActionType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+Variable relevant section in reference guide}
     */
    declare type microflows$IChangeVariableAction = {
        container: microflows$IActionActivity,
        load(): microflows$ChangeVariableAction,
        load(callback: (element: microflows$ChangeVariableAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Change+Variable relevant section in reference guide}
     */
    declare class ChangeVariableAction mixins MicroflowAction, IChangeVariableAction {
        typeName: string;
        container: microflows$ActionActivity;
        changeVariableName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Commit+Object(s) relevant section in reference guide}
     */
    declare type microflows$ICommitAction = {
        container: microflows$IActionActivity,
        load(): microflows$CommitAction,
        load(callback: (element: microflows$CommitAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Commit+Object(s) relevant section in reference guide}
     */
    declare class CommitAction mixins MicroflowAction, ICommitAction {
        typeName: string;
        container: microflows$ActionActivity;
        withEvents: boolean;
        commitVariableName: string;
        refreshInClient: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    declare type microflows$IRange = {
        load(): microflows$Range,
        load(callback: (element: microflows$Range) => void): any
    }


    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Range mixins elements$Element, IRange {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    declare type microflows$IConstantRange = {
        load(): microflows$ConstantRange,
        load(callback: (element: microflows$ConstantRange) => void): any
    } & microflows$IRange



    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    declare class ConstantRange mixins Range, IConstantRange {
        typeName: string;
        singleObject: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IContains = {
        container: microflows$IListOperationAction,
        load(): microflows$Contains,
        load(callback: (element: microflows$Contains) => void): any
    } & microflows$IBinaryListOperation


    declare class Contains mixins BinaryListOperation, IContains {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Continue+Event relevant section in reference guide}
     */
    declare type microflows$IContinueEvent = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$ContinueEvent,
        load(callback: (element: microflows$ContinueEvent) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Continue+Event relevant section in reference guide}
     */
    declare class ContinueEvent mixins MicroflowObject, IContinueEvent {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Persistent+Create+Object relevant section in reference guide}
     */
    declare type microflows$IDeprecatedCreateAction = {
        container: microflows$IActionActivity,
        load(): microflows$DeprecatedCreateAction,
        load(callback: (element: microflows$DeprecatedCreateAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Persistent+Create+Object relevant section in reference guide}
     */
    declare class DeprecatedCreateAction mixins MicroflowAction, IDeprecatedCreateAction {
        typeName: string;
        container: microflows$ActionActivity;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        refreshInClient: boolean;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+Object relevant section in reference guide}
     */
    declare type microflows$ICreateObjectAction = {
        container: microflows$IActionActivity,
        load(): microflows$CreateObjectAction,
        load(callback: (element: microflows$CreateObjectAction) => void): any
    } & microflows$IChangeMembersAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+Object relevant section in reference guide}
     */
    declare class CreateObjectAction mixins ChangeMembersAction, ICreateObjectAction {
        typeName: string;
        container: microflows$ActionActivity;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+List relevant section in reference guide}
     */
    declare type microflows$ICreateListAction = {
        container: microflows$IActionActivity,
        load(): microflows$CreateListAction,
        load(callback: (element: microflows$CreateListAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+List relevant section in reference guide}
     */
    declare class CreateListAction mixins MicroflowAction, ICreateListAction {
        typeName: string;
        container: microflows$ActionActivity;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+Variable relevant section in reference guide}
     */
    declare type microflows$ICreateVariableAction = {
        container: microflows$IActionActivity,
        load(): microflows$CreateVariableAction,
        load(callback: (element: microflows$CreateVariableAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Create+Variable relevant section in reference guide}
     */
    declare class CreateVariableAction mixins MicroflowAction, ICreateVariableAction {
        typeName: string;
        container: microflows$ActionActivity;
        variableName: string;

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        variableDataType: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        initialValue: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    declare type microflows$ICustomRange = {
        load(): microflows$CustomRange,
        load(callback: (element: microflows$CustomRange) => void): any
    } & microflows$IRange



    /**
     * TODO: also described in ImporrtXmlAction and CallWebServiceAction
     */
    declare class CustomRange mixins Range, ICustomRange {
        typeName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        limitExpression: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        offsetExpression: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IDatabaseRetrieveSource = {
        container: microflows$IRetrieveAction,
        load(): microflows$DatabaseRetrieveSource,
        load(callback: (element: microflows$DatabaseRetrieveSource) => void): any
    } & microflows$IRetrieveSource



    /**
     * TODO
     */
    declare class DatabaseRetrieveSource mixins RetrieveSource, IDatabaseRetrieveSource {
        typeName: string;
        container: microflows$RetrieveAction;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        range: microflows$Range;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        sortItemList: microflows$SortItemList;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Delete+Object(s) relevant section in reference guide}
     */
    declare type microflows$IDeleteAction = {
        container: microflows$IActionActivity,
        load(): microflows$DeleteAction,
        load(callback: (element: microflows$DeleteAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Delete+Object(s) relevant section in reference guide}
     */
    declare class DeleteAction mixins MicroflowAction, IDeleteAction {
        typeName: string;
        container: microflows$ActionActivity;
        deleteVariableName: string;
        refreshInClient: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/End+Event relevant section in reference guide}
     */
    declare type microflows$IEndEvent = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$EndEvent,
        load(callback: (element: microflows$EndEvent) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/End+Event relevant section in reference guide}
     */
    declare class EndEvent mixins MicroflowObject, IEndEvent {
        typeName: string;
        container: microflows$MicroflowObjectCollection;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        returnValue: string;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IEnumerationCase = {
        container: microflows$ISequenceFlow,
        load(): microflows$EnumerationCase,
        load(callback: (element: microflows$EnumerationCase) => void): any
    } & microflows$ICaseValue



    /**
     * TODO
     */
    declare class EnumerationCase mixins CaseValue, IEnumerationCase {
        typeName: string;
        container: microflows$SequenceFlow;
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IListEquals = {
        container: microflows$IListOperationAction,
        load(): microflows$ListEquals,
        load(callback: (element: microflows$ListEquals) => void): any
    } & microflows$IBinaryListOperation


    declare class ListEquals mixins BinaryListOperation, IListEquals {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Error+Event relevant section in reference guide}
     */
    declare type microflows$IErrorEvent = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$ErrorEvent,
        load(callback: (element: microflows$ErrorEvent) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Error+Event relevant section in reference guide}
     */
    declare class ErrorEvent mixins MicroflowObject, IErrorEvent {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Merge relevant section in reference guide}
     */
    declare type microflows$IExclusiveMerge = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$ExclusiveMerge,
        load(callback: (element: microflows$ExclusiveMerge) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Merge relevant section in reference guide}
     */
    declare class ExclusiveMerge mixins MicroflowObject, IExclusiveMerge {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Exclusive+Split relevant section in reference guide}
     */
    declare type microflows$IExclusiveSplit = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$ExclusiveSplit,
        load(callback: (element: microflows$ExclusiveSplit) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Exclusive+Split relevant section in reference guide}
     */
    declare class ExclusiveSplit mixins MicroflowObject, IExclusiveSplit {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        splitCondition: microflows$SplitCondition;
        caption: string;
        errorHandlingType: microflows$ErrorHandlingType;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO : Abstract
     */
    declare type microflows$ISplitCondition = {
        container: microflows$IExclusiveSplit,
        load(): microflows$SplitCondition,
        load(callback: (element: microflows$SplitCondition) => void): any
    }


    /**
     * TODO : Abstract
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class SplitCondition mixins elements$Element, ISplitCondition {
        typeName: string;
        container: microflows$ExclusiveSplit;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type microflows$IExpressionSplitCondition = {
        container: microflows$IExclusiveSplit,
        load(): microflows$ExpressionSplitCondition,
        load(callback: (element: microflows$ExpressionSplitCondition) => void): any
    } & microflows$ISplitCondition


    declare class ExpressionSplitCondition mixins SplitCondition, IExpressionSplitCondition {
        typeName: string;
        container: microflows$ExclusiveSplit;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        expression: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IInspectAttribute = {
        container: microflows$IListOperationAction,
        load(): microflows$InspectAttribute,
        load(callback: (element: microflows$InspectAttribute) => void): any
    } & microflows$IListOperation



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class InspectAttribute mixins ListOperation, IInspectAttribute {
        typeName: string;
        container: microflows$ListOperationAction;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        expression: string;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IFilter = {
        container: microflows$IListOperationAction,
        load(): microflows$Filter,
        load(callback: (element: microflows$Filter) => void): any
    } & microflows$IInspectAttribute


    declare class Filter mixins InspectAttribute, IFilter {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IFind = {
        container: microflows$IListOperationAction,
        load(): microflows$Find,
        load(callback: (element: microflows$Find) => void): any
    } & microflows$IInspectAttribute


    declare class Find mixins InspectAttribute, IFind {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IHead = {
        container: microflows$IListOperationAction,
        load(): microflows$Head,
        load(callback: (element: microflows$Head) => void): any
    } & microflows$IListOperation


    declare class Head mixins ListOperation, IHead {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IInheritanceCase = {
        container: microflows$ISequenceFlow,
        load(): microflows$InheritanceCase,
        load(callback: (element: microflows$InheritanceCase) => void): any
    } & microflows$ICaseValue



    /**
     * TODO
     */
    declare class InheritanceCase mixins CaseValue, IInheritanceCase {
        typeName: string;
        container: microflows$SequenceFlow;
        value: domainmodels$IEntity;
        valueQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Inheritance+Split relevant section in reference guide}
     */
    declare type microflows$IInheritanceSplit = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$InheritanceSplit,
        load(callback: (element: microflows$InheritanceSplit) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Inheritance+Split relevant section in reference guide}
     */
    declare class InheritanceSplit mixins MicroflowObject, IInheritanceSplit {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        splitVariableName: string;
        caption: string;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IIntersect = {
        container: microflows$IListOperationAction,
        load(): microflows$Intersect,
        load(callback: (element: microflows$Intersect) => void): any
    } & microflows$IBinaryListOperation


    declare class Intersect mixins BinaryListOperation, IIntersect {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Java+Action+Call relevant section in reference guide}
     */
    declare type microflows$IJavaActionCallAction = {
        container: microflows$IActionActivity,
        load(): microflows$JavaActionCallAction,
        load(callback: (element: microflows$JavaActionCallAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Java+Action+Call relevant section in reference guide}
     */
    declare class JavaActionCallAction mixins MicroflowAction, IJavaActionCallAction {
        typeName: string;
        container: microflows$ActionActivity;
        javaAction: javaactions$IJavaAction;
        javaActionQualifiedName: string;
        parameterMappings: instances$IList<microflows$JavaActionParameterMapping>;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IJavaActionParameterMapping = {
        container: microflows$IJavaActionCallAction,
        load(): microflows$JavaActionParameterMapping,
        load(callback: (element: microflows$JavaActionParameterMapping) => void): any
    }

    declare class JavaActionParameterMapping mixins elements$Element, IJavaActionParameterMapping {
        typeName: string;
        container: microflows$JavaActionCallAction;
        parameter: javaactions$IJavaActionParameter;
        parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/List+Operation relevant section in reference guide}
     */
    declare type microflows$IListOperationAction = {
        container: microflows$IActionActivity,
        load(): microflows$ListOperationAction,
        load(callback: (element: microflows$ListOperationAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/List+Operation relevant section in reference guide}
     */
    declare class ListOperationAction mixins MicroflowAction, IListOperationAction {
        typeName: string;
        container: microflows$ActionActivity;
        operation: microflows$ListOperation;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Log+Message relevant section in reference guide}
     */
    declare type microflows$ILogMessageAction = {
        container: microflows$IActionActivity,
        load(): microflows$LogMessageAction,
        load(callback: (element: microflows$LogMessageAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Log+Message relevant section in reference guide}
     */
    declare class LogMessageAction mixins MicroflowAction, ILogMessageAction {
        typeName: string;
        container: microflows$ActionActivity;
        level: microflows$LogLevel;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        node: string;
        messageTemplate: microflows$StringTemplate;
        includeLatestStackTrace: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Loop relevant section in reference guide}
     */
    declare type microflows$ILoopedActivity = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$LoopedActivity,
        load(callback: (element: microflows$LoopedActivity) => void): any
    } & microflows$IActivity



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Loop relevant section in reference guide}
     */
    declare class LoopedActivity mixins Activity, ILoopedActivity {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        objectCollection: microflows$MicroflowObjectCollection;
        iteratedListVariableName: string;
        loopVariableName: string;
        errorHandlingType: microflows$ErrorHandlingType;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IModuleDocument = {
        container: projects$IFolderBase,
        load(): projects$ModuleDocument,
        load(callback: (element: projects$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type microflows$IDocument = {
        container: projects$IFolderBase,
        load(): projects$Document,
        load(callback: (element: projects$Document) => void): any,
        name: string
    } & microflows$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: Abstract
     */
    declare type microflows$IMicroflowBase = {
        container: projects$IFolderBase,
        load(): microflows$MicroflowBase,
        load(callback: (element: microflows$MicroflowBase) => void): any,

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        returnType: string
    }


    /**
     * TODO: Abstract
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MicroflowBase mixins projects$Document, IMicroflowBase {
        typeName: string;
        container: projects$FolderBase;
        objectCollection: microflows$MicroflowObjectCollection;
        flows: instances$IList<microflows$Flow>;

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        returnType: string;
        applyEntityAccess: boolean;
        markAsUsed: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Microflows relevant section in reference guide}
     */
    declare type microflows$IMicroflow = {
        container: projects$IFolderBase,
        load(): microflows$Microflow,
        load(callback: (element: microflows$Microflow) => void): any
    } & microflows$IMicroflowBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Microflows relevant section in reference guide}
     */
    declare class Microflow mixins MicroflowBase, IMicroflow {
        typeName: string;
        container: projects$FolderBase;
        allowedModuleRoles: instances$IList<security$IModuleRole>;
        allowedModuleRolesQualifiedNames: string[];
        allowConcurrentExecution: boolean;
        concurrenyErrorMessage: texts$Text;
        concurrencyErrorMicroflow: microflows$IMicroflow;
        concurrencyErrorMicroflowQualifiedName: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IMicroflowCall = {
        container: microflows$IMicroflowCallAction,
        load(): microflows$MicroflowCall,
        load(callback: (element: microflows$MicroflowCall) => void): any
    }

    declare class MicroflowCall mixins elements$Element, IMicroflowCall {
        typeName: string;
        container: microflows$MicroflowCallAction;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        parameterMappings: instances$IList<microflows$MicroflowCallParameterMapping>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Microflow+Call relevant section in reference guide}
     */
    declare type microflows$IMicroflowCallAction = {
        container: microflows$IActionActivity,
        load(): microflows$MicroflowCallAction,
        load(callback: (element: microflows$MicroflowCallAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Microflow+Call relevant section in reference guide}
     */
    declare class MicroflowCallAction mixins MicroflowAction, IMicroflowCallAction {
        typeName: string;
        container: microflows$ActionActivity;
        microflowCall: microflows$MicroflowCall;
        useReturnVariable: boolean;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IMicroflowCallParameterMapping = {
        container: microflows$IMicroflowCall,
        load(): microflows$MicroflowCallParameterMapping,
        load(callback: (element: microflows$MicroflowCallParameterMapping) => void): any
    }

    declare class MicroflowCallParameterMapping mixins elements$Element, IMicroflowCallParameterMapping {
        typeName: string;
        container: microflows$MicroflowCall;
        parameter: microflows$IMicroflowParameter;
        parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO: artificial object
     */
    declare type microflows$IMicroflowObjectCollection = {
        load(): microflows$MicroflowObjectCollection,
        load(callback: (element: microflows$MicroflowObjectCollection) => void): any
    }


    /**
     * TODO: artificial object
     */
    declare class MicroflowObjectCollection mixins elements$Element, IMicroflowObjectCollection {
        typeName: string;
        objects: instances$IList<microflows$MicroflowObject>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IMicroflowParameterBase = {
        container: microflows$IMicroflowBase,
        load(): microflows$MicroflowParameterBase,
        load(callback: (element: microflows$MicroflowParameterBase) => void): any,
        name: string,

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        type: string
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MicroflowParameterBase mixins elements$Element, IMicroflowParameterBase {
        typeName: string;
        container: microflows$MicroflowBase;
        name: string;

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        type: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Parameter relevant section in reference guide}
     */
    declare type microflows$IMicroflowParameter = {
        container: microflows$IMicroflow,
        load(): microflows$MicroflowParameter,
        load(callback: (element: microflows$MicroflowParameter) => void): any
    } & microflows$IMicroflowParameterBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Parameter relevant section in reference guide}
     */
    declare class MicroflowParameter mixins MicroflowParameterBase, IMicroflowParameter {
        typeName: string;
        container: microflows$Microflow;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Parameter relevant section in reference guide}
     */
    declare type microflows$IRuleParameter = {
        container: microflows$IRule,
        load(): microflows$RuleParameter,
        load(callback: (element: microflows$RuleParameter) => void): any
    } & microflows$IMicroflowParameterBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Parameter relevant section in reference guide}
     */
    declare class RuleParameter mixins MicroflowParameterBase, IRuleParameter {
        typeName: string;
        container: microflows$Rule;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IMicroflowParameterObject = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$MicroflowParameterObject,
        load(callback: (element: microflows$MicroflowParameterObject) => void): any
    } & microflows$IMicroflowObject


    declare class MicroflowParameterObject mixins MicroflowObject, IMicroflowParameterObject {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        name: string;

        /**
         * The value of this property is conceptually of type Common$DataType.
         */
        type: string;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$INoCase = {
        container: microflows$ISequenceFlow,
        load(): microflows$NoCase,
        load(callback: (element: microflows$NoCase) => void): any
    } & microflows$ICaseValue



    /**
     * TODO
     */
    declare class NoCase mixins CaseValue, INoCase {
        typeName: string;
        container: microflows$SequenceFlow;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Retrieve relevant section in reference guide}
     */
    declare type microflows$IRetrieveAction = {
        container: microflows$IActionActivity,
        load(): microflows$RetrieveAction,
        load(callback: (element: microflows$RetrieveAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Retrieve relevant section in reference guide}
     */
    declare class RetrieveAction mixins MicroflowAction, IRetrieveAction {
        typeName: string;
        container: microflows$ActionActivity;
        retrieveSource: microflows$RetrieveSource;
        outputVariableName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Rollback+Object relevant section in reference guide}
     */
    declare type microflows$IRollbackAction = {
        container: microflows$IActionActivity,
        load(): microflows$RollbackAction,
        load(callback: (element: microflows$RollbackAction) => void): any
    } & microflows$IMicroflowAction



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Rollback+Object relevant section in reference guide}
     */
    declare class RollbackAction mixins MicroflowAction, IRollbackAction {
        typeName: string;
        container: microflows$ActionActivity;
        rollbackVariableName: string;
        refreshInClient: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Rules relevant section in reference guide}
     */
    declare type microflows$IRule = {
        container: projects$IFolderBase,
        load(): microflows$Rule,
        load(callback: (element: microflows$Rule) => void): any
    } & microflows$IMicroflowBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Rules relevant section in reference guide}
     */
    declare class Rule mixins MicroflowBase, IRule {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IRuleCall = {
        container: microflows$IRuleSplitCondition,
        load(): microflows$RuleCall,
        load(callback: (element: microflows$RuleCall) => void): any
    }


    /**
     * TODO
     */
    declare class RuleCall mixins elements$Element, IRuleCall {
        typeName: string;
        container: microflows$RuleSplitCondition;
        rule: microflows$IRule;
        ruleQualifiedName: string;
        parameterMappings: instances$IList<microflows$RuleCallParameterMapping>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IRuleCallParameterMapping = {
        container: microflows$IRuleCall,
        load(): microflows$RuleCallParameterMapping,
        load(callback: (element: microflows$RuleCallParameterMapping) => void): any
    }


    /**
     * TODO
     */
    declare class RuleCallParameterMapping mixins elements$Element, IRuleCallParameterMapping {
        typeName: string;
        container: microflows$RuleCall;
        parameter: microflows$IRuleParameter;
        parameterQualifiedName: string;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        argument: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IRuleSplitCondition = {
        container: microflows$IExclusiveSplit,
        load(): microflows$RuleSplitCondition,
        load(callback: (element: microflows$RuleSplitCondition) => void): any
    } & microflows$ISplitCondition


    declare class RuleSplitCondition mixins SplitCondition, IRuleSplitCondition {
        typeName: string;
        container: microflows$ExclusiveSplit;
        ruleCall: microflows$RuleCall;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sequence+Flow relevant section in reference guide}
     */
    declare type microflows$ISequenceFlow = {
        container: microflows$IMicroflowBase,
        load(): microflows$SequenceFlow,
        load(callback: (element: microflows$SequenceFlow) => void): any
    } & microflows$IFlow



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sequence+Flow relevant section in reference guide}
     */
    declare class SequenceFlow mixins Flow, ISequenceFlow {
        typeName: string;
        container: microflows$MicroflowBase;
        caseValue: microflows$CaseValue;
        isErrorHandler: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$ISort = {
        container: microflows$IListOperationAction,
        load(): microflows$Sort,
        load(callback: (element: microflows$Sort) => void): any
    } & microflows$IListOperation


    declare class Sort mixins ListOperation, ISort {
        typeName: string;
        container: microflows$ListOperationAction;
        sortItemList: microflows$SortItemList;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ISortItem = {
        container: microflows$ISortItemList,
        load(): microflows$SortItem,
        load(callback: (element: microflows$SortItem) => void): any
    }


    /**
     * TODO
     */
    declare class SortItem mixins elements$Element, ISortItem {
        typeName: string;
        container: microflows$SortItemList;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        sortOrder: microflows$SortOrderEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ISortItemList = {
        load(): microflows$SortItemList,
        load(callback: (element: microflows$SortItemList) => void): any
    }


    /**
     * TODO
     */
    declare class SortItemList mixins elements$Element, ISortItemList {
        typeName: string;
        items: instances$IList<microflows$SortItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Start+Event relevant section in reference guide}
     */
    declare type microflows$IStartEvent = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$StartEvent,
        load(callback: (element: microflows$StartEvent) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Start+Event relevant section in reference guide}
     */
    declare class StartEvent mixins MicroflowObject, IStartEvent {
        typeName: string;
        container: microflows$MicroflowObjectCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$ITemplate = {
        load(): microflows$Template,
        load(callback: (element: microflows$Template) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Template mixins elements$Element, ITemplate {
        typeName: string;
        arguments: instances$IList<microflows$TemplateArgument>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$IStringTemplate = {
        load(): microflows$StringTemplate,
        load(callback: (element: microflows$StringTemplate) => void): any
    } & microflows$ITemplate



    /**
     * TODO
     */
    declare class StringTemplate mixins Template, IStringTemplate {
        typeName: string;
        text: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$ISubtract = {
        container: microflows$IListOperationAction,
        load(): microflows$Subtract,
        load(callback: (element: microflows$Subtract) => void): any
    } & microflows$IBinaryListOperation


    declare class Subtract mixins BinaryListOperation, ISubtract {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$ITail = {
        container: microflows$IListOperationAction,
        load(): microflows$Tail,
        load(callback: (element: microflows$Tail) => void): any
    } & microflows$IListOperation


    declare class Tail mixins ListOperation, ITail {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ITemplateArgument = {
        container: microflows$ITemplate,
        load(): microflows$TemplateArgument,
        load(callback: (element: microflows$TemplateArgument) => void): any
    }


    /**
     * TODO
     */
    declare class TemplateArgument mixins elements$Element, ITemplateArgument {
        typeName: string;
        container: microflows$Template;

        /**
         * The value of this property is conceptually of type MicroflowExpressions$MicroflowExpression.
         */
        expression: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * TODO
     */
    declare type microflows$ITextTemplate = {
        load(): microflows$TextTemplate,
        load(callback: (element: microflows$TextTemplate) => void): any
    } & microflows$ITemplate



    /**
     * TODO
     */
    declare class TextTemplate mixins Template, ITextTemplate {
        typeName: string;
        text: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type microflows$IUnion = {
        container: microflows$IListOperationAction,
        load(): microflows$Union,
        load(callback: (element: microflows$Union) => void): any
    } & microflows$IBinaryListOperation


    declare class Union mixins BinaryListOperation, IUnion {
        typeName: string;
        container: microflows$ListOperationAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class NullValueOption mixins instances$IEnum {
        qualifiedTsTypeName: string;
        SendAsNil: microflows$NullValueOption;
        LeaveOutElement: microflows$NullValueOption
    }

    declare class LanguageSettingType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        CurrentUser: microflows$LanguageSettingType;
        ProjectDefault: microflows$LanguageSettingType;
        Variable: microflows$LanguageSettingType
    }

    declare class TargetDocumentType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        HTML: microflows$TargetDocumentType;
        PDF: microflows$TargetDocumentType;
        DOCX: microflows$TargetDocumentType;
        DOC: microflows$TargetDocumentType;
        RTF: microflows$TargetDocumentType;
        ODT: microflows$TargetDocumentType
    }

    declare class ShowMessageType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Information: microflows$ShowMessageType;
        Warning: microflows$ShowMessageType;
        Error: microflows$ShowMessageType
    }

    declare class ActionActivityColor mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: microflows$ActionActivityColor;
        Red: microflows$ActionActivityColor;
        Orange: microflows$ActionActivityColor;
        Yellow: microflows$ActionActivityColor;
        Green: microflows$ActionActivityColor;
        Blue: microflows$ActionActivityColor;
        Purple: microflows$ActionActivityColor;
        Gray: microflows$ActionActivityColor
    }

    declare class AggregateFunctionEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Sum: microflows$AggregateFunctionEnum;
        Average: microflows$AggregateFunctionEnum;
        Count: microflows$AggregateFunctionEnum;
        Minimum: microflows$AggregateFunctionEnum;
        Maximum: microflows$AggregateFunctionEnum
    }

    declare class ChangeActionItemType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Set: microflows$ChangeActionItemType;
        Add: microflows$ChangeActionItemType;
        Remove: microflows$ChangeActionItemType
    }

    declare class ChangeListActionType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Set: microflows$ChangeListActionType;
        Add: microflows$ChangeListActionType;
        Remove: microflows$ChangeListActionType;
        Clear: microflows$ChangeListActionType
    }

    declare class CommitEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Yes: microflows$CommitEnum;
        YesWithoutEvents: microflows$CommitEnum;
        No: microflows$CommitEnum
    }

    declare class ErrorHandlingType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Rollback: microflows$ErrorHandlingType;
        Custom: microflows$ErrorHandlingType;
        CustomWithoutRollBack: microflows$ErrorHandlingType;
        Continue: microflows$ErrorHandlingType
    }

    declare class LogLevel mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Trace: microflows$LogLevel;
        Debug: microflows$LogLevel;
        Info: microflows$LogLevel;
        Warning: microflows$LogLevel;
        Error: microflows$LogLevel;
        Critical: microflows$LogLevel
    }

    declare class SortOrderEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Ascending: microflows$SortOrderEnum;
        Descending: microflows$SortOrderEnum
    }
    declare type webservices$IDataMember = {
        load(): webservices$DataMember,
        load(callback: (element: webservices$DataMember) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataMember mixins elements$Element, IDataMember {
        typeName: string;
        isLockedByContract: boolean;
        exposedName: string;
        isOptionalByContract: boolean;
        isOptional: boolean;
        isNillableByContract: boolean;
        isNillable: boolean;
        isKey: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IDataEntityBase = {
        load(): webservices$DataEntityBase,
        load(callback: (element: webservices$DataEntityBase) => void): any
    } & webservices$IDataMember



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataEntityBase mixins DataMember, IDataEntityBase {
        typeName: string;
        childMembers: instances$IList<webservices$DataMember>;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        exposedItemName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IDataAssociation = {
        container: webservices$IDataEntityBase,
        load(): webservices$DataAssociation,
        load(callback: (element: webservices$DataAssociation) => void): any
    } & webservices$IDataEntityBase


    declare class DataAssociation mixins DataEntityBase, IDataAssociation {
        typeName: string;
        container: webservices$DataEntityBase;
        associationByContract: appservices$MsdAssociation;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IDataAttribute = {
        container: webservices$IDataEntityBase,
        load(): webservices$DataAttribute,
        load(callback: (element: webservices$DataAttribute) => void): any
    } & webservices$IDataMember


    declare class DataAttribute mixins DataMember, IDataAttribute {
        typeName: string;
        container: webservices$DataEntityBase;
        attributeByContract: appservices$MsdAttribute;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IDataEntity = {
        load(): webservices$DataEntity,
        load(callback: (element: webservices$DataEntity) => void): any
    } & webservices$IDataEntityBase


    declare class DataEntity mixins DataEntityBase, IDataEntity {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IModuleDocument = {
        container: projects$IFolderBase,
        load(): microflows$ModuleDocument,
        load(callback: (element: microflows$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type webservices$IDocument = {
        container: projects$IFolderBase,
        load(): microflows$Document,
        load(callback: (element: microflows$Document) => void): any,
        name: string
    } & webservices$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Imported+Web+Services relevant section in reference guide}
     */
    declare type webservices$IImportedWebService = {
        container: projects$IFolderBase,
        load(): webservices$ImportedWebService,
        load(callback: (element: webservices$ImportedWebService) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Imported+Web+Services relevant section in reference guide}
     */
    declare class ImportedWebService mixins projects$Document, IImportedWebService {
        typeName: string;
        container: projects$FolderBase;
        wsdlDescription: webservices$WsdlDescription;
        wsdlUrl: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IOperationInfo = {
        container: webservices$IServiceInfo,
        load(): webservices$OperationInfo,
        load(callback: (element: webservices$OperationInfo) => void): any
    }

    declare class OperationInfo mixins elements$Element, IOperationInfo {
        typeName: string;
        container: webservices$ServiceInfo;
        requestHeaderRpcElement: webservices$RpcOperationElement;
        requestBodyRpcElement: webservices$RpcOperationElement;
        responseBodyRpcElement: webservices$RpcOperationElement;
        requestHeaderPartEncoding: webservices$PartEncoding;
        requestBodyPartEncodings: instances$IList<webservices$PartEncoding>;
        name: string;
        documentation: string;
        soapAction: string;
        requestHeaderElementName: string;
        requestHeaderEncoded: boolean;
        requestBodyEncoded: boolean;
        requestBodyElementName: string;
        responseBodyElementName: string;
        allowSimpleMappingInheritance: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IPartEncoding = {
        container: webservices$IOperationInfo,
        load(): webservices$PartEncoding,
        load(callback: (element: webservices$PartEncoding) => void): any
    }

    declare class PartEncoding mixins elements$Element, IPartEncoding {
        typeName: string;
        container: webservices$OperationInfo;
        partName: string;
        partXsdType: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IPublishedServiceBase = {
        container: projects$IFolderBase,
        load(): webservices$PublishedServiceBase,
        load(callback: (element: webservices$PublishedServiceBase) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class PublishedServiceBase mixins projects$Document, IPublishedServiceBase {
        typeName: string;
        container: projects$FolderBase;
        versionedServices: instances$IList<webservices$VersionedService>;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+App+Services relevant section in reference guide}
     */
    declare type webservices$IPublishedAppService = {
        container: projects$IFolderBase,
        load(): webservices$PublishedAppService,
        load(callback: (element: webservices$PublishedAppService) => void): any
    } & webservices$IPublishedServiceBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+App+Services relevant section in reference guide}
     */
    declare class PublishedAppService mixins PublishedServiceBase, IPublishedAppService {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IPublishedOperation = {
        container: webservices$IVersionedService,
        load(): webservices$PublishedOperation,
        load(callback: (element: webservices$PublishedOperation) => void): any
    }

    declare class PublishedOperation mixins elements$Element, IPublishedOperation {
        typeName: string;
        container: webservices$VersionedService;
        parameters: instances$IList<webservices$PublishedParameter>;
        dataEntity: webservices$DataEntity;
        isLockedByContract: boolean;
        name: string;
        image: images$IImage;
        imageQualifiedName: string;
        description: string;
        documentation: string;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        returnTypeNameByContract: string;
        returnTypeSpecificationByContract: string;
        entityExposedNameByContract: string;
        entityExposedName: string;
        returnTypeIsOptional: boolean;
        returnTypeIsNillable: boolean;
        returnType: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IPublishedParameter = {
        container: webservices$IPublishedOperation,
        load(): webservices$PublishedParameter,
        load(callback: (element: webservices$PublishedParameter) => void): any
    }

    declare class PublishedParameter mixins elements$Element, IPublishedParameter {
        typeName: string;
        container: webservices$PublishedOperation;
        parameterByContract: appservices$MsdMicroflowParameter;
        dataEntity: webservices$DataEntity;
        isLockedByContract: boolean;
        parameter: microflows$IMicroflowParameter;
        parameterQualifiedName: string;
        entityExposedName: string;
        isOptionalByContract: boolean;
        isOptional: boolean;
        isNillable: boolean;
        entityExposedItemNameByContract: string;
        entityExposedItemName: string;
        type: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+Web+Services relevant section in reference guide}
     */
    declare type webservices$IPublishedWebService = {
        container: projects$IFolderBase,
        load(): webservices$PublishedWebService,
        load(callback: (element: webservices$PublishedWebService) => void): any
    } & webservices$IPublishedServiceBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+Web+Services relevant section in reference guide}
     */
    declare class PublishedWebService mixins PublishedServiceBase, IPublishedWebService {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IRpcMessagePartElement = {
        container: webservices$IRpcOperationElement,
        load(): webservices$RpcMessagePartElement,
        load(callback: (element: webservices$RpcMessagePartElement) => void): any
    }

    declare class RpcMessagePartElement mixins elements$Element, IRpcMessagePartElement {
        typeName: string;
        container: webservices$RpcOperationElement;
        partName: string;
        typeName: string;
        elementName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IRpcOperationElement = {
        container: webservices$IOperationInfo,
        load(): webservices$RpcOperationElement,
        load(callback: (element: webservices$RpcOperationElement) => void): any
    }

    declare class RpcOperationElement mixins elements$Element, IRpcOperationElement {
        typeName: string;
        container: webservices$OperationInfo;
        messagePartElements: instances$IList<webservices$RpcMessagePartElement>;
        name: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IServiceInfo = {
        container: webservices$IWsdlDescription,
        load(): webservices$ServiceInfo,
        load(callback: (element: webservices$ServiceInfo) => void): any
    }

    declare class ServiceInfo mixins elements$Element, IServiceInfo {
        typeName: string;
        container: webservices$WsdlDescription;
        operations: instances$IList<webservices$OperationInfo>;
        name: string;
        documentation: string;
        portName: string;
        location: string;
        soapVersion: webservices$SoapVersion;
        locationConstant: constants$IConstant;
        locationConstantQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+Web+Services relevant section in reference guide}
     */
    declare type webservices$IVersionedService = {
        container: webservices$IPublishedServiceBase,
        load(): webservices$VersionedService,
        load(callback: (element: webservices$VersionedService) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Published+Web+Services relevant section in reference guide}
     */
    declare class VersionedService mixins elements$Element, IVersionedService {
        typeName: string;
        container: webservices$PublishedServiceBase;
        operations: instances$IList<webservices$PublishedOperation>;
        enumerationsByContract: appservices$MsdEnumerationContainer;
        documentation: string;
        targetNamespace: string;
        headerAuthentication: integration$HeaderAuthentication;
        isLockedByContract: boolean;
        headerImportMapping: importmappings$IImportMapping;
        headerImportMappingQualifiedName: string;
        headerMicroflow: microflows$IMicroflow;
        headerMicroflowQualifiedName: string;
        versionNumber: number;
        caption: string;
        description: string;
        appServiceState: webservices$AppServiceState;
        image: images$IImage;
        imageQualifiedName: string;
        validate: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IWsdlDescription = {
        load(): webservices$WsdlDescription,
        load(callback: (element: webservices$WsdlDescription) => void): any
    }

    declare class WsdlDescription mixins elements$Element, IWsdlDescription {
        typeName: string;
        wsdlEntries: instances$IList<webservices$WsdlEntry>;
        schemaEntries: instances$IList<xmlschemas$MxXmlSchemaEntry>;
        services: instances$IList<webservices$ServiceInfo>;
        targetNamespace: string;
        importsHaveLocations: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type webservices$IWsdlEntry = {
        container: webservices$IWsdlDescription,
        load(): webservices$WsdlEntry,
        load(callback: (element: webservices$WsdlEntry) => void): any
    }

    declare class WsdlEntry mixins elements$Element, IWsdlEntry {
        typeName: string;
        container: webservices$WsdlDescription;
        location: string;
        contents: string;
        localizedLocationFormat: string;
        localizedContentsFormat: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class AppServiceState mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Draft: webservices$AppServiceState;
        Consumable: webservices$AppServiceState;
        Deprecated: webservices$AppServiceState
    }

    declare class SoapVersion mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Soap11: webservices$SoapVersion;
        Soap12: webservices$SoapVersion
    }
    declare class AppServiceLocationEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: integration$AppServiceLocationEnum;
        Constant: integration$AppServiceLocationEnum;
        Parameter: integration$AppServiceLocationEnum
    }

    declare class ElementType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Undefined: integration$ElementType;
        Inheritance: integration$ElementType;
        Choice: integration$ElementType;
        Object: integration$ElementType;
        Value: integration$ElementType;
        Sequence: integration$ElementType;
        All: integration$ElementType
    }

    declare class HeaderAuthentication mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: integration$HeaderAuthentication;
        UsernamePassword: integration$HeaderAuthentication;
        Custom: integration$HeaderAuthentication
    }
    declare type xmlschemas$IModuleDocument = {
        container: projects$IFolderBase,
        load(): webservices$ModuleDocument,
        load(callback: (element: webservices$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type xmlschemas$IDocument = {
        container: projects$IFolderBase,
        load(): webservices$Document,
        load(callback: (element: webservices$Document) => void): any,
        name: string
    } & xmlschemas$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/XML+Schemas relevant section in reference guide}
     */
    declare type xmlschemas$IMxXmlSchema = {
        container: projects$IFolderBase,
        load(): xmlschemas$MxXmlSchema,
        load(callback: (element: xmlschemas$MxXmlSchema) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/XML+Schemas relevant section in reference guide}
     */
    declare class MxXmlSchema mixins projects$Document, IMxXmlSchema {
        typeName: string;
        container: projects$FolderBase;
        schemaEntries: instances$IList<xmlschemas$MxXmlSchemaEntry>;
        filePath: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type xmlschemas$IMxXmlSchemaEntry = {
        load(): xmlschemas$MxXmlSchemaEntry,
        load(callback: (element: xmlschemas$MxXmlSchemaEntry) => void): any
    }

    declare class MxXmlSchemaEntry mixins elements$Element, IMxXmlSchemaEntry {
        typeName: string;
        targetNamespace: string;
        location: string;
        contents: string;
        localizedLocationFormat: string;
        localizedContentsFormat: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class XmlPrimitiveType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Unknown: xmlschemas$XmlPrimitiveType;
        Boolean: xmlschemas$XmlPrimitiveType;
        Date: xmlschemas$XmlPrimitiveType;
        Time: xmlschemas$XmlPrimitiveType;
        DateTime: xmlschemas$XmlPrimitiveType;
        Decimal: xmlschemas$XmlPrimitiveType;
        Float: xmlschemas$XmlPrimitiveType;
        Integer: xmlschemas$XmlPrimitiveType;
        Binary: xmlschemas$XmlPrimitiveType;
        String: xmlschemas$XmlPrimitiveType;
        AnyType: xmlschemas$XmlPrimitiveType
    }
    declare type appservices$IAppServiceAction = {
        container: appservices$IConsumedAppService,
        load(): appservices$AppServiceAction,
        load(callback: (element: appservices$AppServiceAction) => void): any,
        parameters: instances$IList<appservices$IAppServiceActionParameter>,
        name: string
    }

    declare class AppServiceAction mixins elements$Element, IAppServiceAction {
        typeName: string;
        container: appservices$ConsumedAppService;
        parameters: instances$IList<appservices$AppServiceActionParameter>;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        returnType: string;
        returnTypeCanBeEmpty: boolean;
        name: string;
        imageString: string;
        caption: string;
        description: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IAppServiceActionParameter = {
        container: appservices$IAppServiceAction,
        load(): appservices$AppServiceActionParameter,
        load(callback: (element: appservices$AppServiceActionParameter) => void): any,
        name: string
    }

    declare class AppServiceActionParameter mixins elements$Element, IAppServiceActionParameter {
        typeName: string;
        container: appservices$AppServiceAction;
        name: string;
        type: string;
        canBeEmpty: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IModuleDocument = {
        container: projects$IFolderBase,
        load(): xmlschemas$ModuleDocument,
        load(callback: (element: xmlschemas$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type appservices$IDocument = {
        container: projects$IFolderBase,
        load(): xmlschemas$Document,
        load(callback: (element: xmlschemas$Document) => void): any,
        name: string
    } & appservices$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Consumed+App+Services relevant section in reference guide}
     */
    declare type appservices$IConsumedAppService = {
        container: projects$IFolderBase,
        load(): appservices$ConsumedAppService,
        load(callback: (element: appservices$ConsumedAppService) => void): any,
        actions: instances$IList<appservices$IAppServiceAction >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Consumed+App+Services relevant section in reference guide}
     */
    declare class ConsumedAppService mixins projects$Document, IConsumedAppService {
        typeName: string;
        container: projects$FolderBase;
        actions: instances$IList<appservices$AppServiceAction>;
        msd: appservices$Msd;
        fromAppStore: boolean;
        appStoreGuid: string;
        appStoreVersionGuid: string;
        appStoreVersion: string;
        appServiceLocation: integration$AppServiceLocationEnum;
        locationConstant: constants$IConstant;
        locationConstantQualifiedName: string;
        useTimeOut: boolean;
        timeOut: number;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsd = {
        container: appservices$IConsumedAppService,
        load(): appservices$Msd,
        load(callback: (element: appservices$Msd) => void): any
    }

    declare class Msd mixins elements$Element, IMsd {
        typeName: string;
        container: appservices$ConsumedAppService;
        version: appservices$MsdVersion;
        metadata: appservices$MsdMetadata;
        domainModel: appservices$MsdDomainModel;
        enumerations: appservices$MsdEnumerationContainer;
        wsdlDescription: webservices$WsdlDescription;
        wsdlString: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdAssociation = {
        load(): appservices$MsdAssociation,
        load(callback: (element: appservices$MsdAssociation) => void): any
    }

    declare class MsdAssociation mixins elements$Element, IMsdAssociation {
        typeName: string;
        name: string;
        guid: string;
        parentEntityName: string;
        childEntityName: string;
        associationType: string;
        associationOwner: string;
        parentDeleteBehavior: string;
        childDeleteBehavior: string;
        associationKind: string;
        parentX: number;
        parentY: number;
        childX: number;
        childY: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdAttribute = {
        load(): appservices$MsdAttribute,
        load(callback: (element: appservices$MsdAttribute) => void): any
    }

    declare class MsdAttribute mixins elements$Element, IMsdAttribute {
        typeName: string;
        name: string;
        guid: string;
        attributeType: string;
        enumerationName: string;
        defaultValue: string;
        length: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdDomainModel = {
        container: appservices$IMsd,
        load(): appservices$MsdDomainModel,
        load(callback: (element: appservices$MsdDomainModel) => void): any
    }

    declare class MsdDomainModel mixins elements$Element, IMsdDomainModel {
        typeName: string;
        container: appservices$Msd;
        entities: instances$IList<appservices$MsdEntity>;
        associations: instances$IList<appservices$MsdAssociation>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdEntity = {
        container: appservices$IMsdDomainModel,
        load(): appservices$MsdEntity,
        load(callback: (element: appservices$MsdEntity) => void): any
    }

    declare class MsdEntity mixins elements$Element, IMsdEntity {
        typeName: string;
        container: appservices$MsdDomainModel;
        attributes: instances$IList<appservices$MsdAttribute>;
        name: string;
        guid: string;
        generalizationName: string;
        persistable: boolean;
        locationX: number;
        locationY: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdEnumeration = {
        container: appservices$IMsdEnumerationContainer,
        load(): appservices$MsdEnumeration,
        load(callback: (element: appservices$MsdEnumeration) => void): any
    }

    declare class MsdEnumeration mixins elements$Element, IMsdEnumeration {
        typeName: string;
        container: appservices$MsdEnumerationContainer;
        values: instances$IList<appservices$MsdEnumerationValue>;
        name: string;
        guid: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdEnumerationContainer = {
        load(): appservices$MsdEnumerationContainer,
        load(callback: (element: appservices$MsdEnumerationContainer) => void): any
    }

    declare class MsdEnumerationContainer mixins elements$Element, IMsdEnumerationContainer {
        typeName: string;
        msdEnumerations: instances$IList<appservices$MsdEnumeration>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdEnumerationValue = {
        container: appservices$IMsdEnumeration,
        load(): appservices$MsdEnumerationValue,
        load(callback: (element: appservices$MsdEnumerationValue) => void): any
    }

    declare class MsdEnumerationValue mixins elements$Element, IMsdEnumerationValue {
        typeName: string;
        container: appservices$MsdEnumeration;
        translations: instances$IList<appservices$MsdText>;
        name: string;
        guid: string;
        base64image: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdMetadata = {
        container: appservices$IMsd,
        load(): appservices$MsdMetadata,
        load(callback: (element: appservices$MsdMetadata) => void): any
    }

    declare class MsdMetadata mixins elements$Element, IMsdMetadata {
        typeName: string;
        container: appservices$Msd;
        microflows: instances$IList<appservices$MsdMicroflow>;
        name: string;
        documentation: string;
        version: number;
        publishDateTime: string;
        serviceGuid: string;
        versionGuid: string;
        instanceGuid: string;
        supportedProtocols: instances$IList<string>;
        headerAuthentication: string;
        caption: string;
        imageBase64: string;
        description: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdMicroflow = {
        container: appservices$IMsdMetadata,
        load(): appservices$MsdMicroflow,
        load(callback: (element: appservices$MsdMicroflow) => void): any
    }

    declare class MsdMicroflow mixins elements$Element, IMsdMicroflow {
        typeName: string;
        container: appservices$MsdMetadata;
        parameters: instances$IList<appservices$MsdMicroflowParameter>;
        name: string;
        documentation: string;
        imageBase64: string;
        description: string;
        returnType: string;
        systemEntityType: string;
        returnTypeSpecification: string;
        returnTypeCanBeEmpty: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdMicroflowParameter = {
        load(): appservices$MsdMicroflowParameter,
        load(callback: (element: appservices$MsdMicroflowParameter) => void): any
    }

    declare class MsdMicroflowParameter mixins elements$Element, IMsdMicroflowParameter {
        typeName: string;
        name: string;
        type: string;
        typeSpecification: string;
        systemEntityType: string;
        canBeEmpty: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdText = {
        container: appservices$IMsdEnumerationValue,
        load(): appservices$MsdText,
        load(callback: (element: appservices$MsdText) => void): any
    }

    declare class MsdText mixins elements$Element, IMsdText {
        typeName: string;
        container: appservices$MsdEnumerationValue;
        languageCode: string;
        caption: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type appservices$IMsdVersion = {
        container: appservices$IMsd,
        load(): appservices$MsdVersion,
        load(callback: (element: appservices$MsdVersion) => void): any
    }

    declare class MsdVersion mixins elements$Element, IMsdVersion {
        typeName: string;
        container: appservices$Msd;
        version: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type mappings$IModuleDocument = {
        container: projects$IFolderBase,
        load(): appservices$ModuleDocument,
        load(callback: (element: appservices$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type mappings$IDocument = {
        container: projects$IFolderBase,
        load(): appservices$Document,
        load(callback: (element: appservices$Document) => void): any,
        name: string
    } & mappings$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IMappingDocument = {
        container: projects$IFolderBase,
        load(): importmappings$MappingDocument,
        load(callback: (element: importmappings$MappingDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingDocument mixins projects$Document, IMappingDocument {
        typeName: string;
        container: projects$FolderBase;
        rootMappingelements: instances$IList<importmappings$ObjectMappingElement>;
        mxXmlSchema: xmlschemas$IMxXmlSchema;
        mxXmlSchemaQualifiedName: string;
        rootElementName: string;
        importedWebService: webservices$IImportedWebService;
        importedWebServiceQualifiedName: string;
        serviceName: string;
        operationName: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IMappingElement = {
        load(): importmappings$MappingElement,
        load(callback: (element: importmappings$MappingElement) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingElement mixins elements$Element, IMappingElement {
        typeName: string;
        documentation: string;
        elementType: integration$ElementType;
        path: string;
        minOccurs: number;
        maxOccurs: number;
        nillable: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IMappingMicroflowCall = {
        container: importmappings$IObjectMappingElement,
        load(): mappings$MappingMicroflowCall,
        load(callback: (element: mappings$MappingMicroflowCall) => void): any
    }

    declare class MappingMicroflowCall mixins elements$Element, IMappingMicroflowCall {
        typeName: string;
        container: importmappings$ObjectMappingElement;
        parameterMappings: instances$IList<mappings$MappingMicroflowParameter>;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IMappingMicroflowParameter = {
        container: mappings$IMappingMicroflowCall,
        load(): mappings$MappingMicroflowParameter,
        load(callback: (element: mappings$MappingMicroflowParameter) => void): any
    }

    declare class MappingMicroflowParameter mixins elements$Element, IMappingMicroflowParameter {
        typeName: string;
        container: mappings$MappingMicroflowCall;
        parameter: microflows$IMicroflowParameter;
        parameterQualifiedName: string;
        levelOfParent: number;
        valueElementPath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IObjectMappingElement = {
        load(): importmappings$ObjectMappingElement,
        load(callback: (element: importmappings$ObjectMappingElement) => void): any
    } & mappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ObjectMappingElement mixins MappingElement, IObjectMappingElement {
        typeName: string;
        mappingMicroflowCall: mappings$MappingMicroflowCall;
        children: instances$IList<mappings$MappingElement>;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        objectHandling: importmappings$ObjectHandlingEnum;
        objectHandlingBackup: importmappings$ObjectHandlingBackupEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type mappings$IValueMappingElement = {
        container: mappings$IObjectMappingElement,
        load(): importmappings$ValueMappingElement,
        load(callback: (element: importmappings$ValueMappingElement) => void): any
    } & mappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ValueMappingElement mixins MappingElement, IValueMappingElement {
        typeName: string;
        container: mappings$ObjectMappingElement;
        xmlDataType: string;
        isKey: boolean;
        isXmlAttribute: boolean;
        isContent: boolean;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        converter: microflows$IMicroflow;
        converterQualifiedName: string;
        expectedContentTypes: string;
        maxLength: number;
        fractionDigits: number;
        totalDigits: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type exportmappings$IModuleDocument = {
        container: projects$IFolderBase,
        load(): mappings$ModuleDocument,
        load(callback: (element: mappings$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type exportmappings$IDocument = {
        container: projects$IFolderBase,
        load(): mappings$Document,
        load(callback: (element: mappings$Document) => void): any,
        name: string
    } & exportmappings$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IMappingDocument = {
        container: projects$IFolderBase,
        load(): mappings$MappingDocument,
        load(callback: (element: mappings$MappingDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingDocument mixins projects$Document, IMappingDocument {
        typeName: string;
        container: projects$FolderBase;
        rootMappingelements: instances$IList<mappings$ObjectMappingElement>;
        mxXmlSchema: xmlschemas$IMxXmlSchema;
        mxXmlSchemaQualifiedName: string;
        rootElementName: string;
        importedWebService: webservices$IImportedWebService;
        importedWebServiceQualifiedName: string;
        serviceName: string;
        operationName: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Domain-to-XML+Mappings relevant section in reference guide}
     */
    declare type exportmappings$IExportMapping = {
        container: projects$IFolderBase,
        load(): exportmappings$ExportMapping,
        load(callback: (element: exportmappings$ExportMapping) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Domain-to-XML+Mappings relevant section in reference guide}
     */
    declare class ExportMapping mixins mappings$MappingDocument, IExportMapping {
        typeName: string;
        container: projects$FolderBase;
        parameterName: string;
        parameterTypeName: string;
        isHeader: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IMappingElement = {
        load(): mappings$MappingElement,
        load(callback: (element: mappings$MappingElement) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingElement mixins elements$Element, IMappingElement {
        typeName: string;
        documentation: string;
        elementType: integration$ElementType;
        path: string;
        minOccurs: number;
        maxOccurs: number;
        nillable: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IObjectMappingElement = {
        load(): mappings$ObjectMappingElement,
        load(callback: (element: mappings$ObjectMappingElement) => void): any
    } & exportmappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ObjectMappingElement mixins mappings$MappingElement, IObjectMappingElement {
        typeName: string;
        mappingMicroflowCall: mappings$MappingMicroflowCall;
        children: instances$IList<mappings$MappingElement>;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        objectHandling: importmappings$ObjectHandlingEnum;
        objectHandlingBackup: importmappings$ObjectHandlingBackupEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IExportObjectMappingElement = {
        load(): exportmappings$ExportObjectMappingElement,
        load(callback: (element: exportmappings$ExportObjectMappingElement) => void): any
    }

    declare class ExportObjectMappingElement mixins mappings$ObjectMappingElement, IExportObjectMappingElement {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IValueMappingElement = {
        container: exportmappings$IObjectMappingElement,
        load(): mappings$ValueMappingElement,
        load(callback: (element: mappings$ValueMappingElement) => void): any
    } & exportmappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ValueMappingElement mixins mappings$MappingElement, IValueMappingElement {
        typeName: string;
        container: mappings$ObjectMappingElement;
        xmlDataType: string;
        isKey: boolean;
        isXmlAttribute: boolean;
        isContent: boolean;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        converter: microflows$IMicroflow;
        converterQualifiedName: string;
        expectedContentTypes: string;
        maxLength: number;
        fractionDigits: number;
        totalDigits: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type exportmappings$IExportValueMappingElement = {
        container: mappings$IObjectMappingElement,
        load(): exportmappings$ExportValueMappingElement,
        load(callback: (element: exportmappings$ExportValueMappingElement) => void): any
    }

    declare class ExportValueMappingElement mixins mappings$ValueMappingElement, IExportValueMappingElement {
        typeName: string;
        container: mappings$ObjectMappingElement;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type importmappings$IModuleDocument = {
        container: projects$IFolderBase,
        load(): exportmappings$ModuleDocument,
        load(callback: (element: exportmappings$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type importmappings$IDocument = {
        container: projects$IFolderBase,
        load(): exportmappings$Document,
        load(callback: (element: exportmappings$Document) => void): any,
        name: string
    } & importmappings$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IMappingDocument = {
        container: projects$IFolderBase,
        load(): exportmappings$MappingDocument,
        load(callback: (element: exportmappings$MappingDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingDocument mixins projects$Document, IMappingDocument {
        typeName: string;
        container: projects$FolderBase;
        rootMappingelements: instances$IList<mappings$ObjectMappingElement>;
        mxXmlSchema: xmlschemas$IMxXmlSchema;
        mxXmlSchemaQualifiedName: string;
        rootElementName: string;
        importedWebService: webservices$IImportedWebService;
        importedWebServiceQualifiedName: string;
        serviceName: string;
        operationName: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/XML-to-domain+Mappings relevant section in reference guide}
     */
    declare type importmappings$IImportMapping = {
        container: projects$IFolderBase,
        load(): importmappings$ImportMapping,
        load(callback: (element: importmappings$ImportMapping) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/XML-to-domain+Mappings relevant section in reference guide}
     */
    declare class ImportMapping mixins mappings$MappingDocument, IImportMapping {
        typeName: string;
        container: projects$FolderBase;
        parameterEntity: domainmodels$IEntity;
        parameterEntityQualifiedName: string;
        useSubtransactionsForMicroflows: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IMappingElement = {
        load(): exportmappings$MappingElement,
        load(callback: (element: exportmappings$MappingElement) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MappingElement mixins elements$Element, IMappingElement {
        typeName: string;
        documentation: string;
        elementType: integration$ElementType;
        path: string;
        minOccurs: number;
        maxOccurs: number;
        nillable: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IObjectMappingElement = {
        load(): exportmappings$ObjectMappingElement,
        load(callback: (element: exportmappings$ObjectMappingElement) => void): any
    } & importmappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ObjectMappingElement mixins mappings$MappingElement, IObjectMappingElement {
        typeName: string;
        mappingMicroflowCall: mappings$MappingMicroflowCall;
        children: instances$IList<mappings$MappingElement>;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        objectHandling: importmappings$ObjectHandlingEnum;
        objectHandlingBackup: importmappings$ObjectHandlingBackupEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IImportObjectMappingElement = {
        load(): importmappings$ImportObjectMappingElement,
        load(callback: (element: importmappings$ImportObjectMappingElement) => void): any
    }

    declare class ImportObjectMappingElement mixins mappings$ObjectMappingElement, IImportObjectMappingElement {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IValueMappingElement = {
        container: importmappings$IObjectMappingElement,
        load(): exportmappings$ValueMappingElement,
        load(callback: (element: exportmappings$ValueMappingElement) => void): any
    } & importmappings$IMappingElement



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ValueMappingElement mixins mappings$MappingElement, IValueMappingElement {
        typeName: string;
        container: mappings$ObjectMappingElement;
        xmlDataType: string;
        isKey: boolean;
        isXmlAttribute: boolean;
        isContent: boolean;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        converter: microflows$IMicroflow;
        converterQualifiedName: string;
        expectedContentTypes: string;
        maxLength: number;
        fractionDigits: number;
        totalDigits: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type importmappings$IImportValueMappingElement = {
        container: mappings$IObjectMappingElement,
        load(): importmappings$ImportValueMappingElement,
        load(callback: (element: importmappings$ImportValueMappingElement) => void): any
    }

    declare class ImportValueMappingElement mixins mappings$ValueMappingElement, IImportValueMappingElement {
        typeName: string;
        container: mappings$ObjectMappingElement;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class ObjectHandlingBackupEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Create: importmappings$ObjectHandlingBackupEnum;
        Ignore: importmappings$ObjectHandlingBackupEnum;
        Error: importmappings$ObjectHandlingBackupEnum
    }

    declare class ObjectHandlingEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Create: importmappings$ObjectHandlingEnum;
        Find: importmappings$ObjectHandlingEnum;
        Custom: importmappings$ObjectHandlingEnum
    }
    declare type rest$IModuleDocument = {
        container: projects$IFolderBase,
        load(): importmappings$ModuleDocument,
        load(callback: (element: importmappings$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type rest$IDocument = {
        container: projects$IFolderBase,
        load(): importmappings$Document,
        load(callback: (element: importmappings$Document) => void): any,
        name: string
    } & rest$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type rest$IPublishedRestServiceBase = {
        container: projects$IFolderBase,
        load(): rest$PublishedRestServiceBase,
        load(callback: (element: rest$PublishedRestServiceBase) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class PublishedRestServiceBase mixins projects$Document, IPublishedRestServiceBase {
        typeName: string;
        container: projects$FolderBase;
        resources: instances$IList<rest$PublishedRestResource>;
        namespaceName: string;
        path: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type rest$IPublishedOdataService = {
        container: projects$IFolderBase,
        load(): rest$PublishedOdataService,
        load(callback: (element: rest$PublishedOdataService) => void): any
    } & rest$IPublishedRestServiceBase


    declare class PublishedOdataService mixins PublishedRestServiceBase, IPublishedOdataService {
        typeName: string;
        container: projects$FolderBase;
        allowedRoleIds: instances$IList<security$IModuleRole>;
        allowedRoleIdsQualifiedNames: string[];
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type rest$IPublishedRestResource = {
        container: rest$IPublishedRestServiceBase,
        load(): rest$PublishedRestResource,
        load(callback: (element: rest$PublishedRestResource) => void): any
    }

    declare class PublishedRestResource mixins elements$Element, IPublishedRestResource {
        typeName: string;
        container: rest$PublishedRestServiceBase;
        dataEntity: webservices$DataEntity;
        path: string;
        usePaging: boolean;
        pageSize: number;
        returnType: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type rest$IPublishedRestService = {
        container: projects$IFolderBase,
        load(): rest$PublishedRestService,
        load(callback: (element: rest$PublishedRestService) => void): any
    } & rest$IPublishedRestServiceBase


    declare class PublishedRestService mixins PublishedRestServiceBase, IPublishedRestService {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type settings$ICertificate = {
        container: settings$IProjectSettings,
        load(): settings$Certificate,
        load(callback: (element: settings$Certificate) => void): any
    }

    declare class Certificate mixins elements$Element, ICertificate {
        typeName: string;
        container: settings$ProjectSettings;
        type: settings$CertificateType;
        data: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type settings$IConstantValue = {
        container: settings$IServerConfiguration,
        load(): settings$ConstantValue,
        load(callback: (element: settings$ConstantValue) => void): any
    }

    declare class ConstantValue mixins elements$Element, IConstantValue {
        typeName: string;
        container: settings$ServerConfiguration;
        constant: constants$IConstant;
        constantQualifiedName: string;
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type settings$ICustomSetting = {
        container: settings$IServerConfiguration,
        load(): settings$CustomSetting,
        load(callback: (element: settings$CustomSetting) => void): any
    }

    declare class CustomSetting mixins elements$Element, ICustomSetting {
        typeName: string;
        container: settings$ServerConfiguration;
        name: string;
        value: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type settings$IProjectSettingsPart = {
        container: settings$IProjectSettings,
        load(): pages$ProjectSettingsPart,
        load(callback: (element: pages$ProjectSettingsPart) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectSettingsPart mixins elements$Element, IProjectSettingsPart {
        typeName: string;
        container: settings$ProjectSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type settings$IIntegrationProjectSettingsPart = {
        container: settings$IProjectSettings,
        load(): settings$IntegrationProjectSettingsPart,
        load(callback: (element: settings$IntegrationProjectSettingsPart) => void): any
    } & settings$IProjectSettingsPart


    declare class IntegrationProjectSettingsPart mixins ProjectSettingsPart, IIntegrationProjectSettingsPart {
        typeName: string;
        container: settings$ProjectSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type settings$IProjectDocument = {
        container: projects$IProject,
        load(): projects$ProjectDocument,
        load(callback: (element: projects$ProjectDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectDocument mixins units$ModelUnit, IProjectDocument {
        typeName: string;
        container: projects$Project;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Settings relevant section in reference guide}
     */
    declare type settings$IProjectSettings = {
        container: projects$IProject,
        load(): settings$ProjectSettings,
        load(callback: (element: settings$ProjectSettings) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Settings relevant section in reference guide}
     */
    declare class ProjectSettings mixins projects$ProjectDocument, IProjectSettings {
        typeName: string;
        container: projects$Project;
        languages: instances$IList<texts$Language>;
        settingsParts: instances$IList<settings$ProjectSettingsPart>;
        configurations: instances$IList<settings$ServerConfiguration>;
        certificates: instances$IList<settings$Certificate>;
        hashAlgorithm: projects$HashAlgorithmType;
        roundingMode: settings$RoundingMode;
        conversionState: projects$ConversionState;
        skipJarAnalyzerStep: boolean;
        afterStartupMicroflow: microflows$IMicroflow;
        afterStartupMicroflowQualifiedName: string;
        beforeShutdownMicroflow: microflows$IMicroflow;
        beforeShutdownMicroflowQualifiedName: string;
        healthCheckMicroflow: microflows$IMicroflow;
        healthCheckMicroflowQualifiedName: string;
        defaultLanguageCode: string;
        firstDayOfWeek: settings$FirstDayOfWeekEnum;
        defaultTimeZoneCode: string;
        scheduledEventTimeZoneCode: string;
        allowUserMultipleSessions: boolean;
        lowerCaseMicroflowVariables: boolean;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type settings$IServerConfiguration = {
        container: settings$IProjectSettings,
        load(): settings$ServerConfiguration,
        load(callback: (element: settings$ServerConfiguration) => void): any
    }

    declare class ServerConfiguration mixins elements$Element, IServerConfiguration {
        typeName: string;
        container: settings$ProjectSettings;
        customSettings: instances$IList<settings$CustomSetting>;
        constantValues: instances$IList<settings$ConstantValue>;
        name: string;
        applicationRootUrl: string;
        portOnlyLocal: boolean;
        adminPortOnlyLocal: boolean;
        portNumber: number;
        adminPortNumber: number;
        maxJavaHeapSize: number;
        emulateCloudSecurity: boolean;
        extraJvmParameters: string;
        databaseType: settings$DatabaseType;
        databaseUrl: string;
        databaseName: string;
        databaseUseIntegratedSecurity: boolean;
        databaseUserName: string;
        databasePassword: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class CertificateType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Authority: settings$CertificateType;
        Client: settings$CertificateType
    }

    declare class DatabaseType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Hsqldb: settings$DatabaseType;
        SqlServer: settings$DatabaseType;
        MySql: settings$DatabaseType;
        Oracle: settings$DatabaseType;
        PostgreSql: settings$DatabaseType
    }

    declare class FirstDayOfWeekEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: settings$FirstDayOfWeekEnum;
        Sunday: settings$FirstDayOfWeekEnum;
        Monday: settings$FirstDayOfWeekEnum;
        Tuesday: settings$FirstDayOfWeekEnum;
        Wednesday: settings$FirstDayOfWeekEnum;
        Thursday: settings$FirstDayOfWeekEnum;
        Friday: settings$FirstDayOfWeekEnum;
        Saturday: settings$FirstDayOfWeekEnum
    }

    declare class RoundingMode mixins instances$IEnum {
        qualifiedTsTypeName: string;
        HalfUp: settings$RoundingMode;
        HalfEven: settings$RoundingMode
    }
    declare type pages$IModuleDocument = {
        container: projects$IFolderBase,
        load(): rest$ModuleDocument,
        load(callback: (element: rest$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IDocument = {
        container: projects$IFolderBase,
        load(): rest$Document,
        load(callback: (element: rest$Document) => void): any,
        name: string
    } & pages$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     */
    declare type pages$IFormBase = {
        container: projects$IFolderBase,
        load(): pages$FormBase,
        load(callback: (element: pages$FormBase) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class FormBase mixins projects$Document, IFormBase {
        typeName: string;
        container: projects$FolderBase;
        canvasWidth: number;
        canvasHeight: number;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page relevant section in reference guide}
     */
    declare type pages$IPage = {
        container: projects$IFolderBase,
        load(): pages$Page,
        load(callback: (element: pages$Page) => void): any
    } & pages$IFormBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page relevant section in reference guide}
     */
    declare class Page mixins FormBase, IPage {
        typeName: string;
        container: projects$FolderBase;
        layoutCall: pages$LayoutCall;
        title: texts$Text;
        class: string;
        style: string;
        allowedRoles: instances$IList<security$IModuleRole>;
        allowedRolesQualifiedNames: string[];
        popupWidth: number;
        popupHeight: number;
        popupResizable: boolean;
        markAsUsed: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Layout relevant section in reference guide}
     */
    declare type pages$ILayout = {
        container: projects$IFolderBase,
        load(): pages$Layout,
        load(callback: (element: pages$Layout) => void): any
    } & pages$IFormBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Layout relevant section in reference guide}
     */
    declare class Layout mixins FormBase, ILayout {
        typeName: string;
        container: projects$FolderBase;
        widget: reports$Widget;
        layoutCall: pages$LayoutCall;
        layoutType: pages$LayoutType;
        mainPlaceholder: pages$ILayoutParameter;
        mainPlaceholderQualifiedName: string;
        acceptButtonPlaceholder: pages$ILayoutParameter;
        acceptButtonPlaceholderQualifiedName: string;
        cancelButtonPlaceholder: pages$ILayoutParameter;
        cancelButtonPlaceholderQualifiedName: string;
        useMainPlaceholderForPopups: boolean;
        class: string;
        style: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ILayoutCall = {
        load(): pages$LayoutCall,
        load(callback: (element: pages$LayoutCall) => void): any
    }

    declare class LayoutCall mixins elements$Element, ILayoutCall {
        typeName: string;
        layout: pages$ILayout;
        layoutQualifiedName: string;
        arguments: instances$IList<pages$LayoutCallArgument>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ILayoutCallArgument = {
        container: pages$ILayoutCall,
        load(): pages$LayoutCallArgument,
        load(callback: (element: pages$LayoutCallArgument) => void): any
    }

    declare class LayoutCallArgument mixins elements$Element, ILayoutCallArgument {
        typeName: string;
        container: pages$LayoutCall;
        parameterName: string;
        widget: reports$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ILayoutParameter = {
        container: pages$ILayout,
        load(): pages$LayoutParameter,
        load(callback: (element: pages$LayoutParameter) => void): any,
        name: string
    }

    declare class LayoutParameter mixins elements$Element, ILayoutParameter {
        typeName: string;
        container: pages$Layout;
        name: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     */
    declare type pages$IWidget = {
        load(): reports$Widget,
        load(callback: (element: reports$Widget) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Widget mixins elements$Element, IWidget {
        typeName: string;
        name: string;
        class: string;
        style: string;
        tabIndex: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Placeholder relevant section in reference guide}
     */
    declare type pages$IPlaceholder = {
        load(): pages$Placeholder,
        load(callback: (element: pages$Placeholder) => void): any
    } & pages$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Placeholder relevant section in reference guide}
     */
    declare class Placeholder mixins Widget, IPlaceholder {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IClientAction = {
        load(): pages$ClientAction,
        load(callback: (element: pages$ClientAction) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ClientAction mixins elements$Element, IClientAction {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$INoClientAction = {
        load(): pages$NoClientAction,
        load(callback: (element: pages$NoClientAction) => void): any
    } & pages$IClientAction


    declare class NoClientAction mixins ClientAction, INoClientAction {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IPageClientAction = {
        load(): pages$PageClientAction,
        load(callback: (element: pages$PageClientAction) => void): any
    } & pages$IClientAction


    declare class PageClientAction mixins ClientAction, IPageClientAction {
        typeName: string;
        pageSettings: pages$PageSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IMicroflowClientAction = {
        load(): pages$MicroflowClientAction,
        load(callback: (element: pages$MicroflowClientAction) => void): any
    } & pages$IClientAction


    declare class MicroflowClientAction mixins ClientAction, IMicroflowClientAction {
        typeName: string;
        microflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Opening+Pages relevant section in reference guide}
     */
    declare type pages$IPageSettings = {
        load(): pages$PageSettings,
        load(callback: (element: pages$PageSettings) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Opening+Pages relevant section in reference guide}
     */
    declare class PageSettings mixins elements$Element, IPageSettings {
        typeName: string;
        page: pages$IPage;
        pageQualifiedName: string;
        formTitle: texts$Text;
        location: pages$FormLocation;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Starting+Microflows relevant section in reference guide}
     */
    declare type pages$IMicroflowSettings = {
        load(): pages$MicroflowSettings,
        load(callback: (element: pages$MicroflowSettings) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Starting+Microflows relevant section in reference guide}
     */
    declare class MicroflowSettings mixins elements$Element, IMicroflowSettings {
        typeName: string;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        useAllPages: boolean;
        progressBar: pages$ProgressBarType;
        progressMessage: texts$Text;
        asynchronous: boolean;
        formValidations: pages$FormValidations;
        confirmationInfo: pages$ConfirmationInfo;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConfirmationInfo = {
        container: pages$IMicroflowSettings,
        load(): pages$ConfirmationInfo,
        load(callback: (element: pages$ConfirmationInfo) => void): any
    }

    declare class ConfirmationInfo mixins elements$Element, IConfirmationInfo {
        typeName: string;
        container: pages$MicroflowSettings;
        question: texts$Text;
        proceedButtonCaption: texts$Text;
        cancelButtonCaption: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConditionallyVisibleWidget = {
        load(): pages$ConditionallyVisibleWidget,
        load(callback: (element: pages$ConditionallyVisibleWidget) => void): any
    } & pages$IWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ConditionallyVisibleWidget mixins Widget, IConditionallyVisibleWidget {
        typeName: string;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Label relevant section in reference guide}
     */
    declare type pages$ILabel = {
        load(): pages$Label,
        load(callback: (element: pages$Label) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Label relevant section in reference guide}
     */
    declare class Label mixins ConditionallyVisibleWidget, ILabel {
        typeName: string;
        caption: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image relevant section in reference guide}
     */
    declare type pages$IStaticImageViewer = {
        load(): documenttemplates$StaticImageViewer,
        load(callback: (element: documenttemplates$StaticImageViewer) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image relevant section in reference guide}
     */
    declare class StaticImageViewer mixins ConditionallyVisibleWidget, IStaticImageViewer {
        typeName: string;
        image: images$IImage;
        imageQualifiedName: string;
        widthUnit: pages$ImageSizeUnit;
        heightUnit: pages$ImageSizeUnit;
        width: number;
        height: number;
        clickAction: pages$ClientAction;
        responsive: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Container relevant section in reference guide}
     */
    declare type pages$IDivContainer = {
        load(): pages$DivContainer,
        load(callback: (element: pages$DivContainer) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Container relevant section in reference guide}
     */
    declare class DivContainer mixins ConditionallyVisibleWidget, IDivContainer {
        typeName: string;
        widget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IVerticalFlow = {
        load(): pages$VerticalFlow,
        load(callback: (element: pages$VerticalFlow) => void): any
    } & pages$IWidget


    declare class VerticalFlow mixins Widget, IVerticalFlow {
        typeName: string;
        widgets: instances$IList<pages$Widget>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConditionallyEditableWidget = {
        load(): pages$ConditionallyEditableWidget,
        load(callback: (element: pages$ConditionallyEditableWidget) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ConditionallyEditableWidget mixins ConditionallyVisibleWidget, IConditionallyEditableWidget {
        typeName: string;
        conditionalEditabilitySettings: pages$ConditionalEditabilitySettings;
        editable: pages$EditableEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IInputWidget = {
        load(): pages$InputWidget,
        load(callback: (element: pages$InputWidget) => void): any
    } & pages$IConditionallyEditableWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class InputWidget mixins ConditionallyEditableWidget, IInputWidget {
        typeName: string;
        label: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IMemberWidget = {
        load(): pages$MemberWidget,
        load(callback: (element: pages$MemberWidget) => void): any
    } & pages$IInputWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MemberWidget mixins InputWidget, IMemberWidget {
        typeName: string;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IAttributeWidget = {
        load(): documenttemplates$AttributeWidget,
        load(callback: (element: documenttemplates$AttributeWidget) => void): any
    } & pages$IMemberWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AttributeWidget mixins MemberWidget, IAttributeWidget {
        typeName: string;
        required: boolean;
        requiredMessage: texts$Text;
        onChangeMicroflowSettings: pages$MicroflowSettings;
        onEnterMicroflowSettings: pages$MicroflowSettings;
        onLeaveMicroflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IAttributeWidgetWithPlaceholder = {
        load(): pages$AttributeWidgetWithPlaceholder,
        load(callback: (element: pages$AttributeWidgetWithPlaceholder) => void): any
    } & pages$IAttributeWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AttributeWidgetWithPlaceholder mixins AttributeWidget, IAttributeWidgetWithPlaceholder {
        typeName: string;
        placeholder: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ITextWidget = {
        load(): pages$TextWidget,
        load(callback: (element: pages$TextWidget) => void): any
    } & pages$IAttributeWidgetWithPlaceholder



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class TextWidget mixins AttributeWidgetWithPlaceholder, ITextWidget {
        typeName: string;
        maxLengthCode: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text+Box relevant section in reference guide}
     */
    declare type pages$ITextBox = {
        load(): pages$TextBox,
        load(callback: (element: pages$TextBox) => void): any
    } & pages$ITextWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text+Box relevant section in reference guide}
     */
    declare class TextBox mixins TextWidget, ITextBox {
        typeName: string;
        inputMask: string;
        formattingInfo: pages$FormattingInfo;
        isPasswordBox: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text+Area relevant section in reference guide}
     */
    declare type pages$ITextArea = {
        load(): pages$TextArea,
        load(callback: (element: pages$TextArea) => void): any
    } & pages$ITextWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text+Area relevant section in reference guide}
     */
    declare class TextArea mixins TextWidget, ITextArea {
        typeName: string;
        numberOfLines: number;
        counterMessage: texts$Text;
        textTooLongMessage: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Check+Box relevant section in reference guide}
     */
    declare type pages$ICheckBox = {
        load(): pages$CheckBox,
        load(callback: (element: pages$CheckBox) => void): any
    } & pages$IAttributeWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Check+Box relevant section in reference guide}
     */
    declare class CheckBox mixins AttributeWidget, ICheckBox {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Picker relevant section in reference guide}
     */
    declare type pages$IDatePicker = {
        load(): pages$DatePicker,
        load(callback: (element: pages$DatePicker) => void): any
    } & pages$IAttributeWidgetWithPlaceholder



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Picker relevant section in reference guide}
     */
    declare class DatePicker mixins AttributeWidgetWithPlaceholder, IDatePicker {
        typeName: string;
        formattingInfo: pages$FormattingInfo;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IFormattingInfo = {
        load(): pages$FormattingInfo,
        load(callback: (element: pages$FormattingInfo) => void): any
    }

    declare class FormattingInfo mixins elements$Element, IFormattingInfo {
        typeName: string;
        decimalPrecision: number;
        groupDigits: boolean;
        enumFormat: pages$EnumFormat;
        dateFormat: pages$DateFormat;
        customDateFormat: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConditionalSettings = {
        load(): pages$ConditionalSettings,
        load(callback: (element: pages$ConditionalSettings) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ConditionalSettings mixins elements$Element, IConditionalSettings {
        typeName: string;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        conditions: instances$IList<enumerations$Condition>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConditionalVisibilitySettings = {
        load(): pages$ConditionalVisibilitySettings,
        load(callback: (element: pages$ConditionalVisibilitySettings) => void): any
    } & pages$IConditionalSettings


    declare class ConditionalVisibilitySettings mixins ConditionalSettings, IConditionalVisibilitySettings {
        typeName: string;
        moduleRoles: instances$IList<security$IModuleRole>;
        moduleRolesQualifiedNames: string[];
        ignoreSecurity: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IConditionalEditabilitySettings = {
        container: pages$IConditionallyEditableWidget,
        load(): pages$ConditionalEditabilitySettings,
        load(callback: (element: pages$ConditionalEditabilitySettings) => void): any
    } & pages$IConditionalSettings


    declare class ConditionalEditabilitySettings mixins ConditionalSettings, IConditionalEditabilitySettings {
        typeName: string;
        container: pages$ConditionallyEditableWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Table relevant section in reference guide}
     */
    declare type pages$ITable = {
        load(): pages$Table,
        load(callback: (element: pages$Table) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Table relevant section in reference guide}
     */
    declare class Table mixins ConditionallyVisibleWidget, ITable {
        typeName: string;
        cells: instances$IList<pages$TableCell>;
        columns: instances$IList<pages$TableColumn>;
        widthUnit: pages$UnitEnum;
        rows: instances$IList<pages$TableRow>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ITableCell = {
        container: pages$ITable,
        load(): pages$TableCell,
        load(callback: (element: pages$TableCell) => void): any
    }

    declare class TableCell mixins elements$Element, ITableCell {
        typeName: string;
        container: pages$Table;
        class: string;
        style: string;
        isHeader: boolean;
        widget: pages$Widget;
        leftColumnIndex: number;
        topRowIndex: number;
        width: number;
        height: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ITableColumn = {
        container: pages$ITable,
        load(): pages$TableColumn,
        load(callback: (element: pages$TableColumn) => void): any
    }

    declare class TableColumn mixins elements$Element, ITableColumn {
        typeName: string;
        container: pages$Table;
        width: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ITableRow = {
        container: pages$ITable,
        load(): pages$TableRow,
        load(callback: (element: pages$TableRow) => void): any
    }

    declare class TableRow mixins elements$Element, ITableRow {
        typeName: string;
        container: pages$Table;
        class: string;
        style: string;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IEntityWidget = {
        load(): documenttemplates$EntityWidget,
        load(callback: (element: documenttemplates$EntityWidget) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class EntityWidget mixins ConditionallyVisibleWidget, IEntityWidget {
        typeName: string;
        dataSource: pages$DataSource;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Sources relevant section in reference guide}
     */
    declare type pages$IDataSource = {
        container: pages$IEntityWidget,
        load(): pages$DataSource,
        load(callback: (element: pages$DataSource) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Sources relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataSource mixins elements$Element, IDataSource {
        typeName: string;
        container: pages$EntityWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IEntityPathSource = {
        container: pages$IEntityWidget,
        load(): pages$EntityPathSource,
        load(callback: (element: pages$EntityPathSource) => void): any
    } & pages$IDataSource



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class EntityPathSource mixins DataSource, IEntityPathSource {
        typeName: string;
        container: pages$EntityWidget;

        /**
         * The value of this property is conceptually of type Paths$EntityPath.
         */
        entityPath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IMicroflowSource = {
        container: pages$IEntityWidget,
        load(): pages$MicroflowSource,
        load(callback: (element: pages$MicroflowSource) => void): any
    } & pages$IDataSource


    declare class MicroflowSource mixins DataSource, IMicroflowSource {
        typeName: string;
        container: pages$EntityWidget;
        microflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IListenTargetWidget = {
        load(): pages$ListenTargetWidget,
        load(callback: (element: pages$ListenTargetWidget) => void): any
    } & pages$IEntityWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ListenTargetWidget mixins EntityWidget, IListenTargetWidget {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IAssociationSource = {
        container: pages$IEntityWidget,
        load(): pages$AssociationSource,
        load(callback: (element: pages$AssociationSource) => void): any
    } & pages$IEntityPathSource


    declare class AssociationSource mixins EntityPathSource, IAssociationSource {
        typeName: string;
        container: pages$EntityWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View relevant section in reference guide}
     */
    declare type pages$IDataView = {
        load(): pages$DataView,
        load(callback: (element: pages$DataView) => void): any
    } & pages$IEntityWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View relevant section in reference guide}
     */
    declare class DataView mixins EntityWidget, IDataView {
        typeName: string;
        widget: pages$Widget;
        editable: boolean;
        showControlBar: boolean;
        closeOnSaveOrCancel: boolean;
        useSchema: boolean;
        noEntityMessage: texts$Text;
        labelWidth: number;
        controlBar: pages$DataViewControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IControlBar = {
        load(): pages$ControlBar,
        load(callback: (element: pages$ControlBar) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ControlBar mixins elements$Element, IControlBar {
        typeName: string;
        items: instances$IList<pages$ControlBarItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Control+Bar relevant section in reference guide}
     */
    declare type pages$IDataViewControlBar = {
        container: pages$IDataView,
        load(): pages$DataViewControlBar,
        load(callback: (element: pages$DataViewControlBar) => void): any
    } & pages$IControlBar



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Control+Bar relevant section in reference guide}
     */
    declare class DataViewControlBar mixins ControlBar, IDataViewControlBar {
        typeName: string;
        container: pages$DataView;
        closeButton: pages$ControlBarItem;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IDataViewSource = {
        container: pages$IEntityWidget,
        load(): pages$DataViewSource,
        load(callback: (element: pages$DataViewSource) => void): any
    } & pages$IEntityPathSource


    declare class DataViewSource mixins EntityPathSource, IDataViewSource {
        typeName: string;
        container: pages$EntityWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IListenTargetSource = {
        container: pages$IEntityWidget,
        load(): pages$ListenTargetSource,
        load(callback: (element: pages$ListenTargetSource) => void): any
    } & pages$IDataSource


    declare class ListenTargetSource mixins DataSource, IListenTargetSource {
        typeName: string;
        container: pages$EntityWidget;
        listenTarget: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IControlBarItem = {
        load(): pages$ControlBarItem,
        load(callback: (element: pages$ControlBarItem) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ControlBarItem mixins elements$Element, IControlBarItem {
        typeName: string;
        name: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IControlBarButton = {
        load(): pages$ControlBarButton,
        load(callback: (element: pages$ControlBarButton) => void): any
    } & pages$IControlBarItem



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ControlBarButton mixins ControlBarItem, IControlBarButton {
        typeName: string;
        caption: pages$ClientTemplate;
        tooltip: texts$Text;
        icon: pages$Icon;
        class: string;
        style: string;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        buttonStyle: pages$ButtonStyle;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IDataViewControlBarButton = {
        container: pages$IControlBar,
        load(): pages$DataViewControlBarButton,
        load(callback: (element: pages$DataViewControlBarButton) => void): any
    } & pages$IControlBarButton



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataViewControlBarButton mixins ControlBarButton, IDataViewControlBarButton {
        typeName: string;
        container: pages$ControlBar;
        tabIndex: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Cancel+Button relevant section in reference guide}
     */
    declare type pages$IDataViewCancelButton = {
        container: pages$IControlBar,
        load(): pages$DataViewCancelButton,
        load(callback: (element: pages$DataViewCancelButton) => void): any
    } & pages$IDataViewControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Cancel+Button relevant section in reference guide}
     */
    declare class DataViewCancelButton mixins DataViewControlBarButton, IDataViewCancelButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Close+Button relevant section in reference guide}
     */
    declare type pages$IDataViewCloseButton = {
        container: pages$IControlBar,
        load(): pages$DataViewCloseButton,
        load(callback: (element: pages$DataViewCloseButton) => void): any
    } & pages$IDataViewControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Close+Button relevant section in reference guide}
     */
    declare class DataViewCloseButton mixins DataViewControlBarButton, IDataViewCloseButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+view+action+button relevant section in reference guide}
     */
    declare type pages$IDataViewActionButton = {
        container: pages$IControlBar,
        load(): pages$DataViewActionButton,
        load(callback: (element: pages$DataViewActionButton) => void): any
    } & pages$IDataViewControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+view+action+button relevant section in reference guide}
     */
    declare class DataViewActionButton mixins DataViewControlBarButton, IDataViewActionButton {
        typeName: string;
        container: pages$ControlBar;
        action: pages$ClientAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Save+Button relevant section in reference guide}
     */
    declare type pages$IDataViewSaveButton = {
        container: pages$IControlBar,
        load(): pages$DataViewSaveButton,
        load(callback: (element: pages$DataViewSaveButton) => void): any
    } & pages$IDataViewControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+Save+Button relevant section in reference guide}
     */
    declare class DataViewSaveButton mixins DataViewControlBarButton, IDataViewSaveButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/List+View relevant section in reference guide}
     */
    declare type pages$IListView = {
        load(): pages$ListView,
        load(callback: (element: pages$ListView) => void): any
    } & pages$IListenTargetWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/List+View relevant section in reference guide}
     */
    declare class ListView mixins ListenTargetWidget, IListView {
        typeName: string;
        widget: pages$Widget;
        pageSize: number;
        clickAction: pages$ClientAction;
        editable: boolean;
        templates: instances$IList<pages$ListViewTemplate>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IListViewTemplate = {
        container: pages$IListView,
        load(): pages$ListViewTemplate,
        load(callback: (element: pages$ListViewTemplate) => void): any
    }

    declare class ListViewTemplate mixins elements$Element, IListViewTemplate {
        typeName: string;
        container: pages$ListView;
        specialization: domainmodels$IEntity;
        specializationQualifiedName: string;
        widget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IListViewDatabaseSource = {
        container: pages$IEntityWidget,
        load(): pages$ListViewDatabaseSource,
        load(callback: (element: pages$ListViewDatabaseSource) => void): any
    } & pages$IEntityPathSource


    declare class ListViewDatabaseSource mixins EntityPathSource, IListViewDatabaseSource {
        typeName: string;
        container: pages$EntityWidget;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        searchPaths: instances$IList<string>;
        sortBar: pages$GridSortBar;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sort+Bar relevant section in reference guide}
     */
    declare type pages$IGridSortBar = {
        load(): pages$GridSortBar,
        load(callback: (element: pages$GridSortBar) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sort+Bar relevant section in reference guide}
     */
    declare class GridSortBar mixins elements$Element, IGridSortBar {
        typeName: string;
        sortItems: instances$IList<pages$GridSortItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IGridSortItem = {
        container: pages$IGridSortBar,
        load(): pages$GridSortItem,
        load(callback: (element: pages$GridSortItem) => void): any
    }

    declare class GridSortItem mixins elements$Element, IGridSortItem {
        typeName: string;
        container: pages$GridSortBar;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        sortDirection: pages$SortDirection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Button+Widgets relevant section in reference guide}
     */
    declare type pages$IButton = {
        load(): pages$Button,
        load(callback: (element: pages$Button) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Button+Widgets relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Button mixins ConditionallyVisibleWidget, IButton {
        typeName: string;
        caption: pages$ClientTemplate;
        tooltip: texts$Text;
        icon: pages$Icon;
        renderType: pages$RenderType;
        buttonStyle: pages$ButtonStyle;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IStaticOrDynamicString = {
        container: pages$ILinkButton,
        load(): pages$StaticOrDynamicString,
        load(callback: (element: pages$StaticOrDynamicString) => void): any
    }

    declare class StaticOrDynamicString mixins elements$Element, IStaticOrDynamicString {
        typeName: string;
        container: pages$LinkButton;
        isDynamic: boolean;
        value: string;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attribute: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Back+Button relevant section in reference guide}
     */
    declare type pages$IBackButton = {
        load(): pages$BackButton,
        load(callback: (element: pages$BackButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Back+Button relevant section in reference guide}
     */
    declare class BackButton mixins Button, IBackButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cancel+Button relevant section in reference guide}
     */
    declare type pages$ICancelButton = {
        load(): pages$CancelButton,
        load(callback: (element: pages$CancelButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cancel+Button relevant section in reference guide}
     */
    declare class CancelButton mixins Button, ICancelButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sign+Out+Button relevant section in reference guide}
     */
    declare type pages$ILogoutButton = {
        load(): pages$LogoutButton,
        load(callback: (element: pages$LogoutButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sign+Out+Button relevant section in reference guide}
     */
    declare class LogoutButton mixins Button, ILogoutButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Action+Button relevant section in reference guide}
     */
    declare type pages$IActionButton = {
        load(): pages$ActionButton,
        load(callback: (element: pages$ActionButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Action+Button relevant section in reference guide}
     */
    declare class ActionButton mixins Button, IActionButton {
        typeName: string;
        action: pages$ClientAction;
        disabledDuringAction: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/New+Button relevant section in reference guide}
     */
    declare type pages$INewButton = {
        load(): pages$NewButton,
        load(callback: (element: pages$NewButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/New+Button relevant section in reference guide}
     */
    declare class NewButton mixins Button, INewButton {
        typeName: string;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        pageSettings: pages$PageSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Save+Button relevant section in reference guide}
     */
    declare type pages$ISaveButton = {
        load(): pages$SaveButton,
        load(callback: (element: pages$SaveButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Save+Button relevant section in reference guide}
     */
    declare class SaveButton mixins Button, ISaveButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IClientTemplate = {
        load(): pages$ClientTemplate,
        load(callback: (element: pages$ClientTemplate) => void): any
    }

    declare class ClientTemplate mixins elements$Element, IClientTemplate {
        typeName: string;
        template: texts$Text;
        parameters: instances$IList<pages$ClientTemplateParameter>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IClientTemplateParameter = {
        container: pages$IClientTemplate,
        load(): pages$ClientTemplateParameter,
        load(callback: (element: pages$ClientTemplateParameter) => void): any
    }

    declare class ClientTemplateParameter mixins elements$Element, IClientTemplateParameter {
        typeName: string;
        container: pages$ClientTemplate;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IGrid = {
        load(): pages$Grid,
        load(callback: (element: pages$Grid) => void): any
    } & pages$IListenTargetWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Grid mixins ListenTargetWidget, IGrid {
        typeName: string;
        isControlBarVisible: boolean;
        isPagingEnabled: boolean;
        selectionMode: pages$GridSelectionMode;
        selectFirst: boolean;
        defaultButtonTrigger: pages$ClickTypeType;
        refreshTime: number;
        controlBar: pages$GridControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IColumnGrid = {
        load(): pages$ColumnGrid,
        load(callback: (element: pages$ColumnGrid) => void): any
    } & pages$IGrid



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ColumnGrid mixins Grid, IColumnGrid {
        typeName: string;
        columns: instances$IList<pages$GridColumn>;
        numberOfRows: number;
        showEmptyRows: boolean;
        widthUnit: pages$UnitEnum;
        tooltipPage: pages$IPage;
        tooltipPageQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISearchField = {
        container: pages$IControlBar,
        load(): pages$SearchField,
        load(callback: (element: pages$SearchField) => void): any
    } & pages$IControlBarItem



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class SearchField mixins ControlBarItem, ISearchField {
        typeName: string;
        container: pages$ControlBar;
        caption: texts$Text;
        type: pages$SearchFieldType;
        defaultValue: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISingleSearchField = {
        container: pages$IControlBar,
        load(): pages$SingleSearchField,
        load(callback: (element: pages$SingleSearchField) => void): any
    } & pages$ISearchField



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class SingleSearchField mixins SearchField, ISingleSearchField {
        typeName: string;
        container: pages$ControlBar;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        operator: pages$SearchFieldOperator;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Comparison+Search+Field relevant section in reference guide}
     */
    declare type pages$IComparisonSearchField = {
        container: pages$IControlBar,
        load(): pages$ComparisonSearchField,
        load(callback: (element: pages$ComparisonSearchField) => void): any
    } & pages$ISingleSearchField



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Comparison+Search+Field relevant section in reference guide}
     */
    declare class ComparisonSearchField mixins SingleSearchField, IComparisonSearchField {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IGridBaseSource = {
        container: pages$IEntityWidget,
        load(): pages$GridBaseSource,
        load(callback: (element: pages$GridBaseSource) => void): any
    } & pages$IEntityPathSource



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class GridBaseSource mixins EntityPathSource, IGridBaseSource {
        typeName: string;
        container: pages$EntityWidget;
        sortBar: pages$GridSortBar;
        searchBar: pages$SearchBar;
        searchBarType: pages$SearchBarTypeEnum;
        waitForSearch: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IGridDatabaseSource = {
        container: pages$IEntityWidget,
        load(): pages$GridDatabaseSource,
        load(callback: (element: pages$GridDatabaseSource) => void): any
    } & pages$IGridBaseSource


    declare class GridDatabaseSource mixins GridBaseSource, IGridDatabaseSource {
        typeName: string;
        container: pages$EntityWidget;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        applyContext: boolean;
        removeAllFromContext: boolean;
        removeFromContextIds: instances$IList<domainmodels$IEntity>;
        removeFromContextIdsQualifiedNames: string[];
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Grid relevant section in reference guide}
     */
    declare type pages$IDataGrid = {
        load(): pages$DataGrid,
        load(callback: (element: pages$DataGrid) => void): any
    } & pages$IColumnGrid



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Grid relevant section in reference guide}
     */
    declare class DataGrid mixins ColumnGrid, IDataGrid {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IGridControlBarButton = {
        load(): pages$GridControlBarButton,
        load(callback: (element: pages$GridControlBarButton) => void): any
    } & pages$IControlBarButton



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class GridControlBarButton mixins ControlBarButton, IGridControlBarButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Add+Button relevant section in reference guide}
     */
    declare type pages$IDataGridAddButton = {
        container: pages$IControlBar,
        load(): pages$DataGridAddButton,
        load(callback: (element: pages$DataGridAddButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Add+Button relevant section in reference guide}
     */
    declare class DataGridAddButton mixins GridControlBarButton, IDataGridAddButton {
        typeName: string;
        container: pages$ControlBar;
        pageSettings: pages$PageSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+To+CSV+Button relevant section in reference guide}
     */
    declare type pages$IDataGridExportToCSVButton = {
        container: pages$IControlBar,
        load(): pages$DataGridExportToCSVButton,
        load(callback: (element: pages$DataGridExportToCSVButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+To+CSV+Button relevant section in reference guide}
     */
    declare class DataGridExportToCSVButton mixins GridControlBarButton, IDataGridExportToCSVButton {
        typeName: string;
        container: pages$ControlBar;
        maxNumberOfRows: number;
        decimalSeparator: string;
        groupSeparator: string;
        delimiter: string;
        generateExcelHint: boolean;
        useGridDateFormat: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+To+Excel+Button relevant section in reference guide}
     */
    declare type pages$IDataGridExportToExcelButton = {
        container: pages$IControlBar,
        load(): pages$DataGridExportToExcelButton,
        load(callback: (element: pages$DataGridExportToExcelButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Export+To+Excel+Button relevant section in reference guide}
     */
    declare class DataGridExportToExcelButton mixins GridControlBarButton, IDataGridExportToExcelButton {
        typeName: string;
        container: pages$ControlBar;
        maxNumberOfRows: number;
        useExcelDateType: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Remove+Button relevant section in reference guide}
     */
    declare type pages$IDataGridRemoveButton = {
        container: pages$IControlBar,
        load(): pages$DataGridRemoveButton,
        load(callback: (element: pages$DataGridRemoveButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Remove+Button relevant section in reference guide}
     */
    declare class DataGridRemoveButton mixins GridControlBarButton, IDataGridRemoveButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop-Down+Widget relevant section in reference guide}
     */
    declare type pages$IDropDown = {
        load(): pages$DropDown,
        load(callback: (element: pages$DropDown) => void): any
    } & pages$IAttributeWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop-Down+Widget relevant section in reference guide}
     */
    declare class DropDown mixins AttributeWidget, IDropDown {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop+Down+Button relevant section in reference guide}
     */
    declare type pages$IDropDownButton = {
        load(): pages$DropDownButton,
        load(callback: (element: pages$DropDownButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop+Down+Button relevant section in reference guide}
     */
    declare class DropDownButton mixins Button, IDropDownButton {
        typeName: string;
        items: instances$IList<pages$DropDownButtonItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IActionItem = {
        container: pages$IConditionallyVisibleWidget,
        load(): pages$ActionItem,
        load(callback: (element: pages$ActionItem) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ActionItem mixins elements$Element, IActionItem {
        typeName: string;
        container: pages$ConditionallyVisibleWidget;
        action: pages$ClientAction;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IDropDownButtonItem = {
        container: pages$IDropDownButton,
        load(): pages$DropDownButtonItem,
        load(callback: (element: pages$DropDownButtonItem) => void): any
    } & pages$IActionItem


    declare class DropDownButtonItem mixins ActionItem, IDropDownButtonItem {
        typeName: string;
        container: pages$DropDownButton;
        caption: texts$Text;
        image: images$IImage;
        imageQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop-down+Search+Field relevant section in reference guide}
     */
    declare type pages$IDropDownSearchField = {
        container: pages$IControlBar,
        load(): pages$DropDownSearchField,
        load(callback: (element: pages$DropDownSearchField) => void): any
    } & pages$ISingleSearchField



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop-down+Search+Field relevant section in reference guide}
     */
    declare class DropDownSearchField mixins SingleSearchField, IDropDownSearchField {
        typeName: string;
        container: pages$ControlBar;
        sortBar: pages$GridSortBar;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        allowMultipleSelect: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Viewer relevant section in reference guide}
     */
    declare type pages$IDynamicImageViewer = {
        load(): documenttemplates$DynamicImageViewer,
        load(callback: (element: documenttemplates$DynamicImageViewer) => void): any
    } & pages$IEntityWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Viewer relevant section in reference guide}
     */
    declare class DynamicImageViewer mixins EntityWidget, IDynamicImageViewer {
        typeName: string;
        defaultImage: images$IImage;
        defaultImageQualifiedName: string;
        widthUnit: pages$ImageSizeUnit;
        heightUnit: pages$ImageSizeUnit;
        width: number;
        height: number;
        responsive: boolean;
        showAsThumbnail: boolean;
        onClickBehavior: pages$OnClickBehavior;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text relevant section in reference guide}
     */
    declare type pages$IDynamicText = {
        load(): pages$DynamicText,
        load(callback: (element: pages$DynamicText) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Text relevant section in reference guide}
     */
    declare class DynamicText mixins ConditionallyVisibleWidget, IDynamicText {
        typeName: string;
        content: pages$ClientTemplate;
        renderMode: pages$TextRenderMode;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/File+Manager relevant section in reference guide}
     */
    declare type pages$IFileManager = {
        load(): pages$FileManager,
        load(callback: (element: pages$FileManager) => void): any
    } & pages$IInputWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/File+Manager relevant section in reference guide}
     */
    declare class FileManager mixins InputWidget, IFileManager {
        typeName: string;
        allowedExtensions: string;
        type: pages$FileManagerType;
        maxFileSize: number;
        showFileInBrowser: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IPageForSpecialization = {
        container: pages$IGridEditButton,
        load(): pages$PageForSpecialization,
        load(callback: (element: pages$PageForSpecialization) => void): any
    }

    declare class PageForSpecialization mixins elements$Element, IPageForSpecialization {
        typeName: string;
        container: pages$GridEditButton;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        pageSettings: pages$PageSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Property relevant section in reference guide}
     */
    declare type pages$IIcon = {
        load(): pages$Icon,
        load(callback: (element: pages$Icon) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Property relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Icon mixins elements$Element, IIcon {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IGlyphIcon = {
        load(): pages$GlyphIcon,
        load(callback: (element: pages$GlyphIcon) => void): any
    } & pages$IIcon


    declare class GlyphIcon mixins Icon, IGlyphIcon {
        typeName: string;
        code: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Grid+action+button relevant section in reference guide}
     */
    declare type pages$IGridActionButton = {
        container: pages$IControlBar,
        load(): pages$GridActionButton,
        load(callback: (element: pages$GridActionButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Grid+action+button relevant section in reference guide}
     */
    declare class GridActionButton mixins GridControlBarButton, IGridActionButton {
        typeName: string;
        container: pages$ControlBar;
        action: pages$ClientAction;
        maintainSelectionAfterMicroflow: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns relevant section in reference guide}
     */
    declare type pages$IGridColumn = {
        container: pages$IColumnGrid,
        load(): pages$GridColumn,
        load(callback: (element: pages$GridColumn) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns relevant section in reference guide}
     */
    declare class GridColumn mixins elements$Element, IGridColumn {
        typeName: string;
        container: pages$ColumnGrid;
        name: string;
        caption: texts$Text;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        formattingInfo: pages$FormattingInfo;
        showTooltip: boolean;
        aggregateCaption: texts$Text;
        aggregateFunction: pages$AggregateFunction;
        editable: boolean;
        width: number;
        class: string;
        style: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Control+Bar relevant section in reference guide}
     */
    declare type pages$IGridControlBar = {
        container: pages$IGrid,
        load(): pages$GridControlBar,
        load(callback: (element: pages$GridControlBar) => void): any
    } & pages$IControlBar



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Control+Bar relevant section in reference guide}
     */
    declare class GridControlBar mixins ControlBar, IGridControlBar {
        typeName: string;
        container: pages$Grid;
        searchButton: pages$GridSearchButton;
        defaultButton: pages$ControlBarItem;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Delete+Button relevant section in reference guide}
     */
    declare type pages$IGridDeleteButton = {
        container: pages$IControlBar,
        load(): pages$GridDeleteButton,
        load(callback: (element: pages$GridDeleteButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Delete+Button relevant section in reference guide}
     */
    declare class GridDeleteButton mixins GridControlBarButton, IGridDeleteButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Deselect+All+Button relevant section in reference guide}
     */
    declare type pages$IGridDeselectAllButton = {
        container: pages$IControlBar,
        load(): pages$GridDeselectAllButton,
        load(callback: (element: pages$GridDeselectAllButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Deselect+All+Button relevant section in reference guide}
     */
    declare class GridDeselectAllButton mixins GridControlBarButton, IGridDeselectAllButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Edit+Button relevant section in reference guide}
     */
    declare type pages$IGridEditButton = {
        container: pages$IControlBar,
        load(): pages$GridEditButton,
        load(callback: (element: pages$GridEditButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Edit+Button relevant section in reference guide}
     */
    declare class GridEditButton mixins GridControlBarButton, IGridEditButton {
        typeName: string;
        container: pages$ControlBar;
        pageSettings: pages$PageSettings;
        pagesForSpecializations: instances$IList<pages$PageForSpecialization>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Grid+New+Button relevant section in reference guide}
     */
    declare type pages$IGridNewButton = {
        container: pages$IControlBar,
        load(): pages$GridNewButton,
        load(callback: (element: pages$GridNewButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Grid+New+Button relevant section in reference guide}
     */
    declare class GridNewButton mixins GridControlBarButton, IGridNewButton {
        typeName: string;
        container: pages$ControlBar;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        editLocation: pages$NewButtonEditLocation;
        pageSettings: pages$PageSettings;
        isPersistent: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Search+Button relevant section in reference guide}
     */
    declare type pages$IGridSearchButton = {
        load(): pages$GridSearchButton,
        load(callback: (element: pages$GridSearchButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Search+Button relevant section in reference guide}
     */
    declare class GridSearchButton mixins GridControlBarButton, IGridSearchButton {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Select+All+Button relevant section in reference guide}
     */
    declare type pages$IGridSelectAllButton = {
        container: pages$IControlBar,
        load(): pages$GridSelectAllButton,
        load(callback: (element: pages$GridSelectAllButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Select+All+Button relevant section in reference guide}
     */
    declare class GridSelectAllButton mixins GridControlBarButton, IGridSelectAllButton {
        typeName: string;
        container: pages$ControlBar;
        selectionType: pages$SelectionType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Group+Box relevant section in reference guide}
     */
    declare type pages$IGroupBox = {
        load(): pages$GroupBox,
        load(callback: (element: pages$GroupBox) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Group+Box relevant section in reference guide}
     */
    declare class GroupBox mixins ConditionallyVisibleWidget, IGroupBox {
        typeName: string;
        caption: pages$ClientTemplate;
        collapsible: pages$GroupBoxCollapsible;
        widget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Header relevant section in reference guide}
     */
    declare type pages$IHeader = {
        load(): pages$Header,
        load(callback: (element: pages$Header) => void): any
    } & pages$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Header relevant section in reference guide}
     */
    declare class Header mixins Widget, IHeader {
        typeName: string;
        leftWidget: pages$Widget;
        rightWidget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISplitPane = {
        load(): pages$SplitPane,
        load(callback: (element: pages$SplitPane) => void): any
    } & pages$IWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class SplitPane mixins Widget, ISplitPane {
        typeName: string;
        firstWidget: pages$Widget;
        secondWidget: pages$Widget;
        animatedResize: boolean;
        height: number;
        position: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Horizontal+Split+Pane relevant section in reference guide}
     */
    declare type pages$IHorizontalSplitPane = {
        load(): pages$HorizontalSplitPane,
        load(callback: (element: pages$HorizontalSplitPane) => void): any
    } & pages$ISplitPane



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Horizontal+Split+Pane relevant section in reference guide}
     */
    declare class HorizontalSplitPane mixins SplitPane, IHorizontalSplitPane {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IImageIcon = {
        load(): pages$ImageIcon,
        load(callback: (element: pages$ImageIcon) => void): any
    } & pages$IIcon


    declare class ImageIcon mixins Icon, IImageIcon {
        typeName: string;
        image: images$IImage;
        imageQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Uploader relevant section in reference guide}
     */
    declare type pages$IImageUploader = {
        load(): pages$ImageUploader,
        load(callback: (element: pages$ImageUploader) => void): any
    } & pages$IInputWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Uploader relevant section in reference guide}
     */
    declare class ImageUploader mixins InputWidget, IImageUploader {
        typeName: string;
        allowedExtensions: string;
        thumbnailSize: common$ISize;
        maxFileSize: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IImageViewerSource = {
        container: pages$IEntityWidget,
        load(): pages$ImageViewerSource,
        load(callback: (element: pages$ImageViewerSource) => void): any
    } & pages$IEntityPathSource


    declare class ImageViewerSource mixins EntityPathSource, IImageViewerSource {
        typeName: string;
        container: pages$EntityWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IAssociationWidget = {
        load(): pages$AssociationWidget,
        load(callback: (element: pages$AssociationWidget) => void): any
    } & pages$IMemberWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AssociationWidget mixins MemberWidget, IAssociationWidget {
        typeName: string;
        selectorSource: pages$SelectorSource;
        selectPageSettings: pages$PageSettings;
        onChangeMicroflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Input+Reference+Set+Selector relevant section in reference guide}
     */
    declare type pages$IInputReferenceSetSelector = {
        load(): pages$InputReferenceSetSelector,
        load(callback: (element: pages$InputReferenceSetSelector) => void): any
    } & pages$IAssociationWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Input+Reference+Set+Selector relevant section in reference guide}
     */
    declare class InputReferenceSetSelector mixins AssociationWidget, IInputReferenceSetSelector {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Layout+Grid relevant section in reference guide}
     */
    declare type pages$ILayoutGrid = {
        load(): pages$LayoutGrid,
        load(callback: (element: pages$LayoutGrid) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Layout+Grid relevant section in reference guide}
     */
    declare class LayoutGrid mixins ConditionallyVisibleWidget, ILayoutGrid {
        typeName: string;
        width: pages$ContainerWidth;
        rows: instances$IList<pages$LayoutGridRow>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ILayoutGridColumn = {
        container: pages$ILayoutGridRow,
        load(): pages$LayoutGridColumn,
        load(callback: (element: pages$LayoutGridColumn) => void): any
    }

    declare class LayoutGridColumn mixins elements$Element, ILayoutGridColumn {
        typeName: string;
        container: pages$LayoutGridRow;
        weight: number;
        widget: pages$Widget;
        class: string;
        style: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ILayoutGridRow = {
        container: pages$ILayoutGrid,
        load(): pages$LayoutGridRow,
        load(callback: (element: pages$LayoutGridRow) => void): any
    }

    declare class LayoutGridRow mixins elements$Element, ILayoutGridRow {
        typeName: string;
        container: pages$LayoutGrid;
        columns: instances$IList<pages$LayoutGridColumn>;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        class: string;
        style: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Link+Button relevant section in reference guide}
     */
    declare type pages$ILinkButton = {
        load(): pages$LinkButton,
        load(callback: (element: pages$LinkButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Link+Button relevant section in reference guide}
     */
    declare class LinkButton mixins Button, ILinkButton {
        typeName: string;
        linkType: pages$LinkType;
        address: pages$StaticOrDynamicString;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Widgets relevant section in reference guide}
     */
    declare type pages$IMenuWidget = {
        load(): pages$MenuWidget,
        load(callback: (element: pages$MenuWidget) => void): any
    } & pages$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Widgets relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MenuWidget mixins Widget, IMenuWidget {
        typeName: string;
        menuSource: pages$MenuSource;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Bar relevant section in reference guide}
     */
    declare type pages$IMenuBar = {
        load(): pages$MenuBar,
        load(callback: (element: pages$MenuBar) => void): any
    } & pages$IMenuWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Bar relevant section in reference guide}
     */
    declare class MenuBar mixins MenuWidget, IMenuBar {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IMenuSource = {
        container: pages$IMenuWidget,
        load(): pages$MenuSource,
        load(callback: (element: pages$MenuSource) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MenuSource mixins elements$Element, IMenuSource {
        typeName: string;
        container: pages$MenuWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IMenuDocumentSource = {
        container: pages$IMenuWidget,
        load(): pages$MenuDocumentSource,
        load(callback: (element: pages$MenuDocumentSource) => void): any
    } & pages$IMenuSource


    declare class MenuDocumentSource mixins MenuSource, IMenuDocumentSource {
        typeName: string;
        container: pages$MenuWidget;
        menu: menus$IMenuDocument;
        menuQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation+List relevant section in reference guide}
     */
    declare type pages$INavigationList = {
        load(): pages$NavigationList,
        load(callback: (element: pages$NavigationList) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation+List relevant section in reference guide}
     */
    declare class NavigationList mixins ConditionallyVisibleWidget, INavigationList {
        typeName: string;
        items: instances$IList<pages$NavigationListItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$INavigationListItem = {
        container: pages$INavigationList,
        load(): pages$NavigationListItem,
        load(callback: (element: pages$NavigationListItem) => void): any
    } & pages$IActionItem


    declare class NavigationListItem mixins ActionItem, INavigationListItem {
        typeName: string;
        container: pages$NavigationList;
        widget: pages$Widget;
        class: string;
        style: string;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$INavigationSource = {
        container: pages$IMenuWidget,
        load(): pages$NavigationSource,
        load(callback: (element: pages$NavigationSource) => void): any
    } & pages$IMenuSource


    declare class NavigationSource mixins MenuSource, INavigationSource {
        typeName: string;
        container: pages$MenuWidget;
        deviceType: navigation$DeviceType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation+Tree relevant section in reference guide}
     */
    declare type pages$INavigationTree = {
        load(): pages$NavigationTree,
        load(callback: (element: pages$NavigationTree) => void): any
    } & pages$IMenuWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation+Tree relevant section in reference guide}
     */
    declare class NavigationTree mixins MenuWidget, INavigationTree {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IOnClickBehavior = {
        container: pages$IDynamicImageViewer,
        load(): pages$OnClickBehavior,
        load(callback: (element: pages$OnClickBehavior) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class OnClickBehavior mixins elements$Element, IOnClickBehavior {
        typeName: string;
        container: pages$DynamicImageViewer;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IOnClickEnlarge = {
        container: pages$IDynamicImageViewer,
        load(): pages$OnClickEnlarge,
        load(callback: (element: pages$OnClickEnlarge) => void): any
    } & pages$IOnClickBehavior


    declare class OnClickEnlarge mixins OnClickBehavior, IOnClickEnlarge {
        typeName: string;
        container: pages$DynamicImageViewer;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IOnClickMicroflow = {
        container: pages$IDynamicImageViewer,
        load(): pages$OnClickMicroflow,
        load(callback: (element: pages$OnClickMicroflow) => void): any
    } & pages$IOnClickBehavior


    declare class OnClickMicroflow mixins OnClickBehavior, IOnClickMicroflow {
        typeName: string;
        container: pages$DynamicImageViewer;
        microflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IOnClickNothing = {
        container: pages$IDynamicImageViewer,
        load(): pages$OnClickNothing,
        load(callback: (element: pages$OnClickNothing) => void): any
    } & pages$IOnClickBehavior


    declare class OnClickNothing mixins OnClickBehavior, IOnClickNothing {
        typeName: string;
        container: pages$DynamicImageViewer;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Range+Search+Field relevant section in reference guide}
     */
    declare type pages$IRangeSearchField = {
        container: pages$IControlBar,
        load(): pages$RangeSearchField,
        load(callback: (element: pages$RangeSearchField) => void): any
    } & pages$ISearchField



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Range+Search+Field relevant section in reference guide}
     */
    declare class RangeSearchField mixins SearchField, IRangeSearchField {
        typeName: string;
        container: pages$ControlBar;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        lowerBound: string;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        upperBound: string;
        includeLower: boolean;
        includeUpper: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Reference+Selector relevant section in reference guide}
     */
    declare type pages$IReferenceSelector = {
        load(): pages$ReferenceSelector,
        load(callback: (element: pages$ReferenceSelector) => void): any
    } & pages$IAssociationWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Reference+Selector relevant section in reference guide}
     */
    declare class ReferenceSelector mixins AssociationWidget, IReferenceSelector {
        typeName: string;
        required: boolean;
        requiredMessage: texts$Text;
        renderMode: pages$ReferenceSelectorRenderModeType;
        gotoPageSettings: pages$PageSettings;
        formattingInfo: pages$FormattingInfo;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Reference+Set+Selector relevant section in reference guide}
     */
    declare type pages$IReferenceSetSelector = {
        load(): pages$ReferenceSetSelector,
        load(callback: (element: pages$ReferenceSetSelector) => void): any
    } & pages$IColumnGrid



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Reference+Set+Selector relevant section in reference guide}
     */
    declare class ReferenceSetSelector mixins ColumnGrid, IReferenceSetSelector {
        typeName: string;
        onChangeMicroflowSettings: pages$MicroflowSettings;

        /**
         * The value of this property is conceptually of type Paths$EntityPath.
         */
        constrainedBy: instances$IList<string>;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        removeAllFromContext: boolean;
        removeFromContextEntities: instances$IList<domainmodels$IEntity>;
        removeFromContextEntitiesQualifiedNames: string[];
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IReferenceSetSource = {
        container: pages$IEntityWidget,
        load(): pages$ReferenceSetSource,
        load(callback: (element: pages$ReferenceSetSource) => void): any
    } & pages$IGridBaseSource


    declare class ReferenceSetSource mixins GridBaseSource, IReferenceSetSource {
        typeName: string;
        container: pages$EntityWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Scroll+Container relevant section in reference guide}
     */
    declare type pages$IScrollContainer = {
        load(): pages$ScrollContainer,
        load(callback: (element: pages$ScrollContainer) => void): any
    } & pages$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Scroll+Container relevant section in reference guide}
     */
    declare class ScrollContainer mixins Widget, IScrollContainer {
        typeName: string;
        center: pages$ScrollContainerRegion;
        left: pages$ScrollContainerRegion;
        right: pages$ScrollContainerRegion;
        top: pages$ScrollContainerRegion;
        bottom: pages$ScrollContainerRegion;
        layoutMode: pages$LayoutModeType;
        widthMode: pages$SizeMode;
        width: number;
        alignment: pages$AlignmentEnum;
        scrollBehavior: pages$ScrollBehavior;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IScrollContainerRegion = {
        container: pages$IScrollContainer,
        load(): pages$ScrollContainerRegion,
        load(callback: (element: pages$ScrollContainerRegion) => void): any
    }

    declare class ScrollContainerRegion mixins elements$Element, IScrollContainerRegion {
        typeName: string;
        container: pages$ScrollContainer;
        widget: pages$Widget;
        sizeMode: pages$SizeMode;
        size: number;
        class: string;
        style: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Search+Bar relevant section in reference guide}
     */
    declare type pages$ISearchBar = {
        container: pages$IGridBaseSource,
        load(): pages$SearchBar,
        load(callback: (element: pages$SearchBar) => void): any
    } & pages$IControlBar



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Search+Bar relevant section in reference guide}
     */
    declare class SearchBar mixins ControlBar, ISearchBar {
        typeName: string;
        container: pages$GridBaseSource;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Select+Button relevant section in reference guide}
     */
    declare type pages$ISelectButton = {
        container: pages$IControlBar,
        load(): pages$SelectButton,
        load(callback: (element: pages$SelectButton) => void): any
    } & pages$IGridControlBarButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Select+Button relevant section in reference guide}
     */
    declare class SelectButton mixins GridControlBarButton, ISelectButton {
        typeName: string;
        container: pages$ControlBar;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISelectorSource = {
        container: pages$IAssociationWidget,
        load(): pages$SelectorSource,
        load(callback: (element: pages$SelectorSource) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class SelectorSource mixins elements$Element, ISelectorSource {
        typeName: string;
        container: pages$AssociationWidget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$ISelectorDatabaseSource = {
        container: pages$IAssociationWidget,
        load(): pages$SelectorDatabaseSource,
        load(callback: (element: pages$SelectorDatabaseSource) => void): any
    } & pages$ISelectorSource


    declare class SelectorDatabaseSource mixins SelectorSource, ISelectorDatabaseSource {
        typeName: string;
        container: pages$AssociationWidget;
        sortBar: pages$GridSortBar;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;

        /**
         * The value of this property is conceptually of type Paths$EntityPath.
         */
        constrainedBy: instances$IList<string>;
        applyContext: boolean;
        removeAllFromContext: boolean;
        removeFromContextEntities: instances$IList<domainmodels$IEntity>;
        removeFromContextEntitiesQualifiedNames: string[];
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISelectorMicroflowSource = {
        container: pages$IAssociationWidget,
        load(): pages$SelectorMicroflowSource,
        load(callback: (element: pages$SelectorMicroflowSource) => void): any
    } & pages$ISelectorSource


    declare class SelectorMicroflowSource mixins SelectorSource, ISelectorMicroflowSource {
        typeName: string;
        container: pages$AssociationWidget;
        dataSourceMicroflowSettings: pages$MicroflowSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sidebar+Toggle+Button relevant section in reference guide}
     */
    declare type pages$ISidebarToggleButton = {
        load(): pages$SidebarToggleButton,
        load(callback: (element: pages$SidebarToggleButton) => void): any
    } & pages$IButton



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sidebar+Toggle+Button relevant section in reference guide}
     */
    declare class SidebarToggleButton mixins Button, ISidebarToggleButton {
        typeName: string;
        region: pages$SidebarToggleRegion;
        mode: pages$SidebarToggleMode;
        initiallyOpen: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Simple+Menu+Bar relevant section in reference guide}
     */
    declare type pages$ISimpleMenuBar = {
        load(): pages$SimpleMenuBar,
        load(callback: (element: pages$SimpleMenuBar) => void): any
    } & pages$IMenuWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Simple+Menu+Bar relevant section in reference guide}
     */
    declare class SimpleMenuBar mixins MenuWidget, ISimpleMenuBar {
        typeName: string;
        orientation: pages$SimpleMenuBarOrientation;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Snippet relevant section in reference guide}
     */
    declare type pages$ISnippet = {
        container: projects$IFolderBase,
        load(): pages$Snippet,
        load(callback: (element: pages$Snippet) => void): any,
        entity: domainmodels$IEntity,
        entityQualifiedName: string
    } & pages$IFormBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Snippet relevant section in reference guide}
     */
    declare class Snippet mixins FormBase, ISnippet {
        typeName: string;
        container: projects$FolderBase;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        widget: pages$Widget;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ISnippetCall = {
        container: pages$ISnippetCallWidget,
        load(): pages$SnippetCall,
        load(callback: (element: pages$SnippetCall) => void): any
    }

    declare class SnippetCall mixins elements$Element, ISnippetCall {
        typeName: string;
        container: pages$SnippetCallWidget;
        snippet: pages$ISnippet;
        snippetQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Snippet+Call relevant section in reference guide}
     */
    declare type pages$ISnippetCallWidget = {
        load(): pages$SnippetCallWidget,
        load(callback: (element: pages$SnippetCallWidget) => void): any
    } & pages$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Snippet+Call relevant section in reference guide}
     */
    declare class SnippetCallWidget mixins Widget, ISnippetCallWidget {
        typeName: string;
        snippetCall: pages$SnippetCall;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Tab+Container relevant section in reference guide}
     */
    declare type pages$ITabContainer = {
        load(): pages$TabContainer,
        load(callback: (element: pages$TabContainer) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Tab+Container relevant section in reference guide}
     */
    declare class TabContainer mixins ConditionallyVisibleWidget, ITabContainer {
        typeName: string;
        tabPages: instances$IList<pages$TabPage>;
        defaultPage: pages$TabPage;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Tab+Page relevant section in reference guide}
     */
    declare type pages$ITabPage = {
        container: pages$ITabContainer,
        load(): pages$TabPage,
        load(callback: (element: pages$TabPage) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Tab+Page relevant section in reference guide}
     */
    declare class TabPage mixins elements$Element, ITabPage {
        typeName: string;
        container: pages$TabContainer;
        name: string;
        caption: texts$Text;
        refreshOnShow: boolean;
        conditionalVisibilitySettings: pages$ConditionalVisibilitySettings;
        widget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid relevant section in reference guide}
     */
    declare type pages$ITemplateGrid = {
        load(): pages$TemplateGrid,
        load(callback: (element: pages$TemplateGrid) => void): any
    } & pages$IGrid



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid relevant section in reference guide}
     */
    declare class TemplateGrid mixins Grid, ITemplateGrid {
        typeName: string;
        contents: pages$TemplateGridContents;
        numberOfRows: number;
        numberOfColumns: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$ITemplateGridContents = {
        container: pages$ITemplateGrid,
        load(): pages$TemplateGridContents,
        load(callback: (element: pages$TemplateGridContents) => void): any
    }

    declare class TemplateGridContents mixins elements$Element, ITemplateGridContents {
        typeName: string;
        container: pages$TemplateGrid;
        widget: pages$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page+Title relevant section in reference guide}
     */
    declare type pages$ITitle = {
        load(): pages$Title,
        load(callback: (element: pages$Title) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page+Title relevant section in reference guide}
     */
    declare class Title mixins ConditionallyVisibleWidget, ITitle {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Vertical+Split+Pane relevant section in reference guide}
     */
    declare type pages$IVerticalSplitPane = {
        load(): pages$VerticalSplitPane,
        load(callback: (element: pages$VerticalSplitPane) => void): any
    } & pages$ISplitPane



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Vertical+Split+Pane relevant section in reference guide}
     */
    declare class VerticalSplitPane mixins SplitPane, IVerticalSplitPane {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type pages$IProjectSettingsPart = {
        container: settings$IProjectSettings,
        load(): settings$ProjectSettingsPart,
        load(callback: (element: settings$ProjectSettingsPart) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectSettingsPart mixins elements$Element, IProjectSettingsPart {
        typeName: string;
        container: settings$ProjectSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type pages$IWebUIProjectSettingsPart = {
        container: settings$IProjectSettings,
        load(): pages$WebUIProjectSettingsPart,
        load(callback: (element: pages$WebUIProjectSettingsPart) => void): any
    }

    declare class WebUIProjectSettingsPart mixins settings$ProjectSettingsPart, IWebUIProjectSettingsPart {
        typeName: string;
        container: settings$ProjectSettings;
        theme: string;
        feedbackWidgetUpdated: boolean;
        useModernUI: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class FormLocation mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Content: pages$FormLocation;
        Popup: pages$FormLocation;
        ModalPopup: pages$FormLocation
    }

    declare class ProgressBarType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$ProgressBarType;
        NonBlocking: pages$ProgressBarType;
        Blocking: pages$ProgressBarType
    }

    declare class FormValidations mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$FormValidations;
        Widget: pages$FormValidations;
        All: pages$FormValidations
    }

    declare class EnumFormat mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Text: pages$EnumFormat;
        Image: pages$EnumFormat
    }

    declare class DateFormat mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Date: pages$DateFormat;
        Time: pages$DateFormat;
        DateTime: pages$DateFormat;
        Custom: pages$DateFormat
    }

    declare class EditableEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Always: pages$EditableEnum;
        Never: pages$EditableEnum;
        Conditional: pages$EditableEnum
    }

    declare class UnitEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Weight: pages$UnitEnum;
        Pixels: pages$UnitEnum
    }

    declare class SortDirection mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Ascending: pages$SortDirection;
        Descending: pages$SortDirection
    }

    declare class RenderType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Button: pages$RenderType;
        Link: pages$RenderType
    }

    declare class ButtonStyle mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: pages$ButtonStyle;
        Inverse: pages$ButtonStyle;
        Primary: pages$ButtonStyle;
        Info: pages$ButtonStyle;
        Success: pages$ButtonStyle;
        Warning: pages$ButtonStyle;
        Danger: pages$ButtonStyle
    }

    declare class AggregateFunction mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$AggregateFunction;
        Average: pages$AggregateFunction;
        Maximum: pages$AggregateFunction;
        Minimum: pages$AggregateFunction;
        Sum: pages$AggregateFunction;
        Count: pages$AggregateFunction
    }

    declare class AlignmentEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Left: pages$AlignmentEnum;
        Center: pages$AlignmentEnum;
        Right: pages$AlignmentEnum
    }

    declare class ClickTypeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Single: pages$ClickTypeType;
        Double: pages$ClickTypeType
    }

    declare class ContainerWidth mixins instances$IEnum {
        qualifiedTsTypeName: string;
        FullWidth: pages$ContainerWidth;
        FixedWidth: pages$ContainerWidth
    }

    declare class FileManagerType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Upload: pages$FileManagerType;
        Download: pages$FileManagerType;
        Both: pages$FileManagerType
    }

    declare class GridSelectionMode mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$GridSelectionMode;
        Single: pages$GridSelectionMode;
        SingleAndMaintain: pages$GridSelectionMode;
        Multi: pages$GridSelectionMode;
        SimpleMulti: pages$GridSelectionMode
    }

    declare class GroupBoxCollapsible mixins instances$IEnum {
        qualifiedTsTypeName: string;
        No: pages$GroupBoxCollapsible;
        YesInitiallyExpanded: pages$GroupBoxCollapsible;
        YesInitiallyCollapsed: pages$GroupBoxCollapsible
    }

    declare class ImageSizeUnit mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Auto: pages$ImageSizeUnit;
        Pixels: pages$ImageSizeUnit;
        Percentage: pages$ImageSizeUnit
    }

    declare class LayoutModeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Headline: pages$LayoutModeType;
        Sidebar: pages$LayoutModeType
    }

    declare class LayoutType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Responsive: pages$LayoutType;
        Tablet: pages$LayoutType;
        Phone: pages$LayoutType;
        ModalPopup: pages$LayoutType;
        Popup: pages$LayoutType;
        Legacy: pages$LayoutType
    }

    declare class LinkType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Web: pages$LinkType;
        Email: pages$LinkType;
        Call: pages$LinkType;
        Text: pages$LinkType
    }

    declare class MobileFooterType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$MobileFooterType;
        MenuBar: pages$MobileFooterType;
        Custom: pages$MobileFooterType
    }

    declare class NewButtonEditLocation mixins instances$IEnum {
        qualifiedTsTypeName: string;
        InlineAtTop: pages$NewButtonEditLocation;
        InlineAtBottom: pages$NewButtonEditLocation;
        Form: pages$NewButtonEditLocation
    }

    declare class ReferenceSelectorRenderModeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Form: pages$ReferenceSelectorRenderModeType;
        DropDown: pages$ReferenceSelectorRenderModeType
    }

    declare class RenderModeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Button: pages$RenderModeType;
        Link: pages$RenderModeType
    }

    declare class ScrollBehavior mixins instances$IEnum {
        qualifiedTsTypeName: string;
        PerRegion: pages$ScrollBehavior;
        FullWidget: pages$ScrollBehavior
    }

    declare class SearchBarTypeEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: pages$SearchBarTypeEnum;
        FoldableOpen: pages$SearchBarTypeEnum;
        FoldableClosed: pages$SearchBarTypeEnum;
        AlwaysOpen: pages$SearchBarTypeEnum
    }

    declare class SearchFieldOperator mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Contains: pages$SearchFieldOperator;
        StartsWith: pages$SearchFieldOperator;
        Greater: pages$SearchFieldOperator;
        GreaterOrEqual: pages$SearchFieldOperator;
        Equal: pages$SearchFieldOperator;
        NotEqual: pages$SearchFieldOperator;
        SmallerOrEqual: pages$SearchFieldOperator;
        Smaller: pages$SearchFieldOperator
    }

    declare class SearchFieldType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Normal: pages$SearchFieldType;
        Hidden: pages$SearchFieldType;
        ReadOnly: pages$SearchFieldType
    }

    declare class SelectionType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        SelectPage: pages$SelectionType;
        SelectAll: pages$SelectionType
    }

    declare class SidebarToggleMode mixins instances$IEnum {
        qualifiedTsTypeName: string;
        PushContentAside: pages$SidebarToggleMode;
        SlideOverContent: pages$SidebarToggleMode;
        ShrinkContent: pages$SidebarToggleMode
    }

    declare class SidebarToggleRegion mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Left: pages$SidebarToggleRegion;
        Right: pages$SidebarToggleRegion
    }

    declare class SimpleMenuBarOrientation mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Horizontal: pages$SimpleMenuBarOrientation;
        Vertical: pages$SimpleMenuBarOrientation
    }

    declare class SizeMode mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Auto: pages$SizeMode;
        Pixels: pages$SizeMode;
        Percentage: pages$SizeMode
    }

    declare class TableCellRenderModeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: pages$TableCellRenderModeType;
        Header: pages$TableCellRenderModeType;
        Title: pages$TableCellRenderModeType
    }

    declare class TextRenderMode mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Text: pages$TextRenderMode;
        Paragraph: pages$TextRenderMode;
        H1: pages$TextRenderMode;
        H2: pages$TextRenderMode;
        H3: pages$TextRenderMode;
        H4: pages$TextRenderMode;
        H5: pages$TextRenderMode;
        H6: pages$TextRenderMode
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     */
    declare type customwidgets$IWidget = {
        load(): pages$Widget,
        load(callback: (element: pages$Widget) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Widget mixins elements$Element, IWidget {
        typeName: string;
        name: string;
        class: string;
        style: string;
        tabIndex: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$ICustomWidget = {
        load(): customwidgets$CustomWidget,
        load(callback: (element: customwidgets$CustomWidget) => void): any
    }

    declare class CustomWidget mixins pages$Widget, ICustomWidget {
        typeName: string;
        type: customwidgets$CustomWidgetType;
        object: customwidgets$WidgetObject;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$ICustomWidgetType = {
        container: customwidgets$ICustomWidget,
        load(): customwidgets$CustomWidgetType,
        load(callback: (element: customwidgets$CustomWidgetType) => void): any
    }

    declare class CustomWidgetType mixins elements$Element, ICustomWidgetType {
        typeName: string;
        container: customwidgets$CustomWidget;
        widgetId: string;
        needsEntityContext: boolean;
        name: string;
        description: string;
        phoneGapEnabled: boolean;
        objectType: customwidgets$WidgetObjectType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetEnumerationValue = {
        container: customwidgets$IWidgetValueType,
        load(): customwidgets$WidgetEnumerationValue,
        load(callback: (element: customwidgets$WidgetEnumerationValue) => void): any
    }

    declare class WidgetEnumerationValue mixins elements$Element, IWidgetEnumerationValue {
        typeName: string;
        container: customwidgets$WidgetValueType;
        key: string;
        caption: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetObject = {
        load(): customwidgets$WidgetObject,
        load(callback: (element: customwidgets$WidgetObject) => void): any
    }

    declare class WidgetObject mixins elements$Element, IWidgetObject {
        typeName: string;
        type: customwidgets$WidgetObjectType;
        properties: instances$IList<customwidgets$WidgetProperty>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetObjectType = {
        load(): customwidgets$WidgetObjectType,
        load(callback: (element: customwidgets$WidgetObjectType) => void): any
    }

    declare class WidgetObjectType mixins elements$Element, IWidgetObjectType {
        typeName: string;
        propertyTypes: instances$IList<customwidgets$WidgetPropertyType>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetProperty = {
        container: customwidgets$IWidgetObject,
        load(): customwidgets$WidgetProperty,
        load(callback: (element: customwidgets$WidgetProperty) => void): any
    }

    declare class WidgetProperty mixins elements$Element, IWidgetProperty {
        typeName: string;
        container: customwidgets$WidgetObject;
        type: customwidgets$WidgetPropertyType;
        value: customwidgets$WidgetValue;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetPropertyType = {
        container: customwidgets$IWidgetObjectType,
        load(): customwidgets$WidgetPropertyType,
        load(callback: (element: customwidgets$WidgetPropertyType) => void): any
    }

    declare class WidgetPropertyType mixins elements$Element, IWidgetPropertyType {
        typeName: string;
        container: customwidgets$WidgetObjectType;
        key: string;
        category: string;
        caption: string;
        description: string;
        isDefault: boolean;
        valueType: customwidgets$WidgetValueType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetReturnType = {
        container: customwidgets$IWidgetValueType,
        load(): customwidgets$WidgetReturnType,
        load(callback: (element: customwidgets$WidgetReturnType) => void): any
    }

    declare class WidgetReturnType mixins elements$Element, IWidgetReturnType {
        typeName: string;
        container: customwidgets$WidgetValueType;
        type: customwidgets$WidgetReturnTypeEnum;
        isList: boolean;
        entityProperty: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetTranslation = {
        container: customwidgets$IWidgetValueType,
        load(): customwidgets$WidgetTranslation,
        load(callback: (element: customwidgets$WidgetTranslation) => void): any
    }

    declare class WidgetTranslation mixins elements$Element, IWidgetTranslation {
        typeName: string;
        container: customwidgets$WidgetValueType;
        languageCode: string;
        text: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetValue = {
        container: customwidgets$IWidgetProperty,
        load(): customwidgets$WidgetValue,
        load(callback: (element: customwidgets$WidgetValue) => void): any
    }

    declare class WidgetValue mixins elements$Element, IWidgetValue {
        typeName: string;
        container: customwidgets$WidgetProperty;
        type: customwidgets$WidgetValueType;
        primitiveValue: string;

        /**
         * The value of this property is conceptually of type Paths$EntityPath.
         */
        entityPath: string;

        /**
         * The value of this property is conceptually of type Paths$AttributePath.
         */
        attributePath: string;
        page: pages$IPage;
        pageQualifiedName: string;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        image: images$IImage;
        imageQualifiedName: string;
        translatableValue: texts$Text;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        objects: instances$IList<customwidgets$WidgetObject>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type customwidgets$IWidgetValueType = {
        container: customwidgets$IWidgetPropertyType,
        load(): customwidgets$WidgetValueType,
        load(callback: (element: customwidgets$WidgetValueType) => void): any
    }

    declare class WidgetValueType mixins elements$Element, IWidgetValueType {
        typeName: string;
        container: customwidgets$WidgetPropertyType;
        type: customwidgets$WidgetValueTypeEnum;
        isList: boolean;
        entityProperty: string;
        allowNonPersistableEntities: boolean;
        isPath: customwidgets$IsPath;
        pathType: customwidgets$PathType;
        parameterIsList: boolean;
        multiline: boolean;
        defaultValue: string;
        required: boolean;
        attributeTypes: instances$IList<customwidgets$CustomWidgetAttributeType>;
        enumerationValues: instances$IList<customwidgets$WidgetEnumerationValue>;
        objectType: customwidgets$WidgetObjectType;
        returnType: customwidgets$WidgetReturnType;
        translations: instances$IList<customwidgets$WidgetTranslation>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class CustomWidgetAttributeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        AutoNumber: customwidgets$CustomWidgetAttributeType;
        Binary: customwidgets$CustomWidgetAttributeType;
        Boolean: customwidgets$CustomWidgetAttributeType;
        Currency: customwidgets$CustomWidgetAttributeType;
        DateTime: customwidgets$CustomWidgetAttributeType;
        Enum: customwidgets$CustomWidgetAttributeType;
        Float: customwidgets$CustomWidgetAttributeType;
        HashString: customwidgets$CustomWidgetAttributeType;
        Integer: customwidgets$CustomWidgetAttributeType;
        Long: customwidgets$CustomWidgetAttributeType;
        String: customwidgets$CustomWidgetAttributeType;
        Decimal: customwidgets$CustomWidgetAttributeType
    }

    declare class IsPath mixins instances$IEnum {
        qualifiedTsTypeName: string;
        No: customwidgets$IsPath;
        Optional: customwidgets$IsPath;
        Yes: customwidgets$IsPath
    }

    declare class PathType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: customwidgets$PathType;
        Reference: customwidgets$PathType;
        ReferenceSet: customwidgets$PathType
    }

    declare class WidgetReturnTypeEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Void: customwidgets$WidgetReturnTypeEnum;
        Boolean: customwidgets$WidgetReturnTypeEnum;
        Integer: customwidgets$WidgetReturnTypeEnum;
        Float: customwidgets$WidgetReturnTypeEnum;
        DateTime: customwidgets$WidgetReturnTypeEnum;
        String: customwidgets$WidgetReturnTypeEnum;
        Object: customwidgets$WidgetReturnTypeEnum;
        Decimal: customwidgets$WidgetReturnTypeEnum
    }

    declare class WidgetValueTypeEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Attribute: customwidgets$WidgetValueTypeEnum;
        Boolean: customwidgets$WidgetValueTypeEnum;
        Entity: customwidgets$WidgetValueTypeEnum;
        EntityConstraint: customwidgets$WidgetValueTypeEnum;
        Enumeration: customwidgets$WidgetValueTypeEnum;
        Form: customwidgets$WidgetValueTypeEnum;
        Image: customwidgets$WidgetValueTypeEnum;
        Integer: customwidgets$WidgetValueTypeEnum;
        Microflow: customwidgets$WidgetValueTypeEnum;
        Object: customwidgets$WidgetValueTypeEnum;
        String: customwidgets$WidgetValueTypeEnum;
        TranslatableString: customwidgets$WidgetValueTypeEnum
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     */
    declare type documenttemplates$IWidget = {
        load(): customwidgets$Widget,
        load(callback: (element: customwidgets$Widget) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Widget mixins elements$Element, IWidget {
        typeName: string;
        name: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IAttributeWidget = {
        load(): pages$AttributeWidget,
        load(callback: (element: pages$AttributeWidget) => void): any
    } & pages$IMemberWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AttributeWidget mixins Widget, IAttributeWidget {
        typeName: string;
        attributePath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IConditionSettings = {
        container: documenttemplates$IMxTableRow,
        load(): documenttemplates$ConditionSettings,
        load(callback: (element: documenttemplates$ConditionSettings) => void): any
    }

    declare class ConditionSettings mixins elements$Element, IConditionSettings {
        typeName: string;
        container: documenttemplates$MxTableRow;
        conditions: instances$IList<enumerations$Condition>;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IDataGridCell = {
        container: documenttemplates$IDataGridColumn,
        load(): documenttemplates$DataGridCell,
        load(callback: (element: documenttemplates$DataGridCell) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns+(document+template) relevant section in reference guide}
     */
    declare class DataGridCell mixins elements$Element, IDataGridCell {
        typeName: string;
        container: documenttemplates$DataGridColumn;
        style: documenttemplates$MxStyle;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IDataGridColumn = {
        container: documenttemplates$IMxDataGrid,
        load(): documenttemplates$DataGridColumn,
        load(callback: (element: documenttemplates$DataGridColumn) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Columns+(document+template) relevant section in reference guide}
     */
    declare class DataGridColumn mixins elements$Element, IDataGridColumn {
        typeName: string;
        container: documenttemplates$MxDataGrid;
        oddRowsCell: documenttemplates$DataGridCell;
        evenRowsCell: documenttemplates$DataGridCell;
        caption: texts$Text;
        formattingInfo: pages$FormattingInfo;
        style: documenttemplates$MxStyle;
        attributePath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sort+Bar relevant section in reference guide}
     */
    declare type documenttemplates$IDocGridSortBar = {
        container: documenttemplates$IMxGrid,
        load(): documenttemplates$DocGridSortBar,
        load(callback: (element: documenttemplates$DocGridSortBar) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Sort+Bar relevant section in reference guide}
     */
    declare class DocGridSortBar mixins elements$Element, IDocGridSortBar {
        typeName: string;
        container: documenttemplates$MxGrid;
        sortItems: instances$IList<documenttemplates$DocGridSortItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IDocGridSortItem = {
        container: documenttemplates$IDocGridSortBar,
        load(): documenttemplates$DocGridSortItem,
        load(callback: (element: documenttemplates$DocGridSortItem) => void): any
    }

    declare class DocGridSortItem mixins elements$Element, IDocGridSortItem {
        typeName: string;
        container: documenttemplates$DocGridSortBar;
        attributePath: string;
        sortOrder: pages$SortDirection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IModuleDocument = {
        container: projects$IFolderBase,
        load(): pages$ModuleDocument,
        load(callback: (element: pages$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type documenttemplates$IDocument = {
        container: projects$IFolderBase,
        load(): pages$Document,
        load(callback: (element: pages$Document) => void): any,
        name: string
    } & documenttemplates$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Document+Templates relevant section in reference guide}
     */
    declare type documenttemplates$IDocumentTemplate = {
        container: projects$IFolderBase,
        load(): documenttemplates$DocumentTemplate,
        load(callback: (element: documenttemplates$DocumentTemplate) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Document+Templates relevant section in reference guide}
     */
    declare class DocumentTemplate mixins projects$Document, IDocumentTemplate {
        typeName: string;
        container: projects$FolderBase;
        toplevels: instances$IList<documenttemplates$Widget>;
        header: documenttemplates$MxHeaderDropZone;
        footer: documenttemplates$MxFooterDropZone;
        style: documenttemplates$MxStyle;
        canvasWidth: number;
        pageWidth: string;
        pageHeight: string;
        pPI: number;
        marginLeftInInch: number;
        marginRightInInch: number;
        marginTopInInch: number;
        marginBottomInInch: number;
        showHeaderAndFooterOnFirstPage: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IEntityWidget = {
        load(): pages$EntityWidget,
        load(callback: (element: pages$EntityWidget) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class EntityWidget mixins Widget, IEntityWidget {
        typeName: string;
        entityPath: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image+Viewer relevant section in reference guide}
     */
    declare type documenttemplates$IDynamicImageViewer = {
        load(): pages$DynamicImageViewer,
        load(callback: (element: pages$DynamicImageViewer) => void): any
    } & documenttemplates$IEntityWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Dynamic+Image+(document+template) relevant section in reference guide}
     */
    declare class DynamicImageViewer mixins EntityWidget, IDynamicImageViewer {
        typeName: string;
        image: images$IImage;
        imageQualifiedName: string;
        useThumbnail: boolean;
        width: number;
        height: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IMxGrid = {
        load(): documenttemplates$MxGrid,
        load(callback: (element: documenttemplates$MxGrid) => void): any
    } & documenttemplates$IEntityWidget



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MxGrid mixins EntityWidget, IMxGrid {
        typeName: string;
        style: documenttemplates$MxStyle;
        sortBar: documenttemplates$DocGridSortBar;
        cellSpacing: number;
        cellPadding: number;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Grid+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxDataGrid = {
        load(): documenttemplates$MxDataGrid,
        load(callback: (element: documenttemplates$MxDataGrid) => void): any
    } & documenttemplates$IMxGrid



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Grid+(document+template) relevant section in reference guide}
     */
    declare class MxDataGrid mixins MxGrid, IMxDataGrid {
        typeName: string;
        columns: instances$IList<documenttemplates$DataGridColumn>;
        weights: instances$IList<number>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxDataView = {
        load(): documenttemplates$MxDataView,
        load(callback: (element: documenttemplates$MxDataView) => void): any
    } & documenttemplates$IEntityWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+(document+template) relevant section in reference guide}
     */
    declare class MxDataView mixins EntityWidget, IMxDataView {
        typeName: string;
        contents: documenttemplates$MxDataViewDropZone;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxDataViewDropZone = {
        container: documenttemplates$IMxDataView,
        load(): documenttemplates$MxDataViewDropZone,
        load(callback: (element: documenttemplates$MxDataViewDropZone) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+View+(document+template) relevant section in reference guide}
     */
    declare class MxDataViewDropZone mixins elements$Element, IMxDataViewDropZone {
        typeName: string;
        container: documenttemplates$MxDataView;
        widget: documenttemplates$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Dynamic+label+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxDynamicLabel = {
        load(): documenttemplates$MxDynamicLabel,
        load(callback: (element: documenttemplates$MxDynamicLabel) => void): any
    } & documenttemplates$IAttributeWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Dynamic+label+(document+template) relevant section in reference guide}
     */
    declare class MxDynamicLabel mixins AttributeWidget, IMxDynamicLabel {
        typeName: string;
        style: documenttemplates$MxStyle;
        formattingInfo: pages$FormattingInfo;
        renderXHTML: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Footer+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxFooterDropZone = {
        container: documenttemplates$IDocumentTemplate,
        load(): documenttemplates$MxFooterDropZone,
        load(callback: (element: documenttemplates$MxFooterDropZone) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Footer+(document+template) relevant section in reference guide}
     */
    declare class MxFooterDropZone mixins elements$Element, IMxFooterDropZone {
        typeName: string;
        container: documenttemplates$DocumentTemplate;
        widget: documenttemplates$Widget;
        bottomMargin: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Header+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxHeaderDropZone = {
        container: documenttemplates$IDocumentTemplate,
        load(): documenttemplates$MxHeaderDropZone,
        load(callback: (element: documenttemplates$MxHeaderDropZone) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Header+(document+template) relevant section in reference guide}
     */
    declare class MxHeaderDropZone mixins elements$Element, IMxHeaderDropZone {
        typeName: string;
        container: documenttemplates$DocumentTemplate;
        widget: documenttemplates$Widget;
        topMargin: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Line+Break+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxLineBreak = {
        load(): documenttemplates$MxLineBreak,
        load(callback: (element: documenttemplates$MxLineBreak) => void): any
    } & documenttemplates$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Line+Break+(document+template) relevant section in reference guide}
     */
    declare class MxLineBreak mixins Widget, IMxLineBreak {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page+Break+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxPageBreak = {
        load(): documenttemplates$MxPageBreak,
        load(callback: (element: documenttemplates$MxPageBreak) => void): any
    } & documenttemplates$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Page+Break+(document+template) relevant section in reference guide}
     */
    declare class MxPageBreak mixins Widget, IMxPageBreak {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Static+label+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxStaticLabel = {
        load(): documenttemplates$MxStaticLabel,
        load(callback: (element: documenttemplates$MxStaticLabel) => void): any
    } & documenttemplates$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Static+label+(document+template) relevant section in reference guide}
     */
    declare class MxStaticLabel mixins Widget, IMxStaticLabel {
        typeName: string;
        caption: texts$Text;
        style: documenttemplates$MxStyle;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type documenttemplates$IMxStyle = {
        load(): documenttemplates$MxStyle,
        load(callback: (element: documenttemplates$MxStyle) => void): any
    }

    declare class MxStyle mixins elements$Element, IMxStyle {
        typeName: string;
        fontFamily: documenttemplates$FontFamily;
        fontSize: number;
        bold: boolean;
        italic: boolean;
        fontColor: string;
        backgroundColor: string;
        overrideFontFamily: boolean;
        overrideFontSize: boolean;
        overrideBold: boolean;
        overrideItalic: boolean;
        overrideFontColor: boolean;
        overrideBackgroundColor: boolean;
        textAlign: documenttemplates$TextAlign;
        customStyles: string;
        borderStyleTop: documenttemplates$BorderStyle;
        borderStyleBottom: documenttemplates$BorderStyle;
        borderStyleLeft: documenttemplates$BorderStyle;
        borderStyleRight: documenttemplates$BorderStyle;
        borderWidthTop: number;
        borderWidthBottom: number;
        borderWidthLeft: number;
        borderWidthRight: number;
        borderColorTop: string;
        borderColorBottom: string;
        borderColorLeft: string;
        borderColorRight: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Table+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTable = {
        load(): documenttemplates$MxTable,
        load(callback: (element: documenttemplates$MxTable) => void): any
    } & documenttemplates$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Table+(document+template) relevant section in reference guide}
     */
    declare class MxTable mixins Widget, IMxTable {
        typeName: string;
        rows: instances$IList<documenttemplates$MxTableRow>;
        style: documenttemplates$MxStyle;
        columnWeights: instances$IList<number>;
        cellSpacing: number;
        cellPadding: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cell+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTableCell = {
        container: documenttemplates$IMxTableRow,
        load(): documenttemplates$MxTableCell,
        load(callback: (element: documenttemplates$MxTableCell) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Cell+(document+template) relevant section in reference guide}
     */
    declare class MxTableCell mixins elements$Element, IMxTableCell {
        typeName: string;
        container: documenttemplates$MxTableRow;
        style: documenttemplates$MxStyle;
        widget: documenttemplates$Widget;
        colSpan: number;
        rowSpan: number;
        isPartOfSpan: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Row+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTableRow = {
        container: documenttemplates$IMxTable,
        load(): documenttemplates$MxTableRow,
        load(callback: (element: documenttemplates$MxTableRow) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Row+(document+template) relevant section in reference guide}
     */
    declare class MxTableRow mixins elements$Element, IMxTableRow {
        typeName: string;
        container: documenttemplates$MxTable;
        cells: instances$IList<documenttemplates$MxTableCell>;
        conditionSettings: documenttemplates$ConditionSettings;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTemplateGrid = {
        load(): documenttemplates$MxTemplateGrid,
        load(callback: (element: documenttemplates$MxTemplateGrid) => void): any
    } & documenttemplates$IMxGrid



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid+(document+template) relevant section in reference guide}
     */
    declare class MxTemplateGrid mixins MxGrid, IMxTemplateGrid {
        typeName: string;
        oddRowsDropZone: documenttemplates$MxTemplateGridDropZone;
        evenRowsDropZone: documenttemplates$MxTemplateGridDropZone;
        numberOfColumns: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTemplateGridDropZone = {
        container: documenttemplates$IMxTemplateGrid,
        load(): documenttemplates$MxTemplateGridDropZone,
        load(callback: (element: documenttemplates$MxTemplateGridDropZone) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Template+Grid+(document+template) relevant section in reference guide}
     */
    declare class MxTemplateGridDropZone mixins elements$Element, IMxTemplateGridDropZone {
        typeName: string;
        container: documenttemplates$MxTemplateGrid;
        widget: documenttemplates$Widget;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Title+(document+template) relevant section in reference guide}
     */
    declare type documenttemplates$IMxTitle = {
        load(): documenttemplates$MxTitle,
        load(callback: (element: documenttemplates$MxTitle) => void): any
    } & documenttemplates$IWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Title+(document+template) relevant section in reference guide}
     */
    declare class MxTitle mixins Widget, IMxTitle {
        typeName: string;
        caption: texts$Text;
        style: documenttemplates$MxStyle;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Image relevant section in reference guide}
     */
    declare type documenttemplates$IStaticImageViewer = {
        load(): pages$StaticImageViewer,
        load(callback: (element: pages$StaticImageViewer) => void): any
    } & pages$IConditionallyVisibleWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Static+Image+(document+template) relevant section in reference guide}
     */
    declare class StaticImageViewer mixins Widget, IStaticImageViewer {
        typeName: string;
        image: images$IImage;
        imageQualifiedName: string;
        width: number;
        height: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class BorderStyle mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: documenttemplates$BorderStyle;
        Dotted: documenttemplates$BorderStyle;
        Dashed: documenttemplates$BorderStyle;
        Solid: documenttemplates$BorderStyle
    }

    declare class FontFamily mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Courier: documenttemplates$FontFamily;
        Tahoma: documenttemplates$FontFamily;
        Times: documenttemplates$FontFamily;
        Helvetica: documenttemplates$FontFamily;
        Arial: documenttemplates$FontFamily
    }

    declare class TextAlign mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Left: documenttemplates$TextAlign;
        Right: documenttemplates$TextAlign;
        Center: documenttemplates$TextAlign
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type navigation$IProjectDocument = {
        container: projects$IProject,
        load(): settings$ProjectDocument,
        load(callback: (element: settings$ProjectDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectDocument mixins units$ModelUnit, IProjectDocument {
        typeName: string;
        container: projects$Project;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation relevant section in reference guide}
     */
    declare type navigation$INavigationDocument = {
        container: projects$IProject,
        load(): navigation$NavigationDocument,
        load(callback: (element: navigation$NavigationDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Navigation relevant section in reference guide}
     */
    declare class NavigationDocument mixins projects$ProjectDocument, INavigationDocument {
        typeName: string;
        container: projects$Project;
        phoneProfile: navigation$NavigationProfile;
        tabletProfile: navigation$NavigationProfile;
        desktopProfile: navigation$NavigationProfile;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type navigation$INavigationProfile = {
        container: navigation$INavigationDocument,
        load(): navigation$NavigationProfile,
        load(callback: (element: navigation$NavigationProfile) => void): any
    }

    declare class NavigationProfile mixins elements$Element, INavigationProfile {
        typeName: string;
        container: navigation$NavigationDocument;
        type: navigation$DeviceType;
        enabled: boolean;
        homePage: navigation$HomePage;
        roleBasedHomePages: instances$IList<navigation$RoleBasedHomePage>;
        applicationTitle: string;
        menuItemCollection: menus$MenuItemCollection;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type navigation$IHomePageBase = {
        container: navigation$INavigationProfile,
        load(): navigation$HomePageBase,
        load(callback: (element: navigation$HomePageBase) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class HomePageBase mixins elements$Element, IHomePageBase {
        typeName: string;
        container: navigation$NavigationProfile;
        page: pages$IPage;
        pageQualifiedName: string;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type navigation$IHomePage = {
        container: navigation$INavigationProfile,
        load(): navigation$HomePage,
        load(callback: (element: navigation$HomePage) => void): any
    } & navigation$IHomePageBase


    declare class HomePage mixins HomePageBase, IHomePage {
        typeName: string;
        container: navigation$NavigationProfile;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type navigation$IRoleBasedHomePage = {
        container: navigation$INavigationProfile,
        load(): navigation$RoleBasedHomePage,
        load(callback: (element: navigation$RoleBasedHomePage) => void): any
    } & navigation$IHomePageBase


    declare class RoleBasedHomePage mixins HomePageBase, IRoleBasedHomePage {
        typeName: string;
        container: navigation$NavigationProfile;
        userRole: security$IUserRole;
        userRoleQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class DeviceType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Desktop: navigation$DeviceType;
        Tablet: navigation$DeviceType;
        Phone: navigation$DeviceType
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     */
    declare type reports$IWidget = {
        load(): documenttemplates$Widget,
        load(callback: (element: documenttemplates$Widget) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Pages relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Widget mixins elements$Element, IWidget {
        typeName: string;
        name: string;
        class: string;
        style: string;
        tabIndex: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Widgets relevant section in reference guide}
     */
    declare type reports$IReportWidget = {
        load(): reports$ReportWidget,
        load(callback: (element: reports$ReportWidget) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Widgets relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ReportWidget mixins pages$Widget, IReportWidget {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Basic+Reports relevant section in reference guide}
     */
    declare type reports$IBasicReport = {
        load(): reports$BasicReport,
        load(callback: (element: reports$BasicReport) => void): any
    } & reports$IReportWidget



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Basic+Reports relevant section in reference guide}
     */
    declare class BasicReport mixins ReportWidget, IBasicReport {
        typeName: string;
        dataSet: datasets$IDataSet;
        dataSetQualifiedName: string;
        columns: instances$IList<reports$BasicReportColumn>;
        aggregates: instances$IList<reports$BasicReportAggregate>;
        showExportButton: boolean;
        zoomInfo: reports$ReportZoomInfo;
        isPagingEnabled: boolean;
        pageSize: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IBasicReportAggregate = {
        container: reports$IBasicReport,
        load(): reports$BasicReportAggregate,
        load(callback: (element: reports$BasicReportAggregate) => void): any
    }

    declare class BasicReportAggregate mixins elements$Element, IBasicReportAggregate {
        typeName: string;
        container: reports$BasicReport;
        caption: texts$Text;
        aggregateFunction: microflows$AggregateFunctionEnum;
        applicablePerColumn: instances$IList<boolean>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IBasicReportColumn = {
        container: reports$IBasicReport,
        load(): reports$BasicReportColumn,
        load(callback: (element: reports$BasicReportColumn) => void): any
    }

    declare class BasicReportColumn mixins elements$Element, IBasicReportColumn {
        typeName: string;
        container: reports$BasicReport;
        caption: texts$Text;
        dataSetColumnName: string;
        width: number;
        alignment: pages$AlignmentEnum;
        format: reports$ColumnFormat;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Button relevant section in reference guide}
     */
    declare type reports$IReportButton = {
        load(): reports$ReportButton,
        load(callback: (element: reports$ReportButton) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Button relevant section in reference guide}
     */
    declare class ReportButton mixins pages$Widget, IReportButton {
        typeName: string;
        caption: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Chart relevant section in reference guide}
     */
    declare type reports$IReportChart = {
        load(): reports$ReportChart,
        load(callback: (element: reports$ReportChart) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Chart relevant section in reference guide}
     */
    declare class ReportChart mixins pages$Widget, IReportChart {
        typeName: string;
        dataSet: datasets$IDataSet;
        dataSetQualifiedName: string;
        type: reports$ChartType;
        seriess: instances$IList<reports$ReportChartSeries>;
        xAxisCaption: texts$Text;
        yAxisCaption: texts$Text;
        xAxisColumn: string;
        xAxisFormat: reports$ColumnFormat;
        yAxisPrecision: number;
        yAxisUseMinMax: boolean;
        yAxisMinimum: number;
        yAxisMaximum: number;
        aspectRatio: reports$AspectRatio;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IReportChartSeries = {
        container: reports$IReportChart,
        load(): reports$ReportChartSeries,
        load(callback: (element: reports$ReportChartSeries) => void): any
    }

    declare class ReportChartSeries mixins elements$Element, IReportChartSeries {
        typeName: string;
        container: reports$ReportChart;
        caption: texts$Text;
        dataSetColumn: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Range+Field relevant section in reference guide}
     */
    declare type reports$IReportDateRangeField = {
        container: reports$IReportDateRangeSelector,
        load(): reports$ReportDateRangeField,
        load(callback: (element: reports$ReportDateRangeField) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Range+Field relevant section in reference guide}
     */
    declare class ReportDateRangeField mixins elements$Element, IReportDateRangeField {
        typeName: string;
        container: reports$ReportDateRangeSelector;
        caption: texts$Text;
        type: reports$DateRangeFieldEnum;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IReportParameter = {
        load(): reports$ReportParameter,
        load(callback: (element: reports$ReportParameter) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ReportParameter mixins pages$Widget, IReportParameter {
        typeName: string;
        parameterName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Range+Selector relevant section in reference guide}
     */
    declare type reports$IReportDateRangeSelector = {
        load(): reports$ReportDateRangeSelector,
        load(callback: (element: reports$ReportDateRangeSelector) => void): any
    } & reports$IReportParameter



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Date+Range+Selector relevant section in reference guide}
     */
    declare class ReportDateRangeSelector mixins ReportParameter, IReportDateRangeSelector {
        typeName: string;
        fields: instances$IList<reports$ReportDateRangeField>;
        minYear: number;
        maxYear: number;
        fieldsPerRow: number;
        showFromToRange: boolean;
        fromCaption: texts$Text;
        toCaption: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop+Down relevant section in reference guide}
     */
    declare type reports$IReportDropDown = {
        load(): reports$ReportDropDown,
        load(callback: (element: reports$ReportDropDown) => void): any
    } & reports$IReportParameter



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Drop+Down relevant section in reference guide}
     */
    declare class ReportDropDown mixins ReportParameter, IReportDropDown {
        typeName: string;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Pane relevant section in reference guide}
     */
    declare type reports$IReportPane = {
        load(): reports$ReportPane,
        load(callback: (element: reports$ReportPane) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Report+Pane relevant section in reference guide}
     */
    declare class ReportPane mixins pages$Widget, IReportPane {
        typeName: string;
        parameterWidget: pages$Widget;
        reportWidget: pages$Widget;
        generateOnLoad: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IReportZoomInfo = {
        container: reports$IBasicReport,
        load(): reports$ReportZoomInfo,
        load(callback: (element: reports$ReportZoomInfo) => void): any
    }

    declare class ReportZoomInfo mixins elements$Element, IReportZoomInfo {
        typeName: string;
        container: reports$BasicReport;
        targetPage: pages$IPage;
        targetPageQualifiedName: string;
        mappings: instances$IList<reports$ReportZoomMapping>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type reports$IReportZoomMapping = {
        container: reports$IReportZoomInfo,
        load(): reports$ReportZoomMapping,
        load(callback: (element: reports$ReportZoomMapping) => void): any
    }

    declare class ReportZoomMapping mixins elements$Element, IReportZoomMapping {
        typeName: string;
        container: reports$ReportZoomInfo;
        targetParameterName: string;
        sourceReportColumnName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class AggregateFunctionEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Sum: reports$AggregateFunctionEnum;
        Average: reports$AggregateFunctionEnum;
        Count: reports$AggregateFunctionEnum;
        Minimum: reports$AggregateFunctionEnum;
        Maximum: reports$AggregateFunctionEnum
    }

    declare class ColumnFormat mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: reports$ColumnFormat;
        MonthName: reports$ColumnFormat;
        WeekdayName: reports$ColumnFormat
    }

    declare class ChartType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        VerticalBars: reports$ChartType;
        VerticalBars3D: reports$ChartType;
        HorizontalBars: reports$ChartType;
        Lines: reports$ChartType;
        Area: reports$ChartType
    }

    declare class AspectRatio mixins instances$IEnum {
        qualifiedTsTypeName: string;
        SixteenToNine: reports$AspectRatio;
        ThreeToTwo: reports$AspectRatio;
        FourToThree: reports$AspectRatio;
        OneToOne: reports$AspectRatio;
        ThreeToFour: reports$AspectRatio;
        TwoToThree: reports$AspectRatio;
        NineToSixteen: reports$AspectRatio
    }

    declare class DateRangeFieldEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Year: reports$DateRangeFieldEnum;
        Month: reports$DateRangeFieldEnum;
        Week: reports$DateRangeFieldEnum;
        Period: reports$DateRangeFieldEnum;
        Quarter: reports$DateRangeFieldEnum
    }
    declare type menus$IModuleDocument = {
        container: projects$IFolderBase,
        load(): documenttemplates$ModuleDocument,
        load(callback: (element: documenttemplates$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type menus$IDocument = {
        container: projects$IFolderBase,
        load(): documenttemplates$Document,
        load(callback: (element: documenttemplates$Document) => void): any,
        name: string
    } & menus$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu relevant section in reference guide}
     */
    declare type menus$IMenuDocument = {
        container: projects$IFolderBase,
        load(): menus$MenuDocument,
        load(callback: (element: menus$MenuDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu relevant section in reference guide}
     */
    declare class MenuDocument mixins projects$Document, IMenuDocument {
        typeName: string;
        container: projects$FolderBase;
        itemCollection: menus$MenuItemCollection;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type menus$IMenuItemContainer = {
        load(): menus$MenuItemContainer,
        load(callback: (element: menus$MenuItemContainer) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class MenuItemContainer mixins elements$Element, IMenuItemContainer {
        typeName: string;
        items: instances$IList<menus$MenuItem>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type menus$IMenuItemCollection = {
        load(): menus$MenuItemCollection,
        load(callback: (element: menus$MenuItemCollection) => void): any
    } & menus$IMenuItemContainer


    declare class MenuItemCollection mixins MenuItemContainer, IMenuItemCollection {
        typeName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Item relevant section in reference guide}
     */
    declare type menus$IMenuItem = {
        container: menus$IMenuItemContainer,
        load(): menus$MenuItem,
        load(callback: (element: menus$MenuItem) => void): any
    } & menus$IMenuItemContainer



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Menu+Item relevant section in reference guide}
     */
    declare class MenuItem mixins MenuItemContainer, IMenuItem {
        typeName: string;
        container: menus$MenuItemContainer;
        caption: texts$Text;
        icon: pages$Icon;
        action: pages$ClientAction;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type datasets$IModuleDocument = {
        container: projects$IFolderBase,
        load(): menus$ModuleDocument,
        load(callback: (element: menus$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type datasets$IDocument = {
        container: projects$IFolderBase,
        load(): menus$Document,
        load(callback: (element: menus$Document) => void): any,
        name: string
    } & datasets$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Sets relevant section in reference guide}
     */
    declare type datasets$IDataSet = {
        container: projects$IFolderBase,
        load(): datasets$DataSet,
        load(callback: (element: datasets$DataSet) => void): any,
        parameters: instances$IList<datasets$IDataSetParameter >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Data+Sets relevant section in reference guide}
     */
    declare class DataSet mixins projects$Document, IDataSet {
        typeName: string;
        container: projects$FolderBase;
        source: datasets$DataSetSource;
        parameters: instances$IList<datasets$DataSetParameter>;
        dataSetAccess: datasets$DataSetAccess;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetAccess = {
        container: datasets$IDataSet,
        load(): datasets$DataSetAccess,
        load(callback: (element: datasets$DataSetAccess) => void): any
    }

    declare class DataSetAccess mixins elements$Element, IDataSetAccess {
        typeName: string;
        container: datasets$DataSet;
        moduleRoleAccessList: instances$IList<datasets$DataSetModuleRoleAccess>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetColumn = {
        container: datasets$IJavaDataSetSource,
        load(): datasets$DataSetColumn,
        load(callback: (element: datasets$DataSetColumn) => void): any
    }

    declare class DataSetColumn mixins elements$Element, IDataSetColumn {
        typeName: string;
        container: datasets$JavaDataSetSource;
        name: string;
        type: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetConstraintAccess = {
        container: datasets$IDataSetParameterAccess,
        load(): datasets$DataSetConstraintAccess,
        load(callback: (element: datasets$DataSetConstraintAccess) => void): any
    }

    declare class DataSetConstraintAccess mixins elements$Element, IDataSetConstraintAccess {
        typeName: string;
        container: datasets$DataSetParameterAccess;
        constraintText: string;
        enabled: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetParameterConstraint = {
        container: datasets$IDataSetParameter,
        load(): datasets$DataSetParameterConstraint,
        load(callback: (element: datasets$DataSetParameterConstraint) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataSetParameterConstraint mixins elements$Element, IDataSetParameterConstraint {
        typeName: string;
        container: datasets$DataSetParameter;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type datasets$IDataSetDateTimeConstraint = {
        container: datasets$IDataSetParameter,
        load(): datasets$DataSetDateTimeConstraint,
        load(callback: (element: datasets$DataSetDateTimeConstraint) => void): any
    } & datasets$IDataSetParameterConstraint


    declare class DataSetDateTimeConstraint mixins DataSetParameterConstraint, IDataSetDateTimeConstraint {
        typeName: string;
        container: datasets$DataSetParameter;
        modifier: datasets$DateTimeIntervalModifier;
        length: datasets$DateTimeIntervalLength;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetModuleRoleAccess = {
        container: datasets$IDataSetAccess,
        load(): datasets$DataSetModuleRoleAccess,
        load(callback: (element: datasets$DataSetModuleRoleAccess) => void): any
    }

    declare class DataSetModuleRoleAccess mixins elements$Element, IDataSetModuleRoleAccess {
        typeName: string;
        container: datasets$DataSetAccess;
        parameterAccessList: instances$IList<datasets$DataSetParameterAccess>;
        moduleRole: security$IModuleRole;
        moduleRoleQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetNumericConstraint = {
        container: datasets$IDataSetParameter,
        load(): datasets$DataSetNumericConstraint,
        load(callback: (element: datasets$DataSetNumericConstraint) => void): any
    } & datasets$IDataSetParameterConstraint


    declare class DataSetNumericConstraint mixins DataSetParameterConstraint, IDataSetNumericConstraint {
        typeName: string;
        container: datasets$DataSetParameter;
        begin: string;
        applyBegin: boolean;
        end: string;
        applyEnd: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetObjectConstraint = {
        container: datasets$IDataSetParameter,
        load(): datasets$DataSetObjectConstraint,
        load(callback: (element: datasets$DataSetObjectConstraint) => void): any
    } & datasets$IDataSetParameterConstraint


    declare class DataSetObjectConstraint mixins DataSetParameterConstraint, IDataSetObjectConstraint {
        typeName: string;
        container: datasets$DataSetParameter;
        name: string;
        constraint: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetParameter = {
        container: datasets$IDataSet,
        load(): datasets$DataSetParameter,
        load(callback: (element: datasets$DataSetParameter) => void): any,
        name: string
    }

    declare class DataSetParameter mixins elements$Element, IDataSetParameter {
        typeName: string;
        container: datasets$DataSet;
        constraints: instances$IList<datasets$DataSetParameterConstraint>;
        name: string;
        type: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetParameterAccess = {
        container: datasets$IDataSetModuleRoleAccess,
        load(): datasets$DataSetParameterAccess,
        load(callback: (element: datasets$DataSetParameterAccess) => void): any
    }

    declare class DataSetParameterAccess mixins elements$Element, IDataSetParameterAccess {
        typeName: string;
        container: datasets$DataSetModuleRoleAccess;
        constraintAccessList: instances$IList<datasets$DataSetConstraintAccess>;
        parameterName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IDataSetSource = {
        container: datasets$IDataSet,
        load(): datasets$DataSetSource,
        load(callback: (element: datasets$DataSetSource) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DataSetSource mixins elements$Element, IDataSetSource {
        typeName: string;
        container: datasets$DataSet;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type datasets$IJavaDataSetSource = {
        container: datasets$IDataSet,
        load(): datasets$JavaDataSetSource,
        load(callback: (element: datasets$JavaDataSetSource) => void): any
    } & datasets$IDataSetSource


    declare class JavaDataSetSource mixins DataSetSource, IJavaDataSetSource {
        typeName: string;
        container: datasets$DataSet;
        columns: instances$IList<datasets$DataSetColumn>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type datasets$IOqlDataSetSource = {
        container: datasets$IDataSet,
        load(): datasets$OqlDataSetSource,
        load(callback: (element: datasets$OqlDataSetSource) => void): any
    } & datasets$IDataSetSource


    declare class OqlDataSetSource mixins DataSetSource, IOqlDataSetSource {
        typeName: string;
        container: datasets$DataSet;
        query: string;
        ignoreErrorsInQuery: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class DateTimeIntervalLength mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Day: datasets$DateTimeIntervalLength;
        Week: datasets$DateTimeIntervalLength;
        Period: datasets$DateTimeIntervalLength;
        Month: datasets$DateTimeIntervalLength;
        Quarter: datasets$DateTimeIntervalLength;
        Year: datasets$DateTimeIntervalLength
    }

    declare class DateTimeIntervalModifier mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Last: datasets$DateTimeIntervalModifier;
        This: datasets$DateTimeIntervalModifier;
        Next: datasets$DateTimeIntervalModifier;
        Past: datasets$DateTimeIntervalModifier;
        Future: datasets$DateTimeIntervalModifier;
        Always: datasets$DateTimeIntervalModifier
    }

    /**
     * See: {@link https://world.mendix.com/display/refguide5/Translatable+Texts relevant section in reference guide}
     */
    declare type texts$IText = {
        load(): texts$Text,
        load(callback: (element: texts$Text) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Translatable+Texts relevant section in reference guide}
     */
    declare class Text mixins elements$Element, IText {
        typeName: string;
        translations: instances$IList<texts$Translation>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type texts$ITranslation = {
        container: texts$IText,
        load(): texts$Translation,
        load(callback: (element: texts$Translation) => void): any
    }

    declare class Translation mixins elements$Element, ITranslation {
        typeName: string;
        container: texts$Text;
        languageCode: string;
        text: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Settings relevant section in reference guide}
     */
    declare type texts$ILanguage = {
        container: settings$IProjectSettings,
        load(): texts$Language,
        load(callback: (element: texts$Language) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Settings relevant section in reference guide}
     */
    declare class Language mixins elements$Element, ILanguage {
        typeName: string;
        container: settings$ProjectSettings;
        code: string;
        checkCompleteness: boolean;
        customDateFormat: string;
        customTimeFormat: string;
        customDateTimeFormat: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type texts$ISystemText = {
        container: texts$ISystemTextCollection,
        load(): texts$SystemText,
        load(callback: (element: texts$SystemText) => void): any
    }

    declare class SystemText mixins elements$Element, ISystemText {
        typeName: string;
        container: texts$SystemTextCollection;
        text: texts$Text;
        key: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type texts$IProjectDocument = {
        container: projects$IProject,
        load(): navigation$ProjectDocument,
        load(callback: (element: navigation$ProjectDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectDocument mixins units$ModelUnit, IProjectDocument {
        typeName: string;
        container: projects$Project;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/System+Texts relevant section in reference guide}
     */
    declare type texts$ISystemTextCollection = {
        container: projects$IProject,
        load(): texts$SystemTextCollection,
        load(callback: (element: texts$SystemTextCollection) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/System+Texts relevant section in reference guide}
     */
    declare class SystemTextCollection mixins projects$ProjectDocument, ISystemTextCollection {
        typeName: string;
        container: projects$Project;
        systemTexts: instances$IList<texts$SystemText>;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type javaactions$IModuleDocument = {
        container: projects$IFolderBase,
        load(): datasets$ModuleDocument,
        load(callback: (element: datasets$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type javaactions$IDocument = {
        container: projects$IFolderBase,
        load(): datasets$Document,
        load(callback: (element: datasets$Document) => void): any,
        name: string
    } & javaactions$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Java+Actions relevant section in reference guide}
     */
    declare type javaactions$IJavaAction = {
        container: projects$IFolderBase,
        load(): javaactions$JavaAction,
        load(callback: (element: javaactions$JavaAction) => void): any,
        parameters: instances$IList<javaactions$IJavaActionParameter>,
        returnType: string
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Java+Actions relevant section in reference guide}
     */
    declare class JavaAction mixins projects$Document, IJavaAction {
        typeName: string;
        container: projects$FolderBase;
        parameters: instances$IList<javaactions$JavaActionParameter>;
        returnType: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type javaactions$IJavaActionParameter = {
        container: javaactions$IJavaAction,
        load(): javaactions$JavaActionParameter,
        load(callback: (element: javaactions$JavaActionParameter) => void): any,
        name: string,
        type: string
    }

    declare class JavaActionParameter mixins elements$Element, IJavaActionParameter {
        typeName: string;
        container: javaactions$JavaAction;
        name: string;
        type: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type constants$IModuleDocument = {
        container: projects$IFolderBase,
        load(): javaactions$ModuleDocument,
        load(callback: (element: javaactions$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type constants$IDocument = {
        container: projects$IFolderBase,
        load(): javaactions$Document,
        load(callback: (element: javaactions$Document) => void): any,
        name: string
    } & constants$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Constants relevant section in reference guide}
     */
    declare type constants$IConstant = {
        container: projects$IFolderBase,
        load(): constants$Constant,
        load(callback: (element: constants$Constant) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Constants relevant section in reference guide}
     */
    declare class Constant mixins projects$Document, IConstant {
        typeName: string;
        container: projects$FolderBase;
        dataType: string;
        defaultValue: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type scheduledevents$IModuleDocument = {
        container: projects$IFolderBase,
        load(): constants$ModuleDocument,
        load(callback: (element: constants$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type scheduledevents$IDocument = {
        container: projects$IFolderBase,
        load(): constants$Document,
        load(callback: (element: constants$Document) => void): any,
        name: string
    } & scheduledevents$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Scheduled+Events relevant section in reference guide}
     */
    declare type scheduledevents$IScheduledEvent = {
        container: projects$IFolderBase,
        load(): scheduledevents$ScheduledEvent,
        load(callback: (element: scheduledevents$ScheduledEvent) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Scheduled+Events relevant section in reference guide}
     */
    declare class ScheduledEvent mixins projects$Document, IScheduledEvent {
        typeName: string;
        container: projects$FolderBase;
        startDateTime: string;
        timeZone: scheduledevents$TimeZoneEnum;
        interval: number;
        intervalType: scheduledevents$IntervalType;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        enabled: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare class IntervalType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Second: scheduledevents$IntervalType;
        Minute: scheduledevents$IntervalType;
        Hour: scheduledevents$IntervalType;
        Day: scheduledevents$IntervalType;
        Week: scheduledevents$IntervalType;
        Month: scheduledevents$IntervalType;
        Year: scheduledevents$IntervalType
    }

    declare class TimeZoneEnum mixins instances$IEnum {
        qualifiedTsTypeName: string;
        UTC: scheduledevents$TimeZoneEnum;
        Server: scheduledevents$TimeZoneEnum
    }
    declare type regularexpressions$IModuleDocument = {
        container: projects$IFolderBase,
        load(): scheduledevents$ModuleDocument,
        load(callback: (element: scheduledevents$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type regularexpressions$IDocument = {
        container: projects$IFolderBase,
        load(): scheduledevents$Document,
        load(callback: (element: scheduledevents$Document) => void): any,
        name: string
    } & regularexpressions$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Regular+Expressions relevant section in reference guide}
     */
    declare type regularexpressions$IRegularExpression = {
        container: projects$IFolderBase,
        load(): regularexpressions$RegularExpression,
        load(callback: (element: regularexpressions$RegularExpression) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Regular+Expressions relevant section in reference guide}
     */
    declare class RegularExpression mixins projects$Document, IRegularExpression {
        typeName: string;
        container: projects$FolderBase;
        regEx: string;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type images$IModuleDocument = {
        container: projects$IFolderBase,
        load(): regularexpressions$ModuleDocument,
        load(callback: (element: regularexpressions$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type images$IDocument = {
        container: projects$IFolderBase,
        load(): regularexpressions$Document,
        load(callback: (element: regularexpressions$Document) => void): any,
        name: string
    } & images$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Images relevant section in reference guide}
     */
    declare type images$IImageCollection = {
        container: projects$IFolderBase,
        load(): images$ImageCollection,
        load(callback: (element: images$ImageCollection) => void): any,
        images: instances$IList<images$IImage >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Images relevant section in reference guide}
     */
    declare class ImageCollection mixins projects$Document, IImageCollection {
        typeName: string;
        container: projects$FolderBase;
        images: instances$IList<images$Image>;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type images$IImage = {
        container: images$IImageCollection,
        load(): images$Image,
        load(callback: (element: images$Image) => void): any,
        name: string
    }

    declare class Image mixins elements$Element, IImage {
        typeName: string;
        container: images$ImageCollection;
        name: string;

        /**
         * ?
         */
        imageData: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type security$IAccessRuleContainerBase = {
        container: security$IProjectSecurity,
        load(): security$AccessRuleContainerBase,
        load(callback: (element: security$AccessRuleContainerBase) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AccessRuleContainerBase mixins elements$Element, IAccessRuleContainerBase {
        typeName: string;
        container: security$ProjectSecurity;
        accessRules: instances$IList<domainmodels$AccessRule>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type security$IDemoUser = {
        container: security$IProjectSecurity,
        load(): security$DemoUser,
        load(callback: (element: security$DemoUser) => void): any
    }

    declare class DemoUser mixins elements$Element, IDemoUser {
        typeName: string;
        container: security$ProjectSecurity;
        userName: string;
        password: string;
        entity: domainmodels$IEntity;
        entityQualifiedName: string;
        userRoleIds: instances$IList<security$IUserRole>;
        userRoleIdsQualifiedNames: string[];
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type security$IFileDocumentAccessRuleContainer = {
        container: security$IProjectSecurity,
        load(): security$FileDocumentAccessRuleContainer,
        load(callback: (element: security$FileDocumentAccessRuleContainer) => void): any
    } & security$IAccessRuleContainerBase


    declare class FileDocumentAccessRuleContainer mixins AccessRuleContainerBase, IFileDocumentAccessRuleContainer {
        typeName: string;
        container: security$ProjectSecurity;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type security$IImageAccessRuleContainer = {
        container: security$IProjectSecurity,
        load(): security$ImageAccessRuleContainer,
        load(callback: (element: security$ImageAccessRuleContainer) => void): any
    } & security$IAccessRuleContainerBase


    declare class ImageAccessRuleContainer mixins AccessRuleContainerBase, IImageAccessRuleContainer {
        typeName: string;
        container: security$ProjectSecurity;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Module+Role relevant section in reference guide}
     */
    declare type security$IModuleRole = {
        container: security$IModuleSecurity,
        load(): security$ModuleRole,
        load(callback: (element: security$ModuleRole) => void): any,
        name: string
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Module+Role relevant section in reference guide}
     */
    declare class ModuleRole mixins elements$Element, IModuleRole {
        typeName: string;
        container: security$ModuleSecurity;
        name: string;
        description: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Module+Security relevant section in reference guide}
     */
    declare type security$IModuleSecurity = {
        container: projects$IModule,
        load(): security$ModuleSecurity,
        load(callback: (element: security$ModuleSecurity) => void): any,
        moduleRoles: instances$IList<security$IModuleRole >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Module+Security relevant section in reference guide}
     */
    declare class ModuleSecurity mixins units$ModelUnit, IModuleSecurity {
        typeName: string;
        container: projects$Module;
        moduleRoles: instances$IList<security$ModuleRole>;
        constructor(container: projects$IModule): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type security$IPasswordPolicySettings = {
        container: security$IProjectSecurity,
        load(): security$PasswordPolicySettings,
        load(callback: (element: security$PasswordPolicySettings) => void): any
    }

    declare class PasswordPolicySettings mixins elements$Element, IPasswordPolicySettings {
        typeName: string;
        container: security$ProjectSecurity;
        minimumLength: number;
        requireMixedCase: boolean;
        requireSymbol: boolean;
        requireDigit: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     */
    declare type security$IProjectDocument = {
        container: projects$IProject,
        load(): texts$ProjectDocument,
        load(callback: (element: texts$ProjectDocument) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project relevant section in reference guide}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ProjectDocument mixins units$ModelUnit, IProjectDocument {
        typeName: string;
        container: projects$Project;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Security relevant section in reference guide}
     */
    declare type security$IProjectSecurity = {
        container: projects$IProject,
        load(): security$ProjectSecurity,
        load(callback: (element: security$ProjectSecurity) => void): any,
        userRoles: instances$IList<security$IUserRole >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Project+Security relevant section in reference guide}
     */
    declare class ProjectSecurity mixins projects$ProjectDocument, IProjectSecurity {
        typeName: string;
        container: projects$Project;
        fileDocumentAccess: security$FileDocumentAccessRuleContainer;
        imageAccess: security$ImageAccessRuleContainer;
        passwordPolicySettings: security$PasswordPolicySettings;
        userRoles: instances$IList<security$UserRole>;
        demoUsers: instances$IList<security$DemoUser>;
        securityLevel: projects$SecurityLevel;
        checkSecurity: boolean;
        adminUserName: string;
        adminPassword: string;
        adminUserRoleName: string;
        enableDemoUsers: boolean;
        enableGuestAccess: boolean;
        guestUserRoleName: string;
        signInMicroflow: microflows$IMicroflow;
        signInMicroflowQualifiedName: string;
        constructor(container: projects$IProject): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/User+Role relevant section in reference guide}
     */
    declare type security$IUserRole = {
        container: security$IProjectSecurity,
        load(): security$UserRole,
        load(callback: (element: security$UserRole) => void): any,
        name: string
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/User+Role relevant section in reference guide}
     */
    declare class UserRole mixins elements$Element, IUserRole {
        typeName: string;
        container: security$ProjectSecurity;
        guid: string;
        name: string;
        description: string;
        moduleRoleIds: instances$IList<security$IModuleRole>;
        moduleRoleIdsQualifiedNames: string[];
        manageAllRoles: boolean;
        manageableRoleIds: instances$IList<security$IUserRole>;
        manageableRoleIdsQualifiedNames: string[];
        manageUsersWithoutRoles: boolean;
        checkSecurity: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }
    declare type domainmodels$IModuleDocument = {
        container: projects$IFolderBase,
        load(): images$ModuleDocument,
        load(callback: (element: images$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Domain+Model relevant section in reference guide}
     */
    declare type domainmodels$IDomainModel = {
        container: projects$IModule,
        load(): domainmodels$DomainModel,
        load(callback: (element: domainmodels$DomainModel) => void): any,
        entities: instances$IList<domainmodels$IEntity>,
        associations: instances$IList<domainmodels$IAssociation>,
        crossAssociations: instances$IList<domainmodels$ICrossAssociation >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Domain+Model relevant section in reference guide}
     */
    declare class DomainModel mixins projects$ModuleDocument, IDomainModel {
        typeName: string;
        container: projects$Module;
        documentation: string;
        entities: instances$IList<domainmodels$Entity>;
        annotations: instances$IList<microflows$Annotation>;
        associations: instances$IList<domainmodels$Association>;
        crossAssociations: instances$IList<domainmodels$CrossAssociation>;
        constructor(container: projects$IModule): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Entities relevant section in reference guide}
     */
    declare type domainmodels$IEntity = {
        container: domainmodels$IDomainModel,
        load(): domainmodels$Entity,
        load(callback: (element: domainmodels$Entity) => void): any,
        name: string,
        generalization: domainmodels$IGeneralizationBase,
        attributes: instances$IList<domainmodels$IAttribute >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Entities relevant section in reference guide}
     */
    declare class Entity mixins elements$Element, IEntity {
        typeName: string;
        container: domainmodels$DomainModel;
        name: string;
        dataStorageGuid: string;
        location: common$IPoint;
        documentation: string;
        generalization: domainmodels$GeneralizationBase;
        attributes: instances$IList<domainmodels$Attribute>;
        validationRules: instances$IList<domainmodels$ValidationRule>;
        eventHandlers: instances$IList<domainmodels$EventHandler>;
        indexes: instances$IList<domainmodels$Index>;
        accessRules: instances$IList<domainmodels$AccessRule>;
        image: images$IImage;
        imageQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IGeneralizationBase = {
        container: domainmodels$IEntity,
        load(): domainmodels$GeneralizationBase,
        load(callback: (element: domainmodels$GeneralizationBase) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class GeneralizationBase mixins elements$Element, IGeneralizationBase {
        typeName: string;
        container: domainmodels$Entity;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IGeneralization = {
        container: domainmodels$IEntity,
        load(): domainmodels$Generalization,
        load(callback: (element: domainmodels$Generalization) => void): any,
        generalization: domainmodels$IEntity,
        generalizationQualifiedName: string
    } & domainmodels$IGeneralizationBase


    declare class Generalization mixins GeneralizationBase, IGeneralization {
        typeName: string;
        container: domainmodels$Entity;
        generalization: domainmodels$IEntity;
        generalizationQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$INoGeneralization = {
        container: domainmodels$IEntity,
        load(): domainmodels$NoGeneralization,
        load(callback: (element: domainmodels$NoGeneralization) => void): any,
        persistable: boolean
    } & domainmodels$IGeneralizationBase


    declare class NoGeneralization mixins GeneralizationBase, INoGeneralization {
        typeName: string;
        container: domainmodels$Entity;
        hasChangedDate: boolean;
        hasCreatedDate: boolean;
        hasOwner: boolean;
        hasChangedBy: boolean;
        persistable: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Attributes relevant section in reference guide}
     */
    declare type domainmodels$IAttribute = {
        container: domainmodels$IEntity,
        load(): domainmodels$Attribute,
        load(callback: (element: domainmodels$Attribute) => void): any,
        name: string,
        type: domainmodels$IAttributeType
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Attributes relevant section in reference guide}
     */
    declare class Attribute mixins elements$Element, IAttribute {
        typeName: string;
        container: domainmodels$Entity;
        name: string;
        dataStorageGuid: string;
        type: domainmodels$AttributeType;
        documentation: string;
        value: domainmodels$ValueType;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IValueType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$ValueType,
        load(callback: (element: domainmodels$ValueType) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ValueType mixins elements$Element, IValueType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IStoredValue = {
        container: domainmodels$IAttribute,
        load(): domainmodels$StoredValue,
        load(callback: (element: domainmodels$StoredValue) => void): any
    } & domainmodels$IValueType


    declare class StoredValue mixins ValueType, IStoredValue {
        typeName: string;
        container: domainmodels$Attribute;
        defaultValue: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$ICalculatedValue = {
        container: domainmodels$IAttribute,
        load(): domainmodels$CalculatedValue,
        load(callback: (element: domainmodels$CalculatedValue) => void): any
    } & domainmodels$IValueType


    declare class CalculatedValue mixins ValueType, ICalculatedValue {
        typeName: string;
        container: domainmodels$Attribute;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        passEntity: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$AttributeType,
        load(callback: (element: domainmodels$AttributeType) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AttributeType mixins elements$Element, IAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IBinaryAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$BinaryAttributeType,
        load(callback: (element: domainmodels$BinaryAttributeType) => void): any
    } & domainmodels$IAttributeType


    declare class BinaryAttributeType mixins AttributeType, IBinaryAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IBooleanAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$BooleanAttributeType,
        load(callback: (element: domainmodels$BooleanAttributeType) => void): any
    } & domainmodels$IAttributeType


    declare class BooleanAttributeType mixins AttributeType, IBooleanAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IDateTimeAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$DateTimeAttributeType,
        load(callback: (element: domainmodels$DateTimeAttributeType) => void): any
    } & domainmodels$IAttributeType


    declare class DateTimeAttributeType mixins AttributeType, IDateTimeAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        localizeDate: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IEnumerationAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$EnumerationAttributeType,
        load(callback: (element: domainmodels$EnumerationAttributeType) => void): any,
        enumeration: enumerations$IEnumeration,
        enumerationQualifiedName: string
    } & domainmodels$IAttributeType


    declare class EnumerationAttributeType mixins AttributeType, IEnumerationAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        enumeration: enumerations$IEnumeration;
        enumerationQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IHashedStringAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$HashedStringAttributeType,
        load(callback: (element: domainmodels$HashedStringAttributeType) => void): any
    } & domainmodels$IAttributeType


    declare class HashedStringAttributeType mixins AttributeType, IHashedStringAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IStringAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$StringAttributeType,
        load(callback: (element: domainmodels$StringAttributeType) => void): any
    } & domainmodels$IAttributeType


    declare class StringAttributeType mixins AttributeType, IStringAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        length: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$INumericAttributeTypeBase = {
        container: domainmodels$IAttribute,
        load(): domainmodels$NumericAttributeTypeBase,
        load(callback: (element: domainmodels$NumericAttributeTypeBase) => void): any
    } & domainmodels$IAttributeType



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class NumericAttributeTypeBase mixins AttributeType, INumericAttributeTypeBase {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IDecimalAttributeTypeBase = {
        container: domainmodels$IAttribute,
        load(): domainmodels$DecimalAttributeTypeBase,
        load(callback: (element: domainmodels$DecimalAttributeTypeBase) => void): any
    } & domainmodels$INumericAttributeTypeBase



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class DecimalAttributeTypeBase mixins NumericAttributeTypeBase, IDecimalAttributeTypeBase {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IDecimalAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$DecimalAttributeType,
        load(callback: (element: domainmodels$DecimalAttributeType) => void): any
    } & domainmodels$IDecimalAttributeTypeBase


    declare class DecimalAttributeType mixins DecimalAttributeTypeBase, IDecimalAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IFloatAttributeTypeBase = {
        container: domainmodels$IAttribute,
        load(): domainmodels$FloatAttributeTypeBase,
        load(callback: (element: domainmodels$FloatAttributeTypeBase) => void): any
    } & domainmodels$IDecimalAttributeTypeBase



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class FloatAttributeTypeBase mixins DecimalAttributeTypeBase, IFloatAttributeTypeBase {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IFloatAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$FloatAttributeType,
        load(callback: (element: domainmodels$FloatAttributeType) => void): any
    } & domainmodels$IFloatAttributeTypeBase


    declare class FloatAttributeType mixins FloatAttributeTypeBase, IFloatAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$ICurrencyAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$CurrencyAttributeType,
        load(callback: (element: domainmodels$CurrencyAttributeType) => void): any
    } & domainmodels$IFloatAttributeTypeBase


    declare class CurrencyAttributeType mixins FloatAttributeTypeBase, ICurrencyAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IIntegerAttributeTypeBase = {
        container: domainmodels$IAttribute,
        load(): domainmodels$IntegerAttributeTypeBase,
        load(callback: (element: domainmodels$IntegerAttributeTypeBase) => void): any
    } & domainmodels$INumericAttributeTypeBase



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class IntegerAttributeTypeBase mixins NumericAttributeTypeBase, IIntegerAttributeTypeBase {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IIntegerAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$IntegerAttributeType,
        load(callback: (element: domainmodels$IntegerAttributeType) => void): any
    } & domainmodels$IIntegerAttributeTypeBase


    declare class IntegerAttributeType mixins IntegerAttributeTypeBase, IIntegerAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$ILongAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$LongAttributeType,
        load(callback: (element: domainmodels$LongAttributeType) => void): any
    } & domainmodels$IIntegerAttributeTypeBase


    declare class LongAttributeType mixins IntegerAttributeTypeBase, ILongAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IAutoNumberAttributeType = {
        container: domainmodels$IAttribute,
        load(): domainmodels$AutoNumberAttributeType,
        load(callback: (element: domainmodels$AutoNumberAttributeType) => void): any
    } & domainmodels$IIntegerAttributeTypeBase


    declare class AutoNumberAttributeType mixins IntegerAttributeTypeBase, IAutoNumberAttributeType {
        typeName: string;
        container: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Associations TODO: This is whre it belongs, but the word AssociationBase is never used}
     */
    declare type domainmodels$IAssociationBase = {
        container: domainmodels$IDomainModel,
        load(): domainmodels$AssociationBase,
        load(callback: (element: domainmodels$AssociationBase) => void): any,
        name: string,
        type: domainmodels$AssociationType,
        owner: domainmodels$AssociationOwner,
        parent: domainmodels$IEntity
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Associations TODO: This is whre it belongs, but the word AssociationBase is never used}
     * 
    Warning: this class represents a non-instantiable concept in the meta model,
    i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class AssociationBase mixins elements$Element, IAssociationBase {
        typeName: string;
        container: domainmodels$DomainModel;
        name: string;
        dataStorageGuid: string;
        type: domainmodels$AssociationType;
        owner: domainmodels$AssociationOwner;
        deleteBehavior: domainmodels$AssociationDeleteBehavior;
        parent: domainmodels$Entity;
        documentation: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Associations relevant section in reference guide}
     */
    declare type domainmodels$IAssociation = {
        container: domainmodels$IDomainModel,
        load(): domainmodels$Association,
        load(callback: (element: domainmodels$Association) => void): any,
        child: domainmodels$IEntity
    } & domainmodels$IAssociationBase



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Associations relevant section in reference guide}
     */
    declare class Association mixins AssociationBase, IAssociation {
        typeName: string;
        container: domainmodels$DomainModel;
        child: domainmodels$Entity;
        parentConnection: common$IPoint;
        childConnection: common$IPoint;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$ICrossAssociation = {
        container: domainmodels$IDomainModel,
        load(): domainmodels$CrossAssociation,
        load(callback: (element: domainmodels$CrossAssociation) => void): any,
        child: domainmodels$IEntity,
        childQualifiedName: string
    } & domainmodels$IAssociationBase


    declare class CrossAssociation mixins AssociationBase, ICrossAssociation {
        typeName: string;
        container: domainmodels$DomainModel;
        child: domainmodels$IEntity;
        childQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IAssociationDeleteBehavior = {
        container: domainmodels$IAssociationBase,
        load(): domainmodels$AssociationDeleteBehavior,
        load(callback: (element: domainmodels$AssociationDeleteBehavior) => void): any
    }

    declare class AssociationDeleteBehavior mixins elements$Element, IAssociationDeleteBehavior {
        typeName: string;
        container: domainmodels$AssociationBase;
        parentDeleteBehavior: domainmodels$DeletingBehavior;
        childDeleteBehavior: domainmodels$DeletingBehavior;
        parentErrorMessage: texts$Text;
        childErrorMessage: texts$Text;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotation relevant section in reference guide}
     */
    declare type domainmodels$IAnnotation = {
        container: microflows$IMicroflowObjectCollection,
        load(): microflows$Annotation,
        load(callback: (element: microflows$Annotation) => void): any
    } & microflows$IMicroflowObject



    /**
     * See: {@link https://world.mendix.com/display/refguide5/Annotations relevant section in reference guide}
     */
    declare class Annotation mixins elements$Element, IAnnotation {
        typeName: string;
        container: domainmodels$DomainModel;
        caption: string;
        location: common$IPoint;
        width: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Access+Rules relevant section in reference guide}
     */
    declare type domainmodels$IAccessRule = {
        load(): domainmodels$AccessRule,
        load(callback: (element: domainmodels$AccessRule) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Access+Rules relevant section in reference guide}
     */
    declare class AccessRule mixins elements$Element, IAccessRule {
        typeName: string;
        memberAccesses: instances$IList<domainmodels$MemberAccess>;
        moduleRoles: instances$IList<security$IModuleRole>;
        moduleRolesQualifiedNames: string[];
        documentation: string;
        allowCreate: boolean;
        allowDelete: boolean;
        defaultMemberAccessRights: domainmodels$MemberAccessRights;

        /**
         * The value of this property is conceptually of type XPathConstraints$XPathConstraint.
         */
        xPathConstraint: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IMemberAccess = {
        container: domainmodels$IAccessRule,
        load(): domainmodels$MemberAccess,
        load(callback: (element: domainmodels$MemberAccess) => void): any
    }

    declare class MemberAccess mixins elements$Element, IMemberAccess {
        typeName: string;
        container: domainmodels$AccessRule;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        association: domainmodels$IAssociationBase;
        associationQualifiedName: string;
        accessRights: domainmodels$MemberAccessRights;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Event+Handlers relevant section in reference guide}
     */
    declare type domainmodels$IEventHandler = {
        container: domainmodels$IEntity,
        load(): domainmodels$EventHandler,
        load(callback: (element: domainmodels$EventHandler) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Event+Handlers relevant section in reference guide}
     */
    declare class EventHandler mixins elements$Element, IEventHandler {
        typeName: string;
        container: domainmodels$Entity;
        moment: domainmodels$ActionMoment;
        event: domainmodels$EventType;
        microflow: microflows$IMicroflow;
        microflowQualifiedName: string;
        raiseErrorOnFalse: boolean;
        passEventObject: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Indexes relevant section in reference guide}
     */
    declare type domainmodels$IIndex = {
        container: domainmodels$IEntity,
        load(): domainmodels$Index,
        load(callback: (element: domainmodels$Index) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Indexes relevant section in reference guide}
     */
    declare class Index mixins elements$Element, IIndex {
        typeName: string;
        container: domainmodels$Entity;
        dataStorageGuid: string;
        attributes: instances$IList<domainmodels$IndexedAttribute>;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IIndexedAttribute = {
        container: domainmodels$IIndex,
        load(): domainmodels$IndexedAttribute,
        load(callback: (element: domainmodels$IndexedAttribute) => void): any
    }

    declare class IndexedAttribute mixins elements$Element, IIndexedAttribute {
        typeName: string;
        container: domainmodels$Index;
        type: domainmodels$IndexedAttributeType;
        attribute: domainmodels$Attribute;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Validation+Rules relevant section in reference guide}
     */
    declare type domainmodels$IValidationRule = {
        container: domainmodels$IEntity,
        load(): domainmodels$ValidationRule,
        load(callback: (element: domainmodels$ValidationRule) => void): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Validation+Rules relevant section in reference guide}
     */
    declare class ValidationRule mixins elements$Element, IValidationRule {
        typeName: string;
        container: domainmodels$Entity;
        attribute: domainmodels$IAttribute;
        attributeQualifiedName: string;
        errorMessage: texts$Text;
        ruleInfo: domainmodels$RuleInfo;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$RuleInfo,
        load(callback: (element: domainmodels$RuleInfo) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class RuleInfo mixins elements$Element, IRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IEqualsToRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$EqualsToRuleInfo,
        load(callback: (element: domainmodels$EqualsToRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class EqualsToRuleInfo mixins RuleInfo, IEqualsToRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        useValue: boolean;
        equalsToValue: string;
        equalsToAttribute: domainmodels$IAttribute;
        equalsToAttributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IMaxLengthRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$MaxLengthRuleInfo,
        load(callback: (element: domainmodels$MaxLengthRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class MaxLengthRuleInfo mixins RuleInfo, IMaxLengthRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        maxLength: number;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IRangeRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$RangeRuleInfo,
        load(callback: (element: domainmodels$RangeRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class RangeRuleInfo mixins RuleInfo, IRangeRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        typeOfRange: domainmodels$RangeType;
        useMinValue: boolean;
        useMaxValue: boolean;
        minValue: string;
        maxValue: string;
        minAttribute: domainmodels$IAttribute;
        minAttributeQualifiedName: string;
        maxAttribute: domainmodels$IAttribute;
        maxAttributeQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IRegExRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$RegExRuleInfo,
        load(callback: (element: domainmodels$RegExRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class RegExRuleInfo mixins RuleInfo, IRegExRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        regularExpression: regularexpressions$IRegularExpression;
        regularExpressionQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type domainmodels$IRequiredRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$RequiredRuleInfo,
        load(callback: (element: domainmodels$RequiredRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class RequiredRuleInfo mixins RuleInfo, IRequiredRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type domainmodels$IUniqueRuleInfo = {
        container: domainmodels$IValidationRule,
        load(): domainmodels$UniqueRuleInfo,
        load(callback: (element: domainmodels$UniqueRuleInfo) => void): any
    } & domainmodels$IRuleInfo


    declare class UniqueRuleInfo mixins RuleInfo, IUniqueRuleInfo {
        typeName: string;
        container: domainmodels$ValidationRule;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare class AssociationType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Reference: domainmodels$AssociationType;
        ReferenceSet: domainmodels$AssociationType
    }

    declare class AssociationOwner mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Default: domainmodels$AssociationOwner;
        Both: domainmodels$AssociationOwner
    }

    declare class DeletingBehavior mixins instances$IEnum {
        qualifiedTsTypeName: string;
        DeleteMeAndReferences: domainmodels$DeletingBehavior;
        DeleteMeButKeepReferences: domainmodels$DeletingBehavior;
        DeleteMeIfNoReferences: domainmodels$DeletingBehavior
    }

    declare class MemberAccessRights mixins instances$IEnum {
        qualifiedTsTypeName: string;
        None: domainmodels$MemberAccessRights;
        ReadOnly: domainmodels$MemberAccessRights;
        ReadWrite: domainmodels$MemberAccessRights
    }

    declare class ActionMoment mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Before: domainmodels$ActionMoment;
        After: domainmodels$ActionMoment
    }

    declare class EventType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Create: domainmodels$EventType;
        Commit: domainmodels$EventType;
        Delete: domainmodels$EventType;
        RollBack: domainmodels$EventType
    }

    declare class IndexedAttributeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        Normal: domainmodels$IndexedAttributeType;
        CreatedDate: domainmodels$IndexedAttributeType;
        ChangedDate: domainmodels$IndexedAttributeType
    }

    declare class RangeType mixins instances$IEnum {
        qualifiedTsTypeName: string;
        GreaterThanOrEqualTo: domainmodels$RangeType;
        SmallerThanOrEqualTo: domainmodels$RangeType;
        Between: domainmodels$RangeType
    }
    declare type enumerations$IModuleDocument = {
        container: projects$IFolderBase,
        load(): domainmodels$ModuleDocument,
        load(callback: (element: domainmodels$ModuleDocument) => void): any
    }


    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class ModuleDocument mixins units$ModelUnit, IModuleDocument {
        typeName: string;
        container: projects$FolderBase;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): Object
    }

    declare type enumerations$IDocument = {
        container: projects$IFolderBase,
        load(): images$Document,
        load(callback: (element: images$Document) => void): any,
        name: string
    } & enumerations$IModuleDocument



    /**
     * Warning: this class represents a non-instantiable concept in the meta model,
     * i.e. it is effectively abstract and you should _not_ try to instantiate this class directly,
    but instantiate one of its (effectively concrete) sub classes.
    Instantiating this class is not impossible, but there's no guarantee the result will be useful.
    */
    declare class Document mixins projects$ModuleDocument, IDocument {
        typeName: string;
        container: projects$FolderBase;
        name: string;
        documentation: string;
        excluded: boolean;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Enumerations relevant section in reference guide}
     */
    declare type enumerations$IEnumeration = {
        container: projects$IFolderBase,
        load(): enumerations$Enumeration,
        load(callback: (element: enumerations$Enumeration) => void): any,
        values: instances$IList<enumerations$IEnumerationValue >
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Enumerations relevant section in reference guide}
     */
    declare class Enumeration mixins projects$Document, IEnumeration {
        typeName: string;
        container: projects$FolderBase;
        values: instances$IList<enumerations$EnumerationValue>;
        constructor(container: projects$IFolderBase): this;
        constructor(isCreatingNewInstance: boolean, model: model$Model, container: units$StructuralUnit, json: transport$IAbstractUnitJson, isPartial: boolean): this;
        toPlainJson(): any
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Enumerations relevant section in reference guide}
     */
    declare type enumerations$IEnumerationValue = {
        container: enumerations$IEnumeration,
        load(): enumerations$EnumerationValue,
        load(callback: (element: enumerations$EnumerationValue) => void): any,
        name: string
    }


    /**
     * See: {@link https://world.mendix.com/display/refguide5/Enumerations relevant section in reference guide}
     */
    declare class EnumerationValue mixins elements$Element, IEnumerationValue {
        typeName: string;
        container: enumerations$Enumeration;
        name: string;
        caption: texts$Text;
        image: images$IImage;
        imageQualifiedName: string;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    declare type enumerations$ICondition = {
        load(): enumerations$Condition,
        load(callback: (element: enumerations$Condition) => void): any
    }

    declare class Condition mixins elements$Element, ICondition {
        typeName: string;
        attributeValue: string;
        editableVisible: boolean;
        constructor(): this;
        constructor(isCreatingNewInstance: boolean, unit: units$ModelUnit, container: elements$AbstractElement, json: transport$IAbstractElementJson, isPartial: boolean): this;
        toPlainJson(): any
    }

    /**
     * This interface exposes a single Mendix Model.
     * This interface contains the parts of the {@link Model} that are exposed through the SDK.
     */
    declare type IModel = {

            /**
             * Working copy id of the current opened model (read only)
             */
            id: string,

            /**
             * The actual contents of the model.
             */
            root: projects$IProject,

            /**
             * The meta data of the model.
             */
            metadata: undefined.IWorkingCopy,

            /**
             * Ends the connection with the Model API client.
             * Flushes any pending deltas and invokes the callback once complete.
            (Errors will be handled through the default modelstore error handler.)
            */
            closeConnection(callback: common$IVoidCallback, errorCallback?: common$IErrorCallback): any,

            /**
             * Deletes this model from the server, and the (SDK) client.
             * If you are altering the model before deleting it, make sure to call this method in the callback of {@link closeConnection}.
             */
            deleteWorkingCopy(callback: common$IVoidCallback, errorCallback?: common$IErrorCallback): any,

            /**
             * Exports this model as MPK.
             * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
             */
            exportMpk(
                outFilePath: string,
                callback: common$IVoidCallback,
                errorCallback?: common$IErrorCallback): any,

            /**
             * Given a moduleName, returns a module name
             * (For modules, their qualified name equals their name)
             */
            findModuleByQualifiedName(qname: string): any,

            /**
             * Given an id, fetches a complete unit. The result might be returned from the cache.
             * Use this method if you have just a unit Id, otherwise, unit.fetch() is a simpler alternative.
             */
            fetchUnitById<T>(
                id: string,
                callback: common$ICallback<T>,
                errorCallback?: common$IErrorCallback): any
        } & &


        /**
         * Client class of the Mendix Model Sdk.
         * By instantiating this class with appropriate configuration, you can create and read working copies.
         */
        declare class ModelSdkClient {
            constructor(connectionConfig: configuration$ISdkConfig): this;

            /**
             * Create a new working copy on the model server, and reads it for immediate editing.
             */
            createWorkingCopy(
                workingCopyParameters: configuration$ICreateWorkingCopyParameters,
                callback: common$ICallback<IModel>,
                errorCallback: common$IErrorCallback): void;

            /**
             * Reads a working copy on the model server so it can be edited.
             */
            openWorkingCopy(
                workingCopyId: string,
                callback: common$ICallback<IModel>,
                errorCallback: common$IErrorCallback): void;

            /**
             * Deletes this working copy from the server, and the (SDK) client.
             */
            deleteWorkingCopy(
                workingCopyId: string,
                callback: common$IVoidCallback,
                errorCallback: common$IErrorCallback): void;

            /**
             * Grants access to the member specified to his/her OpenID on this working copy.
             */
            grantAccess(
                workingCopyId: string,
                memberOpenId: string,
                callback: common$IVoidCallback,
                errorCallback: common$IErrorCallback): void;

            /**
             * Revokes access of the member specified to his/her OpenID on this working copy.
             */
            revokeAccess(
                workingCopyId: string,
                memberOpenId: string,
                callback: common$IVoidCallback,
                errorCallback: common$IErrorCallback): void;

            /**
             * Returns whether the member specified to his/her OpenID has (been granted) access to this working copy.
             */
            checkAccess(
                workingCopyId: string,
                memberOpenId: string,
                callback: common$ICallback<boolean>,
                errorCallback: common$IErrorCallback): void;

            /**
             * Exports this working copy as MPK.
             */
            exportMpk(
                workingCopyId: string,
                outFilePath: string,
                callback: common$IVoidCallback,
                errorCallback: common$IErrorCallback): void
        }
}
declare var mobservable: IMobservableStatic;
declare var global: any;
declare var require: {
    (id: string): any,
    resolve(id: string): string,
    cache: any,
    extensions: any,
    main: any
};
declare var module: {
    exports: any,
    require(id: string): any,
    id: string,
    filename: string,
    loaded: boolean,
    parent: any,
    children: any[]
};