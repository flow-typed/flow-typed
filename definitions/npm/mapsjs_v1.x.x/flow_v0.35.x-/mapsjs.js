// @flow
/**
 * Flowtype definitions for mapsjs
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'mapsjs' {

    /**
     * Clusters a set of points.
     * @param  An options object which specifies the clustering algorithm.
     * @returns  An array of clustered points.
     */
    declare     export function clusterPoints(
        options: {
            data: {}[],
            pointKey: string,
            valueFunction?: (row: any) => number,
            radiusFunction: (row: any) => number,
            aggregateFunction?: (srcRow: any, cmpRow: any, aggRow: any) => void,
            mapUnitsPerPixel: number,
            marginPixels?: number
        }): {}[]
    declare module 'envelope' {

        /**
         * Creates a new envelope from MapDotNet XML.
         * @param  A MapDotNet XML string of the envelope.
         * @returns  A new envelope 
         */
        declare         export function createFromMdnXml(xml: string): envelope

        /**
         * Creates new envelope from two corner points.
         * @param  Corner point
         * @param  Opposite corner point
         * @returns  A new envelope
         */
        declare         export function createFromPoints(pt1: point, pt2: point): envelope

        /**
         * Creates a new envelope from the x and y coordinates of the center 
         * point and x and y margins from the center point.
         * @param  The center x coordinate.
         * @param  The center y coordinate.
         * @param  The margin from center x coordinate.
         * @param  The margin from center y coordinate.
         * @returns  A new envelope
         */
        declare         export function createFromCenterAndMargins(
            centerPtX: number,
            centerPtY: number,
            marginX: number,
            marginY: number): envelope

        /**
         * Tests whether two given envelopes intersect.
         * @param  First envelope to test.
         * @param  Second envelope to test.
         * @returns  Result of the intersection test.
         */
        declare         export function intersects(env1: envelope, env2: envelope): boolean

        /**
         * Creates a new envelope from the union of two given envelopes.
         * @param  The first enevelope to unite.
         * @param  The second envelope to unite.
         * @returns  A new envelope.
         */
        declare         export function union(env1: envelope, env2: envelope): envelope
    }

    declare module 'geometry' {

        /**
         * A polyline object which is an open path geometry with one or more paths.
         *    
         * @class  polyline
         */
        declare class polyline mixins geometry {
            constructor(geom: geometry): this;

            /**
             * Gets the underlying geometry of the polyline.
             * @returns  The polyline's underlying geometry object.
             */
            getGeometry(): geometry;

            /**
             * Creates a new polyline object from a deep copy of the underlying geometry.
             * @returns  Thew new cloned polyline.
             */
            clone(): polyline;

            /**
             * Gets number of lines in this polyline.
             * @returns  Number of lines.
             */
            getLineCount(): number;

            /**
             * Gets a line from this polyline's liune collection by index, or, 
             * if no index is provided, gets the last line.
             * @param  Index of the line to return.
             * @returns  A line as an array of points in the form [xn,yn].
             */
            getLine(idx: number): number[];

            /**
             * Adds a new line to this polyline's line collection.
             * @param  Line to add as an array of points in the form [xn,yn].
             */
            pushLine(s: number[]): void;

            /**
             * Gets the last line in the polyline's set collection and removes it 
             * from the collection.
             * @returns  Line removed as an array of points in the form [xn,yn].
             */
            popLine(): number[];

            /**
             * Calculates distance of a line in a polyline by index according 
             * to projected map cooordinates. If no index is provided, uses
            the last line in the polyline's set collection.
             * @param  Index of the line for which to compute the distance.
             * @returns  Length in projected units of the distance of the line.
            */
            getProjectedDistance(idx: number): number;

            /**
             * Calculates distance of a line in a polyline by index according 
             * to actual distance. If no index is provided, uses the last line 
            in the polyline's set collection.
             * @param  Index of the line for which to compute the distance.
             * @returns  Distance in meters of the line.
            */
            getActualDistance(idx?: number): number;

            /**
             * Determines whether this polyline intersects a given geometry.
             * @param  Geometry to test against.
             * @returns  Result of the intersection test.
             */
            intersects(geom: geometry): boolean
        }

        /**
         * A polyline object which is a closed path geometry with one or more paths.
         *    
         * @class  polygon
         */
        declare class polygon mixins geometry {
            constructor(geom: geometry): this;

            /**
             * Gets the underlying geometry of the polygon.
             * @returns  The polygon's underlying geometry object.
             */
            getGeometry(): geometry;

            /**
             * Creates a new polygon object from a deep copy of the underlying geometry.
             * @returns  Thew new cloned polygon.
             */
            clone(): polygon;

            /**
             * Gets number of rings in this polygon.
             * @returns  Number of rings.
             */
            getRingCount(): number;

            /**
             * Gets a ring from this polygon's set collection by index, or, 
             * if no index is provided, gets the last ring.
             * @param  Index of the ring to return.
             * @returns  A ring as an array of points in the form [xn,yn].
             */
            getRing(idx: number): number[];

            /**
             * Adds a new ring to this polygon's ring collection.
             * @param  Ring to add as an array of points in the form [xn,yn].
             */
            pushRing(s: number[]): void;

            /**
             * Gets the last ring in the polygon's ring collection and removes it 
             * from the collection.
             * @returns  Ring removed as an array of points in the form [xn,yn].
             */
            popRing(): number[];

            /**
             * Calculates area of a ring in a polygon by index according 
             * to projected map cooordinates. If no index is provided, uses
            the last ring in the polygon's ring collection.
             * @param  Index of the ring for which to compute the area.
             * @returns  Area in square projected units of the ring.
            */
            getProjectedArea(idx: number): number;

            /**
             * Calculates perimeter of a ring in a polygon by index according 
             * to projected map cooordinates. If no index is provided, uses
            the last ring in the polygon's ring collection.
             * @param  Index of the ring for which to compute the perimeter.
             * @returns  Length in projected units of the distance of the ring.
            */
            getProjectedPerimeter(idx: number): number;

            /**
             * Calculates area of a ring in a polygon by index according 
             * to the actual area. If no index is provided, uses the last ring
            in the polygon's ring collection.
             * @param  Index of the ring for which to compute the area.
             * @returns  Area in square meters of the ring.
            */
            getActualArea(idx?: number): number;

            /**
             * Calculates perimeter of a ring in a polygon by index according 
             * to actual distance. If no index is provided, uses the last ring
            in the polygon's ring collection.
             * @param  Index of the ring for which to compute the perimeter.
             * @returns  Length in meters of the perimeter of the ring.
            */
            getActualPerimeter(idx?: number): number;

            /**
             * Determines whether this polygon intersects a given geometry.
             * @param  Geometry to test against.
             * @returns  Result of the intersection test.
             */
            intersects(geom: geometry): boolean;

            /**
             * Determines whether this polyline overlaps a given geometry.
             * @param  Geometry to test against.
             * @returns  Result of the intersection test.
             */
            overlaps(poly: polygon): boolean;

            /**
             * Convert this polygon into an array of OGC compliant polygons where
             * the first set is a ring and all subsequent contained sets are holes.
             * @returns  An array of OGC polygons.
             */
            toMultiPolygon(): polygon[]
        }
    }


    /**
     * A style specification for geometry objects.
     * @class  geometryStyle
     */
    declare     export class geometryStyle {
        constructor(options?: styleObj): this;

        /**
         * Gets path outline thickness in pixels.
         * @returns  Thickness of path outline.
         */
        getOutlineThicknessPix(): number;

        /**
         * Sets path outline thickness in pixels.
         * @param  Desired thickness.
         */
        setOutlineThicknessPix(t: number): void;

        /**
         * Gets path outline color as a CSS style string.
         * @returns  Outline color as a CSS style string.
         */
        getOutlineColor(): string;

        /**
         * Sets path outline color from a CSS style string.
         * @param  Outline color as a CSS style string.
         */
        setOutlineColor(c: string): void;

        /**
         * Gets path outline opacity in decimal format.
         * @returns  Outline opacity.
         */
        getOutlineOpacity(): number;

        /**
         * Set path outline opacity to a decimal between 0 and 1.
         * @param  Outline opacity.
         */
        setOutlineOpacity(o: number): void;

        /**
         * Gets fill color as a CSS style string.
         * @returns  Fill color as a CSS style string.
         */
        getFillColor(): string;

        /**
         * Sets fill color as a CSS style string.
         * @param  Fill color as a CSS style string.
         */
        setFillColor(c: string): void;

        /**
         * Gets fill opacity in decimal format.
         * @returns  Fill opacity.
         */
        getFillOpacity(): number;

        /**
         * Sets fill opacity to a decimal between 0 and 1.
         * @param  Fill opacity.
         */
        setFillOpacity(o: number): void;

        /**
         * Gets the dash array as a string.
         * @returns  Dash array as astring.
         */
        getDashArray(): string;

        /**
         * Sets dash array string from a CSS style string. Defaults to solid
         * stroke if no dash array string is provided.
         * @param  Dash array as a CSS style string.
         */
        setDashArray(da: string): void
    }
    declare     export var license: string;
    declare module 'point' {

        /**
         * Computes the distance between two points in coordinate units.
         * @param  The x coordinate for the first point.
         * @param  The y coordinate for the first point. 
         * @param  The x coordinate for the second point. 
         * @param  The y coordinate for the second point. 
         * @returns  Distance in coordinate units.
         */
        declare         export function distance(x1: number, y1: number, x2: number, y2: number): number

        /**
         * Computes the midpoint of two points.
         * @param  The x coordinate for the first point.
         * @param  The y coordinate for the first point. 
         * @param  The x coordinate for the second point. 
         * @param  The y coordinate for the second point. 
         * @return  Midpoint point.
         */
        declare         export function midpoint(x1: number, y1: number, x2: number, y2: number): point
    }

    declare module 'sphericalMercator' {

        /**
         * Gets the EPSG number for Spherical Mercator.
         * @return  ESPG number.
         */
        declare         export function getEpsg(): number

        /**
         * Gets the minimum zoom level for this projection.
         * @returns  Minimum zoom level.
         */
        declare         export function getMinZoomLevel(): number

        /**
         * Sets the minimum zoom level for this projection. Normally this is 
         * set to 1.0 and should not be altered.
         * @param  Desired minimum zoom level.
         */
        declare         export function setMinZoomLevel(minZ: number): void

        /**
         * Gets the maxmimum zoom level for this projection.
         * @returns  Maximum zoom level.
         */
        declare         export function getMaxZoomLevel(): number

        /**
         * Sets the maximum zoom level for this projection. Normally this is 
         * set to 20.0 and should not be altered.
         * @param  Desired maximum zoom level.
         */
        declare         export function setMaxZoomLevel(maxZ: number): void

        /**
         * Gets the tile height and width in pixels.
         * @returns  The height and width of the tiles in pixels.
         */
        declare         export function getTileSizePix(): number

        /**
         * Gets the display DPI, which defaults to 96. Note: The dpi is 
         * recomputed on page load complete.
         * @returns  Dots per inch on display.
         */
        declare         export function getDpi(): number

        /**
         * Set the display DPI, which defaults to 96. Note: The DPI is 
         * recomputed on page load complete.
         * @param  Dots per inch on display.
         */
        declare         export function setDpi(dpi: number): void

        /**
         * Return the equitorial radius in meters for this projection.
         * @returns  Equitorial radius in meters.
         */
        declare         export function getRadius(): number

        /**
         * Returns equitorial circumference in meters for this projection
         * @returns  Equitorial circumference in meters.
         */
        declare         export function getCircumference(): number

        /**
         * Returns half the equitorial circumference in meters for this projection
         * @returns  Half of the equitorial circumference in meters.
         */
        declare         export function getHalfCircumference(): number

        /**
         * Get the envelope in map units for a given quadtree node, i.e. tile,
         * based on the given x, y, and z quadtree coordinates.
         * @param  The x coordinate.
         * @param  The y coordinate.
         * @param  The z coordinate.
         * @returns  Envelope of the tile in map units.
         */
        declare         export function getQuadTreeNodeToMapEnvelope(x: number, y: number, z: number): envelope

        /**
         * Gets the envelope in map units of tiles in the quadtree from an 
         * evelope in map units and a zoom level.
         * @param  Envelope for which to find intersecting tiles.
         * @param  Zoom level with which to test for intersection.
         * @returns  The envelope in map units of the tiles.
         */
        declare         export function getQuadTreeNodeRangeFromEnvelope(env: envelope, z: number): envelope

        /**
         * Gets projected map units per pixel for a given zoom level.
         * @param  Reference zoom level.
         * @returns  Projection units per pixel.
         */
        declare         export function getProjectionUnitsPerPixel(zoomLevel: number): number

        /**
         * Gets the required scale transform to apply to shapes so distance 
         * and area computations yield actual Earth-geodesic units instead of 
        projected map units.
         * @param  Reference latitude for the computation.
         * @returns  Scale transform multiplier.
        */
        declare         export function getActualShapeScaleTransform(mapPtY: number): number

        /**
         * Gets actual, on-the-ground meters per pixel for a given zoom level 
         * and map point in map units.
         * @param  Reference location for the computation.
         * @param  Reference zoom level.
         * @returns  Meters per pixel multiplier.
         */
        declare         export function getActualUnitsPerPixel(mapPt: point, zoomLevel: number): number

        /**
         * Gets the optimal zoom level for a given envelope in map units 
         * based on the envelope of visible device area in pixels.
         * @param  Envelope in map units to display.
         * @param  Envelope in pixels of visible area.
         * @returns  Optimal zoom level for viewing envelopeMap.
         */
        declare         export function getBestFitZoomLevelByExtents(envelopeMap: envelope, envelopeDevice: envelope): number

        /**
         * Gets a quad-key from x, y, and z coordinates.
         * @param  The x coordinate.
         * @param  The y coordinate.
         * @param  The z coordinate.
         * @returns  Quad-key string.
         */
        declare         export function getQuadKeyFromXYZ(x: number, y: number, z: number): string

        /**
         * Gets x, y, and z coordinates as an object from a given quad-key.
         * @param  Reference quad-key.
         * @return  JavaScript object of the form {x,y,z}.
         */
        declare         export function getXYZFromQuadKey(key: string): {
            x: number,
            y: number,
            z: number
        }

        /**
         * Project a point from latitude/longitude to Spherical Mercator.
         * @param  Point object in latitude/longitude. 
         * @returns  The same point in Spherical Mercator.
         */
        declare         export function projectFromLatLon(lonLat: point): point

        /**
         * Project a point from Spherical Mercator to latitude/longitude.
         * @param  Point object in Spherical Mercator.
         * @returns  The same point in latitude/longitude.
         */
        declare         export function deprojectToLatLon(mapPt: point): point
    }


    /**
     * A geometry object decorated with a geometry style object
     * @class  styledGeometry
     */
    declare     export class styledGeometry {
        constructor(geom: geometry, gStyle?: geometryStyle): this;

        /**
         * Set this styledGeometry's geometry.
         * @param  A new Geometry.
         */
        setGeometry(g: geometry): void;

        /**
         * Set this styledGeometry's geometryStyle.
         * @param  A new styledGeometry.
         */
        setGeometryStyle(gs: geometryStyle): void;

        /**
         * Gets the styledGeometry's underlying geometry object.
         * @returns  The underlying geometry.
         */
        getGeometry(): geometry;

        /**
         * Gets the styledGeometry's underlying geometryStyle object.
         * @returns  The underlying geometry style.
         */
        getGeometryStyle(): geometryStyle;

        /**
         * Gets path outline thickness in pixels.
         * @returns  Thickness in pixels.
         */
        getOutlineThicknessPix(): number;

        /**
         * Sets path outline thickness in pixels.
         * @param  Thickness in pixels.
         */
        setOutlineThicknessPix(t: number): void;

        /**
         * Gets path outline color as a CSS style string.
         * @returns  Outline color as a CSS style string.
         */
        getOutlineColor(): string;

        /**
         * Gets path outline opacity in decimal format.
         * @param  opacity.
         */
        setOutlineColor(c: string): void;

        /**
         * Gets path outline opacity in decimal format.
         * @returns  Outline opacity.
         */
        getOutlineOpacity(): number;

        /**
         * Set path outline opacity to a decimal between 0 and 1.
         * @param  Outline opacity.
         */
        setOutlineOpacity(o: number): void;

        /**
         * Gets fill color as a CSS style string.
         * @returns  Fill color as a CSS style string.
         */
        getFillColor(): string;

        /**
         * Sets fill color as a CSS style string.
         * @param  Fill color as a CSS style string.
         */
        setFillColor(c: string): void;

        /**
         * Gets fill opacity in decimal format.
         * @returns  Fill opacity.
         */
        getFillOpacity(): number;

        /**
         * Sets fill opacity to a decimal between 0 and 1.
         * @param  Fill opacity.
         */
        setFillOpacity(o: number): void;

        /**
         * Gets the dash array as a string.
         * @returns  Dash array as astring.
         */
        getDashArray(): string;

        /**
         * Sets dash array string from a CSS style string. Defaults to solid
         * stroke if no dash array string is provided.
         * @param  Dash array as a CSS style string.
         */
        setDashArray(da: string): void;

        /**
         * Gets optional animation function called when SVG node is created.
         * @returns  Function with the signature animation(pathElement, loopback).
         */
        getAnimation(): (pathElement: HTMLElement, loopback: () => void) => void;

        /**
         * You can use the loopback parameter on complete to call itself and 
         * create repeating animation.
         * @param  with the signature animation(pathElement, loopback).
         */
        setAnimation(action: (pathElement: HTMLElement, loopback: () => void) => void): void;

        /**
         * Renders this geometry as an SVG path. Note: We attach original
         * geometry bounds to svg doc as an expando.
         * @param  Identifer to keep track of the SVG DOM element.
         * @param  Map units per pixel with which to create the SVG element.
         * @returns  A new SVG document root.
         */
        createSvgPathElement(key: string, mapUnitsPerPix: number): HTMLElement;

        /**
         * Renders this to a canvas context.
         * @param  Canvas context to which to render.
         */
        renderPathToCanvasContext(ctx: CanvasRenderingContext2D): void
    }
    declare     export var version: string;
    declare module 'wkt' {

        /**
         * Parses WKT as a point.
         * @param  A WKT string.
         * @returns  The parsed point.
         */
        declare         export function parsePoint(wkt: string): point

        /**
         * Parses WKT as a multipoint.
         * @param string } w A WKT string.
         * @retuns  {geometry} The parsed multipoint geometry.
         */
        declare         export function parseMultiPoint(wkt: string): geometry

        /**
         * Parses WKT as an open path geometry with a single set.
         * @param  A WKT string.
         * @returns  The parsed open path geometry.
         */
        declare         export function parseLineString(wkt: string): geometry

        /**
         * Parses WKT as an open path geometry with multiple sets.
         * @param  A WKT string.
         * @returns  The parsed open path geometry.
         */
        declare         export function parseMultiLineString(wkt: string): geometry

        /**
         * Parses WKT as a closed path geometry with a single set.
         * @param  A WKT string.
         * @returns  The parsed closed path geometry.
         */
        declare         export function parsePolygon(wkt: string): geometry

        /**
         * Parses WKT as a closed path geometry with multiple sets.
         * @param  A WKT string.
         * @returns  The parsed closed path geometry.
         */
        declare         export function parseMultiPolygon(wkt: string): geometry

        /**
         * Parses WKT as a geometry and determines its type from the string.
         * @param  The WKT string.
         * @returns  The parsed shape, a point, geometry, or an array of
        polygons depending on the WKT.
        */
        declare         export function parse(wkt: string): any

        /**
         * Converts an array of polygons to an OGC compliant multipolygon WKT string.
         * @param  Set of polygons to parse into WKT.
         * @returns  The OGC compliant WKT for the polygons.
         */
        declare         export function toMultiPolygonString(polys: geometry.polygon[]): string
    }

    declare module 'tile' {

        /**
         * A tile layer is a view on the map containing an array of rectangular content.
         *    
         * @class  layer
         */
        declare         export class layer {
            constructor(id: string, useBackdrop?: boolean, maxConcurrentRequests?: number): this;

            /**
             * 
             * @param  - number for margin in pixelsGets ID associated with this tile layer.
             * @returns  ID of the layer.
             */
            getId(): string;

            /**
             * Determines whether this tile layer uses a backdrop.
             * @returns  Whether or not the layer uses a backdrop.
             */
            getUseBackdrop(): boolean;

            /**
             * Returns the tile layer's descriptor, which describes how 
             * requested content is rendered or styled.
             * @returns  The tile layer's descriptor.
             */
            getDescriptor(): any;

            /**
             * Sets the tile layer's descriptor, which describes how requested
             * content is rendered or styled.
             * @param  A descriptor for this tile layer.
             */
            setDescriptor(d: any): void;

            /**
             * Notifies the tile layer to check for changes to its descriptor.
             */
            notifyDescriptorChange(): void;

            /**
             * Returns this tile layer's requestor which defines what kind of 
             * content to get and where to get it.
             * @returns  This tile layer's requestor.
             */
            getRequestor(): tile.requestor;

            /**
             * Sets this tile layer's requestor, which defines what kind of
             * content to get and where to get it.
             * @param  A requestor object.
             * @param  Descriptor object so that both
            can be set in one call and incur only one content change event.
            */
            setRequestor(req: tile.requestor, desc?: any): void;

            /**
             * Returns this tile layer's renderer if it exists, which defines 
             * how geometry data for a quadView is rendered.
             * @returns  The renderer object.
             */
            getRenderer(): tile.renderer;

            /**
             * Sets optional renderer which defines how geometry data for 
             * quadView is rendered.
             * @param  The renderer delegate function with 
            signature renderer(quadview).
            */
            setRenderer(r: any): void;

            /**
             * Notifies the tile layer to check for changes to its renderer.
             */
            notifyRendererChange(): void;

            /**
             * Gets the visibility state of this tile layer.
             * @returns  Whether or not this layer is visible.
             */
            getIsVisible(): boolean;

            /**
             * Sets visibility state of this tile layer.
             * @param  Whether this layer should be visible or not.
             */
            setIsVisible(v: boolean): void;

            /**
             * Gets the opacity of this tile layer.
             * @returns  Opacity as a decimal.
             */
            getOpacity(): number;

            /**
             * Sets opacity of this tile layer.
             * @param  Opacity as a decimal.
             */
            setOpacity(o: number): void;

            /**
             * Gets minimum zoom level where this tile layer is visible.
             * @returns  The minimum zoom level.
             */
            getMinZoomLevel(): number;

            /**
             * Sets minimum zoom level where this tile layer is visible.
             * @param  The desired minimum zoom level.
             */
            setMinZoomLevel(minZ: number): void;

            /**
             * Gets maximum zoom level where this tile layer is visible.
             * @returns  The maximum zoom level.
             */
            getMaxZoomLevel(): number;

            /**
             * Sets maximum zoom level where this tile layer is visible.
             * @param  The desired maximum zoom level.
             */
            setMaxZoomLevel(maxZ: number): void;

            /**
             * Sets pixel bleed on quadTiles, which defaults to 1. Setting this 
             * to zero for overlay layers with translucent polygon fills is 
            recommended. Bleed overlap can create faint lines at tile 
            boundries when fill is not opaque.
             * @param  The number of pixels to bleed.
            */
            setTileBleedPix(bleed: number): void;

            /**
             * Sets whether or not to retain and display previous level tile 
             * content as you change tile levels to provide a nice zoom level 
            change effect. Once the next level is loaded the old level 
            content is always discarded. This should be set to false if there 
            is translucent content to display. Defaults to true (prior to 
            version 9.0.0001 this value had the same state as useBackdrop.)
             * @param  Whether or not to retain interlevel content.
            */
            setRetainInterlevelContent(retain: boolean): void;

            /**
             * Enables or disables the fade in on tile content, which defaults to enabled.
             * @param  Whether or not fade in on tile content 
            should be enabled.
            */
            setEnableTileFadeIn(fadeIn: boolean): void;

            /**
             * Sets the default action to take on error.
             * @param  Function to execute on error.
             */
            setNotifyErrorAction(action: () => void): void;

            /**
             * Sets an optional function to be called when the tile loading
             * queue for this layer has emptied.
             * @param  Callback function.
             */
            setNotifyLoadingQueueHasEmptiedAction(action: () => void): void;

            /**
             * Sets the optional function to be called by this layer's tile 
             * loader during processing. The supplied progress function takes 
            tiles loaded and tiles total parameters.
             * @param  Callback of the signature action(tileLoaded, tilesTotal).
            */
            setNotifyLoadingQueueProgressAction(action: (tilesLoaded: number, tilesTotal: number) => void): void;

            /**
             * Sets optional request processor for this tile layer. This is 
             * an advanced feature allowing developers to tap into tile 
            request pipeline for purposes of customizing requests or manage 
            custom caching. This is also the mechanism used for offline 
            apps with frameworks such as phonegap.
             * @param  function with signature
            processor(requestor, descriptor, quad, timeoutMs, complete, error)
            */
            setRequestProcessor(
                processorFunc: (
                    requestor: tile.requestor,
                    descriptor: any,
                    quad: tile.quad,
                    timeoutMs: number,
                    completeAction: (img: HTMLElement) => void,
                    errorAction: (msg: string) => void) => void): void;

            /**
             * Instructs the tile loader to populate a specified tile pyramid.
             * This is used to fetch content (e.g. bitmap tiles) and preload 
            it into the browser cache.
             * @param  Envelope for which to fetch content.
             * @param  Minimum zoom level for which to
            fetch content.
             * @param  Maximum zoom level for which to 
            fetch content.
            */
            preload(extents: envelope, startZoomLevel: number, endZoomLevel: number): void;

            /**
             * Composes an array of quadtiles with composition information and
             * requestor endpoints. This can be used to create static images
            or print-ready versions of this tile layer at arbitrary extents
            (both source and target) For example: If you needed a 5x3 inch 
            300 dpi output you can specify extents in device units to be
            1500x900. This function determines the correct zoom level so 
            that the source extents fits in the target extents to the
            nearest integer zoom level.
             * @param  Source extents in map units.
             * @param  Target extents in pixels.
             * @returns  Composed object in the form 
            {quadCollection, endpointCollection, idxMinX, idxMinY, ulX, ulY }
            where quadCollection is an array of quad objects, endpointCollection
            is an array of REST endpoints from which to obtain the tiled content,
            idxMinX and idxMinY are the minimum x and y tile indicies of the
            collection respectively, and ulX and ulY are the offset in pixels
            of the upper left tile from the upper left target extents.
            */
            compose(
                extentsMapUnits: envelope,
                extentsDeviceUnits: envelope): {
                quadCollection: tile.quad[],
                endpointCollection: string[],
                idxMinX: number,
                idxMinY: number,
                ulX: number,
                ulY: number
            };

            /**
             * Unbind all associations with this tile layer to facilitate garbage collection
             */
            dispose(): void
        }

        /**
         * A layerOptions object is a method for constructing a tile layer for 
         * immediate use, for example by passing it to the jQuery widget or
        in the knockout binding.
           
         * @class  layerOptions
        */
        declare         export class layerOptions {
            constructor(id: string, options: {
                useBackdrop?: boolean,
                maxConcurrentRequests?: number,
                requestor?: tile.requestor,
                descriptor?: any,
                renderer?: tile.renderer,
                requestProcessor?: any,
                visible?: boolean,
                opacity?: number,
                minZoomLevel?: number,
                maxZoomLevel?: number,
                tileBleedPix?: number,
                retainInterlevelContent?: boolean,
                enableTileFadeIn?: boolean,
                notifyErrorAction?: (msg?: string) => void,
                notifyLoadingQueueHasEmptiedAction?: () => void
            }): this;

            /**
             * Returns the underlying tile layer.
             * @returns  The underlying tile layer.
             */
            getTileLayer(): tile.layer;

            /**
             * Gets ID associated with the underlying tile layer.
             * @returns  ID of the layer.
             */
            getId(): string;

            /**
             * Gets this layerOptions object as a JavaScript object.
             */
            getOptions(): any
        }
        declare module 'quad' {

            /**
             * Generates a new quad tile based on a given quad key.
             * @param  The quad key from which to generate the quad tile.
             * @returns  The generated quad tile.
             */
            declare             export function factoryQuadFromKey(key: string): quad
        }


        /**
         * A tile renderer handles converting JSON vector content loaded from the
         * MapDotNet REST feature service into a canvas rendering on a tile.
           
         * @class  renderer
        */
        declare         export class renderer {
            constructor(options?: {
                renderPoint?: (pt: point, context: CanvasRenderingContext2D) => void,
                renderGeometry?: (shape: geometry, context: CanvasRenderingContext2D) => void,
                renderBitmap?: (
                    img: HTMLElement,
                    context: CanvasRenderingContext2D,
                    contextSize: number,
                    bleed: number) => void
            }): this;

            /**
             * Sets the render point function which takes a point and canvas 
             * context and renders the point to the canvas. The points passed 
            in are transformed to pixel units and offset to context origin.
             * @param  Function of the form func(shape, context)
            where shape is the point object to be rendered and context is the 
            canvas context on which to render.
            */
            setRenderPoint(func: (pt: point, context: CanvasRenderingContext2D) => void): void;

            /**
             * Sets render geometry function which takes a geometry and canvas 
             * context and renders the geometry to the canvas context. The 
            geometries passed in are transformed to pixel units and offset 
            to the context origin.
             * @param  Function with signature func(shape, context)
            where shape is the geometry to render and context is the canvas
            context on which to render.
            */
            setRenderGeometry(func: (shape: geometry, context: CanvasRenderingContext2D) => void): void;

            /**
             * Sets the render bitmap function which takes a bitmap image and
             * a canvas context and renders the image to the canvas context.
             * @param  Function with the signature 
            func(img, context, contextSize, bleed) where img is the bitmap
            image to render, context is the canvas context on which to 
            render the image, contextSize is the size of the canvas context
            in pixels and bleed is the margin around each tile to bleed.
            */
            setRenderBitmap(
                func: (
                    img: HTMLElement,
                    context: CanvasRenderingContext2D,
                    contextSize: number,
                    bleed: number) => void): void
        }

        /**
         * An auto-ranging density map renderer.
         *    
         * @class  rendererDensityMap
         */
        declare         export class rendererDensityMap {
            constructor(): this;

            /**
             * Sets the bleed ratio, which is the sets the percentage of the
             * margin around each tile to use in the tile's computation. Note:
            some bleed (i.e., greater than 1) is required since a heat map
            relies on adjacent data.
             * @param  The desired bleed ratio.
            */
            setBleed(bleed: number): void;

            /**
             * Sets the number of rows and columns of cells to be used for 
             * computation within the grid.
             * @param  Number of rows and columns used in
            the grid.
            */
            setGridSize(gridSize: number): void;

            /**
             * Sets filter radius corresponding to standard deviations. The
             * filter radius is the cutoff point at which adjacent cells no
            longer contribute to a cell's calculation.
             * @param  Number of standard deviations
            from the mean of a normal distribution to which to give positive 
            weight.
            */
            setFilterStdDevRadius(filterStdDevRadius: number): void;

            /**
             * Sets color ranges from cold to hot for the renderer.
             * @param  Array of arrrays of numbers, each
            of the form [r,g,b,a], where each array represents a color and
            colors range from cold to hot. Note: Typically, a dozen colors
            is sufficient.
            */
            setColorMatrix(matrix: number[][]): void;

            /**
             * Sets the minimum required cell value for a cell to receive 
             * a color. Default minimum value is 0.
             * @param  The minimum cell value for painting.
             */
            setMinCellValue(min: number): void;

            /**
             * Sets an optional action to perform on each row. This enables 
             * processing the values on one or more columns for each row for
            use in the density map computations.
             * @param  Function to call on each row with signature
            action(row). The value returned from the function will is added
            to the cell's value.
            */
            setRowAction(action: (row: any) => number): void;

            /**
             * Tells renderer to re-render density map and recompute ranges. 
             * This should be called if the data changes or if, due to extent
            changes, the density changes.
            */
            notifyRecompute(extents?: envelope): void
        }

        /**
         * This is a base requestor class.
         *    
         * @class  requestor
         */
        declare         export class requestor {
            constructor(): this;

            /**
             * Gets formatted endpoint using the supplied quadtile and a descriptor.
             * @param  Quadtile for which to fetch the endpoint.
             * @returns  The requested URI string.
             */
            getFormattedEndpoint(quad: quad, descriptor: any): string;

            /**
             * Gets data locally if the requestor supports it.
             * @param  Quadtile for which to fetch the endpoint.
             * @returns  The requested JSON data.
             */
            getLocalData(quad: quad, descriptor: any): string;

            /**
             * Creates unique sha1 hash from this requestor and the supplied
             * descriptor. This is useful in creating a unique key or folder 
            for tile caching. This combined with a tile's quad-key can 
            efficiently and uniquely identify a particular tile.
             * @params  {descriptor} The descriptor for which to create the hash.
             * @returns  The generated sha1 hash.
            */
            hash(descriptor: any): string;

            /**
             * Determines whether or not this requestor returns bitmap images.
             * @returns  Whether or not this requestor returns bitmap
            images.
            */
            getIsRestImage(): boolean;

            /**
             * Sets whether this requestor should return bitmap images.
             * @param  Whether or not this requestor should return
            bitmap images.
            */
            setIsRestImage(flag: boolean): void;

            /**
             * Determines whether or not this requestor uses an endpoint 
             * rather than local data.
             * @returns  Whether or not this requestor gets data from
            an endpoint.
            */
            getUsesEndpoint(): boolean;

            /**
             * Sets whether or not this requestor uses an endpoint rather than
             * local data.
             * @param  or not this requestor should get data
            from an endpoint.
            */
            setUsesEndpoint(flag: boolean): void;

            /**
             * Gets format of data returned by REST service.
             * @returns  Data format returned by the REST service.
             */
            getDataFormat(): string;

            /**
             * Sets format of data that should be returned by REST service.
             * @param  Name of the data format the REST service 
            should use.
            */
            setDataFormat(df: string): void;

            /**
             * Returns whether or not caching is enabled for vector-based 
             * requestors. 
             * @returns  Whether or not caching is enabled.
             */
            getCacheEnabled(): boolean;

            /**
             * Sets whether or not caching is enabled for vector-beased requestors. 
             * @param  - true (default) if caching is enabled
             */
            setCacheEnabled(flag: boolean): void;

            /**
             * Gets requestor timeout in miliseconds.
             * @returns  Requestor timeout in miliseconds.
             */
            getTimeoutMs(): number;

            /**
             * Sets requestor timeout in miliseconds.
             * @param  Desired requestor timeout in miliseconds.
             */
            setTimeoutMs(ms: number): void;

            /**
             * ???
             * Gets the additional 
             * @returns  
             */
            getKeyVals(): {}[];

            /**
             * Set any key/value pairs that are attached to the ajax call (such as username and password)
             */
            setKeyVals(options: {}[]): void;

            /**
             * Gets maximum available zoom level content that can be retrieved 
             * from the endpoint this requestor consumes.
             * @returns  The maximum available zoom level for this requestor.
             */
            getMaxAvailableZoomLevel(): number;

            /**
             * Sets maximum available zoom level content that can be retrieved
             * from the endpoint this requestor consumes. Note: This defaults
            to the projection's maximum available zoom level, which is 20
            in spherical mercator.
             * @param  The maximum available zoom level for this requestor.
            */
            setMaxAvailableZoomLevel(max: number): void
        }

        /**
         * A tile requestor for Microsoft Bing maps.
         *    
         * @class  requestorBing
         */
        declare         export class requestorBing mixins requestor {
            constructor(options?: {
                dataFormat?: string,
                timeoutMs?: number,
                maxAvailableZoomLevel?: number
            }): this;

            /**
             * Gets the formatted endpoint uri for Bing maps, e.g. 
             * ecn.t{0}.tiles.virtualearth.net/tiles/{1}{2}{3}?g={4}&mkt={5}&shading=hill.
             * @returns  endpoint to Bing tile server as a formatted string
             */
            getEndpoint(): string;

            /**
             * Gets the protocol for the endpoint, either 'http' or 'https'.
             * @returns  The endpoint protocol.
             */
            getScheme(): string;

            /**
             * Sets endpoint protocol to either 'http' or 'https'.
             * @param  Protocol to use in endpoints.
             */
            setScheme(s: string): void;

            /**
             * Gets Bing tile generation
             * @returns  the tile generation as an integer
             */
            getGeneration(): string;

            /**
             * Sets Bing tile generation
             * @param  - generation as an integer
             */
            setGeneration(g: string): void;

            /**
             * Gets the language code for which the tiles are rendered. The
             * default code is 'en-US'.
             * @returns  The language code for which tiles are rendered.
             */
            getMarket(): string;

            /**
             * Sets language code for which to render tiles. For example,
             * 'en-US'.
             * @param  Language code for which to render tiles.
             */
            setMarket(m: string): void;

            /**
             * Gets the Bing key associated with this requestor.
             * @returns  The Bing key for this requestor.
             */
            getBingKey(): string;

            /**
             * Sets Bing key which then calls Microsoft metadata service and
             * automatically configures content endpoint.
             * @param  Bing key.
             */
            setBingKey(key: string): void
        }

        /**
         * The bitmap or vector tile requestor using MapDotNet REST services.
         *    
         * @class  requestorMDN
         */
        declare         export class requestorMDNRest mixins requestor {
            constructor(endpoint: string, options?: {
                dataFormat?: string,
                timeoutMs?: number,
                maxAvailableZoomLevel?: number
            }): this;

            /**
             * Gets uri endpoint for the MapDotNet REST service.
             * @returns  Uri endpoint for the MapDotNet REST service.
             */
            getEndpoint(): string
        }

        /**
         * Creates an instance of a descriptor for describing content from a 
         * MapDotNet UX REST map service.
           
         * @class  descriptorMDNRestMap
        */
        declare         export class descriptorMDNRestMap {
            constructor(mapId: string, options?: {
                version?: string,
                imageType?: string,
                bleedRatio?: number,
                mapCacheOption?: string,
                mapCacheName?: string,
                useQuadKeyForMapCacheName?: boolean,
                backgroundColorStr?: string,
                layerVisibility?: {},
                layerOutline?: {},
                layerFill?: {},
                layerWhere?: {},
                tag?: string
            }): this;

            /**
             * Sets the flag to suspend descriptor change notifications. If 
             * set true, all changes to this descriptor will not cause the map
            to redraw. Setting to false will enable redraws and immediately
            force a redraw.
             * @param  Whether or not descriptor change notifications
            should be enabled.
            */
            setSuspendDescriptorChangeNotifications(flag: boolean): void;

            /**
             * Gets the map ID.
             * @returns  The map ID.
             */
            getMapId(): string;

            /**
             * Gets the REST service version.
             * @returns  The REST service version.
             */
            getVersion(): string;

            /**
             * Sets the REST service version.
             * @param  The version number.
             */
            setVersion(v: string): void;

            /**
             * Gets image type associated with this descriptor, either 'png',
             * 'png8', or 'jpg'.
             * @returns  The image type associated with this descriptor.
             */
            getImageType(): string;

            /**
             * Gets image type associated with this descriptor to one of 'png',
             * 'png8', or 'jpg'.
             * @param  The image type associated which should be
            associated with this descriptor.
            */
            setImageType(t: string): void;

            /**
             * Gets bleed ratio for the layer associated with this descriptor.
             * @returns  The bleed ratio.
             */
            getBleedRatio(): number;

            /**
             * Sets the bleed ratio. Bleeds greater than 1.0 will fetch content 
             * beyond the edge of the tile extents (this is useful for point 
            features).
             * @param  The desired bleed ratio, between 1.0 and 2.0.
            */
            setBleedRatio(br: number): void;

            /**
             * Gets the map's cache setting, which is one of 'None', 
             * 'ReadOnly', 'ReadWrite', 'ForceWrite', and 'Default.'
             * @returns  The map's cache setting.
             */
            getMapCacheOption(): string;

            /**
             * Gets the map's cache setting to one of 'None', 
             * 'ReadOnly', 'ReadWrite', 'ForceWrite', and 'Default.'
             * @param  The desired cache setting for the map.
             */
            setMapCacheOption(mco: string): void;

            /**
             * Gets the optional map cache name.
             * @returns  The map cache name.
             */
            getMapCacheName(): string;

            /**
             * Sets the optional map cache name.
             * @param  The desired map cache name.
             */
            setMapCacheName(mcn: string): void;

            /**
             * Determines whether the map is flagged to use the quadkey as its
             * map cache name.
             * @returns  Whether or not the map has been flagged to
            use the quadkey as its map cache name.
            */
            getUseQuadKeyForMapCacheName(): boolean;

            /**
             * Sets the flag that uses the quadkey as its map cache name.
             * @param  Whether or not the map should be flagged
            to use the quadkey as its map cache name.
            */
            setUseQuadKeyForMapCacheName(flag: boolean): void;

            /**
             * Gets map image background color.
             * @returns  CSS style string for the map image background color.
             */
            getBackgroundColorStr(): string;

            /**
             * Sets the map image background color.
             * @param  Alpha level.
             * @param  Red level.
             * @param  Green level.
             * @param  Blue level.
             */
            setBackgroundColor(a: number, r: number, g: number, b: number): void;

            /**
             * Checks whether or not the map background is transparent.
             * @returns  Whether or not the map background is transparent.
             */
            getIsBackgroundTransparent(): boolean;

            /**
             * Sets a layer's visibility.
             * @param  The MapDotNet map layer ID.
             * @param  Whether or not the layer should be visible.
             */
            setLayerVisibility(layerId: string, isVisible: boolean): void;

            /**
             * Gets a layer's visibility.
             * @param  The MapDotNet map layer ID.
             * @returns  Whether or not the layer is visible.
             */
            getLayerVisibility(layerId: string): boolean;

            /**
             * Sets a layer's outline color and thickness.
             * @param  The MapDotNet map layer ID.
             * @param  Alpha level.
             * @param  Red level.
             * @param  Green level.
             * @param  Blue level.
             * @param  Outline thickness in pixels.
             */
            setLayerOutline(layerId: string, a: number, r: number, g: number, b: number, thk: number): void;

            /**
             * Gets a layer's outline color and thickness.
             * @param  The MapDotNet map layer ID.
             * @returns  JavaScript object of the form {color, thickness}
            where color is the CSS style string of the outline color and 
            thickness is the outline thickness in pixels.
            */
            getLayerOutline(layerId: string): {
                color: string,
                thickness: number
            };

            /**
             * Sets a layer's fill color.
             * @param  The MapDotNet map layer ID.
             * @param  Alpha level.
             * @param  Red level.
             * @param  Green level.
             * @param  Blue level.
             */
            setLayerFill(layerId: string, a: number, r: number, g: number, b: number): void;

            /**
             * Sets a layer's fill color as a SQL expression.
             * @param  The MapDotNet map layer ID.
             * @param  The SQL expression to select a row's fill color.
             */
            setLayerFillAsExpression(layerId: string, exp: string): void;

            /**
             * Gets a layer's fill color as a CSS style string or as a SQL expression.
             * @param  The MapDotNet map layer ID.
             * @returns  Either the CSS style string or the SQL expression,
            according to how the layer's fill color was set.
            */
            getLayerFill(layerId: string): string;

            /**
             * Add or replace the where clause for a layer. The where clause
             * is a SQL expression used to filter rows.
             * @param  The MapDotNet map layer ID.
             * @param  The desired SQL where expression.
             * @param  Whether to merge the new where clause
            with the existing where clause using a SQL AND or to replace
            the existing where clause with the new one. Defaults to true (merge).
            */
            setLayerWhere(layerId: string, where: string, merge: boolean): void;

            /**
             * Sets a separator character for the layer where clause expression
             * in the query string. This is set to ',' by default, which is 
            consistent with SQL.
             * @param  The desired seperator, which should be a 
            single character.
            */
            setLayerWhereSep(sep: string): void;

            /**
             * Returns the current separator for the layer where clause in the
             * query string. 
             * @returns  The current seperator.
             */
            getLayerWhereSep(): string;

            /**
             * Gets the current layer where clause.
             * @param  The MapDotNet map layer ID.
             * @returns  The current where clause. If no where clause
            is in use, this will return an empty string.
            */
            getLayerWhere(layerId: string): string;

            /**
             * Gets a tag which is used to modify the request URIs to avoid 
             * browser caching
             * @returns  The map's tag.
             */
            getTag(): string;

            /**
             * Sets the map's tag, which is used modify request URIs to avoid 
             * browser caching.
             * @param  The desired tag.
             */
            setTag(tag: string): void
        }

        /**
         * Creates an instance of a descriptor for describing content from
         * a MapDotNet REST feature service.
         * @class  descriptorMDNRestFeature
         */
        declare         export class descriptorMDNRestFeature {
            constructor(mapId: string, layerId: string, options?: {
                version?: string,
                bleedRatio?: number,
                fieldNames?: string[],
                clipToRenderBounds?: boolean,
                simplifyEnabled?: boolean
            }): this;

            /**
             * Gets the map ID.
             * @returns  The map ID.
             */
            getMapId(): string;

            /**
             * Gets the layer's ID.
             * @returns  The layer's ID.
             */
            getLayerId(): string;

            /**
             * Gets the version of the REST service.
             * @returns  The REST service version.
             */
            getVersion(): string;

            /**
             * Sets the REST service version number.
             * @param  The version number to set.
             */
            setVersion(v: string): void;

            /**
             * Gets the bleed ratio.
             * @returns  The current bleed ratio.
             */
            getBleedRatio(): number;

            /**
             * Sets the bleed ratio. Bleeds greater than 1.0 will fetch content 
             * beyond the edge of the tile extents (this is useful for point features).
             * @param  The desired bleed ratio, a number between 1.0 and 2.0.
             */
            setBleedRatio(br: number): void;

            /**
             * Gets the optional field names to query. This attribute data may
             * be used in dynamic client-side rendering.
             * @returns  An array of field names as strings.
             */
            getFieldNames(): string[];

            /**
             * Sets the optional field names to query. This attribute data may be used in 
             * dynamic client-side rendering.
             * @param  - array of strings for each field to query
             */
            setFieldNames(names: string[]): void;

            /**
             * Checks the flag whether to clip geometry fetched at the bounds 
             * of the request.
             * @returns  The value of the flag.
             */
            getClipToRenderBounds(): boolean;

            /**
             * Sets the flag whether to clip geometry fetched at the bounds 
             * of the request. This can greatly improve performance with large
            complex geometries. Only supported when back-end store is SQL 
            2008/2012 or PostGIS.
             * @param  Whether or not to clip geometries fetched
            at the bounds of the request.
            */
            setClipToRenderBounds(flag: boolean): void;

            /**
             * Checks the flag whether to simplify paths based on the units per
             * pixel for the quad tile being requested.
             * @returns  The value of the flag.
             */
            getSimplifyEnabled(): boolean;

            /**
             * Sets the flag whether to simplify paths based on the units per
             * pixel for the quad tile being requested.
             * @param  Whether or not to simply paths based on 
            the units per pixel.
            */
            setSimplifyEnabled(flag: boolean): void;

            /**
             * Sets the action to perform on descriptor change.
             * @param  Function with signature action().
             */
            setNotifyDescriptorChangeAction(action: () => void): void
        }

        /**
         * This is a generic tile requestor suitable for several third-party
         * tile servers. These include open street map, map quest, cloudmade, 
        Nokia, etc.
         * @class  requestorOpen
        */
        declare         export class requestorOpen mixins requestor {
            constructor(endpoint: string, subdomains: string[], options?: {
                dataFormat?: string,
                timeoutMs?: number,
                maxAvailableZoomLevel?: number
            }): this
        }

        /**
         * This is a requestor for local collections of data. These local collections may 
         * originate from inlined code or from datasources other than a MapDotNet REST 
        feature service.
         * @class  requestorLocal
        */
        declare         export class requestorLocal mixins requestor {
            constructor(options?: {
                dataFormat?: string,
                timeoutMs?: number,
                maxAvailableZoomLevel?: number,
                data: {}[]
            }): this;

            /**
             * Gets the unparsed source data.
             * @returns  Array of source data objects.
             */
            getSource(): {}[];

            /**
             * Sets source data.
             * @param  An array of JavaScript objects to use as
            the requestor source data.
            */
            setSource(data: {}[]): void;

            /**
             * Returns your source data parsed into theformat { Shapes: [],
             *          Values: [], Bounds: [] } This may be useful for doing client-side 
                     queries on the local data where all of the WKT has been parsed 
                     into points and geometry. There is also a bounds collection to 
                     do a quick spatial check for complex polygons.
             * @returns  Parsed data object in the form {Shapes, Values, Bounds}.
            */
            getParsedData(): {
                Shapes: any[],
                Values: any[],
                Bounds: envelope[]
            }
        }

        /**
         * Local descriptor object for describing source data when the source
         * data is fecthed by a local requestor.
         * @class  descriptorLocal
         */
        declare         export class descriptorLocal {
            constructor(options: {
                valueFieldNames: string[],
                geometryFieldName: string,
                bleedRatio?: number
            }): this
        }
    }

    declare interface pointObject {
        x: number,
            y: number
    }
    declare interface envObject {

        /**
         * 
         * @returns  minX as integer
         */
        minX: number,

            /**
             * 
             * @returns  minY coord as integer
             */
            minY: number,

            /**
             * 
             * @returns  maxX coord as integer
             */
            maxX: number,

            /**
             * 
             * @returns  maxY coord as integer
             */
            maxY: number
    }
    declare interface extentChangeStatsObj {
        centerX: number,
            centerY: number,
            centerLat: number,
            centerLon: number,
            zoomLevel: number,
            mapScale: number,
            mapScaleProjected: number,
            mapUnitsPerPixel: number,
            extents: envelope
    }
    declare interface repositionStatsObj {
        centerX: number,
            centerY: number,
            zoomLevel: number,
            mapUnitsPerPixel: number
    }
    declare interface beginDigitizeOptions {
        key?: string,
            shapeType: string,
            geometryStyle?: geometryStyle,
            styledGeometry?: styledGeometry,
            nodeTapAndHoldAction?: (setIdx: number, idx: number) => boolean,
            nodeMoveAction?: (x: number, y: number, actionType: string) => any,
            shapeChangeAction?: () => void,
            envelopeEndAction?: (env: envelope) => void,
            circleEndAction?: (circle: geometry.polygon) => void,
            suppressNodeAdd?: boolean,
            leavePath?: boolean
    }
    declare interface styleObj {
        fillColor?: string,
            fillOpacity?: number,
            outlineColor?: string,
            outlineOpacity?: number,
            outlineThicknessPix?: number,
            dashArray?: string
    }
    declare interface mapsjsWidget {

        /**
         * Gets the center of the map in spherical mercator. Use 
         * sphericalMercator.deprojectToLatLon static function to convert to a lat/lon.
         * @return  A point map center
         */
        getMapCenter(): point,

            /**
             * Sets the center of the map in spherical mercator. Use
             * sphericalMercator.projectFromLatLon static function to convert from a lat/lon.
             * @param  The map center as a point
             */
            setMapCenter(center: point): void,

            /**
             * Same as setMapCenter except will animate from current map center to the 
             * specified location
             * @param  The map center as a point.
             * @param  Duration in miliseconds.
             * @param  Callback to perform on animaton complete.
             */
            setMapCenterAnimate(center: point, durationMs?: number, completeAction?: () => void): void,

            /**
             * Sets the map center to the current geolocation if supported. The map is
             *       animated to the new location.
                  
             * @param  Duration in miliseconds.
             * @param  Callback to perform on animaton complete.
            */
            setMapCenterToGeolocationAnimate(durationMs?: number, completeAction?: () => void): void,

            /**
             * Offsets the current map center by the specified deltas in pixels. 
             * @param  offset x in pixels.
             * @param  offset y in pixels.
             */
            offsetMapCenterByPixelDelta(dx: number, dy: number): void,

            /**
             * Offsets the current map center by the specified deltas in pixels - animated version.
             * @param  offset x in pixels.
             * @param  offset y in pixels.
             * @param  animation duration in mS.
             */
            offsetMapCenterByPixelDeltaAnimate(dx: number, dy: number, durationMs?: number): void,

            /**
             * Gets the current zoom level.
             * @returns  The current zoom level.
             */
            getZoomLevel(): number,

            /**
             * Sets the current zoom level.
             * @param  The desired zoom level.
             */
            setZoomLevel(zl: number): void,

            /**
             * Sets the minimum zoom level for the map.
             * @param  Desired minimum zoom level.
             */
            setMinZoomLevel(zl: number): void,

            /**
             * Sets the maximum zoom level for the map.
             * @param  The desired maximum zoom level.
             */
            setMaxZoomLevel(zl: number): void,

            /**
             * Animates the map from the current zoom level to the given zoom level.
             * @param  The desired zoom level.
             * @param  The duration in miliseconds.
             * @param  Function to call when the animation
            completes with signature completeAction().
            */
            setZoomLevelAnimate(zl: number, durationMs?: number, completeAction?: () => void): void,

            /**
             * Changes the current zoom level.
             * @param  Change to be added to the current zoom level.
             */
            zoomDelta(delta: number): void,

            /**
             * Animates a change to the current zoom level.
             * @param  Change to be added to the current zoom level.
             * @param  Duration in miliseconds.
             */
            zoomDeltaAnimate(delta: number, durationMs?: number): void,

            /**
             * Animates parabolically from the current map center and zoom level
             * to the given map center and zoom level.
             * @param  Desired map center as a point.
             * @param  Desired zoom level.
             * @param  Animation duration in miliseconds.
             * @param  Function to call after the animation
            completes with signature completeAction().
            */
            flyTo(
                center: point,
                zl: number,
                durationMs?: number,
                completeAction?: () => void): void,

            /**
             * Gets the current map extents in spherical mercator units.
             * @return  envelope The current map extents.
             */
            getMapExtents(): envelope,

            /**
             * Gets the current map units per pixel.
             * @returns  Map units (meters) per pixel.
             */
            getMapUnitsPerPixel(): number,

            /**
             * Gets the map extents' width and height in pixels.
             * @returns  JavaScript object of the form {w, h} where w is
            the current extents' width in pixels and h is the current extents'
            height in pixels.
            */
            getViewExtentsInPix(): {
                w: number,
                h: number
            },

            /**
             * Gets the current projected map scale. This is the ratio of units on
             * the screen to map units depicted.
             * @returns  Ratio of screen units to map units.
             */
            getProjectedMapScale(): number,

            /**
             * Gets the current actual map scale. This is the ratio of units on 
             * the screen to actual units on the earth's surface at the latitude 
            of the current map center.
             * @returns  The ratio of screen units to actual meters.
            */
            getActualMapScale(): number,

            /**
             * Gets the best fit zoom level based on the supplied map extents for 
             * the current display extents in pixels.
             * @param  New map extents to fit.
             * @returns  The zoom level which best fits the extents.
             */
            getBestFitZoomLevelByExtents(extentsNew: envelope): number,

            /**
             * Forces the map to redraw the currently loaded tile and geometry 
             * content. You should not have to call this as redraws are automatically
            handled during programatic state changes. This would be for edge cases 
            where the developer is affecting internal state in an undocumented way.
            */
            redraw(): void,

            /**
             * Updates the map to the size of its container. This updates internal 
             * parameters for computing map extents and handling the amount of tile 
            content to download. This is handled automatically if the browser 
            window is resized. But if you are sizing the map programatically 
            (e.g. resizable panel or slider) then call this after the parent 
            container has resized.
            */
            resize(): void,

            /**
             * Pushes a supplied tile layer onto the top of the display stack.
             * @param  The desired tile layer.
             */
            pushTileLayer(tl: tile.layer): void,

            /**
             * Removes a tile layer off the top of the display stack
             * @returns  The removed tile layer.
             */
            popTileLayer(): tile.layer,

            /**
             * Removes a tile layer off the display stack by reference
             * @param  A tile layer to remove.
             */
            removeTileLayer(tl: tile.layer): void,

            /**
             * Removes all tile layers off the display stack
             */
            removeAllTileLayers(): void,

            /**
             * Gets the current number of tile layers in the display stack.
             * @returns  The number of tile layers in the display stack.
             */
            getTileLayerCount(): number,

            /**
             * Gets a tile layer from the display stack by its key.
             * @param  The desired tile layer's key.
             * @returns  The tile layer associated with the key, or null
            if no tile layer is associated with the key.
            */
            getTileLayer(key: string): tile.layer,

            /**
             * Gets a point in map units from supplied coordinates pixel units 
             * with respect to the currently displayed extents.
             * @param  The x coordinate in pixels.
             * @param  The y coordinate in pixels.
             * @returns  The generated point in map units.
             */
            computeMapPointFromPixelLocation(x: number, y: number): point,

            /**
             * Flags whether or not map extent changes can occur through gestures 
             * like mouse or touch drag, mouse wheel, or pinch zoom.
             * @param  Whether or not gestures should affect map 
            extent changes.
            */
            setSuspendMapExtentChangesByGestures(flag: boolean): void,

            /**
             * Sets the z-order of drawn content in relation to the gesture capture 
             * panel. The default behavior (false) is to have fixed content and 
            geometry underneath the gesture panel in the DOM. If false, all 
            pointer events are handled by the gesture capture panel and
            optionally parents of the map control. If true, drawn content will
            receive pointer events first and will block gestures to the map. If 
            true, digitizing will not function and polygons will block map 
            navigation. In some scenarios you may want to set this to true if you
            are placing fixed content (such as point features) on the map and 
            need to handle gestures on the placed content. You can call this 
            function at any time to change the order.
                  
             * @param  Whether or not the fixed content layer should 
            reside above the gesture layer.
            */
            setDrawnContentZorderToTop(flag: boolean): void,

            /**
             * Add a fixed element to the content area which resides at a z-level 
             * above tiled map content. These elements do not scale with the map
            scale. This is used to place markers or callouts on the map
             * @param  Any html that can be added to the DOM.
             * @param  The x coordinate of the insertion point in map units.
             * @param  The y coordinate of the insertion point in map units.
             * @param  Callback function called after the 
            DOM element has been placed with signature addAction(element).
             * @param  JavaScript object of the form {dragEnabled,
            useElementInsteadOfNewGestureOverlay, downAction, moveAction, upAction, 
            wheelAction } where dragEnabled flags whether dragging should be
            enabled on the element, and downAction, moveAction, upAction, and 
            wheelAction are callback functions invoked on mousedown, mousemove,
            mouseup, and scroll events respectively.
            */
            addFixedContentElement(
                element: HTMLElement,
                mapUnitsX: number,
                mapUnitsY: number,
                addAction?: (ele: HTMLElement) => void,
                dragOptions?: {
                    dragEnabled: boolean,
                    useElementInsteadOfNewGestureOverlay: boolean,
                    downAction?: (downPoint: point) => any,
                    moveAction?: (movePoint: point) => void,
                    upAction?: (upPoint: point) => void,
                    wheelAction?: (delta: number) => void
                }): void,

            /**
             * Move an existing fixed content element.
             * @param  The existing DOM element to move.
             * @param  The new x coordinate in map units.
             * @param  The new y coordinate in map units.
             */
            moveFixedContentElement(element: HTMLElement, mapUnitsX: number, mapUnitsY: number): void,

            /**
             * Removes a fixed content element.
             * @param  The DOM element to remove. Note: This
            must be the same element added by addFixedContentElement.
            */
            removeFixedContentElement(element: HTMLElement): void,

            /**
             * Add a styled path geometry to the content area which resides at a z-level 
             * above tiled map content. The geometry is converted to SVG and added to the 
            content area DOM. If an attempt to add a geometry is made with the same 
            key, the geometry is swapped out. You must remove using removePathGeometry 
            for resource cleanup.
             * @param  The styledGeometry to render.
             * @param  String used to tie a geometry to its SVG
             * @param  optional function that is called when mapsjs adds an svg element to the DOM representing this styledGeometry.
             * @param  optional function that is called when mapsjs adds an svg element to the DOM representing this styledGeometry.
            rendering in the DOM.
             * @returns  The SVG element which was added to the DOM.
            */
            addPathGeometry(
                styledGeom: styledGeometry,
                key: string,
                addAction?: (svg: SVGElement) => void,
                removeAction?: (svg: SVGElement) => void): SVGElement,

            /**
             * Updates an existing path geometry to reflect a style change.
             * @param  The new geometryStyle.
             * @param  The key of the geometry to receive the new style.
             */
            updatePathGeometryStyle(styleNew: geometryStyle, key: string): void,

            /**
             * Removes a styledGeometry from display.
             * @param  The key of the geometry to remove.
             * @returns  The SVG element which was removed from the DOM.
             */
            removePathGeometry(key?: string): SVGElement,

            /**
             * Initiates digitization on the map control. This creates a new
             * geometry and adds verticies to the geometry accord to mouse
            click locations.
             * @param  JavaScript object of the form { key,
            shapeType, geometryStyle, styledGeometry, nodeTapAndHoldAction, nodeMoveAction,
            shapeChangeAction, envelopeEndAction, circleEndAction, supressNodeAdd, leavePath }
            where key is a a string associated with this geometry, shapeType
            is the type of shape this geometry is, one of 'polygon', 'polyline', 'multipoint', 'envelope' or 'circle', 
            geometryStyle is a geometryStyle which should be applied
            to the digitized geometry, styledGeometry is an optional styledGeometry for existing paths to edit, set this to enter edit mode,
            nodeTapAndHoldAction is a callback invoked
            when any point in the geometry is clicked and held and has the
            signature nodeTapAndHoldAction(setIdx, idx), nodeMoveAction is a
            callback invoked after any node is dragged to a new location and
            has signature nodeMoveAction(x, y, actionType), shapeChangeAction
            is a callback that is invoked after the geometry shape changes and,
            has signature shapeChangeAction(shape), envelopeEndAction is a callback 
            invoked after an envelope is created and has signature envelopeEndAction(envelope), 
            circleEndAction is similar to envelopeEndAction but takes a geometry.polygon representing the circle,
            and leavePath is a flag that indicates whether the digitized shape
            should be left on the map after digitization is complete.
            */
            beginDigitize(options: beginDigitizeOptions): void,
            endDigitize(): void,

            /**
             * Gets a snapshot copy of the currently digitizing path.
             * @returns  The currently digitizing path.
             */
            getDigitizeSnapshot(): geometry,

            /**
             * Forces additional digitized points to be pushed to a new set of the
             * currently digitizing geometry.
             */
            pushSetOnDigitizePath(): void,

            /**
             * Removes the last set from the currently digitizing path.
             * @return  The last set from the currently digitizing path
            in the form [xn,yn]. 
            */
            popSetFromDigitizePath(): number[],

            /**
             * Programmatically delete a node from the currently digitizing path.
             * @param  The index of the set from which to remove the node.
             * @param  The index of the node to remove.
             */
            deleteNodeOnDigitizePath(setIdx: number, nodeIdx: number): void,

            /**
             * Determines whether a shape is currently being digitized.
             * @returns  Whether or not a shape is being digitized.
             */
            isDigitizingEnabled(): boolean,

            /**
             * Set the function called when the map extents have stopped changing 
             * (e.g. after an animated pan or zoom).
             * @param  The function to call when the extents
            finish changing with signature action(object) where object is of
            the form { centerX, centerY, centerLat, centerLon, zoomLevel, mapScale,
            mapScaleProjected, mapUnitsPerPixel, extents }.
            */
            setExtentChangeCompleteAction(action: (vals: extentChangeStatsObj) => void): void,

            /**
             * Set the function called when map content (map tiles and fixed elements) are 
             * re-positioned in the DOM. This is done automatically as the map is panned 
            beyond existing content and zoomed to a new level requiring content.
             * @param  The function to call when the map content
            completes repositioning with signature action(object) where object
            is of the form { centerX, centerY, zoomLevel, mapUnitsPerPixel }.
            */
            setContentRepositionAction(action: (vals: repositionStatsObj) => void): void,

            /**
             * Sets function called when map is clicked or tapped.
             * @param  The function to call on mouse click or tap 
            with signature action(point).
            */
            setPointerClickAction(action: (pt: point) => void): void,

            /**
             * Sets function called when the map pointer hovers over the map.
             * @param  The function to call on mouse hover with 
            signature action(point).
            */
            setPointerHoverAction(action: (pt: point) => void): void,

            /**
             * Sets the margin around the map in pixels for extra content fetched so that tile 
             * rebuilding of the display is minimized. This is an advanced property and does not 
            generally need to be adjusted. The default is 128 pixels, or half the width
            of a tile. This should be increased for maps which are very large in pixels
            or where panning is constant. This should be decreased for very small maps,
            such as on mobile devices, or where panning is minimal.
             * @param  The content extent margin in pixels.
            */
            setContentExtentsMarginInPixels(cem: number): void,

            /**
             * Sets the background color of the map using a css color string
             * @param  - a css color string
             */
            setBackground(b: string): void
    }
}
declare interface JQuery {
    rimMap(): JQuery,
        rimMap(
            command: any,
            param?: any,
            param2?: any,
            param3?: any,
            param4?: any,
            param5?: any): JQuery,
        getMapsjs(): any
}