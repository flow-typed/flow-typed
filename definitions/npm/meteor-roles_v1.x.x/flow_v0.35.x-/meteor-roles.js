/**
 * Flowtype definitions for meteor-roles
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare
var npm$namespace$Roles: {
    addUsersToRoles: typeof Roles$addUsersToRoles,
    createRole: typeof Roles$createRole,
    deleteRole: typeof Roles$deleteRole,
    getAllRoles: typeof Roles$getAllRoles,
    getGroupsForUser: typeof Roles$getGroupsForUser,
    getRolesForUser: typeof Roles$getRolesForUser,
    getUsersInRole: typeof Roles$getUsersInRole,
    removeUsersFromRoles: typeof Roles$removeUsersFromRoles,
    setUserRoles: typeof Roles$setUserRoles,
    userIsInRole: typeof Roles$userIsInRole,
}
declare
var GLOBAL_GROUP: string;

declare
var subscription: Subscription;


/**
 * Add users to roles. Will create roles as needed.
 * 
NOTE: Mixing grouped and non-grouped roles for the same user
       is not supported and will throw an error.

Makes 2 calls to database:
  1. retrieve list of all existing roles
  2. update users' roles
 * @example  *     Roles.addUsersToRoles(userId, 'admin')
Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')
Roles.addUsersToRoles([user1, user2], ['user','editor'])
Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')
Roles.addUsersToRoles(userId, 'admin', Roles.GLOBAL_GROUP)
 * @method  addUsersToRoles
 * @param  User id(s) or object(s) with an _id field
 * @param  Name(s) of roles/permissions to add users to
 * @param  Optional group name. If supplied, roles will be
specific to that group.
Group names can not start with '$' or numbers.
Periods in names '.' are automatically converted
to underscores.
The special group Roles.GLOBAL_GROUP provides
a convenient way to assign blanket roles/permissions
across all groups.  The roles/permissions in the
Roles.GLOBAL_GROUP group will be automatically
included in checks for any group.
*/
declare
function Roles$addUsersToRoles(
    user: string | string[] | Object | Object[],
    roles: string | string[],
    group?: string): void


/**
 * Create a new role. Whitespace will be trimmed.
 * @method  createRole
 * @param  Name of role
 * @return  id of new role
 */
declare
function Roles$createRole(role: string): string


/**
 * Delete an existing role.  Will throw "Role in use" error if any users
 * are currently assigned to the target role.
 * @method  deleteRole
 * @param  Name of role
 */
declare
function Roles$deleteRole(role: string): void


/**
 * Retrieve set of all existing roles
 * @method  getAllRoles
 * @return  cursor of existing roles
 */
declare
function Roles$getAllRoles(): Mongo.Cursor<Roles$Role >


    /**
     * Retrieve users groups, if any
     * @method  getGroupsForUser
     * @param  User Id or actual user object
     * @param  Optional name of roles to restrict groups to.
     * @return  Array of user's groups, unsorted. Roles.GLOBAL_GROUP will be omitted
     */
    declare
function Roles$getGroupsForUser(user: string | Object, role?: string): string[]


/**
 * Retrieve users roles
 * @method  getRolesForUser
 * @param  User Id or actual user object
 * @param  Optional name of group to restrict roles to.
User's Roles.GLOBAL_GROUP will also be included.
 * @return  Array of user's roles, unsorted.
*/
declare
function Roles$getRolesForUser(user: string | Object, group?: string): Roles$Role[]


/**
 * Retrieve all users who are in target role.
 * 
NOTE: This is an expensive query; it performs a full collection scan
on the users collection since there is no index set on the 'roles' field.
This is by design as most queries will specify an _id so the _id index is
used automatically.
 * @method  getUsersInRole
 * @param  Name of role/permission.  If array, users
returned will have at least one of the roles
specified but need not have _all_ roles.
 * @param  Optional name of group to restrict roles to.
User's Roles.GLOBAL_GROUP will also be checked.
 * @param  Optional options which are passed directly
through to `Meteor.users.find(query, options)`
 * @return  cursor of users in role
*/
declare
function Roles$getUsersInRole(
    role: string | string[],
    group?: string,
    options?: {
        sort?: Mongo.SortSpecifier,
        skip?: number,
        limit?: number,
        fields?: Mongo.FieldSpecifier,
        reactive?: boolean,
        transform?: Function
    }): Mongo.Cursor<Meteor$User >


    /**
     * Remove users from roles
     * @example  *     Roles.removeUsersFromRoles(users.bob, 'admin')
    Roles.removeUsersFromRoles([users.bob, users.joe], ['editor'])
    Roles.removeUsersFromRoles([users.bob, users.joe], ['editor', 'user'])
    Roles.removeUsersFromRoles(users.eve, ['user'], 'group1')
     * @method  removeUsersFromRoles
     * @param  User id(s) or object(s) with an _id field
     * @param  Name(s) of roles to add users to
     * @param  Optional. Group name. If supplied, only that
    group will have roles removed.
    */
    declare
function Roles$removeUsersFromRoles(
    user: string | string[] | Object | Object[],
    roles?: string[],
    group?: string): void


/**
 * Set a users roles/permissions.
 * @example  *     Roles.setUserRoles(userId, 'admin')
Roles.setUserRoles(userId, ['view-secrets'], 'example.com')
Roles.setUserRoles([user1, user2], ['user','editor'])
Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')
Roles.setUserRoles(userId, 'admin', Roles.GLOBAL_GROUP)
 * @method  setUserRoles
 * @param  User id(s) or object(s) with an _id field
 * @param  Name(s) of roles/permissions to add users to
 * @param  Optional group name. If supplied, roles will be
specific to that group.
Group names can not start with '$'.
Periods in names '.' are automatically converted
to underscores.
The special group Roles.GLOBAL_GROUP provides
a convenient way to assign blanket roles/permissions
across all groups.  The roles/permissions in the
Roles.GLOBAL_GROUP group will be automatically
included in checks for any group.
*/
declare
function Roles$setUserRoles(
    user: string | string[] | Object | Object[],
    roles: string | string[],
    group?: string): void


/**
 * Check if user has specified permissions/roles
 * @example  *     // non-group usage
Roles.userIsInRole(user, 'admin')
Roles.userIsInRole(user, ['admin','editor'])
Roles.userIsInRole(userId, 'admin')
Roles.userIsInRole(userId, ['admin','editor'])

// per-group usage
Roles.userIsInRole(user,   ['admin','editor'], 'group1')
Roles.userIsInRole(userId, ['admin','editor'], 'group1')
Roles.userIsInRole(userId, ['admin','editor'], Roles.GLOBAL_GROUP)

// this format can also be used as short-hand for Roles.GLOBAL_GROUP
Roles.userIsInRole(user, 'admin')
 * @method  userIsInRole
 * @param  User Id or actual user object
 * @param  Name of role/permission or Array of
roles/permissions to check against.  If array,
will return true if user is in _any_ role.
 * @param  Optional. Name of group.  If supplied, limits check
to just that group.
The user's Roles.GLOBAL_GROUP will always be checked
whether group is specified or not.
 * @return  true if user is in _any_ of the target roles
*/
declare
function Roles$userIsInRole(
    user: string | string[] | Object | Object[],
    roles: string | string[],
    group?: string): boolean

declare interface Roles$Role {
    name: string
}
declare
var roles: Mongo.Collection<Roles$Role>;