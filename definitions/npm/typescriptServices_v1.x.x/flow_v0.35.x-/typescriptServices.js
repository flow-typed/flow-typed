// @flow
/**
 * Flowtype definitions for typescriptServices
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$ts: {
    displayPartsToString: typeof ts$displayPartsToString,
    getDefaultCompilerOptions: typeof ts$getDefaultCompilerOptions,
    transpileModule: typeof ts$transpileModule,
    transpile: typeof ts$transpile,
    createLanguageServiceSourceFile: typeof ts$createLanguageServiceSourceFile,
    updateLanguageServiceSourceFile: typeof ts$updateLanguageServiceSourceFile,
    createGetCanonicalFileName: typeof ts$createGetCanonicalFileName,
    createDocumentRegistry: typeof ts$createDocumentRegistry,
    preProcessFile: typeof ts$preProcessFile,
    createLanguageService: typeof ts$createLanguageService,
    createClassifier: typeof ts$createClassifier,
    getDefaultLibFilePath: typeof ts$getDefaultLibFilePath,
}
declare var servicesVersion: string;

declare type ts$Node = {
    kind: SyntaxKind,
    flags: NodeFlags,
    decorators?: ts$NodeArray<ts$Decorator>,
    modifiers?: ts$ModifiersArray,
    parent?: ts$Node
} & ts$TextRange


declare interface ts$Symbol {
    flags: SymbolFlags,
        name: string,
        declarations?: ts$Declaration[],
        valueDeclaration?: ts$Declaration,
        members?: ts$SymbolTable,
        exports?: ts$SymbolTable
}

declare interface ts$Type {
    flags: TypeFlags,
        symbol?: ts$Symbol
}

declare interface ts$Signature {
    declaration: ts$SignatureDeclaration,
        typeParameters: ts$TypeParameter[],
        parameters: ts$Symbol[],
        typePredicate?: ts$TypePredicate
}

declare type ts$SourceFile = {
    statements: ts$NodeArray<ts$Statement>,
    endOfFileToken: ts$Node,
    fileName: string,
    text: string,
    amdDependencies: {
        path: string,
        name: string
    }[],
    moduleName: string,
    referencedFiles: ts$FileReference[],
    languageVariant: LanguageVariant,

    /**
     * lib.d.ts should have a reference comment like
     * 
      /// <reference no-default-lib="true"/>

    If any other file has this comment, it signals not to include lib.d.ts
    because this containing file is intended to act as a default library.
    */
    hasNoDefaultLib: boolean,
    languageVersion: ScriptTarget
} & ts$Declaration



/**
 * Represents an immutable snapshot of a script at a specified time.Once acquired, the
 * snapshot is observably immutable. i.e. the same calls with the same parameters will return
the same values.
*/
declare interface ts$IScriptSnapshot {

    /**
     * Gets a portion of the script snapshot specified by [start, end). 
     */
    getText(start: number, end: number): string,

        /**
         * Gets the length of this script snapshot. 
         */
        getLength(): number,

        /**
         * Gets the TextChangeRange that describe how the text changed between this text and
         * an older version.  This information is used by the incremental parser to determine
        what sections of the script need to be re-parsed.  'undefined' can be returned if the
        change range cannot be determined.  However, in that case, incremental parsing will
        not happen and the entire document will be re - parsed.
        */
        getChangeRange(oldSnapshot: ts$IScriptSnapshot): ts$TextChangeRange,

        /**
         * Releases all resources held by this script snapshot 
         */
        dispose(): void
}


declare var npm$namespace$ScriptSnapshot: {
    fromString: typeof ScriptSnapshot$fromString,
}
declare function ScriptSnapshot$fromString(text: string): ts$IScriptSnapshot

declare interface ts$PreProcessedFileInfo {
    referencedFiles: ts$FileReference[],
        importedFiles: ts$FileReference[],
        ambientExternalModules: string[],
        isLibFile: boolean
}

declare interface ts$HostCancellationToken {
    isCancellationRequested(): boolean
}

declare interface ts$LanguageServiceHost {
    getCompilationSettings(): ts$CompilerOptions,
        getNewLine(): string,
        getProjectVersion(): string,
        getScriptFileNames(): string[],
        getScriptVersion(fileName: string): string,
        getScriptSnapshot(fileName: string): ts$IScriptSnapshot,
        getLocalizedDiagnosticMessages(): any,
        getCancellationToken(): ts$HostCancellationToken,
        getCurrentDirectory(): string,
        getDefaultLibFileName(options: ts$CompilerOptions): string,
        log(s: string): void,
        trace(s: string): void,
        error(s: string): void,
        useCaseSensitiveFileNames(): boolean,
        resolveModuleNames(moduleNames: string[], containingFile: string): ts$ResolvedModule[]
}

declare interface ts$LanguageService {
    cleanupSemanticCache(): void,
        getSyntacticDiagnostics(fileName: string): ts$Diagnostic[],
        getSemanticDiagnostics(fileName: string): ts$Diagnostic[],
        getCompilerOptionsDiagnostics(): ts$Diagnostic[],

        /**
         * 
         * @deprecated  Use getEncodedSyntacticClassifications instead.
         */
        getSyntacticClassifications(fileName: string, span: ts$TextSpan): ts$ClassifiedSpan[],

        /**
         * 
         * @deprecated  Use getEncodedSemanticClassifications instead.
         */
        getSemanticClassifications(fileName: string, span: ts$TextSpan): ts$ClassifiedSpan[],
        getEncodedSyntacticClassifications(fileName: string, span: ts$TextSpan): ts$Classifications,
        getEncodedSemanticClassifications(fileName: string, span: ts$TextSpan): ts$Classifications,
        getCompletionsAtPosition(fileName: string, position: number): ts$CompletionInfo,
        getCompletionEntryDetails(
            fileName: string,
            position: number,
            entryName: string): ts$CompletionEntryDetails,
        getQuickInfoAtPosition(fileName: string, position: number): ts$QuickInfo,
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): ts$TextSpan,
        getBreakpointStatementAtPosition(fileName: string, position: number): ts$TextSpan,
        getSignatureHelpItems(fileName: string, position: number): ts$SignatureHelpItems,
        getRenameInfo(fileName: string, position: number): ts$RenameInfo,
        findRenameLocations(
            fileName: string,
            position: number,
            findInStrings: boolean,
            findInComments: boolean): ts$RenameLocation[],
        getDefinitionAtPosition(fileName: string, position: number): ts$DefinitionInfo[],
        getTypeDefinitionAtPosition(fileName: string, position: number): ts$DefinitionInfo[],
        getReferencesAtPosition(fileName: string, position: number): ts$ReferenceEntry[],
        findReferences(fileName: string, position: number): ts$ReferencedSymbol[],
        getDocumentHighlights(
            fileName: string,
            position: number,
            filesToSearch: string[]): ts$DocumentHighlights[],

        /**
         * 
         * @deprecated  
         */
        getOccurrencesAtPosition(fileName: string, position: number): ts$ReferenceEntry[],
        getNavigateToItems(searchValue: string, maxResultCount?: number): ts$NavigateToItem[],
        getNavigationBarItems(fileName: string): ts$NavigationBarItem[],
        getOutliningSpans(fileName: string): ts$OutliningSpan[],
        getTodoComments(fileName: string, descriptors: ts$TodoCommentDescriptor[]): ts$TodoComment[],
        getBraceMatchingAtPosition(fileName: string, position: number): ts$TextSpan[],
        getIndentationAtPosition(fileName: string, position: number, options: ts$EditorOptions): number,
        getFormattingEditsForRange(
            fileName: string,
            start: number,
            end: number,
            options: ts$FormatCodeOptions): ts$TextChange[],
        getFormattingEditsForDocument(fileName: string, options: ts$FormatCodeOptions): ts$TextChange[],
        getFormattingEditsAfterKeystroke(
            fileName: string,
            position: number,
            key: string,
            options: ts$FormatCodeOptions): ts$TextChange[],
        getDocCommentTemplateAtPosition(fileName: string, position: number): ts$TextInsertion,
        getEmitOutput(fileName: string): ts$EmitOutput,
        getProgram(): ts$Program,
        getSourceFile(fileName: string): ts$SourceFile,
        dispose(): void
}

declare interface ts$Classifications {
    spans: number[],
        endOfLineState: EndOfLineState
}

declare interface ts$ClassifiedSpan {
    textSpan: ts$TextSpan,
        classificationType: string
}

declare interface ts$NavigationBarItem {
    text: string,
        kind: string,
        kindModifiers: string,
        spans: ts$TextSpan[],
        childItems: ts$NavigationBarItem[],
        indent: number,
        bolded: boolean,
        grayed: boolean
}

declare interface ts$TodoCommentDescriptor {
    text: string,
        priority: number
}

declare interface ts$TodoComment {
    descriptor: ts$TodoCommentDescriptor,
        message: string,
        position: number
}

declare class TextChange {
    span: ts$TextSpan;
    newText: string
}

declare interface ts$TextInsertion {
    newText: string,

        /**
         * The position in newText the caret should point to after the insertion. 
         */
        caretOffset: number
}

declare interface ts$RenameLocation {
    textSpan: ts$TextSpan,
        fileName: string
}

declare interface ts$ReferenceEntry {
    textSpan: ts$TextSpan,
        fileName: string,
        isWriteAccess: boolean
}

declare interface ts$DocumentHighlights {
    fileName: string,
        highlightSpans: ts$HighlightSpan[]
}

declare var none: string;

declare var definition: string;

declare var reference: string;

declare var writtenReference: string;

declare interface ts$HighlightSpan {
    fileName?: string,
        textSpan: ts$TextSpan,
        kind: string
}

declare interface ts$NavigateToItem {
    name: string,
        kind: string,
        kindModifiers: string,
        matchKind: string,
        isCaseSensitive: boolean,
        fileName: string,
        textSpan: ts$TextSpan,
        containerName: string,
        containerKind: string
}

declare interface ts$EditorOptions {
    IndentSize: number,
        TabSize: number,
        NewLineCharacter: string,
        ConvertTabsToSpaces: boolean
}

declare type ts$FormatCodeOptions = {
    InsertSpaceAfterCommaDelimiter: boolean,
    InsertSpaceAfterSemicolonInForStatements: boolean,
    InsertSpaceBeforeAndAfterBinaryOperators: boolean,
    InsertSpaceAfterKeywordsInControlFlowStatements: boolean,
    InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean,
    InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean,
    PlaceOpenBraceOnNewLineForFunctions: boolean,
    PlaceOpenBraceOnNewLineForControlBlocks: boolean,
    [s: string]: boolean | number | string
} & ts$EditorOptions


declare interface ts$DefinitionInfo {
    fileName: string,
        textSpan: ts$TextSpan,
        kind: string,
        name: string,
        containerKind: string,
        containerName: string
}

declare interface ts$ReferencedSymbol {
    definition: ts$DefinitionInfo,
        references: ts$ReferenceEntry[]
}

declare interface ts$SymbolDisplayPart {
    text: string,
        kind: string
}

declare interface ts$QuickInfo {
    kind: string,
        kindModifiers: string,
        textSpan: ts$TextSpan,
        displayParts: ts$SymbolDisplayPart[],
        documentation: ts$SymbolDisplayPart[]
}

declare interface ts$RenameInfo {
    canRename: boolean,
        localizedErrorMessage: string,
        displayName: string,
        fullDisplayName: string,
        kind: string,
        kindModifiers: string,
        triggerSpan: ts$TextSpan
}

declare interface ts$SignatureHelpParameter {
    name: string,
        documentation: ts$SymbolDisplayPart[],
        displayParts: ts$SymbolDisplayPart[],
        isOptional: boolean
}


/**
 * Represents a single signature to show in signature help.
 * The id is used for subsequent calls into the language service to ask questions about the
signature help item in the context of any documents that have been updated.  i.e. after
an edit has happened, while signature help is still active, the host can ask important
questions like 'what parameter is the user currently contained within?'.
*/
declare interface ts$SignatureHelpItem {
    isVariadic: boolean,
        prefixDisplayParts: ts$SymbolDisplayPart[],
        suffixDisplayParts: ts$SymbolDisplayPart[],
        separatorDisplayParts: ts$SymbolDisplayPart[],
        parameters: ts$SignatureHelpParameter[],
        documentation: ts$SymbolDisplayPart[]
}


/**
 * Represents a set of signature help items, and the preferred item that should be selected.
 */
declare interface ts$SignatureHelpItems {
    items: ts$SignatureHelpItem[],
        applicableSpan: ts$TextSpan,
        selectedItemIndex: number,
        argumentIndex: number,
        argumentCount: number
}

declare interface ts$CompletionInfo {
    isMemberCompletion: boolean,
        isNewIdentifierLocation: boolean,
        entries: ts$CompletionEntry[]
}

declare interface ts$CompletionEntry {
    name: string,
        kind: string,
        kindModifiers: string,
        sortText: string
}

declare interface ts$CompletionEntryDetails {
    name: string,
        kind: string,
        kindModifiers: string,
        displayParts: ts$SymbolDisplayPart[],
        documentation: ts$SymbolDisplayPart[]
}

declare interface ts$OutliningSpan {

    /**
     * The span of the document to actually collapse. 
     */
    textSpan: ts$TextSpan,

        /**
         * The span of the document to display when the user hovers over the collapsed span. 
         */
        hintSpan: ts$TextSpan,

        /**
         * The text to display in the editor for the collapsed region. 
         */
        bannerText: string,

        /**
         * Whether or not this region should be automatically collapsed when
         * the 'Collapse to Definitions' command is invoked.
         */
        autoCollapse: boolean
}

declare interface ts$EmitOutput {
    outputFiles: ts$OutputFile[],
        emitSkipped: boolean
}

declare interface ts$OutputFile {
    name: string,
        writeByteOrderMark: boolean,
        text: string
}

declare interface ts$ClassificationResult {
    finalLexState: EndOfLineState,
        entries: ts$ClassificationInfo[]
}

declare interface ts$ClassificationInfo {
    length: number,
        classification: TokenClass
}

declare interface ts$Classifier {

    /**
     * Gives lexical classifications of tokens on a line without any syntactic context.
     * For instance, a token consisting of the text 'string' can be either an identifier
    named 'string' or the keyword 'string', however, because this classifier is not aware,
    it relies on certain heuristics to give acceptable results. For classifications where
    speed trumps accuracy, this function is preferable; however, for true accuracy, the
    syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
    lexical, syntactic, and semantic classifiers may issue the best user experience.
     * @param text The text of a line to classify.
     * @param lexState The state of the lexical classifier at the end of the previous line.
     * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
    If there is no syntactic classifier (syntacticClassifierAbsent=true),
    certain heuristics may be used in its place; however, if there is a
    syntactic classifier (syntacticClassifierAbsent=false), certain
    classifications which may be incorrectly categorized will be given
    back as Identifiers in order to allow the syntactic classifier to
    subsume the classification.
     * @deprecated  Use getLexicalClassifications instead.
    */
    getClassificationsForLine(
            text: string,
            lexState: EndOfLineState,
            syntacticClassifierAbsent: boolean): ts$ClassificationResult,
        getEncodedLexicalClassifications(
            text: string,
            endOfLineState: EndOfLineState,
            syntacticClassifierAbsent: boolean): ts$Classifications
}


/**
 * The document registry represents a store of SourceFile objects that can be shared between
 * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
of files in the context.
SourceFile objects account for most of the memory usage by the language service. Sharing
the same DocumentRegistry instance between different instances of LanguageService allow
for more efficient memory utilization since all projects will share at least the library
file (lib.d.ts).

A more advanced use of the document registry is to serialize sourceFile objects to disk
and re-hydrate them when needed.

To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
to all subsequent createLanguageService calls.
*/
declare interface ts$DocumentRegistry {

    /**
     * Request a stored SourceFile with a given fileName and compilationSettings.
     * The first call to acquire will call createLanguageServiceSourceFile to generate
    the SourceFile if was not found in the registry.
     * @param fileName The name of the file requested
     * @param compilationSettings Some compilation settings like target affects the
    shape of a the resulting SourceFile. This allows the DocumentRegistry to store
    multiple copies of the same file for different compilation settings.
     * @parm  scriptSnapshot Text of the file. Only used if the file was not found
    in the registry and a new one was created.
     * @parm  version Current version of the file. Only used if the file was not found
    in the registry and a new one was created.
    */
    acquireDocument(
            fileName: string,
            compilationSettings: ts$CompilerOptions,
            scriptSnapshot: ts$IScriptSnapshot,
            version: string): ts$SourceFile,

        /**
         * Request an updated version of an already existing SourceFile with a given fileName
         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
        to get an updated SourceFile.
         * @param fileName The name of the file requested
         * @param compilationSettings Some compilation settings like target affects the
        shape of a the resulting SourceFile. This allows the DocumentRegistry to store
        multiple copies of the same file for different compilation settings.
         * @param scriptSnapshot Text of the file.
         * @param version Current version of the file.
        */
        updateDocument(
            fileName: string,
            compilationSettings: ts$CompilerOptions,
            scriptSnapshot: ts$IScriptSnapshot,
            version: string): ts$SourceFile,

        /**
         * Informs the DocumentRegistry that a file is not needed any longer.
         * 
        Note: It is not allowed to call release on a SourceFile that was not acquired from
        this registry originally.
         * @param fileName The name of the file to be released
         * @param compilationSettings The compilation settings used to acquire the file
        */
        releaseDocument(fileName: string, compilationSettings: ts$CompilerOptions): void,
        reportStats(): string
}

declare var unknown: string;

declare var warning: string;

declare var keyword: string;

declare var scriptElement: string;

declare var moduleElement: string;

declare var classElement: string;

declare var localClassElement: string;

declare var interfaceElement: string;

declare var typeElement: string;

declare var enumElement: string;

declare var variableElement: string;

declare var localVariableElement: string;

declare var functionElement: string;

declare var localFunctionElement: string;

declare var memberFunctionElement: string;

declare var memberGetAccessorElement: string;

declare var memberSetAccessorElement: string;

declare var memberVariableElement: string;

declare var constructorImplementationElement: string;

declare var callSignatureElement: string;

declare var indexSignatureElement: string;

declare var constructSignatureElement: string;

declare var parameterElement: string;

declare var typeParameterElement: string;

declare var primitiveType: string;

declare var label: string;

declare var alias: string;

declare var constElement: string;

declare var letElement: string;

declare var none: string;

declare var publicMemberModifier: string;

declare var privateMemberModifier: string;

declare var protectedMemberModifier: string;

declare var exportedModifier: string;

declare var ambientModifier: string;

declare var staticModifier: string;

declare var abstractModifier: string;

declare class ClassificationTypeNames {
    comment: string;
    identifier: string;
    keyword: string;
    numericLiteral: string;
    operator: string;
    stringLiteral: string;
    whiteSpace: string;
    text: string;
    punctuation: string;
    className: string;
    enumName: string;
    interfaceName: string;
    moduleName: string;
    typeParameterName: string;
    typeAliasName: string;
    parameterName: string;
    docCommentTagName: string
}

declare type ts$DisplayPartsSymbolWriter = {
    displayParts(): ts$SymbolDisplayPart[]
} & ts$SymbolWriter


declare function ts$displayPartsToString(displayParts: ts$SymbolDisplayPart[]): string

declare function ts$getDefaultCompilerOptions(): ts$CompilerOptions

declare interface ts$TranspileOptions {
    compilerOptions?: ts$CompilerOptions,
        fileName?: string,
        reportDiagnostics?: boolean,
        moduleName?: string,
        renamedDependencies?: ts$Map<string >
}

declare interface ts$TranspileOutput {
    outputText: string,
        diagnostics?: ts$Diagnostic[],
        sourceMapText?: string
}

declare function ts$transpileModule(input: string, transpileOptions: ts$TranspileOptions): ts$TranspileOutput

declare function ts$transpile(
    input: string,
    compilerOptions?: ts$CompilerOptions,
    fileName?: string,
    diagnostics?: ts$Diagnostic[],
    moduleName?: string): string

declare function ts$createLanguageServiceSourceFile(
    fileName: string,
    scriptSnapshot: ts$IScriptSnapshot,
    scriptTarget: ScriptTarget,
    version: string,
    setNodeParents: boolean): ts$SourceFile

declare var disableIncrementalParsing: boolean;

declare function ts$updateLanguageServiceSourceFile(
    sourceFile: ts$SourceFile,
    scriptSnapshot: ts$IScriptSnapshot,
    version: string,
    textChangeRange: ts$TextChangeRange,
    aggressiveChecks?: boolean): ts$SourceFile

declare function ts$createGetCanonicalFileName(useCaseSensitivefileNames: boolean): (fileName: string) => string

declare function ts$createDocumentRegistry(useCaseSensitiveFileNames?: boolean): ts$DocumentRegistry

declare function ts$preProcessFile(sourceText: string, readImportFiles?: boolean): ts$PreProcessedFileInfo

declare function ts$createLanguageService(
    host: ts$LanguageServiceHost,
    documentRegistry?: ts$DocumentRegistry): ts$LanguageService

declare function ts$createClassifier(): ts$Classifier


/**
 * Get the path of the default library files (lib.d.ts) as distributed with the typescript
 * node package.
The functionality is not supported if the ts module is consumed outside of a node module.
*/
declare function ts$getDefaultLibFilePath(options: ts$CompilerOptions): string