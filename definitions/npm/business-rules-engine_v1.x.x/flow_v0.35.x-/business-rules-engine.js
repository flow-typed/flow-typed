// @flow
/**
 * Flowtype definitions for business-rules-engine
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Validation$IErrorCustomMessage {
    (config: any, args: any): string
}

declare interface Validation$IPropertyValidator {
    isAcceptable(s: any): boolean,
        customMessage?: Validation$IErrorCustomMessage,
        tagName?: string
}

declare type Validation$IStringValidator = {
    isAcceptable(s: string): boolean
} & Validation$IPropertyValidator


declare interface Validation$IAsyncPropertyValidator {
    isAcceptable(s: any): Q.Promise<boolean>,
        customMessage?: Validation$IErrorCustomMessage,
        isAsync: boolean,
        tagName?: string
}

declare type Validation$IAsyncStringPropertyValidator = {
    isAcceptable(s: string): Q.Promise<boolean >
} & Validation$IAsyncPropertyValidator


declare interface Validation$IError {
    HasError: boolean,
        ErrorMessage: string,
        TranslateArgs?: Validation$IErrorTranslateArgs
}

declare interface Validation$IErrorTranslateArgs {
    TranslateId: string,
        MessageArgs: any,
        CustomMessage?: Validation$IErrorCustomMessage
}

declare interface Validation$IOptional {
    (): boolean
}

declare type Validation$IValidationFailure = {
    IsAsync: boolean,
    Error: Validation$IError
} & Validation$IError


declare interface Validation$IValidationResult {
    Name: string,
        Add(validationResult: Validation$IValidationResult): void,
        Remove(index: number): void,
        Children: Validation$IValidationResult[],
        HasErrors: boolean,
        HasErrorsDirty: boolean,
        ErrorMessage: string,
        ErrorCount: number,
        Optional?: Validation$IOptional,
        TranslateArgs?: Validation$IErrorTranslateArgs[]
}

declare interface Validation$IValidate {
    (args: Validation$IError): void
}

declare interface Validation$IAsyncValidate {
    (args: Validation$IError): Q.Promise<any >
}

declare interface Validation$IValidatorFce {
    Name: string,
        ValidationFce?: Validation$IValidate,
        AsyncValidationFce?: Validation$IAsyncValidate
}

declare interface Validation$IValidator {
    Validate(context: any): Validation$IValidationFailure,
        ValidateAsync(context: any): Q.Promise<Validation$IValidationFailure>,
        Error: Validation$IError
}

declare interface Validation$IAbstractValidator<T>{
    RuleFor(prop: string, validator: Validation$IPropertyValidator): any,
    ValidationFor(prop: string, validatorFce: Validation$IValidatorFce): any,
    Validation(validatorFce: Validation$IValidatorFce): any,
    ValidatorFor<K>(prop: string, validator: Validation$IAbstractValidator<K>): any,
    CreateRule(name: string): Validation$IAbstractValidationRule<any>,
    CreateAbstractRule(name: string): Validation$IAbstractValidationRule<any>,
    CreateAbstractListRule(name: string): Validation$IAbstractValidationRule<any>,
    ForList: boolean
}

declare interface Validation$IAbstractValidationRule<T>{
    Validate(context: T): Validation$IValidationResult,
    ValidateAsync(context: T): Q.Promise<Validation$IValidationResult>,
    ValidateAll(context: T): Q.Promise<Validation$IValidationResult>,
    ValidateProperty(context: T, propName: string): void,
    ValidationResult: Validation$IValidationResult,
    Rules: {
        [name: string]: Validation$IPropertyValidationRule<T >
    },
    Validators: {
        [name: string]: Validation$IValidator
    },
    Children: {
        [name: string]: Validation$IAbstractValidationRule<any >
    }
}

declare interface Validation$IPropertyValidationRule<T>{
    Validators: {
        [name: string]: any
    },
    Validate(context: Validation$IValidationContext<T>): Validation$IValidationFailure[],
    ValidateAsync(
        context: Validation$IValidationContext<T>): Q.Promise<Validation$IValidationFailure[] >
}

declare interface Validation$IValidationContext<T>{
    Value: string,
    Key: string,
    Data: T
}

declare class Error mixins IError {
    HasError: boolean;
    ErrorMessage: string;
    constructor(): this
}

declare class ValidationFailure mixins IError {
    Error: Validation$IError;
    IsAsync: boolean;
    constructor(Error: Validation$IError, IsAsync: boolean): this;
    HasError: boolean;
    ErrorMessage: string;
    TranslateArgs: Validation$IErrorTranslateArgs
}

declare class ValidationResult mixins IValidationResult {
    Name: string;
    constructor(Name: string): this;
    IsDirty: boolean;
    Children: Validation$IValidationResult[];
    Add(error: Validation$IValidationResult): void;
    Remove(index: number): void;
    Optional: Validation$IOptional;
    TranslateArgs: Validation$IErrorTranslateArgs[];
    HasErrorsDirty: boolean;
    HasErrors: boolean;
    ErrorCount: number;
    ErrorMessage: string
}

declare class CompositeValidationResult mixins IValidationResult {
    Name: string;
    Children: Validation$IValidationResult[];
    constructor(Name: string): this;
    Optional: Validation$IOptional;
    AddFirst(error: Validation$IValidationResult): void;
    Add(error: Validation$IValidationResult): void;
    Remove(index: number): void;
    HasErrorsDirty: boolean;
    HasErrors: boolean;
    ErrorCount: number;
    ErrorMessage: string;
    TranslateArgs: Validation$IErrorTranslateArgs[];
    LogErrors(headerMessage?: string): void;
    Errors: {
        [name: string]: Validation$IValidationResult
    };
    SetDirty(): void;
    SetPristine(): void
}

declare class AbstractValidator<T>mixins IAbstractValidator<T>{
    Validators: {
        [name: string]: Validation$IPropertyValidator[]
    };
    AbstractValidators: {
        [name: string]: Validation$IAbstractValidator<any >
    };
    ValidationFunctions: {
        [name: string]: Validation$IValidatorFce[]
    };
    RuleFor(prop: string, validator: Validation$IPropertyValidator): void;
    ValidationFor(prop: string, fce: Validation$IValidatorFce): void;
    Validation(fce: Validation$IValidatorFce): void;
    ValidatorFor<K>(
        prop: string,
        validator: Validation$IAbstractValidator<K>,
        forList?: boolean): void;
    CreateAbstractRule(name: string): Validation$IAbstractValidationRule<T>;
    CreateAbstractListRule(name: string): Validation$IAbstractValidationRule<T>;
    CreateRule(name: string): Validation$IAbstractValidationRule<T>;
    ForList: boolean
}

declare class MessageLocalization {
    customMsg: string;
    defaultMessages: {
        required: string,
        remote: string,
        email: string,
        url: string,
        date: string,
        dateISO: string,
        number: string,
        digits: string,
        signedDigits: string,
        creditcard: string,
        equalTo: string,
        maxlength: string,
        minlength: string,
        rangelength: string,
        range: string,
        max: string,
        min: string,
        step: string,
        contains: string,
        mask: string,
        custom: string
    };
    ValidationMessages: {
        required: string,
        remote: string,
        email: string,
        url: string,
        date: string,
        dateISO: string,
        number: string,
        digits: string,
        signedDigits: string,
        creditcard: string,
        equalTo: string,
        maxlength: string,
        minlength: string,
        rangelength: string,
        range: string,
        max: string,
        min: string,
        step: string,
        contains: string,
        mask: string,
        custom: string
    };
    GetValidationMessage(validator: any): string
}
declare module 'business-rule-engine' {
    declare module.exports: typeof Validation
}