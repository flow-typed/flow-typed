// @flow
/**
 * Flowtype definitions for anydb-sql
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'anydb-sql' {
    declare type AnyDBPool = {
        query: (
            text: string,
            values: any[],
            callback: (err: Error, result: any) => void) => void,
        begin: () => anydbSQL$Transaction,
        close: (err: Error) => void
    }
    declare interface Dictionary<T>{
        [key: string]: T
    }
    declare     export interface anydbSQL$OrderByValueNode {}

    declare     export interface anydbSQL$ColumnDefinition {
        primaryKey?: boolean,
            dataType?: string,
            references?: {
                table: string,
                column: string
            },
            notNull?: boolean
    }

    declare     export interface anydbSQL$TableDefinition {
        name: string,
            columns: Dictionary<anydbSQL$ColumnDefinition>,
            has?: Dictionary<{
                from: string,
                many?: boolean
            } >
    }

    declare     export interface anydbSQL$QueryLike {
        query: string,
            values: any[],
            text: string
    }

    declare     export interface anydbSQL$DatabaseConnection {
        queryAsync<T>(query: string, ...params: any[]): Promise<{
                rowCount: number,
                rows: T[]
            }>,
            queryAsync<T>(query: anydbSQL$QueryLike): Promise<{
                rowCount: number,
                rows: T[]
            } >
    }

    declare     export type anydbSQL$Transaction = {
        rollback(): void,
        commitAsync(): Promise<void >
    } & anydbSQL$DatabaseConnection


    declare     export interface anydbSQL$SubQuery<T>{
        select(node: anydbSQL$Column<T>): anydbSQL$SubQuery<T>,
        where(...nodes: any[]): anydbSQL$SubQuery<T>,
        from(table: anydbSQL$TableNode): anydbSQL$SubQuery<T>,
        group(...nodes: any[]): anydbSQL$SubQuery<T>,
        order(criteria: anydbSQL$OrderByValueNode): anydbSQL$SubQuery<T>,
        notExists(subQuery: anydbSQL$SubQuery<any>): anydbSQL$SubQuery<T >
    }

    declare interface anydbSQL$Executable<T>{
        get(): Promise<T>,
        getWithin(tx: anydbSQL$DatabaseConnection): Promise<T>,
        exec(): Promise<void>,
        all(): Promise<T[]>,
        execWithin(tx: anydbSQL$DatabaseConnection): Promise<void>,
        allWithin(tx: anydbSQL$DatabaseConnection): Promise<T[]>,
        toQuery(): anydbSQL$QueryLike
    }

    declare interface anydbSQL$Queryable<T>{
        where(...nodes: any[]): anydbSQL$Query<T>,
        delete(): anydbSQL$ModifyingQuery,
        select<U>(...nodes: any[]): anydbSQL$Query<U>,
        selectDeep<U>(table: anydbSQL$Table<T>): anydbSQL$Query<T>,
        selectDeep<U>(...nodesOrTables: any[]): anydbSQL$Query<U >
    }

    declare     export type anydbSQL$Query<T>= {
        from(table: anydbSQL$TableNode): anydbSQL$Query<T>,
        update(o: Dictionary<any>): anydbSQL$ModifyingQuery,
        update(o: {}): anydbSQL$ModifyingQuery,
        group(...nodes: any[]): anydbSQL$Query<T>,
        order(...criteria: anydbSQL$OrderByValueNode[]): anydbSQL$Query<T>,
        limit(l: number): anydbSQL$Query<T>,
        offset(o: number): anydbSQL$Query<T >
    } & anydbSQL$Executable & anydbSQL$Queryable


    declare     export type anydbSQL$ModifyingQuery = {
        returning<U>(...nodes: any[]): anydbSQL$Query<U>,
        where(...nodes: any[]): anydbSQL$ModifyingQuery
    } & anydbSQL$Executable


    declare     export interface anydbSQL$TableNode {
        join(table: anydbSQL$TableNode): anydbSQL$JoinTableNode,
            leftJoin(table: anydbSQL$TableNode): anydbSQL$JoinTableNode
    }

    declare     export type anydbSQL$JoinTableNode = {
        on(filter: anydbSQL$BinaryNode): anydbSQL$TableNode,
        on(filter: string): anydbSQL$TableNode
    } & anydbSQL$TableNode


    declare type anydbSQL$CreateQuery = {
        ifNotExists(): anydbSQL$Executable<void >
    } & anydbSQL$Executable


    declare type anydbSQL$DropQuery = {
        ifExists(): anydbSQL$Executable<void >
    } & anydbSQL$Executable


    declare     export type anydbSQL$Table<T>= {
        create(): anydbSQL$CreateQuery,
        drop(): anydbSQL$DropQuery,
        as(name: string): anydbSQL$Table<T>,
        update(o: any): anydbSQL$ModifyingQuery,
        insert(row: T): anydbSQL$ModifyingQuery,
        insert(rows: T[]): anydbSQL$ModifyingQuery,
        select(): anydbSQL$Query<T>,
        select<U>(...nodes: any[]): anydbSQL$Query<U>,
        from<U>(table: anydbSQL$TableNode): anydbSQL$Query<U>,
        star(): anydbSQL$Column<any>,
        subQuery<U>(): anydbSQL$SubQuery<U>,
        eventEmitter: {
            emit: (type: string, ...args: any[]) => void,
            on: (eventName: string, handler: Function) => void
        },
        columns: anydbSQL$Column<any>[],
        sql: anydbSQL$SQL,
        alter(): anydbSQL$AlterQuery<T >
    } & anydbSQL$TableNode & anydbSQL$Queryable


    declare     export type anydbSQL$AlterQuery<T>= {
        addColumn(column: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        addColumn(name: string, options: string): anydbSQL$AlterQuery<T>,
        dropColumn(column: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        renameColumn(
            column: anydbSQL$Column<any>,
            newColumn: anydbSQL$Column<any>): anydbSQL$AlterQuery<T>,
        renameColumn(column: anydbSQL$Column<any>, newName: string): anydbSQL$AlterQuery<T>,
        renameColumn(name: string, newName: string): anydbSQL$AlterQuery<T>,
        rename(newName: string): anydbSQL$AlterQuery<T >
    } & anydbSQL$Executable


    declare     export interface anydbSQL$SQL {
        functions: {
            LOWER(c: anydbSQL$Column<string>): anydbSQL$Column<string >
        }
    }

    declare     export interface anydbSQL$BinaryNode {
        and(node: anydbSQL$BinaryNode): anydbSQL$BinaryNode,
            or(node: anydbSQL$BinaryNode): anydbSQL$BinaryNode
    }

    declare     export interface anydbSQL$Column<T>{ in (arr: T[]): anydbSQL$BinaryNode,
        in (subQuery: anydbSQL$SubQuery<T>): anydbSQL$BinaryNode,
        notIn(arr: T[]): anydbSQL$BinaryNode,
        equals(node: any): anydbSQL$BinaryNode,
        notEquals(node: any): anydbSQL$BinaryNode,
        gte(node: any): anydbSQL$BinaryNode,
        lte(node: any): anydbSQL$BinaryNode,
        gt(node: any): anydbSQL$BinaryNode,
        lt(node: any): anydbSQL$BinaryNode,
        like(str: string): anydbSQL$BinaryNode,
        multiply: {
            (node: anydbSQL$Column<T>): anydbSQL$Column<T>,
            (n: number): anydbSQL$Column<number >
        },
        isNull(): anydbSQL$BinaryNode,
        isNotNull(): anydbSQL$BinaryNode,
        sum(): anydbSQL$Column<number>,
        count(): anydbSQL$Column<number>,
        count(name: string): anydbSQL$Column<number>,
        distinct(): anydbSQL$Column<T>,
        as(name: string): anydbSQL$Column<T>,
        ascending: anydbSQL$OrderByValueNode,
        descending: anydbSQL$OrderByValueNode,
        asc: anydbSQL$OrderByValueNode,
        desc: anydbSQL$OrderByValueNode
    }

    declare     export type anydbSQL$AnydbSql = {
        define<T>(map: anydbSQL$TableDefinition): anydbSQL$Table<T>,
        transaction<T>(fn: (tx: anydbSQL$Transaction) => Promise<T>): Promise<T>,
        allOf(...tables: anydbSQL$Table<any>[]): any,
        models: Dictionary<anydbSQL$Table<any >> ,
        functions: {
            LOWER: (name: anydbSQL$Column<string>) => anydbSQL$Column<string>,
            RTRIM: (name: anydbSQL$Column<string>) => anydbSQL$Column<string >
        },
        makeFunction(name: string): Function,
        begin(): anydbSQL$Transaction,
        open(): void,
        close(): void,
        getPool(): AnyDBPool,
        dialect(): string
    } & anydbSQL$DatabaseConnection

    declare module.exports: typeof anydbSQL
}