/**
 * Flowtype definitions for typescript
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'typescript' {
    declare interface Map<T>{
        [index: string]: T
    }
    declare interface FileMap<T>{
        get(fileName: string): T,
        set(fileName: string, value: T): void,
        contains(fileName: string): boolean,
        remove(fileName: string): void,
        forEachValue(f: (v: T) => void): void,
        clear(): void
    }
    declare interface TextRange {
        pos: number,
            end: number
    }
    declare type Node = {
        kind: SyntaxKind,
        flags: NodeFlags,
        decorators?: NodeArray<Decorator>,
        modifiers?: ModifiersArray,
        parent?: Node
    } & TextRange

    declare type NodeArray<T>= {
        hasTrailingComma?: boolean
    } & Array & TextRange

    declare type ModifiersArray = {
        flags: number
    } & NodeArray

    declare type Identifier = {
        text: string,
        originalKeywordKind?: SyntaxKind
    } & PrimaryExpression

    declare type QualifiedName = {
        left: EntityName,
        right: Identifier
    } & Node

    declare type EntityName = Identifier | QualifiedName;
    declare type DeclarationName = Identifier | LiteralExpression | ComputedPropertyName | BindingPattern;
    declare type Declaration = {
        _declarationBrand: any,
        name?: DeclarationName
    } & Node

    declare type ComputedPropertyName = {
        expression: Expression
    } & Node

    declare type Decorator = {
        expression: LeftHandSideExpression
    } & Node

    declare type TypeParameterDeclaration = {
        name: Identifier,
        constraint?: TypeNode,
        expression?: Expression
    } & Declaration

    declare type SignatureDeclaration = {
        typeParameters?: NodeArray<TypeParameterDeclaration>,
        parameters: NodeArray<ParameterDeclaration>,
        type?: TypeNode
    } & Declaration

    declare type VariableDeclaration = {
        parent?: VariableDeclarationList,
        name: Identifier | BindingPattern,
        type?: TypeNode,
        initializer?: Expression
    } & Declaration

    declare type VariableDeclarationList = {
        declarations: NodeArray<VariableDeclaration >
    } & Node

    declare type ParameterDeclaration = {
        dotDotDotToken?: Node,
        name: Identifier | BindingPattern,
        questionToken?: Node,
        type?: TypeNode,
        initializer?: Expression
    } & Declaration

    declare type BindingElement = {
        propertyName?: Identifier,
        dotDotDotToken?: Node,
        name: Identifier | BindingPattern,
        initializer?: Expression
    } & Declaration

    declare type PropertyDeclaration = {
        name: DeclarationName,
        questionToken?: Node,
        type?: TypeNode,
        initializer?: Expression
    } & Declaration & ClassElement

    declare type ObjectLiteralElement = {
        _objectLiteralBrandBrand: any
    } & Declaration

    declare type PropertyAssignment = {
        _propertyAssignmentBrand: any,
        name: DeclarationName,
        questionToken?: Node,
        initializer: Expression
    } & ObjectLiteralElement

    declare type ShorthandPropertyAssignment = {
        name: Identifier,
        questionToken?: Node
    } & ObjectLiteralElement

    declare type VariableLikeDeclaration = {
        propertyName?: Identifier,
        dotDotDotToken?: Node,
        name: DeclarationName,
        questionToken?: Node,
        type?: TypeNode,
        initializer?: Expression
    } & Declaration

    declare type BindingPattern = {
        elements: NodeArray<BindingElement >
    } & Node


    /**
     * Several node kinds share function-like features such as a signature,
     * a name, and a body. These nodes should extend FunctionLikeDeclaration.
    Examples:
    - FunctionDeclaration
    - MethodDeclaration
    - AccessorDeclaration
    */
    declare type FunctionLikeDeclaration = {
        _functionLikeDeclarationBrand: any,
        asteriskToken?: Node,
        questionToken?: Node,
        body?: Block | Expression
    } & SignatureDeclaration

    declare type FunctionDeclaration = {
        name?: Identifier,
        body?: Block
    } & FunctionLikeDeclaration & Statement

    declare type MethodDeclaration = {
        body?: Block
    } & FunctionLikeDeclaration & ClassElement & ObjectLiteralElement

    declare type ConstructorDeclaration = {
        body?: Block
    } & FunctionLikeDeclaration & ClassElement

    declare type SemicolonClassElement = {
        _semicolonClassElementBrand: any
    } & ClassElement

    declare type AccessorDeclaration = {
        _accessorDeclarationBrand: any,
        body: Block
    } & FunctionLikeDeclaration & ClassElement & ObjectLiteralElement

    declare type IndexSignatureDeclaration = {
        _indexSignatureDeclarationBrand: any
    } & SignatureDeclaration & ClassElement

    declare type TypeNode = {
        _typeNodeBrand: any
    } & Node

    declare type FunctionOrConstructorTypeNode = {
        _functionOrConstructorTypeNodeBrand: any
    } & TypeNode & SignatureDeclaration

    declare type TypeReferenceNode = {
        typeName: EntityName,
        typeArguments?: NodeArray<TypeNode >
    } & TypeNode

    declare type TypePredicateNode = {
        parameterName: Identifier,
        type: TypeNode
    } & TypeNode

    declare type TypeQueryNode = {
        exprName: EntityName
    } & TypeNode

    declare type TypeLiteralNode = {
        members: NodeArray<Node >
    } & TypeNode & Declaration

    declare type ArrayTypeNode = {
        elementType: TypeNode
    } & TypeNode

    declare type TupleTypeNode = {
        elementTypes: NodeArray<TypeNode >
    } & TypeNode

    declare type UnionOrIntersectionTypeNode = {
        types: NodeArray<TypeNode >
    } & TypeNode

    declare type UnionTypeNode = {} & UnionOrIntersectionTypeNode

    declare type IntersectionTypeNode = {} & UnionOrIntersectionTypeNode

    declare type ParenthesizedTypeNode = {
        type: TypeNode
    } & TypeNode

    declare type StringLiteral = {
        _stringLiteralBrand: any
    } & LiteralExpression & TypeNode

    declare type Expression = {
        _expressionBrand: any,
        contextualType?: Type
    } & Node

    declare type UnaryExpression = {
        _unaryExpressionBrand: any
    } & Expression

    declare type PrefixUnaryExpression = {
        operator: SyntaxKind,
        operand: UnaryExpression
    } & UnaryExpression

    declare type PostfixUnaryExpression = {
        operand: LeftHandSideExpression,
        operator: SyntaxKind
    } & PostfixExpression

    declare type PostfixExpression = {
        _postfixExpressionBrand: any
    } & UnaryExpression

    declare type LeftHandSideExpression = {
        _leftHandSideExpressionBrand: any
    } & PostfixExpression

    declare type MemberExpression = {
        _memberExpressionBrand: any
    } & LeftHandSideExpression

    declare type PrimaryExpression = {
        _primaryExpressionBrand: any
    } & MemberExpression

    declare type DeleteExpression = {
        expression: UnaryExpression
    } & UnaryExpression

    declare type TypeOfExpression = {
        expression: UnaryExpression
    } & UnaryExpression

    declare type VoidExpression = {
        expression: UnaryExpression
    } & UnaryExpression

    declare type AwaitExpression = {
        expression: UnaryExpression
    } & UnaryExpression

    declare type YieldExpression = {
        asteriskToken?: Node,
        expression?: Expression
    } & Expression

    declare type BinaryExpression = {
        left: Expression,
        operatorToken: Node,
        right: Expression
    } & Expression

    declare type ConditionalExpression = {
        condition: Expression,
        questionToken: Node,
        whenTrue: Expression,
        colonToken: Node,
        whenFalse: Expression
    } & Expression

    declare type FunctionExpression = {
        name?: Identifier,
        body: Block | Expression
    } & PrimaryExpression & FunctionLikeDeclaration

    declare type ArrowFunction = {
        equalsGreaterThanToken: Node
    } & Expression & FunctionLikeDeclaration

    declare type LiteralExpression = {
        text: string,
        isUnterminated?: boolean,
        hasExtendedUnicodeEscape?: boolean
    } & PrimaryExpression

    declare type TemplateExpression = {
        head: LiteralExpression,
        templateSpans: NodeArray<TemplateSpan >
    } & PrimaryExpression

    declare type TemplateSpan = {
        expression: Expression,
        literal: LiteralExpression
    } & Node

    declare type ParenthesizedExpression = {
        expression: Expression
    } & PrimaryExpression

    declare type ArrayLiteralExpression = {
        elements: NodeArray<Expression >
    } & PrimaryExpression

    declare type SpreadElementExpression = {
        expression: Expression
    } & Expression

    declare type ObjectLiteralExpression = {
        properties: NodeArray<ObjectLiteralElement >
    } & PrimaryExpression & Declaration

    declare type PropertyAccessExpression = {
        expression: LeftHandSideExpression,
        dotToken: Node,
        name: Identifier
    } & MemberExpression

    declare type ElementAccessExpression = {
        expression: LeftHandSideExpression,
        argumentExpression?: Expression
    } & MemberExpression

    declare type CallExpression = {
        expression: LeftHandSideExpression,
        typeArguments?: NodeArray<TypeNode>,
        arguments: NodeArray<Expression >
    } & LeftHandSideExpression

    declare type ExpressionWithTypeArguments = {
        expression: LeftHandSideExpression,
        typeArguments?: NodeArray<TypeNode >
    } & TypeNode

    declare type NewExpression = {} & CallExpression & PrimaryExpression

    declare type TaggedTemplateExpression = {
        tag: LeftHandSideExpression,
        template: LiteralExpression | TemplateExpression
    } & MemberExpression

    declare type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator;
    declare type AsExpression = {
        expression: Expression,
        type: TypeNode
    } & Expression

    declare type TypeAssertion = {
        type: TypeNode,
        expression: UnaryExpression
    } & UnaryExpression

    declare type AssertionExpression = TypeAssertion | AsExpression;
    declare type JsxElement = {
        openingElement: JsxOpeningElement,
        children: NodeArray<JsxChild>,
        closingElement: JsxClosingElement
    } & PrimaryExpression

    declare type JsxOpeningElement = {
        _openingElementBrand?: any,
        tagName: EntityName,
        attributes: NodeArray<JsxAttribute | JsxSpreadAttribute >
    } & Expression

    declare type JsxSelfClosingElement = {
        _selfClosingElementBrand?: any
    } & PrimaryExpression & JsxOpeningElement

    declare type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;
    declare type JsxAttribute = {
        name: Identifier,
        initializer?: Expression
    } & Node

    declare type JsxSpreadAttribute = {
        expression: Expression
    } & Node

    declare type JsxClosingElement = {
        tagName: EntityName
    } & Node

    declare type JsxExpression = {
        expression?: Expression
    } & Expression

    declare type JsxText = {
        _jsxTextExpressionBrand: any
    } & Node

    declare type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement;
    declare type Statement = {
        _statementBrand: any
    } & Node

    declare type Block = {
        statements: NodeArray<Statement >
    } & Statement

    declare type VariableStatement = {
        declarationList: VariableDeclarationList
    } & Statement

    declare type ExpressionStatement = {
        expression: Expression
    } & Statement

    declare type IfStatement = {
        expression: Expression,
        thenStatement: Statement,
        elseStatement?: Statement
    } & Statement

    declare type IterationStatement = {
        statement: Statement
    } & Statement

    declare type DoStatement = {
        expression: Expression
    } & IterationStatement

    declare type WhileStatement = {
        expression: Expression
    } & IterationStatement

    declare type ForStatement = {
        initializer?: VariableDeclarationList | Expression,
        condition?: Expression,
        incrementor?: Expression
    } & IterationStatement

    declare type ForInStatement = {
        initializer: VariableDeclarationList | Expression,
        expression: Expression
    } & IterationStatement

    declare type ForOfStatement = {
        initializer: VariableDeclarationList | Expression,
        expression: Expression
    } & IterationStatement

    declare type BreakOrContinueStatement = {
        label?: Identifier
    } & Statement

    declare type ReturnStatement = {
        expression?: Expression
    } & Statement

    declare type WithStatement = {
        expression: Expression,
        statement: Statement
    } & Statement

    declare type SwitchStatement = {
        expression: Expression,
        caseBlock: CaseBlock
    } & Statement

    declare type CaseBlock = {
        clauses: NodeArray<CaseOrDefaultClause >
    } & Node

    declare type CaseClause = {
        expression?: Expression,
        statements: NodeArray<Statement >
    } & Node

    declare type DefaultClause = {
        statements: NodeArray<Statement >
    } & Node

    declare type CaseOrDefaultClause = CaseClause | DefaultClause;
    declare type LabeledStatement = {
        label: Identifier,
        statement: Statement
    } & Statement

    declare type ThrowStatement = {
        expression: Expression
    } & Statement

    declare type TryStatement = {
        tryBlock: Block,
        catchClause?: CatchClause,
        finallyBlock?: Block
    } & Statement

    declare type CatchClause = {
        variableDeclaration: VariableDeclaration,
        block: Block
    } & Node

    declare type ClassLikeDeclaration = {
        name?: Identifier,
        typeParameters?: NodeArray<TypeParameterDeclaration>,
        heritageClauses?: NodeArray<HeritageClause>,
        members: NodeArray<ClassElement >
    } & Declaration

    declare type ClassDeclaration = {} & ClassLikeDeclaration & Statement

    declare type ClassExpression = {} & ClassLikeDeclaration & PrimaryExpression

    declare type ClassElement = {
        _classElementBrand: any
    } & Declaration

    declare type InterfaceDeclaration = {
        name: Identifier,
        typeParameters?: NodeArray<TypeParameterDeclaration>,
        heritageClauses?: NodeArray<HeritageClause>,
        members: NodeArray<Declaration >
    } & Declaration & Statement

    declare type HeritageClause = {
        token: SyntaxKind,
        types?: NodeArray<ExpressionWithTypeArguments >
    } & Node

    declare type TypeAliasDeclaration = {
        name: Identifier,
        typeParameters?: NodeArray<TypeParameterDeclaration>,
        type: TypeNode
    } & Declaration & Statement

    declare type EnumMember = {
        name: DeclarationName,
        initializer?: Expression
    } & Declaration

    declare type EnumDeclaration = {
        name: Identifier,
        members: NodeArray<EnumMember >
    } & Declaration & Statement

    declare type ModuleDeclaration = {
        name: Identifier | LiteralExpression,
        body: ModuleBlock | ModuleDeclaration
    } & Declaration & Statement

    declare type ModuleBlock = {
        statements: NodeArray<Statement >
    } & Node & Statement

    declare type ImportEqualsDeclaration = {
        name: Identifier,
        moduleReference: EntityName | ExternalModuleReference
    } & Declaration & Statement

    declare type ExternalModuleReference = {
        expression?: Expression
    } & Node

    declare type ImportDeclaration = {
        importClause?: ImportClause,
        moduleSpecifier: Expression
    } & Statement

    declare type ImportClause = {
        name?: Identifier,
        namedBindings?: NamespaceImport | NamedImports
    } & Declaration

    declare type NamespaceImport = {
        name: Identifier
    } & Declaration

    declare type ExportDeclaration = {
        exportClause?: NamedExports,
        moduleSpecifier?: Expression
    } & Declaration & Statement

    declare type NamedImportsOrExports = {
        elements: NodeArray<ImportOrExportSpecifier >
    } & Node

    declare type NamedImports = NamedImportsOrExports;
    declare type NamedExports = NamedImportsOrExports;
    declare type ImportOrExportSpecifier = {
        propertyName?: Identifier,
        name: Identifier
    } & Declaration

    declare type ImportSpecifier = ImportOrExportSpecifier;
    declare type ExportSpecifier = ImportOrExportSpecifier;
    declare type ExportAssignment = {
        isExportEquals?: boolean,
        expression: Expression
    } & Declaration & Statement

    declare type FileReference = {
        fileName: string
    } & TextRange

    declare type CommentRange = {
        hasTrailingNewLine?: boolean,
        kind: SyntaxKind
    } & TextRange

    declare type JSDocTypeExpression = {
        type: JSDocType
    } & Node

    declare type JSDocType = {
        _jsDocTypeBrand: any
    } & TypeNode

    declare type JSDocAllType = {
        _JSDocAllTypeBrand: any
    } & JSDocType

    declare type JSDocUnknownType = {
        _JSDocUnknownTypeBrand: any
    } & JSDocType

    declare type JSDocArrayType = {
        elementType: JSDocType
    } & JSDocType

    declare type JSDocUnionType = {
        types: NodeArray<JSDocType >
    } & JSDocType

    declare type JSDocTupleType = {
        types: NodeArray<JSDocType >
    } & JSDocType

    declare type JSDocNonNullableType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocNullableType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocRecordType = {
        members: NodeArray<JSDocRecordMember >
    } & JSDocType & TypeLiteralNode

    declare type JSDocTypeReference = {
        name: EntityName,
        typeArguments: NodeArray<JSDocType >
    } & JSDocType

    declare type JSDocOptionalType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocFunctionType = {
        parameters: NodeArray<ParameterDeclaration>,
        type: JSDocType
    } & JSDocType & SignatureDeclaration

    declare type JSDocVariadicType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocConstructorType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocThisType = {
        type: JSDocType
    } & JSDocType

    declare type JSDocRecordMember = {
        name: Identifier | LiteralExpression,
        type?: JSDocType
    } & PropertyDeclaration

    declare type JSDocComment = {
        tags: NodeArray<JSDocTag >
    } & Node

    declare type JSDocTag = {
        atToken: Node,
        tagName: Identifier
    } & Node

    declare type JSDocTemplateTag = {
        typeParameters: NodeArray<TypeParameterDeclaration >
    } & JSDocTag

    declare type JSDocReturnTag = {
        typeExpression: JSDocTypeExpression
    } & JSDocTag

    declare type JSDocTypeTag = {
        typeExpression: JSDocTypeExpression
    } & JSDocTag

    declare type JSDocParameterTag = {
        preParameterName?: Identifier,
        typeExpression?: JSDocTypeExpression,
        postParameterName?: Identifier,
        isBracketed: boolean
    } & JSDocTag

    declare type SourceFile = {
        statements: NodeArray<Statement>,
        endOfFileToken: Node,
        fileName: string,
        text: string,
        amdDependencies: {
            path: string,
            name: string
        }[],
        moduleName: string,
        referencedFiles: FileReference[],
        languageVariant: LanguageVariant,

        /**
         * lib.d.ts should have a reference comment like
         * 
          /// <reference no-default-lib="true"/>

        If any other file has this comment, it signals not to include lib.d.ts
        because this containing file is intended to act as a default library.
        */
        hasNoDefaultLib: boolean,
        languageVersion: ScriptTarget
    } & Declaration

    declare interface ScriptReferenceHost {
        getCompilerOptions(): CompilerOptions,
            getSourceFile(fileName: string): SourceFile,
            getCurrentDirectory(): string
    }
    declare type ParseConfigHost = {
        readDirectory(rootDir: string, extension: string, exclude: string[]): string[]
    } & ModuleResolutionHost

    declare interface WriteFileCallback {
        (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void): void
    }
    declare class OperationCanceledException {}
    declare interface CancellationToken {
        isCancellationRequested(): boolean,

            /**
             * 
             * @throws  OperationCanceledException if isCancellationRequested is true 
             */
            throwIfCancellationRequested(): void
    }
    declare type Program = {

        /**
         * Get a list of root file names that were passed to a 'createProgram'
         */
        getRootFileNames(): string[],

        /**
         * Get a list of files in the program
         */
        getSourceFiles(): SourceFile[],

        /**
         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then
         * the JavaScript and declaration files will be produced for all the files in this program.
        If targetSourceFile is specified, then only the JavaScript and declaration for that
        specific file will be generated.

        If writeFile is not specified then the writeFile callback from the compiler host will be
        used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter
        will be invoked when writing the JavaScript and declaration files.
        */
        emit(
            targetSourceFile?: SourceFile,
            writeFile?: WriteFileCallback,
            cancellationToken?: CancellationToken): EmitResult,
        getOptionsDiagnostics(cancellationToken?: CancellationToken): Diagnostic[],
        getGlobalDiagnostics(cancellationToken?: CancellationToken): Diagnostic[],
        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[],
        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[],
        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[],

        /**
         * Gets a type checker that can be used to semantically analyze source fils in the program.
         */
        getTypeChecker(): TypeChecker
    } & ScriptReferenceHost

    declare interface SourceMapSpan {

        /**
         * Line number in the .js file. 
         */
        emittedLine: number,

            /**
             * Column number in the .js file. 
             */
            emittedColumn: number,

            /**
             * Line number in the .ts file. 
             */
            sourceLine: number,

            /**
             * Column number in the .ts file. 
             */
            sourceColumn: number,

            /**
             * Optional name (index into names array) associated with this span. 
             */
            nameIndex?: number,

            /**
             * .ts file (index into sources array) associated with this span 
             */
            sourceIndex: number
    }
    declare interface SourceMapData {
        sourceMapFilePath: string,
            jsSourceMappingURL: string,
            sourceMapFile: string,
            sourceMapSourceRoot: string,
            sourceMapSources: string[],
            sourceMapSourcesContent?: string[],
            inputSourceFileNames: string[],
            sourceMapNames?: string[],
            sourceMapMappings: string,
            sourceMapDecodedMappings: SourceMapSpan[]
    }
    declare interface EmitResult {
        emitSkipped: boolean,
            diagnostics: Diagnostic[]
    }
    declare interface TypeChecker {
        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type,
            getDeclaredTypeOfSymbol(symbol: Symbol): Type,
            getPropertiesOfType(type: Type): Symbol[],
            getPropertyOfType(type: Type, propertyName: string): Symbol,
            getSignaturesOfType(type: Type, kind: SignatureKind): Signature[],
            getIndexTypeOfType(type: Type, kind: IndexKind): Type,
            getBaseTypes(type: InterfaceType): ObjectType[],
            getReturnTypeOfSignature(signature: Signature): Type,
            getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[],
            getSymbolAtLocation(node: Node): Symbol,
            getShorthandAssignmentValueSymbol(location: Node): Symbol,
            getTypeAtLocation(node: Node): Type,
            typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string,
            symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): string,
            getSymbolDisplayBuilder(): SymbolDisplayBuilder,
            getFullyQualifiedName(symbol: Symbol): string,
            getAugmentedPropertiesOfType(type: Type): Symbol[],
            getRootSymbols(symbol: Symbol): Symbol[],
            getContextualType(node: Expression): Type,
            getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[]): Signature,
            getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature,
            isImplementationOfOverload(node: FunctionLikeDeclaration): boolean,
            isUndefinedSymbol(symbol: Symbol): boolean,
            isArgumentsSymbol(symbol: Symbol): boolean,
            getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): number,
            isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName, propertyName: string): boolean,
            getAliasedSymbol(symbol: Symbol): Symbol,
            getExportsOfModule(moduleSymbol: Symbol): Symbol[],
            getJsxElementAttributesType(elementNode: JsxOpeningLikeElement): Type,
            getJsxIntrinsicTagNames(): Symbol[],
            isOptionalParameter(node: ParameterDeclaration): boolean
    }
    declare interface SymbolDisplayBuilder {
        buildTypeDisplay(
                type: Type,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildSymbolDisplay(
                symbol: Symbol,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                meaning?: SymbolFlags,
                flags?: SymbolFormatFlags): void,
            buildSignatureDisplay(
                signatures: Signature,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildParameterDisplay(
                parameter: Symbol,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildTypeParameterDisplay(
                tp: TypeParameter,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildTypeParameterDisplayFromSymbol(
                symbol: Symbol,
                writer: SymbolWriter,
                enclosingDeclaraiton?: Node,
                flags?: TypeFormatFlags): void,
            buildDisplayForParametersAndDelimiters(
                parameters: Symbol[],
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildDisplayForTypeParametersAndDelimiters(
                typeParameters: TypeParameter[],
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void,
            buildReturnTypeDisplay(
                signature: Signature,
                writer: SymbolWriter,
                enclosingDeclaration?: Node,
                flags?: TypeFormatFlags): void
    }
    declare interface SymbolWriter {
        writeKeyword(text: string): void,
            writeOperator(text: string): void,
            writePunctuation(text: string): void,
            writeSpace(text: string): void,
            writeStringLiteral(text: string): void,
            writeParameter(text: string): void,
            writeSymbol(text: string, symbol: Symbol): void,
            writeLine(): void,
            increaseIndent(): void,
            decreaseIndent(): void,
            clear(): void,
            trackSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags): void
    }
    declare interface TypePredicate {
        parameterName: string,
            parameterIndex: number,
            type: Type
    }
    declare interface Symbol {
        flags: SymbolFlags,
            name: string,
            declarations?: Declaration[],
            valueDeclaration?: Declaration,
            members?: SymbolTable,
            exports?: SymbolTable
    }
    declare interface SymbolTable {
        [index: string]: Symbol
    }
    declare interface Type {
        flags: TypeFlags,
            symbol?: Symbol
    }
    declare type StringLiteralType = {
        text: string
    } & Type

    declare type ObjectType = {} & Type

    declare type InterfaceType = {
        typeParameters: TypeParameter[],
        outerTypeParameters: TypeParameter[],
        localTypeParameters: TypeParameter[]
    } & ObjectType

    declare type InterfaceTypeWithDeclaredMembers = {
        declaredProperties: Symbol[],
        declaredCallSignatures: Signature[],
        declaredConstructSignatures: Signature[],
        declaredStringIndexType: Type,
        declaredNumberIndexType: Type
    } & InterfaceType

    declare type TypeReference = {
        target: GenericType,
        typeArguments: Type[]
    } & ObjectType

    declare type GenericType = {} & InterfaceType & TypeReference

    declare type TupleType = {
        elementTypes: Type[],
        baseArrayType: TypeReference
    } & ObjectType

    declare type UnionOrIntersectionType = {
        types: Type[]
    } & Type

    declare type UnionType = {} & UnionOrIntersectionType

    declare type IntersectionType = {} & UnionOrIntersectionType

    declare type TypeParameter = {
        constraint: Type
    } & Type

    declare interface Signature {
        declaration: SignatureDeclaration,
            typeParameters: TypeParameter[],
            parameters: Symbol[],
            typePredicate?: TypePredicate
    }
    declare interface DiagnosticMessage {
        key: string,
            category: DiagnosticCategory,
            code: number
    }

    /**
     * A linked list of formatted diagnostic messages to be used as part of a multiline message.
     * It is built from the bottom up, leaving the head to be the "main" diagnostic.
    While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,
    the difference is that messages are all preformatted in DMC.
    */
    declare interface DiagnosticMessageChain {
        messageText: string,
            category: DiagnosticCategory,
            code: number,
            next?: DiagnosticMessageChain
    }
    declare interface Diagnostic {
        file: SourceFile,
            start: number,
            length: number,
            messageText: string | DiagnosticMessageChain,
            category: DiagnosticCategory,
            code: number
    }
    declare interface CompilerOptions {
        allowNonTsExtensions?: boolean,
            charset?: string,
            declaration?: boolean,
            diagnostics?: boolean,
            emitBOM?: boolean,
            help?: boolean,
            init?: boolean,
            inlineSourceMap?: boolean,
            inlineSources?: boolean,
            jsx?: JsxEmit,
            listFiles?: boolean,
            locale?: string,
            mapRoot?: string,
            module?: ModuleKind,
            newLine?: NewLineKind,
            noEmit?: boolean,
            noEmitHelpers?: boolean,
            noEmitOnError?: boolean,
            noErrorTruncation?: boolean,
            noImplicitAny?: boolean,
            noLib?: boolean,
            noResolve?: boolean,
            out?: string,
            outFile?: string,
            outDir?: string,
            preserveConstEnums?: boolean,
            project?: string,
            removeComments?: boolean,
            rootDir?: string,
            sourceMap?: boolean,
            sourceRoot?: string,
            suppressExcessPropertyErrors?: boolean,
            suppressImplicitAnyIndexErrors?: boolean,
            target?: ScriptTarget,
            version?: boolean,
            watch?: boolean,
            isolatedModules?: boolean,
            experimentalDecorators?: boolean,
            experimentalAsyncFunctions?: boolean,
            emitDecoratorMetadata?: boolean,
            moduleResolution?: ModuleResolutionKind, [option: string]: string | number | boolean
    }
    declare interface LineAndCharacter {
        line: number,
            character: number
    }
    declare interface ParsedCommandLine {
        options: CompilerOptions,
            fileNames: string[],
            errors: Diagnostic[]
    }
    declare interface ModuleResolutionHost {
        fileExists(fileName: string): boolean,
            readFile(fileName: string): string
    }
    declare interface ResolvedModule {
        resolvedFileName: string,
            isExternalLibraryImport?: boolean
    }
    declare interface ResolvedModuleWithFailedLookupLocations {
        resolvedModule: ResolvedModule,
            failedLookupLocations: string[]
    }
    declare type CompilerHost = {
        getSourceFile(
            fileName: string,
            languageVersion: ScriptTarget,
            onError?: (message: string) => void): SourceFile,
        getCancellationToken(): CancellationToken,
        getDefaultLibFileName(options: CompilerOptions): string,
        writeFile: WriteFileCallback,
        getCurrentDirectory(): string,
        getCanonicalFileName(fileName: string): string,
        useCaseSensitiveFileNames(): boolean,
        getNewLine(): string,
        resolveModuleNames(moduleNames: string[], containingFile: string): ResolvedModule[]
    } & ModuleResolutionHost

    declare interface TextSpan {
        start: number,
            length: number
    }
    declare interface TextChangeRange {
        span: TextSpan,
            newLength: number
    }
    declare interface System {
        args: string[],
            newLine: string,
            useCaseSensitiveFileNames: boolean,
            write(s: string): void,
            readFile(path: string, encoding?: string): string,
            writeFile(path: string, data: string, writeByteOrderMark?: boolean): void,
            watchFile(path: string, callback: (path: string) => void): FileWatcher,
            resolvePath(path: string): string,
            fileExists(path: string): boolean,
            directoryExists(path: string): boolean,
            createDirectory(path: string): void,
            getExecutingFilePath(): string,
            getCurrentDirectory(): string,
            readDirectory(path: string, extension?: string, exclude?: string[]): string[],
            getMemoryUsage(): number,
            exit(exitCode?: number): void
    }
    declare interface FileWatcher {
        close(): void
    }
    declare var sys: System;
    declare interface ErrorCallback {
        (message: DiagnosticMessage, length: number): void
    }
    declare interface Scanner {
        getStartPos(): number,
            getToken(): SyntaxKind,
            getTextPos(): number,
            getTokenPos(): number,
            getTokenText(): string,
            getTokenValue(): string,
            hasExtendedUnicodeEscape(): boolean,
            hasPrecedingLineBreak(): boolean,
            isIdentifier(): boolean,
            isReservedWord(): boolean,
            isUnterminated(): boolean,
            reScanGreaterToken(): SyntaxKind,
            reScanSlashToken(): SyntaxKind,
            reScanTemplateToken(): SyntaxKind,
            scanJsxIdentifier(): SyntaxKind,
            reScanJsxToken(): SyntaxKind,
            scanJsxToken(): SyntaxKind,
            scan(): SyntaxKind,
            setText(text: string, start?: number, length?: number): void,
            setOnError(onError: ErrorCallback): void,
            setScriptTarget(scriptTarget: ScriptTarget): void,
            setLanguageVariant(variant: LanguageVariant): void,
            setTextPos(textPos: number): void,
            lookAhead<T>(callback: () => T): T,
            tryScan<T>(callback: () => T): T
    }
    declare function tokenToString(t: SyntaxKind): string
    declare function getPositionOfLineAndCharacter(sourceFile: SourceFile, line: number, character: number): number
    declare function getLineAndCharacterOfPosition(sourceFile: SourceFile, position: number): LineAndCharacter
    declare function isWhiteSpace(ch: number): boolean
    declare function isLineBreak(ch: number): boolean
    declare function couldStartTrivia(text: string, pos: number): boolean
    declare function getLeadingCommentRanges(text: string, pos: number): CommentRange[]
    declare function getTrailingCommentRanges(text: string, pos: number): CommentRange[]

    /**
     * Optionally, get the shebang 
     */
    declare function getShebang(text: string): string
    declare function isIdentifierStart(ch: number, languageVersion: ScriptTarget): boolean
    declare function isIdentifierPart(ch: number, languageVersion: ScriptTarget): boolean
    declare function createScanner(
        languageVersion: ScriptTarget,
        skipTrivia: boolean,
        languageVariant?: LanguageVariant,
        text?: string,
        onError?: ErrorCallback,
        start?: number,
        length?: number): Scanner
    declare function getDefaultLibFileName(options: CompilerOptions): string
    declare function textSpanEnd(span: TextSpan): number
    declare function textSpanIsEmpty(span: TextSpan): boolean
    declare function textSpanContainsPosition(span: TextSpan, position: number): boolean
    declare function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean
    declare function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean
    declare function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan
    declare function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean
    declare function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean
    declare function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean
    declare function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean
    declare function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan
    declare function createTextSpan(start: number, length: number): TextSpan
    declare function createTextSpanFromBounds(start: number, end: number): TextSpan
    declare function textChangeRangeNewSpan(range: TextChangeRange): TextSpan
    declare function textChangeRangeIsUnchanged(range: TextChangeRange): boolean
    declare function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange
    declare var unchangedTextChangeRange: TextChangeRange;

    /**
     * Called to merge all the changes that occurred across several versions of a script snapshot
     * into a single change.  i.e. if a user keeps making successive edits to a script we will
    have a text change from V1 to V2, V2 to V3, ..., Vn.

    This function will then merge those changes into a single change range valid between V1 and
    Vn.
    */
    declare function collapseTextChangeRangesAcrossMultipleVersions(changes: TextChangeRange[]): TextChangeRange
    declare function getTypeParameterOwner(d: Declaration): Declaration
    declare function getNodeConstructor(kind: SyntaxKind): () => Node
    declare function createNode(kind: SyntaxKind): Node
    declare function forEachChild<T>(
        node: Node,
        cbNode: (node: Node) => T,
        cbNodeArray?: (nodes: Node[]) => T): T
    declare function createSourceFile(
        fileName: string,
        sourceText: string,
        languageVersion: ScriptTarget,
        setParentNodes?: boolean): SourceFile
    declare function updateSourceFile(
        sourceFile: SourceFile,
        newText: string,
        textChangeRange: TextChangeRange,
        aggressiveChecks?: boolean): SourceFile
    declare var version: string;
    declare function findConfigFile(searchPath: string): string
    declare function resolveTripleslashReference(moduleName: string, containingFile: string): string
    declare function resolveModuleName(
        moduleName: string,
        containingFile: string,
        compilerOptions: CompilerOptions,
        host: ModuleResolutionHost): ResolvedModuleWithFailedLookupLocations
    declare function nodeModuleNameResolver(
        moduleName: string,
        containingFile: string,
        host: ModuleResolutionHost): ResolvedModuleWithFailedLookupLocations
    declare function classicNameResolver(
        moduleName: string,
        containingFile: string,
        compilerOptions: CompilerOptions,
        host: ModuleResolutionHost): ResolvedModuleWithFailedLookupLocations
    declare function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost
    declare function getPreEmitDiagnostics(
        program: Program,
        sourceFile?: SourceFile,
        cancellationToken?: CancellationToken): Diagnostic[]
    declare function flattenDiagnosticMessageText(messageText: string | DiagnosticMessageChain, newLine: string): string
    declare function createProgram(
        rootNames: string[],
        options: CompilerOptions,
        host?: CompilerHost,
        oldProgram?: Program): Program
    declare function parseCommandLine(commandLine: string[], readFile?: (path: string) => string): ParsedCommandLine

    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    declare function readConfigFile(fileName: string): {
        config?: any,
        error?: Diagnostic
    }

    /**
     * Parse the text of the tsconfig.json file
     * @param fileName The path to the config file
     * @param jsonText The text of the config file
     */
    declare function parseConfigFileText(fileName: string, jsonText: string): {
        config?: any,
        error?: Diagnostic
    }

    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param json The contents of the config file to parse
     * @param basePath A root directory to resolve relative path entries in the config
    file to. e.g. outDir
    */
    declare function parseConfigFile(json: any, host: ParseConfigHost, basePath: string): ParsedCommandLine
    declare var servicesVersion: string;

    /**
     * Represents an immutable snapshot of a script at a specified time.Once acquired, the
     * snapshot is observably immutable. i.e. the same calls with the same parameters will return
    the same values.
    */
    declare interface IScriptSnapshot {

        /**
         * Gets a portion of the script snapshot specified by [start, end). 
         */
        getText(start: number, end: number): string,

            /**
             * Gets the length of this script snapshot. 
             */
            getLength(): number,

            /**
             * Gets the TextChangeRange that describe how the text changed between this text and
             * an older version.  This information is used by the incremental parser to determine
            what sections of the script need to be re-parsed.  'undefined' can be returned if the
            change range cannot be determined.  However, in that case, incremental parsing will
            not happen and the entire document will be re - parsed.
            */
            getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange,

            /**
             * Releases all resources held by this script snapshot 
             */
            dispose(): void
    }

    declare var npm$namespace$ScriptSnapshot: {
        fromString: typeof ScriptSnapshot$fromString,
    }
    declare function ScriptSnapshot$fromString(text: string): IScriptSnapshot
    declare interface PreProcessedFileInfo {
        referencedFiles: FileReference[],
            importedFiles: FileReference[],
            ambientExternalModules: string[],
            isLibFile: boolean
    }
    declare interface HostCancellationToken {
        isCancellationRequested(): boolean
    }
    declare interface LanguageServiceHost {
        getCompilationSettings(): CompilerOptions,
            getNewLine(): string,
            getProjectVersion(): string,
            getScriptFileNames(): string[],
            getScriptVersion(fileName: string): string,
            getScriptSnapshot(fileName: string): IScriptSnapshot,
            getLocalizedDiagnosticMessages(): any,
            getCancellationToken(): HostCancellationToken,
            getCurrentDirectory(): string,
            getDefaultLibFileName(options: CompilerOptions): string,
            log(s: string): void,
            trace(s: string): void,
            error(s: string): void,
            useCaseSensitiveFileNames(): boolean,
            resolveModuleNames(moduleNames: string[], containingFile: string): ResolvedModule[]
    }
    declare interface LanguageService {
        cleanupSemanticCache(): void,
            getSyntacticDiagnostics(fileName: string): Diagnostic[],
            getSemanticDiagnostics(fileName: string): Diagnostic[],
            getCompilerOptionsDiagnostics(): Diagnostic[],

            /**
             * 
             * @deprecated  Use getEncodedSyntacticClassifications instead.
             */
            getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[],

            /**
             * 
             * @deprecated  Use getEncodedSemanticClassifications instead.
             */
            getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[],
            getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications,
            getEncodedSemanticClassifications(fileName: string, span: TextSpan): Classifications,
            getCompletionsAtPosition(fileName: string, position: number): CompletionInfo,
            getCompletionEntryDetails(fileName: string, position: number, entryName: string): CompletionEntryDetails,
            getQuickInfoAtPosition(fileName: string, position: number): QuickInfo,
            getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan,
            getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan,
            getSignatureHelpItems(fileName: string, position: number): SignatureHelpItems,
            getRenameInfo(fileName: string, position: number): RenameInfo,
            findRenameLocations(
                fileName: string,
                position: number,
                findInStrings: boolean,
                findInComments: boolean): RenameLocation[],
            getDefinitionAtPosition(fileName: string, position: number): DefinitionInfo[],
            getTypeDefinitionAtPosition(fileName: string, position: number): DefinitionInfo[],
            getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[],
            findReferences(fileName: string, position: number): ReferencedSymbol[],
            getDocumentHighlights(
                fileName: string,
                position: number,
                filesToSearch: string[]): DocumentHighlights[],

            /**
             * 
             * @deprecated  
             */
            getOccurrencesAtPosition(fileName: string, position: number): ReferenceEntry[],
            getNavigateToItems(searchValue: string, maxResultCount?: number): NavigateToItem[],
            getNavigationBarItems(fileName: string): NavigationBarItem[],
            getOutliningSpans(fileName: string): OutliningSpan[],
            getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[],
            getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[],
            getIndentationAtPosition(fileName: string, position: number, options: EditorOptions): number,
            getFormattingEditsForRange(
                fileName: string,
                start: number,
                end: number,
                options: FormatCodeOptions): TextChange[],
            getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions): TextChange[],
            getFormattingEditsAfterKeystroke(
                fileName: string,
                position: number,
                key: string,
                options: FormatCodeOptions): TextChange[],
            getDocCommentTemplateAtPosition(fileName: string, position: number): TextInsertion,
            getEmitOutput(fileName: string): EmitOutput,
            getProgram(): Program,
            getSourceFile(fileName: string): SourceFile,
            dispose(): void
    }
    declare interface Classifications {
        spans: number[],
            endOfLineState: EndOfLineState
    }
    declare interface ClassifiedSpan {
        textSpan: TextSpan,
            classificationType: string
    }
    declare interface NavigationBarItem {
        text: string,
            kind: string,
            kindModifiers: string,
            spans: TextSpan[],
            childItems: NavigationBarItem[],
            indent: number,
            bolded: boolean,
            grayed: boolean
    }
    declare interface TodoCommentDescriptor {
        text: string,
            priority: number
    }
    declare interface TodoComment {
        descriptor: TodoCommentDescriptor,
            message: string,
            position: number
    }
    declare class TextChange {
        span: TextSpan;
        newText: string
    }
    declare interface TextInsertion {
        newText: string,

            /**
             * The position in newText the caret should point to after the insertion. 
             */
            caretOffset: number
    }
    declare interface RenameLocation {
        textSpan: TextSpan,
            fileName: string
    }
    declare interface ReferenceEntry {
        textSpan: TextSpan,
            fileName: string,
            isWriteAccess: boolean
    }
    declare interface DocumentHighlights {
        fileName: string,
            highlightSpans: HighlightSpan[]
    }
    declare var none: string;

    declare var definition: string;

    declare var reference: string;

    declare var writtenReference: string;
    declare interface HighlightSpan {
        fileName?: string,
            textSpan: TextSpan,
            kind: string
    }
    declare interface NavigateToItem {
        name: string,
            kind: string,
            kindModifiers: string,
            matchKind: string,
            isCaseSensitive: boolean,
            fileName: string,
            textSpan: TextSpan,
            containerName: string,
            containerKind: string
    }
    declare interface EditorOptions {
        IndentSize: number,
            TabSize: number,
            NewLineCharacter: string,
            ConvertTabsToSpaces: boolean
    }
    declare type FormatCodeOptions = {
        InsertSpaceAfterCommaDelimiter: boolean,
        InsertSpaceAfterSemicolonInForStatements: boolean,
        InsertSpaceBeforeAndAfterBinaryOperators: boolean,
        InsertSpaceAfterKeywordsInControlFlowStatements: boolean,
        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean,
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean,
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean,
        PlaceOpenBraceOnNewLineForFunctions: boolean,
        PlaceOpenBraceOnNewLineForControlBlocks: boolean,
        [s: string]: boolean | number | string
    } & EditorOptions

    declare interface DefinitionInfo {
        fileName: string,
            textSpan: TextSpan,
            kind: string,
            name: string,
            containerKind: string,
            containerName: string
    }
    declare interface ReferencedSymbol {
        definition: DefinitionInfo,
            references: ReferenceEntry[]
    }
    declare interface SymbolDisplayPart {
        text: string,
            kind: string
    }
    declare interface QuickInfo {
        kind: string,
            kindModifiers: string,
            textSpan: TextSpan,
            displayParts: SymbolDisplayPart[],
            documentation: SymbolDisplayPart[]
    }
    declare interface RenameInfo {
        canRename: boolean,
            localizedErrorMessage: string,
            displayName: string,
            fullDisplayName: string,
            kind: string,
            kindModifiers: string,
            triggerSpan: TextSpan
    }
    declare interface SignatureHelpParameter {
        name: string,
            documentation: SymbolDisplayPart[],
            displayParts: SymbolDisplayPart[],
            isOptional: boolean
    }

    /**
     * Represents a single signature to show in signature help.
     * The id is used for subsequent calls into the language service to ask questions about the
    signature help item in the context of any documents that have been updated.  i.e. after
    an edit has happened, while signature help is still active, the host can ask important
    questions like 'what parameter is the user currently contained within?'.
    */
    declare interface SignatureHelpItem {
        isVariadic: boolean,
            prefixDisplayParts: SymbolDisplayPart[],
            suffixDisplayParts: SymbolDisplayPart[],
            separatorDisplayParts: SymbolDisplayPart[],
            parameters: SignatureHelpParameter[],
            documentation: SymbolDisplayPart[]
    }

    /**
     * Represents a set of signature help items, and the preferred item that should be selected.
     */
    declare interface SignatureHelpItems {
        items: SignatureHelpItem[],
            applicableSpan: TextSpan,
            selectedItemIndex: number,
            argumentIndex: number,
            argumentCount: number
    }
    declare interface CompletionInfo {
        isMemberCompletion: boolean,
            isNewIdentifierLocation: boolean,
            entries: CompletionEntry[]
    }
    declare interface CompletionEntry {
        name: string,
            kind: string,
            kindModifiers: string,
            sortText: string
    }
    declare interface CompletionEntryDetails {
        name: string,
            kind: string,
            kindModifiers: string,
            displayParts: SymbolDisplayPart[],
            documentation: SymbolDisplayPart[]
    }
    declare interface OutliningSpan {

        /**
         * The span of the document to actually collapse. 
         */
        textSpan: TextSpan,

            /**
             * The span of the document to display when the user hovers over the collapsed span. 
             */
            hintSpan: TextSpan,

            /**
             * The text to display in the editor for the collapsed region. 
             */
            bannerText: string,

            /**
             * Whether or not this region should be automatically collapsed when
             * the 'Collapse to Definitions' command is invoked.
             */
            autoCollapse: boolean
    }
    declare interface EmitOutput {
        outputFiles: OutputFile[],
            emitSkipped: boolean
    }
    declare interface OutputFile {
        name: string,
            writeByteOrderMark: boolean,
            text: string
    }
    declare interface ClassificationResult {
        finalLexState: EndOfLineState,
            entries: ClassificationInfo[]
    }
    declare interface ClassificationInfo {
        length: number,
            classification: TokenClass
    }
    declare interface Classifier {

        /**
         * Gives lexical classifications of tokens on a line without any syntactic context.
         * For instance, a token consisting of the text 'string' can be either an identifier
        named 'string' or the keyword 'string', however, because this classifier is not aware,
        it relies on certain heuristics to give acceptable results. For classifications where
        speed trumps accuracy, this function is preferable; however, for true accuracy, the
        syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
        lexical, syntactic, and semantic classifiers may issue the best user experience.
         * @param text The text of a line to classify.
         * @param lexState The state of the lexical classifier at the end of the previous line.
         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
        If there is no syntactic classifier (syntacticClassifierAbsent=true),
        certain heuristics may be used in its place; however, if there is a
        syntactic classifier (syntacticClassifierAbsent=false), certain
        classifications which may be incorrectly categorized will be given
        back as Identifiers in order to allow the syntactic classifier to
        subsume the classification.
         * @deprecated  Use getLexicalClassifications instead.
        */
        getClassificationsForLine(
                text: string,
                lexState: EndOfLineState,
                syntacticClassifierAbsent: boolean): ClassificationResult,
            getEncodedLexicalClassifications(
                text: string,
                endOfLineState: EndOfLineState,
                syntacticClassifierAbsent: boolean): Classifications
    }

    /**
     * The document registry represents a store of SourceFile objects that can be shared between
     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
    of files in the context.
    SourceFile objects account for most of the memory usage by the language service. Sharing
    the same DocumentRegistry instance between different instances of LanguageService allow
    for more efficient memory utilization since all projects will share at least the library
    file (lib.d.ts).

    A more advanced use of the document registry is to serialize sourceFile objects to disk
    and re-hydrate them when needed.

    To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
    to all subsequent createLanguageService calls.
    */
    declare interface DocumentRegistry {

        /**
         * Request a stored SourceFile with a given fileName and compilationSettings.
         * The first call to acquire will call createLanguageServiceSourceFile to generate
        the SourceFile if was not found in the registry.
         * @param fileName The name of the file requested
         * @param compilationSettings Some compilation settings like target affects the
        shape of a the resulting SourceFile. This allows the DocumentRegistry to store
        multiple copies of the same file for different compilation settings.
         * @parm  scriptSnapshot Text of the file. Only used if the file was not found
        in the registry and a new one was created.
         * @parm  version Current version of the file. Only used if the file was not found
        in the registry and a new one was created.
        */
        acquireDocument(
                fileName: string,
                compilationSettings: CompilerOptions,
                scriptSnapshot: IScriptSnapshot,
                version: string): SourceFile,

            /**
             * Request an updated version of an already existing SourceFile with a given fileName
             * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
            to get an updated SourceFile.
             * @param fileName The name of the file requested
             * @param compilationSettings Some compilation settings like target affects the
            shape of a the resulting SourceFile. This allows the DocumentRegistry to store
            multiple copies of the same file for different compilation settings.
             * @param scriptSnapshot Text of the file.
             * @param version Current version of the file.
            */
            updateDocument(
                fileName: string,
                compilationSettings: CompilerOptions,
                scriptSnapshot: IScriptSnapshot,
                version: string): SourceFile,

            /**
             * Informs the DocumentRegistry that a file is not needed any longer.
             * 
            Note: It is not allowed to call release on a SourceFile that was not acquired from
            this registry originally.
             * @param fileName The name of the file to be released
             * @param compilationSettings The compilation settings used to acquire the file
            */
            releaseDocument(fileName: string, compilationSettings: CompilerOptions): void,
            reportStats(): string
    }
    declare var unknown: string;

    declare var warning: string;

    declare var keyword: string;

    declare var scriptElement: string;

    declare var moduleElement: string;

    declare var classElement: string;

    declare var localClassElement: string;

    declare var interfaceElement: string;

    declare var typeElement: string;

    declare var enumElement: string;

    declare var variableElement: string;

    declare var localVariableElement: string;

    declare var functionElement: string;

    declare var localFunctionElement: string;

    declare var memberFunctionElement: string;

    declare var memberGetAccessorElement: string;

    declare var memberSetAccessorElement: string;

    declare var memberVariableElement: string;

    declare var constructorImplementationElement: string;

    declare var callSignatureElement: string;

    declare var indexSignatureElement: string;

    declare var constructSignatureElement: string;

    declare var parameterElement: string;

    declare var typeParameterElement: string;

    declare var primitiveType: string;

    declare var label: string;

    declare var alias: string;

    declare var constElement: string;

    declare var letElement: string;
    declare var none: string;

    declare var publicMemberModifier: string;

    declare var privateMemberModifier: string;

    declare var protectedMemberModifier: string;

    declare var exportedModifier: string;

    declare var ambientModifier: string;

    declare var staticModifier: string;

    declare var abstractModifier: string;
    declare class ClassificationTypeNames {
        comment: string;
        identifier: string;
        keyword: string;
        numericLiteral: string;
        operator: string;
        stringLiteral: string;
        whiteSpace: string;
        text: string;
        punctuation: string;
        className: string;
        enumName: string;
        interfaceName: string;
        moduleName: string;
        typeParameterName: string;
        typeAliasName: string;
        parameterName: string;
        docCommentTagName: string
    }
    declare type DisplayPartsSymbolWriter = {
        displayParts(): SymbolDisplayPart[]
    } & SymbolWriter

    declare function displayPartsToString(displayParts: SymbolDisplayPart[]): string
    declare function getDefaultCompilerOptions(): CompilerOptions
    declare interface TranspileOptions {
        compilerOptions?: CompilerOptions,
            fileName?: string,
            reportDiagnostics?: boolean,
            moduleName?: string,
            renamedDependencies?: Map<string >
    }
    declare interface TranspileOutput {
        outputText: string,
            diagnostics?: Diagnostic[],
            sourceMapText?: string
    }
    declare function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput
    declare function transpile(
        input: string,
        compilerOptions?: CompilerOptions,
        fileName?: string,
        diagnostics?: Diagnostic[],
        moduleName?: string): string
    declare function createLanguageServiceSourceFile(
        fileName: string,
        scriptSnapshot: IScriptSnapshot,
        scriptTarget: ScriptTarget,
        version: string,
        setNodeParents: boolean): SourceFile
    declare var disableIncrementalParsing: boolean;
    declare function updateLanguageServiceSourceFile(
        sourceFile: SourceFile,
        scriptSnapshot: IScriptSnapshot,
        version: string,
        textChangeRange: TextChangeRange,
        aggressiveChecks?: boolean): SourceFile
    declare function createGetCanonicalFileName(useCaseSensitivefileNames: boolean): (fileName: string) => string
    declare function createDocumentRegistry(useCaseSensitiveFileNames?: boolean): DocumentRegistry
    declare function preProcessFile(sourceText: string, readImportFiles?: boolean): PreProcessedFileInfo
    declare function createLanguageService(
        host: LanguageServiceHost,
        documentRegistry?: DocumentRegistry): LanguageService
    declare function createClassifier(): Classifier

    /**
     * Get the path of the default library files (lib.d.ts) as distributed with the typescript
     * node package.
    The functionality is not supported if the ts module is consumed outside of a node module.
    */
    declare function getDefaultLibFilePath(options: CompilerOptions): string
}