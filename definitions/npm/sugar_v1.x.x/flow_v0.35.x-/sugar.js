

declare module 'sugar' {
		declare interface String {
		add(str: string, index?: number): string,
		insert(str: string, index?: number): string,
		assign(...objs: any[]): string,
		at(index: number, loop?: boolean): string,
		at(...indicies: number[]): string[],
		camelize(first?: boolean): string,
		capitalize(all?: boolean): string,
		chars(fn?: (c: string) => void): string[],
		codes(fn?: (c: string) => void): number[],
		compact(): string,
		dasherize(): string,
		decodeBase64(): string,
		each(search: string, fn?: (m: string) => void): string[],
		each(search: RegExp, fn?: (m: string) => void): string[],
		each(fn?: (m: string) => void): string[],
		encodeBase64(): string,
		endsWith(find: string, pos?: number, case_?: boolean): boolean,
		endsWith(find: string, case_?: boolean): boolean,
		endsWith(find: RegExp, pos?: number, case_?: boolean): boolean,
		endsWith(find: RegExp, case_?: boolean): boolean,
		escapeHTML(): string,
		escapeRegExp(): string,
		escapeURL(param?: boolean): string,
		first(n?: number): string,
		from(index?: number): string,
		hankaku(mode?: string): string,
		hankaku(...modes: string[]): string,
		has(find: string): boolean,
		has(find: RegExp): boolean,
		hasArabic(): boolean,
		hasCyrillic(): boolean,
		hasGreek(): boolean,
		hasHangul(): boolean,
		hasHan(): boolean,
		hasKanji(): boolean,
		hasHebrew(): boolean,
		hasHiragana(): boolean,
		hasKana(): boolean,
		hasKatakana(): boolean,
		hasLatin(): boolean,
		hasThai(): boolean,
		hasDevanagari(): boolean,
		hiragana(all?: boolean): string,
		humanize(): string,
		isBlank(): boolean,
		isArabic(): boolean,
		isCyrillic(): boolean,
		isGreek(): boolean,
		isHangul(): boolean,
		isHan(): boolean,
		isKanji(): boolean,
		isHebrew(): boolean,
		isHiragana(): boolean,
		isKana(): boolean,
		isKatakana(): boolean,
		isLatin(): boolean,
		isThai(): boolean,
		isDevanagari(): boolean,
		katakana(): string,
		last(n?: number): string,
		lines(fn?: (l: string) => void): string[],
		normalize(): string,
		pad(padding: string, num?: number): string,
		padLeft(padding: string, num?: number): string,
		padRight(padding: string, num?: number): string,
		paragraphs(fn?: (p: string) => void): string[],
		parameterize(): string,
		pluralize(): string,
		remove(find: string): string,
		remove(find: RegExp): string,
		removeTags(...tags: string[]): string,
		repeat(num?: number): string,
		reverse(): string,
		shift(num: number): string[],
		singularize(): string,
		spacify(): string,
		startsWith(find: string, pos?: number, case_?: boolean): boolean,
		startsWith(find: string, case_?: boolean): boolean,
		startsWith(find: RegExp, pos?: number, case_?: boolean): boolean,
		startsWith(find: RegExp, case_?: boolean): boolean,
		stripTags(...tags: string[]): string,
		titleize(): string,
		to(index?: number): string,
		toNumber(base?: number): number,
		trimLeft(): string,
		trimRight(): string,
		truncate(length: number, split?: boolean, from?: string, ellipsis?: string): string,
		underscore(): string,
		unescapeHTML(): string,
		unescapeURL(partial?: boolean): string,
		words(fn?: (word: string) => void): string[],
		zenkaku(...modes: string[]): string
	}

	declare interface NumberConstructor {
		random(n1?: number, n2?: number): number
	}

	declare interface Number {
		abbr(precision?: number): string,
		bytes(precision?: number, limit?: number): string,
		bytes(precision?: number, limit?: boolean): string,
		ceil(precision?: number): number,
		chr(): string,
		downto(num: number, fn?: (n: number) => void, step?: number): number[],
		duration(locale?: string): string,
		floor(precision?: number): number,
		format(place?: number, thousands?: string, decimal?: string): string,
		hex(pad?: number): string,
		isEven(): boolean,
		isInteger(): boolean,
		isMultipleOf(num: number): boolean,
		isOdd(): boolean,
		log(base?: number): number,
		abs(): number,
		sin(): number,
		asin(): number,
		cos(): number,
		acos(): number,
		tan(): number,
		atan(): number,
		sqrt(): number,
		exp(): number,
		pow(num: number): number,
		metric(precision?: number, limit?: number): string,
		metric(precision?: number, limit?: boolean): string,
		ordinalize(): string,
		pad(place?: number, sign?: boolean, base?: number): string,
		round(precision?: number): number,
		times(fn: (i: number) => void): number,
		toNumber(): number,
		millisecond(): number,
		milliseconds(): number,
		second(): number,
		seconds(): number,
		minute(): number,
		minutes(): number,
		hour(): number,
		hours(): number,
		day(): number,
		days(): number,
		week(): number,
		weeks(): number,
		month(): number,
		months(): number,
		year(): number,
		years(): number,
		millisecondAfter(d: string, locale?: string): Date,
		millisecondAfter(d: Date, locale?: string): Date,
		millisecondsAfter(d: string, locale?: string): Date,
		millisecondsAfter(d: Date, locale?: string): Date,
		secondAfter(d: string, locale?: string): Date,
		secondAfter(d: Date, locale?: string): Date,
		secondsAfter(d: string, locale?: string): Date,
		secondsAfter(d: Date, locale?: string): Date,
		minuteAfter(d: string, locale?: string): Date,
		minuteAfter(d: Date, locale?: string): Date,
		minutesAfter(d: string, locale?: string): Date,
		minutesAfter(d: Date, locale?: string): Date,
		hourAfter(d: string, locale?: string): Date,
		hourAfter(d: Date, locale?: string): Date,
		hoursAfter(d: string, locale?: string): Date,
		hoursAfter(d: Date, locale?: string): Date,
		dayAfter(d: string, locale?: string): Date,
		dayAfter(d: Date, locale?: string): Date,
		daysAfter(d: string, locale?: string): Date,
		daysAfter(d: Date, locale?: string): Date,
		weekAfter(d: string, locale?: string): Date,
		weekAfter(d: Date, locale?: string): Date,
		weeksAfter(d: string, locale?: string): Date,
		weeksAfter(d: Date, locale?: string): Date,
		monthAfter(d: string, locale?: string): Date,
		monthAfter(d: Date, locale?: string): Date,
		monthsAfter(d: string, locale?: string): Date,
		yearAfter(d: string, locale?: string): Date,
		yearAfter(d: Date, locale?: string): Date,
		yearsAfter(d: string, locale?: string): Date,
		yearsAfter(d: Date, locale?: string): Date,
		millisecondAgo(): Date,
		millisecondsAgo(): Date,
		secondAgo(): Date,
		secondsAgo(): Date,
		minuteAgo(): Date,
		minutesAgo(): Date,
		hourAgo(): Date,
		hoursAgo(): Date,
		dayAgo(): Date,
		daysAgo(): Date,
		weekAgo(): Date,
		weeksAgo(): Date,
		monthAgo(): Date,
		monthsAgo(): Date,
		yearAgo(): Date,
		yearsAgo(): Date,
		millisecondBefore(d: string, locale?: string): Date,
		millisecondBefore(d: Date, locale?: string): Date,
		millisecondsBefore(d: string, locale?: string): Date,
		millisecondsBefore(d: Date, locale?: string): Date,
		secondBefore(d: string, locale?: string): Date,
		secondBefore(d: Date, locale?: string): Date,
		secondsBefore(d: string, locale?: string): Date,
		secondsBefore(d: Date, locale?: string): Date,
		minuteBefore(d: string, locale?: string): Date,
		minuteBefore(d: Date, locale?: string): Date,
		minutesBefore(d: string, locale?: string): Date,
		minutesBefore(d: Date, locale?: string): Date,
		hourBefore(d: string, locale?: string): Date,
		hourBefore(d: Date, locale?: string): Date,
		hoursBefore(d: string, locale?: string): Date,
		hoursBefore(d: Date, locale?: string): Date,
		dayBefore(d: string, locale?: string): Date,
		dayBefore(d: Date, locale?: string): Date,
		daysBefore(d: string, locale?: string): Date,
		daysBefore(d: Date, locale?: string): Date,
		weekBefore(d: string, locale?: string): Date,
		weekBefore(d: Date, locale?: string): Date,
		weeksBefore(d: string, locale?: string): Date,
		weeksBefore(d: Date, locale?: string): Date,
		monthBefore(d: string, locale?: string): Date,
		monthBefore(d: Date, locale?: string): Date,
		monthsBefore(d: string, locale?: string): Date,
		monthsBefore(d: Date, locale?: string): Date,
		yearBefore(d: string, locale?: string): Date,
		yearBefore(d: Date, locale?: string): Date,
		yearsBefore(d: string, locale?: string): Date,
		yearsBefore(d: Date, locale?: string): Date,
		millisecondFromNow(): Date,
		millisecondsFromNow(): Date,
		secondFromNow(): Date,
		secondsFromNow(): Date,
		minuteFromNow(): Date,
		minutesFromNow(): Date,
		hourFromNow(): Date,
		hoursFromNow(): Date,
		dayFromNow(): Date,
		daysFromNow(): Date,
		weekFromNow(): Date,
		weeksFromNow(): Date,
		monthFromNow(): Date,
		monthsFromNow(): Date,
		yearFromNow(): Date,
		yearsFromNow(): Date,
		upto(num: number, fn?: Function, step?: number): number[]
	}

	declare interface ArrayConstructor {
		create<T>(...args: T[]): T[],
		isArray(obj: any): boolean
	}

	declare interface Array<T> {
		add(el: T, index?: number): T[],
		add(el: T[], index?: number): T[],
		insert(el: T, index?: number): T[],
		insert(el: T[], index?: number): T[],
		at(index: number, loop?: boolean): T,
		at(start: number, stop: number): T[],
		average(map?: (e: T) => number): number,
		clone(): T[],
		compact(all?: boolean): T[],
		count(f: T): number,
		each(
		fn: (element: T, index?: number, array?: T[]) => any, index?: number, loop?: boolean
	): T[],
		every(f: T, scope?: any): boolean,
		all(f: T, scope?: any): boolean,
		all(f: (element: T, index: number, array: T[]) => boolean, scope?: any): boolean,
		exclude(...f: T[]): T[],
		exclude(f: (element: T, index: number, array: T[]) => boolean): T[],
		filter(f: T, scope?: any): T[],
		find(f: T, index?: number, loop?: boolean): T,
		find(
		f: (element: T, index: number, array: T[]) => boolean, index?: number, loop?: boolean
	): T,
		findAll(f: T, index?: number, loop?: boolean): T[],
		findAll(
		f: (element: T, index: number, array: T[]) => boolean, index?: number, loop?: boolean
	): T[],
		findIndex(f: T, startIndex?: number, loop?: boolean): number,
		findIndex(
		f: (element: T, index: number, array: T[]) => boolean, startIndex?: number, loop?: boolean
	): number,
		first(): T,
		first(num: number): T[],
		flatten(limit?: number): T[],
		from(index: number): T[],
		groupBy<U>(
		map: string, fn?: (key: string, items: T[]) => void
	): {
		[key: string]: T
	},
		groupBy<U>(
		map: (element: T) => U, fn?: (key: string, items: T[]) => void
	): {
		[key: string]: T[]
	},
		include(element: T, index?: number): T[],
		include(elements: T[], index?: number): T[],
		intersect(...args: T[]): T[],
		isEmpty(): boolean,
		last(): T,
		last(num: number): T[],
		lastIndexOf(search: any, fromIndex?: number): number,
		least(map: string): T[],
		least<U>(map: (n: T) => U): T[],
		map<U>(map: string, scope?: any): U[],
		map<U>(map: (n: T) => U, scope?: any): U[],
		max(map?: string): T,
		max(map: string, all: boolean): T[],
		max<U>(map: (n: T) => U): T,
		max<U>(map: (n: T) => U, all: boolean): T[],
		min(map?: string): T,
		min(map: string, all: boolean): T[],
		min<U>(map: (n: T) => U): T,
		min<U>(map: (n: T) => U, all: boolean): T[],
		most(map?: string): T[],
		most<U>(map: (n: T) => U): T[],
		none(f: T): boolean,
		none(f: (n: T) => boolean): boolean,
		randomize(): T[],
		reduce(fn: (a: T, b: T) => T, init: T): T,
		reduceRight(fn: (a: T, b: T) => T, init: T): T,
		remove(...args: T[]): T[],
		remove(fn: (n: T) => boolean): T[],
		removeAt(start: number, end?: number): T[],
		sample(): T,
		sample(num: number): T[],
		some(f: T, scope?: any): boolean,
		some(f: (n: T) => boolean, scope?: any): boolean,
		sortBy(map: string, desc?: boolean): T[],
		sortBy<U>(fn: (n: T) => U, desc?: boolean): T[],
		subtract(...args: T[]): T[],
		subtract(args: T[]): T[],
		sum(map: string): number,
		sum(): number,
		sum(map: (n: T) => number): number,
		to(index: number): any[],
		union(array: T[]): T[],
		union(...args: T[]): T[],
		unique(map?: string): T[],
		unique<U>(fn: (obj: T) => U): T[]
	}

	declare interface ObjectConstructor {
		extended(obj?: any): any,
		fromQueryString<T>(str: string, deep?: boolean): T,
		isArray(obj: any): boolean,
		isObject(obj: any): boolean,
		isBoolean(obj: any): boolean,
		isDate(obj: any): boolean,
		isFunction(obj: any): boolean,
		isNaN(obj: any): boolean,
		isNumber(obj: any): boolean,
		isString(obj: any): boolean,
		isRegExp(obj: any): boolean,
		toQueryString(obj: any, namespace?: string): string,
		clone<T>(obj?: T, deep?: boolean): T,
		map<T, U>(obj: T, map: string): U,
		map<T, U>(obj: T, map: (key: string, value: any) => any): U,
		each(obj: any, map: (key: string, value: any) => void): void,
		any(obj: any, map: string): boolean,
		any(obj: any, map: (key: string, value: any) => boolean): boolean,
		all(obj: any, map: string): boolean,
		all(obj: any, map: (key: string, value: any) => boolean): boolean,
		none(obj: any, map: string): boolean,
		none(obj: any, map: (key: string, value: any) => boolean): boolean,
		count(obj: any, map: string): number,
		count(obj: any, map: (key: string, value: any) => boolean): number,
		find(obj: any, map: string): any,
		find(obj: any, map: (key: string, value: any) => boolean): any,
		findAll(obj: any, map: string): any[],
		findAll(obj: any, map: (key: string, value: any) => boolean): any[],
		reduce(obj: any, map: string, init?: any): any,
		reduce(obj: any, map: (key: string, value: any) => any, init?: any): any,
		isEmpty(obj: any): boolean,
		sum(obj: any, map: string): number,
		sum(obj: any, map: (key: string, value: any) => number): number,
		average(obj: any, map: string): number,
		average(obj: any, map: (key: string, value: any) => number): number,
		min(obj: any, map: string): any,
		min(obj: any, map: (key: string, value: any) => any): any,
		max(obj: any, map: string): any,
		max(obj: any, map: (key: string, value: any) => any): any,
		least(obj: any, map: string): any,
		least(obj: any, map: (key: string, value: any) => any): any,
		most(obj: any, map: string): any,
		most(obj: any, map: (key: string, value: any) => any): any,
		equal(a: any, b: any): boolean,
		has(obj: any, key: string): boolean,
		keys(obj: any, fn?: (key: string, value: any) => void): string[],
		merge(target: any, source: any, deep?: boolean, resolve?: boolean): any,
		merge(
		target: any, source: any, deep?: boolean, resolve?: (key: string, targetVal: any, sourceVal: any) => any
	): any,
		reject(obj: any, ...find: any[]): any,
		select(obj: any, ...find: any[]): any,
		size(obj: Object): number,
		tap(obj: any, fn: string): any,
		tap(obj: any, fn: (...args: any[]) => any): any,
		values(obj: any, fn?: (value: any) => any): any[],
		watch(
		obj: any, prop: string, fn: (prop?: string, oldVal?: any, newVal?: any) => any
	): void
	}

	declare interface Object {
		extended(obj?: any): Object,
		isArray(): boolean,
		isObject(): boolean,
		isBoolean(): boolean,
		isDate(): boolean,
		isFunction(): boolean,
		isNaN(): boolean,
		isNumber(): boolean,
		isString(): boolean,
		isRegExp(): boolean,
		toQueryString(namespace?: string): string,
		clone(deep?: boolean): any,
		map<U>(map: string): U,
		map<U>(map: (key: string, value: any) => any): U,
		any(map: string): boolean,
		any(map: (key: string, value: any) => boolean): boolean,
		all(map: string): boolean,
		all(map: (key: string, value: any) => boolean): boolean,
		none(map: string): boolean,
		none(map: (key: string, value: any) => boolean): boolean,
		count(map: string): number,
		count(map: (key: string, value: any) => boolean): number,
		find(map: string): any,
		find(map: (key: string, value: any) => boolean): any,
		findAll(map: string): any[],
		findAll(map: (key: string, value: any) => boolean): any[],
		reduce(map: string, init?: any): any,
		reduce(map: (key: string, value: any) => any, init?: any): any,
		isEmpty(): boolean,
		sum(map: string): number,
		sum(map: (key: string, value: any) => number): number,
		average(map: string): number,
		average(map: (key: string, value: any) => number): number,
		min(map: string): any,
		min(map: (key: string, value: any) => any): any,
		max(map: string): any,
		max(map: (key: string, value: any) => any): any,
		least(map: string): any,
		least(map: (key: string, value: any) => any): any,
		most(map: string): any,
		most(map: (key: string, value: any) => any): any,
		equal(b: any): boolean,
		has(key: string): boolean,
		keys(fn?: (key: string, value: any) => void): string[],
		merge(source: any, deep?: boolean, resolve?: boolean): any,
		merge(
		source: any, deep?: boolean, resolve?: (key: string, targetVal: any, sourceVal: any) => any
	): any,
		reject(...find: any[]): any,
		select(...find: any[]): any,
		size(): number,
		tap(fn: string): any,
		tap(fn: (...args: any[]) => any): any,
		values(fn?: (value: any) => any): any[],
		watch(prop: string, fn: (prop?: string, oldVal?: any, newVal?: any) => any): void
	}

	declare interface Function {
		after(num?: number): Function,
		bind(scope?: any, ...args: any[]): Function,
		cancel(): Function,
		debounce(ms: number): Function,
		delay(ms?: number, ...args: any[]): Function,
		fill(...args: any[]): Function,
		lazy(ms?: number, limit?: number): Function,
		once(): Function,
		throttle(ms: number): Function
	}

	declare interface RegExpConstructor {
		escape(str: string): string
	}

	declare interface RegExp {
		addFlag(flag: string): RegExp,
		getFlags(): string,
		removeFlag(flag: string): RegExp,
		setFlags(flags: string): RegExp
	}

	declare interface Locale {
		plural: boolean,
		months: string,
		weekdays: string,
		units: string,
		numbers: string,
		tokens: string[],
		short: string,
		long: string,
		full: string,
		past: string,
		future: string,
		duration: string,
		timeMarker: string,
		ampm: string,
		modifiers: {
		name: string,
		src: string,
		value: number
	}[],
		dateParse: string[],
		timeParse: string[]
	}

	declare interface DateConstructor {
		addLocale(code: string, set: Locale): Locale,
		create(locale?: string): Date,
		create(d: string, locale?: string): Date,
		create(year: number, month: number, day: number, locale?: string): Date,
		future(d: string, locale?: string): Date,
		getLocale(code?: string): Locale,
		now(): number,
		past(d: string, local?: string): Date,
		range(start: Date, end: Date): DateRange,
		setLocale(code: string): Locale
	}

	declare interface DateFields {
		year?: number,
		month?: number,
		day?: number
	}

	declare interface Date {
		addMilliseconds(num: number, reset?: boolean): Date,
		addSeconds(num: number, reset?: boolean): Date,
		addMinutes(num: number, reset?: boolean): Date,
		addHours(num: number, reset?: boolean): Date,
		addDays(num: number, reset?: boolean): Date,
		addWeeks(num: number, reset?: boolean): Date,
		addMonths(num: number, reset?: boolean): Date,
		addYears(num: number, reset?: boolean): Date,
		advance(set: string, reset?: boolean): Date,
		advance(year: number, month: number, day: number, reset?: boolean): Date,
		advance(milliseconds: number, reset?: boolean): Date,
		advance(set: DateFields, reset?: boolean): Date,
		beginningOfDay(): Date,
		beginningOfWeek(): Date,
		beginningOfMonth(): Date,
		beginningOfYear(): Date,
		clone(): Date,
		daysInMonth(): number,
		endOfDay(): Date,
		endOfWeek(): Date,
		endOfMonth(): Date,
		endOfYear(): Date,
		format(format: string, locale?: string): string,
		short(locale?: string): string,
		long(locale?: string): string,
		full(locale?: string): string,
		getUTCOffset(iso?: boolean): string,
		getISOWeek(): number,
		getWeekday(): number,
		getUTCWeekday(): number,
		is(d: string, margin?: number): boolean,
		is(milliseconds: number, margin?: number): boolean,
		is(d: Date, margin?: number): boolean,
		isAfter(d: string, margin?: number): boolean,
		isAfter(milliseconds: number, margin?: number): boolean,
		isAfter(d: Date, margin?: number): boolean,
		isBefore(d: string, margin?: number): boolean,
		isBefore(milliseconds: number, margin?: number): boolean,
		isBefore(d: Date, margin?: number): boolean,
		isBefore(start: string, end: string, margin?: number): boolean,
		isBefore(start: number, end: string, margin?: number): boolean,
		isBefore(start: Date, end: Date, margin?: number): boolean,
		isToday(): boolean,
		isYesterday(): boolean,
		isTomorrow(): boolean,
		isWeekday(): boolean,
		isWeekend(): boolean,
		isSunday(): boolean,
		isMonday(): boolean,
		isTuesday(): boolean,
		isWednesday(): boolean,
		isThursday(): boolean,
		isFriday(): boolean,
		isSaturday(): boolean,
		isFuture(): boolean,
		isLastWeek(): boolean,
		isLastMonth(): boolean,
		isLastYear(): boolean,
		isLeapYear(): boolean,
		isNextWeek(): boolean,
		isNextMonth(): boolean,
		isNextYear(): boolean,
		isPast(): boolean,
		isThisWeek(): boolean,
		isThisMonth(): boolean,
		isThisYear(): boolean,
		isUTC(): boolean,
		isValid(): boolean,
		iso(): string,
		relative(locale: string): string,
		relative(
		fn?: (value: number, unit: string, ms: number, loc: Locale) => string, locale?: string
	): string,
		reset(unit?: string): Date,
		rewind(ms: number, reset?: boolean): Date,
		rewind(year: number, month: number, day: number, reset?: boolean): Date,
		rewind(d: DateFields, reset?: boolean): Date,
		set(ms: number): Date,
		set(year: number, month: number, day: number): Date,
		set(d: DateFields, reset?: boolean): Date,
		setISOWeek(week: number): void,
		setWeekday(day: number): void,
		toJSON(): string,
		millisecondsAgo(): number,
		secondsAgo(): number,
		minutesAgo(): number,
		hoursAgo(): number,
		daysAgo(): number,
		weeksAgo(): number,
		monthsAgo(): number,
		yearsAgo(): number,
		millisecondsFromNow(): number,
		secondsFromNow(): number,
		minutesFromNow(): number,
		hoursFromNow(): number,
		daysFromNow(): number,
		weeksFromNow(): number,
		monthsFromNow(): number,
		yearsFromNow(): number,
		millisecondsSince(date?: Date, locale?: string): number,
		millisecondsSince(date: string, locale?: string): number,
		secondsSince(date?: Date, locale?: string): number,
		secondsSince(date: string, locale?: string): number,
		minutesSince(date?: Date, locale?: string): number,
		minutesSince(date: string, locale?: string): number,
		hoursSince(date?: Date, locale?: string): number,
		hoursSince(date: string, locale?: string): number,
		daysSince(date?: Date, locale?: string): number,
		daysSince(date: string, locale?: string): number,
		weeksSince(date?: Date, locale?: string): number,
		weeksSince(date: string, locale?: string): number,
		monthsSince(date?: Date, locale?: string): number,
		monthsSince(date: string, locale?: string): number,
		yearsSince(date?: Date, locale?: string): number,
		yearsSince(date: string, locale?: string): number,
		millisecondsUntil(date?: Date, locale?: string): number,
		millisecondsUntil(date: string, locale?: string): number,
		secondsUntil(date?: Date, locale?: string): number,
		secondsUntil(date: string, locale?: string): number,
		minutesUntil(date?: Date, locale?: string): number,
		minutesUntil(date: string, locale?: string): number,
		hoursUntil(date?: Date, locale?: string): number,
		hoursUntil(date: string, locale?: string): number,
		daysUntil(date?: Date, locale?: string): number,
		daysUntil(date: string, locale?: string): number,
		weeksUntil(date?: Date, locale?: string): number,
		weeksUntil(date: string, locale?: string): number,
		monthsUntil(date?: Date, locale?: string): number,
		monthsUntil(date: string, locale?: string): number,
		yearsUntil(date?: Date, locale?: string): number,
		yearsUntil(date: string, locale?: string): number,
		utc(on?: boolean): Date
	}

	declare interface DateRange {
		start: Date,
		end: Date,
		clamp(d: Date): Date,
		contains(d: Date): boolean,
		contains(d: DateRange): boolean,
		every(ms: number, fn?: (d: Date) => void): Date[],
		every(increment: string, fn?: (d: Date) => void): Date[],
		intersect(range: DateRange): DateRange,
		isValid(): boolean,
		span(): number,
		toString(): string,
		union(range: DateRange): DateRange
	}

			
}