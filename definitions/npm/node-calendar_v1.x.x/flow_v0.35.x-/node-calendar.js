// @flow
/**
 * Flowtype definitions for node-calendar
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare type IWeekRow<T>= {
    [dayIndex: number]: T
} & Array
declare type IMonthGrid<T>= {
    [weekRowIndex: number]: IWeekRow<T >
} & Array
declare type IMonthRow<T>= {
    [monthColumnIndex: number]: IMonthGrid<T >
} & Array
declare type IYearGrid<T>= {
    [monthRowIndex: number]: IMonthRow<T >
} & Array
declare module 'node-calendar' {
    declare     export var MONDAY: number;
    declare     export var TUESDAY: number;
    declare     export var WEDNESDAY: number;
    declare     export var THURSDAY: number;
    declare     export var FRIDAY: number;
    declare     export var SATURDAY: number;
    declare     export var SUNDAY: number;
    declare     export var JANUARY: number;
    declare     export var FEBRUARY: number;
    declare     export var MARCH: number;
    declare     export var APRIL: number;
    declare     export var MAY: number;
    declare     export var JUNE: number;
    declare     export var JULY: number;
    declare     export var AUGUST: number;
    declare     export var SEPTEMBER: number;
    declare     export var OCTOBER: number;
    declare     export var NOVEMBER: number;
    declare     export var DECEMBER: number;
    declare     export var day_name: string[];
    declare     export var day_abbr: string[];
    declare     export var month_name: string[];
    declare     export var month_abbr: string[];

    /**
     * Base calendar class. This class doesn't do any formatting. It simply provides
     * data to subclasses.
     */
    declare     export class Calendar {

        /**
         * 
         * @param  Numerical day of the week the calendar weeks should start.
        (0=MON, 1=TUE, ...) Default: 0
        */
        constructor(firstweekday?: number): this;

        /**
         * Numerical day of the week the calendar weeks should start.
         * (0=MON, 1=TUE, ...)
         * @method  getfirstweekday
         */
        getfirstweekday(): number;

        /**
         * Numerical day of the week the calendar weeks should start.
         * (0=MON, 1=TUE, ...)
         * @param  Numerical day of the week the calendar weeks should start.
        (0=MON, 1=TUE, ...) Default: 0
        */
        setfirstweekday(firstweekday: number): void;

        /**
         * One week of weekday numbers starting with the configured first one.
         */
        iterweekdays(): number[];

        /**
         * Dates for one month. The array will contain Date values and will always
         * iterate through complete weeks, so it will yield dates outside the
        specified month.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
        */
        itermonthdates(year: number, month: number): Date[];

        /**
         * Like itermonthdates(), but will yield day numbers. For days outside
         * the specified month the day number is 0.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
         */
        itermonthdays(year: number, month: number): number[];

        /**
         * Like itermonthdates(), but will yield [day number, weekday number]
         * arrays. For days outside the specified month the day number is 0.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
         */
        itermonthdays2(year: number, month: number): [number, number][];

        /**
         * A matrix (array of array) representing a month's calendar.
         * Each row represents a week; week entries are Date values.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
         */
        monthdatescalendar(year: number, month: number): IMonthGrid<Date>;

        /**
         * A matrix representing a month's calendar. Each row represents a week;
         * days outside this month are zero.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
         */
        monthdayscalendar(year: number, month: number): IMonthGrid<number>;

        /**
         * Return a matrix representing a month's calendar. Each row represents
         * a week; week entries are [day number, weekday number] arrays. Day numbers
        outside this month are zero.
         * @param  Year for which the calendar should be generated.
         * @param  Month for which the calendar should be generated.
        */
        monthdays2calendar(year: number, month: number): IMonthGrid<[number, number]>;

        /**
         * The specified year ready for formatting. The return value is an array
         * of month rows. Each month row contains up to width months. Each month
        contains between 4 and 6 weeks and each week contains 1-7 days. Days
        are Date objects.
         * @param  Year for which the calendar should be generated.
         * @param  The number of months to include in each row. Default: 3
        */
        yeardatescalendar(year: number, width?: number): IYearGrid<Date>;

        /**
         * the specified year ready for formatting (similar to yeardatescalendar()).
         * Entries in the week arrays are day numbers. Day numbers outside this
        month are zero.
         * @param  Year for which the calendar should be generated
         * @param  The number of months to include in each row. Default: 3
        */
        yeardayscalendar(year: number, width?: number): IYearGrid<number>;

        /**
         * The specified year ready for formatting (similar to yeardatescalendar()).
         * Entries in the week arrays are [day number, weekday number] arrays.
        Day numbers outside this month are zero.
         * @param  Year for which the calendar should be generated
         * @param  The number of months to include in each row. Default: 3
        */
        yeardays2calendar(year: number, width?: number): IYearGrid<[number, number] >
    }

    /**
     * 
     * @param  Year to test.
     * @return  *  true for leap years, false for non-leap years.
     */
    declare     export function isleap(year: number): boolean

    /**
     * 
     * @param  Beginning year in the range to test.
     * @param  Ending year in the range to test.
     * @return  *  Number of leap years in range (y1...y2). Assumes y1 <= y2.
     */
    declare     export function leapdays(y1: number, y2: number): number

    /**
     * 
     * @param  Year for which the range should be calculated.
     * @param  Month for which the range should be calculated.
     * @throws  {IllegalMonthError} if the provided month is invalid.
     * @return  *  starting weekday (0-6 ~ Mon-Sun) and number of days (28-31) for year, month.
     */
    declare     export function monthrange(year: number, month: number): [number, number]

    /**
     * Sets the locale for use in extracting month and weekday names.
     * @param  Locale to set on the calendar object. Default: en_US
     * @throws  {IllegalLocaleError} if the provided locale is invalid.
     */
    declare     export function setlocale(locale?: string): void

    /**
     * Unrelated but handy function to calculate Unix timestamp from GMT.
     * @param timegmt *  An array containing the elements from a time structure dataset.
    Format: [tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec]
     * @throws  {IllegalMonthError} if the provided month element is invalid.
     * @throws  {IllegalDayError} if the provided day element is invalid.
     * @throws  {IllegalTimeError} if any of the the provided time elements are invalid.
     * @return  *  Unix timestamp from GMT.
    */
    declare     export function timegm(timegmt: [number, number, number, number, number, number]): number

    /**
     * 
     * @param  Year for which the weekday should be calculated.
     * @param  Month for which the weekday should be calculated.
     * @param  Day for which the weekday should be calculated.
     * @throws  {IllegalMonthError} if the provided month element is invalid.
     * @throws  {IllegalDayError} if the provided day element is invalid.
     * @return  *  weekday (0-6 ~ Mon-Sun) for year (1970-...), month (1-12), day (1-31).
     */
    declare     export function weekday(year: number, month: number, day: number): number

    /**
     * Error indicating a nonexistent or unsupported locale specified. 
     */
    declare     export class IllegalLocaleError mixins Error {
        name: string;
        message: string;

        /**
         * 
         * @param  Optional custom error message.
         */
        constructor(message?: string): this
    }

    /**
     * Error indicating a day index specified outside of the valid range. 
     */
    declare     export class IllegalDayError mixins Error {
        name: string;
        message: string;

        /**
         * 
         * @param  Optional custom error message.
         */
        constructor(message?: string): this
    }

    /**
     * Error indicating a month index specified outside of the expected range (1-12 ~ Jan-Dec). 
     */
    declare     export class IllegalMonthError mixins Error {
        name: string;
        message: string;

        /**
         * 
         * @param  Optional custom error message.
         */
        constructor(message?: string): this
    }

    /**
     * Error indicating a time element is outside of the valid range. 
     */
    declare     export class IllegalTimeError mixins Error {
        name: string;
        message: string;

        /**
         * 
         * @param  Optional custom error message.
         */
        constructor(message?: string): this
    }

    /**
     * Error indicating a weekday index specified outside of the expected range (0-6 ~ Mon-Sun). 
     */
    declare     export class IllegalWeekdayError mixins Error {
        name: string;
        message: string;

        /**
         * 
         * @param  Optional custom error message.
         */
        constructor(message?: string): this
    }
}