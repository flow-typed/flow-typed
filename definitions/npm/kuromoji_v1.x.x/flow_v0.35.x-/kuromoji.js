// @flow
/**
 * Flowtype definitions for kuromoji
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$kuromoji: {
    builder: typeof kuromoji$builder,
    dictionaryBuilder: typeof kuromoji$dictionaryBuilder,
}
declare interface kuromoji$ConnectionCosts {
    buffer: Int16Array,
        put(forward_id: number, backward_id: number, cost: number): void,
        get(forward_id: number, backward_id: number): number,
        loadConnectionCosts(connection_costs_buffer: Int16Array): void
}

declare interface kuromoji$DynamicDictionaries {
    trie: doublearray.DoubleArray,
        token_info_dictionary: kuromoji$TokenInfoDictionary,
        connection_costs: kuromoji$ConnectionCosts,
        unknown_dictionary: kuromoji$UnknownDictionary,
        loadTrie(
            base_buffer: Int32Array,
            check_buffer: Int32Array): kuromoji$DynamicDictionaries
}

declare interface kuromoji$TokenInfoDictionary {
    buildDictionary(entries: any[][]): {
            [word_id: number]: string
        },
        put(
            left_id: number,
            right_id: number,
            word_cost: number,
            surface_form: string,
            feature: string): number,
        addMapping(source: number, target: number): void,
        targetMapToBuffer(): Uint8Array,
        loadDictionary(array_buffer: Uint8Array): kuromoji$TokenInfoDictionary,
        loadPosVector(array_buffer: Uint8Array): kuromoji$TokenInfoDictionary,
        loadTargetMap(array_buffer: Uint8Array): kuromoji$TokenInfoDictionary,
        getFeatures(token_info_id_str: string): string
}

declare type kuromoji$UnknownDictionary = {} & kuromoji$TokenInfoDictionary


declare interface kuromoji$ByteBuffer {
    buffer: Uint8Array,
        position: number,
        size(): number,
        reallocate(): void,
        shrink(): Uint8Array,
        put(b: number): void,
        get(index: number): number,
        putShort(num: number): void,
        getShort(index: number): number,
        putInt(num: number): void,
        getInt(index: number): number,
        readInt(): number,
        putString(str: string): void,
        getString(index: number): string
}

declare interface kuromoji$DictionaryBuilder {
    tid_entries: string[],
        unk_entries: string[],
        addTokenInfoDictionary(text: string): kuromoji$DictionaryBuilder,
        costMatrix(matrix_text: string): kuromoji$DictionaryBuilder,
        charDef(char_text: string): kuromoji$DictionaryBuilder,
        unkDef(text: string): kuromoji$DictionaryBuilder,
        build(): kuromoji$DynamicDictionaries,
        buildTokenInfoDictionary(): {
            trie: doublearray.DoubleArray,
            token_info_dictionary: kuromoji$TokenInfoDictionary
        },
        buildUnknownDictionary(): kuromoji$UnknownDictionary,
        buildConnectionCosts(): kuromoji$ConnectionCosts,
        buildDoubleArray(): doublearray.DoubleArray
}

declare interface kuromoji$Formatter<T>{
    formatEntry(word_id: number, position: number, type: string, features: string[]): T,
    formatUnknownEntry(word_id: number, position: number, type: string, features: string[]): T
}

declare type kuromoji$IpadicFormatter = {} & kuromoji$Formatter


declare export interface kuromoji$IpadicFeatures {
    word_id: number,
        word_type: string,
        word_position: number,
        surface_form: string,
        pos: string,
        pos_detail_1: string,
        pos_detail_2: string,
        pos_detail_3: string,
        conjugated_type: string,
        conjugated_form: string,
        basic_form: string,
        reading?: string,
        pronunciation?: string
}

declare interface kuromoji$ViterbiBuilder {
    trie: doublearray.DoubleArray,
        token_info_dictionary: kuromoji$TokenInfoDictionary,
        unknown_dictionary: kuromoji$UnknownDictionary,
        build(sentence_str: string): kuromoji$ViterbiLattice
}

declare interface kuromoji$ViterbiLattice {
    append(node: kuromoji$ViterbiNode): void,
        appendEos(): void
}

declare interface kuromoji$ViterbiNode {
    name: string,
        cost: number,
        start_pos: number,
        length: number,
        left_id: number,
        right_id: number,
        prev: kuromoji$ViterbiNode,
        surface_form: string,
        shortest_cost: number,
        type: string
}

declare interface kuromoji$ViterbiSearcher {
    connection_costs: kuromoji$ConnectionCosts,
        search(lattice: kuromoji$ViterbiLattice): kuromoji$ViterbiNode[],
        forward(lattice: kuromoji$ViterbiLattice): kuromoji$ViterbiLattice,
        backward(lattice: kuromoji$ViterbiLattice): kuromoji$ViterbiNode[]
}

declare interface kuromoji$TokenizerStatic {
    splitByPunctuation(input: string): string[]
}

declare interface kuromoji$Tokenizer<T>{
    token_info_dictionary: kuromoji$TokenInfoDictionary,
    unknown_dictionary: kuromoji$UnknownDictionary,
    viterbi_builder: kuromoji$ViterbiBuilder,
    viterbi_searcher: kuromoji$ViterbiSearcher,
    formatter: kuromoji$Formatter<T>,
    tokenize(text: string): T[],
    getLattice(text: string): kuromoji$ViterbiLattice
}

declare interface kuromoji$TokenizerBuilder<T>{
    build(callback: (err: Error, tokenizer: kuromoji$Tokenizer<T>) => void): void
}

declare interface kuromoji$TokenizerBuilderOption {
    dicPath?: string
}

declare export function kuromoji$builder(
    option: kuromoji$TokenizerBuilderOption): kuromoji$TokenizerBuilder<kuromoji$IpadicFeatures >

    declare export function kuromoji$dictionaryBuilder(): kuromoji$DictionaryBuilder