/**
 * Flowtype definitions for jest
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare var beforeAll: jest$Lifecycle;
declare var beforeEach: jest$Lifecycle;
declare var afterAll: jest$Lifecycle;
declare var afterEach: jest$Lifecycle;
declare var describe: jest$Describe;
declare var fdescribe: jest$Describe;
declare var xdescribe: jest$Describe;
declare var it: jest$It;
declare var fit: jest$It;
declare var xit: jest$It;
declare var test: jest$It;
declare var xtest: jest$It;
declare function expect(actual: any): jest$Matchersdeclare interface NodeRequire {

    /**
     * Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not. 
     */
    requireActual(moduleName: string): any,

        /**
         * Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not. 
         */
        requireMock(moduleName: string): any
}
declare var npm$namespace$jest: {
    addMatchers: typeof jest$addMatchers,
    autoMockOff: typeof jest$autoMockOff,
    autoMockOn: typeof jest$autoMockOn,
    clearAllMocks: typeof jest$clearAllMocks,
    clearAllTimers: typeof jest$clearAllTimers,
    deepUnmock: typeof jest$deepUnmock,
    disableAutomock: typeof jest$disableAutomock,
    doMock: typeof jest$doMock,
    dontMock: typeof jest$dontMock,
    enableAutomock: typeof jest$enableAutomock,
    fn: typeof jest$fn,
    genMockFromModule: typeof jest$genMockFromModule,
    isMockFunction: typeof jest$isMockFunction,
    mock: typeof jest$mock,
    resetModuleRegistry: typeof jest$resetModuleRegistry,
    resetModules: typeof jest$resetModules,
    runAllImmediates: typeof jest$runAllImmediates,
    runAllTicks: typeof jest$runAllTicks,
    runAllTimers: typeof jest$runAllTimers,
    runOnlyPendingTimers: typeof jest$runOnlyPendingTimers,
    runTimersToTime: typeof jest$runTimersToTime,
    setMock: typeof jest$setMock,
    unmock: typeof jest$unmock,
    useFakeTimers: typeof jest$useFakeTimers,
    useRealTimers: typeof jest$useRealTimers,
}
declare function jest$addMatchers(matchers: jasmine$CustomMatcherFactories): typeof jest


/**
 * Disables automatic mocking in the module loader. 
 */
declare function jest$autoMockOff(): typeof jest


/**
 * Enables automatic mocking in the module loader. 
 */
declare function jest$autoMockOn(): typeof jest


/**
 * Clears the mock.calls and mock.instances properties of all mocks. Equivalent to calling .mockClear() on every mocked function. 
 */
declare function jest$clearAllMocks(): typeof jest


/**
 * Removes any pending timers from the timer system. If any timers have been scheduled, they will be cleared and will never have the opportunity to execute in the future. 
 */
declare function jest$clearAllTimers(): typeof jest


/**
 * Indicates that the module system should never return a mocked version of the specified module, including all of the specificied module's dependencies. 
 */
declare function jest$deepUnmock(moduleName: string): typeof jest


/**
 * Disables automatic mocking in the module loader. 
 */
declare function jest$disableAutomock(): typeof jest


/**
 * Mocks a module with an auto-mocked version when it is being required. 
 */
declare function jest$doMock(moduleName: string): typeof jest


/**
 * Indicates that the module system should never return a mocked version of the specified module from require() (e.g. that it should always return the real module). 
 */
declare function jest$dontMock(moduleName: string): typeof jest


/**
 * Enables automatic mocking in the module loader. 
 */
declare function jest$enableAutomock(): typeof jest


/**
 * Creates a mock function. Optionally takes a mock implementation. 
 */
declare function jest$fn<T>(implementation?: Function): jest$Mock<T >


    /**
     * Use the automatic mocking system to generate a mocked version of the given module. 
     */
    declare function jest$genMockFromModule<T>(moduleName: string): T


/**
 * Returns whether the given function is a mock function. 
 */
declare function jest$isMockFunction(fn: any): Mock


/**
 * Mocks a module with an auto-mocked version when it is being required. 
 */
declare function jest$mock(moduleName: string, factory?: any, options?: jest$MockOptions): typeof jest


/**
 * Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests. 
 */
declare function jest$resetModuleRegistry(): typeof jest


/**
 * Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests. 
 */
declare function jest$resetModules(): typeof jest


/**
 * Exhausts tasks queued by setImmediate(). 
 */
declare function jest$runAllImmediates(): typeof jest


/**
 * Exhausts the micro-task queue (usually interfaced in node via process.nextTick). 
 */
declare function jest$runAllTicks(): typeof jest


/**
 * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout() and setInterval()). 
 */
declare function jest$runAllTimers(): typeof jest


/**
 * Executes only the macro-tasks that are currently pending (i.e., only the tasks that have been queued by setTimeout() or setInterval() up to this point).
 * If any of the currently pending macro-tasks schedule new macro-tasks, those new tasks will not be executed by this call. 
 */
declare function jest$runOnlyPendingTimers(): typeof jest


/**
 * Executes only the macro task queue (i.e. all tasks queued by setTimeout() or setInterval() and setImmediate()). 
 */
declare function jest$runTimersToTime(msToRun: number): typeof jest


/**
 * Explicitly supplies the mock object that the module system should return for the specified module. 
 */
declare function jest$setMock<T>(moduleName: string, moduleExports: T): typeof jest


/**
 * Indicates that the module system should never return a mocked version of the specified module from require() (e.g. that it should always return the real module). 
 */
declare function jest$unmock(moduleName: string): typeof jest


/**
 * Instructs Jest to use fake versions of the standard timer functions. 
 */
declare function jest$useFakeTimers(): typeof jest


/**
 * Instructs Jest to use the real versions of the standard timer functions. 
 */
declare function jest$useRealTimers(): typeof jest

declare interface jest$MockOptions {
    virtual?: boolean
}

declare interface jest$EmptyFunction {
    (): void
}

declare interface jest$DoneCallback {
    (...args: any[]): any,
    fail(error?: string | {
        message: string
    }): any
}

declare interface jest$ProvidesCallback {
    (cb?: jest$DoneCallback): any
}

declare interface jest$Lifecycle {
    (fn: jest$ProvidesCallback): any
}

declare interface jest$It {
    (name: string, fn: jest$ProvidesCallback): void,
    only: jest$It,
        skip: jest$It,
        concurrent: jest$It
}

declare interface jest$Describe {
    (name: string, fn: jest$EmptyFunction): void,
    only: jest$Describe,
        skip: jest$Describe
}

declare interface jest$Matchers {
    not: jest$Matchers,
        lastCalledWith(...args: any[]): void,
        toBe(expected: any): void,
        toBeCalled(): void,
        toBeCalledWith(...args: any[]): void,
        toBeCloseTo(expected: number, delta: number): void,
        toBeDefined(): void,
        toBeFalsy(): void,
        toBeGreaterThan(expected: number): void,
        toBeGreaterThanOrEqual(expected: number): void,
        toBeInstanceOf(expected: any): void,
        toBeLessThan(expected: number): void,
        toBeLessThanOrEqual(expected: number): void,
        toBeNull(): void,
        toBeTruthy(): void,
        toBeUndefined(): void,
        toContain(expected: any): void,
        toContainEqual(expected: any): void,
        toEqual(expected: any): void,
        toHaveBeenCalled(): boolean,
        toHaveBeenCalledTimes(expected: number): boolean,
        toHaveBeenCalledWith(...params: any[]): boolean,
        toMatch(expected: string | RegExp): void,
        toMatchSnapshot(): void,
        toThrow(): void,
        toThrowError(error?: string | jest$Constructable | RegExp): void,
        toThrowErrorMatchingSnapshot(): void
}

declare interface jest$Constructable {
    new(...args: any[]): any
}

declare type jest$Mock<T>= {
    new(): T,
    (...args: any[]): any,
    mock: jest$MockContext<T>,
    mockClear(): void,
    mockImplementation(fn: Function): jest$Mock<T>,
    mockImplementationOnce(fn: Function): jest$Mock<T>,
    mockReturnThis(): jest$Mock<T>,
    mockReturnValue(value: any): jest$Mock<T>,
    mockReturnValueOnce(value: any): jest$Mock<T >
} & Function


declare interface jest$MockContext<T>{
    calls: any[][],
    instances: T[]
}
declare function spyOn(object: any, method: string): jasmine$Spy
/**
 * If you call the function pending anywhere in the spec body, no matter the expectations, the spec will be marked pending. 
 */
declare function pending(reason?: string): void
/**
 * Fails a test when called within one. 
 */
declare function fail(error?: any): void
declare var npm$namespace$jasmine: {
    any: typeof jasmine$any,
    anything: typeof jasmine$anything,
    arrayContaining: typeof jasmine$arrayContaining,
    objectContaining: typeof jasmine$objectContaining,
    createSpy: typeof jasmine$createSpy,
    createSpyObj: typeof jasmine$createSpyObj,
    pp: typeof jasmine$pp,
    addCustomEqualityTester: typeof jasmine$addCustomEqualityTester,
    addMatchers: typeof jasmine$addMatchers,
    stringMatching: typeof jasmine$stringMatching,
}
declare var clock: () => jasmine$Clock;

declare function jasmine$any(aclass: any): jasmine$Any

declare function jasmine$anything(): jasmine$Any

declare function jasmine$arrayContaining(sample: any[]): jasmine$ArrayContaining

declare function jasmine$objectContaining(sample: any): jasmine$ObjectContaining

declare function jasmine$createSpy(name: string, originalFn?: Function): jasmine$Spy

declare function jasmine$createSpyObj(baseName: string, methodNames: any[]): any

declare function jasmine$pp(value: any): string

declare function jasmine$addCustomEqualityTester(equalityTester: jasmine$CustomEqualityTester): void

declare function jasmine$addMatchers(matchers: jasmine$CustomMatcherFactories): typeof jest

declare function jasmine$stringMatching(value: string | RegExp): jasmine$Any

declare interface jasmine$Clock {
    install(): void,
        uninstall(): void,

        /**
         * Calls to any registered callback are triggered when the clock is ticked forward via the jasmine.clock().tick function, which takes a number of milliseconds. 
         */
        tick(ms: number): void,
        mockDate(date?: Date): void
}

declare interface jasmine$Any {
    new(expectedClass: any): any,
    jasmineMatches(other: any): boolean,
        jasmineToString(): string
}

declare interface jasmine$ArrayContaining {
    new(sample: any[]): any,
    asymmetricMatch(other: any): boolean,
        jasmineToString(): string
}

declare interface jasmine$ObjectContaining {
    new(sample: any): any,
    jasmineMatches(other: any, mismatchKeys: any[], mismatchValues: any[]): boolean,
        jasmineToString(): string
}

declare interface jasmine$Spy {
    (...params: any[]): any,
    identity: string,
        and: jasmine$SpyAnd,
        calls: jasmine$Calls,
        mostRecentCall: {
            args: any[]
        },
        argsForCall: any[],
        wasCalled: boolean
}

declare interface jasmine$SpyAnd {

    /**
     * By chaining the spy with and.callThrough, the spy will still track all calls to it but in addition it will delegate to the actual implementation. 
     */
    callThrough(): jasmine$Spy,

        /**
         * By chaining the spy with and.returnValue, all calls to the function will return a specific value. 
         */
        returnValue(val: any): jasmine$Spy,

        /**
         * By chaining the spy with and.returnValues, all calls to the function will return specific values in order until it reaches the end of the return values list. 
         */
        returnValues(...values: any[]): jasmine$Spy,

        /**
         * By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied function. 
         */
        callFake(fn: Function): jasmine$Spy,

        /**
         * By chaining the spy with and.throwError, all calls to the spy will throw the specified value. 
         */
        throwError(msg: string): jasmine$Spy,

        /**
         * When a calling strategy is used for a spy, the original stubbing behavior can be returned at any time with and.stub. 
         */
        stub(): jasmine$Spy
}

declare interface jasmine$Calls {

    /**
     * By chaining the spy with calls.any(), will return false if the spy has not been called at all, and then true once at least one call happens. 
     */
    any(): boolean,

        /**
         * By chaining the spy with calls.count(), will return the number of times the spy was called 
         */
        count(): number,

        /**
         * By chaining the spy with calls.argsFor(), will return the arguments passed to call number index 
         */
        argsFor(index: number): any[],

        /**
         * By chaining the spy with calls.allArgs(), will return the arguments to all calls 
         */
        allArgs(): any[],

        /**
         * By chaining the spy with calls.all(), will return the context (the this) and arguments passed all calls 
         */
        all(): jasmine$CallInfo[],

        /**
         * By chaining the spy with calls.mostRecent(), will return the context (the this) and arguments for the most recent call 
         */
        mostRecent(): jasmine$CallInfo,

        /**
         * By chaining the spy with calls.first(), will return the context (the this) and arguments for the first call 
         */
        first(): jasmine$CallInfo,

        /**
         * By chaining the spy with calls.reset(), will clears all tracking for a spy 
         */
        reset(): void
}

declare interface jasmine$CallInfo {

    /**
     * The context (the this) for the call 
     */
    object: any,

        /**
         * All arguments passed to the call 
         */
        args: any[],

        /**
         * The return value of the call 
         */
        returnValue: any
}

declare interface jasmine$CustomMatcherFactories {
    [index: string]: jasmine$CustomMatcherFactory
}

declare interface jasmine$CustomMatcherFactory {
    (util: jasmine$MatchersUtil, customEqualityTesters: Array<jasmine$CustomEqualityTester>): jasmine$CustomMatcher
}

declare interface jasmine$MatchersUtil {
    equals(a: any, b: any, customTesters?: Array<jasmine$CustomEqualityTester>): boolean,
        contains<T>(
            haystack: jasmine$ArrayLike<T>| string,
            needle: any,
            customTesters?: Array<jasmine$CustomEqualityTester>): boolean,
        buildFailureMessage(
            matcherName: string,
            isNot: boolean,
            actual: any,
            ...expected: Array<any>): string
}

declare interface jasmine$CustomEqualityTester {
    (first: any, second: any): boolean
}

declare interface jasmine$CustomMatcher {
    compare<T>(actual: T, expected: T): jasmine$CustomMatcherResult,
        compare(actual: any, expected: any): jasmine$CustomMatcherResult
}

declare interface jasmine$CustomMatcherResult {
    pass: boolean,
        message: string | (() => string)
}

declare interface jasmine$ArrayLike<T>{
    length: number,
    [n: number]: T
}