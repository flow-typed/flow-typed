// @flow
/**
 * Flowtype definitions for lazy.js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface LazyJS$LazyStatic {
    (value: string): LazyJS$StringLikeSequence,
    (value: T[]): LazyJS$ArrayLikeSequence<T>,
        (value: any[]): LazyJS$ArrayLikeSequence<any>,
        (value: Object): LazyJS$ObjectLikeSequence<T>,
        (value: Object): LazyJS$ObjectLikeSequence<any>,
        strict(): LazyJS$LazyStatic,
        generate<T>(
            generatorFn: LazyJS$GeneratorCallback<T>,
            length?: number): LazyJS$GeneratedSequence<T>,
        range(to: number): LazyJS$GeneratedSequence<number>,
        range(from: number, to: number, step?: number): LazyJS$GeneratedSequence<number>,
        repeat<T>(value: T, count?: number): LazyJS$GeneratedSequence<T>,
        on<T>(eventType: string): LazyJS$Sequence<T>,
        readFile(path: string): LazyJS$StringLikeSequence,
        makeHttpRequest(path: string): LazyJS$StringLikeSequence
}

declare interface LazyJS$ArrayLike<T>{
    length: number,
    [index: number]: T
}

declare interface LazyJS$Callback {
    (): void
}

declare interface LazyJS$ErrorCallback {
    (error: any): void
}

declare interface LazyJS$ValueCallback<T>{
    (value: T): void
}

declare interface LazyJS$GetKeyCallback<T>{
    (value: T): string
}

declare interface LazyJS$TestCallback<T>{
    (value: T): boolean
}

declare interface LazyJS$MapCallback<T, U>{
    (value: T): U
}

declare interface LazyJS$MapStringCallback {
    (value: string): string
}

declare interface LazyJS$NumberCallback<T>{
    (value: T): number
}

declare interface LazyJS$MemoCallback<T, U>{
    (memo: U, value: T): U
}

declare interface LazyJS$GeneratorCallback<T>{
    (index: number): T
}

declare interface LazyJS$CompareCallback {
    (x: any, y: any): number
}

declare interface LazyJS$Iterator<T>{
    new(sequence: LazyJS$Sequence<T>): LazyJS$Iterator<T>,
    current(): T,
    moveNext(): boolean
}

declare type LazyJS$GeneratedSequence<T>= {
    new(
        generatorFn: LazyJS$GeneratorCallback<T>,
        length: number): LazyJS$GeneratedSequence<T>,
    length(): number
} & LazyJS$Sequence


declare type LazyJS$AsyncSequence<T>= {
    each(callback: LazyJS$ValueCallback<T>): LazyJS$AsyncHandle<T >
} & LazyJS$SequenceBase


declare interface LazyJS$AsyncHandle<T>{
    cancel(): void,
    onComplete(callback: LazyJS$Callback): void,
    onError(callback: LazyJS$ErrorCallback): void
}


declare var npm$namespace$Sequence: {
    define: typeof Sequence$define,
}
declare function Sequence$define(methodName: string[], overrides: Object): Function

declare type LazyJS$Sequence<T>= {
    each(eachFn: LazyJS$ValueCallback<T>): LazyJS$Sequence<T >
} & LazyJS$SequenceBase


declare type LazyJS$SequenceBase<T>= {
    first(): any,
    first(count: number): LazyJS$Sequence<T>,
    indexOf(value: any, startIndex?: number): LazyJS$Sequence<T>,
    last(): any,
    last(count: number): LazyJS$Sequence<T>,
    lastIndexOf(value: any): LazyJS$Sequence<T>,
    reverse(): LazyJS$Sequence<T >
} & LazyJS$SequenceBaser


declare interface LazyJS$SequenceBaser<T>{
    async(interval: number): LazyJS$AsyncSequence<T>,
    chunk(size: number): LazyJS$Sequence<T>,
    compact(): LazyJS$Sequence<T>,
    concat(var_args: T[]): LazyJS$Sequence<T>,
    consecutive(length: number): LazyJS$Sequence<T>,
    contains(value: T): boolean,
    countBy(keyFn: LazyJS$GetKeyCallback<T>): LazyJS$ObjectLikeSequence<T>,
    countBy(propertyName: string): LazyJS$ObjectLikeSequence<T>,
    dropWhile(predicateFn: LazyJS$TestCallback<T>): LazyJS$Sequence<T>,
    every(predicateFn: LazyJS$TestCallback<T>): boolean,
    filter(predicateFn: LazyJS$TestCallback<T>): LazyJS$Sequence<T>,
    find(predicateFn: LazyJS$TestCallback<T>): T,
    findWhere(properties: Object): T,
    flatten(): LazyJS$Sequence<T>,
    groupBy(keyFn: LazyJS$GetKeyCallback<T>): LazyJS$ObjectLikeSequence<T>,
    initial(count?: number): LazyJS$Sequence<T>,
    intersection(var_args: T[]): LazyJS$Sequence<T>,
    invoke(methodName: string): LazyJS$Sequence<T>,
    isEmpty(): boolean,
    join(delimiter?: string): string,
    map<U>(mapFn: LazyJS$MapCallback<T, U>): LazyJS$Sequence<U>,
    max(valueFn?: LazyJS$NumberCallback<T>): T,
    min(valueFn?: LazyJS$NumberCallback<T>): T,
    none(valueFn?: LazyJS$TestCallback<T>): boolean,
    pluck(propertyName: string): LazyJS$Sequence<any>,
    reduce<U>(aggregatorFn: LazyJS$MemoCallback<T, U>, memo?: U): U,
    reduceRight<U>(aggregatorFn: LazyJS$MemoCallback<T, U>, memo: U): U,
    reject(predicateFn: LazyJS$TestCallback<T>): LazyJS$Sequence<T>,
    rest(count?: number): LazyJS$Sequence<T>,
    shuffle(): LazyJS$Sequence<T>,
    some(predicateFn?: LazyJS$TestCallback<T>): boolean,
    sort(sortFn?: LazyJS$CompareCallback, descending?: boolean): LazyJS$Sequence<T>,
    sortBy(sortFn: string, descending?: boolean): LazyJS$Sequence<T>,
    sortBy(sortFn: LazyJS$NumberCallback<T>, descending?: boolean): LazyJS$Sequence<T>,
    sortedIndex(value: T): LazyJS$Sequence<T>,
    size(): number,
    sum(valueFn?: LazyJS$NumberCallback<T>): T,
    takeWhile(predicateFn: LazyJS$TestCallback<T>): LazyJS$Sequence<T>,
    union(var_args: T[]): LazyJS$Sequence<T>,
    uniq(): LazyJS$Sequence<T>,
    where(properties: Object): LazyJS$Sequence<T>,
    without(...var_args: T[]): LazyJS$Sequence<T>,
    without(var_args: T[]): LazyJS$Sequence<T>,
    zip(var_args: T[]): LazyJS$Sequence<T>,
    toArray(): T[],
    toObject(): Object
}


declare var npm$namespace$ArrayLikeSequence: {
    define: typeof ArrayLikeSequence$define,
}
declare function ArrayLikeSequence$define(methodName: string[], overrides: Object): Function

declare type LazyJS$ArrayLikeSequence<T>= {
    concat(var_args: T[]): LazyJS$ArrayLikeSequence<T>,
    first(count?: number): LazyJS$ArrayLikeSequence<T>,
    get(index: number): T,
    length(): number,
    map<U>(mapFn: LazyJS$MapCallback<T, U>): LazyJS$ArrayLikeSequence<U>,
    pop(): LazyJS$ArrayLikeSequence<T>,
    rest(count?: number): LazyJS$ArrayLikeSequence<T>,
    reverse(): LazyJS$ArrayLikeSequence<T>,
    shift(): LazyJS$ArrayLikeSequence<T>,
    slice(begin: number, end?: number): LazyJS$ArrayLikeSequence<T >
} & LazyJS$Sequence



declare var npm$namespace$ObjectLikeSequence: {
    define: typeof ObjectLikeSequence$define,
}
declare function ObjectLikeSequence$define(methodName: string[], overrides: Object): Function

declare type LazyJS$ObjectLikeSequence<T>= {
    assign(other: Object): LazyJS$ObjectLikeSequence<T>,
    defaults(defaults: Object): LazyJS$ObjectLikeSequence<T>,
    functions(): LazyJS$Sequence<T>,
    get(property: string): LazyJS$ObjectLikeSequence<T>,
    invert(): LazyJS$ObjectLikeSequence<T>,
    keys(): LazyJS$Sequence<string>,
    omit(properties: string[]): LazyJS$ObjectLikeSequence<T>,
    pairs(): LazyJS$Sequence<T>,
    pick(properties: string[]): LazyJS$ObjectLikeSequence<T>,
    toArray(): T[],
    toObject(): Object,
    values(): LazyJS$Sequence<T >
} & LazyJS$Sequence



declare var npm$namespace$StringLikeSequence: {
    define: typeof StringLikeSequence$define,
}
declare function StringLikeSequence$define(methodName: string[], overrides: Object): Function

declare type LazyJS$StringLikeSequence = {
    charAt(index: number): string,
    charCodeAt(index: number): number,
    contains(value: string): boolean,
    endsWith(suffix: string): boolean,
    first(): string,
    first(count: number): LazyJS$StringLikeSequence,
    indexOf(substring: string, startIndex?: number): number,
    last(): string,
    last(count: number): LazyJS$StringLikeSequence,
    lastIndexOf(substring: string, startIndex?: number): number,
    mapString(mapFn: LazyJS$MapStringCallback): LazyJS$StringLikeSequence,
    match(pattern: RegExp): LazyJS$StringLikeSequence,
    reverse(): LazyJS$StringLikeSequence,
    split(delimiter: string): LazyJS$StringLikeSequence,
    split(delimiter: RegExp): LazyJS$StringLikeSequence,
    startsWith(prefix: string): boolean,
    substring(start: number, stop?: number): LazyJS$StringLikeSequence,
    toLowerCase(): LazyJS$StringLikeSequence,
    toUpperCase(): LazyJS$StringLikeSequence
} & LazyJS$SequenceBaser
declare var Lazy: LazyJS$LazyStatic;
declare module 'lazy.js' {
    declare module.exports: typeof Lazy
}