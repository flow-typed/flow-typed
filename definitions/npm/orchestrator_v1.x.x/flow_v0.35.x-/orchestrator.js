/**
 * Flowtype definitions for orchestrator
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare type Strings = string | string[];
declare module 'orchestrator' {
    declare module.exports: typeof Orchestrator
    declare interface Orchestrator$AddMethodCallback {

        /**
         * Accept a callback
         * @param callback 
         */
        (callback?: Function): any,

        /**
         * Return a promise
         */
        (): Q.Promise<any>,

            /**
             * Return a stream: (task is marked complete when stream ends)
             */
            (): any
    }


    /**
     * Define a task
     */
    declare interface Orchestrator$AddMethod {

        /**
         * Define a task
         * @param name The name of the task.
         * @param deps An array of task names to be executed and completed before your task will run.
         * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
        <ul>
        <li>Take in a callback</li>
        <li>Return a stream or a promise</li>
        </ul>
        */
        (name: string, deps?: string[], fn?: Orchestrator$AddMethodCallback | Function): Orchestrator,

        /**
         * Define a task
         * @param name The name of the task.
         * @param fn The function that performs the task's operations. For asynchronous tasks, you need to provide a hint when the task is complete:
        <ul>
        <li>Take in a callback</li>
        <li>Return a stream or a promise</li>
        </ul>
        */
        (name: string, fn?: Orchestrator$AddMethodCallback | Function): Orchestrator
    }


    /**
     * Start running the tasks
     */
    declare interface Orchestrator$StartMethod {

        /**
         * Start running the tasks
         * @param tasks Tasks to be executed. You may pass any number of tasks as individual arguments.
         * @param cb Callback to call after run completed.
         */
        (tasks: Strings, cb?: (error?: any) => any): Orchestrator,

        /**
         * Start running the tasks
         * @param tasks Tasks to be executed. You may pass any number of tasks as individual arguments.
         * @param cb Callback to call after run completed.
         */
        (...tasks: Strings[]): Orchestrator,
        (task1: Strings, task2: Strings, cb?: (error?: any) => any): Orchestrator,
        (task1: Strings, task2: Strings, task3: Strings, cb?: (error?: any) => any): Orchestrator,
        (task1: Strings, task2: Strings, task3: Strings, task4: Strings, cb?: (error?: any) => any): Orchestrator,
        (task1: Strings, task2: Strings, task3: Strings, task4: Strings, task5: Strings, cb?: (error?: any) => any): Orchestrator,
        (task1: Strings, task2: Strings, task3: Strings, task4: Strings, task5: Strings, task6: Strings, cb?: (error?: any) => any): Orchestrator
    }

    declare interface Orchestrator$OnCallbackEvent {
        message: string,
            task: string,
            err: any,
            duration?: number
    }

    declare type Orchestrator$OnAllCallbackEvent = {
        src: string
    } & Orchestrator$OnCallbackEvent

}