/**
 * Flowtype definitions for node-0.11
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare var process: NodeJS$Process;
declare var global: any;
declare var ___filename: string;
declare var ___dirname: string;
declare function setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timerdeclare function clearTimeout(timeoutId: NodeJS$Timer): voiddeclare function setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): NodeJS$Timerdeclare function clearInterval(intervalId: NodeJS$Timer): voiddeclare function setImmediate(callback: (...args: any[]) => void, ...args: any[]): anydeclare function clearImmediate(immediateId: any): voiddeclare var require: {
    (id: string): any,
    resolve(id: string): string,
    cache: any,
    extensions: any,
    main: any
};
declare var module: {
    exports: any,
    require(id: string): any,
    id: string,
    filename: string,
    loaded: boolean,
    parent: any,
    children: any[]
};
declare var exports: any;
declare var SlowBuffer: {
    new(str: string, encoding?: string): Buffer,
    new(size: number): Buffer,
    new(size: Uint8Array): Buffer,
    new(array: any[]): Buffer,
    prototype: Buffer,
    isBuffer(obj: any): boolean,
    byteLength(string: string, encoding?: string): number,
    concat(list: Buffer[], totalLength?: number): Buffer
};
declare type Buffer = {} & NodeBuffer
declare var Buffer: {
    new(str: string, encoding?: string): Buffer,
    new(size: number): Buffer,
    new(size: Uint8Array): Buffer,
    new(array: any[]): Buffer,
    prototype: Buffer,
    isBuffer(obj: any): boolean,
    byteLength(string: string, encoding?: string): number,
    concat(list: Buffer[], totalLength?: number): Buffer
};
declare export type NodeJS$ErrnoException = {
    errno?: number,
    code?: string,
    path?: string,
    syscall?: string,
    stack?: string
} & Error


declare export interface NodeJS$EventEmitter {
    addListener(event: string, listener: Function): this,
        on(event: string, listener: Function): this,
        once(event: string, listener: Function): this,
        removeListener(event: string, listener: Function): this,
        removeAllListeners(event?: string): this,
        setMaxListeners(n: number): void,
        listeners(event: string): Function[],
        emit(event: string, ...args: any[]): boolean
}

declare export type NodeJS$ReadableStream = {
    readable: boolean,
    read(size?: number): any,
    setEncoding(encoding: string): void,
    pause(): void,
    resume(): void,
    pipe<T>(destination: T, options?: {
        end?: boolean
    }): T,
    unpipe<T>(destination?: T): void,
    unshift(chunk: string): void,
    unshift(chunk: Buffer): void,
    wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream
} & NodeJS$EventEmitter


declare export type NodeJS$WritableStream = {
    writable: boolean,
    write(buffer: Buffer, cb?: Function): boolean,
    write(str: string, cb?: Function): boolean,
    write(str: string, encoding?: string, cb?: Function): boolean,
    end(): void,
    end(buffer: Buffer, cb?: Function): void,
    end(str: string, cb?: Function): void,
    end(str: string, encoding?: string, cb?: Function): void
} & NodeJS$EventEmitter


declare export type NodeJS$ReadWriteStream = {} & NodeJS$ReadableStream & NodeJS$WritableStream


declare export type NodeJS$Process = {
    stdout: NodeJS$WritableStream,
    stderr: NodeJS$WritableStream,
    stdin: NodeJS$ReadableStream,
    argv: string[],
    execPath: string,
    abort(): void,
    chdir(directory: string): void,
    cwd(): string,
    env: any,
    exit(code?: number): void,
    getgid(): number,
    setgid(id: number): void,
    setgid(id: string): void,
    getuid(): number,
    setuid(id: number): void,
    setuid(id: string): void,
    version: string,
    versions: {
        http_parser: string,
        node: string,
        v8: string,
        ares: string,
        uv: string,
        zlib: string,
        openssl: string
    },
    config: {
        target_defaults: {
            cflags: any[],
            default_configuration: string,
            defines: string[],
            include_dirs: string[],
            libraries: string[]
        },
        variables: {
            clang: number,
            host_arch: string,
            node_install_npm: boolean,
            node_install_waf: boolean,
            node_prefix: string,
            node_shared_openssl: boolean,
            node_shared_v8: boolean,
            node_shared_zlib: boolean,
            node_use_dtrace: boolean,
            node_use_etw: boolean,
            node_use_openssl: boolean,
            target_arch: string,
            v8_no_strict_aliasing: number,
            v8_use_snapshot: boolean,
            visibility: string
        }
    },
    kill(pid: number, signal?: string | number): void,
    pid: number,
    title: string,
    arch: string,
    platform: string,
    memoryUsage(): {
        rss: number,
        heapTotal: number,
        heapUsed: number
    },
    nextTick(callback: Function): void,
    umask(mask?: number): number,
    uptime(): number,
    hrtime(time?: number[]): number[],
    send(message: any, sendHandle?: any): void
} & NodeJS$EventEmitter


declare export interface NodeJS$Timer {
    ref(): void,
        unref(): void
}
/**
 * 
 * @deprecated  
 */
declare interface NodeBuffer {
    [index: number]: number,
    write(string: string, offset?: number, length?: number, encoding?: string): number,
        toString(encoding?: string, start?: number, end?: number): string,
        toJSON(): any,
        length: number,
        copy(
            targetBuffer: Buffer,
            targetStart?: number,
            sourceStart?: number,
            sourceEnd?: number): number,
        slice(start?: number, end?: number): Buffer,
        readUInt8(offset: number, noAssert?: boolean): number,
        readUInt16LE(offset: number, noAssert?: boolean): number,
        readUInt16BE(offset: number, noAssert?: boolean): number,
        readUInt32LE(offset: number, noAssert?: boolean): number,
        readUInt32BE(offset: number, noAssert?: boolean): number,
        readInt8(offset: number, noAssert?: boolean): number,
        readInt16LE(offset: number, noAssert?: boolean): number,
        readInt16BE(offset: number, noAssert?: boolean): number,
        readInt32LE(offset: number, noAssert?: boolean): number,
        readInt32BE(offset: number, noAssert?: boolean): number,
        readFloatLE(offset: number, noAssert?: boolean): number,
        readFloatBE(offset: number, noAssert?: boolean): number,
        readDoubleLE(offset: number, noAssert?: boolean): number,
        readDoubleBE(offset: number, noAssert?: boolean): number,
        writeUInt8(value: number, offset: number, noAssert?: boolean): void,
        writeUInt16LE(value: number, offset: number, noAssert?: boolean): void,
        writeUInt16BE(value: number, offset: number, noAssert?: boolean): void,
        writeUInt32LE(value: number, offset: number, noAssert?: boolean): void,
        writeUInt32BE(value: number, offset: number, noAssert?: boolean): void,
        writeInt8(value: number, offset: number, noAssert?: boolean): void,
        writeInt16LE(value: number, offset: number, noAssert?: boolean): void,
        writeInt16BE(value: number, offset: number, noAssert?: boolean): void,
        writeInt32LE(value: number, offset: number, noAssert?: boolean): void,
        writeInt32BE(value: number, offset: number, noAssert?: boolean): void,
        writeFloatLE(value: number, offset: number, noAssert?: boolean): void,
        writeFloatBE(value: number, offset: number, noAssert?: boolean): void,
        writeDoubleLE(value: number, offset: number, noAssert?: boolean): void,
        writeDoubleBE(value: number, offset: number, noAssert?: boolean): void,
        fill(value: any, offset?: number, end?: number): void
}
declare module 'buffer' {
    declare export var INSPECT_MAX_BYTES: number;
}
declare module 'querystring' {
    declare export function stringify(obj: any, sep?: string, eq?: string): string
    declare export function parse(str: string, sep?: string, eq?: string, options?: {
        maxKeys?: number
    }): any
    declare export function escape(str: string): string
    declare export function unescape(str: string): string
}
declare module 'events' {
    declare export class EventEmitter mixins NodeJS$EventEmitter {
        listenerCount(emitter: NodeJS$EventEmitter, event: string): number;
        addListener(event: string, listener: Function): this;
        on(event: string, listener: Function): this;
        once(event: string, listener: Function): this;
        removeListener(event: string, listener: Function): this;
        removeAllListeners(event?: string): this;
        setMaxListeners(n: number): void;
        listeners(event: string): Function[];
        emit(event: string, ...args: any[]): boolean
    }
}
declare module 'http' {
    declare export type Server = {
        listen(port: number, hostname?: string, backlog?: number, callback?: Function): Server,
        listen(path: string, callback?: Function): Server,
        listen(handle: any, listeningListener?: Function): Server,
        close(cb?: any): Server,
        address(): {
            port: number,
            family: string,
            address: string
        },
        maxHeadersCount: number
    }
    declare export type ServerRequest = {
            method: string,
            url: string,
            headers: any,
            trailers: string,
            httpVersion: string,
            setEncoding(encoding?: string): void,
            pause(): void,
            resume(): void,
            connection: net.Socket
        } & &

        declare export type ServerResponse = {
            write(buffer: Buffer): boolean,
            write(buffer: Buffer, cb?: Function): boolean,
            write(str: string, cb?: Function): boolean,
            write(str: string, encoding?: string, cb?: Function): boolean,
            write(str: string, encoding?: string, fd?: string): boolean,
            writeContinue(): void,
            writeHead(statusCode: number, reasonPhrase?: string, headers?: any): void,
            writeHead(statusCode: number, headers?: any): void,
            statusCode: number,
            setHeader(name: string, value: string): void,
            sendDate: boolean,
            getHeader(name: string): string,
            removeHeader(name: string): void,
            write(chunk: any, encoding?: string): any,
            addTrailers(headers: any): void,
            end(): void,
            end(buffer: Buffer, cb?: Function): void,
            end(str: string, cb?: Function): void,
            end(str: string, encoding?: string, cb?: Function): void,
            end(data?: any, encoding?: string): void
        } & &

        declare export type ClientRequest = {
            write(buffer: Buffer): boolean,
            write(buffer: Buffer, cb?: Function): boolean,
            write(str: string, cb?: Function): boolean,
            write(str: string, encoding?: string, cb?: Function): boolean,
            write(str: string, encoding?: string, fd?: string): boolean,
            write(chunk: any, encoding?: string): void,
            abort(): void,
            setTimeout(timeout: number, callback?: Function): void,
            setNoDelay(noDelay?: boolean): void,
            setSocketKeepAlive(enable?: boolean, initialDelay?: number): void,
            end(): void,
            end(buffer: Buffer, cb?: Function): void,
            end(str: string, cb?: Function): void,
            end(str: string, encoding?: string, cb?: Function): void,
            end(data?: any, encoding?: string): void
        } & &

        declare export type ClientResponse = {
            statusCode: number,
            httpVersion: string,
            headers: any,
            trailers: any,
            setEncoding(encoding?: string): void,
            pause(): void,
            resume(): void
        } & &

        declare export interface Agent {
        maxSockets: number,
            sockets: any,
            requests: any
    }
    declare export var STATUS_CODES: {
        [errorCode: number]: string,
        [errorCode: string]: string
    };
    declare export function createServer(
        requestListener?: (request: ServerRequest, response: ServerResponse) => void): Server
    declare export function createClient(port?: number, host?: string): any
    declare export function request(options: any, callback?: Function): ClientRequest
    declare export function get(options: any, callback?: Function): ClientRequest
    declare export var globalAgent: Agent;
}
declare module 'cluster' {
    declare export interface ClusterSettings {
        exec?: string,
            args?: string[],
            silent?: boolean
    }
    declare export class Worker mixins events.EventEmitter {
        id: string;
        process: child.ChildProcess;
        suicide: boolean;
        send(message: any, sendHandle?: any): void;
        kill(signal?: string): void;
        destroy(signal?: string): void;
        disconnect(): void
    }
    declare export var settings: ClusterSettings;
    declare export var isMaster: boolean;
    declare export var isWorker: boolean;
    declare export function setupMaster(settings?: ClusterSettings): void
    declare export function fork(env?: any): Worker
    declare export function disconnect(callback?: Function): void
    declare export var worker: Worker;
    declare export var workers: Worker[];
    declare export function addListener(event: string, listener: Function): void
    declare export function on(event: string, listener: Function): any
    declare export function once(event: string, listener: Function): void
    declare export function removeListener(event: string, listener: Function): void
    declare export function removeAllListeners(event?: string): void
    declare export function setMaxListeners(n: number): void
    declare export function listeners(event: string): Function[]
    declare export function emit(event: string, ...args: any[]): boolean
}
declare module 'zlib' {
    declare export interface ZlibOptions {
        chunkSize?: number,
            windowBits?: number,
            level?: number,
            memLevel?: number,
            strategy?: number,
            dictionary?: any
    }
    declare export type Gzip = {}
    declare export type Gunzip = {}
    declare export type Deflate = {}
    declare export type Inflate = {}
    declare export type DeflateRaw = {}
    declare export type InflateRaw = {}
    declare export type Unzip = {}
    declare export function createGzip(options?: ZlibOptions): Gzip
    declare export function createGunzip(options?: ZlibOptions): Gunzip
    declare export function createDeflate(options?: ZlibOptions): Deflate
    declare export function createInflate(options?: ZlibOptions): Inflate
    declare export function createDeflateRaw(options?: ZlibOptions): DeflateRaw
    declare export function createInflateRaw(options?: ZlibOptions): InflateRaw
    declare export function createUnzip(options?: ZlibOptions): Unzip
    declare export function deflate(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function deflateRaw(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function gzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function gunzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function inflate(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function inflateRaw(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export function unzip(buf: Buffer, callback: (error: Error, result: any) => void): void
    declare export var Z_NO_FLUSH: number;
    declare export var Z_PARTIAL_FLUSH: number;
    declare export var Z_SYNC_FLUSH: number;
    declare export var Z_FULL_FLUSH: number;
    declare export var Z_FINISH: number;
    declare export var Z_BLOCK: number;
    declare export var Z_TREES: number;
    declare export var Z_OK: number;
    declare export var Z_STREAM_END: number;
    declare export var Z_NEED_DICT: number;
    declare export var Z_ERRNO: number;
    declare export var Z_STREAM_ERROR: number;
    declare export var Z_DATA_ERROR: number;
    declare export var Z_MEM_ERROR: number;
    declare export var Z_BUF_ERROR: number;
    declare export var Z_VERSION_ERROR: number;
    declare export var Z_NO_COMPRESSION: number;
    declare export var Z_BEST_SPEED: number;
    declare export var Z_BEST_COMPRESSION: number;
    declare export var Z_DEFAULT_COMPRESSION: number;
    declare export var Z_FILTERED: number;
    declare export var Z_HUFFMAN_ONLY: number;
    declare export var Z_RLE: number;
    declare export var Z_FIXED: number;
    declare export var Z_DEFAULT_STRATEGY: number;
    declare export var Z_BINARY: number;
    declare export var Z_TEXT: number;
    declare export var Z_ASCII: number;
    declare export var Z_UNKNOWN: number;
    declare export var Z_DEFLATED: number;
    declare export var Z_NULL: number;
}
declare module 'os' {
    declare export function tmpdir(): string
    declare export function hostname(): string
    declare export function type(): string
    declare export function platform(): string
    declare export function arch(): string
    declare export function release(): string
    declare export function uptime(): number
    declare export function loadavg(): number[]
    declare export function totalmem(): number
    declare export function freemem(): number
    declare export function cpus(): {
        model: string,
        speed: number,
        times: {
            user: number,
            nice: number,
            sys: number,
            idle: number,
            irq: number
        }
    }[]
    declare export function networkInterfaces(): any
    declare export var EOL: string;
}
declare module 'https' {
    declare export interface ServerOptions {
        pfx?: any,
            key?: any,
            passphrase?: string,
            cert?: any,
            ca?: any,
            crl?: any,
            ciphers?: string,
            honorCipherOrder?: boolean,
            requestCert?: boolean,
            rejectUnauthorized?: boolean,
            NPNProtocols?: any,
            SNICallback?: (servername: string) => any
    }
    declare export interface RequestOptions {
        host?: string,
            hostname?: string,
            port?: number,
            path?: string,
            method?: string,
            headers?: any,
            auth?: string,
            agent?: any,
            pfx?: any,
            key?: any,
            passphrase?: string,
            cert?: any,
            ca?: any,
            ciphers?: string,
            rejectUnauthorized?: boolean
    }
    declare export interface Agent {
        maxSockets: number,
            sockets: any,
            requests: any
    }
    declare export var Agent: {
        new(options?: RequestOptions): Agent
    };
    declare export type Server = {
        listen(port: number, hostname?: string, backlog?: number, callback?: Function): Server,
        listen(path: string, callback?: Function): Server,
        listen(handle: any, listeningListener?: Function): Server,
        close(cb?: any): Server,
        address(): {
            port: number,
            family: string,
            address: string
        },
        maxHeadersCount: number
    }
    declare export function createServer(
        requestListener?: (request: ServerRequest, response: ServerResponse) => void): Server
    declare export function request(options: any, callback?: Function): ClientRequest
    declare export function get(options: any, callback?: Function): ClientRequest
    declare export var globalAgent: Agent;
}
declare module 'punycode' {
    declare export function decode(string: string): string
    declare export function encode(string: string): string
    declare export function toUnicode(domain: string): string
    declare export function toASCII(domain: string): string
    declare export var ucs2: ucs2;
    declare interface ucs2 {
        decode(string: string): string,
            encode(codePoints: number[]): string
    }
    declare export var version: any;
}
declare module 'repl' {
    declare export interface ReplOptions {
        prompt?: string,
            input?: NodeJS$ReadableStream,
            output?: NodeJS$WritableStream,
            terminal?: boolean,
            eval?: Function,
            useColors?: boolean,
            useGlobal?: boolean,
            ignoreUndefined?: boolean,
            writer?: Function
    }
    declare export function start(options: ReplOptions): events.EventEmitter
}
declare module 'readline' {
    declare export type ReadLine = {
        setPrompt(prompt: string): void,
        prompt(preserveCursor?: boolean): void,
        question(query: string, callback: Function): void,
        pause(): void,
        resume(): void,
        close(): void,
        write(data: any, key?: any): void
    }
    declare export interface ReadLineOptions {
        input: NodeJS$ReadableStream,
            output: NodeJS$WritableStream,
            completer?: Function,
            terminal?: boolean
    }
    declare export function createInterface(options: ReadLineOptions): ReadLine
}
declare module 'vm' {
    declare export interface Context {}
    declare export interface Script {
        runInThisContext(): void,
            runInNewContext(sandbox?: Context): void
    }
    declare export function runInThisContext(code: string, filename?: string): void
    declare export function runInNewContext(code: string, sandbox?: Context, filename?: string): void
    declare export function runInContext(code: string, context: Context, filename?: string): void
    declare export function createContext(initSandbox?: Context): Context
    declare export function createScript(code: string, filename?: string): Script
}
declare module 'child_process' {
    declare export type ChildProcess = {
        stdin: stream.Writable,
        stdout: stream.Readable,
        stderr: stream.Readable,
        pid: number,
        kill(signal?: string): void,
        send(message: any, sendHandle: any): void,
        connected: boolean,
        disconnect(): void
    }
    declare export function spawn(
        command: string,
        args?: string[],
        options?: {
            cwd?: string,
            stdio?: any,
            custom?: any,
            env?: any,
            detached?: boolean
        }): ChildProcess
    declare export function exec(
        command: string,
        options: {
            cwd?: string,
            stdio?: any,
            customFds?: any,
            env?: any,
            encoding?: string,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string
        },
        callback: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess
    declare export function execFile(
        file: string,
        args: string[],
        options: {
            cwd?: string,
            stdio?: any,
            customFds?: any,
            env?: any,
            encoding?: string,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string
        },
        callback: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess
    declare export function fork(env?: any): Worker
}
declare module 'url' {
    declare export interface Url {
        href?: string,
            protocol?: string,
            auth?: string,
            hostname?: string,
            port?: string,
            host?: string,
            pathname?: string,
            search?: string,
            query?: any,
            slashes?: boolean,
            hash?: string,
            path?: string
    }
    declare export function parse(str: string, sep?: string, eq?: string, options?: {
        maxKeys?: number
    }): any
    declare export function format(url: Url): string
    declare export function resolve(from: string, to: string): string
}
declare module 'dns' {
    declare export function lookup(
        domain: string,
        family: number,
        callback: (err: Error, address: string, family: number) => void): string
    declare export function resolve(from: string, to: string): string
    declare export function resolve4(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolve6(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveMx(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveTxt(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveSrv(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveNs(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function resolveCname(domain: string, callback: (err: Error, addresses: string[]) => void): string[]
    declare export function reverse(ip: string, callback: (err: Error, domains: string[]) => void): string[]
}
declare module 'net' {
    declare export type Socket = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        connect(port: number, host?: string, connectionListener?: Function): void,
        connect(path: string, connectionListener?: Function): void,
        bufferSize: number,
        setEncoding(encoding?: string): void,
        write(data: any, encoding?: string, callback?: Function): void,
        destroy(): void,
        pause(): void,
        resume(): void,
        setTimeout(timeout: number, callback?: Function): void,
        setNoDelay(noDelay?: boolean): void,
        setKeepAlive(enable?: boolean, initialDelay?: number): void,
        address(): {
            port: number,
            family: string,
            address: string
        },
        remoteAddress: string,
        remotePort: number,
        bytesRead: number,
        bytesWritten: number,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void
    }
    declare export var Socket: {
        new(options?: {
            fd?: string,
            type?: string,
            allowHalfOpen?: boolean
        }): Socket
    };
    declare export type Server = {
        listen(port: number, hostname?: string, backlog?: number, callback?: Function): Server,
        listen(path: string, callback?: Function): Server,
        listen(handle: any, listeningListener?: Function): Server,
        close(cb?: any): Server,
        address(): {
            port: number,
            family: string,
            address: string
        },
        maxHeadersCount: number
    }
    declare export function createServer(
        requestListener?: (request: ServerRequest, response: ServerResponse) => void): Server
    declare export function connect(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function createConnection(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function isIP(input: string): number
    declare export function isIPv4(input: string): boolean
    declare export function isIPv6(input: string): boolean
}
declare module 'dgram' {
    declare interface RemoteInfo {
        address: string,
            port: number,
            size: number
    }
    declare interface AddressInfo {
        address: string,
            family: string,
            port: number
    }
    declare export function createSocket(type: string, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket
    declare export type Socket = {
        write(buffer: Buffer): boolean,
        write(buffer: Buffer, cb?: Function): boolean,
        write(str: string, cb?: Function): boolean,
        write(str: string, encoding?: string, cb?: Function): boolean,
        write(str: string, encoding?: string, fd?: string): boolean,
        connect(port: number, host?: string, connectionListener?: Function): void,
        connect(path: string, connectionListener?: Function): void,
        bufferSize: number,
        setEncoding(encoding?: string): void,
        write(data: any, encoding?: string, callback?: Function): void,
        destroy(): void,
        pause(): void,
        resume(): void,
        setTimeout(timeout: number, callback?: Function): void,
        setNoDelay(noDelay?: boolean): void,
        setKeepAlive(enable?: boolean, initialDelay?: number): void,
        address(): {
            port: number,
            family: string,
            address: string
        },
        remoteAddress: string,
        remotePort: number,
        bytesRead: number,
        bytesWritten: number,
        end(): void,
        end(buffer: Buffer, cb?: Function): void,
        end(str: string, cb?: Function): void,
        end(str: string, encoding?: string, cb?: Function): void,
        end(data?: any, encoding?: string): void
    }
}
declare module 'fs' {
    declare interface Stats {
        isFile(): boolean,
            isDirectory(): boolean,
            isBlockDevice(): boolean,
            isCharacterDevice(): boolean,
            isSymbolicLink(): boolean,
            isFIFO(): boolean,
            isSocket(): boolean,
            dev: number,
            ino: number,
            mode: number,
            nlink: number,
            uid: number,
            gid: number,
            rdev: number,
            size: number,
            blksize: number,
            blocks: number,
            atime: Date,
            mtime: Date,
            ctime: Date
    }
    declare type FSWatcher = {
        close(): void
    }
    declare export type ReadStream = {}
    declare export type WriteStream = {}
    declare export function rename(
        oldPath: string,
        newPath: string,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function renameSync(oldPath: string, newPath: string): void
    declare export function truncate(path: string, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function truncateSync(path: string, len?: number): void
    declare export function ftruncate(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function ftruncateSync(fd: number, len?: number): void
    declare export function chown(
        path: string,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function chownSync(path: string, uid: number, gid: number): void
    declare export function fchown(
        fd: number,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fchownSync(fd: number, uid: number, gid: number): void
    declare export function lchown(
        path: string,
        uid: number,
        gid: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function lchownSync(path: string, uid: number, gid: number): void
    declare export function chmod(
        path: string,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function chmodSync(path: string, mode: number): void
    declare export function fchmod(
        fd: number,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fchmodSync(fd: number, mode: number): void
    declare export function lchmod(
        path: string,
        mode: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function lchmodSync(path: string, mode: number): void
    declare export function stat(
        path: string,
        callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function lstat(
        path: string,
        callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function fstat(fd: number, callback?: (err: NodeJS$ErrnoException, stats: Stats) => any): void
    declare export function statSync(path: string): Stats
    declare export function lstatSync(path: string): Stats
    declare export function fstatSync(fd: number): Stats
    declare export function link(
        srcpath: string,
        dstpath: string,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function linkSync(srcpath: string, dstpath: string): void
    declare export function symlink(
        srcpath: string,
        dstpath: string,
        type?: string,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function symlinkSync(srcpath: string, dstpath: string, type?: string): void
    declare export function readlink(
        path: string,
        callback?: (err: NodeJS$ErrnoException, linkString: string) => any): void
    declare export function readlinkSync(path: string): string
    declare export function realpath(
        path: string,
        callback?: (err: NodeJS$ErrnoException, resolvedPath: string) => any): void
    declare export function realpathSync(path: string, cache?: {
        [path: string]: string
    }): string
    declare export function unlink(path: string, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function unlinkSync(path: string): void
    declare export function rmdir(path: string, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function rmdirSync(path: string): void
    declare export function mkdir(path: string, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function mkdirSync(path: string, mode?: number): void
    declare export function readdir(
        path: string,
        callback?: (err: NodeJS$ErrnoException, files: string[]) => void): void
    declare export function readdirSync(path: string): string[]
    declare export function close(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function closeSync(fd: number): void
    declare export function open(
        path: string,
        flags: string,
        callback?: (err: NodeJS$ErrnoException, fd: number) => any): void
    declare export function openSync(path: string, flags: string, mode?: number): number
    declare export function utimes(
        path: string,
        atime: number,
        mtime: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function utimesSync(path: string, atime: number, mtime: number): void
    declare export function futimes(
        fd: number,
        atime: number,
        mtime: number,
        callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function futimesSync(fd: number, atime: number, mtime: number): void
    declare export function fsync(fd: number, callback?: (err?: NodeJS$ErrnoException) => void): void
    declare export function fsyncSync(fd: number): void
    declare export function write(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number,
        callback?: (err: NodeJS$ErrnoException, written: number, buffer: Buffer) => void): void
    declare export function writeSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number): number
    declare export function read(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position: number,
        callback?: (err: NodeJS$ErrnoException, bytesRead: number, buffer: Buffer) => void): void
    declare export function readSync(
        fd: number,
        buffer: Buffer,
        offset: number,
        length: number,
        position?: number): number
    declare export function readFile(
        filename: string,
        encoding: string,
        callback: (err: NodeJS$ErrnoException, data: string) => void): void
    declare export function readFileSync(filename: string, encoding: string): string
    declare export function writeFile(
        filename: string,
        data: any,
        callback?: (err: NodeJS$ErrnoException) => void): void
    declare export function writeFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare export function appendFile(
        filename: string,
        data: any,
        options: {
            encoding?: string,
            mode?: number,
            flag?: string
        },
        callback?: (err: NodeJS$ErrnoException) => void): void
    declare export function appendFileSync(
        filename: string,
        data: any,
        options?: {
            encoding?: string,
            mode?: number,
            flag?: string
        }): void
    declare export function watchFile(filename: string, listener: (curr: Stats, prev: Stats) => void): void
    declare export function unwatchFile(filename: string, listener?: (curr: Stats, prev: Stats) => void): void
    declare export function watch(
        filename: string,
        listener?: (event: string, filename: string) => any): FSWatcher
    declare export function exists(path: string, callback?: (exists: boolean) => void): void
    declare export function existsSync(path: string): boolean
    declare export function createReadStream(
        path: string,
        options?: {
            flags?: string,
            encoding?: string,
            fd?: string,
            mode?: number,
            bufferSize?: number
        }): ReadStream
    declare export function createWriteStream(
        path: string,
        options?: {
            flags?: string,
            encoding?: string,
            string?: string
        }): WriteStream
}
declare module 'path' {
    declare export function normalize(p: string): string
    declare export function join(...paths: any[]): string
    declare export function resolve(from: string, to: string): string
    declare export function relative(from: string, to: string): string
    declare export function dirname(p: string): string
    declare export function basename(p: string, ext?: string): string
    declare export function extname(p: string): string
    declare export var sep: string;
}
declare module 'string_decoder' {
    declare export interface NodeStringDecoder {
        write(buffer: Buffer): string,
            end(): string
    }
    declare export var StringDecoder: {
        new(encoding?: string): NodeStringDecoder
    };
}
declare module 'tls' {
    declare var CLIENT_RENEG_LIMIT: number;
    declare var CLIENT_RENEG_WINDOW: number;
    declare export interface TlsOptions {
        pfx?: any,
            key?: any,
            passphrase?: string,
            cert?: any,
            ca?: any,
            crl?: any,
            ciphers?: string,
            honorCipherOrder?: any,
            requestCert?: boolean,
            rejectUnauthorized?: boolean,
            NPNProtocols?: any,
            SNICallback?: (servername: string) => any
    }
    declare export interface ConnectionOptions {
        host?: string,
            port?: number,
            socket?: net.Socket,
            pfx?: any,
            key?: any,
            passphrase?: string,
            cert?: any,
            ca?: any,
            rejectUnauthorized?: boolean,
            NPNProtocols?: any,
            servername?: string
    }
    declare export type Server = {
        listen(port: number, hostname?: string, backlog?: number, callback?: Function): Server,
        listen(path: string, callback?: Function): Server,
        listen(handle: any, listeningListener?: Function): Server,
        close(cb?: any): Server,
        address(): {
            port: number,
            family: string,
            address: string
        },
        maxHeadersCount: number
    }
    declare export type ClearTextStream = {
        authorized: boolean,
        authorizationError: Error,
        getPeerCertificate(): any,
        getCipher: {
            name: string,
            version: string
        },
        address: {
            port: number,
            family: string,
            address: string
        },
        remoteAddress: string,
        remotePort: number
    }
    declare export interface SecurePair {
        encrypted: any,
            cleartext: any
    }
    declare export function createServer(
        requestListener?: (request: ServerRequest, response: ServerResponse) => void): Server
    declare export function connect(
        options: {
            port: number,
            host?: string,
            localAddress?: string,
            allowHalfOpen?: boolean
        },
        connectionListener?: Function): Socket
    declare export function createSecurePair(
        credentials?: crypto.Credentials,
        isServer?: boolean,
        requestCert?: boolean,
        rejectUnauthorized?: boolean): SecurePair
}
declare module 'crypto' {
    declare export interface CredentialDetails {
        pfx: string,
            key: string,
            passphrase: string,
            cert: string,
            ca: any,
            crl: any,
            ciphers: string
    }
    declare export interface Credentials {
        context?: any
    }
    declare export function createCredentials(details: CredentialDetails): Credentials
    declare export function createHash(algorithm: string): Hash
    declare export function createHmac(algorithm: string, key: string): Hmac
    declare interface Hash {
        update(data: any, input_encoding?: string): Hash,
            digest(encoding: "buffer"): Buffer,
            digest(encoding: string): any,
            digest(): Buffer
    }
    declare interface Hmac {
        update(data: any, input_encoding?: string): Hmac,
            digest(encoding: "buffer"): Buffer,
            digest(encoding: string): any,
            digest(): Buffer
    }
    declare export function createCipher(algorithm: string, password: any): Cipher
    declare export function createCipheriv(algorithm: string, key: any, iv: any): Cipher
    declare interface Cipher {
        update(data: any, input_encoding?: string, output_encoding?: string): string,
            final(output_encoding?: string): string,
            setAutoPadding(auto_padding: boolean): void
    }
    declare export function createDecipher(algorithm: string, password: any): Decipher
    declare export function createDecipheriv(algorithm: string, key: any, iv: any): Decipher
    declare interface Decipher {
        update(data: any, input_encoding?: string, output_encoding?: string): void,
            final(output_encoding?: string): string,
            setAutoPadding(auto_padding: boolean): void
    }
    declare export function createSign(algorithm: string): Signer
    declare type Signer = {
        update(data: any): void,
        sign(private_key: string, output_format: string): string
    }
    declare export function createVerify(algorith: string): Verify
    declare type Verify = {
        update(data: any): void,
        verify(object: string, signature: string, signature_format?: string): boolean,
        objectMode?: boolean
    }
    declare export function createDiffieHellman(prime_length: number): DiffieHellman
    declare interface DiffieHellman {
        generateKeys(encoding?: string): string,
            computeSecret(
                other_public_key: string,
                input_encoding?: string,
                output_encoding?: string): string,
            getPrime(encoding?: string): string,
            getGenerator(encoding: string): string,
            getPublicKey(encoding?: string): string,
            getPrivateKey(encoding?: string): string,
            setPublicKey(public_key: string, encoding?: string): void,
            setPrivateKey(public_key: string, encoding?: string): void
    }
    declare export function getDiffieHellman(group_name: string): DiffieHellman
    declare export function pbkdf2(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number,
        callback: (err: Error, derivedKey: Buffer) => any): void
    declare export function pbkdf2Sync(
        password: string | Buffer,
        salt: string | Buffer,
        iterations: number,
        keylen: number): Buffer
    declare export function randomBytes(size: number): Buffer
    declare export function pseudoRandomBytes(size: number): Buffer
}
declare module 'stream' {
    declare export type Stream = {
        pipe<T>(destination: T, options?: {
            end?: boolean
        }): T
    }
    declare export interface ReadableOptions {
        highWaterMark?: number,
            encoding?: string,
            objectMode?: boolean
    }
    declare export class Readable mixins events.EventEmitter, NodeJS$ReadableStream {
        readable: boolean;
        constructor(opts?: ReadableOptions): this;
        _read(size: number): void;
        read(size?: number): any;
        setEncoding(encoding: string): void;
        pause(): void;
        resume(): void;
        pipe<T>(destination: T, options?: {
            end?: boolean
        }): T;
        unpipe<T>(destination?: T): void;
        unshift(chunk: string): void;
        unshift(chunk: Buffer): void;
        wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream;
        push(chunk: any, encoding?: string): boolean
    }
    declare export interface WritableOptions {
        highWaterMark?: number,
            decodeStrings?: boolean,
            objectMode?: boolean
    }
    declare export class Writable mixins events.EventEmitter, NodeJS$WritableStream {
        writable: boolean;
        constructor(opts?: WritableOptions): this;
        _write(data: Buffer, encoding: string, callback: Function): void;
        _write(data: string, encoding: string, callback: Function): void;
        write(buffer: Buffer, cb?: Function): boolean;
        write(str: string, cb?: Function): boolean;
        write(str: string, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(buffer: Buffer, cb?: Function): void;
        end(str: string, cb?: Function): void;
        end(str: string, encoding?: string, cb?: Function): void
    }
    declare export type DuplexOptions = {
        allowHalfOpen?: boolean
    } & ReadableOptions & WritableOptions

    declare export class Duplex mixins Readable, NodeJS$ReadWriteStream {
        writable: boolean;
        constructor(opts?: DuplexOptions): this;
        _write(data: Buffer, encoding: string, callback: Function): void;
        _write(data: string, encoding: string, callback: Function): void;
        write(buffer: Buffer, cb?: Function): boolean;
        write(str: string, cb?: Function): boolean;
        write(str: string, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(buffer: Buffer, cb?: Function): void;
        end(str: string, cb?: Function): void;
        end(str: string, encoding?: string, cb?: Function): void
    }
    declare export type TransformOptions = {} & ReadableOptions & WritableOptions

    declare export class Transform mixins events.EventEmitter, NodeJS$ReadWriteStream {
        readable: boolean;
        writable: boolean;
        constructor(opts?: TransformOptions): this;
        _transform(chunk: Buffer, encoding: string, callback: Function): void;
        _transform(chunk: string, encoding: string, callback: Function): void;
        _flush(callback: Function): void;
        read(size?: number): any;
        setEncoding(encoding: string): void;
        pause(): void;
        resume(): void;
        pipe<T>(destination: T, options?: {
            end?: boolean
        }): T;
        unpipe<T>(destination?: T): void;
        unshift(chunk: string): void;
        unshift(chunk: Buffer): void;
        wrap(oldStream: NodeJS$ReadableStream): NodeJS$ReadableStream;
        push(chunk: any, encoding?: string): boolean;
        write(buffer: Buffer, cb?: Function): boolean;
        write(str: string, cb?: Function): boolean;
        write(str: string, encoding?: string, cb?: Function): boolean;
        end(): void;
        end(buffer: Buffer, cb?: Function): void;
        end(str: string, cb?: Function): void;
        end(str: string, encoding?: string, cb?: Function): void
    }
    declare export class PassThrough mixins Transform {}
}
declare module 'util' {
    declare export interface InspectOptions {
        showHidden?: boolean,
            depth?: number,
            colors?: boolean,
            customInspect?: boolean
    }
    declare export function format(url: Url): string
    declare export function deprecate(fn: Function, msg: string): Function
    declare export function debuglog(set: string): Function
    declare export function inspect(object: any, showHidden?: boolean, depth?: number, color?: boolean): string
    declare export function isArray(object: any): boolean
    declare export function isBoolean(arg: any): boolean
    declare export function isNull(arg: any): boolean
    declare export function isNullOrUndefined(arg: any): boolean
    declare export function isNumber(arg: any): boolean
    declare export function isString(arg: any): boolean
    declare export function isSymbol(arg: any): boolean
    declare export function isUndefined(arg: any): boolean
    declare export function isRegExp(arg: any): boolean
    declare export function isObject(arg: any): boolean
    declare export function isDate(arg: any): boolean
    declare export function isError(arg: any): boolean
    declare export function isFunction(arg: any): boolean
    declare export function isPrimitive(arg: any): boolean
    declare export function isBuffer(arg: any): boolean
    declare export function log(...arg: any[]): void
    declare export function inherits(constructor: any, superConstructor: any): void
    declare export function p(...arg: any[]): void
    declare export function exec(
        command: string,
        options: {
            cwd?: string,
            stdio?: any,
            customFds?: any,
            env?: any,
            encoding?: string,
            timeout?: number,
            maxBuffer?: number,
            killSignal?: string
        },
        callback: (error: Error, stdout: Buffer, stderr: Buffer) => void): ChildProcess
    declare export function print(...arg: any[]): void
    declare export function puts(...arg: any[]): void
    declare export function debug(string: string): void
    declare export function error(...arg: any[]): void
}
declare module 'assert' {
    declare module.exports: typeof internal

    declare var npm$namespace$internal: {
        fail: typeof internal$fail,
        ok: typeof internal$ok,
        equal: typeof internal$equal,
        notEqual: typeof internal$notEqual,
        deepEqual: typeof internal$deepEqual,
        notDeepEqual: typeof internal$notDeepEqual,
        strictEqual: typeof internal$strictEqual,
        notStrictEqual: typeof internal$notStrictEqual,
        ifError: typeof internal$ifError,
    }
    declare export class AssertionError mixins Error {
        name: string;
        message: string;
        actual: any;
        expected: any;
        operator: string;
        generatedMessage: boolean;
        constructor(options?: {
            message?: string,
            actual?: any,
            expected?: any,
            operator?: string,
            stackStartFunction?: Function
        }): this
    }

    declare export function internal$fail(actual?: any, expected?: any, message?: string, operator?: string): void

    declare export function internal$ok(value: any, message?: string): void

    declare export function internal$equal(actual: any, expected: any, message?: string): void

    declare export function internal$notEqual(actual: any, expected: any, message?: string): void

    declare export function internal$deepEqual(actual: any, expected: any, message?: string): void

    declare export function internal$notDeepEqual(acutal: any, expected: any, message?: string): void

    declare export function internal$strictEqual(actual: any, expected: any, message?: string): void

    declare export function internal$notStrictEqual(actual: any, expected: any, message?: string): void

    declare export var throws: {
        (block: Function, message?: string): void,
        (block: Function, error: Function, message?: string): void,
        (block: Function, error: RegExp, message?: string): void,
        (block: Function, error: (err: any) => boolean, message?: string): void
    };

    declare export var doesNotThrow: {
        (block: Function, message?: string): void,
        (block: Function, error: Function, message?: string): void,
        (block: Function, error: RegExp, message?: string): void,
        (block: Function, error: (err: any) => boolean, message?: string): void
    };

    declare export function internal$ifError(value: any): void
}
declare module 'tty' {
    declare export function isatty(fd: number): boolean
    declare export type ReadStream = {}
    declare export type WriteStream = {}
}
declare module 'domain' {
    declare export class Domain mixins events.EventEmitter {
        run(fn: Function): void;
        add(emitter: events.EventEmitter): void;
        remove(emitter: events.EventEmitter): void;
        bind(cb: (err: Error, data: any) => any): any;
        intercept(cb: (data: any) => any): any;
        dispose(): void
    }
    declare export function create(): Domain
}