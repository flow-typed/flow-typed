// @flow
/**
 * Flowtype definitions for prelude-ls
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'prelude-ls' {

    declare     var npm$namespace$PreludeLS: {
        id: typeof PreludeLS$id,
        isType: typeof PreludeLS$isType,
        replicate: typeof PreludeLS$replicate,
        each: typeof PreludeLS$each,
        map: typeof PreludeLS$map,
        compact: typeof PreludeLS$compact,
        filter: typeof PreludeLS$filter,
        reject: typeof PreludeLS$reject,
        partition: typeof PreludeLS$partition,
        find: typeof PreludeLS$find,
        head: typeof PreludeLS$head,
        tail: typeof PreludeLS$tail,
        last: typeof PreludeLS$last,
        initial: typeof PreludeLS$initial,
        empty: typeof PreludeLS$empty,
        reverse: typeof PreludeLS$reverse,
        unique: typeof PreludeLS$unique,
        uniqueBy: typeof PreludeLS$uniqueBy,
        fold: typeof PreludeLS$fold,
        foldl: typeof PreludeLS$foldl,
        fold1: typeof PreludeLS$fold1,
        foldl1: typeof PreludeLS$foldl1,
        foldr: typeof PreludeLS$foldr,
        foldr1: typeof PreludeLS$foldr1,
        unfoldr: typeof PreludeLS$unfoldr,
        concat: typeof PreludeLS$concat,
        concatMap: typeof PreludeLS$concatMap,
        flatten: typeof PreludeLS$flatten,
        difference: typeof PreludeLS$difference,
        intersection: typeof PreludeLS$intersection,
        union: typeof PreludeLS$union,
        countBy: typeof PreludeLS$countBy,
        groupBy: typeof PreludeLS$groupBy,
        andList: typeof PreludeLS$andList,
        orList: typeof PreludeLS$orList,
        any: typeof PreludeLS$any,
        all: typeof PreludeLS$all,
        sort: typeof PreludeLS$sort,
        sortWith: typeof PreludeLS$sortWith,
        sortBy: typeof PreludeLS$sortBy,
        sum: typeof PreludeLS$sum,
        product: typeof PreludeLS$product,
        mean: typeof PreludeLS$mean,
        maximum: typeof PreludeLS$maximum,
        minimum: typeof PreludeLS$minimum,
        maximumBy: typeof PreludeLS$maximumBy,
        minimumBy: typeof PreludeLS$minimumBy,
        scan: typeof PreludeLS$scan,
        scanl: typeof PreludeLS$scanl,
        scan1: typeof PreludeLS$scan1,
        scanl1: typeof PreludeLS$scanl1,
        scanr: typeof PreludeLS$scanr,
        scanr1: typeof PreludeLS$scanr1,
        slice: typeof PreludeLS$slice,
        take: typeof PreludeLS$take,
        drop: typeof PreludeLS$drop,
        splitAt: typeof PreludeLS$splitAt,
        takeWhile: typeof PreludeLS$takeWhile,
        dropWhile: typeof PreludeLS$dropWhile,
        span: typeof PreludeLS$span,
        breakList: typeof PreludeLS$breakList,
        zip: typeof PreludeLS$zip,
        zipWith: typeof PreludeLS$zipWith,
        zipAll: typeof PreludeLS$zipAll,
        zipAllWith: typeof PreludeLS$zipAllWith,
        at: typeof PreludeLS$at,
        elemIndex: typeof PreludeLS$elemIndex,
        elemIndices: typeof PreludeLS$elemIndices,
        findIndex: typeof PreludeLS$findIndex,
        findIndices: typeof PreludeLS$findIndices,
        keys: typeof PreludeLS$keys,
        values: typeof PreludeLS$values,
        pairsToObj: typeof PreludeLS$pairsToObj,
        objToPairs: typeof PreludeLS$objToPairs,
        listsToObj: typeof PreludeLS$listsToObj,
        objToLists: typeof PreludeLS$objToLists,
        split: typeof PreludeLS$split,
        join: typeof PreludeLS$join,
        lines: typeof PreludeLS$lines,
        unlines: typeof PreludeLS$unlines,
        words: typeof PreludeLS$words,
        unwords: typeof PreludeLS$unwords,
        chars: typeof PreludeLS$chars,
        unchars: typeof PreludeLS$unchars,
        repeat: typeof PreludeLS$repeat,
        capitalize: typeof PreludeLS$capitalize,
        camelize: typeof PreludeLS$camelize,
        dasherize: typeof PreludeLS$dasherize,
        breakStr: typeof PreludeLS$breakStr,
        apply: typeof PreludeLS$apply,
        curry: typeof PreludeLS$curry,
        flip: typeof PreludeLS$flip,
        fix: typeof PreludeLS$fix,
        over: typeof PreludeLS$over,
        max: typeof PreludeLS$max,
        min: typeof PreludeLS$min,
        negate: typeof PreludeLS$negate,
        abs: typeof PreludeLS$abs,
        signum: typeof PreludeLS$signum,
        quot: typeof PreludeLS$quot,
        rem: typeof PreludeLS$rem,
        div: typeof PreludeLS$div,
        mod: typeof PreludeLS$mod,
        recip: typeof PreludeLS$recip,
        exp: typeof PreludeLS$exp,
        sqrt: typeof PreludeLS$sqrt,
        ln: typeof PreludeLS$ln,
        pow: typeof PreludeLS$pow,
        sin: typeof PreludeLS$sin,
        cos: typeof PreludeLS$cos,
        tan: typeof PreludeLS$tan,
        asin: typeof PreludeLS$asin,
        acos: typeof PreludeLS$acos,
        atan: typeof PreludeLS$atan,
        atan2: typeof PreludeLS$atan2,
        truncate: typeof PreludeLS$truncate,
        round: typeof PreludeLS$round,
        ceiling: typeof PreludeLS$ceiling,
        floor: typeof PreludeLS$floor,
        isItNaN: typeof PreludeLS$isItNaN,
        even: typeof PreludeLS$even,
        odd: typeof PreludeLS$odd,
        gcd: typeof PreludeLS$gcd,
        lcm: typeof PreludeLS$lcm,
    }
    declare     export function PreludeLS$id<A>(x: A): A

    declare     export function PreludeLS$isType<A>(type: string): (x: A) => boolean

    declare     export function PreludeLS$replicate<A>(n: number): (x: A) => A[]

    declare     export function PreludeLS$each<A>(f: (x: A) => void): (xs: A[]) => A[]

    declare     export function PreludeLS$map<A, B>(f: (x: A) => B): (xs: A[]) => B[]

    declare     export function PreludeLS$compact<A>(xs: A[]): A[]

    declare     export function PreludeLS$filter<A>(f: (x: A) => boolean): (xs: A[]) => A[]

    declare     export function PreludeLS$reject<A>(f: (x: A) => boolean): (xs: A[]) => A[]

    declare     export function PreludeLS$partition<A>(f: (x: A) => Boolean): (xs: A[]) => [A[], A[]]

    declare     export function PreludeLS$find<A>(f: (x: A) => Boolean): (xs: A[]) => A

    declare     export function PreludeLS$head<A>(xs: A[]): A

    declare     export function PreludeLS$tail<A>(xs: A[]): A[]

    declare     export function PreludeLS$last<A>(xs: A[]): A

    declare     export function PreludeLS$initial<A>(xs: A[]): A[]

    declare     export function PreludeLS$empty<A>(xs: A[]): boolean

    declare     export function PreludeLS$reverse<A>(xs: A[]): A[]

    declare     export function PreludeLS$unique<A>(xs: A[]): A[]

    declare     export function PreludeLS$uniqueBy<A, B>(f: (x: A) => B): (xs: A[]) => A[]

    declare     export function PreludeLS$fold<A, B>(f: (x: A) => (y: B) => A): (memo: A) => (xs: B[]) => A

    declare     export function PreludeLS$foldl<A, B>(f: (x: A) => (y: B) => A): (memo: A) => (xs: B[]) => A

    declare     export function PreludeLS$fold1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A

    declare     export function PreludeLS$foldl1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A

    declare     export function PreludeLS$foldr<A, B>(f: (x: A) => (y: B) => B): (memo: B) => (xs: A[]) => B

    declare     export function PreludeLS$foldr1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A

    declare     export function PreludeLS$unfoldr<A, B>(f: (x: B) => ([A, B] | void)): (x: B) => A[]

    declare     export function PreludeLS$concat<A>(xss: A[][]): A[]

    declare     export function PreludeLS$concatMap<A, B>(f: (x: A) => B[]): (xs: A[]) => B[]

    declare     export function PreludeLS$flatten(xs: any[]): any[]

    declare     export function PreludeLS$difference<A>(...xss: A[][]): A[]

    declare     export function PreludeLS$intersection<A>(...xss: A[][]): A[]

    declare     export function PreludeLS$union<A>(...xss: A[][]): A[]

    declare     export function PreludeLS$countBy<A, B>(f: (x: A) => B): (xs: A[]) => any

    declare     export function PreludeLS$groupBy<A, B>(f: (x: A) => B): (xs: A[]) => any

    declare     export function PreludeLS$andList<A>(xs: A[]): boolean

    declare     export function PreludeLS$orList<A>(xs: A[]): boolean

    declare     export function PreludeLS$any<A>(f: (x: A) => boolean): (xs: A[]) => boolean

    declare     export function PreludeLS$all<A>(f: (x: A) => boolean): (xs: A[]) => boolean

    declare     export function PreludeLS$sort<A>(xs: A[]): A[]

    declare     export function PreludeLS$sortWith<A>(f: (x: A) => (y: A) => number): (xs: A[]) => A[]

    declare     export function PreludeLS$sortBy<A, B>(f: (x: A) => B): (xs: A[]) => A[]

    declare     export function PreludeLS$sum(xs: number[]): number

    declare     export function PreludeLS$product(xs: number[]): number

    declare     export function PreludeLS$mean(xs: number[]): number

    declare     export function PreludeLS$maximum<A>(xs: A[]): A

    declare     export function PreludeLS$minimum<A>(xs: A[]): A

    declare     export function PreludeLS$maximumBy<A, B>(f: (x: A) => B): (xs: A[]) => A

    declare     export function PreludeLS$minimumBy<A, B>(f: (x: A) => B): (xs: A[]) => A

    declare     export function PreludeLS$scan<A, B>(f: (x: A) => (y: B) => A): (memo: A) => (xs: B[]) => A[]

    declare     export function PreludeLS$scanl<A, B>(f: (x: A) => (y: B) => A): (memo: A) => (xs: B[]) => A[]

    declare     export function PreludeLS$scan1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A[]

    declare     export function PreludeLS$scanl1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A[]

    declare     export function PreludeLS$scanr<A, B>(f: (x: A) => (y: B) => B): (memo: B) => (xs: A[]) => B[]

    declare     export function PreludeLS$scanr1<A>(f: (x: A) => (y: A) => A): (xs: A[]) => A[]

    declare     export function PreludeLS$slice<A>(x: number): (y: number) => (xs: A[]) => A[]

    declare     export function PreludeLS$take<A>(n: number): (xs: A[]) => A[]

    declare     export function PreludeLS$drop<A>(n: number): (xs: A[]) => A[]

    declare     export function PreludeLS$splitAt<A>(n: number): (xs: A[]) => [A[], A[]]

    declare     export function PreludeLS$takeWhile<A>(p: (x: A) => boolean): (xs: A[]) => A[]

    declare     export function PreludeLS$dropWhile<A>(p: (x: A) => boolean): (xs: A[]) => A[]

    declare     export function PreludeLS$span<A>(p: (x: A) => boolean): (xs: A[]) => [A[], A[]]

    declare     export function PreludeLS$breakList<A>(p: (x: A) => boolean): (xs: A[]) => [A[], A[]]

    declare     export function PreludeLS$zip<A, B>(xs: A[]): (ys: B[]) => [A, B][]

    declare     export function PreludeLS$zipWith<A, B, C>(f: (x: A) => (y: B) => C): (xs: A[]) => (ys: B[]) => C[]

    declare     export function PreludeLS$zipAll<A>(...xss: A[][]): A[][]

    declare     export function PreludeLS$zipAllWith<A, B>(f: (...xs: A[]) => B, ...xss: A[][]): B[]

    declare     export function PreludeLS$at<A>(n: number): (xs: A[]) => A

    declare     export function PreludeLS$elemIndex<A>(x: A): (xs: A[]) => number

    declare     export function PreludeLS$elemIndices<A>(x: A): (xs: A[]) => number[]

    declare     export function PreludeLS$findIndex<A>(f: (x: A) => boolean): (xs: A[]) => number

    declare     export function PreludeLS$findIndices<A>(f: (x: A) => boolean): (xs: A[]) => number[]

    declare     export function PreludeLS$keys<A>(object: {
        [key: string]: A
    }): string[]

    declare     export function PreludeLS$values<A>(object: {
        [key: string]: A
    }): A[]

    declare     export function PreludeLS$pairsToObj<A>(object: [string, A][]): {
        [key: string]: A
    }

    declare     export function PreludeLS$objToPairs<A>(object: {
        [key: string]: A
    }): [string, A][]

    declare     export function PreludeLS$listsToObj<A>(keys: string[]): (values: A[]) => {
        [key: string]: A
    }

    declare     export function PreludeLS$objToLists<A>(object: {
        [key: string]: A
    }): [string[], A[]]

    declare module 'Obj' {
        declare         export function empty<A>(xs: A[]): boolean
        declare         export function each<A>(f: (x: A) => void): (xs: A[]) => A[]
        declare         export function map<A, B>(f: (x: A) => B): (xs: A[]) => B[]
        declare         export function compact<A>(xs: A[]): A[]
        declare         export function filter<A>(f: (x: A) => boolean): (xs: A[]) => A[]
        declare         export function reject<A>(f: (x: A) => boolean): (xs: A[]) => A[]
        declare         export function partition<A>(f: (x: A) => Boolean): (xs: A[]) => [A[], A[]]
        declare         export function find<A>(f: (x: A) => Boolean): (xs: A[]) => A
    }


    declare     export function PreludeLS$split(separator: string): (str: string) => string[]

    declare     export function PreludeLS$join(separator: string): (xs: string[]) => string

    declare     export function PreludeLS$lines(str: string): string[]

    declare     export function PreludeLS$unlines(xs: string[]): string

    declare     export function PreludeLS$words(str: string): string[]

    declare     export function PreludeLS$unwords(xs: string[]): string

    declare     export function PreludeLS$chars(str: string): string[]

    declare     export function PreludeLS$unchars(xs: string[]): string

    declare     export function PreludeLS$repeat(n: number): (str: string) => string

    declare     export function PreludeLS$capitalize(str: string): string

    declare     export function PreludeLS$camelize(str: string): string

    declare     export function PreludeLS$dasherize(str: string): string

    declare     export function PreludeLS$breakStr(f: (str: string) => boolean): (str: string) => [string, string]

    declare module 'Str' {
        declare         export function empty<A>(xs: A[]): boolean
        declare         export function reverse<A>(xs: A[]): A[]
        declare         export function slice<A>(x: number): (y: number) => (xs: A[]) => A[]
        declare         export function take<A>(n: number): (xs: A[]) => A[]
        declare         export function drop<A>(n: number): (xs: A[]) => A[]
        declare         export function splitAt<A>(n: number): (xs: A[]) => [A[], A[]]
        declare         export function takeWhile<A>(p: (x: A) => boolean): (xs: A[]) => A[]
        declare         export function dropWhile<A>(p: (x: A) => boolean): (xs: A[]) => A[]
        declare         export function span<A>(p: (x: A) => boolean): (xs: A[]) => [A[], A[]]
        declare         export function breakStr(f: (str: string) => boolean): (str: string) => [string, string]
    }


    declare     export function PreludeLS$apply<A, B>(f: (...args: A[]) => B): (args: A[]) => B

    declare     export function PreludeLS$curry(f: Function): Function

    declare     export function PreludeLS$flip<A, B, C>(f: (x: A) => (y: B) => C): (y: B) => (x: A) => C

    declare     export function PreludeLS$fix(f: Function): Function

    declare     export function PreludeLS$over<A, B, C>(f: (x: B) => (y: B) => C): (g: (x: A) => B) => (x: A) => (y: A) => C

    declare     export function PreludeLS$max<Comparable>(x: Comparable): (y: Comparable) => Comparable

    declare     export function PreludeLS$min<Comparable>(x: Comparable): (y: Comparable) => Comparable

    declare     export function PreludeLS$negate(x: number): number

    declare     export function PreludeLS$abs(x: number): number

    declare     export function PreludeLS$signum(x: number): number

    declare     export function PreludeLS$quot(x: number): (y: number) => number

    declare     export function PreludeLS$rem(x: number): (y: number) => number

    declare     export function PreludeLS$div(x: number): (y: number) => number

    declare     export function PreludeLS$mod(x: number): (y: number) => number

    declare     export function PreludeLS$recip(x: number): number

    declare     export var pi: number;

    declare     export var tau: number;

    declare     export function PreludeLS$exp(x: number): number

    declare     export function PreludeLS$sqrt(x: number): number

    declare     export function PreludeLS$ln(x: number): number

    declare     export function PreludeLS$pow(x: number): (y: number) => number

    declare     export function PreludeLS$sin(x: number): number

    declare     export function PreludeLS$cos(x: number): number

    declare     export function PreludeLS$tan(x: number): number

    declare     export function PreludeLS$asin(x: number): number

    declare     export function PreludeLS$acos(x: number): number

    declare     export function PreludeLS$atan(x: number): number

    declare     export function PreludeLS$atan2(x: number, y: number): number

    declare     export function PreludeLS$truncate(x: number): number

    declare     export function PreludeLS$round(x: number): number

    declare     export function PreludeLS$ceiling(x: number): number

    declare     export function PreludeLS$floor(x: number): number

    declare     export function PreludeLS$isItNaN(x: number): boolean

    declare     export function PreludeLS$even(x: number): boolean

    declare     export function PreludeLS$odd(x: number): boolean

    declare     export function PreludeLS$gcd(x: number): (y: number) => number

    declare     export function PreludeLS$lcm(x: number): (y: number) => number
    declare module.exports: typeof PreludeLS
}