/**
 * Flowtype definitions for express-serve-static-core
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
export interface Express$Request {}

declare
export interface Express$Response {}

declare
export interface Express$Application {}
declare module 'express-serve-static-core' {

    declare interface NextFunction {
        (err?: any): void
    }
    declare interface RequestHandler {
        (req: Express$Request, res: Express$Response, next: NextFunction): any
    }
    declare interface ErrorRequestHandler {
        (err: any, req: Express$Request, res: Express$Response, next: NextFunction): any
    }
    declare type PathParams = string | RegExp | (string | RegExp)[];
    declare type RequestHandlerParams = RequestHandler | ErrorRequestHandler | (RequestHandler | ErrorRequestHandler)[];
    declare interface IRouterMatcher<T>{
        (path: PathParams, ...handlers: RequestHandler[]): T,
        (path: PathParams, ...handlers: RequestHandlerParams[]): T
    }
    declare interface IRouterHandler<T>{
        (...handlers: RequestHandler[]): T,
        (...handlers: RequestHandlerParams[]): T
    }
    declare type IRouter = {

        /**
         * Map the given param placeholder `name`(s) to the given callback(s).
         * 
        Parameter mapping is used to provide pre-conditions to routes
        which use normalized placeholders. For example a _:user_id_ parameter
        could automatically load a user's information from the database without
        any additional code,

        The callback uses the samesignature as middleware, the only differencing
        being that the value of the placeholder is passed, in this case the _id_
        of the user. Once the `next()` function is invoked, just like middleware
        it will continue on to execute the route, or subsequent parameter functions.

              app.param('user_id', function(req, res, next, id){
                User.find(id, function(err, user){
                  if (err) {
                    next(err);
                  } else if (user) {
                    req.user = user;
                    next();
                  } else {
                    next(new Error('failed to load user'));
                  }
                });
              });
         * @param name 
         * @param fn 
        */
        param(name: string, handler: RequestParamHandler): this,
        param(callback: (name: string, matcher: RegExp) => RequestParamHandler): this,

        /**
         * Special-cased "all" method, applying the given route `path`,
         * middleware, and callback to _every_ HTTP method.
         * @param path 
         * @param fn 
         */
        all: IRouterMatcher<this>,
        get: IRouterMatcher<this>,
        post: IRouterMatcher<this>,
        put: IRouterMatcher<this>,
        delete: IRouterMatcher<this>,
        patch: IRouterMatcher<this>,
        options: IRouterMatcher<this>,
        head: IRouterMatcher<this>,
        checkout: IRouterMatcher<this>,
        copy: IRouterMatcher<this>,
        lock: IRouterMatcher<this>,
        merge: IRouterMatcher<this>,
        mkactivity: IRouterMatcher<this>,
        mkcol: IRouterMatcher<this>,
        move: IRouterMatcher<this>,
        m - search: IRouterMatcher<this>,
        notify: IRouterMatcher<this>,
        purge: IRouterMatcher<this>,
        report: IRouterMatcher<this>,
        search: IRouterMatcher<this>,
        subscribe: IRouterMatcher<this>,
        trace: IRouterMatcher<this>,
        unlock: IRouterMatcher<this>,
        unsubscribe: IRouterMatcher<this>,
        use: IRouterHandler<this>& IRouterMatcher<this>,
        route(prefix: PathParams): IRoute,

        /**
         * Stack of configured routes
         */
        stack: any[]
    } & RequestHandler

    declare interface IRoute {
        path: string,
            stack: any,
            all: IRouterHandler<this>,
            get: IRouterHandler<this>,
            post: IRouterHandler<this>,
            put: IRouterHandler<this>,
            delete: IRouterHandler<this>,
            patch: IRouterHandler<this>,
            options: IRouterHandler<this>,
            head: IRouterHandler<this>,
            checkout: IRouterHandler<this>,
            copy: IRouterHandler<this>,
            lock: IRouterHandler<this>,
            merge: IRouterHandler<this>,
            mkactivity: IRouterHandler<this>,
            mkcol: IRouterHandler<this>,
            move: IRouterHandler<this>,
            m - search: IRouterHandler<this>,
            notify: IRouterHandler<this>,
            purge: IRouterHandler<this>,
            report: IRouterHandler<this>,
            search: IRouterHandler<this>,
            subscribe: IRouterHandler<this>,
            trace: IRouterHandler<this>,
            unlock: IRouterHandler<this>,
            unsubscribe: IRouterHandler<this >
    }
    declare export type Router = {} & IRouter

    declare interface CookieOptions {
        maxAge?: number,
            signed?: boolean,
            expires?: Date | boolean,
            httpOnly?: boolean,
            path?: string,
            domain?: string,
            secure?: boolean | "auto"
    }
    declare interface Errback {
        (err: Error): void
    }
    declare export interface Request {}
    declare interface MediaType {
        value: string,
            quality: number,
            type: string,
            subtype: string
    }
    declare interface Send {
        (status: number, body?: any): Express$Response,
        (body?: any): Express$Response
    }
    declare export interface Response {}
    declare type Handler = {} & RequestHandler

    declare interface RequestParamHandler {
        (req: Express$Request, res: Express$Response, next: NextFunction, value: any, name: string): any
    }
    declare export interface Application {}
    declare type Express = {
        request: Express$Request,
        response: Express$Response
    } & Express$Application

}