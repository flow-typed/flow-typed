/**
 * Flowtype definitions for js-combinatorics
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$___Combinatorics: {
    P: typeof ___Combinatorics$P,
    C: typeof ___Combinatorics$C,
    factorial: typeof ___Combinatorics$factorial,
    factoradic: typeof ___Combinatorics$factoradic,
    power: typeof ___Combinatorics$power,
    combination: typeof ___Combinatorics$combination,
    permutation: typeof ___Combinatorics$permutation,
    permutationCombination: typeof ___Combinatorics$permutationCombination,
    baseN: typeof ___Combinatorics$baseN,
    cartesianProduct: typeof ___Combinatorics$cartesianProduct,
}
declare interface ___Combinatorics$IGenerator<T>{

    /**
     * Returns the element or undefined if no more element is available.
     */
    next(): T,

    /**
     * Applies the callback function for each element.
     */
    forEach(f: (item: T) => void): void,

    /**
     * All elements at once with function applied to each element.
     */
    map<TResult>(f: (item: T) => TResult): TResult[],

    /**
     * Returns an array with elements that passes the filter function.
     */
    filter(predicate: (item: T) => boolean): T[],

    /**
     * All elements at once.
     */
    toArray(): T[],

    /**
     * Returns the number of elements to be generated which equals to generator.toArray().length
     * but it is precalculated without actually generating elements.
    Handy when you prepare for large iteration.
    */
    length: number
}

declare type ___Combinatorics$IPredictableGenerator<T>= {

    /**
     * Returns the nth element (starting 0).
     */
    nth(n: number): T
} & ___Combinatorics$IGenerator


declare type ___Combinatorics$ICartesianProductGenerator<T>= {

    /**
     * Arguments are coordinates in integer.
     * Arguments can be out of bounds but it returns undefined in such cases.
     */
    get(...coordinates: number[]): T
} & ___Combinatorics$IPredictableGenerator



/**
 * Calculates m P n
 */
declare function ___Combinatorics$P(m: number, n: number): number


/**
 * Calculates m C n
 */
declare function ___Combinatorics$C(m: number, n: number): number


/**
 * Calculates n!
 */
declare function ___Combinatorics$factorial(n: number): number


/**
 * Returns the factoradic representation of n in array, in least significant order.
 * See http://en.wikipedia.org/wiki/Factorial_number_system
 */
declare function ___Combinatorics$factoradic(n: number): number[]


/**
 * Generates the power set of array.
 */
declare function ___Combinatorics$power<T>(a: T[]): ___Combinatorics$IPredictableGenerator<T[] >


    /**
     * Generates the combination of array with n elements.
     * When n is ommited, the length of the array is used.
     */
    declare function ___Combinatorics$combination<T>(a: T[], n?: number): ___Combinatorics$IGenerator<T[] >


    /**
     * Generates the permutation of array with n elements.
     * When n is ommited, the length of the array is used.
     */
    declare function ___Combinatorics$permutation<T>(a: T[], n?: number): ___Combinatorics$IGenerator<T[] >


    /**
     * Generates the permutation of the combination of n.
     * Equivalent to permutation(combination(a)), but more efficient.
     */
    declare function ___Combinatorics$permutationCombination<T>(a: T[]): ___Combinatorics$IGenerator<T[] >


    /**
     * Generates n-digit "numbers" where each digit is an element in array.
     * Note this "number" is in the least significant order.
    When n is ommited, the length of the array is used.
    */
    declare function ___Combinatorics$baseN<T>(a: T[], n?: number): ___Combinatorics$IPredictableGenerator<T[] >


    /**
     * Generates the cartesian product of the arrays. All arguments must be arrays with more than one element.
     */
    declare function ___Combinatorics$cartesianProduct<T1>(a1: T1[]): ___Combinatorics$ICartesianProductGenerator<[T1] >

    declare var VERSION: string;
declare module 'js-combinatorics' {
    declare module.exports: typeof ___Combinatorics
}