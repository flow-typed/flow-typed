// @flow
/**
 * Flowtype definitions for sipml
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$SIPml: {
    getNavigatorFriendlyName: typeof SIPml$getNavigatorFriendlyName,
    getNavigatorVersion: typeof SIPml$getNavigatorVersion,
    getSystemFriendlyName: typeof SIPml$getSystemFriendlyName,
    getWebRtc4AllVersion: typeof SIPml$getWebRtc4AllVersion,
    haveMediaStream: typeof SIPml$haveMediaStream,
    init: typeof SIPml$init,
    isInitialized: typeof SIPml$isInitialized,
    isNavigatorOutdated: typeof SIPml$isNavigatorOutdated,
    isReady: typeof SIPml$isReady,
    isScreenShareSupported: typeof SIPml$isScreenShareSupported,
    isWebRtcPluginOutdated: typeof SIPml$isWebRtcPluginOutdated,
    isWebRtc4AllSupported: typeof SIPml$isWebRtc4AllSupported,
    isWebRtcSupported: typeof SIPml$isWebRtcSupported,
    isWebSocketSupported: typeof SIPml$isWebSocketSupported,
    setDebugLevel: typeof SIPml$setDebugLevel,
    setWebRtcType: typeof SIPml$setWebRtcType,
}
declare class Event {
    description: string;
    type: string;
    getContent(): Object;
    getContentString(): string;
    getContentType(): Object;
    getSipResponseCode(): number
}

declare class EventTarget<EventSubscriptionType, EventType>{
    addEventListener(type: Stack$EventSubscriptionType, listener: (e: EventType) => void): void;
    removeEventListener(type: Stack$EventSubscriptionType): void
}

declare class Session mixins EventTarget<Session$EventSubscriptionType, Session$Event>{
    accept(configuration?: Session$Configuration): number;
    getId(): number;
    getRemoteFriendlyName(): string;
    getRemoteUri(): string;
    reject(configuration?: Session$Configuration): number;
    setConfiguration(configuration?: Session$Configuration): void
}


/**
 * Should be
 * 
"*" |
"connecting" |
"connected" |
"terminating" |
"terminated" |
"i_ao_request" |
"media_added" |
"media_removed" |
"i_request" |
"o_request" |
"cancelled_request" |
"sent_request" |
"transport_error" |
"global_error" |
"message_error" |
"webrtc_error" |
*/
declare type Session$EventSubscriptionType = string;

declare interface Session$Configuration {
    audio_remote?: HTMLElement,
        bandwidth?: {
            audio: number,
            video: number
        },
        events_listener?: {
            events: Session$EventSubscriptionType | Session$EventSubscriptionType[],
            listener: (e: Session$Event) => void
        },
        expires?: number,
        from?: string,
        sip_caps?: Object[],
        sip_headers?: Object[],
        video_local?: HTMLElement,
        video_remote?: HTMLElement,
        video_size?: {
            minWidth?: number,
            maxWidth?: number,
            minHeight?: number,
            maxHeight?: number
        }
}

declare class Call mixins Session, EventTarget<Call$EventSubscriptionType, Session$Event>{
    acceptTransfer(configuration?: Session$Configuration): number;
    call(to: string, configuration?: Session$Configuration): number;
    dtmf(): number;
    hangup(configuration?: Session$Configuration): number;
    hold(configuration?: Session$Configuration): number;
    info(): number;
    rejectTransfer(): number;
    resume(): number;
    transfer(): number
}


/**
 * Should be
 * 
"*" |
"connecting" |
"connected" |
"terminating" |
"terminated" |
"i_ao_request" |
"media_added" |
"media_removed" |
"i_request" |
"o_request" |
"cancelled_request" |
"sent_request" |
"transport_error" |
"global_error" |
"message_error" |
"webrtc_error" |
*/
declare type Call$EventSubscriptionType = string;

declare class Event mixins SIPml$Event {
    session: SIPml$Session;
    getTransferDestinationFriendlyName(): string
}

declare class Message mixins Session {
    send(
        to: string,
        content?: any,
        contentType?: string,
        configuration?: Session$Configuration): number
}

declare class Publish mixins Session {
    publish(
        content?: any,
        contentType?: string,
        configuration?: Session$Configuration): number;
    unpublish(configuration?: Session$Configuration): void
}

declare class Registration mixins Session {
    register(configuration?: Session$Configuration): void;
    unregister(configuration?: Session$Configuration): void
}

declare class Subscribe mixins Session, EventTarget<Subscribe$EventSubscriptionType, Session$Event>{
    subscribe(to: string, configuration?: Session$Configuration): number;
    unsubscribe(configuration?: Session$Configuration): number
}


/**
 * Should be
 * 
"*" |
"connecting" |
"connected" |
"terminating" |
"terminated" |
"i_ao_request" |
"media_added" |
"media_removed" |
"i_request" |
"o_request" |
"cancelled_request" |
"sent_request" |
"transport_error" |
"global_error" |
"message_error" |
"webrtc_error" |
*/
declare type Subscribe$EventSubscriptionType = string;

declare class Stack mixins EventTarget<Stack$EventSubscriptionType, Stack$Event>{
    constructor(configuration?: Stack$Configuration): this;
    setConfiguration(configuration: Stack$Configuration): number;
    newSession(type: string, configuration?: Session$Configuration): any;
    start(): number;
    stop(timeout?: number): number
}


/**
 * Should be
 * 
"*" |
"connecting" |
"connected" |
"terminating" |
"terminated" |
"i_ao_request" |
"media_added" |
"media_removed" |
"i_request" |
"o_request" |
"cancelled_request" |
"sent_request" |
"transport_error" |
"global_error" |
"message_error" |
"webrtc_error" |
*/
declare type Stack$EventSubscriptionType = string;

declare interface Stack$Configuration {
    audio_remote?: HTMLElement,
        bandwidth?: {
            audio: number,
            video: number
        },
        events_listener?: {
            events: Stack$EventSubscriptionType | Stack$EventSubscriptionType[],
            listener: (e: Session$Event) => void
        },
        expires?: number,
        from?: string,
        sip_caps?: Object[],
        sip_headers?: Object[],
        video_local?: HTMLElement,
        video_remote?: HTMLElement,
        video_size?: {
            minWidth?: number,
            maxWidth?: number,
            minHeight?: number,
            maxHeight?: number
        }
}

declare class Event mixins SIPml$Event {
    description: string;
    newSession: SIPml$Session;
    type: string
}

declare function SIPml$getNavigatorFriendlyName(): string

declare function SIPml$getNavigatorVersion(): string

declare function SIPml$getSystemFriendlyName(): string

declare function SIPml$getWebRtc4AllVersion(): string

declare function SIPml$haveMediaStream(): boolean

declare function SIPml$init(readyCallback?: (e: any) => any, errorCallback?: (e: any) => any): boolean

declare function SIPml$isInitialized(): boolean

declare function SIPml$isNavigatorOutdated(): boolean

declare function SIPml$isReady(): boolean

declare function SIPml$isScreenShareSupported(): boolean

declare function SIPml$isWebRtcPluginOutdated(): boolean

declare function SIPml$isWebRtc4AllSupported(): boolean

declare function SIPml$isWebRtcSupported(): boolean

declare function SIPml$isWebSocketSupported(): boolean

declare function SIPml$setDebugLevel(level: string): void

declare function SIPml$setWebRtcType(type: string): boolean