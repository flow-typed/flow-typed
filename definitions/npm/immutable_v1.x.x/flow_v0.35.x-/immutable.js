/**
 * Flowtype definitions for immutable
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$Immutable: {
        fromJS: typeof Immutable$fromJS,
        is: typeof Immutable$is,
        List: typeof Immutable$List,
        Map: typeof Immutable$Map,
        OrderedMap: typeof Immutable$OrderedMap,
        Set: typeof Immutable$Set,
        OrderedSet: typeof Immutable$OrderedSet,
        Stack: typeof Immutable$Stack,
        Range: typeof Immutable$Range,
        Repeat: typeof Immutable$Repeat,
        Record: typeof Immutable$Record,
        Seq: typeof Immutable$Seq,
        Iterable: typeof Immutable$Iterable,
    }
    /**
     * Deeply converts plain JS objects and arrays to Immutable Maps and Lists.
     * 
    If a `reviver` is optionally provided, it will be called with every
    collection as a Seq (beginning with the most nested collections
    and proceeding to the top-level collection itself), along with the key
    refering to each collection and the parent JS object provided as `this`.
    For the top level, object, the key will be `""`. This `reviver` is expected
    to return a new Immutable Iterable, allowing for custom conversions from
    deep JS objects.

    This example converts JSON to List and OrderedMap:

         Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {
           var isIndexed = Immutable.Iterable.isIndexed(value);
           return isIndexed ? value.toList() : value.toOrderedMap();
         });

         // true, "b", {b: [10, 20, 30]}
         // false, "a", {a: {b: [10, 20, 30]}, c: 40}
         // false, "", {"": {a: {b: [10, 20, 30]}, c: 40}}

    If `reviver` is not provided, the default behavior will convert Arrays into
    Lists and Objects into Maps.

    `reviver` acts similarly to the [same parameter in `JSON.parse`][1].

    `Immutable.fromJS` is conservative in its conversion. It will only convert
    arrays which pass `Array.isArray` to Lists, and only raw objects (no custom
    prototype) to Map.

    Keep in mind, when using JS objects to construct Immutable Maps, that
    JavaScript Object properties are always strings, even if written in a
    quote-less shorthand, while Immutable Maps accept keys of any type.

    ```js
    var obj = { 1: "one" };
    Object.keys(obj); // [ "1" ]
    obj["1"]; // "one"
    obj[1];   // "one"

    var map = Map(obj);
    map.get("1"); // "one"
    map.get(1);   // undefined
    ```

    Property access for JavaScript Objects first converts the key to a string,
    but since Immutable Map keys can be of any type the argument to `get()` is
    not altered.

    [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter
          "Using the reviver parameter"
    */
declare export function Immutable$fromJS(json: any, reviver?: (k: any, v: Immutable$Iterable<any, any>) => any): any


/**
 * Value equality check with semantics similar to `Object.is`, but treats
 * Immutable `Iterable`s as values, equal if the second `Iterable` includes
equivalent values.

It's used throughout Immutable when checking for equality, including `Map`
key equality and `Set` membership.

     var map1 = Immutable.Map({a:1, b:1, c:1});
     var map2 = Immutable.Map({a:1, b:1, c:1});
     assert(map1 !== map2);
     assert(Object.is(map1, map2) === false);
     assert(Immutable.is(map1, map2) === true);

Note: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same
value, matching the behavior of ES6 Map key equality.
*/
declare export function Immutable$is(first: any, second: any): boolean


/**
 * Create a new immutable List containing the values of the provided
 * iterable-like.
 */
declare export function Immutable$List<T>(): Immutable$List<T >


    /**
     * Creates a new Immutable Map.
     * 
    Created with the same key value pairs as the provided Iterable.Keyed or
    JavaScript Object or expects an Iterable of [K, V] tuple entries.

         var newMap = Map({key: "value"});
         var newMap = Map([["key", "value"]]);

    Keep in mind, when using JS objects to construct Immutable Maps, that
    JavaScript Object properties are always strings, even if written in a
    quote-less shorthand, while Immutable Maps accept keys of any type.

    ```js
    var obj = { 1: "one" };
    Object.keys(obj); // [ "1" ]
    obj["1"]; // "one"
    obj[1];   // "one"

    var map = Map(obj);
    map.get("1"); // "one"
    map.get(1);   // undefined
    ```

    Property access for JavaScript Objects first converts the key to a string,
    but since Immutable Map keys can be of any type the argument to `get()` is
    not altered.
    */
    declare export function Immutable$Map<K, V>(): Immutable$Map<K, V >


    /**
     * Creates a new Immutable OrderedMap.
     * 
    Created with the same key value pairs as the provided Iterable.Keyed or
    JavaScript Object or expects an Iterable of [K, V] tuple entries.

    The iteration order of key-value pairs provided to this constructor will
    be preserved in the OrderedMap.

         var newOrderedMap = OrderedMap({key: "value"});
         var newOrderedMap = OrderedMap([["key", "value"]]);
    */
    declare export function Immutable$OrderedMap<K, V>(): Immutable$OrderedMap<K, V >


    /**
     * Create a new immutable Set containing the values of the provided
     * iterable-like.
     */
    declare export function Immutable$Set<T>(): Immutable$Set<T >


    /**
     * Create a new immutable OrderedSet containing the values of the provided
     * iterable-like.
     */
    declare export function Immutable$OrderedSet<T>(): Immutable$OrderedSet<T >


    /**
     * Create a new immutable Stack containing the values of the provided
     * iterable-like.

    The iteration order of the provided iterable is preserved in the
    resulting `Stack`.
    */
    declare export function Immutable$Stack<T>(): Immutable$Stack<T >


    /**
     * Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`
     * (exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to
    infinity. When `start` is equal to `end`, returns empty range.

         Range() // [0,1,2,3,...]
         Range(10) // [10,11,12,13,...]
         Range(10,15) // [10,11,12,13,14]
         Range(10,30,5) // [10,15,20,25]
         Range(30,10,5) // [30,25,20,15]
         Range(30,30,5) // []
    */
    declare export function Immutable$Range(start?: number, end?: number, step?: number): Seq.Indexed<number >


    /**
     * Returns a Seq.Indexed of `value` repeated `times` times. When `times` is
     * not defined, returns an infinite `Seq` of `value`.

         Repeat('foo') // ['foo','foo','foo',...]
         Repeat('bar',4) // ['bar','bar','bar','bar']
    */
    declare export function Immutable$Repeat<T>(value: T, times?: number): Seq.Indexed<T >

    declare export function Immutable$Record(defaultValues: {
    [key: string]: any
}, name?: string): Record.Class


/**
 * Creates a Seq.
 * 
Returns a particular kind of `Seq` based on the input.

   * If a `Seq`, that same `Seq`.
   * If an `Iterable`, a `Seq` of the same kind (Keyed, Indexed, or Set).
   * If an Array-like, an `Seq.Indexed`.
   * If an Object with an Iterator, an `Seq.Indexed`.
   * If an Iterator, an `Seq.Indexed`.
   * If an Object, a `Seq.Keyed`.
*/
declare export function Immutable$Seq<K, V>(): Immutable$Seq<K, V >


    /**
     * Creates an Iterable.
     * 
    The type of Iterable created is based on the input.

       * If an `Iterable`, that same `Iterable`.
       * If an Array-like, an `Iterable.Indexed`.
       * If an Object with an Iterator, an `Iterable.Indexed`.
       * If an Iterator, an `Iterable.Indexed`.
       * If an Object, an `Iterable.Keyed`.

    This methods forces the conversion of Objects and Strings to Iterables.
    If you want to ensure that a Iterable of one item is returned, use
    `Seq.of`.
    */
    declare export function Immutable$Iterable<K, V>(iterable: Immutable$Iterable<K, V>): Immutable$Iterable<K, V >

    declare export type Immutable$Collection<K, V>= {

    /**
     * All collections maintain their current `size` as an integer.
     */
    size: number
} & Immutable$Iterable



/**
 * ES6 Iterator.
 * 
This is not part of the Immutable library, but a common interface used by
many types in ES6 JavaScript.
 * @ignore  
*/
declare export interface Immutable$Iterator<T>{
    next(): {
        value: T,
        done: boolean
    }
}
declare module 'immutable' {
    declare module.exports: typeof Immutable
}