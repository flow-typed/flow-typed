/**
 * Flowtype definitions for SlickGrid
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare type DOMEvent = {} & Slick$Event

/**
 * slick.core.jsAn event object for passing data to event handlers and letting them control propagation.
 * <p>This is pretty much identical to how W3C and jQuery implement events.</p>
 * @class  EventData
 * @constructor  *
 */
declare export class EventData {
    constructor(): this;
    stopPropagation(): void;
    isPropagationStopped(): boolean;
    stopImmediatePropagation(): void;
    isImmediatePropagationStopped(): boolean
}

declare export class Event<T>{
    constructor(): this;
    subscribe(fn: (e: Slick$EventData, data: T) => any): void;
    subscribe(fn: (e: DOMEvent, data: T) => any): void;
    unsubscribe(fn: (e: Slick$EventData, data: T) => any): void;
    unsubscribe(fn: (e: DOMEvent, data: T) => any): void;
    notify(args?: T, e?: Slick$EventData, scope?: any): any;
    notify(args?: T, e?: DOMEvent, scope?: any): any
}

declare export class EventHandler {
    constructor(): this;
    subscribe(event: Slick$EventData, handler: Function): Slick$EventHandler;
    unsubscribe(event: Slick$EventData, handler: Function): Slick$EventHandler;
    unsubscribeAll(): Slick$EventHandler
}

declare export class Range {

    /**
     * A structure containing a range of cells.
     * @constructor  * 
     * @param fromRow Starting row.
     * @param fromCell Starting cell.
     * @param toRow Optional. Ending row. Defaults to <code>fromRow</code>.
     * @param toCell Optional. Ending cell. Defaults to <code>fromCell</code>.
     */
    constructor(fromRow: number, fromCell: number, toRow?: number, toCell?: number): this;
    fromRow: number;
    fromCell: number;
    toRow: number;
    toCell: number;
    isSingleRow(): boolean;
    isSingleCell(): boolean;
    contains(row: number, cell: number): boolean;
    toString(): string
}

declare export class NonDataRow {}

declare export class Group<T>mixins NonDataRow {
    constructor(): this;

    /**
     * Grouping level, starting with 0.
     * @property  level
     * @type  
     */
    level: number;
    count: number;
    value: any;
    title: string;
    collapsed: boolean;
    totals: Slick$GroupTotals<T>;

    /**
     * Rows that are part of the group.
     * @property  rows
     * @type  
     */
    rows: T[];

    /**
     * Sub-groups that are part of the group.
     * @property  groups
     * @type  
     */
    groups: Slick$Group<T>[];

    /**
     * A unique key used to identify the group.  This key can be used in calls to DataView
     * collapseGroup() or expandGroup().
     * @property  groupingKey
     * @type  
     */
    groupingKey: any;
    equals(group: Slick$Group<T>): boolean
}

declare export class GroupTotals<T>mixins NonDataRow {
    constructor(): this;
    group: Slick$Group<T >
}

declare export class EditorLock<T>{
    constructor(): this;
    isActive(editController: Editors.Editor<T>): boolean;
    activate(editController: Editors.Editor<T>): void;
    deactivate(editController: Editors.Editor<T>): void;
    commitCurrentEdit(): boolean;
    cancelCurrentEdit(): boolean
}

declare export var GlobalEditorLock: Slick$EditorLock<Slick$SlickData>;


/**
 * slick.grid.jsOptions which you can apply to the columns objects.
 */
declare export interface Slick$Column<T>{

    /**
     * This accepts a function of the form function(cellNode, row, dataContext, colDef) and is used to post-process the cell's DOM node / nodes
     * @param cellNode 
     * @param row 
     * @param dataContext 
     * @param colDef 
     * @return  *
     */
    asyncPostRender?: (cellNode: any, row: any, dataContext: any, colDef: any) => void,

    /**
     * Used by the the slick.rowMoveManager.js plugin for moving rows. Has no effect without the plugin installed.
     */
    behavior?: any,

    /**
     * In the "Add New" row, determines whether clicking cells in this column can trigger row addition. If true, clicking on the cell in this column in the "Add New" row will not trigger row addition.
     */
    cannotTriggerInsert?: boolean,

    /**
     * Accepts a string as a class name, applies that class to every row cell in the column.
     */
    cssClass?: string,

    /**
     * When set to true, the first user click on the header will do a descending sort. When set to false, the first user click on the header will do an ascending sort.
     */
    defaultSortAsc?: boolean,

    /**
     * The editor for cell edits {TextEditor, IntegerEditor, DateEditor...} See slick.editors.js
     */
    editor?: any,

    /**
     * The property name in the data object to pull content from. (This is assumed to be on the root of the data object.)
     */
    field?: string,

    /**
     * When set to false, clicking on a cell in this column will not select the row for that cell. The cells in this column will also be skipped during tab navigation.
     */
    focusable?: boolean,

    /**
     * This accepts a function of the form function(row, cell, value, columnDef, dataContext) and returns a formatted version of the data in each cell of this column. For example, setting formatter to function(r, c, v, cd, dc) { return "Hello!"; } would overwrite every value in the column with "Hello!" See defaultFormatter in slick.grid.js for an example formatter.
     * @param row 
     * @param cell 
     * @param value 
     * @param columnDef 
     * @param dataContext 
     * @return  *
     */
    formatter?: Slick$Formatter<T>,

    /**
     * Accepts a string as a class name, applies that class to the cell for the column header.
     */
    headerCssClass?: string,

    /**
     * A unique identifier for the column within the grid.
     */
    id?: string,

    /**
     * Set the maximum allowable width of this column, in pixels.
     */
    maxWidth?: number,

    /**
     * Set the minimum allowable width of this column, in pixels.
     */
    minWidth?: number,

    /**
     * The text to display on the column heading.
     */
    name?: string,

    /**
     * If set to true, whenever this column is resized, the entire table view will rerender.
     */
    rerenderOnResize?: boolean,

    /**
     * If false, column can no longer be resized.
     */
    resizable?: boolean,

    /**
     * If false, when a row is selected, the CSS class for selected cells ("selected" by default) is not applied to the cell in this column.
     */
    selectable?: boolean,

    /**
     * If true, the column will be sortable by clicking on the header.
     */
    sortable?: boolean,

    /**
     * If set to a non-empty string, a tooltip will appear on hover containing the string.
     */
    toolTip?: string,

    /**
     * Width of the column in pixels. (May often be overridden by things like minWidth, maxWidth, forceFitColumns, etc.)
     */
    width?: number
}

declare export interface Slick$EditorFactory {
    getEditor<T>(column: Slick$Column<T>): Editors.Editor<T >
}

declare export interface Slick$FormatterFactory<T>{
    getFormatter(column: Slick$Column<T>): Slick$Formatter<any >
}

declare export interface Slick$GridOptions<T>{

    /**
     * Makes cell editors load asynchronously after a small delay. This greatly increases keyboard navigation speed.
     */
    asyncEditorLoading?: boolean,

    /**
     * Delay after which cell editor is loaded. Ignored unless asyncEditorLoading is true.
     */
    asyncEditorLoadDelay?: number,

    /**
     * 
     */
    asyncPostRenderDelay?: number,

    /**
     * Cell will not automatically go into edit mode when selected.
     */
    autoEdit?: boolean,

    /**
     * 
     */
    autoHeight?: boolean,

    /**
     * A CSS class to apply to flashing cells via flashCell().
     */
    cellFlashingCssClass?: string,

    /**
     * A CSS class to apply to cells highlighted via setHighlightedCells().
     */
    cellHighlightCssClass?: string,

    /**
     * 
     */
    dataItemColumnValueExtractor?: any,

    /**
     * 
     */
    defaultColumnWidth?: number,

    /**
     * 
     */
    defaultFormatter?: Slick$Formatter<T>,

    /**
     * 
     */
    editable?: boolean,

    /**
     * Not listed as a default under options in slick.grid.js
     */
    editCommandHandler?: any,

    /**
     * A factory object responsible to creating an editor for a given cell. Must implement getEditor(column).
     */
    editorFactory?: Slick$EditorFactory,

    /**
     * A Slick.EditorLock instance to use for controlling concurrent data edits.
     */
    editorLock?: Slick$EditorLock<T>,

    /**
     * If true, a blank row will be displayed at the bottom - typing values in that row will add a new one. Must subscribe to onAddNewRow to save values.
     */
    enableAddRow?: boolean,

    /**
     * If true, async post rendering will occur and asyncPostRender delegates on columns will be called.
     */
    enableAsyncPostRender?: boolean,

    /**
     * *WARNING: Not contained in SlickGrid 2.1, may be deprecated
     */
    enableCellRangeSelection?: any,

    /**
     * Appears to enable cell virtualisation for optimised speed with large datasets
     */
    enableCellNavigation?: boolean,

    /**
     * 
     */
    enableColumnReorder?: boolean,

    /**
     * *WARNING: Not contained in SlickGrid 2.1, may be deprecated
     */
    enableRowReordering?: any,

    /**
     * 
     */
    enableTextSelectionOnCells?: boolean,

    /**
     * 
     * @see  Example: Explicit Initialization
     */
    explicitInitialization?: boolean,

    /**
     * Force column sizes to fit into the container (preventing horizontal scrolling). Effectively sets column width to be 1/Number of Columns which on small containers may not be desirable
     */
    forceFitColumns?: boolean,

    /**
     * 
     */
    forceSyncScrolling?: boolean,

    /**
     * A factory object responsible to creating a formatter for a given cell. Must implement getFormatter(column).
     */
    formatterFactory?: Slick$FormatterFactory<T>,

    /**
     * Will expand the table row divs to the full width of the container, table cell divs will remain aligned to the left
     */
    fullWidthRows?: boolean,

    /**
     * 
     */
    headerRowHeight?: number,

    /**
     * 
     */
    leaveSpaceForNewRows?: boolean,

    /**
     * 
     * @see  Example: Multi-Column Sort
     */
    multiColumnSort?: boolean,

    /**
     * 
     */
    multiSelect?: boolean,

    /**
     * 
     */
    rowHeight?: number,

    /**
     * 
     */
    selectedCellCssClass?: string,

    /**
     * 
     */
    showHeaderRow?: boolean,

    /**
     * If true, the column being resized will change its width as the mouse is dragging the resize handle. If false, the column will resize after mouse drag ends.
     */
    syncColumnCellResize?: boolean,

    /**
     * 
     */
    topPanelHeight?: number
}

declare export interface Slick$DataProvider<T>{

    /**
     * Returns the number of data items in the set.
     */
    getLength(): number,

    /**
     * Returns the item at a given index.
     * @param index 
     */
    getItem(index: number): T,

    /**
     * Returns the metadata for the item at a given index (optional).
     * @param index 
     */
    getItemMetadata(index: number): Slick$RowMetadata<T >
}

declare export interface Slick$SlickData {}

declare export interface Slick$RowMetadata<T>{

    /**
     * One or more (space-separated) CSS classes to be added to the entire row.
     */
    cssClasses?: string,

    /**
     * Whether or not any cells in the row can be set as "active".
     */
    focusable?: boolean,

    /**
     * Whether or not a row or any cells in it can be selected.
     */
    selectable?: boolean,

    /**
     * Metadata related to individual columns
     */
    columns?: {
        [index: string]: Slick$ColumnMetadata<T>,
        [index: number]: Slick$ColumnMetadata<T >
    }
}

declare export interface Slick$ColumnMetadata<T>{

    /**
     * Whether or not a cell can be set as "active".
     */
    focusable?: boolean,

    /**
     * Whether or not a cell can be selected.
     */
    selectable?: boolean,

    /**
     * A custom cell formatter.
     */
    formatter?: Slick$Formatter<T>,

    /**
     * A custom cell editor.
     */
    editor?: undefined.Editor<T>,

    /**
     * Number of columns this cell will span. Can also contain "" to indicate that the cell should span the rest of the row.
     */
    colspan?: number | string
}


/**
 * Selecting cells in SlickGrid is handled by a selection model.
 * Selection models are controllers responsible for handling user interactions and notifying subscribers of the changes in the selection. Selection is represented as an array of Slick.Range objects.
You can get the current selection model from the grid by calling getSelectionModel() and set a different one using setSelectionModel(selectionModel). By default, no selection model is set.
The grid also provides two helper methods to simplify development - getSelectedRows() and setSelectedRows(rowsArray), as well as an onSelectedRowsChanged event.
SlickGrid includes two pre-made selection models - Slick.CellSelectionModel and Slick.RowSelectionModel, but you can easily write a custom one.
*/
declare export class SelectionModel<T, E>{

    /**
     * An initializer function that will be called with an instance of the grid whenever a selection model is registered with setSelectionModel. The selection model can use this to initialize its state and subscribe to grid events.
     */
    init(grid: Slick$Grid<T>): void;

    /**
     * A destructor function that will be called whenever a selection model is unregistered from the grid by a call to setSelectionModel with another selection model or whenever a grid with this selection model is destroyed. The selection model can use this destructor to unsubscribe from grid events and release all resources (remove DOM nodes, event listeners, etc.).
     */
    destroy(): void;
    onSelectedRangesChanged: Slick$Event<E >
}

declare export class Grid<T>{

    /**
     * Create an instance of the grid.
     * @param container Container node to create the grid in. This can be a DOM Element, a jQuery node, or a jQuery selector.
     * @param data Databinding source. This can either be a regular JavaScript array or a custom object exposing getItem(index) and getLength() functions.
     * @param columns An array of column definition objects. See Column Options for a list of options that can be included on each column definition object.
     * @param options Additional options.  See Grid Options for a list of options that can be included.
     */
    constructor(container: string | HTMLElement | JQuery, data: T[] | Slick$DataProvider<T>, columns: Slick$Column<T>[], options: Slick$GridOptions<T>): this;

    /**
     * Initializes the grid. Called after plugins are registered. Normally, this is called by the constructor, so you don't need to call it. However, in certain cases you may need to delay the initialization until some other process has finished. In that case, set the explicitInitialization option to true and call the grid.init() manually.
     */
    init(): void;

    /**
     * todo: no docs
     */
    destroy(): void;

    /**
     * Returns an array of every data object, unless you're using DataView in which case it returns a DataView object.
     * @return  *
     */
    getData(): any;

    /**
     * Returns the databinding item at a given position.
     * @param index Item index.
     * @return  *
     */
    getDataItem(index: number): T;

    /**
     * Sets a new source for databinding and removes all rendered rows. Note that this doesn't render the new rows - you can follow it with a call to render() to do that.
     * @param newData New databinding source using a regular JavaScript array..
     * @param scrollToTop If true, the grid will reset the vertical scroll position to the top of the grid.
     */
    setData(newData: T[], scrollToTop: boolean): void;

    /**
     * Sets a new source for databinding and removes all rendered rows. Note that this doesn't render the new rows - you can follow it with a call to render() to do that.
     * @param newData New databinding source using a custom object exposing getItem(index) and getLength() functions.
     * @param scrollToTop If true, the grid will reset the vertical scroll position to the top of the grid.
     */
    setData(newData: Slick$DataProvider<T>, scrollToTop: boolean): void;

    /**
     * Returns the size of the databinding source.
     * @return  *
     */
    getDataLength(): number;

    /**
     * Returns an object containing all of the Grid options set on the grid. See a list of Grid Options here.
     * @return  *
     */
    getOptions(): Slick$GridOptions<any>;

    /**
     * Returns an array of row indices corresponding to the currently selected rows.
     * @return  *
     */
    getSelectedRows(): number[];

    /**
     * Returns the current SelectionModel. See here for more information about SelectionModels.
     * @return  *
     */
    getSelectionModel(): Slick$SelectionModel<any,
    any>;

    /**
     * Extends grid options with a given hash. If an there is an active edit, the grid will attempt to commit the changes and only continue if the attempt succeeds.
     * @options  An object with configuration options.
     */
    setOptions(options: Slick$GridOptions<T>): void;

    /**
     * Accepts an array of row indices and applies the current selectedCellCssClass to the cells in the row, respecting whether cells have been flagged as selectable.
     * @param rowsArray An array of row numbers.
     */
    setSelectedRows(rowsArray: number[]): void;

    /**
     * Unregisters a current selection model and registers a new one. See the definition of SelectionModel for more information.
     * @selectionModel  A SelectionModel.
     */
    setSelectionModel(selectionModel: Slick$SelectionModel<T, any>): void;

    /**
     * Proportionately resizes all columns to fill available horizontal space. This does not take the cell contents into consideration.
     */
    autosizeColumns(): void;

    /**
     * Returns the index of a column with a given id. Since columns can be reordered by the user, this can be used to get the column definition independent of the order:
     * @param id A column id.
     * @return  *
     */
    getColumnIndex(id: string): number;

    /**
     * Returns an array of column definitions, containing the option settings for each individual column.
     * @return  *
     */
    getColumns(): Slick$Column<T>[];

    /**
     * Sets grid columns. Column headers will be recreated and all rendered rows will be removed. To rerender the grid (if necessary), call render().
     * @param columnDefinitions An array of column definitions.
     */
    setColumns(columnDefinitions: Slick$Column<T>[]): void;

    /**
     * Accepts a columnId string and an ascending boolean. Applies a sort glyph in either ascending or descending form to the header of the column. Note that this does not actually sort the column. It only adds the sort glyph to the header.
     * @param columnId 
     * @param ascending 
     */
    setSortColumn(columnId: string, ascending: boolean): void;

    /**
     * Accepts an array of objects in the form [ { columnId: [string], sortAsc: [boolean] }, ... ]. When called, this will apply a sort glyph in either ascending or descending form to the header of each column specified in the array. Note that this does not actually sort the column. It only adds the sort glyph to the header
     * @param cols 
     */
    setSortColumns(cols: {
        columnId: string,
        sortAsc: boolean
    }[]): void;

    /**
     * todo: no docs or comments available
     * @return  *
     */
    getSortColumns(): {
        columnId: string,
        sortAsc: boolean
    }[];

    /**
     * Updates an existing column definition and a corresponding header DOM element with the new title and tooltip.
     * @param columnId Column id.
     * @param title New column name.
     * @param toolTip New column tooltip.
     */
    updateColumnHeader(columnId: string, title?: string, toolTip?: string): void;

    /**
     * Adds an "overlay" of CSS classes to cell DOM elements. SlickGrid can have many such overlays associated with different keys and they are frequently used by plugins. For example, SlickGrid uses this method internally to decorate selected cells with selectedCellCssClass (see options).
     * @param key A unique key you can use in calls to setCellCssStyles and removeCellCssStyles. If a hash with that key has already been set, an exception will be thrown.
     * @param hash A hash of additional cell CSS classes keyed by row number and then by column id. Multiple CSS classes can be specified and separated by space.
     * @example  * {
    0:    {
    "number_column":    "cell-bold",
    "title_column":     "cell-title cell-highlighted"
    },
    4:    {
    "percent_column":    "cell-highlighted"
    }
    }
    */
    addCellCssStyles(key: string, hash: Slick$CellCssStylesHash): void;

    /**
     * Returns true if you can click on a given cell and make it the active focus.
     * @param row A row index.
     * @param col A column index.
     * @return  *
     */
    canCellBeActive(row: number, col: number): boolean;

    /**
     * Returns true if selecting the row causes this particular cell to have the selectedCellCssClass applied to it. A cell can be selected if it exists and if it isn't on an empty / "Add New" row and if it is not marked as "unselectable" in the column definition.
     * @param row A row index.
     * @param col A column index.
     * @return  *
     */
    canCellBeSelected(row: number, col: number): boolean;

    /**
     * Attempts to switch the active cell into edit mode. Will throw an error if the cell is set to be not editable. Uses the specified editor, otherwise defaults to any default editor for that given cell.
     * @param editor A SlickGrid editor (see examples in slick.editors.js).
     */
    editActiveCell(editor: Editors.Editor<T>): void;

    /**
     * Flashes the cell twice by toggling the CSS class 4 times.
     * @param row A row index.
     * @param cell A column index.
     * @param speed (optional) - The milliseconds delay between the toggling calls. Defaults to 100 ms.
     */
    flashCell(row: number, cell: number, speed?: number): void;

    /**
     * Returns an object representing the coordinates of the currently active cell:
     * @example  * 	{
    row: activeRow,
    cell: activeCell
    }
     * @return  *
    */
    getActiveCell(): Slick$Cell;

    /**
     * Returns the DOM element containing the currently active cell. If no cell is active, null is returned.
     * @return  *
     */
    getActiveCellNode(): HTMLElement;

    /**
     * Returns an object representing information about the active cell's position. All coordinates are absolute and take into consideration the visibility and scrolling position of all ancestors.
     * @return  *
     */
    getActiveCellPosition(): Slick$CellPosition;

    /**
     * Accepts a key name, returns the group of CSS styles defined under that name. See setCellCssStyles for more info.
     * @param key A string.
     * @return  *
     */
    getCellCssStyles(key: string): Slick$CellCssStylesHash;

    /**
     * Returns the active cell editor. If there is no actively edited cell, null is returned.
     * @return  *
     */
    getCellEditor(): Editors.Editor<any>;

    /**
     * Returns a hash containing row and cell indexes from a standard W3C/jQuery event.
     * @param e A standard W3C/jQuery event.
     * @return  *
     */
    getCellFromEvent(e: DOMEvent): Slick$Cell;

    /**
     * Returns a hash containing row and cell indexes. Coordinates are relative to the top left corner of the grid beginning with the first row (not including the column headers).
     * @param x An x coordinate.
     * @param y A y coordinate.
     * @return  *
     */
    getCellFromPoint(x: number, y: number): Slick$Cell;

    /**
     * Returns a DOM element containing a cell at a given row and cell.
     * @param row A row index.
     * @param cell A column index.
     * @return  *
     */
    getCellNode(row: number, cell: number): HTMLElement;

    /**
     * Returns an object representing information about a cell's position. All coordinates are absolute and take into consideration the visibility and scrolling position of all ancestors.
     * @param row A row index.
     * @param cell A column index.
     * @return  *
     */
    getCellNodeBox(row: number, cell: number): Slick$CellPosition;

    /**
     * Accepts a row integer and a cell integer, scrolling the view to the row where row is its row index, and cell is its cell index. Optionally accepts a forceEdit boolean which, if true, will attempt to initiate the edit dialogue for the field in the specified cell.
     * Unlike setActiveCell, this scrolls the row into the viewport and sets the keyboard focus.
     * @param row A row index.
     * @param cell A column index.
     * @param forceEdit If true, will attempt to initiate the edit dialogue for the field in the specified cell.
     * @return  *
     */
    gotoCell(row: number, cell: number, forceEdit?: boolean): void;

    /**
     * todo: no docs
     * @return  *
     */
    getTopPanel(): HTMLElement;

    /**
     * todo: no docs
     * @param visible 
     */
    setTopPanelVisibility(visible: boolean): void;

    /**
     * todo: no docs
     * @param visible 
     */
    setHeaderRowVisibility(visible: boolean): void;

    /**
     * todo: no docs
     * @return  *
     */
    getHeaderRow(): HTMLElement;

    /**
     * todo: no docs, return type is probably wrong -> "return $header && $header[0]"
     * @param columnId 
     * @return  *
     */
    getHeaderRowColumn(columnId: string): Slick$Column<any>;

    /**
     * todo: no docs
     * @return  *
     */
    getGridPosition(): Slick$CellPosition;

    /**
     * Switches the active cell one row down skipping unselectable cells. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigateDown(): boolean;

    /**
     * Switches the active cell one cell left skipping unselectable cells. Unline navigatePrev, navigateLeft stops at the first cell of the row. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigateLeft(): boolean;

    /**
     * Tabs over active cell to the next selectable cell. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigateNext(): boolean;

    /**
     * Tabs over active cell to the previous selectable cell. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigatePrev(): boolean;

    /**
     * Switches the active cell one cell right skipping unselectable cells. Unline navigateNext, navigateRight stops at the last cell of the row. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigateRight(): boolean;

    /**
     * Switches the active cell one row up skipping unselectable cells. Returns a boolean saying whether it was able to complete or not.
     * @return  *
     */
    navigateUp(): boolean;

    /**
     * Removes an "overlay" of CSS classes from cell DOM elements. See setCellCssStyles for more.
     * @param key A string key.
     */
    removeCellCssStyles(key: string): void;

    /**
     * Resets active cell.
     */
    resetActiveCell(): void;

    /**
     * Sets an active cell.
     * @param row A row index.
     * @param cell A column index.
     */
    setActiveCell(row: number, cell: number): void;

    /**
     * Sets CSS classes to specific grid cells by calling removeCellCssStyles(key) followed by addCellCssStyles(key, hash). key is name for this set of styles so you can reference it later - to modify it or remove it, for example. hash is a per-row-index, per-column-name nested hash of CSS classes to apply.
     * Suppose you have a grid with columns:
    ["login", "name", "birthday", "age", "likes_icecream", "favorite_cake"]
    ...and you'd like to highlight the "birthday" and "age" columns for people whose birthday is today, in this case, rows at index 0 and 9. (The first and tenth row in the grid).
     * @param key A string key. Will overwrite any data already associated with this key.
     * @param hash A hash of additional cell CSS classes keyed by row number and then by column id. Multiple CSS classes can be specified and separated by space.
    */
    setCellCssStyles(key: string, hash: Slick$CellCssStylesHash): void;
    onScroll: Slick$Event<Slick$OnScrollEventArgs<T >> ;
    onSort: Slick$Event<Slick$OnSortEventArgs<T >> ;
    onHeaderMouseEnter: Slick$Event<Slick$OnHeaderMouseEventArgs<T >> ;
    onHeaderMouseLeave: Slick$Event<Slick$OnHeaderMouseEventArgs<T >> ;
    onHeaderContextMenu: Slick$Event<Slick$OnHeaderContextMenuEventArgs<T >> ;
    onHeaderClick: Slick$Event<Slick$OnHeaderClickEventArgs<T >> ;
    onHeaderCellRendered: Slick$Event<Slick$OnHeaderCellRenderedEventArgs<T >> ;
    onBeforeHeaderCellDestroy: Slick$Event<Slick$OnBeforeHeaderCellDestroyEventArgs<T >> ;
    onHeaderRowCellRendered: Slick$Event<Slick$OnHeaderRowCellRenderedEventArgs<T >> ;
    onBeforeHeaderRowCellDestroy: Slick$Event<Slick$OnBeforeHeaderRowCellDestroyEventArgs<T >> ;
    onMouseEnter: Slick$Event<Slick$OnMouseEnterEventArgs<T >> ;
    onMouseLeave: Slick$Event<Slick$OnMouseLeaveEventArgs<T >> ;
    onClick: Slick$Event<Slick$OnClickEventArgs<T >> ;
    onDblClick: Slick$Event<Slick$OnDblClickEventArgs<T >> ;
    onContextMenu: Slick$Event<Slick$OnContextMenuEventArgs<T >> ;
    onKeyDown: Slick$Event<Slick$OnKeyDownEventArgs<T >> ;
    onAddNewRow: Slick$Event<Slick$OnAddNewRowEventArgs<T >> ;
    onValidationError: Slick$Event<Slick$OnValidationErrorEventArgs<T >> ;
    onColumnsReordered: Slick$Event<Slick$OnColumnsReorderedEventArgs<T >> ;
    onColumnsResized: Slick$Event<Slick$OnColumnsResizedEventArgs<T >> ;
    onCellChange: Slick$Event<Slick$OnCellChangeEventArgs<T >> ;
    onBeforeEditCell: Slick$Event<Slick$OnBeforeEditCellEventArgs<T >> ;
    onBeforeCellEditorDestroy: Slick$Event<Slick$OnBeforeCellEditorDestroyEventArgs<T >> ;
    onBeforeDestroy: Slick$Event<Slick$OnBeforeDestroyEventArgs<T >> ;
    onActiveCellChanged: Slick$Event<Slick$OnActiveCellChangedEventArgs<T >> ;
    onActiveCellPositionChanged: Slick$Event<Slick$OnActiveCellPositionChangedEventArgs<T >> ;
    onDragInit: Slick$Event<Slick$OnDragInitEventArgs<T >> ;
    onDragStart: Slick$Event<Slick$OnDragStartEventArgs<T >> ;
    onDrag: Slick$Event<Slick$OnDragEventArgs<T >> ;
    onDragEnd: Slick$Event<Slick$OnDragEndEventArgs<T >> ;
    onSelectedRowsChanged: Slick$Event<Slick$OnSelectedRowsChangedEventArgs<T >> ;
    onCellCssStylesChanged: Slick$Event<Slick$OnCellCssStylesChangedEventArgs<T >> ;
    onViewportChanged: Slick$Event<Slick$OnViewportChangedEventArgs<T >> ;
    registerPlugin(plugin: Slick$Plugin<T>): void;
    unregisterPlugin(plugin: Slick$Plugin<T>): void;
    render(): void;
    invalidate(): void;
    invalidateRow(row: number): void;
    invalidateRows(rows: number[]): void;
    invalidateAllRows(): void;
    updateCell(row: number, cell: number): void;
    updateRow(row: number): void;
    getViewport(viewportTop?: number, viewportLeft?: number): Slick$Viewport;
    getRenderedRange(viewportTop?: number, viewportLeft?: number): Slick$Viewport;
    resizeCanvas(): void;
    updateRowCount(): void;
    scrollRowIntoView(row: number, doPaging: boolean): void;
    scrollRowToTop(row: number): void;
    scrollCellIntoView(row: number, cell: number, doPaging: boolean): void;
    getCanvasNode(): HTMLCanvasElement;
    focus(): void;
    getEditorLock(): Slick$EditorLock<any>;
    getEditController(): {
        commitCurrentEdit(): boolean,
        cancelCurrentEdit(): boolean
    }
}

declare export interface Slick$GridEventArgs<T>{
    grid: Slick$Grid<T >
}

declare export type Slick$OnCellCssStylesChangedEventArgs<T>= {
    key: string,
    hash: Slick$CellCssStylesHash
} & Slick$GridEventArgs


declare export type Slick$OnSelectedRowsChangedEventArgs<T>= {
    rows: number[]
} & Slick$GridEventArgs


declare export type Slick$OnDragEndEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnDragEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnDragStartEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnDragInitEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnActiveCellPositionChangedEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnActiveCellChangedEventArgs<T>= {
    row: number,
    cell: number
} & Slick$GridEventArgs


declare export type Slick$OnBeforeDestroyEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnBeforeCellEditorDestroyEventArgs<T>= {
    editor: Editors.Editor<T >
} & Slick$GridEventArgs


declare export type Slick$OnBeforeEditCellEventArgs<T>= {
    row: number,
    cell: number,
    item: T,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnCellChangeEventArgs<T>= {
    row: number,
    cell: number,
    item: T
} & Slick$GridEventArgs


declare export type Slick$OnColumnsResizedEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnColumnsReorderedEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnValidationErrorEventArgs<T>= {
    editor: Editors.Editor<T>,
    cellNode: HTMLElement,
    validationResults: Slick$ValidateResults,
    row: number,
    cell: number,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnAddNewRowEventArgs<T>= {
    item: T,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnKeyDownEventArgs<T>= {
    row: number,
    cell: number
} & Slick$GridEventArgs


declare export type Slick$OnContextMenuEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnDblClickEventArgs<T>= {
    row: number,
    cell: number
} & Slick$GridEventArgs


declare export type Slick$OnClickEventArgs<T>= {
    row: number,
    cell: number
} & Slick$GridEventArgs


declare export type Slick$OnMouseLeaveEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnMouseEnterEventArgs<T>= {} & Slick$GridEventArgs


declare export type Slick$OnBeforeHeaderRowCellDestroyEventArgs<T>= {
    node: HTMLElement,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnHeaderRowCellRenderedEventArgs<T>= {
    node: HTMLElement,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnBeforeHeaderCellDestroyEventArgs<T>= {
    node: HTMLElement,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnHeaderCellRenderedEventArgs<T>= {
    node: HTMLElement,
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnHeaderClickEventArgs<T>= {
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnHeaderContextMenuEventArgs<T>= {
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnHeaderMouseEventArgs<T>= {
    column: Slick$Column<T >
} & Slick$GridEventArgs


declare export type Slick$OnSortEventArgs<T>= {
    multiColumnSort: boolean,
    sortCol?: Slick$Column<T>,
    sortAsc: boolean,
    sortCols?: Slick$SortColumn<T>[]
} & Slick$GridEventArgs


declare export type Slick$OnScrollEventArgs<T>= {
    scrollLeft: number,
    scrollTop: number
} & Slick$GridEventArgs


declare export type Slick$OnViewportChangedEventArgs<T>= {} & Slick$GridEventArgs


declare export interface Slick$SortColumn<T>{
    sortCol: Slick$Column<T>,
    sortAsc: boolean
}

declare export interface Slick$Cell {
    row: number,
        cell: number
}

declare export type Slick$CellPosition = {
    bottom: number,
    height: number,
    right: number,
    visible: boolean,
    width: number
} & Slick$Position


declare export interface Slick$Position {
    top: number,
        left: number
}

declare export interface Slick$CellCssStylesHash {
    [index: number]: {
        [id: string]: string
    }
}

declare export interface Slick$Viewport {
    top: number,
        bottom: number,
        leftPx: number,
        rightPx: number
}

declare export interface Slick$ValidateResults {
    valid: boolean,
        msg: string
}

declare module 'Editors' {
    declare export interface EditorOptions<T>{
        column: Slick$Column<T>,
        container: HTMLElement,
        grid: Slick$Grid<T >
    }
    declare export class Editor<T>{
        constructor(args: EditorOptions<T>): this;
        init(): void;
        destroy(): void;
        focus(): void;
        loadValue(item: any): void;
        applyValue(item: any, state: string): void;
        isValueChanged(): boolean;
        serializeValue(): any;
        validate(): Slick$ValidateResults
    }
    declare export class Text<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        getValue(): string;
        setValue(val: string): void;
        serializeValue(): string
    }
    declare export class Integer<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        serializeValue(): number
    }
    declare export class Date<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        show(): void;
        hide(): void;
        position(position: Slick$Position): void;
        serializeValue(): string
    }
    declare export class YesNoSelect<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        serializeValue(): boolean
    }
    declare export class Checkbox<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        serializeValue(): boolean
    }
    declare export class PercentComplete<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        serializeValue(): number
    }
    declare export class LongText<T>mixins Editor<T>{
        constructor(args: EditorOptions<T>): this;
        handleKeyDown(e: DOMEvent): void;
        save(): void;
        cancel(): void;
        hide(): void;
        show(): void;
        position(position: Slick$Position): void;
        serializeValue(): string
    }
}


declare export interface Slick$Formatter<T>{
    (row: number, cell: number, value: any, columnDef: Slick$Column<T>, dataContext: Slick$SlickData): string
}

declare module 'Formatters' {
    declare var PercentComplete: Slick$Formatter<Slick$SlickData>;
    declare var PercentCompleteBar: Slick$Formatter<Slick$SlickData>;
    declare var YesNo: Slick$Formatter<Slick$SlickData>;
    declare var Checkmark: Slick$Formatter<Slick$SlickData>;
}


declare module 'Data' {
    declare export interface DataViewOptions<T>{
        groupItemMetadataProvider?: GroupItemMetadataProvider<T>,
        inlineFilters?: boolean
    }

    /**
     * Item -> Data by index
     * Row -> Data by row
     */
    declare export class DataView<T>mixins DataProvider<T>{
        constructor(options?: DataViewOptions<T>): this;
        beginUpdate(): void;
        endUpdate(): void;
        setPagingOptions(args: PagingOptions): void;
        getPagingInfo(): PagingOptions;
        getItems(): T[];
        setItems(data: T[], objectIdProperty?: string): void;
        setFilter(filterFn: (item: T, args: any) => boolean): void;
        sort(comparer: Function, ascending: boolean): void;
        fastSort(field: string, ascending: boolean): void;
        fastSort(field: Function, ascending: boolean): void;
        reSort(): void;
        setGrouping(groupingInfos: GroupingOptions<T>| GroupingOptions<T>[]): void;
        getGrouping(): GroupingOptions<T>[];

        /**
         * 
         * @deprecated  *
         */
        groupBy(valueGetter: any, valueFormatter: any, sortComparer: any): void;

        /**
         * 
         * @deprecated  *
         */
        setAggregators(groupAggregators: any, includeCollapsed: any): void;

        /**
         * 
         * @param level Optional level to collapse.  If not specified, applies to all levels.
         */
        collapseAllGroups(level?: number): void;

        /**
         * 
         * @param level Optional level to collapse.  If not specified, applies to all levels.
         */
        expandAllGroups(level?: number): void;

        /**
         * 
         * @param varArgs Either a Slick.Group's "groupingKey" property, or a
        variable argument list of grouping values denoting a unique path to the row.  For
        example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of
        the 'high' setGrouping.
        */
        collapseGroup(...varArgs: string[]): void;

        /**
         * 
         * @param varArgs Either a Slick.Group's "groupingKey" property, or a
        variable argument list of grouping values denoting a unique path to the row.  For
        example, calling expandGroup('high', '10%') will expand the '10%' subgroup of
        the 'high' setGrouping.
        */
        expandGroup(...varArgs: string[]): void;
        getGroups(): Slick$Group<T>[];
        getIdxById(id: string): number;
        getRowById(id: string): number;
        getItemById(id: any): T;
        getItemByIdx(idx: number): T;
        mapRowsToIds(rowArray: T[]): string[];
        setRefreshHints(hints: RefreshHints): void;
        setFilterArgs(args: any): void;
        refresh(): void;
        updateItem(id: string, item: T): void;
        insertItem(insertBefore: number, item: T): void;
        addItem(item: T): void;
        deleteItem(id: string): void;
        syncGridSelection(grid: Slick$Grid<T>, preserveHidden: boolean): void;
        syncGridCellCssStyles(grid: Slick$Grid<T>, key: string): void;
        getLength(): number;
        getItem(index: number): T;
        getItemMetadata(index: number): Slick$RowMetadata<T>;
        onRowCountChanged: Slick$Event<OnRowCountChangedEventData>;
        onRowsChanged: Slick$Event<OnRowsChangedEventData>;
        onPagingInfoChanged: Slick$Event<OnPagingInfoChangedEventData >
    }
    declare export interface GroupingOptions<T>{
        getter?: ((item?: T) => any) | string,
        formatter?: (item?: T) => string,
        comparer?: (a: Slick$Group<T>, b: Slick$Group<T>) => number,
        predefinedValues?: any[],
        aggregators?: Aggregators.Aggregator<T>[],
        aggregateEmpty?: boolean,
        aggregateCollapsed?: boolean,
        aggregateChildGroups?: boolean,
        collapsed?: boolean,
        displayTotalsRow?: boolean
    }
    declare export interface PagingOptions {
        pageSize?: number,
            pageNum?: number,
            totalRows?: number,
            totalPages?: number
    }
    declare export interface RefreshHints {
        isFilterNarrowing?: boolean,
            isFilterExpanding?: boolean,
            isFilterUnchanged?: boolean,
            ignoreDiffsBefore?: boolean,
            ignoreDiffsAfter?: boolean
    }
    declare export interface OnRowCountChangedEventData {}
    declare export interface OnRowsChangedEventData {
        rows: number[]
    }
    declare export type OnPagingInfoChangedEventData = {} & PagingOptions

    declare module 'Aggregators' {
        declare     export class Aggregator<T>{
            field: string;
            init(): void;
            accumulate(item: T): void;
            storeResult(groupTotals: Slick$GroupTotals<T>): void
        }
        declare     export class Avg<T>mixins Aggregator<T>{}
        declare     export class Min<T>mixins Aggregator<T>{}
        declare     export class Max<T>mixins Aggregator<T>{}
        declare     export class Sum<T>mixins Aggregator<T>{}
    }

    declare export class GroupItemMetadataProvider<T>{
        init(): void;
        destroy(): void;
        getGroupRowMetadata(item?: Slick$Group<T>): Slick$RowMetadata<T>;
        getTotalsRowMetadata(item?: Slick$GroupTotals<T>): Slick$RowMetadata<T >
    }
    declare export interface GroupItemMetadataProviderOptions {
        groupCssClass?: string,
            groupTitleCssClass?: string,
            totalsCssClass?: string,
            groupFocusable?: boolean,
            totalsFocusable?: boolean,
            toggleCssClass?: string,
            toggleExpandedCssCass?: string,
            toggleCollapsedCssClass?: string,
            enableExpandCollapse?: boolean
    }
}


declare export class Plugin<T>{
    constructor(options?: Slick$PluginOptions): this;
    init(grid: Slick$Grid<T>): void;
    destroy(): void
}

declare export interface Slick$PluginOptions {}