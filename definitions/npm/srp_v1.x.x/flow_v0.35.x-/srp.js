/**
 * Flowtype definitions for srp
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$SRP: {
    computeVerifier: typeof SRP$computeVerifier,
    genKey: typeof SRP$genKey,
}
declare export interface SRP$Params {
    N_length_bits: number,
        N: BigNum,
        g: BigNum,
        hash: string
}

declare export var params: {
    [bits: string]: SRP$Params
};


/**
 * The verifier is calculated as described in Section 3 of [SRP-RFC].
 * We give the algorithm here for convenience.

The verifier (v) is computed based on the salt (s), user name (I),
password (P), and group parameters (N, g).

         x = H(s | H(I | ":" | P))
         v = g^x % N
 * @param  group parameters, with .N, .g, .hash
 * @param  salt
 * @param  user identity
 * @param  user password
 * @returns  
*/
declare export function SRP$computeVerifier(params: SRP$Params, salt: Buffer, I: Buffer, P: Buffer): Buffer


/**
 * Generate a random key.
 * @param  length of key (default=32)
 * @param  function to call with err,key
 */
declare export function SRP$genKey(bytes: number, callback: (error: Error, key: Buffer) => void): void

declare export class Client {
    constructor(params: SRP$Params, salt: Buffer, identity: Buffer, password: Buffer, secret1: Buffer): this;
    computeA(): Buffer;
    setB(B: Buffer): void;
    computeM1(): Buffer;
    checkM2(M2: Buffer): void;
    computeK(): Buffer
}

declare export class Server {
    constructor(params: SRP$Params, verifier: Buffer, secret2: Buffer): this;
    computeB(): Buffer;
    setA(A: Buffer): void;
    checkM1(M1: Buffer): Buffer;
    computeK(): Buffer
}
declare module 'srp' {
    declare module.exports: typeof SRP
}