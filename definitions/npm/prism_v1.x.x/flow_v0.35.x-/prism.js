/**
 * Flowtype definitions for prism
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


/**
 * The Prism object
 */
declare interface PrismJS$Prism {
    util: PrismJS$Util,
        languages: PrismJS$Languages,
        plugins: any,

        /**
         * This is the most high-level function in Prism’s API. It fetches all the elements that have a .language-xxxx class and then calls Prism.highlightElement() on each one of them.:Element)=>void} callback? - An optional callback to be invoked after the highlighting is done. Mostly useful when async is true, since in that case, the highlighting is done asynchronously.
         * @param  - Whether to use Web Workers to improve performance and avoid blocking the UI when highlighting very large chunks of code. False by default.
         * @returns  void
         */
        highlightAll(async: boolean, callback?: (element: Element) => void): void,

        /**
         * Highlights the code inside a single element.:Element)=>void} callback? - An optional callback to be invoked after the highlighting is done. Mostly useful when async is true, since in that case, the highlighting is done asynchronously.
         * @param  - The element containing the code. It must have a class of language-xxxx to be processed, where xxxx is a valid language identifier.
         * @param  - Whether to use Web Workers to improve performance and avoid blocking the UI when highlighting very large chunks of code. False by default.
         * @returns  void
         */
        highlightElement(element: Element, async: boolean, callback?: (element: Element) => void): void,

        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input and the language definitions to use, and returns a string with the HTML produced.
         * @param  - A string with the code to be highlighted.
         * @param  - An object containing the tokens to use. Usually a language definition like Prism.languages.markup
         * @param  
         * @returns  string - The highlighted HTML
         */
        highlight(
            text: string,
            grammer: PrismJS$LanguageDefinition,
            language?: PrismJS$LanguageDefinition): string,

        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input and the language definitions to use,
         * and returns an array with the tokenized code. When the language definition includes nested tokens, the function is called recursively on each of
        these tokens. This method could be useful in other contexts as well, as a very crude parser.
         * @param  - A string with the code to be highlighted.
         * @param  - An object containing the tokens to use. Usually a language definition like Prism.languages.markup
         * @param  
         * @returns  Array - An array of strings, tokens (class Prism.Token) and other arrays.
        */
        tokenize(
            text: string,
            grammar: PrismJS$LanguageDefinition,
            language?: PrismJS$LanguageDefinition): Array<string>,
        fileHighlight(): void,
        hooks: PrismJS$Hooks
}

declare interface PrismJS$Environment {
    element?: Element,
        language?: PrismJS$LanguageDefinition,
        grammer?: any,
        code?: any,
        highlightedCode?: any,
        type?: string,
        content?: string,
        tag?: string,
        classes?: Array<string>,
        attributes?: Array<string>| Object,
        parent?: Element
}

declare interface PrismJS$Identifier {
    value: number
}

declare interface PrismJS$Util {
    encode(
            tokens: PrismJS$Token | Array<PrismJS$Token>| string): PrismJS$Token | Array<PrismJS$Token>| string,
        type(o: Object): string,
        objId(obj: Object): PrismJS$Identifier,
        clone(o: PrismJS$LanguageDefinition): PrismJS$LanguageDefinition
}

declare interface PrismJS$LanguageDefinition {
    keyword?: RegExp | PrismJS$LanguageDefinition,
        number?: RegExp | PrismJS$LanguageDefinition,
        function?: RegExp | PrismJS$LanguageDefinition,
        string?: RegExp | PrismJS$LanguageDefinition,
        boolean?: RegExp | PrismJS$LanguageDefinition,
        operator?: RegExp | PrismJS$LanguageDefinition,
        punctuation?: RegExp | PrismJS$LanguageDefinition,
        atrule?: RegExp | PrismJS$LanguageDefinition,
        url?: RegExp | PrismJS$LanguageDefinition,
        selector?: RegExp | PrismJS$LanguageDefinition,
        property?: RegExp | PrismJS$LanguageDefinition,
        important?: RegExp | PrismJS$LanguageDefinition,
        style?: RegExp | PrismJS$LanguageDefinition,

        /**
         * This option can be used to define one or more aliases for the matched token. The result will be, that the styles
         * of the token and its aliases are combined. This can be useful, to combine the styling of a well known token,
        which is already supported by most of the themes, with a semantically correct token name. The option can be
        set to a string literal or an array of string literals. In the following example the token name latex-equation
        is not supported by any theme, but it will be highlighted the same as a string.
        */
        alias?: string,
        pattern?: RegExp,

        /**
         * This option mitigates JavaScript’s lack of lookbehind. When set to true, the first capturing group in the regex 
         * pattern is discarded when matching this token, so it effectively behaves as if it was lookbehind
         */
        lookbehind?: boolean,

        /**
         * This property accepts another object literal, with tokens that are allowed to be nested in this token.
         * This makes it easier to define certain languages. However, keep in mind that they’re slower and if coded poorly, 
        can even result in infinite recursion. For an example of nested tokens, check out the Markup language definition
        */
        inside?: PrismJS$LanguageDefinition,

        /**
         * Accepts an object literal with tokens and appends them to the end of the current object literal.
         */
        rest?: Array<PrismJS$Token >
}

declare type PrismJS$Languages = {
    extend(id: string, redef: PrismJS$LanguageDefinition): PrismJS$LanguageDefinition,

    /**
     * Insert a token before another token in a language literal
     * As this needs to recreate the object (we cannot actually insert before keys in object literals),
    we cannot just provide an object, we need anobject and a key.
     * @param inside The key (or language id) of the parent
     * @param before The key to insert before. If not provided, the function appends instead.
     * @param insert Object with the key/value pairs to insert
     * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
    */
    insertBefore(
        inside: string,
        before: string,
        insert: PrismJS$LanguageDefinition,
        root: Object): any
} & Array


declare interface PrismJS$Hooks {
    all: Array<Array<(env: PrismJS$Environment) => void >> ,
        add(name: string, callback: (env: PrismJS$Environment) => void): void,
        run(name: string, env: PrismJS$Environment): void
}

declare interface PrismJS$Token {
    type: string,
        content: PrismJS$Token | Array<PrismJS$Token>| string,
        alias: string,
        stringify(
            o: string | Array<any>,
            language: PrismJS$LanguageDefinition,
            parent: HTMLPreElement): string
}
declare
var Prism: PrismJS$Prism;