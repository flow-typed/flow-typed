

declare module 'jquery-handsontable' {
		declare interface JQuery {
		handsontable(): JQuery,
		handsontable(methodName: string, ...arguments: any[]): any,
		handsontable(options: Handsontable.Options): JQuery
	}

			
}

declare module 'npm$namespace$Handsontable' {
		declare interface CellPosition {
		row: number,
		col: number
	}

	declare interface Options {
		data?: any,
		width?: any,
		height?: any,
		minRows?: number,
		minCols?: number,
		maxRows?: number,
		maxCols?: number,
		startRows?: number,
		startCols?: number,
		rowHeaders?: any,
		colHeaders?: any,
		colWidths?: any,
		columns?: any[],
		cells?: (row: number, col: number, prop: string) => void,
		dataSchema?: any,
		minSpareRows?: number,
		minSpareCols?: number,
		multiSelect?: boolean,
		fillHandle?: any,
		contextMenu?: any,
		undo?: boolean,
		outsideClickDeselects?: boolean,
		enterBeginsEditing?: boolean,
		enterMoves?: any,
		tabMoves?: any,
		autoWrapRow?: boolean,
		autoWrapCol?: boolean,
		autoComplete?: any[],
		copyRowsLimit?: number,
		copyColsLimit?: number,
		pasteMode?: string,
		stretchH?: string,
		isEmptyRow?: (row: number) => boolean,
		isEmptyCol?: (col: number) => boolean,
		manualColumnResize?: any,
		manualColumnMove?: any,
		columnSorting?: boolean,
		persistentState?: boolean,
		currentRowClassName?: string,
		currentColClassName?: string,
		fixedRowsTop?: number,
		fixedColumnsLeft?: number,
		fragmentSelection?: boolean,
		wordWrap?: boolean,
		noWordWrapClassName?: string,
		placeholder?: any,
		placeholderCellClassName?: string,
		invalidCellClassName?: string,
		readOnlyCellClassName?: string,
		debug?: boolean,
		observeDOMVisibility?: boolean,
		autoColumnSize?: boolean | Object,
		observeChanges?: boolean,
		manualRowResize?: boolean,
		manualRowMove?: boolean,
		copyPaste?: boolean,
		search?: boolean,
		mergeCells?: any,
		beforeInitWalkontable?: Function,
		beforeInit?: Function,
		beforeRender?: (isForced: boolean) => void,
		beforeChange?: (changes: any[][], source: string) => void,
		beforeChangeRender?: Function,
		beforeColumnSort?: (column: number, order: boolean) => void,
		beforeSet?: (v: Object) => void,
		beforeGetCellMeta?: (row: number, col: number, cellProperties: Object) => void,
		beforeAutofill?: (start: CellPosition, end: CellPosition, data: string[][]) => void,
		beforeKeyDown?: (event: KeyboardEvent) => void,
		beforeValidate?: (value: any, row: number, prop: string, source: string) => void,
		afterInit?: Function,
		afterLoadData?: Function,
		afterRender?: (isForced: boolean) => void,
		afterChange?: (changes: any[], source: string) => void,
		afterColumnSort?: (column: number, order: boolean) => void,
		afterSelection?: (r: number, c: number, r2: number, c2: number) => void,
		afterSelectionByProp?: (r: number, p: string, r2: number, p2: string) => void,
		afterSelectionEnd?: (r: number, c: number, r2: number, c2: number) => void,
		afterSelectionEndByProp?: (r: number, p: string, r2: number, p2: string) => void,
		afterDeselect?: Function,
		afterGetCellMeta?: (row: number, col: number, cellProperties: Object) => void,
		afterGetColHeader?: (col: number, TH: HTMLTableHeaderCellElement) => void,
		afterGetColWidth?: (col: number, response: Object) => void,
		afterDestroy?: Function,
		afterCreateRow?: (index: number, amount: number) => void,
		afterCreateCol?: (index: number, amount: number) => void,
		beforeRemoveRow?: (index: number, amount: number) => void,
		afterRemoveRow?: (index: number, amount: number) => void,
		beforeRemoveCol?: (index: number, amount: number) => void,
		afterRemoveCol?: (index: number, amount: number) => void,
		afterColumnResize?: (col: number, size: number) => void,
		afterColumnMove?: (oldIndex: number, newIndex: number) => void,
		afterCopyLimit?: (
		selectedRowsCount: number, selectedColsCount: number, copyRowsLimit: number, copyColsLimit: number
	) => void,
		afterValidate?: (
		isValid: boolean, value: any, row: number, prop: string, source: string
	) => boolean,
		beforeSetRangeEnd?: (coords: any[]) => void,
		afterUpdateSettings?: Function,
		afterRenderer?: (
		TD: HTMLTableDataCellElement, row: number, col: number, prop: string, value: string, cellProperties: Object
	) => void,
		afterOnCellMouseDown?: (event: MouseEvent, coords: CellPosition, TD: HTMLTableDataCellElement) => void,
		afterOnCellMouseOver?: (event: MouseEvent, coords: CellPosition, TD: HTMLTableDataCellElement) => void,
		afterOnCellCornerMouseDown?: (event: MouseEvent) => void,
		afterScrollVertically?: Function,
		afterScrollHorizontally?: Function,
		afterCellMetaReset?: Function,
		modifyColWidth?: (width: number, col: number) => void,
		modifyRowHeight?: (height: number, row: number) => void,
		modifyRow?: (row: number) => void,
		modifyCol?: (col: number) => void,
		afterSetCellMeta?: Function,
		onSelection?: (r: number, p: number, r2: number, p2: number) => void,
		onSelectionByProp?: (r: number, p: number, r2: number, p2: number) => void,
		onSelectionEnd?: (r: number, p: number, r2: number, p2: number) => void,
		onSelectionEndByProp?: (r: number, p: number, r2: number, p2: number) => void,
		onBeforeChange?: (changes: any[], source: string) => void,
		onChange?: (changes: any[], source: string) => void,
		onCopyLimit?: (
		selectedRowsCount: number, selectedColsCount: number, copyRowsLimit: number, copyColsLimit: number
	) => void
	}

	declare interface Context {
		updateSettings(options: Options): void,
		getSettings(): Options,
		loadData(data: any[]): void,
		listen(): void,
		getCellRenderer(row: number, col: number): string,
		unlisten(): void,
		isListening(): boolean,
		render(): void,
		destroy(): void,
		validateCells(callback: Function): void,
		getData(): any,
		getData(row: number, col: number, row2: number, col2: number): any,
		getDataAtCell(row: number, col: number): any,
		getDataAtRowProp(row: number, prop: string): any,
		getDataAtRow(row: number): any,
		getSourceDataAtRow(row: number): any,
		getDataAtCol(col: number): any[],
		getSourceDataAtCol(col: number): any[],
		getDataAtProp(prop: string): any[],
		getCopyableData(startRow: number, startCol: number, endRow: number, endCol: number): any,
		getValue(): any,
		setDataAtCell(row: number, col: number, value: any, source?: string): void,
		setDataAtCell(changes: any[], source?: string): void,
		setDataAtRowProp(row: number, prop: string, value: any, source?: string): void,
		setDataAtRowProp(changes: any[], source?: string): void,
		populateFromArray(
		row: number, col: number, input: any[], endRow: number, endCol: number, source?: string, populateMethod?: string
	): void,
		spliceCol(col: number, index: number, amount: number, ...elements: any[]): void,
		spliceRow(row: number, index: number, amount: number, ...elements: any[]): void,
		alter(type: "insert_row", index: number, amount?: number, source?: string): void,
		alter(type: "insert_col", index: number, amount?: number, source?: string): void,
		alter(type: "remove_row", index: number, amount?: number, source?: string): void,
		alter(type: "remove_col", index: number, amount?: number, source?: string): void,
		alter(type: string, index: number, amount?: number, source?: string): void,
		getCell(row: number, col: number): any,
		getCellMeta(row: number, col: number): any,
		setCellMeta(row: number, col: number, key: string, val: string): void,
		destroyEditor(revertOriginal?: boolean): void,
		selectCell(
		row: number, col: number, row2: number, col2: number, scrollToSelection?: boolean
	): void,
		deselectCell(): void,
		getSelected(): number[],
		getSelectedRange(): void,
		clear(): void,
		countRows(): number,
		countCols(): number,
		colToProp(column: number): string,
		rowOffset(): number,
		colOffset(): number,
		countVisibleRows(): number,
		countVisibleCols(): number,
		countEmptyRows(ending?: boolean): number,
		countEmptyCols(ending?: boolean): number,
		isEmptyRow(row: number): boolean,
		isEmptyCol(col: number): boolean,
		getRowHeader(row: number): any,
		getColHeader(col: number): any,
		hasRowHeaders(): boolean,
		hasColHeaders(): boolean,
		getColWidth(col: number): number,
		getRowHeight(row: number): number,
		propToCol(property: string): number,
		clearUndo(): void,
		isUndoAvailable(): boolean,
		isRedoAvailable(): boolean,
		undo(): void,
		redo(): void,
		sort(column: number, order: boolean): void
	}

			
}