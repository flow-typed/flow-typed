/**
 * Flowtype definitions for bull
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'bull' {

    declare module.exports: typeof Bull
    declare export interface Bull$DoneCallback {
        (error?: Error, value?: any): void
    }

    declare export interface Bull$Job {
        jobId: string,

            /**
             * The custom data passed when the job was created
             */
            data: Object,

            /**
             * Report progress on a job
             */
            progress(value: any): Promise<void>,

            /**
             * Removes a Job from the queue from all the lists where it may be included.
             * @returns  A promise that resolves when the job is removed.
             */
            remove(): Promise<void>,

            /**
             * Rerun a Job that has failed.
             * @returns  A promise that resolves when the job is scheduled for retry.
             */
            retry(): Promise<void >
    }

    declare export interface Bull$Backoff {

        /**
         * Backoff type, which can be either `fixed` or `exponential`
         */
        type: string,

            /**
             * Backoff delay, in milliseconds
             */
            delay: number
    }

    declare export interface Bull$AddOptions {

        /**
         * An amount of miliseconds to wait until this job can be processed.
         * Note that for accurate delays, both server and clients should have their clocks synchronized
         */
        delay?: number,

            /**
             * A number of attempts to retry if the job fails [optional]
             */
            attempts?: number,

            /**
             * Backoff setting for automatic retries if the job fails
             */
            backoff?: number | Bull$Backoff,

            /**
             * A boolean which, if true, adds the job to the right
             * of the queue instead of the left (default false)
             */
            lifo?: boolean,

            /**
             * The number of milliseconds after which the job should be fail with a timeout error
             */
            timeout?: number
    }

    declare export interface Bull$Queue {

        /**
         * Defines a processing function for the jobs placed into a given Queue.
         * 
        The callback is called everytime a job is placed in the queue.
        It is passed an instance of the job as first argument.

        The done callback can be called with an Error instance, to signal that the job did not complete successfully,
        or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
        Errors will be passed as a second argument to the "failed" event;
        results, as a second argument to the "completed" event.

        concurrency: Bull will then call you handler in parallel respecting this max number.
        */
        process(
                concurrency: number,
                callback: (job: Bull$Job, done: Bull$DoneCallback) => void): void,

            /**
             * Defines a processing function for the jobs placed into a given Queue.
             * 
            The callback is called everytime a job is placed in the queue.
            It is passed an instance of the job as first argument.

            The done callback can be called with an Error instance, to signal that the job did not complete successfully,
            or with a result as second argument as second argument (e.g.: done(null, result);) when the job is successful.
            Errors will be passed as a second argument to the "failed" event;
            results, as a second argument to the "completed" event.
            */
            process(callback: (job: Bull$Job, done: Bull$DoneCallback) => void): void,

            /**
             * Defines a processing function for the jobs placed into a given Queue.
             * 
            The callback is called everytime a job is placed in the queue.
            It is passed an instance of the job as first argument.

            A promise must be returned to signal job completion.
            If the promise is rejected, the error will be passed as a second argument to the "failed" event.
            If it is resolved, its value will be the "completed" event's second argument.

            concurrency: Bull will then call you handler in parallel respecting this max number.
            */
            process(concurrency: number, callback: (job: Bull$Job) => void): Promise<any>,

            /**
             * Defines a processing function for the jobs placed into a given Queue.
             * 
            The callback is called everytime a job is placed in the queue.
            It is passed an instance of the job as first argument.

            A promise must be returned to signal job completion.
            If the promise is rejected, the error will be passed as a second argument to the "failed" event.
            If it is resolved, its value will be the "completed" event's second argument.
            */
            process(callback: (job: Bull$Job) => void): Promise<any>,

            /**
             * Creates a new job and adds it to the queue.
             * If the queue is empty the job will be executed directly,
            otherwise it will be placed in the queue and executed as soon as possible.
            */
            add(data: Object, opts?: Bull$AddOptions): Promise<Bull$Job>,

            /**
             * Returns a promise that resolves when the queue is paused.
             * The pause is global, meaning that all workers in all queue instances for a given queue will be paused.
            A paused queue will not process new jobs until resumed,
            but current jobs being processed will continue until they are finalized.

            Pausing a queue that is already paused does nothing.
            */
            pause(): Promise<void>,

            /**
             * Returns a promise that resolves when the queue is resumed after being paused.
             * The resume is global, meaning that all workers in all queue instances for a given queue will be resumed.

            Resuming a queue that is not paused does nothing.
            */
            resume(): Promise<void>,

            /**
             * Returns a promise that returns the number of jobs in the queue, waiting or paused.
             * Since there may be other processes adding or processing jobs, this value may be true only for a very small amount of time.
             */
            count(): Promise<number>,

            /**
             * Empties a queue deleting all the input lists and associated jobs.
             */
            empty(): Promise<void>,

            /**
             * Closes the underlying redis client. Use this to perform a graceful shutdown.
             * 
            `close` can be called from anywhere, with one caveat:
            if called from within a job handler the queue won't close until after the job has been processed
            */
            close(): Promise<void>,

            /**
             * Returns a promise that will return the job instance associated with the jobId parameter.
             * If the specified job cannot be located, the promise callback parameter will be set to null.
             */
            getJob(jobId: string): Promise<Bull$Job>,

            /**
             * Tells the queue remove all jobs created outside of a grace period in milliseconds.
             * You can clean the jobs with the following states: completed, waiting, active, delayed, and failed.
             */
            clean(gracePeriod: number, jobsState?: string): Promise<Bull$Job[]>,

            /**
             * Listens to queue events
             * 'ready', 'error', 'activ', 'progress', 'completed', 'failed', 'paused', 'resumed', 'cleaned'
             */
            on(eventName: string, callback: Bull$EventCallback): void
    }

    declare interface Bull$EventCallback {
        (...args: any[]): void
    }

    declare type Bull$ReadyEventCallback = {
        (): void
    } & Bull$EventCallback


    declare type Bull$ErrorEventCallback = {
        (error: Error): void
    } & Bull$EventCallback


    declare interface Bull$JobPromise {

        /**
         * Abort this job
         */
        cancel(): void
    }

    declare type Bull$ActiveEventCallback = {
        (job: Bull$Job, jobPromise: Bull$JobPromise): void
    } & Bull$EventCallback


    declare type Bull$ProgressEventCallback = {
        (job: Bull$Job, progress: any): void
    } & Bull$EventCallback


    declare type Bull$CompletedEventCallback = {
        (job: Bull$Job, result: Object): void
    } & Bull$EventCallback


    declare type Bull$FailedEventCallback = {
        (job: Bull$Job, error: Error): void
    } & Bull$EventCallback


    declare type Bull$PausedEventCallback = {
        (): void
    } & Bull$EventCallback


    declare type Bull$ResumedEventCallback = {
        (job?: Bull$Job): void
    } & Bull$EventCallback



    /**
     * 
     * @see  clean() for details
     */
    declare type Bull$CleanedEventCallback = {
        (jobs: Bull$Job[], type: string): void
    } & Bull$EventCallback

}
declare module 'bull/lib/priority-queue' {


    declare module.exports: typeof PQueue
    declare export interface PQueue$AddOptions {

        /**
         * An amount of miliseconds to wait until this job can be processed.
         * Note that for accurate delays, both server and clients should have their clocks synchronized
         */
        delay?: number,

            /**
             * A number of attempts to retry if the job fails [optional]
             */
            attempts?: number,

            /**
             * Backoff setting for automatic retries if the job fails
             */
            backoff?: number | Bull$Backoff,

            /**
             * A boolean which, if true, adds the job to the right
             * of the queue instead of the left (default false)
             */
            lifo?: boolean,

            /**
             * The number of milliseconds after which the job should be fail with a timeout error
             */
            timeout?: number
    }

    declare export type PQueue$PriorityQueue = {

        /**
         * Creates a new job and adds it to the queue.
         * If the queue is empty the job will be executed directly,
        otherwise it will be placed in the queue and executed as soon as possible.
        */
        add(data: Object, opts?: PQueue$AddOptions): Promise<Bull$Job >
    }
}