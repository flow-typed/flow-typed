/**
 * Flowtype definitions for cryptojs
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare var CryptoJS: CryptoJS$CryptoJSStatic;
declare interface lib$Base {
    extend(overrides: Object): Object,
        init(...args: any[]): void,
        create(...args: any[]): lib$Base,
        mixIn(properties: Object): void,
        clone(): lib$Base
}

declare type lib$WordArray = {
    words: number[],
    sigBytes: number,
    init(words?: number[], sigBytes?: number): void,
    create(words?: number[], sigBytes?: number): lib$WordArray,
    init(typedArray: ArrayBuffer): void,
    init(typedArray: Int8Array): void,
    create(typedArray: ArrayBuffer): lib$WordArray,
    create(typedArray: Int8Array): lib$WordArray,
    toString(encoder?: enc$IEncoder): string,
    concat(wordArray: lib$WordArray): lib$WordArray,
    clamp(): void,
    clone(): lib$WordArray,
    random(nBytes: number): lib$WordArray
} & lib$Base


declare type lib$BufferedBlockAlgorithm = {
    reset(): void,
    clone(): lib$BufferedBlockAlgorithm
} & lib$Base


declare type lib$IHasher<C>= {
    cfg: C,
    init(cfg?: C): void,
    create(cfg?: C): lib$IHasher<C>,
    update(messageUpdate: string): lib$Hasher,
    update(messageUpdate: lib$WordArray): lib$Hasher,
    finalize(messageUpdate?: string): lib$WordArray,
    finalize(messageUpdate?: lib$WordArray): lib$WordArray,
    blockSize: number,
    _createHelper(hasher: lib$Hasher): lib$IHasherHelper<C>,
    _createHmacHelper(hasher: lib$Hasher): lib$IHasherHmacHelper,
    clone(): lib$IHasher<C >
} & lib$BufferedBlockAlgorithm


declare type lib$Hasher = {} & lib$IHasher


declare interface lib$IHasherHelper<C>{
    (message: string, cfg?: C): lib$WordArray,
    (message: lib$WordArray, cfg?: C): lib$WordArray
}

declare type lib$HasherHelper = {} & lib$IHasherHelper


declare interface lib$IHasherHmacHelper {
    (message: string, key: string): lib$WordArray,
    (message: string, key: lib$WordArray): lib$WordArray,
    (message: lib$WordArray, key: string): lib$WordArray,
    (message: lib$WordArray, key: lib$WordArray): lib$WordArray
}

declare type lib$ICipher<C>= {
    cfg: C,
    createEncryptor(key: lib$WordArray, cfg?: C): lib$ICipher<C>,
    createDecryptor(key: lib$WordArray, cfg?: C): lib$ICipher<C>,
    create(xformMode?: number, key?: lib$WordArray, cfg?: C): lib$ICipher<C>,
    init(xformMode?: number, key?: lib$WordArray, cfg?: C): void,
    process(dataUpdate: string): lib$WordArray,
    process(dataUpdate: lib$WordArray): lib$WordArray,
    finalize(dataUpdate?: string): lib$WordArray,
    finalize(dataUpdate?: lib$WordArray): lib$WordArray,
    keySize: number,
    ivSize: number,
    _createHelper(cipher: lib$Cipher): lib$ICipherHelper<C>,
    clone(): lib$ICipher<C >
} & lib$BufferedBlockAlgorithm


declare type lib$Cipher = {} & lib$ICipher


declare type lib$IStreamCipher<C>= {
    drop?: number,
    createEncryptor(key: lib$WordArray, cfg?: C): lib$IStreamCipher<C>,
    createDecryptor(key: lib$WordArray, cfg?: C): lib$IStreamCipher<C>,
    create(xformMode?: number, key?: lib$WordArray, cfg?: C): lib$IStreamCipher<C>,
    blockSize: number
} & lib$ICipher


declare type lib$StreamCipher = {} & lib$IStreamCipher


declare type lib$BlockCipherMode = {
    createEncryptor(cipher: lib$Cipher, iv: number[]): mode$IBlockCipherEncryptor,
    createDecryptor(cipher: lib$Cipher, iv: number[]): mode$IBlockCipherDecryptor,
    init(cipher?: lib$Cipher, iv?: number[]): void,
    create(cipher?: lib$Cipher, iv?: number[]): lib$BlockCipherMode
} & lib$Base


declare type lib$BlockCipher = {} & lib$IStreamCipher


declare interface lib$IBlockCipherCfg {
    iv?: lib$WordArray,
        mode?: mode$IBlockCipherModeImpl,
        padding?: pad$IPaddingImpl
}

declare interface lib$CipherParamsData {
    ciphertext?: lib$WordArray,
        key?: lib$WordArray,
        iv?: lib$WordArray,
        salt?: lib$WordArray,
        algorithm?: lib$Cipher,
        mode?: mode$IBlockCipherModeImpl,
        padding?: pad$IPaddingImpl,
        blockSize?: number,
        formatter?: format$IFormatter
}

declare type lib$CipherParams = {
    init(cipherParams?: lib$CipherParamsData): void,
    create(cipherParams?: lib$CipherParamsData): lib$CipherParams,
    toString(formatter?: format$IFormatter): string
} & lib$Base & lib$CipherParamsData


declare type lib$ISerializableCipher<C>= {
    cfg: C,
    encrypt(
        cipher: lib$Cipher,
        message: lib$WordArray,
        key: lib$WordArray,
        cfg?: C): lib$CipherParams,
    encrypt(
        cipher: lib$Cipher,
        message: string,
        key: lib$WordArray,
        cfg?: C): lib$CipherParams,
    decrypt(
        cipher: lib$Cipher,
        ciphertext: lib$CipherParamsData,
        key: lib$WordArray,
        cfg?: C): lib$WordArray,
    decrypt(
        cipher: lib$Cipher,
        ciphertext: string,
        key: lib$WordArray,
        cfg?: C): lib$WordArray
} & lib$Base


declare type lib$SerializableCipher = {} & lib$ISerializableCipher


declare interface lib$ISerializableCipherCfg {
    format?: format$IFormatter,
        iv?: lib$WordArray,
        mode?: mode$IBlockCipherModeImpl,
        padding?: pad$IPaddingImpl
}

declare type lib$IPasswordBasedCipher<C>= {
    cfg: C,
    encrypt(
        cipher: lib$Cipher,
        message: lib$WordArray,
        password: string,
        cfg?: C): lib$CipherParams,
    encrypt(
        cipher: lib$Cipher,
        message: string,
        password: string,
        cfg?: C): lib$CipherParams,
    decrypt(
        cipher: lib$Cipher,
        ciphertext: lib$CipherParamsData,
        password: string,
        cfg?: C): lib$WordArray,
    decrypt(
        cipher: lib$Cipher,
        ciphertext: string,
        password: string,
        cfg?: C): lib$WordArray
} & lib$Base


declare type lib$PasswordBasedCipher = {} & lib$IPasswordBasedCipher


declare type lib$IPasswordBasedCipherCfg = {
    kdf?: kdf$IKdfImpl,
    mode?: mode$IBlockCipherModeImpl,
    padding?: pad$IPaddingImpl
} & lib$ISerializableCipherCfg



/**
 * see Cipher._createHelper 
 */
declare interface lib$ICipherHelper<C>{
    encrypt(message: string, password: string, cfg?: C): lib$CipherParams,
    encrypt(message: string, key: lib$WordArray, cfg?: C): lib$CipherParams,
    encrypt(message: lib$WordArray, password: string, cfg?: C): lib$CipherParams,
    encrypt(message: lib$WordArray, key: lib$WordArray, cfg?: C): lib$CipherParams,
    decrypt(ciphertext: string, password: string, cfg?: C): lib$WordArray,
    decrypt(ciphertext: string, key: lib$WordArray, cfg?: C): lib$WordArray,
    decrypt(ciphertext: lib$CipherParamsData, password: string, cfg?: C): lib$WordArray,
    decrypt(ciphertext: lib$CipherParamsData, key: lib$WordArray, cfg?: C): lib$WordArray
}

declare type lib$CipherHelper = {} & lib$ICipherHelper


declare interface lib$LibStatic {
    Base: lib$Base,
        WordArray: lib$WordArray,
        CipherParams: lib$CipherParams,
        SerializableCipher: lib$SerializableCipher,
        PasswordBasedCipher: lib$PasswordBasedCipher
}

declare interface enc$IEncoder {
    stringify(wordArray: lib$WordArray): string
}

declare interface enc$IDecoder {
    parse(s: string): lib$WordArray
}

declare type enc$ICoder = {} & enc$IEncoder & enc$IDecoder


declare interface enc$EncStatic {
    Hex: enc$ICoder,
        Latin1: enc$ICoder,
        Utf8: enc$ICoder,
        Base64: enc$ICoder,
        Utf16: enc$ICoder,
        Utf16BE: enc$ICoder,
        Utf16LE: enc$ICoder
}

declare interface kdf$KdfStatic {
    OpenSSL: kdf$IKdfImpl
}

declare interface kdf$IKdfImpl {
    execute(
            password: string,
            keySize: number,
            ivSize: number,
            salt?: string): lib$CipherParams,
        execute(
            password: string,
            keySize: number,
            ivSize: number,
            salt?: lib$WordArray): lib$CipherParams
}

declare interface format$FormatStatic {
    OpenSSL: format$IFormatter,
        Hex: format$IFormatter
}

declare interface format$IFormatter {
    stringify(cipherParams: lib$CipherParamsData): string,
        parse(s: string): lib$CipherParams
}

declare interface algo$AlgoStatic {
    AES: algo$AES,
        DES: algo$DES,
        TripleDES: algo$TripleDES,
        RabbitLegacy: algo$RabbitLegacy,
        Rabbit: algo$Rabbit,
        RC4: algo$RC4,
        MD5: algo$MD5,
        RIPEMD160: algo$RIPEMD160,
        SHA1: algo$SHA1,
        SHA256: algo$SHA256,
        SHA224: algo$SHA224,
        SHA384: algo$SHA384,
        SHA512: algo$SHA512,
        SHA3: algo$SHA3,
        HMAC: algo$HMAC,
        EvpKDF: algo$EvpKDF,
        PBKDF2: algo$PBKDF2,
        RC4Drop: algo$RC4Drop
}

declare type algo$IBlockCipherImpl = {
    encryptBlock(M: number[], offset: number): void,
    decryptBlock(M: number[], offset: number): void,
    createEncryptor(key: lib$WordArray, cfg?: lib$CipherParamsData): algo$IBlockCipherImpl,
    createDecryptor(key: lib$WordArray, cfg?: lib$CipherParamsData): algo$IBlockCipherImpl,
    create(
        xformMode?: number,
        key?: lib$WordArray,
        cfg?: lib$IBlockCipherCfg): algo$IBlockCipherImpl
}

declare type algo$AES = {} & algo$IBlockCipherImpl


declare type algo$DES = {} & algo$IBlockCipherImpl


declare type algo$TripleDES = {} & algo$IBlockCipherImpl


declare type algo$RabbitLegacy = {}

declare type algo$Rabbit = {}

declare type algo$RC4 = {}

declare type algo$MD5 = {}

declare type algo$RIPEMD160 = {}

declare type algo$SHA1 = {}

declare type algo$SHA256 = {}

declare type algo$SHA224 = {}

declare type algo$SHA384 = {}

declare type algo$SHA512 = {}

declare type algo$SHA3 = {}

declare interface algo$ISHA3Cfg {
    outputLength?: number
}

declare type algo$HMAC = {
    init(hasher?: lib$Hasher, key?: string): void,
    init(hasher?: lib$Hasher, key?: lib$WordArray): void,
    create(hasher?: lib$Hasher, key?: string): algo$HMAC,
    create(hasher?: lib$Hasher, key?: lib$WordArray): algo$HMAC,
    update(messageUpdate: string): algo$HMAC,
    update(messageUpdate: lib$WordArray): algo$HMAC,
    finalize(messageUpdate?: string): lib$WordArray,
    finalize(messageUpdate?: lib$WordArray): lib$WordArray
}

declare type algo$EvpKDF = {
    cfg: algo$IEvpKDFCfg,
    init(cfg?: algo$IEvpKDFCfg): void,
    create(cfg?: algo$IEvpKDFCfg): algo$EvpKDF,
    compute(password: string, salt: string): lib$WordArray,
    compute(password: string, salt: lib$WordArray): lib$WordArray,
    compute(password: lib$WordArray, salt: string): lib$WordArray,
    compute(password: lib$WordArray, salt: lib$WordArray): lib$WordArray
}

declare interface algo$IEvpKDFCfg {
    keySize?: number,
        hasher?: lib$Hasher,
        iterations?: number
}

declare interface algo$IEvpKDFHelper {
    (password: string, salt: string, cfg?: algo$IEvpKDFCfg): lib$WordArray,
    (password: string, salt: lib$WordArray, cfg?: algo$IEvpKDFCfg): lib$WordArray,
    (password: lib$WordArray, salt: string, cfg?: algo$IEvpKDFCfg): lib$WordArray,
    (password: lib$WordArray, salt: lib$WordArray, cfg?: algo$IEvpKDFCfg): lib$WordArray
}

declare type algo$PBKDF2 = {} & algo$EvpKDF


declare type algo$RC4Drop = {} & algo$RC4


declare interface mode$ModeStatic {
    CBC: mode$CBC,
        CFB: mode$CFB,
        CTR: mode$CTR,
        CTRGladman: mode$CTRGladman,
        ECB: mode$ECB,
        OFB: mode$OFB
}

declare type mode$IBlockCipherEncryptor = {
    processBlock(words: number[], offset: number): void
}

declare type mode$IBlockCipherDecryptor = {
    processBlock(words: number[], offset: number): void
}

declare type mode$IBlockCipherModeImpl = {
    Encryptor: mode$IBlockCipherEncryptor,
    Decryptor: mode$IBlockCipherDecryptor
}

declare type mode$CBC = {} & mode$IBlockCipherModeImpl


declare type mode$CFB = {} & mode$IBlockCipherModeImpl


declare type mode$CTR = {} & mode$IBlockCipherModeImpl


declare type mode$CTRGladman = {} & mode$IBlockCipherModeImpl


declare type mode$ECB = {} & mode$IBlockCipherModeImpl


declare type mode$OFB = {} & mode$IBlockCipherModeImpl


declare interface pad$PadStatic {
    Pkcs7: pad$Pkcs7,
        AnsiX923: pad$AnsiX923,
        Iso10126: pad$Iso10126,
        Iso97971: pad$Iso97971,
        ZeroPadding: pad$ZeroPadding,
        NoPadding: pad$NoPadding
}

declare interface pad$IPaddingImpl {
    pad(data: lib$WordArray, blockSize: number): void,
        unpad(data: lib$WordArray): void
}

declare type pad$Pkcs7 = {} & pad$IPaddingImpl


declare type pad$AnsiX923 = {} & pad$IPaddingImpl


declare type pad$Iso10126 = {} & pad$IPaddingImpl


declare type pad$Iso97971 = {} & pad$IPaddingImpl


declare type pad$ZeroPadding = {} & pad$IPaddingImpl


declare type pad$NoPadding = {} & pad$IPaddingImpl


declare interface x64$X64Static {
    Word: x64$Word,
        WordArray: x64$WordArray
}

declare type x64$Word = {
    high: number,
    low: number,
    init(high?: number, low?: number): void,
    create(high?: number, low?: number): x64$Word
}

declare type x64$WordArray = {
    words: number[],
    sigBytes: number,
    init(words?: number[], sigBytes?: number): void,
    create(words?: number[], sigBytes?: number): x64$WordArray,
    init(typedArray: ArrayBuffer): void,
    init(typedArray: Int8Array): void,
    create(typedArray: ArrayBuffer): x64$WordArray,
    create(typedArray: Int8Array): x64$WordArray,
    toString(encoder?: enc$IEncoder): string,
    concat(wordArray: x64$WordArray): x64$WordArray,
    clamp(): void,
    clone(): x64$WordArray,
    random(nBytes: number): x64$WordArray
} & lib$Base


declare interface CryptoJS$CryptoJSStatic {
    lib: lib$LibStatic,
        enc: enc$EncStatic,
        kdf: kdf$KdfStatic,
        format: format$FormatStatic,
        algo: algo$AlgoStatic,
        mode: mode$ModeStatic,
        pad: pad$PadStatic,
        x64: x64$X64Static,
        AES: undefined.ICipherHelper<undefined.IBlockCipherCfg>,
        DES: undefined.ICipherHelper<undefined.IBlockCipherCfg>,
        TripleDES: undefined.ICipherHelper<undefined.IBlockCipherCfg>,
        RabbitLegacy: undefined.CipherHelper,
        Rabbit: undefined.CipherHelper,
        RC4: undefined.CipherHelper,
        RC4Drop: undefined.ICipherHelper<Object>,
        MD5: undefined.HasherHelper,
        HmacMD5: undefined.IHasherHmacHelper,
        RIPEMD160: undefined.HasherHelper,
        HmacRIPEMD160: undefined.IHasherHmacHelper,
        SHA1: undefined.HasherHelper,
        HmacSHA1: undefined.IHasherHmacHelper,
        SHA256: undefined.HasherHelper,
        HmacSHA256: undefined.IHasherHmacHelper,
        SHA224: undefined.HasherHelper,
        HmacSHA224: undefined.IHasherHmacHelper,
        SHA512: undefined.HasherHelper,
        HmacSHA512: undefined.IHasherHmacHelper,
        SHA384: undefined.HasherHelper,
        HmacSHA384: undefined.IHasherHmacHelper,
        SHA3: undefined.IHasherHelper<undefined.ISHA3Cfg>,
        HmacSHA3: undefined.IHasherHmacHelper,
        EvpKDF: undefined.IEvpKDFHelper,
        PBKDF2: undefined.IEvpKDFHelper
}