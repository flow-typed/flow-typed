/**
 * Flowtype definitions for leaflet
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare type NativeMouseEvent = L$MouseEvent;
declare var npm$namespace$L: {
    latLng: typeof L$latLng,
    latLngBounds: typeof L$latLngBounds,
    point: typeof L$point,
    bounds: typeof L$bounds,
    gridLayer: typeof L$gridLayer,
    tileLayer: typeof L$tileLayer,
    imageOverlay: typeof L$imageOverlay,
    polyline: typeof L$polyline,
    polygon: typeof L$polygon,
    rectangle: typeof L$rectangle,
    circleMarker: typeof L$circleMarker,
    circle: typeof L$circle,
    svg: typeof L$svg,
    canvas: typeof L$canvas,
    layerGroup: typeof L$layerGroup,
    featureGroup: typeof L$featureGroup,
    geoJSON: typeof L$geoJSON,
    popup: typeof L$popup,
    tooltip: typeof L$tooltip,
    map: typeof L$map,
    icon: typeof L$icon,
    divIcon: typeof L$divIcon,
    marker: typeof L$marker,
}
declare export class Class {
    extend(props: any): any;
    include(props: any): any;
    mergeOptions(props: any): any;
    addInitHook(initHookFn: () => void): any
}

declare export class DomUtil {
    get(id: string): HTMLElement;
    get(id: HTMLElement): HTMLElement;
    getStyle(el: HTMLElement, styleAttrib: string): string;
    create(tagName: String, className?: String, container?: HTMLElement): HTMLElement;
    remove(el: HTMLElement): void;
    empty(el: HTMLElement): void;
    toFront(el: HTMLElement): void;
    toBack(el: HTMLElement): void;
    hasClass(el: HTMLElement, name: String): Boolean;
    addClass(el: HTMLElement, name: String): void;
    removeClass(el: HTMLElement, name: String): void;
    setClass(el: HTMLElement, name: String): void;
    getClass(el: HTMLElement): String;
    setOpacity(el: HTMLElement, opacity: Number): void;
    testProp(props: String[]): String | boolean;
    setTransform(el: HTMLElement, offset: L$Point, scale?: Number): void;
    setPosition(el: HTMLElement, position: L$Point): void;
    getPosition(el: HTMLElement): L$Point;
    disableTextSelection(): void;
    enableTextSelection(): void;
    disableImageDrag(): void;
    enableImageDrag(): void;
    preventOutline(el: HTMLElement): void;
    restoreOutline(): void
}

declare export interface L$CRS {
    latLngToPoint(latlng: L$LatLng, zoom: number): L$Point,
        latLngToPoint(latlng: L$LatLngLiteral, zoom: number): L$Point,
        latLngToPoint(latlng: L$LatLngTuple, zoom: number): L$Point,
        pointToLatLng(point: L$Point): L$LatLng,
        pointToLatLng(point: L$PointTuple): L$LatLng,
        project(latlng: L$LatLng): L$Point,
        project(latlng: L$LatLngLiteral): L$Point,
        project(latlng: L$LatLngTuple): L$Point,
        unproject(point: L$Point): L$LatLng,
        unproject(point: L$PointTuple): L$LatLng,
        scale(zoom: number): number,
        zoom(scale: number): number,
        getProjectedBounds(zoom: number): L$Bounds,
        distance(latlng1: L$LatLng, latlng2: L$LatLng): number,
        distance(latlng1: L$LatLngLiteral, latlng2: L$LatLngLiteral): number,
        distance(latlng1: L$LatLngTuple, latlng2: L$LatLngTuple): number,
        wrapLatLng(latlng: L$LatLng): L$LatLng,
        wrapLatLng(latlng: L$LatLngLiteral): L$LatLng,
        wrapLatLng(latlng: L$LatLngTuple): L$LatLng,
        code: string,
        wrapLng: [number, number],
        wrapLat: [number, number],
        infinite: boolean
}

declare export var EPSG3395: L$CRS;

declare export var EPSG3857: L$CRS;

declare export var EPSG4326: L$CRS;

declare export var Earth: L$CRS;

declare export var Simple: L$CRS;

declare export interface L$Projection {
    project(latlng: L$LatLng): L$Point,
        project(latlng: L$LatLngLiteral): L$Point,
        project(latlng: L$LatLngTuple): L$Point,
        unproject(point: L$Point): L$LatLng,
        unproject(point: L$PointTuple): L$LatLng,
        bounds: L$LatLngBounds
}

declare export var LonLat: L$Projection;

declare export var Mercator: L$Projection;

declare export var SphericalMercator: L$Projection;

declare export interface L$LatLng {
    equals(otherLatLng: L$LatLng, maxMargin?: number): boolean,
        equals(otherLatLng: L$LatLngLiteral, maxMargin?: number): boolean,
        equals(otherLatLng: L$LatLngTuple, maxMargin?: number): boolean,
        toString(): string,
        distanceTo(otherLatLng: L$LatLng): number,
        distanceTo(otherLatLng: L$LatLngLiteral): number,
        distanceTo(otherLatLng: L$LatLngTuple): number,
        wrap(): L$LatLng,
        toBounds(sizeInMeters: number): L$LatLngBounds,
        lat: number,
        lng: number,
        alt: number
}

declare export interface L$LatLngLiteral {
    lat: number,
        lng: number
}

declare export type L$LatLngTuple = [number, number];

declare type L$LatLngExpression = L$LatLng | L$LatLngLiteral | L$LatLngTuple;

declare export function L$latLng(latitude: number, longitude: number, altitude?: number): L$LatLng

declare export interface L$LatLngBounds {
    extend(latlng: L$LatLng): this,
        extend(latlng: L$LatLngLiteral): this,
        extend(latlng: L$LatLngTuple): this,
        extend(otherBounds: L$LatLngBounds): this,
        extend(otherBounds: L$LatLngBoundsLiteral): this,
        pad(bufferRatio: number): L$LatLngBounds,
        getCenter(): L$LatLng,
        getSouthWest(): L$LatLng,
        getNorthEast(): L$LatLng,
        getNorthWest(): L$LatLng,
        getSouthEast(): L$LatLng,
        getWest(): number,
        getSouth(): number,
        getEast(): number,
        getNorth(): number,
        contains(otherBounds: L$LatLngBounds): boolean,
        contains(otherBounds: L$LatLngBoundsLiteral): boolean,
        contains(latlng: L$LatLng): boolean,
        contains(latlng: L$LatLngLiteral): boolean,
        contains(latlng: L$LatLngTuple): boolean,
        intersects(otherBounds: L$LatLngBounds): boolean,
        intersects(otherBounds: L$LatLngLiteral): boolean,
        overlaps(otherBounds: L$Bounds): boolean,
        overlaps(otherBounds: L$BoundsLiteral): boolean,
        toBBoxString(): string,
        equals(otherBounds: L$LatLngBounds): boolean,
        equals(otherBounds: L$LatLngBoundsLiteral): boolean,
        isValid(): boolean
}

declare export type L$LatLngBoundsLiteral = Array<L$LatLngTuple>;

declare type L$LatLngBoundsExpression = L$LatLngBounds | L$LatLngBoundsLiteral;

declare export function L$latLngBounds(southWest: L$LatLng, northEast: L$LatLng): L$LatLngBounds

declare export type L$PointTuple = [number, number];

declare export interface L$Point {
    clone(): L$Point,
        add(otherPoint: L$Point): L$Point,
        add(otherPoint: L$PointTuple): L$Point,
        subtract(otherPoint: L$Point): L$Point,
        subtract(otherPoint: L$PointTuple): L$Point,
        divideBy(num: number): L$Point,
        multiplyBy(num: number): L$Point,
        scaleBy(scale: L$Point): L$Point,
        scaleBy(scale: L$PointTuple): L$Point,
        unscaleBy(scale: L$Point): L$Point,
        unscaleBy(scale: L$PointTuple): L$Point,
        round(): L$Point,
        floor(): L$Point,
        ceil(): L$Point,
        distanceTo(otherPoint: L$Point): L$Point,
        distanceTo(otherPoint: L$PointTuple): L$Point,
        equals(otherPoint: L$Point): boolean,
        equals(otherPoint: L$PointTuple): boolean,
        contains(otherPoint: L$Point): boolean,
        contains(otherPoint: L$PointTuple): boolean,
        toString(): string
}

declare type L$PointExpression = L$Point | L$PointTuple;

declare export function L$point(x: number, y: number, round?: boolean): L$Point

declare export type L$BoundsLiteral = Array<L$PointTuple>;

declare export interface L$Bounds {
    extend(point: L$Point): this,
        extend(point: L$PointTuple): this,
        getCenter(round?: boolean): L$Point,
        getBottomLeft(): L$Point,
        getTopRight(): L$Point,
        getSize(): L$Point,
        contains(otherBounds: L$Bounds): boolean,
        contains(otherBounds: L$BoundsLiteral): boolean,
        contains(point: L$Point): boolean,
        contains(point: L$PointTuple): boolean,
        intersects(otherBounds: L$Bounds): boolean,
        intersects(otherBounds: L$BoundsLiteral): boolean,
        overlaps(otherBounds: L$Bounds): boolean,
        overlaps(otherBounds: L$BoundsLiteral): boolean,
        min: L$Point,
        max: L$Point
}

declare type L$BoundsExpression = L$Bounds | L$BoundsLiteral;

declare export function L$bounds(topLeft: L$Point, bottomRight: L$Point): L$Bounds

declare export type L$EventHandlerFn = (event: L$Event) => void;

declare export type L$EventHandlerFnMap = {
    [type: string]: L$EventHandlerFn
};


/**
 * A set of methods shared between event-powered classes (like Map and Marker).
 * Generally, events allow you to execute some function when something happens
with an object (e.g. the user clicks on the map, causing the map to fire
'click' event).
*/
declare export type L$Evented = {

    /**
     * Adds a listener function (fn) to a particular event type of the object.
     * You can optionally specify the context of the listener (object the this
    keyword will point to). You can also pass several space-separated types
    (e.g. 'click dblclick').
    */
    on(type: string, fn: L$EventHandlerFn, context?: Object): this,

    /**
     * Adds a set of type/listener pairs, e.g. {click: onClick, mousemove: onMouseMove}
     */
    on(eventMap: L$EventHandlerFnMap): this,

    /**
     * Removes a previously added listener function. If no function is specified,
     * it will remove all the listeners of that particular event from the object.
    Note that if you passed a custom context to on, you must pass the same context
    to off in order to remove the listener.
    */
    off(type: string, fn?: L$EventHandlerFn, context?: Object): this,

    /**
     * Removes a set of type/listener pairs.
     */
    off(eventMap: L$EventHandlerFnMap): this,

    /**
     * Removes all listeners to all events on the object.
     */
    off(): this,

    /**
     * Fires an event of the specified type. You can optionally provide a data
     * object — the first argument of the listener function will contain its properties.
    The event might can optionally be propagated to event parents.
    */
    fire(type: string, data?: Object, propagate?: boolean): this,

    /**
     * Returns true if a particular event type has any listeners attached to it.
     */
    listens(type: string): boolean,

    /**
     * Behaves as on(...), except the listener will only get fired once and then removed.
     */
    once(type: string, fn: L$EventHandlerFn, context?: Object): this,

    /**
     * Behaves as on(...), except the listener will only get fired once and then removed.
     */
    once(eventMap: L$EventHandlerFnMap): this,

    /**
     * Adds an event parent - an Evented that will receive propagated events
     */
    addEventParent(obj: L$Evented): this,

    /**
     * Removes an event parent, so it will stop receiving propagated events
     */
    removeEventParent(obj: L$Evented): this,

    /**
     * Alias for on(...)
     * 
    Adds a listener function (fn) to a particular event type of the object.
    You can optionally specify the context of the listener (object the this
    keyword will point to). You can also pass several space-separated types
    (e.g. 'click dblclick').
    */
    addEventListener(type: string, fn: L$EventHandlerFn, context?: Object): this,

    /**
     * Alias for on(...)
     * 
    Adds a set of type/listener pairs, e.g. {click: onClick, mousemove: onMouseMove}
    */
    addEventListener(eventMap: L$EventHandlerFnMap): this,

    /**
     * Alias for off(...)
     * 
    Removes a previously added listener function. If no function is specified,
    it will remove all the listeners of that particular event from the object.
    Note that if you passed a custom context to on, you must pass the same context
    to off in order to remove the listener.
    */
    removeEventListener(type: string, fn: L$EventHandlerFn, context?: Object): this,

    /**
     * Alias for off(...)
     * 
    Removes a set of type/listener pairs.
    */
    removeEventListener(eventMap: L$EventHandlerFnMap): this,

    /**
     * Alias for off()
     * 
    Removes all listeners to all events on the object.
    */
    clearAllEventListeners(): this,

    /**
     * Alias for once(...)
     * 
    Behaves as on(...), except the listener will only get fired once and then removed.
    */
    addOneTimeEventListener(type: string, fn: L$EventHandlerFn, context?: Object): this,

    /**
     * Alias for once(...)
     * 
    Behaves as on(...), except the listener will only get fired once and then removed.
    */
    addOneTimeEventListener(eventMap: L$EventHandlerFnMap): this,

    /**
     * Alias for fire(...)
     * 
    Fires an event of the specified type. You can optionally provide a data
    object — the first argument of the listener function will contain its properties.
    The event might can optionally be propagated to event parents.
    */
    fireEvent(type: string, data?: Object, propagate?: boolean): this,

    /**
     * Alias for listens(...)
     * 
    Returns true if a particular event type has any listeners attached to it.
    */
    hasEventListeners(type: string): boolean
} & L$Class


declare interface L$LayerOptions {
    pane?: string
}

declare type L$InteractiveLayerOptions = {
    interactive?: boolean
} & L$LayerOptions


declare export type L$Layer = {
    addTo(map: L$Map): this,
    remove(): this,
    removeFrom(map: L$Map): this,
    getPane(name?: string): HTMLElement,
    bindPopup(content: string, options?: L$PopupOptions): this,
    bindPopup(content: HTMLElement, options?: L$PopupOptions): this,
    bindPopup(content: (layer: L$Layer) => L$Content, options?: L$PopupOptions): this,
    bindPopup(content: L$Popup): this,
    unbindPopup(): this,
    openPopup(): this,
    openPopup(latlng: L$LatLng): this,
    openPopup(latlng: L$LatLngLiteral): this,
    openPopup(latlng: L$LatLngTuple): this,
    closePopup(): this,
    togglePopup(): this,
    isPopupOpen(): boolean,
    setPopupContent(content: string): this,
    setPopupContent(content: HTMLElement): this,
    setPopupContent(content: L$Popup): this,
    getPopup(): L$Popup,
    bindTooltip(content: string, options?: L$TooltipOptions): this,
    bindTooltip(content: HTMLElement, options?: L$TooltipOptions): this,
    bindTooltip(content: (layer: L$Layer) => L$Content, options?: L$TooltipOptions): this,
    bindTooltip(content: L$Tooltip, options?: L$TooltipOptions): this,
    unbindTooltip(): this,
    openTooltip(): this,
    openTooltip(latlng: L$LatLng): this,
    openTooltip(latlng: L$LatLngLiteral): this,
    openTooltip(latlng: L$LatLngTuple): this,
    closeTooltip(): this,
    toggleTooltip(): this,
    isTooltipOpen(): boolean,
    setTooltipContent(content: string): this,
    setTooltipContent(content: HTMLElement): this,
    setTooltipContent(content: L$Tooltip): this,
    getTooltip(): L$Tooltip,
    onAdd(map: L$Map): this,
    onRemove(map: L$Map): this,
    getEvents(): {
        [name: string]: (event: L$Event) => void
    },
    getAttribution(): string,
    beforeAdd(map: L$Map): this
} & L$Evented


declare export interface L$GridLayerOptions {
    tileSize?: number | L$Point,
        opacity?: number,
        updateWhenIdle?: boolean,
        updateWhenZooming?: boolean,
        updateInterval?: number,
        attribution?: string,
        zIndex?: number,
        bounds?: L$LatLngBoundsExpression,
        minZoom?: number,
        maxZoom?: number,
        noWrap?: boolean,
        pane?: string,
        className?: string,
        keepBuffer?: number
}

declare export type L$GridLayer = {
    bringToFront(): this,
    bringToBack(): this,
    getAttribution(): string,
    getContainer(): HTMLElement,
    setOpacity(opacity: number): this,
    setZIndex(zIndex: number): this,
    isLoading(): boolean,
    redraw(): this,
    getTileSize(): L$Point
} & L$Layer


declare export function L$gridLayer(options?: L$GridLayerOptions): L$GridLayer

declare export type L$TileLayerOptions = {
    minZoom?: number,
    maxZoom?: number,
    maxNativeZoom?: number,
    subdomains?: string | Array<string>,
    errorTileUrl?: string,
    zoomOffset?: number,
    tms?: boolean,
    zoomReverse?: boolean,
    detectRetina?: boolean,
    crossOrigin?: boolean,
    [name: string]: any
} & L$GridLayerOptions


declare export type L$TileLayer = {
    setUrl(url: string, noRedraw?: boolean): this
} & L$GridLayer


declare export function L$tileLayer(urlTemplate: string, options?: L$TileLayerOptions): L$TileLayer

declare export type L$WMSOptions = {
    layers: string,
    styles?: string,
    format?: string,
    transparent?: boolean,
    version?: string,
    crs?: L$CRS,
    uppercase?: boolean
} & L$TileLayerOptions


declare export type L$WMS = {
    setParams(params: Object, noRedraw?: boolean): this
} & L$TileLayer



declare var npm$namespace$tileLayer: {
    wms: typeof tileLayer$wms,
}
declare export function tileLayer$wms(baseUrl: string, options: L$WMSOptions): L$WMS

declare export type L$ImageOverlayOptions = {
    opacity?: number,
    alt?: string,
    interactive?: boolean,
    attribution?: string,
    crossOrigin?: boolean
} & L$LayerOptions


declare export type L$ImageOverlay = {
    setOpacity(opacity: number): this,
    bringToFront(): this,
    bringToBack(): this,
    setUrl(url: string): this
} & L$Layer


declare export function L$imageOverlay(
    imageUrl: string,
    bounds: L$LatLngBoundsExpression,
    options?: L$ImageOverlayOptions): L$ImageOverlay

declare export type L$LineCapShape = "butt" | "round" | "square" | "inherit";

declare export type L$LineJoinShape = "miter" | "round" | "bevel" | "inherit";

declare export type L$FillRule = "nonzero" | "evenodd" | "inherit";

declare export type L$PathOptions = {
    stroke?: boolean,
    color?: string,
    weight?: number,
    opacity?: number,
    lineCap?: L$LineCapShape,
    lineJoin?: L$LineJoinShape,
    dashArray?: string,
    dashOffset?: string,
    fill?: boolean,
    fillColor?: string,
    fillOpacity?: number,
    fillRule?: L$FillRule,
    renderer?: L$Renderer,
    className?: string
} & L$InteractiveLayerOptions


declare export type L$Path = {
    redraw(): this,
    setStyle(style: L$PathOptions): this,
    bringToFront(): this,
    bringToBack(): this
} & L$Layer


declare export type L$PolylineOptions = {
    smoothFactor?: number,
    noClip?: boolean
} & L$PathOptions


declare type L$InternalPolyline = {
    getLatLngs(): Array<L$LatLng>,
    setLatLngs(latlngs: Array<L$LatLng>): this,
    setLatLngs(latlngs: Array<L$LatLngLiteral>): this,
    setLatLngs(latlngs: Array<L$LatLngTuple>): this,
    isEmpty(): boolean,
    getCenter(): L$LatLng,
    getBounds(): L$LatLngBounds,
    addLatLng(latlng: L$LatLng): this,
    addLatLng(latlng: L$LatLngLiteral): this,
    addLatLng(latlng: L$LatLngTuple): this,
    addLatLng(latlng: Array<L$LatLng>): this,
    addLatLng(latlng: Array<L$LatLngLiteral>): this,
    addLatLng(latlng: Array<L$LatLngTuple>): this
} & L$Path


declare export type L$Polyline = {
    toGeoJSON(): GeoJSON.LineString | GeoJSON.MultiLineString
} & L$InternalPolyline


declare export function L$polyline(latlngs: Array<L$LatLng>, options?: L$PolylineOptions): L$Polyline

declare export type L$Polygon = {
    toGeoJSON(): GeoJSON.Polygon | GeoJSON.MultiPolygon
} & L$InternalPolyline


declare export function L$polygon(latlngs: Array<L$LatLng>, options?: L$PolylineOptions): L$Polygon

declare export type L$Rectangle = {
    setBounds(latLngBounds: L$LatLngBounds): this,
    setBounds(latLngBounds: L$LatLngBoundsLiteral): this
} & L$Polygon


declare export function L$rectangle(latLngBounds: L$LatLngBounds, options?: L$PolylineOptions): L$Rectangle

declare export type L$CircleMarkerOptions = {
    radius?: number
} & L$PathOptions


declare export type L$CircleMarker = {
    toGeoJSON(): GeoJSON.Point,
    setLatLng(latLng: L$LatLng): this,
    setLatLng(latLng: L$LatLngLiteral): this,
    setLatLng(latLng: L$LatLngTuple): this,
    getLatLng(): L$LatLng,
    setRadius(radius: number): this,
    getRadius(): number
} & L$Path


declare export function L$circleMarker(latlng: L$LatLng, options?: L$CircleMarkerOptions): L$CircleMarker

declare export type L$CircleOptions = {
    radius?: number
} & L$PathOptions


declare export type L$Circle = {
    setRadius(radius: number): this,
    getRadius(): number,
    getBounds(): L$LatLngBounds
} & L$CircleMarker


declare export function L$circle(latlng: L$LatLng, options?: L$CircleOptions): L$Circle

declare export type L$RendererOptions = {
    padding?: number
} & L$LayerOptions


declare export type L$Renderer = {} & L$Layer


declare export type L$SVG = {} & L$Renderer



declare var npm$namespace$SVG: {
    create: typeof SVG$create,
    pointsToPath: typeof SVG$pointsToPath,
}
declare export function SVG$create(name: string): SVGElement

declare export function SVG$pointsToPath(rings: Array<L$Point>, close: boolean): string

declare export function L$svg(options?: L$RendererOptions): L$SVG

declare export type L$Canvas = {} & L$Renderer


declare export function L$canvas(options?: L$RendererOptions): L$Canvas


/**
 * Used to group several layers and handle them as one.
 * If you add it to the map, any layers added or removed from the group will be
added/removed on the map as well. Extends Layer.
*/
declare export type L$LayerGroup = {

    /**
     * Returns a GeoJSON representation of the layer group (as a GeoJSON GeometryCollection).
     */
    toGeoJSON(): GeoJSON.GeometryCollection,

    /**
     * Adds the given layer to the group.
     */
    addLayer(layer: L$Layer): this,

    /**
     * Removes the given layer from the group.
     */
    removeLayer(layer: L$Layer): this,

    /**
     * Removes the layer with the given internal ID from the group.
     */
    removeLayer(id: number): this,

    /**
     * Returns true if the given layer is currently added to the group.
     */
    hasLayer(layer: L$Layer): boolean,

    /**
     * Removes all the layers from the group.
     */
    clearLayers(): this,

    /**
     * Calls methodName on every layer contained in this group, passing any additional parameters.
     * Has no effect if the layers contained do not implement methodName.
     */
    invoke(methodName: string, ...params: Array<any>): this,

    /**
     * Iterates over the layers of the group,
     * optionally specifying context of the iterator function.
     */
    eachLayer(fn: (layer: L$Layer) => void, context?: Object): this,

    /**
     * Returns the layer with the given internal ID.
     */
    getLayer(id: number): L$Layer,

    /**
     * Returns an array of all the layers added to the group.
     */
    getLayers(): Array<L$Layer>,

    /**
     * Calls setZIndex on every layer contained in this group, passing the z-index.
     */
    setZIndex(zIndex: number): this,

    /**
     * Returns the internal ID for a layer
     */
    getLayerId(layer: L$Layer): number
} & L$Layer



/**
 * Create a layer group, optionally given an initial set of layers.
 */
declare export function L$layerGroup(layers: Array<L$Layer>): L$LayerGroup


/**
 * Extended LayerGroup that also has mouse events (propagated from
 * members of the group) and a shared bindPopup method.
 */
declare export type L$FeatureGroup = {

    /**
     * Sets the given path options to each layer of the group that has a setStyle method.
     */
    setStyle(style: L$PathOptions): this,

    /**
     * Brings the layer group to the top of all other layers
     */
    bringToFront(): this,

    /**
     * Brings the layer group to the top [sic] of all other layers
     */
    bringToBack(): this,

    /**
     * Returns the LatLngBounds of the Feature Group (created from
     * bounds and coordinates of its children).
     */
    getBounds(): L$LatLngBounds
} & L$LayerGroup



/**
 * Create a feature group, optionally given an initial set of layers.
 */
declare export function L$featureGroup(layers?: Array<L$Layer>): L$FeatureGroup

declare type L$StyleFunction = (feature: GeoJSON.Feature<GeoJSON.GeometryObject>) => L$PathOptions;

declare export type L$GeoJSONOptions = {

    /**
     * A Function defining how GeoJSON points spawn Leaflet layers.
     * It is internally called when data is added, passing the GeoJSON point
    feature and its LatLng.

    The default is to spawn a default Marker:

    ```
    function(geoJsonPoint, latlng) {
         return L.marker(latlng);
    }
    ```
    */
    pointToLayer?: (geoJsonPoint: GeoJSON.Point, latlng: L$LatLng) => L$Layer,

    /**
     * A Function defining the Path options for styling GeoJSON lines and polygons,
     * called internally when data is added.

    The default value is to not override any defaults:

    ```
    function (geoJsonFeature) {
         return {}
    }
    ```
    */
    style?: L$StyleFunction,

    /**
     * A Function that will be called once for each created Feature, after it
     * has been created and styled. Useful for attaching events and popups to features.

    The default is to do nothing with the newly created layers:

    ```
    function (feature, layer) {}
    ```
    */
    onEachFeature?: (feature: GeoJSON.Feature<GeoJSON.GeometryObject>, layer: L$Layer) => void,

    /**
     * A Function that will be used to decide whether to show a feature or not.
     * 
    The default is to show all features:

    ```
    function (geoJsonFeature) {
         return true;
    }
    ```
    */
    filter?: (geoJsonFeature: GeoJSON.Feature<GeoJSON.GeometryObject>) => boolean,

    /**
     * A Function that will be used for converting GeoJSON coordinates to LatLngs.
     * The default is the coordsToLatLng static method.
     */
    coordsToLatLng?: (coords: [number, number] | [number, number, number]) => L$LatLng
} & L$LayerOptions



/**
 * Represents a GeoJSON object or an array of GeoJSON objects.
 * Allows you to parse GeoJSON data and display it on the map. Extends FeatureGroup.
 */
declare export type L$GeoJSON = {

    /**
     * Adds a GeoJSON object to the layer.
     */
    addData(data: GeoJSON.GeoJsonObject): L$Layer,

    /**
     * Resets the given vector layer's style to the original GeoJSON style,
     * useful for resetting style after hover events.
     */
    resetStyle(layer: L$Layer): L$Layer,

    /**
     * Changes styles of GeoJSON vector layers with the given style function.
     */
    setStyle(style: L$StyleFunction): this,

    /**
     * Creates a Layer from a given GeoJSON feature. Can use a custom pointToLayer
     * and/or coordsToLatLng functions if provided as options.
     */
    geometryToLayer(
        featureData: GeoJSON.Feature<GeoJSON.GeometryObject>,
        options?: L$GeoJSONOptions): L$Layer,

    /**
     * Creates a LatLng object from an array of 2 numbers (longitude, latitude) or
     * 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
     */
    coordsToLatLng(coords: [number, number]): L$LatLng,
    coordsToLatLng(coords: [number, number, number]): L$LatLng,

    /**
     * Creates a multidimensional array of LatLngs from a GeoJSON coordinates array.
     * levelsDeep specifies the nesting level (0 is for an array of points, 1 for an array of
    arrays of points, etc., 0 by default).
    Can use a custom coordsToLatLng function.
    */
    coordsToLatLngs(
        coords: Array<number>,
        levelsDeep?: number,
        coordsToLatLng?: (coords: [number, number] | [number, number, number]) => L$LatLng): L$LatLng[],

    /**
     * Reverse of coordsToLatLng
     */
    latLngToCoords(latlng: L$LatLng): [number, number] | [number, number, number],

    /**
     * Reverse of coordsToLatLngs closed determines whether the first point should be
     * appended to the end of the array to close the feature, only used when levelsDeep is 0.
    False by default.
    */
    latLngsToCoords(
        latlngs: Array<L$LatLng>,
        levelsDeep?: number,
        closed?: boolean): [number, number] | [number, number, number],

    /**
     * Normalize GeoJSON geometries/features into GeoJSON features.
     */
    asFeature(geojson: GeoJSON.GeometryObject): GeoJSON.Feature<GeoJSON.GeometryObject>,
    asFeature(
        geojson: GeoJSON.Feature<GeoJSON.GeometryObject>): GeoJSON.Feature<GeoJSON.GeometryObject >
} & L$FeatureGroup



/**
 * Creates a GeoJSON layer.
 * 
Optionally accepts an object in GeoJSON format to display on the
map (you can alternatively add it later with addData method) and
an options object.
*/
declare export function L$geoJSON(geojson?: GeoJSON.GeoJsonObject, options?: L$GeoJSONOptions): L$GeoJSON

declare type L$Zoom = boolean | "center";

declare export interface L$MapOptions {
    preferCanvas?: boolean,
        attributionControl?: boolean,
        zoomControl?: boolean,
        closePopupOnClick?: boolean,
        zoomSnap?: number,
        zoomDelta?: number,
        trackResize?: boolean,
        boxZoom?: boolean,
        doubleClickZoom?: L$Zoom,
        dragging?: boolean,
        crs?: L$CRS,
        center?: L$LatLngExpression,
        zoom?: number,
        minZoom?: number,
        maxZoom?: number,
        layers?: Array<L$Layer>,
        maxBounds?: L$LatLngBoundsExpression,
        renderer?: L$Renderer,
        fadeAnimation?: boolean,
        markerZoomAnimation?: boolean,
        transform3DLimit?: number,
        zoomAnimation?: boolean,
        zoomAnimationThreshold?: number,
        inertia?: boolean,
        inertiaDeceleration?: number,
        inertiaMaxSpeed?: number,
        easeLinearity?: number,
        worldCopyJump?: boolean,
        maxBoundsViscosity?: number,
        keyboard?: boolean,
        keyboardPanDelta?: number,
        scrollWheelZoom?: L$Zoom,
        wheelDebounceTime?: number,
        wheelPxPerZoomLevel?: number,
        tap?: boolean,
        tapTolerance?: number,
        touchZoom?: L$Zoom,
        bounceAtZoomLimits?: boolean
}

declare export type L$ControlPosition = "topleft" | "topright" | "bottomleft" | "bottomright";

declare export interface L$ControlOptions {
    position?: L$ControlPosition
}

declare export interface L$Control {
    getPosition(): L$ControlPosition,
        setPosition(position: L$ControlPosition): this,
        getContainer(): HTMLElement,
        addTo(map: L$Map): this,
        remove(): this,
        onAdd(map: L$Map): HTMLElement,
        onRemove(map: L$Map): void
}

declare export type Control$ZoomOptions = {
    zoomInText?: string,
    zoomInTitle?: string,
    zoomOutText?: string,
    zoomOutTitle?: string
} & L$ControlOptions


declare type Control$Zoom = boolean | "center";

declare export type Control$AttributionOptions = {
    prefix?: string | boolean
} & L$ControlOptions


declare export type Control$Attribution = {
    setPrefix(prefix: string): this,
    addAttribution(text: string): this,
    removeAttribution(text: string): this
} & L$Control


declare export type Control$LayersOptions = {
    collapsed?: boolean,
    autoZIndex?: boolean,
    hideSingleBase?: boolean
} & L$ControlOptions


declare export type Control$Layers = {
    addBaseLayer(layer: L$Layer, name: string): this,
    addOverlay(layer: L$Layer, name: string): this,
    removeLayer(layer: L$Layer): this,
    expand(): this,
    collapse(): this
} & L$Control


declare export type Control$ScaleOptions = {
    maxWidth?: number,
    metric?: boolean,
    imperial?: boolean,
    updateWhenIdle?: boolean
} & L$ControlOptions


declare export type Control$Scale = {} & L$Control



declare var npm$namespace$control: {
    zoom: typeof control$zoom,
    attribution: typeof control$attribution,
    layers: typeof control$layers,
    scale: typeof control$scale,
}
declare export function control$zoom(options: Control$ZoomOptions): Control$Zoom

declare export function control$attribution(options: Control$AttributionOptions): Control$Attribution

declare type control$LayersObject = {
    [name: string]: L$Layer
};

declare export function control$layers(
    baseLayers?: control$LayersObject,
    overlays?: control$LayersObject,
    options?: Control$LayersOptions): Control$Layers

declare export function control$scale(options?: Control$ScaleOptions): Control$Scale

declare interface L$DivOverlayOptions {
    offset?: L$PointExpression,
        zoomAnimation?: boolean,
        className?: string,
        pane?: string
}

declare export type L$PopupOptions = {
    maxWidth?: number,
    minWidth?: number,
    maxHeight?: number,
    autoPan?: boolean,
    autoPanPaddingTopLeft?: L$PointExpression,
    autoPanPaddingBottomRight?: L$PointExpression,
    autoPanPadding?: L$PointExpression,
    keepInView?: boolean,
    closeButton?: boolean,
    autoClose?: boolean
} & L$DivOverlayOptions


declare type L$Content = string | HTMLElement;

declare export type L$Popup = {
    getLatLng(): L$LatLng,
    setLatLng(latlng: L$LatLngExpression): this,
    getContent(): L$Content,
    setContent(htmlContent: string): this,
    setContent(htmlContent: HTMLElement): this,
    setContent(htmlContent: (source: L$Layer) => L$Content): this,
    getElement(): L$Content,
    update(): void,
    isOpen(): boolean,
    bringToFront(): this,
    bringToBack(): this,
    openOn(map: L$Map): this
} & L$Layer


declare export function L$popup(options?: L$PopupOptions, source?: L$Layer): L$Popup

declare export type L$Direction = "right" |
    "left" |
    "top" |
    "bottom" |
    "center" |
    "auto";

declare export type L$TooltipOptions = {
    pane?: string,
    offset?: L$PointExpression,
    direction?: L$Direction,
    permanent?: boolean,
    sticky?: boolean,
    interactive?: boolean,
    opacity?: number
} & L$DivOverlayOptions


declare export type L$Tooltip = {} & L$Layer


declare export function L$tooltip(options?: L$TooltipOptions, source?: L$Layer): L$Tooltip

declare export type L$ZoomOptions = {
    zoomInText?: string,
    zoomInTitle?: string,
    zoomOutText?: string,
    zoomOutTitle?: string
} & L$ControlOptions


declare export interface L$PanOptions {
    animate?: boolean,
        duration?: number,
        easeLinearity?: number,
        noMoveStart?: boolean
}

declare export type L$ZoomPanOptions = {} & L$ZoomOptions & L$PanOptions


declare export type L$FitBoundsOptions = {
    paddingTopLeft?: L$PointExpression,
    paddingBottomRight?: L$PointExpression,
    padding?: L$PointExpression,
    maxZoom?: number
} & L$ZoomOptions & L$PanOptions


declare export interface L$LocateOptions {
    watch?: boolean,
        setView?: boolean,
        maxZoom?: number,
        timeout?: number,
        maximumAge?: number,
        enableHighAccuracy?: boolean
}

declare export interface L$Handler {
    enable(): this,
        disable(): this,
        enabled(): boolean,
        addHooks(): void,
        removeHooks(): void
}

declare export interface L$Event {
    type: string,
        target: any
}

declare export type L$MouseEvent = {
    latlng: L$LatLng,
    layerPoint: L$Point,
    containerPoint: L$Point,
    originalEvent: NativeMouseEvent
} & L$Event


declare export type L$LocationEvent = {
    latlng: L$LatLng,
    bounds: L$LatLngBounds,
    accuracy: number,
    altitude: number,
    altitudeAccuracy: number,
    heading: number,
    speed: number,
    timestamp: number
} & L$Event


declare export type L$ErrorEvent = {
    message: string,
    code: number
} & L$Event


declare export type L$LayerEvent = {
    layer: L$Layer
} & L$Event


declare export type L$LayersControlEvent = {
    name: string
} & L$LayerEvent


declare export type L$TileEvent = {
    tile: HTMLImageElement,
    coords: L$Point
} & L$Event


declare export type L$TileErrorEvent = {
    error: Error
} & L$TileEvent


declare export type L$ResizeEvent = {
    oldSize: L$Point,
    newSize: L$Point
} & L$Event


declare export type L$GeoJSONEvent = {
    layer: L$Layer,
    properties: any,
    geometryType: string,
    id: string
} & L$Event


declare export type L$PopupEvent = {
    popup: L$Popup
} & L$Event


declare export type L$TooltipEvent = {
    tooltip: L$Tooltip
} & L$Event


declare export type L$DragEndEvent = {
    distance: number
} & L$Event



declare var npm$namespace$DomEvent: {
    on: typeof DomEvent$on,
    off: typeof DomEvent$off,
    stopPropagation: typeof DomEvent$stopPropagation,
    disableScrollPropagation: typeof DomEvent$disableScrollPropagation,
    disableClickPropagation: typeof DomEvent$disableClickPropagation,
    preventDefault: typeof DomEvent$preventDefault,
    stop: typeof DomEvent$stop,
    getMousePosition: typeof DomEvent$getMousePosition,
    getWheelDelta: typeof DomEvent$getWheelDelta,
    addListener: typeof DomEvent$addListener,
    removeListener: typeof DomEvent$removeListener,
}
declare export function DomEvent$on(
    el: HTMLElement,
    types: string,
    fn: (ev: L$Event) => any,
    context?: Object): typeof DomEvent

declare export function DomEvent$off(
    el: HTMLElement,
    types: string,
    fn: (ev: L$Event) => any,
    context?: Object): typeof DomEvent

declare export function DomEvent$stopPropagation(ev: L$Event): typeof DomEvent

declare export function DomEvent$disableScrollPropagation(el: HTMLElement): typeof DomEvent

declare export function DomEvent$disableClickPropagation(el: HTMLElement): typeof DomEvent

declare export function DomEvent$preventDefault(ev: L$Event): typeof DomEvent

declare export function DomEvent$stop(ev: L$Event): typeof DomEvent

declare export function DomEvent$getMousePosition(ev: L$Event, container?: HTMLElement): L$Point

declare export function DomEvent$getWheelDelta(ev: L$Event): number

declare export function DomEvent$addListener(
    el: HTMLElement,
    types: string,
    fn: (ev: L$Event) => any,
    context?: Object): typeof DomEvent

declare export function DomEvent$removeListener(
    el: HTMLElement,
    types: string,
    fn: (ev: L$Event) => any,
    context?: Object): typeof DomEvent

declare interface L$DefaultMapPanes {
    mapPane: HTMLElement,
        tilePane: HTMLElement,
        overlayPane: HTMLElement,
        shadowPane: HTMLElement,
        markerPane: HTMLElement,
        tooltipPane: HTMLElement,
        popupPane: HTMLElement
}

declare export type L$Map = {
    getRenderer(layer: L$Path): L$Renderer,
    addControl(control: L$Control): this,
    removeControl(control: L$Control): this,
    addLayer(layer: L$Layer): this,
    removeLayer(layer: L$Layer): this,
    hasLayer(layer: L$Layer): boolean,
    eachLayer(fn: (layer: L$Layer) => void, context?: Object): this,
    openPopup(popup: L$Popup): this,
    openPopup(content: string, latlng: L$LatLng, options?: L$PopupOptions): this,
    openPopup(content: string, latlng: L$LatLngLiteral, options?: L$PopupOptions): this,
    openPopup(content: string, latlng: L$LatLngTuple, options?: L$PopupOptions): this,
    openPopup(content: HTMLElement, latlng: L$LatLng, options?: L$PopupOptions): this,
    openPopup(content: HTMLElement, latlng: L$LatLngLiteral, options?: L$PopupOptions): this,
    openPopup(content: HTMLElement, latlng: L$LatLngTuple, options?: L$PopupOptions): this,
    closePopup(popup?: L$Popup): this,
    openTooltip(tooltip: L$Tooltip): this,
    openTooltip(content: string, latlng: L$LatLng, options?: L$TooltipOptions): this,
    openTooltip(content: string, latlng: L$LatLngLiteral, options?: L$TooltipOptions): this,
    openTooltip(content: string, latlng: L$LatLngTuple, options?: L$TooltipOptions): this,
    openTooltip(content: HTMLElement, latlng: L$LatLng, options?: L$TooltipOptions): this,
    openTooltip(
        content: HTMLElement,
        latlng: L$LatLngLiteral,
        options?: L$TooltipOptions): this,
    openTooltip(content: HTMLElement, latlng: L$LatLngTuple, options?: L$TooltipOptions): this,
    closeTooltip(tooltip?: L$Tooltip): this,
    setView(center: L$LatLng, zoom: number, options?: L$ZoomPanOptions): this,
    setView(center: L$LatLngLiteral, zoom: number, options?: L$ZoomPanOptions): this,
    setView(center: L$LatLngTuple, zoom: number, options?: L$ZoomPanOptions): this,
    setZoom(zoom: number, options: L$ZoomPanOptions): this,
    zoomIn(delta?: number, options?: L$ZoomOptions): this,
    zoomOut(delta?: number, options?: L$ZoomOptions): this,
    setZoomAround(latlng: L$LatLng, zoom: number, options: L$ZoomOptions): this,
    setZoomAround(latlng: L$LatLngLiteral, zoom: number, options: L$ZoomOptions): this,
    setZoomAround(latlng: L$LatLngTuple, zoom: number, options: L$ZoomOptions): this,
    setZoomAround(offset: L$Point, zoom: number, options: L$ZoomOptions): this,
    fitBounds(bounds: L$LatLngBounds, options: L$FitBoundsOptions): this,
    fitBounds(bounds: L$LatLngBoundsLiteral, options: L$FitBoundsOptions): this,
    fitWorld(options?: L$FitBoundsOptions): this,
    panTo(latlng: L$LatLng, options?: L$PanOptions): this,
    panTo(latlng: L$LatLngLiteral, options?: L$PanOptions): this,
    panTo(latlng: L$LatLngTuple, options?: L$PanOptions): this,
    panBy(offset: L$Point): this,
    panBy(offset: L$PointTuple): this,
    setMaxBounds(bounds: L$LatLngBounds): this,
    setMaxBounds(bounds: L$LatLngBoundsLiteral): this,
    setMinZoom(zoom: number): this,
    setMaxZoom(zoom: number): this,
    panInsideBounds(bounds: L$LatLngBounds, options?: L$PanOptions): this,
    panInsideBounds(bounds: L$LatLngBoundsLiteral, options?: L$PanOptions): this,
    invalidateSize(options: L$ZoomPanOptions): this,
    invalidateSize(animate: boolean): this,
    stop(): this,
    flyTo(latlng: L$LatLng, zoom?: number, options?: L$ZoomPanOptions): this,
    flyTo(latlng: L$LatLngLiteral, zoom?: number, options?: L$ZoomPanOptions): this,
    flyTo(latlng: L$LatLngTuple, zoom?: number, options?: L$ZoomPanOptions): this,
    flyToBounds(bounds: L$LatLngBounds, options?: L$FitBoundsOptions): this,
    flyToBounds(bounds: L$LatLngBoundsLiteral, options?: L$FitBoundsOptions): this,
    addHandler(name: string, HandlerClass: () => L$Handler): this,
    remove(): this,
    createPane(name: string, container?: HTMLElement): HTMLElement,
    getPane(pane: string): HTMLElement,
    getPane(pane: HTMLElement): HTMLElement,
    getPanes(): {
        [name: string]: HTMLElement
    } & L$DefaultMapPanes,
    getContainer(): HTMLElement,
    whenReady(fn: () => void, context?: Object): this,
    getCenter(): L$LatLng,
    getZoom(): number,
    getBounds(): L$LatLngBounds,
    getMinZoom(): number,
    getMaxZoom(): number,
    getBoundsZoom(bounds: L$LatLngBounds, inside?: boolean): number,
    getBoundsZoom(bounds: L$LatLngBoundsLiteral, inside?: boolean): number,
    getSize(): L$Point,
    getPixelBounds(): L$Bounds,
    getPixelOrigin(): L$Point,
    getPixelWorldBounds(zoom?: number): L$Bounds,
    getZoomScale(toZoom: number, fromZoom: number): number,
    getScaleZoom(scale: number, fromZoom: number): number,
    project(latlng: L$LatLng, zoom: number): L$Point,
    project(latlng: L$LatLngLiteral, zoom: number): L$Point,
    project(latlng: L$LatLngTuple, zoom: number): L$Point,
    unproject(point: L$Point, zoom: number): L$LatLng,
    unproject(point: L$PointTuple, zoom: number): L$LatLng,
    layerPointToLatLng(point: L$Point): L$LatLng,
    layerPointToLatLng(point: L$PointTuple): L$LatLng,
    latLngToLayerPoint(latlng: L$LatLng): L$Point,
    latLngToLayerPoint(latlng: L$LatLngLiteral): L$Point,
    latLngToLayerPoint(latlng: L$LatLngTuple): L$Point,
    wrapLatLng(latlng: L$LatLng): L$LatLng,
    wrapLatLng(latlng: L$LatLngLiteral): L$LatLng,
    wrapLatLng(latlng: L$LatLngTuple): L$LatLng,
    distance(latlng1: L$LatLng, latlng2: L$LatLng): number,
    distance(latlng1: L$LatLngLiteral, latlng2: L$LatLngLiteral): number,
    distance(latlng1: L$LatLngTuple, latlng2: L$LatLngTuple): number,
    containerPointToLayerPoint(point: L$Point): L$Point,
    containerPointToLayerPoint(point: L$PointTuple): L$Point,
    layerPointToContainerPoint(point: L$Point): L$Point,
    layerPointToContainerPoint(point: L$PointTuple): L$Point,
    latLngToContainerPoint(latlng: L$LatLng): L$Point,
    latLngToContainerPoint(latlng: L$LatLngLiteral): L$Point,
    latLngToContainerPoint(latlng: L$LatLngTuple): L$Point,
    mouseEventToContainerPoint(ev: L$MouseEvent): L$Point,
    mouseEventToLayerPoint(ev: L$MouseEvent): L$Point,
    mouseEventToLatLng(ev: L$MouseEvent): L$LatLng,
    locate(options?: L$LocateOptions): this,
    stopLocate(): this,
    boxZoom: L$Handler,
    doubleClickZoom: L$Handler,
    dragging: L$Handler,
    keyboard: L$Handler,
    scrollWheelZoom: L$Handler,
    tap: L$Handler,
    touchZoom: L$Handler
} & L$Evented


declare export function L$map(id: string, options?: L$MapOptions): L$Map

declare export type L$IconOptions = {
    iconUrl: string,
    iconRetinaUrl?: string,
    iconSize?: L$PointExpression,
    iconAnchor?: L$PointExpression,
    popupAnchor?: L$PointExpression,
    shadowUrl?: string,
    shadowRetinaUrl?: string,
    shadowSize?: L$PointExpression,
    shadowAnchor?: L$PointExpression,
    className?: string
} & L$LayerOptions


declare export type L$Icon = {
    createIcon(oldIcon?: HTMLElement): HTMLElement,
    createShadow(oldIcon?: HTMLElement): HTMLElement
} & L$Layer


declare export type L$IconDefault = {
    imagePath: string
} & L$Icon


declare export var Default: L$IconDefault;

declare export function L$icon(options: L$IconOptions): L$Icon

declare export type L$DivIconOptions = {
    html?: string,
    bgPos?: L$PointExpression,
    iconSize?: L$PointExpression,
    iconAnchor?: L$PointExpression,
    popupAnchor?: L$PointExpression,
    className?: string
} & L$LayerOptions


declare export type L$DivIcon = {} & L$Icon


declare export function L$divIcon(options: L$DivIconOptions): L$DivIcon

declare export type L$MarkerOptions = {
    icon?: L$Icon,
    draggable?: boolean,
    keyboard?: boolean,
    title?: string,
    alt?: string,
    zIndexOffset?: number,
    opacity?: number,
    riseOnHover?: boolean,
    riseOffset?: number
} & L$InteractiveLayerOptions


declare export type L$Marker = {
    getLatLng(): L$LatLng,
    setLatLng(latlng: L$LatLng): this,
    setLatLng(latlng: L$LatLngLiteral): this,
    setLatLng(latlng: L$LatLngTuple): this,
    setZIndexOffset(offset: number): this,
    setIcon(icon: L$Icon): this,
    setOpacity(opacity: number): this,
    dragging: L$Handler
} & L$Layer


declare export function L$marker(latlng: L$LatLng, options?: L$MarkerOptions): L$Marker

declare export var ie: boolean;

declare export var ielt9: boolean;

declare export var edge: boolean;

declare export var webkit: boolean;

declare export var gecko: boolean;

declare export var android: boolean;

declare export var android23: boolean;

declare export var chrome: boolean;

declare export var safari: boolean;

declare export var win: boolean;

declare export var ie3d: boolean;

declare export var webkit3d: boolean;

declare export var gecko3d: boolean;

declare export var opera12: boolean;

declare export var any3d: boolean;

declare export var mobile: boolean;

declare export var mobileWebkit: boolean;

declare export var mobiWebkit3d: boolean;

declare export var mobileOpera: boolean;

declare export var mobileGecko: boolean;

declare export var touch: boolean;

declare export var msPointer: boolean;

declare export var pointer: boolean;

declare export var retina: boolean;

declare export var canvas: boolean;

declare export var vml: boolean;

declare export var svg: boolean;
declare module 'leaflet' {
    declare module.exports: typeof L
}