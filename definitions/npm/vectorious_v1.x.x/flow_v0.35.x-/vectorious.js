/**
 * Flowtype definitions for vectorious
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
export class Vector {

    /**
     * 
     * @method  constructor
     * @desc  Creates a two-dimensional `Vector` from the supplied arguments.
     */
    constructor(data: number[]): this;

    /**
     * Static method. Adds two vectors `a` and `b` together.
     * @param  
     * @param  
     * @returns  a vector containing the sum of `a` and `b`
     */
    add(a: Vector, v: Vector): Vector;

    /**
     * Adds `vector` to the current vector.
     * @param  
     * @returns  this
     */
    add(vector: Vector): Vector;

    /**
     * Static method. Subtracts the vector `b` from vector `a`.
     * @param  
     * @param  
     * @returns  a vector containing the difference between `a` and `b`
     */
    subtract(a: Vector, b: Vector): Vector;

    /**
     * Subtracts `vector` from the current vector.
     * @param  
     * @returns  this
     */
    subtract(vector: Vector): Vector;

    /**
     * Static method. Multiplies all elements of `vector` with a specified `scalar`.
     * @param  
     * @param  
     * @returns  a resultant scaled vector
     */
    scale(vector: Vector, scalar: number): Vector;

    /**
     * Multiplies all elements of current vector with a specified `scalar`.
     * @param  
     * @returns  this
     */
    scale(scalar: number): Vector;

    /**
     * Static method. Normalizes `vector`, i.e. divides all elements with the magnitude.
     * @param  
     * @returns  a resultant normalized vector
     */
    normalize(vector: Vector): Vector;

    /**
     * Normalizes current vector.
     * @returns  a resultant normalized vector
     */
    normalize(): Vector;

    /**
     * Static method. Projects the vector `a` onto the vector `b` using
     * the projection formula `(b  (a  b / b  b))`.
     * @param  
     * @param  
     * @returns  a new resultant projected vector
     */
    project(a: Vector, b: Vector): Vector;

    /**
     * Projects the current vector onto `vector` using
     * the projection formula `(b  (a  b / b  b))`.
     * @param  
     * @returns  `vector`
     */
    project(vector: Vector): Vector;

    /**
     * Static method. Creates a vector containing zeros (`0`) of `count` size, takes
     * an optional `type` argument which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @returns  a new vector of the specified size and `type`
     */
    zeros(count: number, type?: any): Vector;

    /**
     * Static method. Creates a vector containing ones (`1`) of `count` size, takes
     * an optional `type` argument which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @returns  a new vector of the specified size and `type`
     */
    ones(count: number, type?: any): Vector;

    /**
     * Static method. Creates a vector containing a range (can be either ascending or descending)
     * of numbers specified by the arguments provided (e.g. `Vector.range(0, .5, 2)`
    gives a vector containing all numbers in the interval `[0, 2)` separated by
    steps of `0.5`), takes an optional `type` argument which should be an instance of
    `TypedArray`.
     * @param  
     * @param  - optional
     * @param  
     * @returns  a new vector containing the specified range of the specified `type`
    */
    range(start: number, end: number): Vector;
    range(start: number, step: number, end: number): Vector;

    /**
     * Static method. Creates a vector of `count` elements containing random
     * values according to a normal distribution, takes an optional `type`
    argument which should be an instance of `TypedArray`.
     * @param  
     * @param  (default 1)
     * @param  (default 0)
     * @param  
     * @returns  a new vector of the specified size and `type`
    */
    random(count: number, deviation?: number, mean?: number, type?: any): Vector;

    /**
     * Static method. Performs dot multiplication with two vectors `a` and `b`.
     * @param  
     * @param  
     * @returns  the dot product of the two vectors
     */
    dot(a: Vector, b: Vector): number;

    /**
     * Performs dot multiplication with current vector and `vector`
     * @param  
     * @returns  the dot product of the two vectors
     */
    dot(vector: Vector): number;

    /**
     * Calculates the magnitude of a vector (also called L2 norm or Euclidean length).
     * @returns  the magnitude (L2 norm) of the vector
     */
    magnitude(): number;

    /**
     * Static method. Determines the angle between two vectors `a` and `b`.
     * @param  
     * @param  
     * @returns  the angle between the two vectors in radians
     */
    angle(a: Vector, b: Vector): number;

    /**
     * Determines the angle between the current vector and `vector`.
     * @param  
     * @returns  the angle between the two vectors in radians
     */
    angle(vector: Vector): number;

    /**
     * Static method. Checks the equality of two vectors `a` and `b`.
     * @param  
     * @param  
     * @returns  `true` if the two vectors are equal, `false` otherwise
     */
    equals(a: Vector, b: Vector): boolean;

    /**
     * Checks the equality of the current vector and `vector`.
     * @param  
     * @returns  `true` if the two vectors are equal, `false` otherwise
     */
    equals(vector: Vector): boolean;

    /**
     * Gets the element at `index` from current vector.
     * @param  
     * @returns  the element at `index`
     */
    get(index: number): number;

    /**
     * Gets the minimum value (smallest) element of current vector.
     * @returns  the smallest element of the current vector
     */
    min(): number;

    /**
     * Gets the maximum value (largest) element of current vector.
     * @returns  the largest element of current vector
     */
    max(): number;

    /**
     * Sets the element at `index` to `value`.
     * @param  
     * @param  
     * @returns  this
     */
    set(index: number, value: number): Vector;

    /**
     * Static method. Combines two vectors `a` and `b` (appends `b` to `a`).
     * @param  
     * @param  
     * @returns  `b` appended to vector `a`
     */
    combine(a: Vector, b: Vector): Vector;

    /**
     * Combines the current vector with `vector`
     * @param  
     * @returns  `vector` combined with current vector
     */
    combine(vector: Vector): Vector;

    /**
     * Pushes a new `value` into current vector.
     * @param  
     * @returns  `this`
     */
    push(value: number): Vector;

    /**
     * Maps a function `callback` to all elements of current vector.
     * @param  
     * @returns  `this`
     */
    map(callback: (element: number) => number): Vector;

    /**
     * Functional version of for-looping the vector, is equivalent
     * to `Array.prototype.forEach`.
     * @param  
     * @returns  `this`
     */
    each(callback: (element: number) => void): Vector;

    /**
     * Equivalent to `TypedArray.prototype.reduce`.
     * @param  
     * @param  
     * @returns  result of reduction
     */
    reduce(
        callback: (memo: number, element: number) => number,
        initialValue?: number): number;

    /**
     * Converts current vector into a readable formatted string.
     * @returns  a string of the vector's contents
     */
    toString(): string;

    /**
     * Converts current vector into a JavaScript array.
     * @returns  an array containing all elements of current vector
     */
    toArray(): number[]
}
declare
export class Matrix {
    T: Matrix;

    /**
     * 
     * @method  constructor
     * @desc  Creates a `Matrix` from the supplied arguments.
     */
    constructor(data: number[][], options?: any): this;
    fromTypedArray(data: any, shape: number[]): Matrix;
    fromArray(data: number[][]): Matrix;

    /**
     * Static method. Adds two matrices `a` and `b` together.
     * @param  
     * @param  
     * @returns  a new matrix containing the sum of `a` and `b`
     */
    add(a: Matrix, b: Matrix): Matrix;

    /**
     * Adds `matrix` to current matrix.
     * @param  
     * @returns  `this`
     */
    add(matrix: Matrix): Matrix;

    /**
     * Static method. Subtracts the matrix `b` from matrix `a`.
     * @param  
     * @param  
     * @returns  a new matrix containing the difference between `a` and `b`
     */
    subtract(a: Matrix, b: Matrix): Matrix;

    /**
     * Subtracts `matrix` from current matrix.
     * @param  
     * @returns  `this`
     */
    subtract(matrix: Matrix): Matrix;

    /**
     * Static method. Multiplies all elements of a matrix `a` with a specified `scalar`.
     * @param  
     * @param  
     * @returns  a new scaled matrix
     */
    scale(matrix: Matrix, scalar: number): Matrix;

    /**
     * Multiplies all elements of current matrix with a specified `scalar`.
     * @param  
     * @returns  `this`
     */
    scale(scalar: number): Matrix;

    /**
     * Static method. Hadamard product of matrices
     * @param  
     * @param  
     * @returns  a new matrix containing the hadamard product
     */
    product(a: Matrix, b: Matrix): Matrix;

    /**
     * Hadamard product of matrices
     * @param  
     * @returns  `this`
     */
    product(matrix: Matrix): Matrix;

    /**
     * Static method. Creates an `i x j` matrix containing zeros (`0`), takes an
     * optional `type` argument which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @param  
     * @returns  a matrix of the specified dimensions and `type`
     */
    zeros(i: number, j: number, type?: any): Matrix;

    /**
     * Static method. Creates an `i x j` matrix containing ones (`1`), takes an
     * optional `type` argument which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @param  
     * @returns  a matrix of the specified dimensions and `type`
     */
    ones(i: number, j: number, type?: any): Matrix;

    /**
     * Static method. Creates an `i x j` matrix containing random values
     * according to a normal distribution, takes an optional `type` argument
    which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @param  (default 0)
     * @param  deviation (default 1)
     * @param  
     * @returns  a matrix of the specified dimensions and `type`
    */
    random(i: number, j: number, deviation?: number, mean?: number, type?: any): Matrix;

    /**
     * Static method. Multiplies two matrices `a` and `b` of matching dimensions.
     * @param  
     * @param  
     * @returns  a new resultant matrix containing the matrix product of `a` and `b`
     */
    multiply(a: Matrix, b: Matrix): Matrix;

    /**
     * Multiplies two matrices `a` and `b` of matching dimensions.
     * @param  
     * @returns  a new resultant matrix containing the matrix product of `a` and `b`
     */
    multiply(matrix: Matrix): Matrix;

    /**
     * Transposes a matrix (mirror across the diagonal).
     * @returns  `this`
     */
    transpose(): Matrix;

    /**
     * Determines the inverse of any invertible square matrix using
     * Gaussian elimination.
     * @returns  the inverse of the matrix
     */
    inverse(): Matrix;

    /**
     * Performs Gaussian elimination on a matrix.
     * @returns  the matrix in reduced row echelon form
     */
    gauss(): Matrix;

    /**
     * Performs full LU decomposition on a matrix.
     * @returns  a triple (3-tuple) of the lower triangular resultant matrix `L`, the upper
    triangular resultant matrix `U` and the pivot array `ipiv`
    */
    lu(): number[];

    /**
     * Static method. Performs LU factorization on current matrix.
     * @returns  an array with a new instance of the current matrix LU-
    factorized and the corresponding pivot Int32Array
    */
    plu(matrix: Matrix): any[];

    /**
     * Performs LU factorization on current matrix.
     * @returns  an array with the current matrix LU-factorized and the
    corresponding pivot Int32Array
    */
    plu(): any[];

    /**
     * Solves an LU factorized matrix with the supplied right hand side(s)
     * @param  , right hand side(s) to solve for
     * @param  of pivoted row indices
     * @returns  rhs replaced by the solution
     */
    lusolve(rhs: Matrix, ipiv: Int32Array): Matrix;

    /**
     * Solves AX = B using LU factorization, where A is the current matrix and
     * B is a Vector/Matrix containing the right hand side(s) of the equation./Vector} rhs, right hand side(s) to solve for
     * @param  of pivoted row indices
     * @returns  a new matrix containing the solutions of the system
     */
    solve(rhs: Matrix | Vector): Matrix;

    /**
     * Static method. Augments two matrices `a` and `b` of matching dimensions
     * (appends `b` to `a`).
     * @param  
     * @param  
     * @returns  the resultant matrix of `b` augmented to `a`
     */
    augment(a: Matrix, b: Matrix): Matrix;

    /**
     * Augments `matrix` with current matrix.
     * @param  
     * @returns  `this`
     */
    augment(matrix: Matrix): Matrix;

    /**
     * Static method. Creates an identity matrix of `size`, takes an optional `type` argument
     * which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @returns  an identity matrix of the specified `size` and `type`
     */
    identity(size: number, type?: any): Matrix;

    /**
     * Static method. Creates a magic square matrix of `size`, takes an optional `type` argument
     * which should be an instance of `TypedArray`.
     * @param  
     * @param  
     * @returns  a magic square matrix of the specified `size` and `type`
     */
    magic(size: number, type?: any): Matrix;

    /**
     * Gets the diagonal of a matrix.
     * @returns  the diagonal of the matrix as a vector
     */
    diag(): Vector;

    /**
     * Gets the determinant of any square matrix using LU factorization.
     * @returns  the determinant of the matrix
     */
    determinant(): number;

    /**
     * Gets the trace of the matrix (the sum of all diagonal elements).
     * @returns  the trace of the matrix
     */
    trace(): number;

    /**
     * Static method. Checks the equality of two matrices `a` and `b`.
     * @param  
     * @param  
     * @returns  `true` if equal, `false` otherwise
     */
    equals(a: Matrix, b: Matrix): boolean;

    /**
     * Checks the equality of `matrix` and current matrix.
     * @param  
     * @returns  `true` if equal, `false` otherwise
     */
    equals(matrix: Matrix): boolean;

    /**
     * Gets the value of the element in row `i`, column `j` of current matrix
     * @param  
     * @param  
     * @returns  the element at row `i`, column `j` of current matrix
     */
    get(i: number, j: number): number;

    /**
     * Sets the element at row `i`, column `j` to value
     * @param  
     * @param  
     * @param  
     * @returns  `this`
     */
    set(i: number, j: number, value: number): Matrix;

    /**
     * Swaps two rows `i` and `j` in a matrix
     * @param  
     * @param  
     * @returns  `this`
     */
    swap(i: number, j: number): Matrix;

    /**
     * Maps a function `callback` to all elements of a copy of current matrix.
     * @param  
     * @returns  the resultant mapped matrix
     */
    map(callback: (element: number) => number): Matrix;

    /**
     * Functional version of for-looping the elements in a matrix, is
     * equivalent to `Array.prototype.forEach`.
     * @param  
     * @returns  `this`
     */
    each(callback: (element: number) => void): Matrix;

    /**
     * Equivalent to `TypedArray.prototype.reduce`.
     * @param  
     * @param  
     * @returns  result of reduction
     */
    reduce(
        callback: (memo: number, element: number) => number,
        initialValue?: number): number;

    /**
     * Finds the rank of the matrix using row echelon form
     * @returns  rank
     */
    rank(): number;

    /**
     * Static method. Finds the rank of a matrix using row echelon form
     * @param  
     * @returns  rank
     */
    rank(matrix: Matrix): number;

    /**
     * Converts current matrix into a readable formatted string
     * @returns  a string of the matrix' contents
     */
    toString(): string;

    /**
     * Converts current matrix into a two-dimensional array
     * @returns  an array of the matrix' contents
     */
    toArray(): number[][]
}
declare
export class BLAS {}