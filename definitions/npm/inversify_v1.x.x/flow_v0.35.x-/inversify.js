// @flow
/**
 * Flowtype definitions for inversify
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface Symbol {
    toString(): string,
        valueOf(): Object
}
declare interface SymbolConstructor {
    (description?: string | number): Symbol
}
declare var Symbol: SymbolConstructor;
declare var npm$namespace$inversify: {
    injectable: typeof inversify$injectable,
    tagged: typeof inversify$tagged,
    named: typeof inversify$named,
    targetName: typeof inversify$targetName,
    unmanaged: typeof inversify$unmanaged,
    inject: typeof inversify$inject,
    guid: typeof inversify$guid,
    multiInject: typeof inversify$multiInject,
}
declare export interface interfaces$KernelConstructor {
    new(): interfaces$Kernel
}

declare export interface interfaces$KernelModuleConstructor {
    new(registry: (bind: interfaces$Bind) => void): interfaces$KernelModule
}

declare export interface interfaces$Newable<T>{
    new(...args: any[]): T
}

declare export type interfaces$ServiceIdentifier<T>= (string | Symbol | interfaces$Newable<T>);

declare export type interfaces$Binding<T>= {
    guid: string,
    moduleId: string,
    activated: boolean,
    serviceIdentifier: interfaces$ServiceIdentifier<T>,
    implementationType: interfaces$Newable<T>,
    factory: interfaces$FactoryCreator<any>,
    provider: interfaces$ProviderCreator<any>,
    constraint: (request: interfaces$Request) => boolean,
    onActivation: (context: interfaces$Context, injectable: T) => T,
    cache: T,
    dynamicValue: (context: interfaces$Context) => T,
    scope: number,
    type: number
} & interfaces$Clonable


declare export type interfaces$Factory<T>= {
    (...args: any[]): (((...args: any[]) => T) | T)
} & Function


declare export type interfaces$FactoryCreator<T>= {
    (context: interfaces$Context): interfaces$Factory<T >
} & Function


declare export type interfaces$Provider<T>= {
    (): Promise<T >
} & Function


declare export type interfaces$ProviderCreator<T>= {
    (context: interfaces$Context): interfaces$Provider<T >
} & Function


declare export interface interfaces$PlanAndResolve<T>{
    (args: interfaces$PlanAndResolveArgs): T[]
}

declare export interface interfaces$PlanAndResolveArgs {
    multiInject: boolean,
        serviceIdentifier: interfaces$ServiceIdentifier<any>,
        target: interfaces$Target,
        contextInterceptor: (contexts: interfaces$Context) => interfaces$Context
}

declare export type interfaces$Middleware = {
    (next: interfaces$PlanAndResolve<any>): interfaces$PlanAndResolve<any >
} & Function


declare export interface interfaces$Context {
    guid: string,
        kernel: interfaces$Kernel,
        plan: interfaces$Plan,
        addPlan(plan: interfaces$Plan): void
}

declare export interface interfaces$ReflectResult {
    [key: string]: interfaces$Metadata[]
}

declare export interface interfaces$Metadata {
    key: string,
        value: any
}

declare export interface interfaces$Plan {
    parentContext: interfaces$Context,
        rootRequest: interfaces$Request
}

declare export interface interfaces$Planner {
    createContext(kernel: interfaces$Kernel): interfaces$Context,
        createPlan(
            parentContext: interfaces$Context,
            binding: interfaces$Binding<any>,
            target: interfaces$Target): interfaces$Plan,
        getBindings<T>(
            kernel: interfaces$Kernel,
            serviceIdentifier: interfaces$ServiceIdentifier<T>): interfaces$Binding<T>[],
        getActiveBindings(
            parentRequest: interfaces$Request,
            target: interfaces$Target): interfaces$Binding<any>[]
}

declare export interface interfaces$QueryableString {
    startsWith(searchString: string): boolean,
        endsWith(searchString: string): boolean,
        contains(searchString: string): boolean,
        equals(compareString: string): boolean,
        value(): string
}

declare export interface interfaces$Request {
    guid: string,
        serviceIdentifier: interfaces$ServiceIdentifier<any>,
        parentContext: interfaces$Context,
        parentRequest: interfaces$Request,
        childRequests: interfaces$Request[],
        target: interfaces$Target,
        bindings: interfaces$Binding<any>[],
        addChildRequest(
            serviceIdentifier: interfaces$ServiceIdentifier<any>,
            bindings: (interfaces$Binding<any>| interfaces$Binding<any>[]),
            target: interfaces$Target): interfaces$Request
}

declare export interface interfaces$Target {
    guid: string,
        serviceIdentifier: interfaces$ServiceIdentifier<any>,
        type: number,
        name: interfaces$QueryableString,
        metadata: Array<interfaces$Metadata>,
        hasTag(key: string): boolean,
        isArray(): boolean,
        matchesArray(name: string | Symbol | interfaces$Newable<any>): boolean,
        isNamed(): boolean,
        isTagged(): boolean,
        matchesNamedTag(name: string): boolean,
        matchesTag(key: string): (value: any) => boolean
}

declare export interface interfaces$Resolver {
    resolve<T>(context: interfaces$Context): T
}

declare export interface interfaces$Kernel {
    guid: string,
        parent: interfaces$Kernel,
        bind<T>(
            serviceIdentifier: interfaces$ServiceIdentifier<T>): interfaces$BindingToSyntax<T>,
        unbind(serviceIdentifier: interfaces$ServiceIdentifier<any>): void,
        unbindAll(): void,
        isBound(serviceIdentifier: interfaces$ServiceIdentifier<any>): boolean,
        get<T>(serviceIdentifier: interfaces$ServiceIdentifier<T>): T,
        getNamed<T>(serviceIdentifier: interfaces$ServiceIdentifier<T>, named: string): T,
        getTagged<T>(
            serviceIdentifier: interfaces$ServiceIdentifier<T>,
            key: string,
            value: any): T,
        getAll<T>(serviceIdentifier: interfaces$ServiceIdentifier<T>): T[],
        getAllNamed<T>(serviceIdentifier: interfaces$ServiceIdentifier<T>, named: string): T[],
        getAllTagged<T>(
            serviceIdentifier: interfaces$ServiceIdentifier<T>,
            key: string,
            value: any): T[],
        load(...modules: interfaces$KernelModule[]): void,
        unload(...modules: interfaces$KernelModule[]): void,
        applyMiddleware(...middleware: interfaces$Middleware[]): void,
        getServiceIdentifierAsString(serviceIdentifier: interfaces$ServiceIdentifier<any>): string,
        snapshot(): void,
        restore(): void
}

declare export type interfaces$Bind = {
    (serviceIdentifier: interfaces$ServiceIdentifier<T>): interfaces$BindingToSyntax<T >
} & Function


declare export interface interfaces$KernelModule {
    guid: string,
        registry: (bind: interfaces$Bind) => void
}

declare export interface interfaces$KernelSnapshot {
    bindings: interfaces$Lookup<interfaces$Binding<any >> ,
        middleware: interfaces$PlanAndResolve<any >
}

declare export interface interfaces$Clonable<T>{
    clone(): T
}

declare export type interfaces$Lookup<T>= {
    add(serviceIdentifier: interfaces$ServiceIdentifier<any>, value: T): void,
    get(serviceIdentifier: interfaces$ServiceIdentifier<any>): Array<T>,
    remove(serviceIdentifier: interfaces$ServiceIdentifier<any>): void,
    removeByModuleId(moduleId: string): void,
    hasKey(serviceIdentifier: interfaces$ServiceIdentifier<any>): boolean
} & interfaces$Clonable


declare export interface interfaces$KeyValuePair<T>{
    serviceIdentifier: interfaces$ServiceIdentifier<any>,
    value: Array<T>,
    guid: string
}

declare export interface interfaces$BindingInSyntax<T>{
    inSingletonScope(): interfaces$BindingWhenOnSyntax<T>,
    inTransientScope(): interfaces$BindingWhenOnSyntax<T >
}

declare export type interfaces$BindingInWhenOnSyntax<T>= {} & interfaces$BindingInSyntax & interfaces$BindingWhenOnSyntax


declare export interface interfaces$BindingOnSyntax<T>{
    onActivation(
        fn: (context: interfaces$Context, injectable: T) => T): interfaces$BindingWhenSyntax<T >
}

declare export interface interfaces$BindingToSyntax<T>{
    to(constructor: {
        new(...args: any[]): T
    }): interfaces$BindingInWhenOnSyntax<T>,
    toSelf(): interfaces$BindingInWhenOnSyntax<T>,
    toConstantValue(value: T): interfaces$BindingWhenOnSyntax<T>,
    toDynamicValue(func: (context: interfaces$Context) => T): interfaces$BindingWhenOnSyntax<T>,
    toConstructor<T2>(constructor: interfaces$Newable<T2>): interfaces$BindingWhenOnSyntax<T>,
    toFactory<T2>(factory: interfaces$FactoryCreator<T2>): interfaces$BindingWhenOnSyntax<T>,
    toFunction(func: T): interfaces$BindingWhenOnSyntax<T>,
    toAutoFactory<T2>(
        serviceIdentifier: interfaces$ServiceIdentifier<T2>): interfaces$BindingWhenOnSyntax<T>,
    toProvider<T2>(
        provider: interfaces$ProviderCreator<T2>): interfaces$BindingWhenOnSyntax<T >
}

declare export type interfaces$BindingWhenOnSyntax<T>= {} & interfaces$BindingWhenSyntax & interfaces$BindingOnSyntax


declare export interface interfaces$BindingWhenSyntax<T>{
    when(
        constraint: (request: interfaces$Request) => boolean): interfaces$BindingOnSyntax<T>,
    whenTargetNamed(name: string): interfaces$BindingOnSyntax<T>,
    whenTargetTagged(tag: string, value: any): interfaces$BindingOnSyntax<T>,
    whenInjectedInto(parent: (Function | string)): interfaces$BindingOnSyntax<T>,
    whenParentNamed(name: string): interfaces$BindingOnSyntax<T>,
    whenParentTagged(tag: string, value: any): interfaces$BindingOnSyntax<T>,
    whenAnyAncestorIs(ancestor: (Function | string)): interfaces$BindingOnSyntax<T>,
    whenNoAncestorIs(ancestor: (Function | string)): interfaces$BindingOnSyntax<T>,
    whenAnyAncestorNamed(name: string): interfaces$BindingOnSyntax<T>,
    whenAnyAncestorTagged(tag: string, value: any): interfaces$BindingOnSyntax<T>,
    whenNoAncestorNamed(name: string): interfaces$BindingOnSyntax<T>,
    whenNoAncestorTagged(tag: string, value: any): interfaces$BindingOnSyntax<T>,
    whenAnyAncestorMatches(
        constraint: (request: interfaces$Request) => boolean): interfaces$BindingOnSyntax<T>,
    whenNoAncestorMatches(
        constraint: (request: interfaces$Request) => boolean): interfaces$BindingOnSyntax<T >
}

declare export var Kernel: interfaces$KernelConstructor;

declare export var KernelModule: interfaces$KernelModuleConstructor;

declare export var decorate: (
    decorator: (ClassDecorator | ParameterDecorator),
    target: any,
    parameterIndex?: number) => void;

declare export function inversify$injectable(): (typeConstructor: any) => void

declare export function inversify$tagged(
    metadataKey: string,
    metadataValue: any): (target: any, targetKey: string, index?: number) => any

declare export function inversify$named(name: string): (target: any, targetKey: string, index?: number) => any

declare export function inversify$targetName(name: string): (target: any, targetKey: string, index: number) => any

declare export function inversify$unmanaged(): (target: any, targetKey: string, index: number) => any

declare export function inversify$inject(
    serviceIdentifier: interfaces$ServiceIdentifier<any>): (target: any, targetKey: string, index?: number) => any

declare export function inversify$guid(): string

declare export function inversify$multiInject(
    serviceIdentifier: interfaces$ServiceIdentifier<any>): (target: any, targetKey: string, index?: number) => any

declare export var traverseAncerstors: (
    request: interfaces$Request,
    constraint: (request: interfaces$Request) => boolean) => boolean;

declare export var taggedConstraint: (tag: string) => (value: any) => (request: interfaces$Request) => boolean;

declare export var namedConstraint: (value: any) => (request: interfaces$Request) => boolean;

declare export var typeConstraint: (type: (Function | string)) => (request: interfaces$Request) => boolean;
declare module 'inversify' {
    declare module.exports: typeof inversify
}