/**
 * Flowtype definitions for durandal-1.x
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'durandal/system' {
    declare export var getModuleId: (obj: any) => string;
    declare export var setModuleId: (obj: << UNKNOWN PARAM FORMAT >> , id: string) => void;
    declare export var debug: (debug?: boolean) => boolean;
    declare export var isArray: (obj: any) => boolean;
    declare export var log: (...msgs: any[]) => void;
    declare export var defer: (action?: Function) => JQueryDeferred<any>;
    declare export var guid: () => string;
    declare export var acquire: (...modules: string[]) => JQueryPromise<any>;
}
declare module 'durandal/app' {
    declare export var title: string;
    declare export var showModal: (
        obj: << UNKNOWN PARAM FORMAT >> ,
        activationData?: << UNKNOWN PARAM FORMAT >> ,
        context?: << UNKNOWN PARAM FORMAT >> ) => JQueryPromise<any>;
    declare export var showMessage: (message: string, title?: string, options?: any) => JQueryPromise<any>;
    declare export var start: () => JQueryPromise<any>;
    declare export var setRoot: (root: any, transition?: string, applicationHost?: string) => void;
    declare export var adaptToDevice: () => void;
    declare export var on: (
        events: string,
        callback: Function,
        context?: << UNKNOWN PARAM FORMAT >> ) => IEventSubscription;
    declare export var off: (events: string, callback: Function, context?: << UNKNOWN PARAM FORMAT >> ) => any;
    declare export var trigger: (events: string, ...args: any[]) => any;
    declare export var proxy: (events: << UNKNOWN PARAM FORMAT >> ) => Function;
}
declare module 'durandal/composition' {
    declare export var activateDuringComposition: boolean;
    declare export var convertTransitionToModuleId: (name: string) => string;
    declare export var defaultTransitionName: string;
    declare export var switchContent: (parent: HTMLElement, newChild: HTMLElement, settings: any) => void;
    declare export var bindAndShow: (element: HTMLElement, view: HTMLElement, settings: any) => void;
    declare export var defaultStrategy: (settings: any) => JQueryPromise<any>;
    declare export var getSettings: (valueAccessor: any) => any;
    declare export var executeStrategy: (element: HTMLElement, settings: any) => void;
    declare export var inject: (element: HTMLElement, settings: any) => void;
    declare export var compose: (element: HTMLElement, settings: any, bindingContext: any) => void;
}
declare module 'durandal/http' {
    declare export var defaultJSONPCallbackParam: string;
    declare export var get: (url: string, query: Object) => JQueryPromise<any>;
    declare export var jsonp: (url: string, query: Object, callbackParam: string) => JQueryPromise<any>;
    declare export var post: (url: string, data: Object) => JQueryPromise<any>;
}
declare module 'durandal/modalDialog' {
    declare export var currentZIndex: number;
    declare export var getNextZIndex: () => number;
    declare export var isModalOpen: () => boolean;
    declare export var getContext: (name: string) => any;
    declare export var addContext: (name: string, modalContext: any) => JQueryPromise<any>;
    declare export var createCompositionSettings: (obj: any, modalContext: any) => any;
    declare export var show: (obj: any, activationData: any, context: any) => JQueryPromise<any>;
}
declare module 'durandal/viewEngine' {
    declare export var viewExtension: string;
    declare export var viewPlugin: string;
    declare export var isViewUrl: (url: string) => boolean;
    declare export var convertViewUrlToViewId: (url: string) => string;
    declare export var convertViewIdToRequirePath: (viewId: string) => string;
    declare export var parseMarkup: (markup: string) => HTMLElement;
    declare export var createView: (viewId: string) => JQueryPromise<any>;
}
declare module 'durandal/viewLocator' {
    declare export var useConvention: (modulesPath?: string, viewsPath?: string, areasPath?: string) => string;
    declare export var locateViewForObject: (obj: {}, elementsToSearch: HTMLElement[]) => JQueryPromise<any>;
    declare export var convertModuleIdToViewId: (moduleId: string) => string;
    declare export var determineFallbackViewId: (obj: any) => string;
    declare export var translateViewIdToArea: (viewId: string, area?: string) => string;
    declare export var locateView: (
        viewOrUrlOrId: any,
        area: string,
        elementsToSearch: HTMLElement[]) => JQueryPromise<any>;
}
declare module 'durandal/viewModel' {
    declare export var defaults: IViewModelDefaults;
    declare export var activator: {
        (): IDurandalViewModelActiveItem,
        (initialActiveItem: any, settings?: IViewModelDefaults): IDurandalViewModelActiveItem
    };
}
declare module 'durandal/viewModelBinder' {
    declare export var bindContext: (bindingContext: KnockoutBindingContext, view: HTMLElement, obj?: any) => void;
    declare export var bind: (obj: any, view: HTMLElement) => void;
}
declare interface IViewModelDefaults {

    /**
     * When the activator attempts to activate an item as described below, it will only activate the new item, by default, if it is a different instance than the current. Overwrite this function to change that behavior.
     */
    areSameItem(
            currentItem: << UNKNOWN PARAM FORMAT >> ,
            newItem: << UNKNOWN PARAM FORMAT >> ,
            activationData: << UNKNOWN PARAM FORMAT >> ): boolean,

        /**
         * default is true
         */
        closeOnDeactivate: boolean,

        /**
         * Interprets values returned from guard methods like canActivate and canDeactivate by transforming them into bools. The default implementation translates string values "Yes" and "Ok" as true...and all other string values as false. Non string values evaluate according to the truthy/falsey values of JavaScript. Replace this function with your own to expand or set up different values. This transformation is used by the activator internally and allows it to work smoothly in the common scenario where a deactivated item needs to show a message box to prompt the user before closing. Since the message box returns a promise that resolves to the button option the user selected, it can be automatically processed as part of the activator's guard check.
         */
        interpretResponse(value: any): boolean,

        /**
         * called before activating a module
         */
        beforeActivate(newItem: any): any,

        /**
         * called after deactivating a module
         */
        afterDeactivate(): any
}
declare interface IDurandalViewModelActiveItem {

    /**
     * knockout observable
     */
    (val?: << UNKNOWN PARAM FORMAT >> ): any,

    /**
     * A property which is the home to some basic settings and functions that control how all activators work. These are used to create the instance settings object for each activator. They can be overriden on a per-instance-basis by passing a settings object when creating an activator or by accessing the settings property of the activator. To change them for all activators, change them on the defaults property. The two most common customizations are presented below. See the source for additional information.
     */
    settings: IViewModelDefaults,

        /**
         * This observable is set internally by the activator during the activation process. It can be used to determine if an activation is currently happening.
         */
        isActivating(val?: boolean): boolean,

        /**
         * Pass a specific item as well as an indication of whether it should be closed, and this function will tell you the answer.
         */
        canDeactivateItem(
            item: << UNKNOWN PARAM FORMAT >> ,
            close: << UNKNOWN PARAM FORMAT >> ): JQueryPromise<any>,

        /**
         * Deactivates the specified item (optionally closing it). Deactivation follows the lifecycle and thus only works if the item can be deactivated.
         */
        deactivateItem(
            item: << UNKNOWN PARAM FORMAT >> ,
            close: << UNKNOWN PARAM FORMAT >> ): JQueryDeferred<any>,

        /**
         * Determines if a specific item can be activated. You can pass an arbitrary object to this function, which will be passed to the item's canActivate function , if present. This is useful if you are manually controlling activation and you want to provide some context for the operation.
         */
        canActivateItem(
            newItem: << UNKNOWN PARAM FORMAT >> ,
            activationData?: << UNKNOWN PARAM FORMAT >> ): JQueryPromise<any>,

        /**
         * Activates a specific item. Activation follows the lifecycle and thus only occurs if possible. activationData functions as stated above.
         */
        activateItem(
            newItem: << UNKNOWN PARAM FORMAT >> ,
            activationData?: << UNKNOWN PARAM FORMAT >> ): JQueryPromise<any>,

        /**
         * Checks whether or not the activator itself can be activated...that is whether or not it's current item or initial value can be activated.
         */
        canActivate(): JQueryPromise<any>,

        /**
         * Activates the activator...that is..it activates it's current item or initial value.
         */
        activate(): JQueryPromise<any>,

        /**
         * Checks whether or not the activator itself can be deactivated...that is whether or not it's current item can be deactivated.
         */
        canDeactivate(): JQueryPromise<any>,

        /**
         * Deactivates the activator...interpreted as deactivating its current item.
         */
        deactivate(): JQueryDeferred<any>,

        /**
         * Adds canActivate, activate, canDeactivate and deactivate functions to the provided model which pass through to the corresponding functions on the activator.
         */
        includeIn(includeIn: any): JQueryPromise<any>,

        /**
         * Sets up a collection representing a pool of objects which the activator will activate. See below for details. Activators without an item boolean always close their values on deactivate. Activators with an items pool only deactivate, but do not close them.
         */
        forItems(items: << UNKNOWN PARAM FORMAT >> ): IDurandalViewModelActiveItem
}
declare module 'durandal/plugins/router' {

    /**
     * Parameters to the map function. or information on route url patterns, see the SammyJS documentation. But 
     * basically, you can have simple routes my/route/, parameterized routes customers/:id or Regex routes. If you 
    have a parameter in your route, then the activation data passed to your module's activate function will have a 
    property for every parameter in the route (rather than the splat array, which is only present for automapped 
    routes).
    */
    declare interface IRouteInfo {
        url: string,
            moduleId: string,
            name: string,

            /**
             * used to set the document title 
             */
            caption: string,

            /**
             * determines whether or not to include it in the router's visibleRoutes array for easy navigation UI binding 
             */
            visible: boolean,
            settings: Object,
            hash: string,

            /**
             * only present on visible routes to track if they are active in the nav 
             */
            isActive?: KnockoutComputed<boolean >
    }

    /**
     * Parameters to the map function. e only required parameter is url the rest can be derived. The derivation 
     * happens by stripping parameters from the url and casing where appropriate. You can always explicitly provide 
    url, name, moduleId, caption, settings, hash and visible. In 99% of situations, you should not need to provide 
    hash; it's just there to simplify databinding for you. Most of the time you may want to teach the router how 
    to properly derive the moduleId and name based on a url. If you want to do that, overwrite.
    */
    declare interface IRouteInfoParameters {

        /**
         * your url pattern. The only required parameter 
         */
        url: any,

            /**
             * if not supplied, router.convertRouteToName derives it 
             */
            moduleId?: string,

            /**
             * if not supplied, router.convertRouteToModuleId derives it 
             */
            name?: string,

            /**
             * used to set the document title 
             */
            caption?: string,

            /**
             * determines whether or not to include it in the router's visibleRoutes array for easy navigation UI binding 
             */
            visible?: boolean,
            settings?: Object
    }
    declare export var ready: KnockoutObservable<boolean>;
    declare export var allRoutes: KnockoutObservableArray<IRouteInfo>;
    declare export var visibleRoutes: KnockoutObservableArray<IRouteInfo>;
    declare export var isNavigating: KnockoutObservable<boolean>;
    declare export var activeItem: IDurandalViewModelActiveItem;
    declare export var activeRoute: KnockoutObservable<IRouteInfo>;
    declare export var afterCompose: () => void;
    declare export var getActivatableInstance: (routeInfo: IRouteInfo, params: any, module: any) => any;
    declare export var navigateBack: () => void;
    declare export var useConvention: () => void;
    declare export var navigateTo: (url: string) => void;
    declare export var replaceLocation: (url: string) => void;
    declare export var convertRouteToName: (route: string) => string;
    declare export var convertRouteToModuleId: (url: string) => string;
    declare export var autoConvertRouteToModuleId: (url: string) => string;
    declare export var prepareRouteInfo: (info: IRouteInfo) => void;
    declare export var handleInvalidRoute: (route: IRouteInfo, parameters: any) => void;
    declare export var mapAuto: (path?: string) => void;
    declare export var mapNav: (url: string, moduleId?: string, name?: string) => IRouteInfo;
    declare export var mapRoute: {
        (route: IRouteInfoParameters): IRouteInfo,
        (url: string, moduleId?: string, name?: string, visible?: boolean): IRouteInfo
    };
    declare export var map: {
        (routeOrRouteArray: IRouteInfoParameters): IRouteInfo,
        (routeOrRouteArray: IRouteInfoParameters[]): IRouteInfo[]
    };
    declare export var activate: (defaultRoute: string) => JQueryPromise<any>;
    declare export var guardRoute: (routeInfo: IRouteInfo, params: any, instance: any) => any;
}
declare module 'durandal/widget' {

    /**
     * Use this function to create a widget through code. The element should reference a dom element that the widget will be created on. The settings can be either a string or an object. If it's a string, it should specify the widget kind. If it's an object, it represents settings that will be passed along to the widget. This object should have a kind property used to identify the widget kind to create. Optionally, you can specify a bindingContext of which you want the widget's binding context to be created as a child.
     */
    declare export function create(element: any, settings: any, bindingContext?: any): void

    /**
     * By default, you can create widgets in html by using the widget binding extension. Calling registerKind allows you to easily create a custom binding handler for your widget kind. Without calling registerKind you might declare a widget binding for an expander control with
     */
    declare export function registerKind(kind: string): void

    /**
     * Use this to re-map a widget kind identifier to a new viewId or moduleId representing the 'skin' and 'behavior' respectively.
     */
    declare export function mapKind(kind: string, viewId?: string, moduleId?: string): void

    /**
     * Developers implementing widgets may wish to use this function to acquire the resolved template parts for a widget. Pass a single dom element or an array of elements and get back an object keyed by part name whose values are the dom elements corresponding to each part in that scope.
     */
    declare export function getParts(elements: any): any

    /**
     * (overrridable) Replace this to re-interpret the kind id as a module path. By default it does a lookup for any custom maps added through mapKind and then falls back to the path "durandal/widgets/{kind}/controller".
     */
    declare export function convertKindToModuleId(kind: << UNKNOWN PARAM FORMAT >> ): string

    /**
     * (overridable) Replace this to re-interpret the kind id as a view id. The default does a lookup for any custom maps added through mapKind and then falls back to the path "durandal/widgets/{kind}/view".
     */
    declare export function convertKindToViewId(kind: << UNKNOWN PARAM FORMAT >> ): string
}
declare interface IEventSubscription {

    /**
     * This function adding callback to event subscription
     */
    then(thenCallback: any): void,

        /**
         * This function removing current subscription from event handlers
         */
        off(): void
}