/**
 * Flowtype definitions for rx
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare
export interface Rx$IScheduler {
    catch (handler: (exception: any) => boolean): Rx$IScheduler,
    catchException(handler: (exception: any) => boolean): Rx$IScheduler
}

declare
export interface Rx$Observer<T>{
    checked(): Rx$Observer<any >
}

declare interface Rx$ObserverStatic {

    /**
     * Schedules the invocation of observer methods on the given scheduler.
     * @param scheduler Scheduler to schedule observer messages on.
     * @returns  Observer whose messages are scheduled on the given scheduler.
     */
    notifyOn<T>(scheduler: Rx$IScheduler): Rx$Observer<T >
}

declare
export interface Rx$Observable<T>{
    observeOn(scheduler: Rx$IScheduler): Rx$Observable<T>,
    subscribeOn(scheduler: Rx$IScheduler): Rx$Observable<T>,
    amb(rightSource: Rx$Observable<T>): Rx$Observable<T>,
    amb(rightSource: IPromise<T>): Rx$Observable<T>,
    onErrorResumeNext(second: Rx$Observable<T>): Rx$Observable<T>,
    onErrorResumeNext(second: IPromise<T>): Rx$Observable<T>,
    bufferWithCount(count: number, skip?: number): Rx$Observable<T[]>,
    windowWithCount(count: number, skip?: number): Rx$Observable<Rx$Observable<T >> ,
    defaultIfEmpty(defaultValue?: T): Rx$Observable<T>,
    distinct(
        skipParameter: boolean,
        valueSerializer: (value: T) => string): Rx$Observable<T>,
    distinct<TKey>(
        keySelector?: (value: T) => TKey,
        keySerializer?: (key: TKey) => string): Rx$Observable<T>,
    groupBy<TKey,
    TElement>(
        keySelector: (value: T) => TKey,
        skipElementSelector?: boolean,
        keySerializer?: (key: TKey) => string): Rx$Observable<Rx$GroupedObservable<TKey,
    T >> ,
    groupBy<TKey,
    TElement>(
        keySelector: (value: T) => TKey,
        elementSelector: (value: T) => TElement,
        keySerializer?: (key: TKey) => string): Rx$Observable<Rx$GroupedObservable<TKey,
    TElement >> ,
    groupByUntil<TKey,
    TDuration>(
        keySelector: (value: T) => TKey,
        skipElementSelector: boolean,
        durationSelector: (group: Rx$GroupedObservable<TKey, T>) => Rx$Observable<TDuration>,
        keySerializer?: (key: TKey) => string): Rx$Observable<Rx$GroupedObservable<TKey,
    T >> ,
    groupByUntil<TKey,
    TElement,
    TDuration>(
        keySelector: (value: T) => TKey,
        elementSelector: (value: T) => TElement,
        durationSelector: (group: Rx$GroupedObservable<TKey, TElement>) => Rx$Observable<TDuration>,
        keySerializer?: (key: TKey) => string): Rx$Observable<Rx$GroupedObservable<TKey,
    TElement >>
}

declare interface Rx$ObservableStatic {
    using<TSource, TResource>(
            resourceFactory: () => TResource,
            observableFactory: (resource: TResource) => Rx$Observable<TSource>): Rx$Observable<TSource>,
        amb<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
        amb<T>(...sources: IPromise<T>[]): Rx$Observable<T>,
        amb<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
        amb<T>(sources: IPromise<T>[]): Rx$Observable<T>,
        onErrorResumeNext<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
        onErrorResumeNext<T>(...sources: IPromise<T>[]): Rx$Observable<T>,
        onErrorResumeNext<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
        onErrorResumeNext<T>(sources: IPromise<T>[]): Rx$Observable<T >
}

declare type Rx$GroupedObservable<TKey, TElement>= {
    key: TKey,
    underlyingObservable: Rx$Observable<TElement >
} & Rx$Observable
declare module 'rx' {
    declare module.exports: typeof Rx
}