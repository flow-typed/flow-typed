/**
 * Flowtype definitions for showdown
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare
var npm$namespace$Showdown: {
    setOption: typeof Showdown$setOption,
    getOption: typeof Showdown$getOption,
    getOptions: typeof Showdown$getOptions,
    resetOptions: typeof Showdown$resetOptions,
    getDefaultOptions: typeof Showdown$getDefaultOptions,
    extension: typeof Showdown$extension,
    getAllExtensions: typeof Showdown$getAllExtensions,
    removeExtension: typeof Showdown$removeExtension,
    resetExtensions: typeof Showdown$resetExtensions,
}
declare interface Showdown$Extension {

    /**
     * Property defines the nature of said sub-extensions and can assume 2 values:
     * 
     * `lang` - Language extensions add new markdown syntax to showdown.
     * `output` - Output extensions (or modifiers) alter the HTML output generated by showdown
     */
    type: string
}


/**
 * Regex/replace style extensions are very similar to javascript's string.replace function.
 * Two properties are given, `regex` and `replace`.
 */
declare type Showdown$RegexReplaceExtension = {

    /**
     * Should be either a string or a RegExp object.
     * 
    Keep in mind that, if a string is used, it will automatically be given a g modifier,
    that is, it is assumed to be a global replacement.
    */
    regex?: string | RegExp,

    /**
     * Can be either a string or a function. If replace is a string,
     * it can use the $1 syntax for group substitution,
    exactly as if it were making use of string.replace (internally it does this actually).
    */
    replace?: any
} & Showdown$Extension



/**
 * If you'd just like to do everything yourself,you can specify a filter property.
 * The filter property should be a function that acts as a callback.
 */
declare type Showdown$FilterExtension = {
    filter?: (
        text: string,
        converter: Showdown$Converter,
        options?: Showdown$ConverterOptions) => string
} & Showdown$Extension



/**
 * Defines a plugin/extension
 * Each single extension can be one of two types:

+ Language Extension -- Language extensions are ones that that add new markdown syntax to showdown. For example, say you wanted ^^youtube http://www.youtube.com/watch?v=oHg5SJYRHA0 to automatically render as an embedded YouTube video, that would be a language extension.
+ Output Modifiers -- After showdown has run, and generated HTML, an output modifier would change that HTML. For example, say you wanted to change <div class="header"> to be <header>, that would be an output modifier.

Each extension can provide two combinations of interfaces for showdown.
*/
declare type Showdown$ShowdownExtension = {} & Showdown$RegexReplaceExtension & Showdown$FilterExtension


declare interface Showdown$ConverterExtensions {
    language: Showdown$ShowdownExtension[],
        output: Showdown$ShowdownExtension[]
}

declare interface Showdown$ShowdownOptions {

    /**
     * Omit the trailing newline in a code block. Ex:
     * 
    This:
       <code><pre>var foo = 'bar';
       </pre></code>

    Becomes this:
       <code><pre>var foo = 'bar';</pre></code>
     * @default  false
    */
    omitExtraWLInCodeBlocks?: boolean,

        /**
         * Disable the automatic generation of header ids. Setting to true overrides <strong>prefixHeaderId</strong>.
         * @default  false
         */
        noHeaderId?: boolean,

        /**
         * Add a prefix to the generated header ids.
         * Passing a string will prefix that string to the header id.
        Setting to true will add a generic 'section' prefix.
         * @default  false
        */
        prefixHeaderId?: string | boolean,

        /**
         * Enable support for setting image dimensions from within markdown syntax.
         * Examples:

           ![foo](foo.jpg =100x80)     simple, assumes units are in px
           ![bar](bar.jpg =100x)      sets the height to "auto"
           ![baz](baz.jpg =80%x5em)  Image with width of 80% and height of 5em
         * @default  false
        */
        parseImgDimensions?: boolean,

        /**
         * Set the header starting level. For instance, setting this to 3 means that
         * 
           # foo

        will be parsed as

           <h3>foo</h3>
         * @default  1
        */
        headerLevelStart?: number,

        /**
         * Turning this on will stop showdown from interpreting underscores in the middle of
         * words as <em> and <strong> and instead treat them as literal underscores.

        Example:

           some text with__underscores__in middle

        will be parsed as

           <p>some text with__underscores__in middle</p>
         * @default  false
        */
        literalMidWordUnderscores?: boolean,

        /**
         * Enable support for strikethrough syntax.
         * `~~strikethrough~~` as `<del>strikethrough</del>`.
         * @default  false
         */
        strikethrough?: boolean,

        /**
         * Enable support for tables syntax. Example:
         * 
           | h1    |    h2   |      h3 |
           |:------|:-------:|--------:|
           | 100   | [a][1]  | ![b][2] |
           | *foo | *bar* | ~~baz~~ |

        See the wiki for more info
         * @default  false
        */
        tables?: boolean,

        /**
         * If enabled adds an id property to table headers tags.
         * @default  false
         */
        tablesHeaderId?: boolean,

        /**
         * Enable support for GFM code block style.
         * @default  true
         */
        ghCodeBlocks?: boolean,

        /**
         * Enable support for GFM takslists. Example:
         * 
           - [x] This task is done
           - [ ] This is still pending
         * @default  false
        */
        tasklists?: boolean,

        /**
         * Prevents weird effects in live previews due to incomplete input.
         * @default  false
         */
        smoothLivePreview?: boolean
}

declare type Showdown$ConverterOptions = {
    extensions?: string | string[]
} & Showdown$ShowdownOptions


declare interface Showdown$Converter {

    /**
     * 
     * @param text The input text (markdown)
     * @return  The output HTML
     */
    makeHtml(text: string): string,

        /**
         * Setting a "local" option only affects the specified Converter object.
         * @param optionKey 
         * @param string 
         */
        setOption(optionKey: string, value: string): void,

        /**
         * Get the option of this Converter instance.
         * @param optionKey 
         */
        getOption(optionKey: string): any,

        /**
         * Get the options of this Converter instance.
         */
        getOptions(): Showdown$ShowdownOptions,

        /**
         * Add extension to THIS converter.
         * @param extension 
         * @param name 
         */
        addExtension(extension: Showdown$ShowdownExtension, name: string): void,

        /**
         * Use a global registered extension with THIS converter
         * @param extensionName Name of the previously registered extension.
         */
        useExtension(extensionName: string): void,

        /**
         * Get all extensions.
         * @return  all extensions.
         */
        getAllExtensions(): Showdown$ConverterExtensions,

        /**
         * Remove an extension from THIS converter.
         * 
        Note: This is a costly operation. It's better to initialize a new converter
        and specify the extensions you wish to use.
         * @param extensions 
        */
        removeExtension(extensions: Showdown$ShowdownExtension[] | Showdown$ShowdownExtension): void
}

declare interface Showdown$ConverterStatic {

    /**
     * 
     * @constructor  * 
     * @param converterOptions Configuration object, describes which extensions to apply
     */
    new(converterOptions?: Showdown$ConverterOptions): Showdown$Converter
}

declare
var Converter: Showdown$ConverterStatic;


/**
 * Setting a "global" option affects all instances of showdown
 */
declare
function Showdown$setOption(optionKey: string, value: string): void


/**
 * Retrieve previous set global option.
 * @param optionKey 
 */
declare
function Showdown$getOption(optionKey: string): any


/**
 * Retrieve previous set global options.
 */
declare
function Showdown$getOptions(): Showdown$ShowdownOptions


/**
 * Reset options.
 */
declare
function Showdown$resetOptions(): void


/**
 * Retrieve the default options.
 */
declare
function Showdown$getDefaultOptions(): Showdown$ShowdownOptions


/**
 * Register an extension.
 * @prarm  name
 * @param extenstion 
 */
declare
function Showdown$extension(
    name: string,
    extension: (() => Showdown$ShowdownExtension) | (() => Showdown$ShowdownExtension[]) | Showdown$ShowdownExtension): void


/**
 * Get all extensions.
 * @return  all extensions.
 */
declare
function Showdown$getAllExtensions(): {
    [name: string]: Showdown$ShowdownExtension[]
}


/**
 * Remove an extension.
 * @param name 
 */
declare
function Showdown$removeExtension(name: string): void


/**
 * Reset extensions.
 */
declare
function Showdown$resetExtensions(): voiddeclare module 'showdown' {
    declare module.exports: typeof Showdown
}