// @flow
/**
 * Flowtype definitions for rrule
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'rrule' {
    declare module.exports: typeof RRule
}

declare var npm$namespace$RRule: {
    parseText: typeof RRule$parseText,
    fromText: typeof RRule$fromText,
    optionsToString: typeof RRule$optionsToString,
    parseString: typeof RRule$parseString,
    fromString: typeof RRule$fromString,
}
declare var FREQUENCIES: "YEARLY" |
    "MONTHLY" |
    "WEEKLY" |
    "DAILY" |
    "HOURLY" |
    "MINUTELY" |
    "SECONDLY";

declare var YEARLY: Frequency;

declare var MONTHLY: Frequency;

declare var WEEKLY: Frequency;

declare var DAILY: Frequency;

declare var HOURLY: Frequency;

declare var MINUTELY: Frequency;

declare var SECONDLY: Frequency;

declare var MO: RRule$Weekday;

declare var TU: RRule$Weekday;

declare var WE: RRule$Weekday;

declare var TH: RRule$Weekday;

declare var FR: RRule$Weekday;

declare var SA: RRule$Weekday;

declare var SU: RRule$Weekday;

declare var DEFAULT_OPTIONS: RRule$Options;

declare function RRule$parseText(text: string, language?: any): RRule$Options

declare function RRule$fromText(text: string, language?: any): RRule

declare function RRule$optionsToString(options: RRule$Options): string

declare function RRule$parseString(rfcString: string): RRule$Options

declare function RRule$fromString(value: string): RRule

declare class RRuleSet mixins RRule {

    /**
     * 
     * @param  The same stratagy as RRule on cache, default to false
     * @constructor  
     */
    constructor(noCache?: boolean): this;
    rrule(rrule: RRule): void;
    rdate(date: Date): void;
    exrule(rrule: RRule): void;
    exdate(date: Date): void;
    valueOf(): string[];

    /**
     * to generate recurrence field sush as:
     *    ["RRULE:FREQ=YEARLY;COUNT=2;BYDAY=TU;DTSTART=19970902T010000Z","RRULE:FREQ=YEARLY;COUNT=1;BYDAY=TH;DTSTART=19970902T010000Z"]
     */
    toString(): string;

    /**
     * Create a new RRuleSet Object completely base on current instance
     */
    clone(): RRule$RRuleSet
}
declare class RRule {

    /**
     * 
     * @param  - see <http://labix.org/python-dateutil/#head-cf004ee9a75592797e076752b2a889c10f445418>
    The only required option is `freq`, one of RRule.YEARLY, RRule.MONTHLY, ...
     * @constructor  
    */
    constructor(options: RRule$Options, noCache?: boolean): this;
    options: RRule$Options;
    origOptions: RRule$Options;

    /**
     * Returns the first recurrence after the given datetime instance.
     * The inc keyword defines what happens if dt is an occurrence.
    With inc == True, if dt itself is an occurrence, it will be returned.
     * @return  Date or null
    */
    after(dt: Date, inc?: boolean): Date;

    /**
     * 
     * @param  - optional function that will be called
    on each date that is added. It can return false
    to stop the iteration.
     * @return  Array containing all recurrences.
    */
    all(iterator?: (date: Date, index?: number) => void): Date[];

    /**
     * Returns all the occurrences of the rrule between after and before.
     * The inc keyword defines what happens if after and/or before are
    themselves occurrences. With inc == True, they will be included in the
    list, if they are found in the recurrence set.
     * @return  Array
    */
    between(
        a: Date,
        b: Date,
        inc?: boolean,
        iterator?: (date: Date, index: number) => void): Date[];

    /**
     * Returns the last recurrence before the given datetime instance.
     * The inc keyword defines what happens if dt is an occurrence.
    With inc == True, if dt itself is an occurrence, it will be returned.
     * @return  Date or null
    */
    before(dt: Date, inc?: boolean): Date;

    /**
     * Returns the number of recurrences in this set. It will have go trough
     * the whole recurrence, if this hasn't been done before.
     */
    count(): number;

    /**
     * Converts the rrule into its string representation
     * @see  <http://www.ietf.org/rfc/rfc2445.txt>
     * @return  String
     */
    toString(): string;

    /**
     * Will convert all rules described in nlp:ToText
     * to text.
     */
    toText(gettext?: (str: string) => string, language?: any): string;
    isFullyConvertibleToText(): boolean;
    clone(): RRule
}