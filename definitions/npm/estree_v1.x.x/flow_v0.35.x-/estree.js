/**
 * Flowtype definitions for estree
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface ESTree$Node {
    type: string,
        loc?: ESTree$SourceLocation,
        range?: [number, number]
}

declare interface ESTree$SourceLocation {
    source?: string,
        start: ESTree$Position,
        end: ESTree$Position
}

declare interface ESTree$Position {
    line: number,
        column: number
}

declare type ESTree$Program = {
    body: Array<ESTree$Statement | ESTree$ModuleDeclaration>,
    sourceType: string
} & ESTree$Node


declare type ESTree$Function = {
    id?: ESTree$Identifier,
    params: Array<ESTree$Pattern>,
    body: ESTree$BlockStatement | ESTree$Expression,
    generator: boolean
} & ESTree$Node


declare type ESTree$Statement = {} & ESTree$Node


declare type ESTree$EmptyStatement = {} & ESTree$Statement


declare type ESTree$BlockStatement = {
    body: Array<ESTree$Statement >
} & ESTree$Statement


declare type ESTree$ExpressionStatement = {
    expression: ESTree$Expression
} & ESTree$Statement


declare type ESTree$IfStatement = {
    test: ESTree$Expression,
    consequent: ESTree$Statement,
    alternate?: ESTree$Statement
} & ESTree$Statement


declare type ESTree$LabeledStatement = {
    label: ESTree$Identifier,
    body: ESTree$Statement
} & ESTree$Statement


declare type ESTree$BreakStatement = {
    label?: ESTree$Identifier
} & ESTree$Statement


declare type ESTree$ContinueStatement = {
    label?: ESTree$Identifier
} & ESTree$Statement


declare type ESTree$WithStatement = {
    object: ESTree$Expression,
    body: ESTree$Statement
} & ESTree$Statement


declare type ESTree$SwitchStatement = {
    discriminant: ESTree$Expression,
    cases: Array<ESTree$SwitchCase >
} & ESTree$Statement


declare type ESTree$ReturnStatement = {
    argument?: ESTree$Expression
} & ESTree$Statement


declare type ESTree$ThrowStatement = {
    argument: ESTree$Expression
} & ESTree$Statement


declare type ESTree$TryStatement = {
    block: ESTree$BlockStatement,
    handler?: ESTree$CatchClause,
    finalizer?: ESTree$BlockStatement
} & ESTree$Statement


declare type ESTree$WhileStatement = {
    test: ESTree$Expression,
    body: ESTree$Statement
} & ESTree$Statement


declare type ESTree$DoWhileStatement = {
    body: ESTree$Statement,
    test: ESTree$Expression
} & ESTree$Statement


declare type ESTree$ForStatement = {
    init?: ESTree$VariableDeclaration | ESTree$Expression,
    test?: ESTree$Expression,
    update?: ESTree$Expression,
    body: ESTree$Statement
} & ESTree$Statement


declare type ESTree$ForInStatement = {
    left: ESTree$VariableDeclaration | ESTree$Expression,
    right: ESTree$Expression,
    body: ESTree$Statement
} & ESTree$Statement


declare type ESTree$DebuggerStatement = {} & ESTree$Statement


declare type ESTree$Declaration = {} & ESTree$Statement


declare type ESTree$FunctionDeclaration = {
    id: ESTree$Identifier
} & ESTree$Function & ESTree$Declaration


declare type ESTree$VariableDeclaration = {
    declarations: Array<ESTree$VariableDeclarator>,
    kind: string
} & ESTree$Declaration


declare type ESTree$VariableDeclarator = {
    id: ESTree$Pattern,
    init?: ESTree$Expression
} & ESTree$Node


declare type ESTree$Expression = {} & ESTree$Node


declare type ESTree$ThisExpression = {} & ESTree$Expression


declare type ESTree$ArrayExpression = {
    elements: Array<ESTree$Expression | ESTree$SpreadElement >
} & ESTree$Expression


declare type ESTree$ObjectExpression = {
    properties: Array<ESTree$Property >
} & ESTree$Expression


declare type ESTree$Property = {
    key: ESTree$Expression,
    value: ESTree$Expression,
    kind: string,
    method: boolean,
    shorthand: boolean,
    computed: boolean
} & ESTree$Node


declare type ESTree$FunctionExpression = {} & ESTree$Function & ESTree$Expression


declare type ESTree$SequenceExpression = {
    expressions: Array<ESTree$Expression >
} & ESTree$Expression


declare type ESTree$UnaryExpression = {
    operator: ESTree$UnaryOperator,
    prefix: boolean,
    argument: ESTree$Expression
} & ESTree$Expression


declare type ESTree$BinaryExpression = {
    operator: ESTree$BinaryOperator,
    left: ESTree$Expression,
    right: ESTree$Expression
} & ESTree$Expression


declare type ESTree$AssignmentExpression = {
    operator: ESTree$AssignmentOperator,
    left: ESTree$Pattern | ESTree$MemberExpression,
    right: ESTree$Expression
} & ESTree$Expression


declare type ESTree$UpdateExpression = {
    operator: ESTree$UpdateOperator,
    argument: ESTree$Expression,
    prefix: boolean
} & ESTree$Expression


declare type ESTree$LogicalExpression = {
    operator: ESTree$LogicalOperator,
    left: ESTree$Expression,
    right: ESTree$Expression
} & ESTree$Expression


declare type ESTree$ConditionalExpression = {
    test: ESTree$Expression,
    alternate: ESTree$Expression,
    consequent: ESTree$Expression
} & ESTree$Expression


declare type ESTree$CallExpression = {
    callee: ESTree$Expression | ESTree$Super,
    arguments: Array<ESTree$Expression | ESTree$SpreadElement >
} & ESTree$Expression


declare type ESTree$NewExpression = {} & ESTree$CallExpression


declare type ESTree$MemberExpression = {
    object: ESTree$Expression | ESTree$Super,
    property: ESTree$Expression,
    computed: boolean
} & ESTree$Expression & ESTree$Pattern


declare type ESTree$Pattern = {} & ESTree$Node


declare type ESTree$SwitchCase = {
    test?: ESTree$Expression,
    consequent: Array<ESTree$Statement >
} & ESTree$Node


declare type ESTree$CatchClause = {
    param: ESTree$Pattern,
    body: ESTree$BlockStatement
} & ESTree$Node


declare type ESTree$Identifier = {
    name: string
} & ESTree$Node & ESTree$Expression & ESTree$Pattern


declare type ESTree$Literal = {
    value?: string | boolean | number | RegExp
} & ESTree$Node & ESTree$Expression


declare type ESTree$RegExpLiteral = {
    regex: {
        pattern: string,
        flags: string
    }
} & ESTree$Literal


declare type ESTree$UnaryOperator = string;

declare type ESTree$BinaryOperator = string;

declare type ESTree$LogicalOperator = string;

declare type ESTree$AssignmentOperator = string;

declare type ESTree$UpdateOperator = string;

declare type ESTree$ForOfStatement = {} & ESTree$ForInStatement


declare type ESTree$Super = {} & ESTree$Node


declare type ESTree$SpreadElement = {
    argument: ESTree$Expression
} & ESTree$Node


declare type ESTree$ArrowFunctionExpression = {
    expression: boolean
} & ESTree$Function & ESTree$Expression


declare type ESTree$YieldExpression = {
    argument?: ESTree$Expression,
    delegate: boolean
} & ESTree$Expression


declare type ESTree$TemplateLiteral = {
    quasis: Array<ESTree$TemplateElement>,
    expressions: Array<ESTree$Expression >
} & ESTree$Expression


declare type ESTree$TaggedTemplateExpression = {
    tag: ESTree$Expression,
    quasi: ESTree$TemplateLiteral
} & ESTree$Expression


declare type ESTree$TemplateElement = {
    tail: boolean,
    value: {
        cooked: string,
        raw: string
    }
} & ESTree$Node


declare type ESTree$AssignmentProperty = {
    value: ESTree$Pattern,
    kind: string,
    method: boolean
} & ESTree$Property


declare type ESTree$ObjectPattern = {
    properties: Array<ESTree$AssignmentProperty >
} & ESTree$Pattern


declare type ESTree$ArrayPattern = {
    elements: Array<ESTree$Pattern >
} & ESTree$Pattern


declare type ESTree$RestElement = {
    argument: ESTree$Pattern
} & ESTree$Pattern


declare type ESTree$AssignmentPattern = {
    left: ESTree$Pattern,
    right: ESTree$Expression
} & ESTree$Pattern


declare type ESTree$Class = {
    id?: ESTree$Identifier,
    superClass: ESTree$Expression,
    body: ESTree$ClassBody
} & ESTree$Node


declare type ESTree$ClassBody = {
    body: Array<ESTree$MethodDefinition >
} & ESTree$Node


declare type ESTree$MethodDefinition = {
    key: ESTree$Expression,
    value: ESTree$FunctionExpression,
    kind: string,
    computed: boolean,
    static: boolean
} & ESTree$Node


declare type ESTree$ClassDeclaration = {
    id: ESTree$Identifier
} & ESTree$Class & ESTree$Declaration


declare type ESTree$ClassExpression = {} & ESTree$Class & ESTree$Expression


declare type ESTree$MetaProperty = {
    meta: ESTree$Identifier,
    property: ESTree$Identifier
} & ESTree$Expression


declare type ESTree$ModuleDeclaration = {} & ESTree$Node


declare type ESTree$ModuleSpecifier = {
    local: ESTree$Identifier
} & ESTree$Node


declare type ESTree$ImportDeclaration = {
    specifiers: Array<ESTree$ImportSpecifier | ESTree$ImportDefaultSpecifier | ESTree$ImportNamespaceSpecifier>,
    source: ESTree$Literal
} & ESTree$ModuleDeclaration


declare type ESTree$ImportSpecifier = {
    imported: ESTree$Identifier
} & ESTree$ModuleSpecifier


declare type ESTree$ImportDefaultSpecifier = {} & ESTree$ModuleSpecifier


declare type ESTree$ImportNamespaceSpecifier = {} & ESTree$ModuleSpecifier


declare type ESTree$ExportNamedDeclaration = {
    declaration?: ESTree$Declaration,
    specifiers: Array<ESTree$ExportSpecifier>,
    source?: ESTree$Literal
} & ESTree$ModuleDeclaration


declare type ESTree$ExportSpecifier = {
    exported: ESTree$Identifier
} & ESTree$ModuleSpecifier


declare type ESTree$ExportDefaultDeclaration = {
    declaration: ESTree$Declaration | ESTree$Expression
} & ESTree$ModuleDeclaration


declare type ESTree$ExportAllDeclaration = {
    source: ESTree$Literal
} & ESTree$ModuleDeclaration