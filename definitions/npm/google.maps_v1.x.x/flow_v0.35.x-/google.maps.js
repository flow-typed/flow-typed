// @flow
/**
 * Flowtype definitions for google.maps
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'maps' {
    declare     export class Map mixins MVCObject {
        constructor(mapDiv: Element, opts?: MapOptions): this;
        fitBounds(bounds: LatLngBounds): void;
        getBounds(): LatLngBounds;
        getCenter(): LatLng;
        getDiv(): Element;
        getHeading(): number;
        getMapTypeId(): MapTypeId | string;
        getProjection(): Projection;
        getStreetView(): StreetViewPanorama;
        getTilt(): number;
        getZoom(): number;
        panBy(x: number, y: number): void;
        panTo(latLng: LatLng | LatLngLiteral): void;
        panToBounds(latLngBounds: LatLngBounds): void;
        setCenter(latlng: LatLng | LatLngLiteral): void;
        setHeading(heading: number): void;
        setMapTypeId(mapTypeId: MapTypeId | string): void;
        setOptions(options: MapOptions): void;
        setStreetView(panorama: StreetViewPanorama): void;
        setTilt(tilt: number): void;
        setZoom(zoom: number): void;
        controls: MVCArray[];
        data: Data;
        mapTypes: MapTypeRegistry;
        overlayMapTypes: MVCArray
    }
    declare     export interface MapOptions {
        backgroundColor?: string,
            center?: LatLng | LatLngLiteral,
            disableDefaultUI?: boolean,
            clickableIcons?: boolean,
            disableDoubleClickZoom?: boolean,
            draggable?: boolean,
            draggableCursor?: string,
            draggingCursor?: string,
            heading?: number,
            keyboardShortcuts?: boolean,
            mapMaker?: boolean,
            mapTypeControl?: boolean,
            mapTypeControlOptions?: MapTypeControlOptions,
            mapTypeId?: MapTypeId,
            maxZoom?: number,
            minZoom?: number,
            noClear?: boolean,
            overviewMapControl?: boolean,
            overviewMapControlOptions?: OverviewMapControlOptions,
            panControl?: boolean,
            panControlOptions?: PanControlOptions,
            rotateControl?: boolean,
            rotateControlOptions?: RotateControlOptions,
            scaleControl?: boolean,
            scaleControlOptions?: ScaleControlOptions,
            scrollwheel?: boolean,
            streetView?: StreetViewPanorama,
            streetViewControl?: boolean,
            streetViewControlOptions?: StreetViewControlOptions,
            styles?: MapTypeStyle[],
            tilt?: number,
            zoom?: number,
            zoomControl?: boolean,
            zoomControlOptions?: ZoomControlOptions
    }
    declare     export interface MapTypeControlOptions {
        mapTypeIds?: (MapTypeId | string)[],
            position?: ControlPosition,
            style?: MapTypeControlStyle
    }
    declare     export interface OverviewMapControlOptions {
        opened?: boolean
    }
    declare     export interface PanControlOptions {
        position?: ControlPosition
    }
    declare     export interface RotateControlOptions {
        position?: ControlPosition
    }
    declare     export interface ScaleControlOptions {
        style?: ScaleControlStyle
    }
    declare     export interface StreetViewControlOptions {
        position?: ControlPosition
    }
    declare     export interface ZoomControlOptions {
        position?: ControlPosition,
            style?: ZoomControlStyle
    }
    declare module 'Data' {
        declare         export interface DataOptions {
            controlPosition?: ControlPosition,
                controls?: string[],
                drawingMode?: string,
                featureFactory?: (geometry: Data.Geometry) => Data.Feature,
                map?: Map,
                style?: Data.StylingFunction | Data.StyleOptions
        }
        declare         export interface GeoJsonOptions {
            idPropertyName?: string
        }
        declare         export interface StyleOptions {
            clickable?: boolean,
                cursor?: string,
                draggable?: boolean,
                editable?: boolean,
                fillColor?: string,
                fillOpacity?: number,
                icon?: string | Icon | Symbol,
                shape?: MarkerShape,
                strokeColor?: string,
                strokeOpacity?: number,
                strokeWeight?: number,
                title?: string,
                visible?: boolean,
                zIndex?: number
        }
        declare         export type StylingFunction = (feature: Data.Feature) => Data.StyleOptions;
        declare         export class Feature {
            constructor(options?: Data.FeatureOptions): this;
            forEachProperty(callback: (value: any, name: string) => void): void;
            getGeometry(): Data.Geometry;
            getId(): number | string;
            getProperty(name: string): any;
            removeProperty(name: string): void;
            setGeometry(newGeometry: Data.Geometry | LatLng | LatLngLiteral): void;
            setProperty(name: string, newValue: any): void;
            toGeoJson(callback: (feature: Object) => void): void
        }
        declare         export interface FeatureOptions {
            geometry?: Data.Geometry | LatLng | LatLngLiteral,
                id?: number | string,
                properties?: Object
        }
        declare         export class Geometry {
            getType(): string
        }
        declare         export class Point mixins Data.Geometry {
            constructor(latLng: LatLng | LatLngLiteral): this;
            get(): LatLng
        }
        declare         export class MultiPoint mixins Data.Geometry {
            constructor(elements: (LatLng | LatLngLiteral)[]): this;
            getArray(): LatLng[];
            getAt(n: number): LatLng;
            getLength(): number
        }
        declare         export class LineString mixins Data.Geometry {
            constructor(elements: (LatLng | LatLngLiteral)[]): this;
            getArray(): LatLng[];
            getAt(n: number): LatLng;
            getLength(): number
        }
        declare         export class MultiLineString mixins Data.Geometry {
            constructor(elements: (Data.LineString | (LatLng | LatLngLiteral)[])[]): this;
            getArray(): Data.LineString[];
            getAt(n: number): Data.LineString;
            getLength(): number
        }
        declare         export class LinearRing mixins Data.Geometry {
            constructor(elements: (LatLng | LatLngLiteral)[]): this;
            getArray(): LatLng[];
            getAt(n: number): LatLng;
            getLength(): number
        }
        declare         export class Polygon mixins Data.Geometry {
            constructor(elements: (Data.LinearRing | (LatLng | LatLngLiteral)[])[]): this;
            getArray(): Data.LinearRing[];
            getAt(n: number): Data.LinearRing;
            getLength(): number
        }
        declare         export class MultiPolygon mixins Data.Geometry {
            constructor(elements: (Data.Polygon | (LinearRing | (LatLng | LatLngLiteral)[])[])[]): this;
            getArray(): Data.Polygon[];
            getAt(n: number): Data.Polygon;
            getLength(): number
        }
        declare         export class GeometryCollection mixins Data.Geometry {
            constructor(elements: (Data.Geometry[] | LatLng[] | LatLngLiteral)[]): this;
            getArray(): Data.Geometry[];
            getAt(n: number): Data.Geometry;
            getLength(): number
        }
        declare         export type MouseEvent = {
            feature: Data.Feature
        }
        declare         export interface AddFeatureEvent {
            feature: Data.Feature
        }
        declare         export interface RemoveFeatureEvent {
            feature: Data.Feature
        }
        declare         export interface SetGeometryEvent {
            feature: Data.Feature,
                newGeometry: Data.Geometry,
                oldGeometry: Data.Geometry
        }
        declare         export interface SetPropertyEvent {
            feature: Data.Feature,
                name: string,
                newValue: any,
                oldValue: any
        }
        declare         export interface RemovePropertyEvent {
            feature: Data.Feature,
                name: string,
                oldValue: any
        }
    }

    declare     export class Marker mixins MVCObject {
        MAX_ZINDEX: number;
        constructor(opts?: MarkerOptions): this;
        getAnimation(): Animation;
        getAttribution(): Attribution;
        getClickable(): boolean;
        getCursor(): string;
        getDraggable(): boolean;
        getIcon(): string | Icon | Symbol;
        getLabel(): MarkerLabel;
        getMap(): Map | StreetViewPanorama;
        getOpacity(): number;
        getPlace(): Place;
        getPosition(): LatLng;
        getShape(): MarkerShape;
        getTitle(): string;
        getVisible(): boolean;
        getZIndex(): number;
        setAnimation(animation: Animation): void;
        setAttribution(attribution: Attribution): void;
        setClickable(flag: boolean): void;
        setCursor(cursor: string): void;
        setDraggable(flag: boolean): void;
        setIcon(icon: string | Icon | Symbol): void;
        setLabel(label: string | MarkerLabel): void;
        setMap(map: Map | StreetViewPanorama): void;
        setOpacity(opacity: number): void;
        setOptions(options: MarkerOptions): void;
        setPlace(place: Place): void;
        setPosition(latlng: LatLng | LatLngLiteral): void;
        setShape(shape: MarkerShape): void;
        setTitle(title: string): void;
        setVisible(visible: boolean): void;
        setZIndex(zIndex: number): void
    }
    declare     export interface MarkerOptions {

        /**
         * The offset from the marker's position to the tip of an InfoWindow
         * that has been opened with the marker as anchor.
         */
        anchorPoint?: Point,

            /**
             * Which animation to play when marker is added to a map. 
             */
            animation?: Animation,

            /**
             * If true, the marker receives mouse and touch events.
             * @default  true
             */
            clickable?: boolean,

            /**
             * Mouse cursor to show on hover. 
             */
            cursor?: string,

            /**
             * If true, the marker can be dragged.
             * @default  false
             */
            draggable?: boolean,

            /**
             * Icon for the foreground.
             * If a string is provided, it is treated as though it were an Icon with the string as url.
             * @type  
             */
            icon?: string | Icon | Symbol,

            /**
             * Adds a label to the marker. The label can either be a string, or a MarkerLabel object. 
             * Only the first character of the string will be displayed.
             * @type  
             */
            label?: string | MarkerLabel,

            /**
             * Map on which to display Marker.
             * @type  *
             */
            map?: Map | StreetViewPanorama,

            /**
             * The marker's opacity between 0.0 and 1.0. 
             */
            opacity?: number,

            /**
             * Optimization renders many markers as a single static element.
             * Optimized rendering is enabled by default.
            Disable optimized rendering for animated GIFs or PNGs, or when each
            marker must be rendered as a separate DOM element (advanced usage
            only).
            */
            optimized?: boolean,

            /**
             * Place information, used to identify and describe the place
             * associated with this Marker. In this context, 'place' means a
            business, point of interest or geographic location. To allow a user
            to save this place, open an info window anchored on this marker.
            The info window will contain information about the place and an
            option for the user to save it. Only one of position or place can
            be specified.
            */
            place?: Place,

            /**
             * Marker position. Required.
             */
            position: LatLng | LatLngLiteral,

            /**
             * Image map region definition used for drag/click. 
             */
            shape?: MarkerShape,

            /**
             * Rollover text. 
             */
            title?: string,

            /**
             * If true, the marker is visible. 
             */
            visible?: boolean,

            /**
             * All markers are displayed on the map in order of their zIndex,
             * with higher values displaying in front of markers with lower values.
            By default, markers are displayed according to their vertical position on screen,
            with lower markers appearing in front of markers further up the screen.
            */
            zIndex?: number
    }
    declare     export interface Icon {

        /**
         * The position at which to anchor an image in correspondence to the
         * location of the marker on the map. By default, the anchor is
        located along the center point of the bottom of the image.
        */
        anchor?: Point,

            /**
             * The origin of the label relative to the top-left corner of the icon
             * image, if a label is supplied by the marker. By default, the origin
            is located in the center point of the image.
            */
            labelOrigin?: Point,

            /**
             * The position of the image within a sprite, if any. By default, the
             * origin is located at the top left corner of the image (0, 0).
             */
            origin?: Point,

            /**
             * The size of the entire image after scaling, if any. Use this
             * property to stretch/ shrink an image or a sprite.
             */
            scaledSize?: Size,

            /**
             * The display size of the sprite or image. When using sprites, you
             * must specify the sprite size. If the size is not provided, it will
            be set when the image loads.
            */
            size?: Size,

            /**
             * The URL of the image or sprite sheet. 
             */
            url?: string
    }
    declare     export interface MarkerLabel {

        /**
         * The color of the label text. Default color is black. 
         */
        color?: string,

            /**
             * The font family of the label text (equivalent to the CSS font-family property). 
             */
            fontFamily?: string,

            /**
             * The font size of the label text (equivalent to the CSS font-size property). Default size is 14px. 
             */
            fontSize?: string,

            /**
             * The font weight of the label text (equivalent to the CSS font-weight property). 
             */
            fontWeight?: string,

            /**
             * The text to be displayed in the label. Only the first character of this string will be shown. 
             */
            text?: string
    }
    declare     export interface MarkerShape {
        coords?: number[],
            type?: string
    }
    declare     export interface Symbol {

        /**
         * The position of the symbol relative to the marker or polyline.
         * The coordinates of the symbol's path are translated left and up by the anchor's x and y coordinates respectively.
        By default, a symbol is anchored at (0, 0).
        The position is expressed in the same coordinate system as the symbol's path.
        */
        anchor?: Point,

            /**
             * The symbol's fill color.
             * All CSS3 colors are supported except for extended named colors. For symbol markers, this defaults to 'black'.
            For symbols on polylines, this defaults to the stroke color of the corresponding polyline.
            */
            fillColor?: string,

            /**
             * The symbol's fill opacity.
             * @default  0
             */
            fillOpacity?: number,

            /**
             * The symbol's path, which is a built-in symbol path, or a custom path expressed using SVG path notation. Required.
             * @type  
             */
            path?: SymbolPath | string,

            /**
             * The angle by which to rotate the symbol, expressed clockwise in degrees.
             * Defaults to 0.
            A symbol in an IconSequence where fixedRotation is false is rotated relative to the angle of the edge on which it lies.
            */
            rotation?: number,

            /**
             * The amount by which the symbol is scaled in size.
             * For symbol markers, this defaults to 1; after scaling, the symbol may be of any size.
            For symbols on a polyline, this defaults to the stroke weight of the polyline;
            after scaling, the symbol must lie inside a square 22 pixels in size centered at the symbol's anchor.
            */
            scale?: number,

            /**
             * The symbol's stroke color. All CSS3 colors are supported except for extended named colors.
             * For symbol markers, this defaults to 'black'.
            For symbols on a polyline, this defaults to the stroke color of the polyline.
            */
            strokeColor?: string,

            /**
             * The symbol's stroke opacity. For symbol markers, this defaults to 1.
             * For symbols on a polyline, this defaults to the stroke opacity of the polyline.
             */
            strokeOpacity?: number,

            /**
             * The symbol's stroke weight. Defaults to the scale of the symbol.v
             */
            strokeWeight?: number
    }

    /**
     * An overlay that looks like a bubble and is often connected to a marker.
     * This class extends MVCObject.
     */
    declare     export class InfoWindow mixins MVCObject {

        /**
         * Creates an info window with the given options. An InfoWindow can be
         * placed on a map at a particular position or above a marker,
        depending on what is specified in the options. Unless auto-pan is
        disabled, an InfoWindow will pan the map to make itself visible
        when it is opened. After constructing an InfoWindow, you must call
        open to display it on the map. The user can click the close button
        on the InfoWindow to remove it from the map, or the developer can
        call close() for the same effect.
        */
        constructor(opts?: InfoWindowOptions): this;

        /**
         * Closes this InfoWindow by removing it from the DOM structure. 
         */
        close(): void;
        getContent(): string | Element;
        getPosition(): LatLng;
        getZIndex(): number;

        /**
         * Opens this InfoWindow on the given map. Optionally, an InfoWindow can be associated with an anchor.
         * In the core API, the only anchor is the Marker class.
        However, an anchor can be any MVCObject that exposes a LatLng position property and optionally
        a Point anchorPoint property for calculating the pixelOffset (see InfoWindowOptions).
        The anchorPoint is the offset from the anchor's position to the tip of the InfoWindow.
        */
        open(map?: Map | StreetViewPanorama, anchor?: MVCObject): void;
        setContent(content: string | Node): void;
        setOptions(options: InfoWindowOptions): void;
        setPosition(position: LatLng): void;
        setZIndex(zIndex: number): void
    }
    declare     export interface InfoWindowOptions {

        /**
         * Content to display in the InfoWindow. This can be an HTML element, a plain-text string, or a string containing HTML.
         * The InfoWindow will be sized according to the content.
        To set an explicit size for the content, set content to be a HTML element with that size.
         * @type  
        */
        content?: string | Node,

            /**
             * Disable auto-pan on open. By default, the info window will pan the map so that it is fully visible when it opens.
             */
            disableAutoPan?: boolean,

            /**
             * Maximum width of the infowindow, regardless of content's width.
             * This value is only considered if it is set before a call to open.
            To change the maximum width when changing content, call close, setOptions, and then open.
            */
            maxWidth?: number,

            /**
             * The offset, in pixels, of the tip of the info window from the point on the map
             * at whose geographical coordinates the info window is anchored.
            If an InfoWindow is opened with an anchor, the pixelOffset will be calculated from the anchor's anchorPoint property.
            */
            pixelOffset?: Size,

            /**
             * The LatLng at which to display this InfoWindow. If the InfoWindow is opened with an anchor, the anchor's position will be used instead.
             */
            position?: LatLng | LatLngLiteral,

            /**
             * All InfoWindows are displayed on the map in order of their zIndex,
             * with higher values displaying in front of InfoWindows with lower values.
            By default, InfoWindows are displayed according to their latitude,
            with InfoWindows of lower latitudes appearing in front of InfoWindows at higher latitudes.
            InfoWindows are always displayed in front of markers.
            */
            zIndex?: number
    }
    declare     export class Polyline mixins MVCObject {
        constructor(opts?: PolylineOptions): this;
        getDraggable(): boolean;
        getEditable(): boolean;
        getMap(): Map;
        getPath(): MVCArray;
        getVisible(): boolean;
        setDraggable(draggable: boolean): void;
        setEditable(editable: boolean): void;
        setMap(map: Map): void;
        setOptions(options: PolylineOptions): void;
        setPath(path: MVCArray | LatLng[] | LatLngLiteral[]): void;
        setVisible(visible: boolean): void
    }
    declare     export interface PolylineOptions {
        clickable?: boolean,
            draggable?: boolean,
            editable?: boolean,
            geodesic?: boolean,
            icons?: IconSequence[],
            map?: Map,
            path?: MVCArray | LatLng[] | LatLngLiteral[],
            strokeColor?: string,
            strokeOpacity?: number,
            strokeWeight?: number,
            visible?: boolean,
            zIndex?: number
    }
    declare     export interface IconSequence {
        fixedRotation?: boolean,
            icon?: Symbol,
            offset?: string,
            repeat?: string
    }
    declare     export class Polygon mixins MVCObject {
        constructor(opts?: PolygonOptions): this;
        getDraggable(): boolean;
        getEditable(): boolean;
        getMap(): Map;
        getPath(): MVCArray;
        getPaths(): MVCArray;
        getVisible(): boolean;
        setDraggable(draggable: boolean): void;
        setEditable(editable: boolean): void;
        setMap(map: Map): void;
        setOptions(options: PolygonOptions): void;
        setPath(path: MVCArray | LatLng[] | LatLngLiteral[]): void;
        setPaths(paths: MVCArray): void;
        setPaths(paths: MVCArray[]): void;
        setPaths(path: LatLng[]): void;
        setPaths(path: LatLng[][]): void;
        setPaths(path: LatLngLiteral[]): void;
        setPaths(path: LatLngLiteral[][]): void;
        setVisible(visible: boolean): void
    }
    declare     export interface PolygonOptions {

        /**
         * Indicates whether this Polygon handles mouse events. Defaults to true. 
         */
        clickable?: boolean,

            /**
             * If set to true, the user can drag this shape over the map.
             * The geodesic property defines the mode of dragging. Defaults to false.
             */
            draggable?: boolean,

            /**
             * If set to true, the user can edit this shape by dragging the control points
             * shown at the vertices and on each segment. Defaults to false.
             */
            editable?: boolean,

            /**
             * The fill color. All CSS3 colors are supported except for extended named colors. 
             */
            fillColor?: string,

            /**
             * The fill opacity between 0.0 and 1.0 
             */
            fillOpacity?: number,

            /**
             * When true, edges of the polygon are interpreted as geodesic and will follow
             * the curvature of the Earth. When false, edges of the polygon are rendered as
            straight lines in screen space. Note that the shape of a geodesic polygon may
            appear to change when dragged, as the dimensions are maintained relative to
            the surface of the earth. Defaults to false.
            */
            geodesic?: boolean,

            /**
             * Map on which to display Polygon. 
             */
            map?: Map,

            /**
             * The ordered sequence of coordinates that designates a closed loop. Unlike
             * polylines, a polygon may consist of one or more paths. As a result, the paths
            property may specify one or more arrays of LatLng coordinates. Paths are
            closed automatically; do not repeat the first vertex of the path as the last
            vertex. Simple polygons may be defined using a single array of LatLngs. More
            complex polygons may specify an array of arrays. Any simple arrays are
            converted into MVCArrays. Inserting or removing LatLngs from the MVCArray
            will automatically update the polygon on the map.
            */
            paths?: any[],

            /**
             * The stroke color.
             * All CSS3 colors are supported except for extended named colors.
             */
            strokeColor?: string,

            /**
             * The stroke opacity between 0.0 and 1.0 
             */
            strokeOpacity?: number,

            /**
             * The stroke position. Defaults to CENTER.
             * This property is not supported on Internet Explorer 8 and earlier.
             */
            strokePosition?: StrokePosition,

            /**
             * The stroke width in pixels. 
             */
            strokeWeight?: number,

            /**
             * Whether this polygon is visible on the map. Defaults to true. 
             */
            visible?: boolean,

            /**
             * The zIndex compared to other polys. 
             */
            zIndex?: number
    }
    declare     export type PolyMouseEvent = {
        edge?: number,
        path?: number,
        vertex?: number
    } & MouseEvent

    declare     export class Rectangle mixins MVCObject {
        constructor(opts?: RectangleOptions): this;
        getBounds(): LatLngBounds;
        getDraggable(): boolean;
        getEditable(): boolean;
        getMap(): Map;
        getVisible(): boolean;
        setBounds(bounds: LatLngBounds): void;
        setDraggable(draggable: boolean): void;
        setEditable(editable: boolean): void;
        setMap(map: Map): void;
        setOptions(options: RectangleOptions): void;
        setVisible(visible: boolean): void
    }
    declare     export interface RectangleOptions {
        bounds?: LatLngBounds,
            clickable?: boolean,
            draggable?: boolean,
            editable?: boolean,
            fillColor?: string,
            fillOpacity?: number,
            map?: Map,
            strokeColor?: string,
            strokeOpacity?: number,
            strokePosition?: StrokePosition,
            strokeWeight?: number,
            visible?: boolean,
            zIndex?: number
    }
    declare     export class Circle mixins MVCObject {
        constructor(opts?: CircleOptions): this;
        getBounds(): LatLngBounds;
        getCenter(): LatLng;
        getDraggable(): boolean;
        getEditable(): boolean;
        getMap(): Map;
        getRadius(): number;
        getVisible(): boolean;
        setCenter(center: LatLng | LatLngLiteral): void;
        setDraggable(draggable: boolean): void;
        setEditable(editable: boolean): void;
        setMap(map: Map): void;
        setOptions(options: CircleOptions): void;
        setRadius(radius: number): void;
        setVisible(visible: boolean): void
    }
    declare     export interface CircleOptions {
        center?: LatLng,
            clickable?: boolean,
            draggable?: boolean,
            editable?: boolean,
            fillColor?: string,
            fillOpacity?: number,
            map?: Map,
            radius?: number,
            strokeColor?: string,
            strokeOpacity?: number,
            strokePosition?: StrokePosition,
            strokeWeight?: number,
            visible?: boolean,
            zIndex?: number
    }
    declare     export class GroundOverlay mixins MVCObject {
        constructor(url: string, bounds: LatLngBounds, opts?: GroundOverlayOptions): this;
        getBounds(): LatLngBounds;
        getMap(): Map;
        getOpacity(): number;
        getUrl(): string;
        setMap(map: Map): void;
        setOpacity(opacity: number): void
    }
    declare     export interface GroundOverlayOptions {
        clickable?: boolean,
            map?: Map,
            opacity?: number
    }
    declare     export class OverlayView mixins MVCObject {
        draw(): void;
        getMap(): Map | StreetViewPanorama;
        getPanes(): MapPanes;
        getProjection(): MapCanvasProjection;
        onAdd(): void;
        onRemove(): void;
        setMap(map: Map | StreetViewPanorama): void
    }
    declare     export interface MapPanes {
        floatPane: Element,
            mapPane: Element,
            markerLayer: Element,
            overlayLayer: Element,
            overlayMouseTarget: Element
    }
    declare     export class MapCanvasProjection mixins MVCObject {
        fromContainerPixelToLatLng(pixel: Point, nowrap?: boolean): LatLng;
        fromDivPixelToLatLng(pixel: Point, nowrap?: boolean): LatLng;
        fromLatLngToContainerPixel(latLng: LatLng): Point;
        fromLatLngToDivPixel(latLng: LatLng): Point;
        getWorldWidth(): number
    }
    declare     export class Geocoder {
        geocode(
            request: GeocoderRequest,
            callback: (results: GeocoderResult[], status: GeocoderStatus) => void): void
    }
    declare     export interface GeocoderRequest {
        address?: string,
            bounds?: LatLngBounds,
            componentRestrictions?: GeocoderComponentRestrictions,
            location?: LatLng | LatLngLiteral,
            placeId?: string,
            region?: string
    }
    declare     export interface GeocoderComponentRestrictions {
        administrativeArea?: string,
            country?: string,
            locality?: string,
            postalCode?: string,
            route?: string
    }
    declare     export interface GeocoderResult {
        address_components: GeocoderAddressComponent[],
            formatted_address: string,
            geometry: GeocoderGeometry,
            partial_match: boolean,
            place_id: string,
            postcode_localities: string[],
            types: string[]
    }
    declare     export interface GeocoderAddressComponent {
        long_name: string,
            short_name: string,
            types: string[]
    }
    declare     export interface GeocoderGeometry {
        bounds: LatLngBounds,
            location: LatLng,
            location_type: GeocoderLocationType,
            viewport: LatLngBounds
    }
    declare     export class DirectionsRenderer mixins MVCObject {
        constructor(opts?: DirectionsRendererOptions): this;
        getDirections(): DirectionsResult;
        getMap(): Map;
        getPanel(): Element;
        getRouteIndex(): number;
        setDirections(directions: DirectionsResult): void;
        setMap(map: Map): void;
        setOptions(options: DirectionsRendererOptions): void;
        setPanel(panel: Element): void;
        setRouteIndex(routeIndex: number): void
    }
    declare     export interface DirectionsRendererOptions {
        directions?: DirectionsResult,
            draggable?: boolean,
            hideRouteList?: boolean,
            infoWindow?: InfoWindow,
            map?: Map,
            markerOptions?: MarkerOptions,
            panel?: Element,
            polylineOptions?: PolylineOptions,
            preserveViewport?: boolean,
            routeIndex?: number,
            suppressBicyclingLayer?: boolean,
            suppressInfoWindows?: boolean,
            suppressMarkers?: boolean,
            suppressPolylines?: boolean
    }
    declare     export class DirectionsService {
        route(
            request: DirectionsRequest,
            callback: (result: DirectionsResult, status: DirectionsStatus) => void): void
    }
    declare     export interface DirectionsRequest {
        avoidFerries?: boolean,
            avoidHighways?: boolean,
            avoidTolls?: boolean,
            destination?: string | LatLng | Place,
            durationInTraffic?: boolean,
            drivingOptions?: DrivingOptions,
            optimizeWaypoints?: boolean,
            origin?: string | LatLng | Place,
            provideRouteAlternatives?: boolean,
            region?: string,
            transitOptions?: TransitOptions,
            travelMode?: TravelMode,
            unitSystem?: UnitSystem,
            waypoints?: DirectionsWaypoint[]
    }
    declare     export interface TransitOptions {
        arrivalTime?: Date,
            departureTime?: Date,
            modes: TransitMode[],
            routingPreference: TransitRoutePreference
    }
    declare     export interface TransitFare {}
    declare     export interface DrivingOptions {
        departureTime: Date,
            trafficModel: TrafficModel
    }
    declare     export interface DirectionsWaypoint {
        location: LatLng | LatLngLiteral | string,
            stopover: boolean
    }
    declare     export interface DirectionsResult {
        routes: DirectionsRoute[]
    }
    declare     export interface DirectionsRoute {
        bounds: LatLngBounds,
            copyrights: string,
            fare: TransitFare,
            legs: DirectionsLeg[],
            overview_path: LatLng[],
            overview_polyline: string,
            warnings: string[],
            waypoint_order: number[]
    }
    declare     export interface DirectionsLeg {
        arrival_time: Time,
            departure_time: Time,
            distance: Distance,
            duration: Duration,
            duration_in_traffic: Duration,
            end_address: string,
            end_location: LatLng,
            start_address: string,
            start_location: LatLng,
            steps: DirectionsStep[],
            via_waypoints: LatLng[]
    }
    declare     export interface DirectionsStep {
        distance: Distance,
            duration: Duration,
            end_location: LatLng,
            instructions: string,
            path: LatLng[],
            start_location: LatLng,
            steps: DirectionsStep,
            transit: TransitDetails,
            travel_mode: TravelMode
    }
    declare     export interface Distance {
        text: string,
            value: number
    }
    declare     export interface Duration {
        text: string,
            value: number
    }
    declare     export interface Time {
        text: string,
            time_zone: string,
            value: Date
    }
    declare     export interface TransitDetails {
        arrival_stop: TransitStop,
            arrival_time: Time,
            departure_stop: TransitStop,
            departure_time: Time,
            headsign: string,
            headway: number,
            line: TransitLine,
            num_stops: number
    }
    declare     export interface TransitStop {
        location: LatLng,
            name: string
    }
    declare     export interface TransitLine {
        agencies: TransitAgency[],
            color: string,
            icon: string,
            name: string,
            short_name: string,
            text_color: string,
            url: string,
            vehicle: TransitVehicle
    }
    declare     export interface TransitAgency {
        name: string,
            phone: string,
            url: string
    }
    declare     export interface TransitVehicle {
        icon: string,
            local_icon: string,
            name: string,
            type: VehicleType
    }
    declare     export class ElevationService {
        getElevationAlongPath(
            request: PathElevationRequest,
            callback: (results: ElevationResult[], status: ElevationStatus) => void): void;
        getElevationForLocations(
            request: LocationElevationRequest,
            callback: (results: ElevationResult[], status: ElevationStatus) => void): void
    }
    declare     export interface LocationElevationRequest {
        locations: LatLng[]
    }
    declare     export interface PathElevationRequest {
        path?: LatLng[],
            samples?: number
    }
    declare     export interface ElevationResult {
        elevation: number,
            location: LatLng,
            resolution: number
    }
    declare     export class MaxZoomService {
        getMaxZoomAtLatLng(
            latlng: LatLng | LatLngLiteral,
            callback: (result: MaxZoomResult) => void): void
    }
    declare     export interface MaxZoomResult {
        status: MaxZoomStatus,
            zoom: number
    }
    declare     export class DistanceMatrixService {
        getDistanceMatrix(
            request: DistanceMatrixRequest,
            callback: (response: DistanceMatrixResponse, status: DistanceMatrixStatus) => void): void
    }
    declare     export interface DistanceMatrixRequest {
        avoidFerries?: boolean,
            avoidHighways?: boolean,
            avoidTolls?: boolean,
            destinations?: string[] | LatLng[] | Place[],
            drivingOptions?: DrivingOptions,
            durationInTraffic?: boolean,
            origins?: string[] | LatLng[] | Place[],
            region?: string,
            transitOptions?: TransitOptions,
            travelMode?: TravelMode,
            unitSystem?: UnitSystem
    }
    declare     export interface DistanceMatrixResponse {
        destinationAddresses: string[],
            originAddresses: string[],
            rows: DistanceMatrixResponseRow[]
    }
    declare     export interface DistanceMatrixResponseRow {
        elements: DistanceMatrixResponseElement[]
    }
    declare     export interface DistanceMatrixResponseElement {
        distance: Distance,
            duration: Duration,
            duration_in_traffic: Duration,
            fare: TransitFare,
            status: DistanceMatrixElementStatus
    }
    declare     export interface Attribution {
        iosDeepLinkId?: string,
            source?: string,
            webUrl?: string
    }
    declare     export interface Place {
        location?: LatLng | LatLngLiteral,
            placeId?: string,
            query?: string
    }
    declare     export class SaveWidget {
        constructor(container: Node, opts?: SaveWidgetOptions): this;
        getAttribution(): Attribution;
        getPlace(): Place;
        setAttribution(attribution: Attribution): void;
        setOptions(opts: SaveWidgetOptions): void;
        setPlace(place: Place): void
    }
    declare     export interface SaveWidgetOptions {
        attribution?: Attribution,
            place?: Place
    }
    declare     export interface MapType {
        getTile(tileCoord: Point, zoom: number, ownerDocument: Document): Element,
            releaseTile(tile: Element): void,
            alt?: string,
            maxZoom?: number,
            minZoom?: number,
            name?: string,
            projection?: Projection,
            radius?: number,
            tileSize?: Size
    }
    declare     export class MapTypeRegistry mixins MVCObject {
        constructor(): this;
        set(id: string, mapType: MapType): void
    }
    declare     export interface Projection {
        fromLatLngToPoint(latLng: LatLng, point?: Point): Point,
            fromPointToLatLng(pixel: Point, noWrap?: boolean): LatLng
    }
    declare     export class ImageMapType mixins MVCObject, MapType {
        constructor(opts: ImageMapTypeOptions): this;
        getOpacity(): number;
        getTile(tileCoord: Point, zoom: number, ownerDocument: Document): Element;
        releaseTile(tile: Element): void;
        setOpacity(opacity: number): void
    }
    declare     export interface ImageMapTypeOptions {
        alt?: string,
            getTileUrl(tileCoord: Point, zoom: number): string,
            maxZoom?: number,
            minZoom?: number,
            name?: string,
            opacity?: number,
            tileSize?: Size
    }
    declare     export class StyledMapType mixins MVCObject, MapType {
        constructor(styles: MapTypeStyle[], options?: StyledMapTypeOptions): this;
        getTile(tileCoord: Point, zoom: number, ownerDocument: Document): Element;
        releaseTile(tile: Element): void
    }
    declare     export interface StyledMapTypeOptions {
        alt?: string,
            maxZoom?: number,
            minZoom?: number,
            name?: string
    }
    declare     export interface MapTypeStyle {
        elementType?: MapTypeStyleElementType,
            featureType?: MapTypeStyleFeatureType,
            stylers?: MapTypeStyler[]
    }
    declare     export interface MapTypeStyleFeatureType {
        administrative?: {
                country?: string,
                land_parcel?: string,
                locality?: string,
                neighborhood?: string,
                province?: string
            },
            all?: string,
            landscape?: {
                man_made?: string,
                natural?: {
                    landcover?: string,
                    terrain?: string
                }
            },
            poi?: {
                attraction?: string,
                business?: string,
                government?: string,
                medical?: string,
                park?: string,
                place_of_worship?: string,
                school?: string,
                sports_complex?: string
            },
            road?: {
                arterial?: string,
                highway?: {
                    controlled_access?: string
                },
                local?: string
            },
            transit?: {
                line?: string,
                station?: {
                    airport?: string,
                    bus?: string,
                    rail?: string
                }
            },
            water?: string
    }
    declare     export interface MapTypeStyleElementType {
        all?: string,
            geometry?: {
                fill?: string,
                stroke?: string
            },
            labels?: {
                icon?: string,
                text?: {
                    fill?: string,
                    stroke?: string
                }
            }
    }
    declare     export interface MapTypeStyler {
        color?: string,
            gamma?: number,
            hue?: string,
            invert_lightness?: boolean,
            lightness?: number,
            saturation?: number,
            visibility?: string,
            weight?: number
    }
    declare     export class BicyclingLayer mixins MVCObject {
        constructor(): this;
        getMap(): Map;
        setMap(map: Map): void
    }
    declare     export class FusionTablesLayer mixins MVCObject {
        constructor(options: FusionTablesLayerOptions): this;
        getMap(): Map;
        setMap(map: Map): void;
        setOptions(options: FusionTablesLayerOptions): void
    }
    declare     export interface FusionTablesLayerOptions {
        clickable?: boolean,
            heatmap?: FusionTablesHeatmap,
            map?: Map,
            query?: FusionTablesQuery,
            styles?: FusionTablesStyle[],
            suppressInfoWindows?: boolean
    }
    declare     export interface FusionTablesQuery {
        from?: string,
            limit?: number,
            offset?: number,
            orderBy?: string,
            select?: string,
            where?: string
    }
    declare     export interface FusionTablesStyle {
        markerOptions?: FusionTablesMarkerOptions,
            polygonOptions?: FusionTablesPolygonOptions,
            polylineOptions?: FusionTablesPolylineOptions,
            where?: string
    }
    declare     export interface FusionTablesHeatmap {
        enabled: boolean
    }
    declare     export interface FusionTablesMarkerOptions {
        iconName: string
    }
    declare     export interface FusionTablesPolygonOptions {
        fillColor?: string,
            fillOpacity?: number,
            strokeColor?: string,
            strokeOpacity?: number,
            strokeWeight?: number
    }
    declare     export interface FusionTablesPolylineOptions {
        strokeColor?: string,
            strokeOpacity?: number,
            strokeWeight?: number
    }
    declare     export interface FusionTablesMouseEvent {
        infoWindowHtml?: string,
            latLng?: LatLng,
            pixelOffset?: Size,
            row?: Object
    }
    declare     export interface FusionTablesCell {
        columnName?: string,
            value?: string
    }
    declare     export class KmlLayer mixins MVCObject {
        constructor(opts?: KmlLayerOptions): this;
        getDefaultViewport(): LatLngBounds;
        getMap(): Map;
        getMetadata(): KmlLayerMetadata;
        getStatus(): KmlLayerStatus;
        getUrl(): string;
        getZIndex(): number;
        setMap(map: Map): void;
        setUrl(url: string): void;
        setZIndez(zIndex: number): void
    }
    declare     export interface KmlLayerOptions {
        clickable?: boolean,
            map?: Map,
            preserveViewport?: boolean,
            screenOverlays?: boolean,
            suppressInfoWindows?: boolean,
            url?: string,
            zIndex?: number
    }
    declare     export interface KmlLayerMetadata {
        author: KmlAuthor,
            description: string,
            hasScreenOverlays: boolean,
            name: string,
            snippet: string
    }
    declare     export interface KmlMouseEvent {
        featureData: KmlFeatureData,
            latLng: LatLng,
            pixelOffset: Size
    }
    declare     export interface KmlFeatureData {
        author: KmlAuthor,
            description: string,
            id: string,
            infoWindowHtml: string,
            name: string,
            snippet: string
    }
    declare     export interface KmlAuthor {
        email: string,
            name: string,
            uri: string
    }
    declare     export class TrafficLayer mixins MVCObject {
        constructor(): this;
        getMap(): void;
        setMap(map: Map): void
    }
    declare     export class TransitLayer mixins MVCObject {
        constructor(): this;
        getMap(): void;
        setMap(map: Map): void
    }
    declare     export class StreetViewPanorama {
        constructor(container: Element, opts?: StreetViewPanoramaOptions): this;
        controls: MVCArray[];
        getLinks(): StreetViewLink[];
        getLocation(): StreetViewLocation;
        getPano(): string;
        getPhotographerPov(): StreetViewPov;
        getPosition(): LatLng;
        getPov(): StreetViewPov;
        getStatus(): StreetViewStatus;
        getVisible(): boolean;
        getZoom(): number;
        registerPanoProvider(provider: (input: string) => StreetViewPanoramaData): void;
        setLinks(links: Array<StreetViewLink>): void;
        setOptions(options: StreetViewPanoramaOptions): void;
        setPano(pano: string): void;
        setPosition(latLng: LatLng | LatLngLiteral): void;
        setPov(pov: StreetViewPov): void;
        setVisible(flag: boolean): void;
        setZoom(zoom: number): void
    }
    declare     export interface FullscreenControlOptions {
        position?: ControlPosition
    }
    declare     export interface StreetViewPanoramaOptions {
        addressControl?: boolean,
            addressControlOptions?: StreetViewAddressControlOptions,
            clickToGo?: boolean,
            disableDefaultUI?: boolean,
            disableDoubleClickZoom?: boolean,
            enableCloseButton?: boolean,
            fullscreenControl?: boolean,
            fullscreenControlOptions?: FullscreenControlOptions,
            imageDateControl?: boolean,
            linksControl?: boolean,
            mode?: "html4" | "html5" | "webgl",
            panControl?: boolean,
            panControlOptions?: PanControlOptions,
            pano?: string,
            panoProvider?: (input: string) => StreetViewPanoramaData,
            position?: LatLng | LatLngLiteral,
            pov?: StreetViewPov,
            scrollwheel?: boolean,
            visible?: boolean,
            zoom?: number,
            zoomControl?: boolean,
            zoomControlOptions?: ZoomControlOptions
    }
    declare     export interface StreetViewAddressControlOptions {
        position?: ControlPosition
    }
    declare     export interface StreetViewLink {
        description?: string,
            heading?: number,
            pano?: string
    }
    declare     export interface StreetViewPov {
        heading?: number,
            pitch?: number
    }
    declare     export interface StreetViewPanoramaData {
        copyright?: string,
            imageDate?: string,
            links?: StreetViewLink[],
            location?: StreetViewLocation,
            tiles?: StreetViewTileData
    }
    declare     export interface StreetViewLocation {
        description?: string,
            latLng?: LatLng,
            pano?: string,
            shortDescription?: string
    }
    declare     export interface StreetViewTileData {
        getTileUrl(pano: string, tileZoom: number, tileX: number, tileY: number): string,
            centerHeading?: number,
            tileSize?: Size,
            worldSize?: Size
    }
    declare     export interface StreetViewLocationRequest {
        location: LatLng | LatLngLiteral,
            preference?: StreetViewPreference,
            radius?: number,
            source?: StreetViewSource
    }
    declare     export interface StreetViewPanoRequest {
        pano: string
    }
    declare     export class StreetViewService {
        getPanorama(
            request: StreetViewLocationRequest | StreetViewPanoRequest,
            cb: (data: StreetViewPanoramaData, status: StreetViewStatus) => void): void;
        getPanoramaById(
            pano: string,
            callback: (
                streetViewPanoramaData: StreetViewPanoramaData,
                streetViewStatus: StreetViewStatus) => void): void;
        getPanoramaByLocation(
            latlng: LatLng | LatLngLiteral,
            radius: number,
            callback: (
                streetViewPanoramaData: StreetViewPanoramaData,
                streetViewStatus: StreetViewStatus) => void): void
    }
    declare     export class StreetViewCoverageLayer mixins MVCObject {
        getMap(): Map;
        setMap(map: Map): void
    }
    declare     export interface MapsEventListener {

        /**
         * Removes the listener.  Equivalent to calling google.maps.event.removeListener(listener). 
         */
        remove(): void
    }
    declare     export class event {

        /**
         * Cross browser event handler registration. This listener is removed by calling
         * removeListener(handle) for the handle that is returned by this function.
         */
        addDomListener(
            instance: Object,
            eventName: string,
            handler: Function,
            capture?: boolean): MapsEventListener;

        /**
         * Wrapper around addDomListener that removes the listener after the first event.
         */
        addDomListenerOnce(
            instance: Object,
            eventName: string,
            handler: Function,
            capture?: boolean): MapsEventListener;

        /**
         * Adds the given listener function to the given event name for the given object
         * instance. Returns an identifier for this listener that can be used with
        removeListener().
        */
        addListener(instance: Object, eventName: string, handler: Function): MapsEventListener;

        /**
         * Like addListener, but the handler removes itself after handling the first event.
         */
        addListenerOnce(instance: Object, eventName: string, handler: Function): MapsEventListener;

        /**
         * Removes all listeners for all events for the given instance.
         */
        clearInstanceListeners(instance: Object): void;

        /**
         * Removes all listeners for the given event for the given instance.
         */
        clearListeners(instance: Object, eventName: string): void;

        /**
         * Removes the given listener, which should have been returned by addListener above.
         * Equivalent to calling listener.remove().
         */
        removeListener(listener: MapsEventListener): void;

        /**
         * Triggers the given event. All arguments after eventName are passed as arguments to
         * the listeners.
         */
        trigger(instance: any, eventName: string, ...args: any[]): void
    }
    declare     export type MouseEvent = {
        feature: Data.Feature
    }

    /**
     * A LatLng is a point in geographical coordinates: latitude and longitude.
     * 
    * Latitude ranges between -90 and 90 degrees, inclusive. Values above or
       below this range will be clamped to the range [-90, 90]. This means
       that if the value specified is less than -90, it will be set to -90.
       And if the value is greater than 90, it will be set to 90.
    * Longitude ranges between -180 and 180 degrees, inclusive. Values above
       or below this range will be wrapped so that they fall within the
       range. For example, a value of -190 will be converted to 170. A value
       of 190 will be converted to -170. This reflects the fact that
       longitudes wrap around the globe.

    Although the default map projection associates longitude with the
    x-coordinate of the map, and latitude with the y-coordinate, the
    latitude coordinate is always written first, followed by the longitude.
    Notice that you cannot modify the coordinates of a LatLng. If you want
    to compute another point, you have to create a new one.
    */
    declare     export class LatLng {

        /**
         * Creates a LatLng object representing a geographic point.
         * Note the ordering of latitude and longitude.
         * @param lat Latitude is specified in degrees within the range [-90, 90].
         * @param lng Longitude is specified in degrees within the range [-180, 180].
         * @param noWrap Set noWrap to true to enable values outside of this range.
         */
        constructor(lat: number, lng: number, noWrap?: boolean): this;

        /**
         * Comparison function. 
         */
        equals(other: LatLng): boolean;

        /**
         * Returns the latitude in degrees. 
         */
        lat(): number;

        /**
         * Returns the longitude in degrees. 
         */
        lng(): number;

        /**
         * Converts to string representation. 
         */
        toString(): string;

        /**
         * Returns a string of the form "lat,lng". We round the lat/lng values to 6 decimal places by default. 
         */
        toUrlValue(precision?: number): string;

        /**
         * Converts to JSON representation. This function is intended to be used via JSON.stringify. 
         */
        toJSON(): LatLngLiteral
    }
    declare     export type LatLngLiteral = {
        lat: number,
        lng: number
    };
    declare     export type LatLngBoundsLiteral = {
        east: number,
        north: number,
        south: number,
        west: number
    };
    declare     export class LatLngBounds {
        constructor(sw?: LatLng | LatLngLiteral, ne?: LatLng | LatLngLiteral): this;
        contains(latLng: LatLng): boolean;
        equals(other: LatLngBounds | LatLngBoundsLiteral): boolean;
        extend(point: LatLng): LatLngBounds;
        getCenter(): LatLng;
        getNorthEast(): LatLng;
        getSouthWest(): LatLng;
        intersects(other: LatLngBounds | LatLngBoundsLiteral): boolean;
        isEmpty(): boolean;
        toSpan(): LatLng;
        toString(): string;
        toUrlValue(precision?: number): string;
        union(other: LatLngBounds | LatLngBoundsLiteral): LatLngBounds
    }
    declare     export class Point {

        /**
         * A point on a two-dimensional plane. 
         */
        constructor(x: number, y: number): this;

        /**
         * The X coordinate 
         */
        x: number;

        /**
         * The Y coordinate 
         */
        y: number;

        /**
         * Compares two Points 
         */
        equals(other: Point): boolean;

        /**
         * Returns a string representation of this Point. 
         */
        toString(): string
    }
    declare     export class Size {
        constructor(width: number, height: number, widthUnit?: string, heightUnit?: string): this;
        height: number;
        width: number;
        equals(other: Size): boolean;
        toString(): string
    }
    declare     export class MVCObject {
        constructor(): this;
        addListener(eventName: string, handler: (...args: any[]) => void): MapsEventListener;
        bindTo(key: string, target: MVCObject, targetKey?: string, noNotify?: boolean): void;
        changed(key: string): void;
        get(key: string): any;
        notify(key: string): void;
        set(key: string, value: any): void;
        setValues(values: any): void;
        unbind(key: string): void;
        unbindAll(): void
    }
    declare     export class MVCArray mixins MVCObject {
        constructor(array?: any[]): this;
        clear(): void;
        forEach(callback: (elem: any, i: number) => void): void;
        getArray(): any[];
        getAt(i: number): any;
        getLength(): number;
        insertAt(i: number, elem: any): void;
        pop(): any;
        push(elem: any): number;
        removeAt(i: number): any;
        setAt(i: number, elem: any): void
    }
    declare module 'geometry' {
        declare         export class encoding {
            decodePath(encodedPath: string): LatLng[];
            encodePath(path: any[]): string
        }

        /**
         * Utility functions for computing geodesic angles, distances and areas.
         * The default radius is Earth's radius of 6378137 meters.
         */
        declare         export class spherical {

            /**
             * Returns the area of a closed path.
             * The computed area uses the same units as the radius.
            The radius defaults to the Earth's radius in meters,
            in which case the area is in square meters.
            */
            computeArea(path: any[], radius?: number): number;

            /**
             * Returns the distance, in meters, between two LatLngs.
             * You can optionally specify a custom radius.
            The radius defaults to the radius of the Earth.
            */
            computeDistanceBetween(from: LatLng, to: LatLng, radius?: number): number;

            /**
             * Returns the heading from one LatLng to another LatLng.
             * Headings are expressed in degrees clockwise from North within the range [-180,180).
             */
            computeHeading(from: LatLng, to: LatLng): number;

            /**
             * Returns the length of the given path.
             */
            computeLength(path: any[], radius?: number): number;

            /**
             * Returns the LatLng resulting from moving a distance from an origin in the
             * specified heading (expressed in degrees clockwise from north).
             */
            computeOffset(from: LatLng, distance: number, heading: number, radius?: number): LatLng;

            /**
             * Returns the location of origin when provided with a LatLng destination, meters
             * travelled and original heading. Headings are expressed in degrees clockwise from
            North. This function returns null when no solution is available.
            */
            computeOffsetOrigin(to: LatLng, distance: number, heading: number, radius?: number): LatLng;

            /**
             * Returns the signed area of a closed path. The signed area may be used to determine
             * the orientation of the path. The computed area uses the same units as the radius.
            The radius defaults to the Earth's radius in meters, in which case the area is in
            square meters.
            */
            computeSignedArea(loop: any[], radius?: number): number;

            /**
             * Returns the LatLng which lies the given fraction of the way between the origin
             * LatLng and the destination LatLng.
             */
            interpolate(from: LatLng, to: LatLng, fraction: number): LatLng
        }
        declare         export class poly {
            containsLocation(point: LatLng, polygon: Polygon): boolean;
            isLocationOnEdge(point: LatLng, poly: Polygon | Polyline, tolerance?: number): boolean
        }
    }

    declare module 'adsense' {
        declare         export class AdUnit mixins MVCObject {
            constructor(container: Element, opts: AdUnitOptions): this;
            getBackgroundColor(): string;
            getBorderColor(): string;
            getChannelNumber(): string;
            getContainer(): Element;
            getFormat(): AdFormat;
            getMap(): Map;
            getPosition(): ControlPosition;
            getPublisherId(): string;
            getTextColor(): string;
            getTitleColor(): string;
            getUrlColor(): string;
            setBackgroundColor(backgroundColor: string): void;
            setBorderColor(borderColor: string): void;
            setChannelNumber(channelNumber: string): void;
            setFormat(format: AdFormat): void;
            setMap(map: Map): void;
            setPosition(position: ControlPosition): void;
            setTextColor(textColor: string): void;
            setTitleColor(titleColor: string): void;
            setUrlColor(urlColor: string): void
        }
        declare         export interface AdUnitOptions {
            backgroundColor?: string,
                borderColor?: string,
                channelNumber?: string,
                format?: AdFormat,
                map?: Map,
                position?: ControlPosition,
                publisherId?: string,
                textColor?: string,
                titleColor?: string,
                urlColor?: string
        }
    }

    declare module 'places' {
        declare         export class Autocomplete mixins MVCObject {
            constructor(inputField: HTMLInputElement, opts?: AutocompleteOptions): this;
            getBounds(): LatLngBounds;
            getPlace(): PlaceResult;
            setBounds(bounds: LatLngBounds): void;
            setComponentRestrictions(restrictions: ComponentRestrictions): void;
            setTypes(types: string[]): void
        }
        declare         export interface AutocompleteOptions {
            bounds?: LatLngBounds,
                componentRestrictions?: ComponentRestrictions,
                types?: string[]
        }
        declare         export interface AutocompletePrediction {
            description: string,
                matched_substrings: PredictionSubstring[],
                place_id: string,
                terms: PredictionTerm[],
                types: string[]
        }
        declare         export interface PredictionTerm {
            offset: number,
                value: string
        }
        declare         export interface PredictionSubstring {
            length: number,
                offset: number
        }
        declare         export class AutocompleteService {
            constructor(): this;
            getPlacePredictions(
                request: AutocompletionRequest,
                callback: (result: AutocompletePrediction[], status: PlacesServiceStatus) => void): void;
            getQueryPredictions(
                request: QueryAutocompletionRequest,
                callback: (result: QueryAutocompletePrediction[], status: PlacesServiceStatus) => void): void
        }
        declare         export interface AutocompletionRequest {
            bounds?: LatLngBounds,
                componentRestrictions?: ComponentRestrictions,
                input: string,
                location?: LatLng,
                offset?: number,
                radius?: number,
                types?: string[]
        }
        declare         export interface ComponentRestrictions {
            country: string
        }
        declare         export interface PlaceAspectRating {
            rating: number,
                type: string
        }
        declare         export interface PlaceDetailsRequest {
            placeId: string
        }
        declare         export interface PlaceGeometry {
            location: LatLng,
                viewport: LatLngBounds
        }
        declare         export interface PlacePhoto {
            height: number,
                html_attributions: string[],
                width: number,
                getUrl(opts: PhotoOptions): string
        }
        declare         export interface PhotoOptions {
            maxHeight?: number,
                maxWidth?: number
        }
        declare         export interface PlaceResult {
            address_components: GeocoderAddressComponent[],
                aspects: PlaceAspectRating[],
                formatted_address: string,
                formatted_phone_number: string,
                geometry: PlaceGeometry,
                html_attributions: string[],
                icon: string,
                international_phone_number: string,
                name: string,
                permanently_closed: boolean,
                photos: PlacePhoto[],
                place_id: string,
                price_level: number,
                rating: number,
                reviews: PlaceReview[],
                types: string[],
                url: string,
                vicinity: string,
                website: string
        }
        declare         export interface PlaceReview {
            aspects: PlaceAspectRating[],
                author_name: string,
                author_url: string,
                language: string,
                text: string
        }
        declare         export interface PlaceSearchPagination {
            nextPage(): void,
                hasNextPage: boolean
        }
        declare         export interface PlaceSearchRequest {
            bounds?: LatLngBounds,
                keyword?: string,
                location?: LatLng | LatLngLiteral,
                maxPriceLevel?: number,
                minPriceLevel?: number,
                name?: string,
                openNow?: boolean,
                radius?: number,
                rankBy?: RankBy,
                types?: string[],
                type?: string
        }
        declare         export class PlacesService {
            constructor(attrContainer: HTMLDivElement | Map): this;
            getDetails(
                request: PlaceDetailsRequest,
                callback: (result: PlaceResult, status: PlacesServiceStatus) => void): void;
            nearbySearch(
                request: PlaceSearchRequest,
                callback: (
                    results: PlaceResult[],
                    status: PlacesServiceStatus,
                    pagination: PlaceSearchPagination) => void): void;
            radarSearch(
                request: RadarSearchRequest,
                callback: (results: PlaceResult[], status: PlacesServiceStatus) => void): void;
            textSearch(
                request: TextSearchRequest,
                callback: (results: PlaceResult[], status: PlacesServiceStatus) => void): void
        }
        declare         export interface QueryAutocompletePrediction {
            description: string,
                matched_substrings: PredictionSubstring[],
                place_id: string,
                terms: PredictionTerm[]
        }
        declare         export interface QueryAutocompletionRequest {
            bounds?: LatLngBounds,
                input?: string,
                location?: LatLng,
                offset?: number,
                radius?: number
        }
        declare         export interface RadarSearchRequest {
            bounds?: LatLngBounds,
                keyword?: string,
                location?: LatLng | LatLngLiteral,
                name?: string,
                radius?: number,
                types?: string[],
                type?: string
        }
        declare         export class SearchBox mixins MVCObject {
            constructor(inputField: HTMLInputElement, opts?: SearchBoxOptions): this;
            getBounds(): LatLngBounds;
            getPlaces(): PlaceResult[];
            setBounds(bounds: LatLngBounds): void
        }
        declare         export interface SearchBoxOptions {
            bounds: LatLngBounds
        }
        declare         export interface TextSearchRequest {
            bounds?: LatLngBounds,
                location?: LatLng | LatLngLiteral,
                query: string,
                radius?: number,
                types?: string[],
                type?: string
        }
    }

    declare module 'drawing' {
        declare         export class DrawingManager mixins MVCObject {
            constructor(options?: DrawingManagerOptions): this;
            getDrawingMode(): OverlayType;
            getMap(): Map;
            setDrawingMode(drawingMode: OverlayType): void;
            setMap(map: Map): void;
            setOptions(options: DrawingManagerOptions): void
        }
        declare         export interface DrawingManagerOptions {
            circleOptions?: CircleOptions,
                drawingControl?: boolean,
                drawingControlOptions?: DrawingControlOptions,
                drawingMode?: OverlayType,
                map?: Map,
                markerOptions?: MarkerOptions,
                polygonOptions?: PolygonOptions,
                polylineOptions?: PolylineOptions,
                rectangleOptions?: RectangleOptions
        }
        declare         export interface DrawingControlOptions {
            drawingModes?: OverlayType[],
                position?: ControlPosition
        }
        declare         export interface OverlayCompleteEvent {
            overlay: Marker |
                Polygon |
                Polyline |
                Rectangle |
                Circle,
                type: OverlayType
        }
    }

    declare module 'visualization' {
        declare         export class MapsEngineLayer mixins MVCObject {
            constructor(options: MapsEngineLayerOptions): this;
            getLayerId(): string;
            getLayerKey(): string;
            getMap(): Map;
            getMapId(): string;
            getOpacity(): number;
            getProperties(): MapsEngineLayerProperties;
            getStatus(): MapsEngineStatus;
            getZIndex(): number;
            setLayerId(layerId: string): void;
            setLayerKey(layerKey: string): void;
            setMap(map: Map): void;
            setMapId(mapId: string): void;
            setOpacity(opacity: number): void;
            setOptions(options: MapsEngineLayerOptions): void;
            setZIndex(zIndex: number): void
        }
        declare         export interface MapsEngineLayerOptions {
            accessToken?: string,
                clickable?: boolean,
                fitBounds?: boolean,
                layerId?: string,
                layerKey?: string,
                map?: Map,
                mapId?: string,
                opacity?: number,
                suppressInfoWindows?: boolean,
                zIndex?: number
        }
        declare         export interface MapsEngineLayerProperties {
            name: string
        }
        declare         export interface MapsEngineMouseEvent {
            featureId?: string,
                infoWindowHtml?: string,
                latLng?: LatLng,
                pixelOffset?: Size
        }
        declare         export class HeatmapLayer mixins MVCObject {
            constructor(opts?: HeatmapLayerOptions): this;
            getData(): MVCArray;
            getMap(): Map;
            setData(data: MVCArray): void;
            setData(data: LatLng[]): void;
            setData(data: WeightedLocation[]): void;
            setMap(map: Map): void
        }
        declare         export interface HeatmapLayerOptions {
            data: any,
                dissipating?: boolean,
                gradient?: string[],
                map?: Map,
                maxIntensity?: number,
                opacity?: number,
                radius?: number
        }
        declare         export interface WeightedLocation {
            location: LatLng,
                weight: number
        }
        declare         export class MouseEvent {
            stop(): void
        }
        declare         export class MapsEventListener {}
    }

}