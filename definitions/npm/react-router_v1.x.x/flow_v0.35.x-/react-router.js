// @flow
/**
 * Flowtype definitions for react-router
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$ReactRouter: {
    createMemoryHistory: typeof ReactRouter$createMemoryHistory,
    applyRouterMiddleware: typeof ReactRouter$applyRouterMiddleware,
    withRouter: typeof ReactRouter$withRouter,
    useRoutes: typeof ReactRouter$useRoutes,
    createRoutes: typeof ReactRouter$createRoutes,
    match: typeof ReactRouter$match,
}
declare type ReactRouter$Component = React.ReactType;

declare type ReactRouter$EnterHook = (
    nextState: ReactRouter$RouterState,
    replace: ReactRouter$RedirectFunction,
    callback?: Function) => void;

declare type ReactRouter$LeaveHook = () => void;

declare type ReactRouter$ChangeHook = (
    prevState: ReactRouter$RouterState,
    nextState: ReactRouter$RouterState,
    replace: ReactRouter$RedirectFunction,
    callback: Function) => void;

declare type ReactRouter$Params = {
    [param: string]: string
};

declare type ReactRouter$ParseQueryString = (queryString: H.QueryString) => H.Query;

declare interface ReactRouter$RedirectFunction {
    (location: H.LocationDescriptor): void,

    /**
     * 
     * @deprecated  `replaceState(state, pathname, query) is deprecated; Use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated
     */
    (state: H.LocationState, pathname: H.Pathname | H.Path, query?: H.Query): void
}

declare type ReactRouter$RouteComponent = ReactRouter$Component;

declare interface ReactRouter$RouteComponentProps<P, R>{
    history?: ReactRouter$History,
    location?: H.Location,
    params?: P,
    route?: ReactRouter$PlainRoute,
    routeParams?: R,
    routes?: ReactRouter$PlainRoute[],
    children?: React.ReactElement<any >
}

declare type ReactRouter$RouteComponents = {
    [key: string]: ReactRouter$RouteComponent
};

declare type ReactRouter$RouteConfig = React.ReactNode | ReactRouter$PlainRoute | ReactRouter$PlainRoute[];

declare type ReactRouter$RouteHook = (nextLocation?: H.Location) => any;

declare type ReactRouter$RoutePattern = string;

declare type ReactRouter$StringifyQuery = (queryObject: H.Query) => H.QueryString;

declare type ReactRouter$RouterListener = (error: Error, nextState: ReactRouter$RouterState) => void;

declare interface ReactRouter$RouterState {
    location: H.Location,
        routes: ReactRouter$PlainRoute[],
        params: ReactRouter$Params,
        components: ReactRouter$RouteComponent[]
}

declare type ReactRouter$HistoryBase = {
    routes: ReactRouter$PlainRoute[],
    parseQueryString?: ReactRouter$ParseQueryString,
    stringifyQuery?: ReactRouter$StringifyQuery
}

declare type ReactRouter$History = ReactRouter$HistoryBase & H.HistoryQueries & ReactRouter$HistoryRoutes;

declare var browserHistory: ReactRouter$History;

declare var hashHistory: ReactRouter$History;

declare function ReactRouter$createMemoryHistory(options?: H.HistoryOptions): H.History

declare interface ReactRouter$Middleware {
    renderRouterContext: (previous: React.Props<{}>[], props: React.Props<{}>) => React.Props<{}>[],
        renderRouteComponent: (previous: React.Props<{}>[], props: React.Props<{}>) => React.Props<{}>[]
}

declare function ReactRouter$applyRouterMiddleware(
    ...middlewares: ReactRouter$Middleware[]): (renderProps: React.Props<{}>) => React.Props<{}>[]

declare type ReactRouter$RouterProps = {
    history?: H.History,
    routes?: ReactRouter$RouteConfig,
    createElement?: (component: ReactRouter$RouteComponent, props: Object) => any,
    onError?: (error: any) => any,
    onUpdate?: () => any,
    parseQueryString?: ReactRouter$ParseQueryString,
    render?: (renderProps: React.Props<{}>) => React.Props<{}>[],
    stringifyQuery?: ReactRouter$StringifyQuery
}

declare type ReactRouter$Router = {}

declare type ReactRouter$RouterElement = {}

declare var Router: ReactRouter$Router;

declare type ReactRouter$LinkProps = {
        activeStyle?: React.CSSProperties,
        activeClassName?: string,
        onlyActiveOnIndex?: boolean,
        to: ReactRouter$RoutePattern | H.LocationDescriptor,
        query?: H.Query,
        state?: H.LocationState
    } & &


    declare type ReactRouter$Link = {}

declare type ReactRouter$LinkElement = {}

declare var Link: ReactRouter$Link;

declare var IndexLink: ReactRouter$Link;

declare type ReactRouter$RouterContextProps = {
    history?: H.History,
    router: ReactRouter$Router,
    createElement: (component: ReactRouter$RouteComponent, props: Object) => any,
    location: H.Location,
    routes: ReactRouter$RouteConfig,
    params: ReactRouter$Params,
    components?: ReactRouter$RouteComponent[]
}

declare type ReactRouter$RouterContext = {}

declare type ReactRouter$RouterContextElement = {
    history?: H.History,
    location: H.Location,
    router?: ReactRouter$Router
}

declare var RouterContext: ReactRouter$RouterContext;

declare type ReactRouter$RouteProps = {
    path?: ReactRouter$RoutePattern,
    component?: ReactRouter$RouteComponent,
    components?: ReactRouter$RouteComponents,
    getComponent?: (
        nextState: ReactRouter$RouterState,
        cb: (error: any, component?: ReactRouter$RouteComponent) => void) => void,
    getComponents?: (
        nextState: ReactRouter$RouterState,
        cb: (error: any, components?: ReactRouter$RouteComponents) => void) => void,
    onEnter?: ReactRouter$EnterHook,
    onLeave?: ReactRouter$LeaveHook,
    onChange?: ReactRouter$ChangeHook,
    getIndexRoute?: (
        location: H.Location,
        cb: (error: any, indexRoute: ReactRouter$RouteConfig) => void) => void,
    getChildRoutes?: (
        location: H.Location,
        cb: (error: any, childRoutes: ReactRouter$RouteConfig) => void) => void
}

declare type ReactRouter$Route = {}

declare type ReactRouter$RouteElement = {}

declare var Route: ReactRouter$Route;

declare interface ReactRouter$PlainRoute {
    path?: ReactRouter$RoutePattern,
        component?: ReactRouter$RouteComponent,
        components?: ReactRouter$RouteComponents,
        getComponent?: (
            nextState: ReactRouter$RouterState,
            cb: (error: any, component?: ReactRouter$RouteComponent) => void) => void,
        getComponents?: (
            nextState: ReactRouter$RouterState,
            cb: (error: any, components?: ReactRouter$RouteComponents) => void) => void,
        onEnter?: ReactRouter$EnterHook,
        onLeave?: ReactRouter$LeaveHook,
        indexRoute?: ReactRouter$PlainRoute,
        getIndexRoute?: (
            location: H.Location,
            cb: (error: any, indexRoute: ReactRouter$RouteConfig) => void) => void,
        childRoutes?: ReactRouter$PlainRoute[],
        getChildRoutes?: (
            location: H.Location,
            cb: (error: any, childRoutes: ReactRouter$RouteConfig) => void) => void
}

declare type ReactRouter$RedirectProps = {
    path?: ReactRouter$RoutePattern,
    from?: ReactRouter$RoutePattern,
    to: ReactRouter$RoutePattern,
    query?: H.Query,
    state?: H.LocationState
}

declare type ReactRouter$Redirect = {}

declare type ReactRouter$RedirectElement = {}

declare var Redirect: ReactRouter$Redirect;

declare type ReactRouter$IndexRouteProps = {
    component?: ReactRouter$RouteComponent,
    components?: ReactRouter$RouteComponents,
    getComponent?: (
        nextState: ReactRouter$RouterState,
        cb: (error: any, component?: ReactRouter$RouteComponent) => void) => void,
    getComponents?: (
        nextState: ReactRouter$RouterState,
        cb: (error: any, components?: ReactRouter$RouteComponents) => void) => void,
    onEnter?: ReactRouter$EnterHook,
    onLeave?: ReactRouter$LeaveHook
}

declare type ReactRouter$IndexRoute = {}

declare type ReactRouter$IndexRouteElement = {}

declare var IndexRoute: ReactRouter$IndexRoute;

declare type ReactRouter$IndexRedirectProps = {
    to: ReactRouter$RoutePattern,
    query?: H.Query,
    state?: H.LocationState
}

declare type ReactRouter$IndexRedirect = {}

declare type ReactRouter$IndexRedirectElement = {}

declare var IndexRedirect: ReactRouter$IndexRedirect;

declare type ReactRouter$RouterOnContext = {
    setRouteLeaveHook(route: ReactRouter$PlainRoute, hook?: ReactRouter$RouteHook): () => void,
    isActive(pathOrLoc: H.LocationDescriptor, indexOnly?: boolean): boolean
}

declare interface ReactRouter$HistoryMixin {
    history: ReactRouter$History
}

declare var History: React.Mixin<any, any>;

declare interface ReactRouter$LifecycleMixin {
    routerWillLeave(nextLocation: H.Location): string | boolean
}

declare var Lifecycle: React.Mixin<any, any>;

declare var RouteContext: React.Mixin<any, any>;

declare interface ReactRouter$InjectedRouter {
    push: (pathOrLoc: H.LocationDescriptor) => void,
        replace: (pathOrLoc: H.LocationDescriptor) => void,
        go: (n: number) => void,
        goBack: () => void,
        goForward: () => void,
        setRouteLeaveHook(route: ReactRouter$PlainRoute, callback: ReactRouter$RouteHook): void,
        createPath(path: H.Path, query?: H.Query): H.Path,
        createHref(path: H.Path, query?: H.Query): H.Href,
        isActive: (pathOrLoc: H.LocationDescriptor, indexOnly?: boolean) => boolean
}

declare function ReactRouter$withRouter<C>(component: C): C

declare interface ReactRouter$HistoryRoutes {
    listen(listener: ReactRouter$RouterListener): Function,
        listenBeforeLeavingRoute(route: ReactRouter$PlainRoute, hook: ReactRouter$RouteHook): void,
        match(
            location: H.Location,
            callback: (
                error: any,
                nextState: ReactRouter$RouterState,
                nextLocation: H.Location) => void): void,
        isActive(pathname: H.Pathname, query?: H.Query, indexOnly?: boolean): boolean,
        setRouteLeaveHook(route: ReactRouter$PlainRoute, callback: ReactRouter$RouteHook): void
}

declare function ReactRouter$useRoutes<T>(
        createHistory: HistoryModule.CreateHistory<T>): HistoryModule.CreateHistory<T & ReactRouter$HistoryRoutes >

    declare function ReactRouter$createRoutes(routes: ReactRouter$RouteConfig): ReactRouter$PlainRoute[]

declare interface ReactRouter$MatchArgs {
    routes?: ReactRouter$RouteConfig,
        history?: H.History,
        location?: H.Location | string,
        parseQueryString?: ReactRouter$ParseQueryString,
        stringifyQuery?: ReactRouter$StringifyQuery,
        basename?: string
}

declare type ReactRouter$MatchState = {
    history: ReactRouter$History,
    router: ReactRouter$Router,
    createElement: (component: ReactRouter$RouteComponent, props: Object) => any
} & ReactRouter$RouterState


declare function ReactRouter$match(
    args: ReactRouter$MatchArgs,
    cb: (
        error: any,
        nextLocation: H.Location,
        nextState: ReactRouter$MatchState) => void): voiddeclare module 'react-router/lib/Router' {
    declare module.exports: typeof ReactRouter$Router
}
declare module 'react-router/lib/Link' {
    declare module.exports: typeof ReactRouter$Link
}
declare module 'react-router/lib/IndexLink' {
    declare module.exports: typeof ReactRouter$IndexLink
}
declare module 'react-router/lib/IndexRedirect' {
    declare module.exports: typeof ReactRouter$IndexRedirect
}
declare module 'react-router/lib/IndexRoute' {
    declare module.exports: typeof ReactRouter$IndexRoute
}
declare module 'react-router/lib/Redirect' {
    declare module.exports: typeof ReactRouter$Redirect
}
declare module 'react-router/lib/Route' {
    declare module.exports: typeof ReactRouter$Route
}
declare module 'react-router/lib/History' {
    declare module.exports: typeof ReactRouter$History
}
declare module 'react-router/lib/Lifecycle' {
    declare module.exports: typeof ReactRouter$Lifecycle
}
declare module 'react-router/lib/RouteContext' {
    declare module.exports: typeof ReactRouter$RouteContext
}
declare module 'react-router/lib/useRoutes' {
    declare module.exports: typeof ReactRouter$useRoutes
}
declare module 'react-router/lib/PatternUtils' {
    declare     export function formatPattern(pattern: string, params: {}): string
}
declare module 'react-router/lib/RouteUtils' {
    declare type E = ___React.ReactElement<any>;
    declare     export function isReactChildren(object: E | E[]): boolean
    declare     export function createRouteFromReactElement(element: E): ReactRouter$PlainRoute
    declare     export function createRoutesFromReactChildren(
        children: E | E[],
        parentRoute: ReactRouter$PlainRoute): ReactRouter$PlainRoute[]
}
declare module 'react-router/lib/RouterContext' {
    declare module.exports: typeof ReactRouter$RouterContext
}
declare module 'react-router/lib/PropTypes' {
    declare     export function falsy(props: any, propName: string, componentName: string): Error
    declare     export var history: React.Requireable<any>;
    declare     export var location: React.Requireable<any>;
    declare     export var component: React.Requireable<any>;
    declare     export var components: React.Requireable<any>;
    declare     export var route: React.Requireable<any>;
    declare     export var routes: React.Requireable<any>;
    declare     export var routerShape: React.Requireable<any>;
    declare     export var locationShape: React.Requireable<any>;
    declare module.exports: typeof NO PRINT IMPLEMENTED: ObjectLiteralExpression
}
declare module 'react-router/lib/browserHistory' {
    declare module.exports: typeof ReactRouter$browserHistory
}
declare module 'react-router/lib/hashHistory' {
    declare module.exports: typeof ReactRouter$hashHistory
}
declare module 'react-router/lib/match' {
    declare module.exports: typeof ReactRouter$match
}
declare module 'react-router/lib/useRouterHistory' {
    declare interface CreateRouterHistory {
        (options?: HistoryModule.HistoryOptions): HistoryModule.History & HistoryModule.HistoryQueries
    }
    declare     export default function useRouterHistory<T>(createHistory: HistoryModule.CreateHistory<T>): CreateRouterHistory
}
declare module 'react-router/lib/createMemoryHistory' {
    declare module.exports: typeof ReactRouter$createMemoryHistory
}
declare module 'react-router/lib/withRouter' {
    declare module.exports: typeof ReactRouter$withRouter
}
declare module 'react-router/lib/applyRouterMiddleware' {
    declare module.exports: typeof ReactRouter$applyRouterMiddleware
}
declare module 'react-router' {






















    declare interface PlainRoute {
        path?: ReactRouter$RoutePattern,
            component?: ReactRouter$RouteComponent,
            components?: ReactRouter$RouteComponents,
            getComponent?: (
                nextState: ReactRouter$RouterState,
                cb: (error: any, component?: ReactRouter$RouteComponent) => void) => void,
            getComponents?: (
                nextState: ReactRouter$RouterState,
                cb: (error: any, components?: ReactRouter$RouteComponents) => void) => void,
            onEnter?: ReactRouter$EnterHook,
            onLeave?: ReactRouter$LeaveHook,
            indexRoute?: ReactRouter$PlainRoute,
            getIndexRoute?: (
                location: H.Location,
                cb: (error: any, indexRoute: ReactRouter$RouteConfig) => void) => void,
            childRoutes?: ReactRouter$PlainRoute[],
            getChildRoutes?: (
                location: H.Location,
                cb: (error: any, childRoutes: ReactRouter$RouteConfig) => void) => void
    }
    declare type EnterHook = (
        nextState: ReactRouter$RouterState,
        replace: ReactRouter$RedirectFunction,
        callback?: Function) => void;
    declare type LeaveHook = () => void;
    declare type ParseQueryString = (queryString: H.QueryString) => H.Query;
    declare interface RedirectFunction {
        (location: H.LocationDescriptor): void,

        /**
         * 
         * @deprecated  `replaceState(state, pathname, query) is deprecated; Use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated
         */
        (state: H.LocationState, pathname: H.Pathname | H.Path, query?: H.Query): void
    }
    declare interface RouteComponentProps<P, R>{
        history?: ReactRouter$History,
        location?: H.Location,
        params?: P,
        route?: ReactRouter$PlainRoute,
        routeParams?: R,
        routes?: ReactRouter$PlainRoute[],
        children?: React.ReactElement<any >
    }
    declare type RouteHook = (nextLocation?: H.Location) => any;
    declare type StringifyQuery = (queryObject: H.Query) => H.QueryString;
    declare type RouterListener = (error: Error, nextState: ReactRouter$RouterState) => void;
    declare interface RouterState {
        location: H.Location,
            routes: ReactRouter$PlainRoute[],
            params: ReactRouter$Params,
            components: ReactRouter$RouteComponent[]
    }
    declare type HistoryBase = {
        routes: ReactRouter$PlainRoute[],
        parseQueryString?: ReactRouter$ParseQueryString,
        stringifyQuery?: ReactRouter$StringifyQuery
    }
    declare type RouterOnContext = {
        setRouteLeaveHook(route: ReactRouter$PlainRoute, hook?: ReactRouter$RouteHook): () => void,
        isActive(pathOrLoc: H.LocationDescriptor, indexOnly?: boolean): boolean
    }
    declare type RouteProps = {
        path?: ReactRouter$RoutePattern,
        component?: ReactRouter$RouteComponent,
        components?: ReactRouter$RouteComponents,
        getComponent?: (
            nextState: ReactRouter$RouterState,
            cb: (error: any, component?: ReactRouter$RouteComponent) => void) => void,
        getComponents?: (
            nextState: ReactRouter$RouterState,
            cb: (error: any, components?: ReactRouter$RouteComponents) => void) => void,
        onEnter?: ReactRouter$EnterHook,
        onLeave?: ReactRouter$LeaveHook,
        onChange?: ReactRouter$ChangeHook,
        getIndexRoute?: (
            location: H.Location,
            cb: (error: any, indexRoute: ReactRouter$RouteConfig) => void) => void,
        getChildRoutes?: (
            location: H.Location,
            cb: (error: any, childRoutes: ReactRouter$RouteConfig) => void) => void
    }
    declare module.exports: typeof Router
}