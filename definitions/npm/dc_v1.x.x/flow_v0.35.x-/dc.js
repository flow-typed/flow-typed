// @flow
/**
 * Flowtype definitions for dc
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export interface DC$IGetSet<T, V>{
    (): T,
    (t: T): V
}

declare export interface DC$IBiGetSet<T, R, V>{
    (): T,
    (t: T, r?: R): V
}

declare export interface DC$IGetSetComputed<T, R, V>{
    (): R,
    (t: T): V
}

declare export interface DC$Scale<T>{
    (x: any): T,
    domain(values: any[]): DC$Scale<T>,
    domain(): any[],
    range(values: T[]): DC$Scale<T>,
    range(): T[]
}

declare export interface DC$Accessor<T, V>{
    (datum: T, index?: number): V
}

declare export interface DC$UnitFunction {
    (start: number, end: number, domain?: Array<any>): number | Array<any >
}

declare export interface DC$FloatPointUnits {
    precision(precision: number): DC$UnitFunction
}

declare export interface DC$Units {
    integers: DC$UnitFunction,
        ordinal: DC$UnitFunction,
        fp: DC$FloatPointUnits
}

declare export interface DC$Events {
    trigger(fn: () => void, delay?: number): void
}

declare export interface DC$Errors {
    Exception(msg: string): void,
        InvalidStateException(msg: string): void
}

declare export interface DC$Filter {
    isFiltered(value: any): boolean
}

declare export interface DC$Filters {
    RangedFilter(low: any, high: any): DC$Filter,
        TwoDimensionalFilter(arr: Array<any>): DC$Filter,
        RangedTwoDimensionalFilter(arr: Array<any>): DC$Filter
}

declare export interface DC$Logger {
    enableDebugLog: boolean,
        warn(msg: string): void,
        debug(msg: string): void,
        deprecate(fn: Function, msg: string): void
}

declare export interface DC$Printers {
    filters(filters: Array<any>): string,
        filter(filter: any): string
}

declare export interface DC$Round {
    floor(n: number): number,
        ceil(n: number): number,
        round(n: number): number
}

declare export interface DC$Utils {
    printSingleValue(filter: any): string,
        add(l: any, r: any): any,
        subtract(l: any, r: any): any,
        isNumber(n: any): boolean,
        isFloat(n: any): boolean,
        isInteger(n: any): boolean,
        isNegligible(n: any): boolean,
        clamp(n: number, min: number, max: number): number,
        uniqueId(): number,
        nameToId(name: string): string,
        appendOrSelect(parent: d3.Selection<any>, selector: string, tag: any): d3.Selection<any>,
        safeNumber(n: any): number
}

declare export interface DC$Legend {
    x: DC$IGetSet<number, number>,
        y: DC$IGetSet<number, number>,
        gap: DC$IGetSet<number, number>,
        itemHeight: DC$IGetSet<number, number>,
        horizontal: DC$IGetSet<boolean, boolean>,
        legendWidth: DC$IGetSet<number, number>,
        itemWidth: DC$IGetSet<number, number>,
        autoItemWidth: DC$IGetSet<boolean, boolean>,
        render: () => void
}

declare export interface DC$BaseMixin<T>{
    width: DC$IGetSet<number,
    T>,
    height: DC$IGetSet<number,
    T>,
    minWidth: DC$IGetSet<number,
    T>,
    minHeight: DC$IGetSet<number,
    T>,
    dimension: DC$IGetSet<any,
    T>,
    data: DC$IGetSetComputed<(group: any) => Array<any>,
    Array<any>,
    T>,
    group: DC$IGetSet<any,
    T>,
    ordering: DC$IGetSet<DC$Accessor<any,
    any>,
    T>,
    filterAll(): void,
    select(selector: d3.Selection<any>| string): d3.Selection<any>,
    selectAll(selector: d3.Selection<any>| string): d3.Selection<any>,
    anchor(
        anchor: DC$BaseMixin<any>| d3.Selection<any>| string,
        chartGroup?: string): d3.Selection<any>,
    anchorName(): string,
    svg: DC$IGetSet<d3.Selection<any>,
    d3.Selection<any >> ,
    resetSvg(): void,
    filterPrinter: DC$IGetSet<(filters: Array<any>) => string,
    T>,
    turnOnControls(): void,
    turnOffControls(): void,
    transitionDuration: DC$IGetSet<number,
    T>,
    render(): void,
    redraw(): void,
    redrawGroup(): void,
    hasFilterHandler: DC$IGetSet<(filters: Array<any>, filter: any) => boolean,
    T>,
    hasFilter(filter?: any): boolean,
    removeFilterHandler: DC$IGetSet<(filters: Array<any>) => Array<any>,
    T>,
    addFilterHandler: DC$IGetSet<(filters: Array<any>) => Array<any>,
    T>,
    resetFilterHandler: DC$IGetSet<(filters: Array<any>) => Array<any>,
    T>,
    filter: DC$IGetSet<any,
    T>,
    filters(): Array<any>,
    onClick(datum: any): void,
    filterHandler: DC$IGetSet<(dimension: any, filter: any) => any,
    T>,
    keyAccessor: DC$IGetSet<DC$Accessor<any,
    any>,
    T>,
    valueAccessor: DC$IGetSet<DC$Accessor<any,
    any>,
    T>,
    label: DC$IGetSet<DC$Accessor<any,
    string>,
    T>,
    renderLabel: DC$IGetSet<boolean,
    T>,
    title: DC$IGetSet<DC$Accessor<any,
    string>,
    T>,
    renderTitle: DC$IGetSet<boolean,
    T>,
    chartGroup: DC$IGetSet<string,
    T>,
    expireCache(): T,
    legend: DC$IGetSet<DC$Legend,
    T>,
    options(optionsObject: any): T,
    renderlet(fn: (chart: T) => any): T,
    on(event: "renderlet", fn: (chart: T, filter: any) => any): T,
    on(event: "pretransition", fn: (chart: T, filter: any) => any): T,
    on(event: "preRender", fn: (chart: T) => any): T,
    on(event: "postRender", fn: (chart: T) => any): T,
    on(event: "preRedraw", fn: (chart: T) => any): T,
    on(event: "postRedraw", fn: (chart: T) => any): T,
    on(event: "filtered", fn: (chart: T, filter: any) => any): T,
    on(event: "zoomed", fn: (chart: T, filter: any) => any): T,
    on(event: string, fn: (chart: T, ...args: any[]) => any): T
}

declare export interface DC$Margins {
    left: number,
        top: number,
        right: number,
        bottom: number
}

declare export interface DC$MarginMixin<T>{
    margins: DC$IGetSet<DC$Margins,
    T >
}

declare export interface DC$ColorMixin<T>{
    colors: DC$IGetSet<Array<string>| DC$Scale<string | d3.Color>,
    T>,
    ordinalColors(r: Array<string>): void,
    linearColors(r: Array<string>): void,
    colorAccessor: DC$IGetSet<DC$Accessor<any,
    string>,
    T>,
    colorDomain: DC$IGetSet<Array<any>,
    T>,
    calculateColorDomain(): void,
    getColor(datum: any, index?: number): string,
    colorCalculator: DC$IGetSet<DC$Accessor<any,
    string>,
    T >
}

declare export type DC$CoordinateGridMixin<T>= {
    rangeChart: DC$IGetSet<DC$BaseMixin<any>,
    T>,
    zoomScale: DC$IGetSet<Array<any>,
    T>,
    zoomOutRestrict: DC$IGetSet<boolean,
    T>,
    g: DC$IGetSet<d3.Selection<any>,
    T>,
    mouseZoomable: DC$IGetSet<boolean,
    T>,
    chartBodyG(): d3.Selection<any>,
    x: DC$IGetSet<(n: any) => any,
    T>,
    xUnits: DC$IGetSet<DC$UnitFunction,
    T>,
    xAxis: DC$IGetSet<undefined.Axis,
    T>,
    elasticX: DC$IGetSet<boolean,
    T>,
    xAxisPadding: DC$IGetSet<number,
    T>,
    xUnitCount(): number,
    useRightYAxis: DC$IGetSet<boolean,
    T>,
    isOrdinal(): boolean,
    xAxisLabel: DC$IBiGetSet<string,
    number,
    T>,
    yAxisLabel: DC$IBiGetSet<string,
    number,
    T>,
    y: DC$IGetSet<DC$Scale<number>,
    T>,
    yAxis: DC$IGetSet<undefined.Axis,
    T>,
    elasticY: DC$IGetSet<boolean,
    T>,
    renderHorizontalGridLines: DC$IGetSet<boolean,
    T>,
    renderVerticalGridLines: DC$IGetSet<boolean,
    T>,
    xAxisMin(): any,
    xAxisMax(): any,
    yAxisMin(): any,
    yAxisMax(): any,
    yAxisPadding: DC$IGetSet<number,
    T>,
    round: DC$IGetSet<(value: any) => any,
    T>,
    clipPadding: DC$IGetSet<number,
    T>,
    focus(range?: Array<any>): void,
    brushOn: DC$IGetSet<boolean,
    T >
} & DC$BaseMixin & DC$MarginMixin & DC$ColorMixin


declare export interface DC$StackMixin<T>{
    stack(group: any, name?: string, accessor?: DC$Accessor<any, any>): void,
    hidableStacks: DC$IGetSet<boolean,
    T>,
    hideStack(name: string): void,
    showStack(name: string): void,
    stackLayout: DC$IGetSet<undefined.Stack<any[],
    any>,
    T >
}

declare export interface DC$CapMixin<T>{
    cap: DC$IGetSet<number,
    T>,
    othersLabel: DC$IGetSet<string,
    T>,
    othersGrouper: DC$IGetSet<(data: Array<any>) => Array<any>,
    T >
}

declare export type DC$BubbleMixin<T>= {
    r: DC$IGetSet<DC$Scale<number>,
    T>,
    radiusValueAccessor: DC$IGetSet<DC$Accessor<any,
    number>,
    T>,
    minRadiusWithLabel: DC$IGetSet<number,
    T>,
    maxBubbleRelativeSize: DC$IGetSet<number,
    T >
} & DC$ColorMixin


declare export type DC$PieChart = {
    slicesCap: DC$IGetSet<number,
    DC$PieChart>,
    innerRadius: DC$IGetSet<number,
    DC$PieChart>,
    radius: DC$IGetSet<number,
    DC$PieChart>,
    cx: DC$IGetSet<number,
    DC$PieChart>,
    cy: DC$IGetSet<number,
    DC$PieChart>,
    minAngleForLabel: DC$IGetSet<number,
    DC$PieChart >
} & DC$CapMixin & DC$ColorMixin & DC$BaseMixin


declare export type DC$BarChart = {
    centerBar: DC$IGetSet<boolean,
    DC$BarChart>,
    barPadding: DC$IGetSet<number,
    DC$BarChart>,
    outerPadding: DC$IGetSet<number,
    DC$BarChart>,
    gap: DC$IGetSet<number,
    DC$BarChart>,
    alwaysUseRounding: DC$IGetSet<boolean,
    DC$BarChart >
} & DC$StackMixin & DC$CoordinateGridMixin


declare export interface DC$RenderDataPointOptions {
    fillOpacity: number,
        strokeOpacity: number,
        radius: number
}

declare export type DC$LineChart = {
    interpolate: DC$IGetSet<string,
    DC$LineChart>,
    tension: DC$IGetSet<number,
    DC$LineChart>,
    defined: DC$IGetSet<DC$Accessor<any,
    boolean>,
    DC$LineChart>,
    dashStyle: DC$IGetSet<Array<number>,
    DC$LineChart>,
    renderArea: DC$IGetSet<boolean,
    DC$LineChart>,
    dotRadius: DC$IGetSet<number,
    DC$LineChart>,
    renderDataPoints: DC$IGetSet<DC$RenderDataPointOptions | any,
    DC$LineChart >
} & DC$StackMixin & DC$CoordinateGridMixin


declare export interface DC$DataCountWidgetHTML {
    all: string,
        some: string
}

declare export type DC$DataCountWidget = {
    html: DC$IGetSet<DC$DataCountWidgetHTML,
    DC$DataCountWidget>,
    formatNumber: DC$IGetSet<DC$Accessor<number,
    string>,
    DC$DataCountWidget >
} & DC$BaseMixin


declare export type DC$DataTableWidget = {
    size: DC$IGetSet<number,
    DC$DataTableWidget>,
    columns: DC$IGetSet<Array<DC$Accessor<any,
    any>| string | Array<DC$Accessor<any,
    any>| string >> ,
    DC$DataTableWidget>,
    sortBy: DC$IGetSet<DC$Accessor<any,
    any>,
    DC$DataTableWidget>,
    order: DC$IGetSet<(a: any, b: any) => number,
    DC$DataTableWidget >
} & DC$BaseMixin


declare export type DC$DataGridWidget = {
    size: DC$IGetSet<number,
    DC$DataTableWidget>,
    html: DC$IGetSet<DC$Accessor<any,
    string>,
    DC$DataTableWidget>,
    htmlGroup: DC$IGetSet<DC$Accessor<any,
    string>,
    DC$DataTableWidget>,
    sortBy: DC$IGetSet<DC$Accessor<any,
    any>,
    DC$DataTableWidget>,
    order: DC$IGetSet<(a: any, b: any) => number,
    DC$DataTableWidget >
} & DC$BaseMixin


declare export type DC$BubbleChart = {
    elasticRadius: DC$IGetSet<boolean,
    DC$BubbleChart >
} & DC$BubbleMixin & DC$CoordinateGridMixin


declare export type DC$ICompositeChart<T>= {
    useRightAxisGridLines: DC$IGetSet<boolean,
    DC$ICompositeChart<T >> ,
    childOptions: DC$IGetSet<any,
    DC$ICompositeChart<T >> ,
    rightYAxisLabel: DC$IGetSet<string,
    DC$ICompositeChart<T >> ,
    compose: DC$IGetSet<Array<DC$BaseMixin<any >> ,
    DC$ICompositeChart<T >> ,
    children(): Array<DC$BaseMixin<any >> ,
    shareColors: DC$IGetSet<boolean,
    DC$ICompositeChart<T >> ,
    shareTitle: DC$IGetSet<boolean,
    DC$ICompositeChart<T >> ,
    rightY: DC$IGetSet<(n: any) => any,
    DC$ICompositeChart<T >> ,
    rightYAxis: DC$IGetSet<undefined.Axis,
    DC$ICompositeChart<T >>
} & DC$CoordinateGridMixin


declare export type DC$CompositeChart = {} & DC$ICompositeChart


declare export type DC$SeriesChart = {
    chart: DC$IGetSet<(c: any) => DC$BaseMixin<any>,
    DC$SeriesChart>,
    seriesAccessor: DC$IGetSet<DC$Accessor<any,
    any>,
    DC$SeriesChart>,
    seriesSort: DC$IGetSet<(a: any, b: any) => number,
    DC$SeriesChart>,
    valueSort: DC$IGetSet<(a: any, b: any) => number,
    DC$SeriesChart >
} & DC$ICompositeChart


declare export interface DC$GeoChoroplethLayer {
    name: string,
        keyAccessor: DC$Accessor<any, any>,
        data: any
}

declare export type DC$GeoChoroplethChart = {
    overlayGeoJson(json: any, name: string, keyAccessor: DC$Accessor<any, any>): void,
    projection: DC$IGetSet<undefined.Projection,
    DC$GeoChoroplethChart>,
    geoJsons(): Array<DC$GeoChoroplethLayer>,
    geoPath(): undefined.Path,
    removeGeoJson(name: string): void
} & DC$ColorMixin & DC$BaseMixin


declare export type DC$BubbleOverlayChart = {
    point(name: string, x: number, y: number): void
} & DC$BubbleMixin & DC$BaseMixin


declare export type DC$RowChart = {
    x: DC$IGetSet<DC$Scale<number>,
    DC$RowChart>,
    renderTitleLabel: DC$IGetSet<boolean,
    DC$RowChart>,
    xAxis: DC$IGetSet<undefined.Axis,
    DC$RowChart>,
    fixedBarHeight: DC$IGetSet<number,
    DC$RowChart>,
    gap: DC$IGetSet<number,
    DC$RowChart>,
    elasticX: DC$IGetSet<boolean,
    DC$RowChart>,
    labelOffsetX: DC$IGetSet<number,
    DC$RowChart>,
    labelOffsetY: DC$IGetSet<number,
    DC$RowChart>,
    titleLabelOffsetX: DC$IGetSet<number,
    DC$RowChart >
} & DC$CapMixin & DC$MarginMixin & DC$ColorMixin & DC$BaseMixin


declare export type DC$ScatterPlot = {
    existenceAccessor: DC$IGetSet<DC$Accessor<any,
    boolean>,
    DC$ScatterPlot>,
    symbol: DC$IGetSet<undefined.Symbol<any>,
    DC$ScatterPlot>,
    symbolSize: DC$IGetSet<number,
    DC$ScatterPlot>,
    highlightedSize: DC$IGetSet<number,
    DC$ScatterPlot>,
    hiddenSize: DC$IGetSet<number,
    DC$ScatterPlot >
} & DC$CoordinateGridMixin


declare export interface DC$NumberDisplayWidgetHTML {
    one: string,
        some: string,
        none: string
}

declare export type DC$NumberDisplayWidget = {
    html: DC$IGetSet<DC$NumberDisplayWidgetHTML,
    DC$NumberDisplayWidget>,
    value(): string,
    formatNumber: DC$IGetSet<DC$Accessor<number,
    string>,
    DC$NumberDisplayWidget >
} & DC$BaseMixin


declare export type DC$HeatMap = {
    colsLabel: DC$IGetSet<DC$Accessor<any,
    string>,
    DC$HeatMap>,
    rowsLabel: DC$IGetSet<DC$Accessor<any,
    string>,
    DC$HeatMap>,
    rows: DC$IGetSet<Array<any>,
    DC$HeatMap>,
    cols: DC$IGetSet<Array<any>,
    DC$HeatMap>,
    boxOnClick: DC$IGetSet<(d: any) => void,
    DC$HeatMap>,
    xAxisOnClick: DC$IGetSet<(d: any) => void,
    DC$HeatMap>,
    yAxisOnClick: DC$IGetSet<(d: any) => void,
    DC$HeatMap >
} & DC$ColorMixin & DC$MarginMixin & DC$BaseMixin


declare export type DC$BoxPlot = {
    boxPadding: DC$IGetSet<number,
    DC$BoxPlot>,
    outerPadding: DC$IGetSet<number,
    DC$BoxPlot>,
    boxWidth: DC$IGetSet<number,
    DC$BoxPlot>,
    tickFormat: DC$IGetSet<DC$Accessor<number,
    string>,
    DC$BoxPlot >
} & DC$CoordinateGridMixin


declare export interface DC$ChartRegistry {
    has(chart: DC$BaseMixin<any>): boolean,
        register(chart: DC$BaseMixin<any>, group?: string): void,
        deregister(chart: DC$BaseMixin<any>, group?: string): void,
        clear(group?: string): void,
        list(group?: string): Array<DC$BaseMixin<any >>
}

declare export interface DC$Base {
    chartRegistry: DC$ChartRegistry,
        registerChart(chart: DC$BaseMixin<any>, group?: string): void,
        deregisterChart(chart: DC$BaseMixin<any>, group?: string): void,
        hasChart(chart: DC$BaseMixin<any>): boolean,
        deregisterAllCharts(group?: string): void,
        filterAll(group?: string): void,
        refocusAll(group?: string): void,
        renderAll(group?: string): void,
        redrawAll(group?: string): void,
        disableTransitions: boolean,
        transition(
            selections: d3.Selection<any>,
            duration: number,
            callback: (s: d3.Selection<any>) => void): void,
        units: DC$Units,
        events: DC$Events,
        errors: DC$Errors,
        instanceOfChart(object: any): boolean,
        logger: DC$Logger,
        override(object: any, fnName: string, newFn: Function): void,
        printers: DC$Printers,
        pluck(n: string, f?: DC$Accessor<any, any>): DC$Accessor<any, any>,
        round: DC$Round,
        utils: DC$Utils,
        legend(): DC$Legend,
        pieChart(parent: string, chartGroup?: string): DC$PieChart,
        barChart(parent: string, chartGroup?: string): DC$BarChart,
        lineChart(parent: string, chartGroup?: string): DC$LineChart,
        dataCount(parent: string, chartGroup?: string): DC$DataCountWidget,
        dataTable(parent: string, chartGroup?: string): DC$DataTableWidget,
        dataGrid(parent: string, chartGroup?: string): DC$DataGridWidget,
        bubbleChart(parent: string, chartGroup?: string): DC$BubbleChart,
        compositeChart(parent: string, chartGroup?: string): DC$CompositeChart,
        seriesChart(parent: string, chartGroup?: string): DC$SeriesChart,
        geoChoroplethChart(parent: string, chartGroup?: string): DC$GeoChoroplethChart,
        bubbleOverlayChart(parent: string, chartGroup?: string): DC$BubbleOverlayChart,
        rowChart(parent: string, chartGroup?: string): DC$RowChart,
        scatterPlot(parent: string, chartGroup?: string): DC$ScatterPlot,
        numberDisplay(parent: string, chartGroup?: string): DC$NumberDisplayWidget,
        heatMap(parent: string, chartGroup?: string): DC$HeatMap,
        boxPlot(parent: string, chartGroup?: string): DC$BoxPlot
}
declare var dc: DC$Base;
declare module 'dc' {
    declare module.exports: typeof dc
}