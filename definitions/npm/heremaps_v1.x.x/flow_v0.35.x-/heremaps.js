/**
 * Flowtype definitions for heremaps
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'Map' {

    /**
     * It defines the number of lower and higher zoom levels, where cached content of the base map is rendered while content of the current zoom level is still loading. Example: if range was set to {lower: 3, higher: 2} and current level is 10 then rendering engine will try to display cached tiles from lower zoom levels 7, 8, 9 and higher levels 11 and 12.
     * @property  lower {number} - The number of lower zoom levels to take into account, default is 0
     * @property  higher {number} - The number of higher zoom levels to take into account, default is 0
     */
    declare export interface BackgroundRange {
        lower: number,
            higher: number
    }

    /**
     * This type defines options which can be used to initialize the map.
     * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
     * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
     * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
     * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
     * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
     * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
     * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
     * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
     * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
     * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
     * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
     * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
     */
    declare export interface Options {
        center?: undefined.IPoint,
            zoom?: number,
            bounds?: undefined.Rect,
            layers?: Array<undefined.Layer>,
            engineType?: EngineType,
            pixelRatio?: number,
            imprint?: undefined.Options,
            renderBaseBackground?: BackgroundRange,
            autoColor?: boolean,
            margin?: number,
            padding?: undefined.Padding,
            fixedCenter?: boolean
    }
}


declare module 'clustering' {

    /**
     * This class represents the input data structure for data points to be clustered.
     * @property  lat {H.geo.Latitude} - The latitude coordinate of the data point's position
     * @property  lng {H.geo.Longitude} - The longitude coordinate of the data point's position
     * @property  wt {number} - The weight of the data point
     * @property  data {*} - Data associated with this data point
     */
    declare export class DataPoint mixins undefined.IPoint {

        /**
         * Constructor
         * @param lat - The latitude coordinate of the data point's position
         * @param lng - The longitude coordinate of the data point's position
         * @param opt_weight - The weight of the data point as a positive number>0. If not specified it , default is 1.
         * @param opt_data *=} - Optional data, which will be associated with this DataPoint
         */
        constructor(lat: undefined.Latitude, lng: undefined.Longitude, opt_weight?: number, opt_data?: any): this;
        lat: undefined.Latitude;
        lng: undefined.Longitude;
        alt: undefined.Altitude;
        ctx: undefined.AltitudeContext;
        wt: number;
        data: any
    }

    /**
     * This interface describes a cluster of data points, which fulfill the clustering specification (i.e. data points are within the epsilon and there are enough points to form a cluster).
     */
    declare export interface ICluster {

        /**
         * Returns the maximum zoom level where this cluster doesn't fall apart into sub clusters and/or noise poinst
         * @returns  
         */
        getMaxZoom(): number,

            /**
             * Returns the bounding rectangle of this cluster.
             * @returns  
             */
            getBounds(): undefined.Rect,

            /**
             * Invokes the specified callback for each "entry" of the cluster. That "entry" can be either a cluster which implements H.clustering.ICluster interface or a noise point which implements H.clustering.INoisePoint interface.
             * @param callback - The callback gets the currently traversed entry as an argument, which is cluster or noise point.
             */
            forEachEntry(callback: (result: undefined.IResult) => void): void,

            /**
             * Invokes the specified callback for each data point which is part of this cluster, even indirectly.
             * @param callback - The callback gets the currently traversed noise point as argument.
             */
            forEachDataPoint(callback: (noise: undefined.INoisePoint) => void): void,

            /**
             * Returns the geographical position of this cluster result.
             * @returns  
             */
            getPosition(): undefined.Point,

            /**
             * Returns the weight of this cluster result.
             * @returns  
             */
            getWeight(): number,

            /**
             * To indicate whether this cluster result is a cluster or noise point
             * @returns  
             */
            isCluster(): boolean,

            /**
             * Returns the minimum zoom level where this item is not part of another cluster
             * @returns  
             */
            getMinZoom(): number
    }

    /**
     * This interface represents a data point which does not belong to a cluster.
     */
    declare export interface INoisePoint {

        /**
         * This method returns data which coresponds to this noise point.
         * @returns  
         */
        getData(): any,

            /**
             * Returns the geographical position of this cluster result.
             * @returns  
             */
            getPosition(): undefined.Point,

            /**
             * Returns the weight of this cluster result.
             * @returns  
             */
            getWeight(): number,

            /**
             * To indicate whether this cluster result is a cluster or noise point
             * @returns  
             */
            isCluster(): boolean,

            /**
             * Returns the minimum zoom level where this item is not part of another cluster
             * @returns  
             */
            getMinZoom(): number
    }

    /**
     * This interface represents the result item of a clustering operation.
     */
    declare export interface IResult {

        /**
         * Returns the geographical position of this cluster result.
         * @returns  
         */
        getPosition(): undefined.Point,

            /**
             * Returns the weight of this cluster result.
             * @returns  
             */
            getWeight(): number,

            /**
             * To indicate whether this cluster result is a cluster or noise point
             * @returns  
             */
            isCluster(): boolean,

            /**
             * Returns the minimum zoom level where this item is not part of another cluster
             * @returns  
             */
            getMinZoom(): number
    }

    /**
     * Interface which specifies the methods a theme must implement.
     */
    declare export interface ITheme {

        /**
         * Function returns a cluster presentation as a map object.
         * @param cluster * 
         * @returns  
         */
        getClusterPresentation(cluster: undefined.ICluster): undefined.Object,

            /**
             * Function returns noise point presentation as a map object
             * @param noisePoint * 
             * @returns  
             */
            getNoisePresentation(noisePoint: undefined.INoisePoint): undefined.Object
    }
    declare module 'Provider' {

        /**
         * Options which are used within cluster calculations.
         * @property  eps {number=} - epsilon parameter for cluster calculation. For the FASTGRID strategy it must not exceed 256 and must take values that are power of 2. For the GRID and DYNAMICGRID strategies it can take values from 10 to 127. Default is 32.
         * @property  minWeight {number=} - the minimum points weight sum to form a cluster, default is 2
         * @property  projection {H.geo.IProjection=} - projection to use for clustering, default is H.geo.mercator
         * @property  strategy {H.clustering.Provider.Strategy=} - clustering stretegy, defaults to H.clustering.Provider.Strategy.FASTGRID
         */
        declare     export interface ClusteringOptions {
            eps?: number,
                minWeight?: number,
                projection?: undefined.IProjection,
                strategy?: undefined.Strategy
        }

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

}


declare module 'data' {
    declare module 'AbstractReader' {

        /**
         * The event class for state events that are dispatched by AbstractReader
         */
        declare     export class Event mixins undefined.Event {

            /**
             * Constructor
             * @param target - The target that's passed to event listeners
             * @param type - The type of the event
             * @param state - The state of the target firing an event
             * @param message - The message associated with an event
             */
            constructor(target: (undefined.AbstractReader | undefined.Object), type: string, state: undefined.State, message: string): this
        }
    }

}


declare module 'geo' {

    /**
     * A Geographic coordinate that specifies the height of a point in meters. A value of undefined is treated as 0.
     */
    declare export type Altitude = number;

    /**
     * An interface to represent a geographic point. Every point in geo space is represented by three coordinates latitude, longitude and optional altitude.
     * @property  lat {H.geo.Latitude} - The latitude coordinate.
     * @property  lng {H.geo.Longitude} - The longitude coordinate.
     * @property  alt {H.geo.Altitude=} - The altitude coordinate.
     * @property  ctx {H.geo.AltitudeContext=} - The altitude context.
     */
    declare export interface IPoint {
        lat: undefined.Latitude,
            lng: Longitude,
            alt?: undefined.Altitude,
            ctx?: undefined.AltitudeContext
    }
    declare export interface IProjection {
        latLngToPoint(lat: number, lng: number, opt_out?: undefined.Point): undefined.Point,
            xyToGeo(x: number, y: number, opt_out?: undefined.Point): undefined.Point,
            pointToGeo(point: undefined.IPoint, opt_out?: undefined.Point): undefined.Point,
            geoToPoint(geoPoint: undefined.IPoint, opt_out?: undefined.Point): undefined.Point
    }

    /**
     * A geographic coordinate that specifies the north-south position of a point on the Earth's surface in the range from -90 to + 90 degrees, inclusive.
     */
    declare export type Latitude = number;

    /**
     * A Geographic coordinate that specifies the east-west position of a point on the Earth's surface in the range from -180 to 180 degrees, inclusive.
     */
    declare export type Longitude = number;

    /**
     * Class represents a geographical point, which is defined by the latitude, longitude and optional altitude.
     * @property  lat {H.geo.Latitude} - The latitude coordinate.
     * @property  lng {H.geo.Longitude} - The longitude coordinate.
     * @property  alt {H.geo.Altitude} - The altitude coordinate.
     * @property  ctx {H.geo.AltitudeContext} - The altitude context.
     */
    declare export class Point mixins IPoint {

        /**
         * Constructor
         * @property  lat {H.geo.Latitude} - The latitude coordinate.
         * @property  lng {H.geo.Longitude} - The longitude coordinate.
         * @property  opt_alt {H.geo.Altitude=} - The altitude coordinate.
         * @property  opt_ctx {H.geo.AltitudeContext=} - The altitude context.
         */
        constructor(lat: undefined.Latitude, lng: Longitude, opt_alt?: undefined.Altitude, opt_ctx?: undefined.AltitudeContext): this;

        /**
         * To compare this point with a supplied other point for equality. Two points are considered equal if they have the same lat and lng as well as equivalent values for alt and ctx.
         * @param other * 
         * @returns  - Whether the two points are equal.
         */
        equals(other: IPoint): boolean;

        /**
         * To calculate the distance between this point and the supplied other point. The method uses the Haversine formula. The altitude is not considered.
         * @param other * 
         * @returns  - The distance between the given location and the location supplied by the caller in meters.
         */
        distance(other: IPoint): number;

        /**
         * This method calculates the geographic point of a destination point using the distance and bearing specified by the caller. The altitude is ignored, instead the WGS84 Mean Radius is taken.
         * @param bearing - The bearing to use in the calculation in degrees.
         * @param distance - The distance to the destination in meters.
         * @param opt_overGreatCircle - If true the computation uses the 'Great Circle' otherwise 'Rhumb Line'.
         * @returns  - The calculated point
         */
        walk(bearing: number, distance: number, opt_overGreatCircle?: boolean): Point;

        /**
         * This method validates the given IPoint. It checks, if lat, lng, alt and ctx have valid types. Additionally the value of the lat property is clamped into a range of -90 ... +90 and the value of the lng property is modulo into a range of -180 ... +180 plus validates the values of the alt and ctx properties
         * @param point - The point to validate
         * @param opt_caller - The caller to use for InvalidArgumentError. If omitted no error is thrown
         * @param opt_argNr - The argument number to use for InvalidArgumentError.
         * @returns  - if the given point could validate
         */
        validate(point: IPoint, opt_caller?: Function, opt_argNr?: number): boolean;

        /**
         * This method creates a Point instance from a given IPoint object.
         * @param iPoint - The IPoint object to use
         * @returns  - the created Point instance
         */
        fromIPoint(iPoint: IPoint): Point;
        lat: undefined.Latitude;
        lng: undefined.Longitude;
        alt: undefined.Altitude;
        ctx: undefined.AltitudeContext
    }

    /**
     * This class represents a rectangular geographic area. The area is defined by four geographical coordinates two (left, right) longitudes and two (top, bottom) latitudes.
     */
    declare export class Rect {

        /**
         * Constructor
         * @param top - the northern-most latitude
         * @param left - the left-most longitude
         * @param bottom - the southern-most latitude
         * @param right - the right-most latitude
         */
        constructor(top: undefined.Latitude, left: undefined.Longitude, bottom: undefined.Latitude, right: undefined.Longitude): this;

        /**
         * To compare this rectangle with a supplied other rectangle for equality.
         * @param other * 
         * @returns  - Whether the two rectangles are equal.
         */
        equals(other: undefined.Rect): boolean;

        /**
         * Toclone this rectangle.
         * @returns  
         */
        clone(): undefined.Rect;

        /**
         * This method returns the top-left corner of the rectangular area.
         * @returns  - the top-left corner of the area
         */
        getTopLeft(): undefined.Point;

        /**
         * This method returns the bottom-right corner of the rectangular area.
         * @returns  - the bottom-right corner of the area
         */
        getBottomRight(): undefined.Point;

        /**
         * This method returns the north-most latitude of this rectangular area
         * @returns  - the north-most latitude of the area
         */
        getTop(): undefined.Latitude;

        /**
         * This method returns the south-most latitude of this rectangular area
         * @returns  - the south-most latitude of the area
         */
        getBottom(): undefined.Latitude;

        /**
         * This method returns the left-most longitude of this rectangular area
         * @returns  - the left-most longitude of the area
         */
        getLeft(): undefined.Longitude;

        /**
         * This method returns the right-most longitude of this rectangular area
         * @returns  - the right-most longitude of the area
         */
        getRight(): undefined.Longitude;

        /**
         * This method returns the center point of this rectangular area
         * @returns  - the center point of the area
         */
        getCenter(): undefined.Point;

        /**
         * Returns this width of this rectangular area in decimal degrees.
         * @returns  - the width of this area
         */
        getWidth(): number;

        /**
         * Returns this height of this rectangular area in decimal degrees.
         * @returns  - the height of this area
         */
        getHeight(): number;

        /**
         * Returns a boolean value indicating whether this rectangular area spans across the date border.
         * @returns  - true if the area spans across the date border, otherwise false
         */
        isCDB(): boolean;

        /**
         * The method checks if the area enclosed by the given bounding box is 0.
         * @returns  - true if the dimensions of the area a 0, otherwise false
         */
        isEmpty(): boolean;

        /**
         * This method checks if the latitude and longitude supplied by the caller lie within the area of this rectangular area.
         * @param lat - the latitude
         * @param lng - the longitude
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - true if the latitude and longitude are contained in this area, otherwise false
         */
        containsLatLng(
            lat: undefined.Latitude,
            lng: undefined.Longitude,
            opt_skipValidation?: boolean): boolean;

        /**
         * This method checks if the point supplied by the caller lies within the area of this rectangular area.
         * @param geoPoint - the point
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - true if the point is contained in this area, otherwise false
         */
        containsPoint(geoPoint: undefined.IPoint, opt_skipValidation?: boolean): boolean;

        /**
         * This method checks if the rectangular area supplied by the caller is completely contained within the area of this rectangular area.
         * @param geoRect - the rectangular area
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - true if the rectangular area is contained in this area, otherwise false
         */
        containsRect(geoRect: undefined.Rect, opt_skipValidation?: boolean): boolean;

        /**
         * This method returns the smallest bounding box that covers this rectangular area and the latitude and longitude supplied by the caller.
         * @param lat - the latitude
         * @param lng - the longitude
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @param opt_out - an optional rectangular area to store the result
         * @returns  - either the rectangular area passed as out parameter or a new rectangular area
         */
        mergeLatLng(
            lat: undefined.Latitude,
            lng: undefined.Longitude,
            opt_skipValidation?: boolean,
            opt_out?: undefined.Rect): undefined.Rect;

        /**
         * This method returns the smallest bounding box that covers this rectangular area and the point supplied by the caller.
         * @param geoPoint - the point to merge
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @param opt_out - an optional rectangular area to store the result
         * @returns  - either the rectangular area passed as out parameter or a new rectangular area
         */
        mergePoint(
            geoPoint: undefined.IPoint,
            opt_skipValidation?: boolean,
            opt_out?: undefined.Rect): undefined.Rect;

        /**
         * This method returns the smallest bounding box that covers this rectangular area and the rectangular area supplied by the caller.
         * @param geoRect - the point to merge
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @param opt_out - an optional rectangular area to store the result
         * @returns  - either the rectangular area passed as out parameter or a new rectangular area
         */
        mergeRect(
            geoRect: undefined.Rect,
            opt_skipValidation?: boolean,
            opt_out?: undefined.Rect): undefined.Rect;

        /**
         * This method returns the smallest bounding box that covers this rectangular area and the rectangular area supplied by the caller.
         * @param top - The top latitude of the rectangle to merge
         * @param left - The left longitude of the rectangle to merge
         * @param bottom - The bottom latitude of the rectangle to merge
         * @param right - The right longitude of the rectangle to merge
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @param opt_out - an optional rectangular area to store the result
         * @returns  - either the rectangular area passed as out parameter or a new rectangular area
         */
        mergeTopLeftBottomRight(
            top: undefined.Latitude,
            left: undefined.Longitude,
            bottom: undefined.Latitude,
            right: undefined.Longitude,
            opt_skipValidation?: boolean,
            opt_out?: undefined.Rect): undefined.Rect;

        /**
         * This method checks if the intersection of two bounding boxes is non-empty.
         * @param geoRect - a rectangular area to be tested for intersection with this rectangular area
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - a boolean value indicating whether the two areas intersect
         */
        intersects(geoRect: undefined.Rect, opt_skipValidation?: boolean): boolean;

        /**
         * This method merges two rects by their values. The result of the merge is a bounding rect which covers all provided rect bounds.
         * @param topA - the northern-most latitude
         * @param leftA - the left-most longitude of operand A
         * @param bottomA - the southern-most latitude of operand A
         * @param rightA - the right-most latitude of operand A
         * @param topB - the northern-most latitude of operand B
         * @param leftB - the left-most longitude of operand B
         * @param bottomB - the southern-most latitude of operand B
         * @param rightB - the right-most latitude of operand B
         * @param opt_out - an optional rect to store the results
         * @returns  - either the opt_out rect or a new rect
         */
        merge(
            topA: undefined.Latitude,
            leftA: undefined.Longitude,
            bottomA: undefined.Latitude,
            rightA: undefined.Longitude,
            topB: undefined.Latitude,
            leftB: undefined.Longitude,
            bottomB: undefined.Latitude,
            rightB: undefined.Longitude,
            opt_out?: undefined.Rect): undefined.Rect;

        /**
         * This method creates a rectangular area from a top-left and bottom-right point pair.
         * @param topLeft - the top-left corner of the area
         * @param bottomRight - the bottom-right corner of the area
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - returns the rectangular area defined by the top-left and bottom-right corners
         */
        fromPoints(
            topLeft: undefined.IPoint,
            bottomRight: undefined.IPoint,
            opt_skipValidation?: boolean): undefined.Rect;

        /**
         * This method creates the minimum rectangular area covering all of the points in the argument array.
         * @param pointArray - the array of points to cover
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - returns the minimum rectangular area covering the points or null if no point is covered
         */
        coverPoints(
            pointArray: Array<undefined.IPoint>,
            opt_skipValidation?: boolean): undefined.Rect;

        /**
         * This method creates the minimum rectangular area covering all of the coordinates in the argument array.
         * @param latLngAltArray - the array of coordinates to cover
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - returns the minimum rectangular area covering the coordinates
         */
        coverLatLngAlts(
            latLngAltArray: Array<number>,
            opt_skipValidation?: boolean): undefined.Rect | void;

        /**
         * This method creates the minimum rectangular area covering all of the rectangular areas in the argument array.
         * @param rectArray - the array of points to cover
         * @param opt_skipValidation - a boolean flag indicating whether to check validity of the arguments
         * @returns  - returns the minimum rectangular area covering the rectangular areas
         */
        coverRects(
            rectArray: Array<undefined.Rect>,
            opt_skipValidation?: boolean): undefined.Rect | void;

        /**
         * This method clones the given bounding rect and resizes the clone if necessary until the location supplied by the caller is at its center.
         * @param center - a point which is to be the center of the resized rectangular area
         * @param opt_out - an optional rectangular area to store the result
         * @returns  - the resized rectangular area
         */
        resizeToCenter(center: undefined.IPoint, opt_out?: undefined.Rect): undefined.Rect
    }

    /**
     * A strip is a flat list of latitude, longitude, altitude tuples in a fixed order.
     */
    declare export class Strip {

        /**
         * Constructor
         * @param opt_latLngAlts - An optional array of latitude, longitude and altitude triples to initialize the strip with.
         * @param opt_ctx - An optional altitude context for all altitudes contained in this strip.
         */
        constructor(opt_latLngAlts?: Array<number>, opt_ctx?: undefined.AltitudeContext): this;

        /**
         * This method pushes a lat, lng, alt to the end of this strip.
         * @param lat * 
         * @param lng * 
         * @param alt 
         */
        pushLatLngAlt(
            lat: undefined.Latitude,
            lng: undefined.Longitude,
            alt: undefined.Altitude): void;

        /**
         * This method splices the strip at the provided index, removing the specified number of items at that index and inserting the lat, lng, alt array.
         * @param index - The index at which to splice
         * @param opt_nRemove - The number of lat, lng, alt values to remove
         * @param opt_latLngAlts - The lat, lng, alt values to add
         * @returns  - an array of removed elements
         */
        spliceLatLngAlts(
            index: number,
            opt_nRemove?: number,
            opt_latLngAlts?: Array<number>): Array<number>;

        /**
         * This method inserts one set of lat, lng, alt values into the strip at the specified index.
         * @param index - the index at which to add the element
         * @param lat - the latitude to insert
         * @param lng - the longitude to insert
         * @param alt - the altitude to insert
         */
        insertLatLngAlt(
            index: number,
            lat: undefined.Latitude,
            lng: undefined.Longitude,
            alt: undefined.Altitude): void;

        /**
         * This method removes one set of lat, lng, alt values from the strip at the specified index.
         * @param index 
         */
        removeLatLngAlt(index: number): void;

        /**
         * This method pushes the lat, lng, alt values of a H.geo.Point to the end of this strip.
         * @param geoPoint 
         */
        pushPoint(geoPoint: undefined.IPoint): void;

        /**
         * This method inserts the lat, lng, alt values of a H.geo.Point into the list at the specified index.
         * @param pointIndex * 
         * @param geoPoint 
         */
        insertPoint(pointIndex: number, geoPoint: undefined.IPoint): void;

        /**
         * This method removes one set of lat, lng, alt values from this strip at the virtual point index specified.
         * @param pointIndex - the virtual point index
         */
        removePoint(pointIndex: number): void;

        /**
         * This method extracts a H.geo.Point from this strip at the virtual point index. If the extracted point has an alt value, the strip's altitude context will be supplied to the point.
         * @param pointIndex - the virtual point index in the strip
         * @param opt_out - an optional point object to store the lat, lng, alt values
         * @returns  - returns either the 'opt_out' point object or a new point object.
         */
        extractPoint(pointIndex: number, opt_out?: undefined.Point): undefined.Point;

        /**
         * This method is a utility method that iterates over the lat, lng, alt array and calls the provided function for each 3 elements passing lat, lng and alt and the virtual point index as arguments.
         * @param eachFn - the function to be called for each 3 elements
         * @param opt_start - an optional start index to iterate from
         * @param opt_end - an optional end index to iterate to
         */
        eachLatLngAlt(
            eachFn: (
                lat: undefined.Latitude,
                lng: undefined.Longitude,
                alt: undefined.Altitude,
                n: number) => void,
            opt_start?: number,
            opt_end?: number): void;

        /**
         * This method returns the number of times that legs in this strip cross the date border.
         * @param opt_closed - indicates whether the strip is closed (i.e. whether the strip's last and first coordinates form the closing leg of a polygon)
         * @returns  - the amount of times this strip crosses the date border.
         */
        getDBCs(opt_closed?: boolean): number;

        /**
         * This method return the number of points stored in this strip.
         * @returns  - the number of points in this strip
         */
        getPointCount(): number;

        /**
         * This method returns the internal array keeping the lat, lng, alt values. Modifying this array directly can destroy the integrity of this strip. Use it only for read access.
         * @returns  - returns the raw lat, lng, alt values of this strip
         */
        getLatLngAltArray(): Array<number>;

        /**
         * This method returns the bounding box of this strip.
         * @returns  - this strip's bounding rectangle
         */
        getBounds(): undefined.Rect;

        /**
         * This method checks whether two longitudes form a leg which crosses the date border.
         * @param lng1 - the start longitude of the leg
         * @param lng2 - the end longitude of the leg
         * @returns  - true if the leg crosses the date border, otherwise false
         */
        isDBC(lng1: undefined.Longitude, lng2: undefined.Longitude): boolean;

        /**
         * This method initializes a new strip with an array of lat, lng values. Arrays are expected to have an even length with the format [lat, lng, lat, lng, ...].
         * @param latLngs - the array of lat, lng value.
         * @returns  - the strip containing the lat, lng values
         */
        fromLatLngArray(latLngs: Array<number>): undefined.Strip
    }
}


declare module 'map' {
    declare module 'AbstractMarker' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'ArrowStyle' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Circle' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * The class represents data model of the map. It holds list of layers that are rendered by map's RenderEngine. The class listens to 'update' events from layers and dispatches them to the RenderEngine.
     */
    declare export class DataModel mixins undefined.OList {

        /**
         * Constructor
         * @param opt_layers - array of layers to be added to the data model
         */
        constructor(opt_layers?: Array<undefined.Layer>): this
    }
    declare module 'DomIcon' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'DomMarker' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * This class represents a spatial shape in geographic space. It is defined by a path containing the vertices of the shape (lat, lng, alt values).
     */
    declare export class GeoShape mixins undefined.Spatial {

        /**
         * Constructor
         * @param isClosed - Indicates whether this geographical shape is closed (a polygon)
         * @param strip - The strip describing the shape of the spatial object
         * @param options - The options to apply
         */
        constructor(isClosed: boolean, strip: undefined.Strip, options: undefined.Options): this;

        /**
         * This method returns the strip which represents the shape of the spatial object.
         * @returns  - the strip
         */
        getStrip(): undefined.Strip;

        /**
         * This method sets the geo-information for the spatial object
         * @param strip - The strip which represents the shape of the spatial object.
         * @returns  - the Spatial instance itself
         */
        setStrip(strip: undefined.Strip): undefined.GeoShape;

        /**
         * This method returns the bounding rectangle for this object. The rectangle is the smallest rectangle which encloses all points of the spatial object.
         * @returns  
         */
        getBounds(): undefined.Rect
    }
    declare module 'Group' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'HitArea' {

    }


    /**
     * Control interface defines method which are used for direct view or camera manipulation
     */
    declare export interface IControl {

        /**
         * This method starts control action for camera. This action allows to control camera animation and movement according to provided values in the H.map.IControl#control function
         * @param opt_kinetics - kinetics settings
         * @param opt_atX - control starts at x screen coordinate
         * @param opt_atY - control starts at y screen coordinate
         */
        startControl(opt_kinetics?: undefined.IKinetics, opt_atX?: number, opt_atY?: number): void,

            /**
             * This method triggers single control action on engine. This will trigger an animation which will start modification of the view's or camera's properties according to values begin set. Modification will occur at every frame. The speed values are measure by 'levels per frame' were 1 level cooresponds to a distance to next zoom level.
             * @param moveX - moves the view/cam in right/left direction
             * @param moveY - moves the view/cam in bottom/top direction
             * @param moveZ - moves the view/cam in depth direction (changes zoom level)
             * @param angleX - rotates cam over x-axis
             * @param angleY - rotates cam over y-axis
             * @param angleZ - rotates cam over z-axis
             * @param zoom - changes current zoom level (for view works as moveZ)
             * @param opt_timestamp 
             */
            control(
                moveX: number,
                moveY: number,
                moveZ: number,
                angleX: number,
                angleY: number,
                angleZ: number,
                zoom: number,
                opt_timestamp?: number): void,

            /**
             * This method ends current control, which will stop ongoing animation triggered by the startControl method. This method can prevent kinetics as well as it can adjust the final view if the adjust function is being passed.
             * @param opt_preventKinetics - if set to true will prevent kinetics animation
             * @param opt_adjustView - user defined function which can adjust the final view this function takes last requestedData from the view model and should return a modified H.map.ViewModel.CameraData which will be set as the final view
             */
            endControl(
                opt_preventKinetics?: boolean,
                opt_adjustView?: (data: undefined.CameraData) => void): void
    }

    /**
     * An interface to specify a copyright note
     * @property  label {string} - A short textual representation of the copyright note, e.g. "DigitalGlobe 2009"
     * @property  alt {string} - A detailed textual representation of the copyright note, e.g. "copyright 2009 DigitalGlobe, Inc."
     */
    declare export interface ICopyright {
        label: string,
            alt: string
    }

    /**
     * Interface describes interaction with the view port. Interaction will reflect view change depending on the interaction coordinates passed and the modifiers which specify the type of interaction.
     */
    declare export interface IInteraction {

        /**
         * This method starts the interaction with the view port. Should be called every time when new interaction is started i.e mouse grab, or touch start.
         * @param modifiers - a bitmask which specifies what operations should performed during every interaction
         * @param opt_kinetics - specifies kinetic move at the end of interaction
         */
        startInteraction(modifiers: undefined.BitMask, opt_kinetics?: undefined.IKinetics): void,

            /**
             * This method resolves direct screen (view port) interaction. This function will modify the current view according to values passed in.
             * @param x - viewport x coordinate
             * @param y - viewport y coordinate
             * @param opt_bx - x coordinate for second pointer/touch if present
             * @param opt_by - y coordinate for secong pointer/touch if present
             * @param opt_timestamp - known timestamp which should be passed
             */
            interaction(
                x: number,
                y: number,
                opt_bx?: number,
                opt_by?: number,
                opt_timestamp?: number): void,

            /**
             * This method ends interaction and applies kinetic movement if defined by using startInteraction method
             * @param opt_preventKinetics - if set to true will prevent kinetics behaviour at the end of interaction
             */
            endInteraction(opt_preventKinetics?: boolean): void
    }
    declare module 'Icon' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Imprint' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Marker' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Object' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Overlay' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * This class represents a polygon in geo-space. It is defined by a strip containing the vertices of a geo shape object (lat, lng, alt values) and a pen to use when rendering the polyline. Polygon represents a closed plane defined by the list of verticies, projected on the map display. List of vericies which define the polygon are is a list of geo coordinates encapsulated by the strip object H.geo.Strip
     */
    declare export class Polygon mixins undefined.GeoShape {

        /**
         * Constructor
         * @param strip - the strip describing this polygon's vertices
         * @param opt_options - optional initialization parameters
         */
        constructor(strip: undefined.Strip, opt_options?: undefined.Options): this;

        /**
         * To set the indicator whether this polygon covers the north pole. It's needed for Polygons whose strip is defined as lines arround the world on longitude axis (for example a circle whose center is one of the poles). In this case a additional information is needed to know if the southern or northern part of the world should be covered by the poygon.
         * @param flag - A value of true means it covers the north pole, false means south pole
         * @returns  - the Polygon instance itself
         */
        setNorthPoleCovering(flag: boolean): undefined.Polygon;

        /**
         * See H.map.Polygon#setNorthPoleCovering
         * @returns  
         */
        getNorthPoleCovering(): boolean
    }
    declare module 'Polyline' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * A Polygon with a rectangular shape.
     */
    declare export class Rect mixins undefined.Polygon {

        /**
         * Constructor
         * @param bounds - The geographical bounding box for this rectangle
         * @param opt_options 
         */
        constructor(bounds: undefined.Rect, opt_options?: undefined.Options): this;

        /**
         * To set the bounds of this rectangle.
         * @param bounds 
         */
        setBounds(bounds: undefined.Rect): void
    }
    declare module 'Spatial' {

        /**
         * Data to used as rendering hint for a label
         * @property  x {number} - The X coordinate of the first line's starting point
         * @property  y {number} - The Y coordinate of the first line's base line
         * @property  angle {number} - The clockwise rotation angle in radians
         * @property  font {string} - The CSS font-family
         * @property  size {number} - The CSS font-size
         * @property  color {string} - The CSS color
         * @property  text {string} - The text content, new line characters (\u000A) are interpreted as line breaks
         */
        declare     export interface Label {
            x: number,
                y: number,
                angle: number,
                font: string,
                size: number,
                color: string,
                text: string
        }

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'SpatialStyle' {

        /**
         * The style of the end caps for a line, one of 'butt', 'round' or 'square'.
         */
        declare     export type LineCap = "butt" | "round" | "square";

        /**
         * The type of corner created, when two lines meet, one of 'round', 'bevel' or 'miter'.
         */
        declare     export type LineJoin = "round" | "bevel" | "miter";

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'ViewModel' {

        /**
         * Defines camera's properties.
         * @property  zoom {number=} - zoom level to be used by rendering engine
         * @property  position {H.geo.IPoint} - the position of the virtual camera in geo-space
         * @property  pitch {number=} - the rotation of the virtual camera along its local x-axis
         * @property  yaw {number=} - the rotation of the virtual camera along its local y-axis
         * @property  roll {number=} - the rotation of the virtual camera along its local z-axis
         * @property  fov {number=} -
         */
        declare     export interface CameraData {
            zoom?: number,
                position: undefined.IPoint,
                pitch?: number,
                yaw?: number,
                roll?: number,
                fov?: number
        }

        /**
         * Defines currently requested view data, which will be rendered by the map.
         * @property  camera {H.map.ViewModel.CameraData=} - The requested camera properties
         * @property  zoom {number=} - The requested zoom level
         * @property  animate {boolean=} - indicates if the requested transition should be animated
         */
        declare     export interface RequestedData {
            camera?: undefined.CameraData,
                zoom?: number,
                animate?: boolean
        }

        /**
         * Update event is fired whenever view model data is changed. It contains property which hold currently requested data
         * @property  target {*} - Object which triggered the event
         * @property  currentTarget {*} - Object which has listener attached
         * @property  type {string} - Name of the dispatched event
         * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
         */
        declare     export class UpdateEvent mixins undefined.Event {

            /**
             * Constructor
             * @param requested 
             */
            constructor(requested: undefined.RequestedData): this;

            /**
             * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
             */
            preventDefault(): void;

            /**
             * Stops propagation for current event.
             */
            stopPropagation(): void;
            target: any;
            currentTarget: any;
            type: string;
            defaultPrevented: boolean
        }
    }

    declare module 'ViewPort' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }

        /**
         * Represents viewport padding definition.
         * @property  top {number} - the padding on the top edge (in pixels)
         * @property  right {number} - the padding on the right edge (in pixels)
         * @property  bottom {number} - the padding on the bottom edge (in pixels)
         * @property  left {number} - the padding on the left edge (in pixels)
         */
        declare     export interface Padding {
            top: number,
                right: number,
                bottom: number,
                left: number
        }
    }

    declare module 'layer' {

        /**
         * BaseTileLayer encapsulates funcitonailty that is common to all layers that deliver tiles, such as H.map.layer.TileLayer. The functionality includes geo bounding box to grid calculation, tile request management.
         */
        declare     export class BaseTileLayer mixins undefined.Layer {

            /**
             * Constructor
             * @param provider - data source for the TileLayer
             * @param opt_options - additional options
             */
            constructor(provider: undefined.TileProvider, opt_options?: undefined.Options): this;

            /**
             * This method returns the provider which feeds this layer with data.
             * @returns  - this layer's provider
             */
            getProvider(): undefined.TileProvider;

            /**
             * This method transforms a geo-rectangle to geometrical projected rectangle at the current projection zoom level or at provided zoom level
             * @param geoRect - geo bounds to be projected
             * @param opt_zoom - overrides current projection zoom level
             * @returns  - projected 2d space rect cooresponding to provided geo bounds
             */
            geoRectToRect(geoRect: undefined.Rect, opt_zoom?: number): undefined.Rect;

            /**
             * This method returns tile grid for a bounding rectangle
             * @param rectBounds - projected rect bounds which coorespond to geo bounding box
             * @param zoom - current zoom level
             * @returns  - rectangle which represents the tile grid bounds
             */
            getTileBounds(rectBounds: undefined.Rect, zoom: number): undefined.Rect;

            /**
             * This method requests a single tile according to tile coordinates. It returns either a Tile object if it is already loaded or undefined and starts loading the tile
             * @param x - tile row position
             * @param y - tile column position
             * @param z - The zoom level for which the tile is requested
             * @param cacheOnly - indicates whether only cached tiles are to be considered
             * @returns  - tile object corresponding to requested coordinates
             */
            requestTile(x: number, y: number, z: number, cacheOnly: boolean): undefined.Tile | void;

            /**
             * This method cancels a previously requested tile.
             * @param x - tile row position
             * @param y - tile column position
             * @param z - zoom level
             */
            cancelTile(x: number, y: number, z: number): void;

            /**
             * This method requests tiles from the data source (provider). It can return a set of tiles which are currently loaded. All tiles which are not yet loaded will be included in response as soon as they will be available during subsequent calls.
             * @param tileBounds - bounds in tile grid
             * @param isCDB * 
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @param prioCenter - The priority center as an offset in screen pixel relative to the center
             * @returns  - returns an array if tile which are already loaded
             */
            getProviderTiles(
                tileBounds: undefined.Rect,
                isCDB: boolean,
                zoomLevel: number,
                cacheOnly: boolean,
                prioCenter: undefined.Point): undefined.Response
        }
        declare module 'IMarkerLayer' {

            /**
             * This type represents a response object returned by the H.map.layer.IMarkerLayer#requestMarkers function.
             * @property  total {number} - The total number of markers, inclusive markers with not ready icons
             * @property  markers {Array<H.map.AbstractMarker>} - The marker objects for the bounding rectangle (only ready)
             */
            declare         export interface Response {
                total: number,
                    markers: Array<undefined.AbstractMarker >
            }

            /**
             * This type represents a response object returned by the H.map.layer.IMarkerLayer#requestMarkers function.
             * @property  number {number} - of returned tiles
             * @property  requested {number} - number of requested tiles
             * @property  objects {Array<H.map.AbstractMarker>} - the marker objects within requested tiled area
             */
            declare         export interface TiledResponse {
                number: number,
                    requested: number,
                    objects: Array<undefined.AbstractMarker >
            }
        }

        declare module 'ITileLayer' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }

            /**
             * This type represents a response object returned by the H.map.layer.IMarkerLayer#requestMarkers function.
             * @property  total {number} - The total number of markers, inclusive markers with not ready icons
             * @property  markers {Array<H.map.AbstractMarker>} - The marker objects for the bounding rectangle (only ready)
             */
            declare         export interface Response {
                total: number,
                    markers: Array<undefined.AbstractMarker >
            }
        }

        declare module 'Layer' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }


        /**
         * ObjectTileLayer represents map objects which are requested on a tile basis
         */
        declare     export class MarkerTileLayer mixins undefined.BaseTileLayer, undefined.IMarkerLayer {

            /**
             * Constructor
             * @param provider * 
             * @param opt_options 
             */
            constructor(provider: undefined.MarkerTileProvider, opt_options?: undefined.Options): this;

            /**
             * This method requests marker objects for provided bounding rectangle.
             * @param boundingRect - the bounding rectangle for which marker are to be returned
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @param prioCenter - The priority center as an offset in screen pixel relative to the center
             * @returns  - a response object containing the number of markers and the markers themselves
             */
            requestMarkers(
                boundingRect: undefined.Rect,
                zoomLevel: number,
                cacheOnly: boolean,
                prioCenter: undefined.Point): (undefined.Response | undefined.TiledResponse);

            /**
             * This method requests dom marker objects for provided bounding rectangle.
             * @param boundingRect - the bounding rectangle for which marker are to be returned
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @param prioCenter - The priority center as an offset in screen pixel relative to the center
             * @returns  - a response object containing the number of markers and the markers themselves
             */
            requestDomMarkers(
                boundingRect: undefined.Rect,
                zoomLevel: number,
                cacheOnly: boolean,
                prioCenter: undefined.Point): (undefined.Response | undefined.TiledResponse)
        }
        declare module 'ObjectLayer' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }

            /**
             * A response object returned by the H.map.layer.ObjectLayer#requestOverlays function.
             * @property  total {number} - The total number of overlays within the requested bounds, inclusive overlays which are not ready loaded yet
             * @property  overlays {Array<H.map.Overlay>} - A list all overlays which are ready to render
             */
            declare         export interface OverlaysResponse {
                total: number,
                    overlays: Array<undefined.Overlay >
            }
        }


        /**
         * Tile Layer, represents data shown on map on a tile basis. Can be used to show map tile images or other type of data which is partitioned into tiles.
         * @event  update {H.util.Event}
         */
        declare     export class TileLayer mixins undefined.BaseTileLayer, undefined.ITileLayer {

            /**
             * Constructor
             * @param provider - data source for the TileLayer
             * @param opt_options - additional options
             */
            constructor(provider: undefined.TileProvider, opt_options?: undefined.Options): this;

            /**
             * This method requests tiles for the current bounding rectangle at the given zoom level (z-value).
             * @param boundingRect - the bounding rectangle for which tiles are to be returned
             * @param zoomLevel - The zoom level for which the tiles are requested
             * @param cacheOnly - Indicates whether only cached tiles are to be considered
             * @param prioCenter - The priority center as an offset in screen pixel relative to the center
             * @returns  - a response object containing the total number of tiles requested and the tile objects that could be immediately returned
             */
            requestTiles(
                boundingRect: undefined.Rect,
                zoomLevel: number,
                cacheOnly: boolean,
                prioCenter: undefined.Point): undefined.Response;
            update: undefined.Event
        }
    }

    declare module 'provider' {
        declare module 'ImageTileProvider' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }

        declare module 'Invalidations' {

            /**
             * The invalidation mark represents a counter which is increased whenever an invalidation takes place.
             */
            declare         export interface Mark {}
        }

        declare module 'MarkerTileProvider' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }


        /**
         * An abstract class to manage and provide map objects (Marker, Polyline, Polygon)
         */
        declare     export class ObjectProvider mixins undefined.Provider {

            /**
             * Constructor
             * @param opt_options 
             */
            constructor(opt_options?: undefined.Options): this;

            /**
             * Returns the accumulate invalidations of this provider's objects that have occurred.
             * @param opt_type - The type of objects to consider for the invalidations. If undefined, all types are taken into account.
             * @returns  
             */
            getInvalidations(opt_type?: undefined.Type): undefined.Invalidations;

            /**
             * To signal to this provider that a map object has been changed. The method updates the Invalidations of this provider and the given map object and triggers dispatchUpdate()
             * @param mapObject - The map object to be invalidated
             * @param changes - The flags indicating the types of occurred changes
             */
            invalidateObject(mapObject: undefined.Object, changes: undefined.BitMask): void;

            /**
             * Checks whether this provider is currently providing overlay map objects. A concrete implementation of ObjectProvider must override it if it currently provides overlays.
             * @returns  
             */
            providesOverlays(): boolean;

            /**
             * Returns all Overlay objects which intersect with the provided area.
             * @param geoRect - A rectangular area in geo space to intersect with
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param visiblesOnly - Indicates whether only invisible objects are to be considered
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @returns  - a list of intersecting objects
             */
            requestOverlays(
                geoRect: undefined.Rect,
                zoomLevel: number,
                visiblesOnly: boolean,
                cacheOnly: boolean): Array<undefined.Overlay>;

            /**
             * Checks whether this provider is currently providing spatial map objects. A concrete implementation of ObjectProvider must override it if it currently provides Spatials.
             * @returns  
             */
            providesSpatials(): boolean;

            /**
             * Returns all polyline, polygon, circle and rect objects which intersect with the provided area.
             * @param geoRect - A rectangular area in geo space to intersect with
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param visiblesOnly - Indicates whether only invisible objects are to be considered
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @returns  - a list of intersecting objects
             */
            requestSpatials(
                geoRect: undefined.Rect,
                zoomLevel: number,
                visiblesOnly: boolean,
                cacheOnly: boolean): Array<undefined.Spatial>;

            /**
             * Returns the spatial objects which intersect the given tile
             * @param tile - The tile for which the objects are requested
             * @param visiblesOnly - Indicates whether only invisible objects are to be considered
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @returns  - a list of intersecting objects
             */
            requestSpatialsByTile(
                tile: undefined.Tile,
                visiblesOnly: boolean,
                cacheOnly: boolean): Array<undefined.Spatial>;

            /**
             * Checks whether this provider is currently providing Marker map objects. A concrete implementation of ObjectProvider must override it if it currently provides Markers.
             * @returns  
             */
            providesMarkers(): boolean;

            /**
             * Returns all Marker map objects which intersect with the provided rectangular area.
             * @param geoRect - A rectangular area in geo space to intersect with
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param visiblesOnly - Indicates whether only invisible objects are to be considered
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @returns  - a list of intersecting objects
             */
            requestMarkers(
                geoRect: undefined.Rect,
                zoomLevel: number,
                visiblesOnly: boolean,
                cacheOnly: boolean): Array<undefined.Marker>;

            /**
             * Checks whether this provider is currently providing DomMarker map objects. A concrete implementation of ObjectProvider must override it if it currently provides Markers.
             * @returns  
             */
            providesDomMarkers(): boolean;

            /**
             * Returns all DomMarker map objects which intersect with the provided rectangular area.
             * @param geoRect - A rectangular area in geo space to intersect with
             * @param zoomLevel - The zoom level for which the objects are requested
             * @param visiblesOnly - Indicates whether only invisible objects are to be considered
             * @param cacheOnly - Indicates whether only cached objects are to be considered
             * @returns  - a list of intersecting objects
             */
            requestDomMarkers(
                geoRect: undefined.Rect,
                zoomLevel: number,
                visiblesOnly: boolean,
                cacheOnly: boolean): Array<undefined.DomMarker >
        }
        declare module 'Provider' {

            /**
             * Options which are used within cluster calculations.
             * @property  eps {number=} - epsilon parameter for cluster calculation. For the FASTGRID strategy it must not exceed 256 and must take values that are power of 2. For the GRID and DYNAMICGRID strategies it can take values from 10 to 127. Default is 32.
             * @property  minWeight {number=} - the minimum points weight sum to form a cluster, default is 2
             * @property  projection {H.geo.IProjection=} - projection to use for clustering, default is H.geo.mercator
             * @property  strategy {H.clustering.Provider.Strategy=} - clustering stretegy, defaults to H.clustering.Provider.Strategy.FASTGRID
             */
            declare         export interface ClusteringOptions {
                eps?: number,
                    minWeight?: number,
                    projection?: undefined.IProjection,
                    strategy?: undefined.Strategy
            }

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }


        /**
         * RemoteTileProvider is an abstract class which should be used by classes implementing data provision on a tile basis. Every child class needs to implement 'requestInternal' (to request remote tile) and 'getCache' (to provide configured cache object were tiled data is being cached)
         */
        declare     export class RemoteTileProvider mixins undefined.TileProvider {

            /**
             * Constructor
             * @param options - The options to instantiate this TileProvider
             */
            constructor(options: undefined.Options): this;

            /**
             * This method returns cache which should be used to store tiles
             * @returns  - cache
             */
            getCache(): undefined.ICache;

            /**
             * This method request tile from remote service
             * @param x - The row number of the tile
             * @param y - The column number of the tile
             * @param z - The zoom level for which the tile is requested
             * @param onResponse - function which is called after response arrives
             * @param onError - function which is called in case of communication error
             * @param opt_priority - optional request priority level
             * @returns  
             */
            requestInternal(
                x: number,
                y: number,
                z: number,
                onResponse?: (
                    object: Array<undefined.Object>| HTMLImageElement | HTMLCanvasElement | ArrayBuffer,
                    response: any) => void,
                onError?: (s: string) => void,
                opt_priority?: undefined.Priority): undefined.ICancelable;

            /**
             * This method instructs the provider to reload data from it's source.
             * @param hard - a boolean flag indicating whether to invalidate in hard mode (true) or in soft mode (false);
             */
            reload(hard: boolean): void
        }

        /**
         * Generic Tile object which represents a part of the world fiting into the Tile area represented by the Tiel coordinates (x - row, y - column) and the zoom level (z). Number of tiles at particular zoom level (which means number of areas into world is being splitted) is defined as following: numberOfRows &#x3D; numberOfColumns &#x3D; 2^zoomlevel
         * @property  key {string} - Unique tile key generated by provider
         * @property  data {*} - Tile data (an image for example)
         * @property  valid {boolean} - This property holds a boolean flag indicating whether this tile is still valid (true) or whether it should be re-fetched (false)
         * @property  x {number} - Tile column
         * @property  y {number} - Tile row
         * @property  z {number} - Tile zoom level
         */
        declare     export class Tile {

            /**
             * Constructor
             * @param x - x tile coordinate (row)
             * @param y - y tile coordinate (column)
             * @param z - tile zoom level
             * @param data - generic data object which cooresponds to the given coordinates
             */
            constructor(x: number, y: number, z: number, data?: any): this;
            key: string;
            data: any;
            valid: boolean;
            x: number;
            y: number;
            z: number
        }
        declare module 'TileProvider' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }

    }

}


declare module 'mapevents' {
    declare module 'Behavior' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * ContextMenuEvent should be fired, when a user right-clicks or longpresses on a map object.
     * @property  viewportX {Array<H.util.ContextItem>} - Contains ContextItems, that will be used to create context menu entries. Should be filled by listeners of the "contextmenu" event
     * @property  viewportY {number} - Map viewport y position
     * @property  target {(H.map.Object | H.Map)} - Target for the event
     * @property  originalEvent {Event} - Original event
     * @property  currentTarget {(H.map.Object | H.Map)} - Object which has listener attached
     * @property  type {string} - Name of the dispatched event
     * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
     */
    declare export class ContextMenuEvent mixins undefined.Event {

        /**
         * Constructor
         * @param viewportX - The x coordinate on the viewport
         * @param viewportY - The y coordinate on the viewport
         * @param target - The event's target element
         * @param originalEvent - target of the event
         */
        constructor(viewportX: number, viewportY: number, target: (H$Map | undefined.Object), originalEvent: Event): this;
        viewportX: Array<undefined.ContextItem>;
        viewportY: number;
        originalEvent: Event
    }

    /**
     * Custom map event. Contains list of pointers on the map, list of changed pointers and original event. Inherits from H.util.Event.
     * @property  pointers {Array<H.mapevents.Pointer>} - Pointers which are currently on the screen
     * @property  changedPointers {Array<H.mapevents.Pointer>} - Pointers which has changed in course of event
     * @property  targetPointers {Array<H.mapevents.Pointer>} - Pointers which are on same target as the current pointer
     * @property  currentPointer {H.mapevents.Pointer} - Current pointer
     * @property  originalEvent {Event} - Original event fired by the browser
     * @property  target {(H.map.Object | H.Map)} - Object which triggered event. Can be the map object (i.e marker or polyline) or the map itself
     * @property  currentTarget {(H.map.Object | H.Map)} - Object which has listener attached
     * @property  type {string} - Name of the dispatched event
     * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
     */
    declare export class Event mixins undefined.Event {

        /**
         * Constructor
         * @param type - type of event
         * @param pointers - pointers which are currently on the screen
         * @param changedPointers - pointers which changed during event
         * @param targetPointers - pointers on the event target
         * @param currentPointer - pointer which triggered the event
         * @param target - target map object which triggered event
         * @param originalEvent - original dom event
         */
        constructor(type: string, pointers: Array<undefined.Pointer>, changedPointers: Array<undefined.Pointer>, targetPointers: Array<undefined.Pointer>, currentPointer: undefined.Pointer, target: (H$Map | undefined.Object), originalEvent: Event): this;

        /**
         * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
         */
        preventDefault(): void;

        /**
         * Stops propagation for current event.
         */
        stopPropagation(): void;
        pointers: Array<undefined.Pointer>;
        changedPointers: Array<undefined.Pointer>;
        targetPointers: Array<undefined.Pointer>;
        currentPointer: undefined.Pointer;
        originalEvent: Event;
        target: (undefined.Object | H$Map);
        currentTarget: (undefined.Object | H$Map);
        type: string;
        defaultPrevented: boolean
    }

    /**
     * MapEvents enable the events functionality on the map and on the map objects. By using this extension it is possible to listen to events on map objects like markers, polylines, polygons, circles and on the map object itself. Events are triggered depending on user interaction. Please check the Events Summary section for the list of events fired by this class and by the map objects.
     */
    declare export class MapEvents mixins undefined.Disposable {

        /**
         * Constructor
         * @param map - map instance which is used for firing events
         */
        constructor(map: H$Map): this;

        /**
         * This method destroys the MapEvents by removing all handlers from the map object. After calling this function mapEvents and map objects will not trigger any events. This object will be disposed automatically if the corresponding map object is disposed.
         */
        dispose(): void;

        /**
         * This method returns map into which events are attached
         * @returns  
         */
        getAttachedMap(): H$Map
    }
    declare module 'Pointer' {

        /**
         * Indicates which pointer device buttons are being pressed, expressed as a bitmask. Bit values are:
         * 
           - 0: No button pressed
           - 1: Left mouse button pressed, or Touch contact or Pen contact
           - 2: Right mouse button pressed, or Pen contact with barrel button pressed
           - 4: Middle mouse button pressed
        */
        declare     export type Buttons = undefined.BitMask;
    }


    /**
     * WheelEvent is fired when the mouse wheel is used over the map. It contains information about cursor position and the map object which resides directly under the cursor.
     * @property  delta {number} - Wheel move delta
     * @property  viewportX {number} - Map viewport x position
     * @property  viewportY {number} - Map viewport y position
     * @property  target {(H.map.Object | H.Map)} - Target for the event
     * @property  originalEvent {Event} - Original mouse wheel event
     * @property  currentTarget {(H.map.Object | H.Map)} - Object which has listener attached
     * @property  type {string} - Name of the dispatched event
     * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
     */
    declare export class WheelEvent mixins undefined.Event {

        /**
         * Constructor
         * @param deltaY - The wheel move delta on y-axis
         * @param viewportX - The x coordinate on the viewport
         * @param viewportY - The y coordinate on the viewport
         * @param target - The event's target element
         * @param originalEvent - target of the event
         */
        constructor(deltaY: number, viewportX: number, viewportY: number, target: (H$Map | undefined.Object), originalEvent: Event): this;
        delta: number;
        viewportX: number;
        viewportY: number;
        originalEvent: Event
    }
}


declare module 'math' {

    /**
     * A signed 32 bit integer (JS restriction) where bit operator can be applied to. The range is [-2,147,483,648 ... 2,147,483,647] or [-2^31 ... 2^31  1]
     */
    declare export type BitMask = number;

    /**
     * An interface to represent a geographic point. Every point in geo space is represented by three coordinates latitude, longitude and optional altitude.
     * @property  lat {H.geo.Latitude} - The latitude coordinate.
     * @property  lng {H.geo.Longitude} - The longitude coordinate.
     * @property  alt {H.geo.Altitude=} - The altitude coordinate.
     * @property  ctx {H.geo.AltitudeContext=} - The altitude context.
     */
    declare export interface IPoint {
        lat: undefined.Latitude,
            lng: Longitude,
            alt?: undefined.Altitude,
            ctx?: undefined.AltitudeContext
    }

    /**
     * An interface for a 2-dimensional size consisting a with and a height.
     * @property  w {number} - The size's width.
     * @property  h {number} - The size's height.
     */
    declare export interface ISize {
        w: number,
            h: number
    }

    /**
     * Class represents a 2-dimensional point, defined by x and y coordinates.
     * @property  x {number} - The point's coordinate on X-axis.
     * @property  y {number} - The point's coordinate on Y-axis.
     */
    declare export class Point mixins IPoint {

        /**
         * Constructor
         * @param x - The point's coordinate on X-axis.
         * @param y - The point's coordinate on Y-axis.
         */
        constructor(x: number, y: number): this;

        /**
         * Sets the x and y coordinate of this point
         * @param x - The point's coordinate on X-axis.
         * @param y - The point's coordinate on Y-axis.
         */
        set(x: number, y: number): void;

        /**
         * This method creates a copy of the current point.
         * @param opt_out - An optional point to store the copied values
         * @returns  - The clone of the point
         */
        clone(opt_out?: Point): Point;

        /**
         * This method adds given point coordinates to the current one.
         * @param other - The point to add
         * @returns  - the point itself after adding
         */
        add(other: IPoint): Point;

        /**
         * This method subtracts given point coordinates from the current point.
         * @param other - The point to subtract
         * @returns  - the point itself after subtracting
         */
        sub(other: IPoint): Point;

        /**
         * This method scales the current point coordinates by the given factor(s).
         * @param factor - multiplication factor
         * @param opt_factorY - If omitted, the factor argument is used
         * @returns  - the point itself after scaling
         */
        scale(factor: number, opt_factorY?: number): Point;

        /**
         * This method rounds the x and y coordinates of the point.
         * @returns  - the point itself after rounding
         */
        round(): Point;

        /**
         * Rounds the x and y coordinates to the next smaller integer values.
         * @returns  - the point itself after flooring
         */
        floor(): Point;

        /**
         * Rounds the x and y coordinates to the next greater integer values.
         * @returns  - the point itself after ceiling
         */
        ceil(): Point;

        /**
         * This method compares current point coordinates with the supplied point coordinates.
         * @param other - The point to compare to.
         * @returns  - True if the points are equal
         */
        equals(other: IPoint): boolean;

        /**
         * Calculates the closest point on a given line
         * @param start - The start point of the line
         * @param end - The end point of the line
         * @returns  - the closest point
         */
        getNearest(start: IPoint, end: IPoint): IPoint;

        /**
         * This method calculates the distance to a point supplied by the caller.
         * @param other * 
         * @returns  
         */
        distance(other: IPoint): number;

        /**
         * This method creates a Point instance from a given IPoint object.
         * @param iPoint - The IPoint object to use
         * @returns  - the created Point instance
         */
        fromIPoint(iPoint: IPoint): Point;
        x: number;
        y: number
    }

    /**
     * Class defines a rectangle in 2-dimensional geometric space. It is used to represent the area in projected space.
     */
    declare export class Rect {

        /**
         * Constructor
         * @param left - The rectangle's left edge x value
         * @param top - The rectangle's top edge y value
         * @param right - The rectangle's right edge x value
         * @param bottom - The rectangle's bottom edge y value
         */
        constructor(left: number, top: number, right: number, bottom: number): this;

        /**
         * To set all values of the rectangle's edges
         * @param left - The rectangle's left edge x value
         * @param top - The rectangle's top edge y value
         * @param right - The rectangle's right edge x value
         * @param bottom - The rectangle's bottom edge y value
         */
        set(left: number, top: number, right: number, bottom: number): void;

        /**
         * To get the rectangle's top-left vertex
         * @returns  
         */
        getTopLeft(): undefined.Point;

        /**
         * To get the rectangle's bottom-right vertex
         * @returns  
         */
        getBottomRight(): undefined.Point;

        /**
         * Method checks if provided coordinates lie within rectangle.
         * @param x - x-coordinate to check
         * @param y - y-coordinate to check
         * @returns  - returns true if coordinates lie within rectangle, if parameters are isNaN returns false
         */
        containsXY(x: number, y: number): boolean;

        /**
         * To create a rectangle from a top-left and bottom-right point pair.
         * @param topLeft - the top-left vertex of the rectanle
         * @param bottomRight - the bottom-right vertex of the rectanle
         * @returns  - returns the rectangular area defined by the top-left and bottom-right vertices
         */
        fromPoints(topLeft: undefined.IPoint, bottomRight: undefined.IPoint): undefined.Rect;

        /**
         * To clone a rectangle
         * @returns  
         */
        clone(): undefined.Rect
    }

    /**
     * Class for representing sizes consisting of a width and height.
     * @property  w {number} - The size's width value
     * @property  h {number} - The size's height value
     */
    declare export class Size {

        /**
         * Constructor
         * @param width - Width.
         * @param height - Height.
         */
        constructor(width: number, height: number): this;
        w: number;
        h: number
    }
}


declare module 'net' {
    declare module 'Request' {
        declare     export interface Priority {}
    }

}


declare module 'service' {
    declare module 'AbstractRestService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'EnterpriseRoutingService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'GeocodingService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * An interface represents an object, that can be configured credentials, settings etc. by H.service.Platform
     */
    declare export interface IConfigurable {

        /**
         * This methods receive configuration parameters from the platform, that can be used by the object implementing the interface.
         * @param appId - The application ID to identify the client against the platform (mandatory to provide)
         * @param appCode - The application code to identify the client against the platform (mandatory to provide)
         * @param useHTTPS - Indicates whether secure communication should be used, default is false
         * @param useCIT - Indicates whether the Customer Integration Testing should be used, default is false
         * @param opt_baseUrl - The base URL of the platform, default is http://api.here.com. Note that if useHTTPS flag is passed it will override the URL scheme specified in the opt_baseUrl to use HTTPS.
         * @returns  
         */
        configure(
            appId: string,
            appCode: string,
            useHTTPS: boolean,
            useCIT: boolean,
            opt_baseUrl?: undefined.Url): undefined.IConfigurable
    }

    /**
     * 
     * @property  id {number} - the ID associated internally with this request
     * @property  cancel {function()} - this function cancels the request and invokes the errback function
     */
    declare export interface JsonpRequestHandle {
        id: number,
            cancel: () => void
    }
    declare module 'MapTileService' {

        /**
         * 
         * @property  maps {Object<string, Object>} -
         * @property  schemes {Object<string, Object>} -
         * @property  tiletypes {Object<string, Object>} -
         * @property  formats {Object<string, Object>} -
         * @property  resolutions {Object<string, Object>} -
         * @property  languages {Object<string, Object>} -
         */
        declare     export interface Info {
            maps: {
                    [key: string]: any
                },
                schemes: {
                    [key: string]: any
                },
                tiletypes: {
                    [key: string]: any
                },
                formats: {
                    [key: string]: any
                },
                resolutions: {
                    [key: string]: any
                },
                languages: {
                    [key: string]: any
                }
        }

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * A map type is an object holding tile layers corresponding to a map type (e.g. 'normal', 'satellite' or 'terrain'). A map type contains at least a map property which defines the basic map layer for a given map type. In addition it can hold other map layers with the given style, e.g. base, xbase, traffic etc.
     * @property  map {H.map.layer.TileLayer} - the basic map tiles with all features and labels
     * @property  mapnight {H.map.layer.TileLayer} - the basic map tiles with all features and labels (night mode)
     * @property  xbase {H.map.layer.TileLayer=} - map tiles without features and labels
     * @property  xbasenight {H.map.layer.TileLayer=} - map tiles without features and labels (night mode)
     * @property  base {H.map.layer.TileLayer=} - map tiles without labels
     * @property  basenight {H.map.layer.TileLayer=} - map tiles without labels (night mode)
     * @property  traffic {H.map.layer.TileLayer=} - map tiles with traffic flow highlighting
     * @property  trafficnight {H.map.layer.TileLayer=} - map tiles with traffic flow highlighting (night mode)
     * @property  transit {H.map.layer.TileLayer=} - map tiles with public transit lines highlighted
     * @property  panorama {H.map.layer.TileLayer=} - map tiles highlighting areas with HERE StreetLevel coverage
     * @property  panoramanight {H.map.layer.TileLayer=} - map tiles highlighting areas with HERE StreetLevel coverage (night mode)
     * @property  labels {H.map.layer.TileLayer=} - transparent map tiles with labels only
     */
    declare export interface MapType {
        map: undefined.TileLayer,
            mapnight: undefined.TileLayer,
            xbase?: undefined.TileLayer,
            xbasenight?: undefined.TileLayer,
            base?: undefined.TileLayer,
            basenight?: undefined.TileLayer,
            traffic?: undefined.TileLayer,
            trafficnight?: undefined.TileLayer,
            transit?: undefined.TileLayer,
            panorama?: undefined.TileLayer,
            panoramanight?: undefined.TileLayer,
            labels?: undefined.TileLayer
    }
    declare module 'PlacesService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Platform' {

        /**
         * Options used to create default layers
         * @property  tileSize {number=} - tile size to be queried from the HERE Map Tile API, default is 256
         * @property  ppi {number=} - 'ppi' parameter to use when querying tiles, default is not specified
         * @property  lg {string=} - optional primary language parameter, default is not specified
         * @property  lg2 {string=} - optional secondary language parameter, default is not specified
         * @property  style {string=} - optional 'style' parameter to use when querying map tiles, default is not specified
         * @property  pois {boolean=} - indicates if pois are displayed on the map
         * @property  crossOrigin {(string | boolean=)} - indicates if CORS headers should be used for default layers, if false is specified, CORS headers are not set, defaults to 'anonymous'. Be aware that storing of content is not possible if crossOrigin is not set to true (see H.Map#storeContent).
         */
        declare     export interface DefaultLayersOptions {
            tileSize?: number,
                ppi?: number,
                lg?: string,
                lg2?: string,
                style?: string,
                pois?: boolean,
                crossOrigin?: (string | boolean)
        }

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }

        /**
         * pre-configured set of HERE tile layers for convenient use with the map.
         */
        declare     export interface MapTypes {
            normal?: undefined.MapType,
                satellite?: undefined.MapType,
                terrain?: undefined.MapType, [key: string]: undefined.MapType
        }
    }

    declare module 'RoutingService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * This type encapsulates URL parameters to be sent to a HERE platform service.
     */
    declare export interface ServiceParameters {
        [key: string]: string
    }

    /**
     * This type encapsulates a response object provider by a HERE platform service.
     */
    declare export interface ServiceResult {
        [key: string]: string
    }

    /**
     * Options which are used to initialize the tile provider.
     * @property  crossOrigin {boolean=} - The string to be set for the crossOrigin attribute for loaded images
     */
    declare export interface TileProviderOptions {
        crossOrigin?: boolean
    }
    declare module 'TrafficIncidentsService' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * This class represents a URL giving access to the individual parts that make up a URL,such as the scheme, host/domain, path, etc. Use the static parse method to populate a new URL object from a URL string. Be aware that URLs with user and password like "ftp://user:password@foo.bar/" are not supported!
     */
    declare export class Url {

        /**
         * Constructor
         * @param scheme - the URL scheme (e.g. "http" or "https" or "mailto")
         * @param host - the host (or domain) part of the URL
         * @param opt_path - the path following the host pointing to a resource
         * @param opt_params - the query string parameters of this URL
         * @param opt_port - The port of the host on which the host listens. If a string is passed it must be convertible to an integer.
         * @param opt_anchor - an optional anchor part of the URL (usually preceded by '#');
         */
        constructor(scheme: string, host: string, opt_path?: string, opt_params?: Object, opt_port?: number, opt_anchor?: string): this;

        /**
         * This function parses a URL string and returns a H.service.Url object. The URL string must contain at least a scheme and a host.
         * @param url - The URL string to parse.
         * @param opt_baseURL - The base URL to use to resolve relative URLs. If ommited the base URL of the document which loaded the API is taken.
         * @returns  - the parsed URL object
         */
        parse(url: string, opt_baseURL?: string): undefined.Url;

        /**
         * Clones this URL object. Optionally, mutations can be passed to this function to modify properties of the cloned object. Note that URL parameters are not replaced but merged with the parameters of this instance.
         * @returns  - the clone of the URL object
         */
        clone(): undefined.Url;

        /**
         * This function sets the scheme of this URL object.
         * @param scheme - the new scheme
         * @returns  - this URL object
         */
        setScheme(scheme: string): undefined.Url;

        /**
         * This function returns the scheme of this Url object.
         * @returns  - the scheme (for example 'http')
         */
        getScheme(): string;

        /**
         * This function sets the host of this URL object.
         * @param host - the new host
         * @returns  - this URL object
         */
        setHost(host: string): undefined.Url;

        /**
         * This function returns the host name of this Url object.
         * @returns  - the host (for example 'api.here.com')
         */
        getHost(): string;

        /**
         * This function sets the path of this URL object.
         * @param path - the new path or a boolean to clear the path
         * @returns  - this URL object
         */
        setPath(path: string | boolean): undefined.Url;

        /**
         * This function returns the path part of this Url object.
         * @returns  - the path (for example 'myresources/resource.html')
         */
        getPath(): string | void;

        /**
         * This function sets the specified parameters for this URL object. Keys in this object, which are associated with undefined values will be treated as query string parameters with no value.
         * @param params - a hash of query string parameters specifying the parameters to be set.or a boolean to clear the parameters.
         * @returns  - this URL object
         */
        setQuery(params?: Object | boolean): undefined.Url;

        /**
         * This function returns a boolean value indicating whether there are any query string parameter associated with this URL.
         * @returns  - true if there are parameters, false if none are present
         */
        hasQuery(): boolean;

        /**
         * This function returns the query object of this Url object.
         * @returns  - the query object
         */
        getQuery(): Object;

        /**
         * This function sets the anchor of this URL object.
         * @param anchor - the new anchor or undefined to clear the anchor
         * @returns  - this URL object
         */
        setAnchor(anchor?: string | boolean): undefined.Url;

        /**
         * This function returns the anchor of this Url object.
         * @returns  - the anchor
         */
        getAnchor(): string | void;

        /**
         * This function merges the provided parameters into this URL's existing parameters. Key-value pairs which are defined in the argument and this URL's parameters will be overwritten. Key-value pairs which are defined in the argument and are not defined in this URL's parameters will be added. Prototype properties and function properties will not be merged.
         * @param other - the parmeters to be merged into this URL's query string parameters
         * @returns  - this URL object
         */
        mergeQuery(other: Object): undefined.Url;

        /**
         * This function adds a sub-domain to the host of this URL object.
         * @param subDomain - the sub domain (non-empty string) to be added
         * @returns  - this URL object
         */
        addSubDomain(subDomain: string): undefined.Url;

        /**
         * This function adds a sub-path to this URL's path
         * @param subPath - the path to be added
         * @returns  - this URL object
         */
        addSubPath(subPath: string): undefined.Url;

        /**
         * This function formats this URL object to a full URL string.
         * @returns  - the URL's string representation
         */
        toString(): string
    }
    declare module 'metaInfo' {
        declare module 'Service' {

            /**
             * 
             * @property  maps {Object<string, Object>} -
             * @property  schemes {Object<string, Object>} -
             * @property  tiletypes {Object<string, Object>} -
             * @property  formats {Object<string, Object>} -
             * @property  resolutions {Object<string, Object>} -
             * @property  languages {Object<string, Object>} -
             */
            declare         export interface Info {
                maps: {
                        [key: string]: any
                    },
                    schemes: {
                        [key: string]: any
                    },
                    tiletypes: {
                        [key: string]: any
                    },
                    formats: {
                        [key: string]: any
                    },
                    resolutions: {
                        [key: string]: any
                    },
                    languages: {
                        [key: string]: any
                    }
            }

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }

        declare module 'TileProvider' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }

    }

    declare module 'venues' {

        /**
         * The class represents the building in the venue hiearachy (see H.service.venues.Venue) and holds floors that belong to the building.
         */
        declare     export class Building mixins undefined.Group {

            /**
             * Constructor
             * @param provider - The object provider of this venue building
             * @param uid - The unique identifier of this building
             * @param minLevel - The minimum floor level of this building
             * @param maxLevel - The maximum floor level of this building
             */
            constructor(provider: undefined.ObjectProvider, uid: string, minLevel: number, maxLevel: number): this;

            /**
             * Method returns the parent object - venue (see H.service.venues.Venue) to which the building belongs to.
             * @returns  
             */
            getVenue(): undefined.Venue;

            /**
             * Method returns the minimum floor level of this building.
             * @returns  
             */
            getMinLevel(): number;

            /**
             * Method returns the maximum floor level of this building
             * @returns  
             */
            getMaxLevel(): number;

            /**
             * Method returns the floor (see H.service.venues.Floor) if one was already loaded. This method doesn't make attempt to fetch the floor data.
             * @param level - floor level within minimum and maximum level boundaries for the building
             * @returns  - The floor object or undefined if floor was not loaded
             */
            getFloor(level: number): undefined.Floor | void
        }

        /**
         * The class represents the floor object in the venue hierarchy (see H.service.venues.Venue). The class holds information about floor geometry and spaces (see H.service.venues.Space) that belong to this floor.
         */
        declare     export class Floor mixins undefined.Group {

            /**
             * Constructor
             * @param provider - The object provider of this venue floor
             * @param data - The meta data of this floor
             * @param level - The level of this floor
             */
            constructor(provider: undefined.ObjectProvider, data: any, level: number): this;

            /**
             * Method returns the level of the floor in the building.
             * @returns  
             */
            getLevel(): number;

            /**
             * Method returns map geometry that represents floor boundaries.
             * @returns  
             */
            getFloorSpace(): undefined.Space | void;

            /**
             * Method returns the H.map.Group of all spaces that belong to the floor.
             * @returns  
             */
            getSpaces(): undefined.Group;

            /**
             * Method returns parent object - building (see H.service.venues.Building) of the floor.
             * @returns  
             */
            getBuilding(): undefined.Building;

            /**
             * Method returns raw data associated with the floor. For more details on data format see http://developer.here.com/rest-apis/documentation/venue-maps/topics/resource-type-venue-interaction-tile-floor.html
             * @returns  - the raw floor data object
             */
            getData(): any;

            /**
             * Method returns the space object with the given ID, that belongs to the floor.
             * @param id - The ID of the space.
             * @returns  - The requested space or undefined if space not found.
             */
            getSpace(id: string): undefined.Space | void
        }
        declare module 'Service' {

            /**
             * 
             * @property  maps {Object<string, Object>} -
             * @property  schemes {Object<string, Object>} -
             * @property  tiletypes {Object<string, Object>} -
             * @property  formats {Object<string, Object>} -
             * @property  resolutions {Object<string, Object>} -
             * @property  languages {Object<string, Object>} -
             */
            declare         export interface Info {
                maps: {
                        [key: string]: any
                    },
                    schemes: {
                        [key: string]: any
                    },
                    tiletypes: {
                        [key: string]: any
                    },
                    formats: {
                        [key: string]: any
                    },
                    resolutions: {
                        [key: string]: any
                    },
                    languages: {
                        [key: string]: any
                    }
            }

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }


        /**
         * Represents a spatial object for this space. Each space object contains data associated with that space and can be retrieved by using H.service.venues.Space#getData method.
         */
        declare     export class Space {

            /**
             * Constructor
             * @param provider - The provider of this object.
             * @param uid - The unique identifier of this space
             * @param data - The meta data of this space
             * @param opt_isFloorSpace - Indicates whether this space represents a floor itself, defaults to false
             */
            constructor(provider: undefined.ObjectProvider, uid: string, data?: any, opt_isFloorSpace?: boolean): this;

            /**
             * The method indicates whether the spatial object represents the whole floor space or a space within a floor boundaries, that belongs to the floor.
             * @returns  - True if this spatial object represents the floor space.
             */
            isFloorSpace(): boolean;

            /**
             * This method sets custom style to use for rendering the labels. Should be called before the first render of the space, otherwise has no any effect. Note that due to the design consistency currently it is not allowed to change the font family and the size of the labels.
             * @param labelStyle - Custom label style
             */
            initLabelStyle(labelStyle: (undefined.SpatialStyle | undefined.Options)): void;

            /**
             * Method returns parent object - floor (see H.service.venues.Floor) of the space.
             * @returns  
             */
            getFloor(): undefined.Floor;

            /**
             * Method returns raw data associated with the space. For more details on data format see http://developer.here.com/rest-apis/documentation/venue-maps/topics/resource-type-venue-interaction-tile-space.html
             * @returns  - raw space data object
             */
            getData(): Object
        }
        declare module 'TileProvider' {

            /**
             * This type defines options which can be used to initialize the map.
             * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
             * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
             * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
             * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
             * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
             * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
             * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
             * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
             * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
             * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
             * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
             * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
             */
            declare         export interface Options {
                center?: undefined.IPoint,
                    zoom?: number,
                    bounds?: undefined.Rect,
                    layers?: Array<undefined.Layer>,
                    engineType?: EngineType,
                    pixelRatio?: number,
                    imprint?: undefined.Options,
                    renderBaseBackground?: BackgroundRange,
                    autoColor?: boolean,
                    margin?: number,
                    padding?: undefined.Padding,
                    fixedCenter?: boolean
            }
        }


        /**
         * The class represents the venue, it is a root for the venue object heirarchy. The venue inherits from H.map.Group and holds building objects (see H.service.venues.Building). Building objects hold floor objects (see H.service.venues.Floor) and inherit from H.map.Group as well. Leaf objects are spaces (see H.service.venues.Space) that are spatial map objects and reside inside floor containers.
         */
        declare     export class Venue mixins undefined.Group {

            /**
             * Constructor
             * @param provider - The object provider of this venue
             * @param uid - The unique identifier of this venue
             */
            constructor(provider: undefined.ObjectProvider, uid: string): this;

            /**
             * Method returns the building object, that belongs to the venue, with the given ID . The method doesn't attempt to fetch building data.
             * @param id - the ID of the building
             * @returns  - The requested building or undefined if building wasn't loaded
             */
            getBuilding(id: string): undefined.Building | void;

            /**
             * Method returns map of all loaded buildings associated with the venue.
             * @returns  
             */
            getBuildings(): any
        }
    }

}


declare module 'ui' {

    /**
     * This class represents the base class for UI controls on the map.
     */
    declare export class Control mixins undefined.Container {

        /**
         * This abstract method can be overridden by deriving classes to be invoked when the UI object&#x27;s unit system changes.
         * @param unitSystem - the unit system the UI currently uses
         */
        onUnitSystemChange(unitSystem: undefined.UnitSystem): void;

        /**
         * This abstract method can be overridden by deriving classes to be invoked when the underlying map engine changes.
         * @param engineType - the engine type the map currently uses
         */
        onMapEngineTypeChange(engineType: undefined.EngineType): void;

        /**
         * This method returns the map to which this control is attached.
         * @returns  - return the map
         */
        getMap(): H$Map;

        /**
         * This method returns the localization object which corresponds to the UI&#x27;s current locale.
         * @returns  
         */
        getLocalization(): undefined.Localization;

        /**
         * This method returns this control&#x27;s layout alignment.
         * @returns  - the control&#x27;s current layout alignment
         */
        getAlignment(): undefined.LayoutAlignment;

        /**
         * This method sets the control&#x27;s layout alignments.
         * @param alignment - The new alignment of the control
         * @returns  - returns this control instance
         */
        setAlignment(alignment: undefined.LayoutAlignment): undefined.Control
    }
    declare module 'DistanceMeasurement' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'InfoBubble' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'MapSettingsControl' {

        /**
         * The map type entry is an object containing a display name and a map type object to which it refers.
         * @property  name {string} - label which describes the map type
         * @property  mapType {H.service.MapType} - reference to map type
         */
        declare     export interface MapTypeEntry {
            name: string,
                mapType: undefined.MapType
        }

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'Pano' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'ScaleBar' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'UI' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'ZoomControl' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare module 'ZoomRectangle' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }

    declare type ES6Element = Element;
    declare module 'base' {
        declare     export class Container mixins undefined.EventTarget {

            /**
             * Constructor
             * @param opt_elementType - the type of HTML element this UI element renders as, default is 'div'
             * @param opt_className - an optional class name to be used on this element
             * @param opt_children - optional child elements to be added to this container
             */
            constructor(opt_elementType?: string, opt_className?: string, opt_children?: Array<Element>): this;

            /**
             * Adds a child element to be rendered within the container element.
             * @param child - the child element to be added
             * @returns  - this container instance
             */
            addChild(child: Element): Container;

            /**
             * Returns the child collection of this container.
             * @returns  - Returns the child collection of this container.
             */
            getChildren(): Array<Element>;

            /**
             * Removes a child element from this container's child collection.
             * @param child - the child element to be removed
             */
            removeChild(child: Element): void;

            /**
             * This method is the concrete implementation of the UI element. This method receives the pre-rendered HTML element which may be modified by deriving classes.
             * @param element - this UI element's HTML representation
             * @param doc - the HTML document into which the element is currently being rendered
             */
            renderInternal(element: ES6Element, doc: Document): void;

            /**
             * This method returns this UI element's disabled state as a boolean value.
             * @returns  - true if the element is disabled, false otherwise
             */
            isDisabled(): boolean;

            /**
             * This method set's the disabled state of this UI element.
             * @param disabled - true to disable the element, false to enable it
             * @param opt_force - an optional boolean flag indicating that the value should be set and propagated even if it is the same as the current state
             * @returns  - this element instance
             */
            setDisabled(disabled: boolean, opt_force?: boolean): ES6Element;

            /**
             * This method returns a previously stored arbitrary data from this element.
             * @returns  - the previously stored data object or null if not data was stored.
             */
            getData(): any;

            /**
             * This method stores arbitrary data with this UI element.
             * @param data - the data to be stored
             */
            setData(data: any): void;

            /**
             * This method returns the HTML element this UI element renders.
             * 
            Note: Before the UI element was rendered the method returns null.
             * @returns  - the element
            */
            getElement(): HTMLElement;

            /**
             * Sets the visibility of this element.
             * @param visibility - visibility
             */
            setVisibility(visibility: boolean): void;

            /**
             * Returns the visibility of this element.
             * @returns  - visibility
             */
            getVisibility(): boolean;

            /**
             * This method adds a CSS class to this UI element (if it is not already present).
             * @param className - the CSS class name to add
             * @returns  - this UI element instance
             */
            addClass(className: string): Element;

            /**
             * This method removes a CSS class from this UI element (if it is present).
             * @param className - the CSS class name to remove
             * @returns  - this UI element instance
             */
            removeClass(className: string): Element
        }
        declare     export class Element mixins undefined.EventTarget {

            /**
             * Constructor
             * @param opt_elementType - the type of HTML element this UI element renders as, default is 'div'
             * @param opt_className - an optional class name to be used on this element
             */
            constructor(opt_elementType?: string, opt_className?: string): this;

            /**
             * This method is the concrete implementation of the UI element. This method receives the pre-rendered HTML element which may be modified by deriving classes.
             * @param element - this UI element's HTML representation
             * @param doc - the HTML document into which the element is currently being rendered
             */
            renderInternal(element: ES6Element, doc: Document): void;

            /**
             * This method returns this UI element's disabled state as a boolean value.
             * @returns  - true if the element is disabled, false otherwise
             */
            isDisabled(): boolean;

            /**
             * This method set's the disabled state of this UI element.
             * @param disabled - true to disable the element, false to enable it
             * @param opt_force - an optional boolean flag indicating that the value should be set and propagated even if it is the same as the current state
             * @returns  - this element instance
             */
            setDisabled(disabled: boolean, opt_force?: boolean): ES6Element;

            /**
             * This method returns a previously stored arbitrary data from this element.
             * @returns  - the previously stored data object or null if not data was stored.
             */
            getData(): any;

            /**
             * This method stores arbitrary data with this UI element.
             * @param data - the data to be stored
             */
            setData(data: any): void;

            /**
             * This method returns the HTML element this UI element renders.
             * 
            Note: Before the UI element was rendered the method returns null.
             * @returns  - the element
            */
            getElement(): HTMLElement;

            /**
             * Sets the visibility of this element.
             * @param visibility - visibility
             */
            setVisibility(visibility: boolean): void;

            /**
             * Returns the visibility of this element.
             * @returns  - visibility
             */
            getVisibility(): boolean;

            /**
             * This method adds a CSS class to this UI element (if it is not already present).
             * @param className - the CSS class name to add
             * @returns  - this UI element instance
             */
            addClass(className: string): Element;

            /**
             * This method removes a CSS class from this UI element (if it is present).
             * @param className - the CSS class name to remove
             * @returns  - this UI element instance
             */
            removeClass(className: string): Element
        }
    }

    declare module 'i18n' {
        declare     export var defaultLocales: Array<string>;

        /**
         * This class is used for internationalization of UI components.
         */
        declare     export class Localization {
            constructor(locale: string, opt_translationMap?: any): this;

            /**
             * This method returns current locale code i.e 'en-US'
             * @returns  - locale code
             */
            getLocale(): string;

            /**
             * This method returns translation keys for current locale. Keys from this set can be used to get translations via translate method.
             * @returns  
             */
            getKeys(): Array<string>;

            /**
             * This method returns a boolean value indicating whether this localization object has a translation for the specified translation key.
             * @param key - a translation key
             * @returns  - true if the key exists, otherwise false
             */
            hasKey(key: string): boolean;

            /**
             * This method returns translation for provided key. It throws exception if translation is not available
             * @param key - a translation key
             * @returns  - a localized string corresponding to provided key
             */
            translate(key: string): string
        }
    }

}


declare module 'util' {

    /**
     * The cache represents a in-memory LRU-cache with a fixed size. It stores any data that is added until the cache's content exceeds a maximum size. Once the size of all content elements exceeds the maximum size the cache will drop the least recently retrieved elements until the size of the cache is within the bounds of its maximum size. Data elements are always associated with an identifier that allow to retrieve them at a later stage and their content size.
     */
    declare export class Cache mixins undefined.ICache {

        /**
         * Constructor
         * @param maxSize - the maximum size of the cache
         * @param opt_onDrop - A callback to be invoked when a data element is dropped from the cache
         * @param opt_filter - A function to filter data elements that are not to be cached
         */
        constructor(maxSize: number, opt_onDrop?: (s: string, i: any, n: number) => void, opt_filter?: (s: string, i: any, n: number) => boolean): this;

        /**
         * This method sets this cache's maximum size to a new size. If the cache's contents exceed the new size, least recently used data elements will be dropped.
         * @param maxSize - the new maximum size of this cache.
         * @returns  - this cache
         */
        setMaxSize(maxSize: number): undefined.Cache;

        /**
         * This method returns the maximum size of this cache.
         * @returns  - the maximum size of the cache
         */
        getMaxSize(): number;

        /**
         * This method returns the current size of this cache.
         * @returns  - the current size of the cache
         */
        getCurrentSize(): number;

        /**
         * This method adds an element to the cache.
         * @param id - The identifier of this data element, the value is converted to a string.
         * @param data - the actual data to be stored
         * @param size - the size of the data element
         * @returns  - a boolean value indicating whether the data was added
         */
        add(id: any, data: any, size: number): boolean;

        /**
         * This method retrieves an element from the cache.
         * @param id - the ID of the data element to be retrieved.
         * @param opt_noUpdate - and optional flag to indicate that the retrieved object should not be marked as 'most recently used'.
         * @returns  - returns the data associated with the ID or undefined if the data element is not currently in the cache.
         */
        get(id: string, opt_noUpdate?: boolean): any;

        /**
         * This method explicitly drops an element from the cache.
         * @param id - the id of the item to drop
         */
        drop(id: any): void;

        /**
         * This method will execute the provided callback function on each of the cache's entries. If the optional match predicate is passed to this method the callback will only be executed on those entries for which the predicated returns true.
         * @param callback - the callback to be invoked for each entry
         * @param opt_ctx - an optional context object to be used as this within the callback
         * @param opt_matcher - an optional match predicate to customize on which entries the callback will be called
         */
        forEach(
            callback: (s: string, i: any, n: number) => void,
            opt_ctx?: any,
            opt_matcher?: (s: string, i: any, n: number) => boolean): void;

        /**
         * This method removes all data elements from the cache. If the optional match predicate is passed to this method only those data elements will be removed for which the predicate return true.
         * @param opt_matcher - an optional function that receives an entries id, data and size and may return true or false to either remove it or leave the entry in the cache respectively
         */
        removeAll(opt_matcher?: (s: string, i: any, n: number) => boolean): void;

        /**
         * This method registers a callback that should be called each time an entry is dropped from the cache.
         * @param callback - the callback to be invoked for each entry
         */
        registerOnDrop(callback: (s: string, i: any, n: number) => void): void
    }

    /**
     * This event indicates a change. It contains the old and the new value.
     * @property  target {*} - Object which triggered the event
     * @property  currentTarget {*} - Object which has listener attached
     * @property  type {string} - Name of the dispatched event
     * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
     */
    declare export class ChangeEvent mixins undefined.Event {

        /**
         * Constructor
         * @param type - The type of the event
         * @param newValue - The new value of the property
         * @param oldValue - The previous value of the property
         */
        constructor(type: string, newValue: any, oldValue: any): this;

        /**
         * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
         */
        preventDefault(): void;

        /**
         * Stops propagation for current event.
         */
        stopPropagation(): void;
        target: any;
        currentTarget: any;
        type: string;
        defaultPrevented: boolean
    }
    declare module 'ContextItem' {

        /**
         * This type defines options which can be used to initialize the map.
         * @property  center {H.geo.IPoint=} - The initial center of the map, default is {lat:0, lng: 0}
         * @property  zoom {number=} - The initial zoom level of the map, default is 0 respectively the minimal zoom level of the base map
         * @property  bounds {H.geo.Rect=} - The view bounds to be displayed on the map. If provided, it takes precedence over center and zoom. and zoom if provided)
         * @property  layers {Array<H.map.layer.Layer>=} - A list of layers to render on top of the base map
         * @property  engineType: {H.Map.EngineType=} - The initial engine type to use, default is P2D
         * @property  pixelRatio {number} - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @property  imprint {H.map.Imprint.Options=} - The imprint options or null to suppress the imprint
         * @property  renderBaseBackground {H.Map.BackgroundRange=} - Object describes how many cached zoom levels should be used as a base map background while base map tiles are loading. Example: {lower: 3, higher: 2}
         * @property  autoColor {boolean=} - Indicates whether the UI's colors should automatically adjusted to the base layer, default is true. Up to now only the copyright style will be adjusted. See H.map.layer.Layer.Options#dark
         * @property  margin {number=} - The size in pixel of the supplemental area to render for each side of the map
         * @property  padding {H.map.ViewPort.Padding=} - The padding in pixels for each side of the map
         * @property  fixedCenter {boolean=} - Indicates whether the center of the map should remain unchanged if the viewport's size or padding has been changed, default is true
         */
        declare     export interface Options {
            center?: undefined.IPoint,
                zoom?: number,
                bounds?: undefined.Rect,
                layers?: Array<undefined.Layer>,
                engineType?: EngineType,
                pixelRatio?: number,
                imprint?: undefined.Options,
                renderBaseBackground?: BackgroundRange,
                autoColor?: boolean,
                margin?: number,
                padding?: undefined.Padding,
                fixedCenter?: boolean
        }
    }


    /**
     * Object which can be safely disposed.
     */
    declare export class Disposable {

        /**
         * Constructor
         */
        constructor(): this;

        /**
         * Method adds a callback which will be triggered when the object is disposed
         * @param callback * 
         * @param opt_scope 
         */
        addOnDisposeCallback(callback: Function, opt_scope?: Object): void
    }

    /**
     * Base Event class which is used for all events dispatched by any EventTarget within the api.
     * @property  target {*} - Object which triggered the event
     * @property  currentTarget {*} - Object which has listener attached
     * @property  type {string} - Name of the dispatched event
     * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
     */
    declare export class Event {

        /**
         * Constructor
         * @param type - Event Type.
         * @param opt_target - Reference to the object that is the target of this event. It has to implement the {
         * @link  EventTargetInstance} interface.
         */
        constructor(type: string, opt_target?: any): this;

        /**
         * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
         */
        preventDefault(): void;

        /**
         * Stops propagation for current event.
         */
        stopPropagation(): void;
        target: any;
        currentTarget: any;
        type: string;
        defaultPrevented: boolean
    }

    /**
     * EventTarget enabled listening and dispatching events on all instances and derived classes.
     */
    declare export class EventTarget {

        /**
         * Constructor
         */
        constructor(): this;

        /**
         * This method allows to listen for specific event triggered by the object. Keep in mind, that you must removeEventListener manually or dispose an object when you no longer need it. Otherwise memory leak is possible.
         * @param type - name of event
         * @param handler - event handler function
         * @param opt_capture - if set to true will listen in the capture phase (bubble otherwise)
         * @param opt_scope - scope for the handler function
         */
        addEventListener(
            type: string,
            handler: EventListenerOrEventListenerObject,
            opt_capture?: boolean,
            opt_scope?: any): void;

        /**
         * This method will removed previously added listener from the event target
         * @param type - name of event
         * @param handler - event handler function
         * @param opt_capture - if set to true will listen in the capture phase (bubble otherwise)
         * @param opt_scope - scope for the handler function
         */
        removeEventListener(
            type: string,
            handler: EventListenerOrEventListenerObject,
            opt_capture?: boolean,
            opt_scope?: any): void;

        /**
         * This method will dispatch event on the event target object
         * @param evt - event object or event name
         */
        dispatchEvent(evt: undefined.Event | string): void;

        /**
         * Removes listeners from this object. Classes that extend EventTarget may need to override this method in order to remove references to DOM Elements and additional listeners.
         */
        dispose(): void;

        /**
         * This method adds callback which is triggered when the object is being disposed
         * @param callback - The callback function.
         * @param opt_scope - An optional scope to call the callback in.
         */
        addOnDisposeCallback(callback: () => void, opt_scope?: any): void
    }

    /**
     * An interface definition for the generic cache. Any data elements can be stored in the cache. They are always associated with an identifier to retrieve them at a later stage and their content size.
     */
    declare export interface ICache {

        /**
         * This method adds an element to the cache.
         * @param id - The identifier of this data element, the value is converted to a string.
         * @param data - the actual data to be stored
         * @param size - the size of the data element
         * @returns  - a boolean value indicating whether the data was added
         */
        add(id: any, data: any, size: number): boolean,

            /**
             * This method retrieves an element from the cache.
             * @param id - the ID of the data element to be retrieved.
             * @param opt_noUpdate - and optional flag to indicate that the retrieved object should not be marked as 'most recently used'.
             * @returns  - returns the data associated with the ID or undefined if the data element is not currently in the cache.
             */
            get(id: string, opt_noUpdate?: boolean): any,

            /**
             * This method explicitly drops an element from the cache.
             * @param id - the id of the item to drop
             */
            drop(id: any): void,

            /**
             * This method will execute the provided callback function on each of the cache's entries. If the optional match predicate is passed to this method the callback will only be executed on those entries for which the predicated returns true.
             * @param callback - the callback to be invoked for each entry
             * @param opt_ctx - an optional context object to be used as this within the callback
             * @param opt_matcher - an optional match predicate to customize on which entries the callback will be called
             */
            forEach(
                callback: (s: string, t: any, n: number) => void,
                opt_ctx?: Object,
                opt_matcher?: ((s: string, t: any, n: number) => boolean)): void,

            /**
             * This method removes all data elements from the cache. If the optional match predicate is passed to this method only those data elements will be removed for which the predicate return true.
             * @param opt_matcher - an optional function that receives an entries id, data and size and may return true or false to either remove it or leave the entry in the cache respectively
             */
            removeAll(opt_matcher?: ((s: string, t: any, n: number) => boolean)): void,

            /**
             * This method registers a callback that should be called each time an entry is dropped from the cache.
             * @param callback - the callback to be invoked for each entry
             */
            registerOnDrop(callback: ((s: string, t: any, n: number) => void)): void
    }

    /**
     * An interface to cancelable requests and actions.
     */
    declare export interface ICancelable {

        /**
         * This method is used to cancel current action
         */
        cancel(): void
    }
    declare export interface ICapturable {

        /**
         * This method is used to capture the element view
         * @param canvas - HTML Canvas element to draw the view of the capturable element
         * @param pixelRation - The pixelRatio to use for over-sampling in cases of high-resolution displays, default is 1
         * @param callback ~captureCallback} - Callback function to call once result of the capturing is ready
         * @param opt_errback ~errorCallback} - Callback function to call if error occurred during capturing
         */
        capture(
            canvas: HTMLCanvasElement,
            pixelRation: number,
            callback: (canvas?: HTMLCanvasElement) => void,
            opt_errback?: (error: string) => void): void
    }
    declare module 'OList' {

        /**
         * The event class for events that are dispatched by OList
         * @property  target {*} - Object which triggered the event
         * @property  currentTarget {*} - Object which has listener attached
         * @property  type {string} - Name of the dispatched event
         * @property  defaultPrevented {boolean} - Indicates if preventDefault was called on the current event
         */
        declare     export class Event mixins undefined.Event {

            /**
             * Constructor
             * @param list - The OList instance which is emitting the event
             * @param type - The type of the event
             * @param idx - The affected index within this list
             * @param added - The value of the entry which was added or set
             * @param removed - The value of the entry which was removed or replaced
             * @param moved - The value of the entry which was moved
             */
            constructor(list: undefined.OList, type: string, idx: number, added: any, removed: any, moved: any): this;

            /**
             * Sets defaultPrevented to true. Which can be used to prevent some default behavior.
             */
            preventDefault(): void;

            /**
             * Stops propagation for current event.
             */
            stopPropagation(): void;
            target: any;
            currentTarget: any;
            type: string;
            defaultPrevented: boolean
        }
    }

    declare module 'Request' {
        declare     export interface Priority {}
    }

    declare module 'animation' {

        /**
         * This mamespace contains easing functions used for Animation class.
         */
        declare     export class ease {

            /**
             * This function defines linear ease.
             * @param val - A value in range [0..1] to translate
             * @returns  - the translated value
             */
            LINEAR(val: number): number;

            /**
             * This function defines quadratic ease in.
             * @param val - A value in range [0..1] to translate
             * @returns  - the translated value
             */
            EASE_IN_QUAD(val: number): number;

            /**
             * This function defines quadratic ease out.
             * @param val - A value in range [0..1] to translate
             * @returns  - the translated value
             */
            EASE_OUT_QUAD(val: number): number;

            /**
             * This function defines ease in and out with slope.
             * @param val - A value in range [0..1] to translate
             * @returns  - the translated value
             */
            EASE_IN_OUT_QUINT(val: number): number;

            /**
             * This function defines ease out with circ function.
             * @param val - A value in range [0..1] to translate
             * @returns  - the translated value
             */
            EASE_OUT_CIRC(val: number): number
        }
    }

    declare module 'kinetics' {

        /**
         * This interface defines kinetic move parameters used by map for kinetic drag.
         * @property  power {number} - Power multiplier. Multiplier is used to increase the speed of the kinetic move. By default map uses 1.
         * @property  duration {number} - Defines duration of the kinetic move.
         */
        declare     export interface IKinetics {

            /**
             * Easing function modifies animation progress. In example it can modify the animation in a way it starts rapidly and then slows down at the end.
             * @param p - current progress
             * @returns  - modified progress
             */
            ease(p: number): number,
                power: number,
                duration: number
        }
    }

}