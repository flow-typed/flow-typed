// @flow
/**
 * Flowtype definitions for openjscad
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$THREE: {
    OrbitControls: typeof THREE$OrbitControls,
    SpriteCanvasMaterial: typeof THREE$SpriteCanvasMaterial,
    RenderableObject: typeof THREE$RenderableObject,
    RenderableFace: typeof THREE$RenderableFace,
    RenderableVertex: typeof THREE$RenderableVertex,
    RenderableLine: typeof THREE$RenderableLine,
    RenderableSprite: typeof THREE$RenderableSprite,
    Projector: typeof THREE$Projector,
}
declare var CSG: {
    fromCSG: (
        csg: CSG,
        defaultColor: any) => {
        colorMesh: Mesh,
        wireframe: Mesh,
        boundLen: number
    },
    getGeometryVertex: (geometry: any, vertex_position: any) => number
};

declare function THREE$OrbitControls(object: any, domElement: any): void

declare function THREE$SpriteCanvasMaterial(parameters?: any): void

declare interface THREE$ICanvasRendererOptions {
    canvas?: HTMLCanvasElement,
        alpha?: boolean
}

declare class CanvasRenderer mixins Renderer {
    domElement: HTMLCanvasElement;
    constructor(parameters: THREE$ICanvasRendererOptions): this;
    supportsVertexTextures(): void;
    setFaceCulling: () => void;
    getPixelRatio(): number;
    setPixelRatio(value: any): void;
    setSize(width: any, height: any, updateStyle: any): void;
    setViewport(x: any, y: any, width: any, height: any): void;
    setScissor(): void;
    enableScissorTest(): void;
    setClearColor(color: any, alpha: any): void;
    setClearColorHex(hex: any, alpha: any): void;
    getClearColor(): Color;
    getClearAlpha(): number;
    getMaxAnisotropy(): number;
    clear(): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    render(
        scene: Scene,
        camera: Camera,
        renderTarget?: RenderTarget,
        forceClear?: boolean): void;
    calculateLights(): void;
    calculateLight(position: any, normal: any, color: any): void;
    renderSprite(v1: any, element: any, material: any): void;
    renderLine(v1: any, v2: any, element: any, material: any): void;
    renderFace3(
        v1: any,
        v2: any,
        v3: any,
        uv1: any,
        uv2: any,
        uv3: any,
        element: any,
        material: any): void;
    drawTriangle(x0: any, y0: any, x1: any, y1: any, x2: any, y2: any): void;
    strokePath(color: any, linewidth: any, linecap: any, linejoin: any): void;
    fillPath(color: any): void;
    onTextureUpdate(event: any): void;
    textureToPattern(texture: any): void;
    patternPath(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        texture: any): void;
    clipImage(
        x0: any,
        y0: any,
        x1: any,
        y1: any,
        x2: any,
        y2: any,
        u0: any,
        v0: any,
        u1: any,
        v1: any,
        u2: any,
        v2: any,
        image: any): void;
    expand(v1: any, v2: any, pixels: any): void;
    setOpacity(value: any): void;
    setBlending(value: any): void;
    setLineWidth(value: any): void;
    setLineCap(value: any): void;
    setLineJoin(value: any): void;
    setStrokeStyle(value: any): void;
    setFillStyle(value: any): void;
    setLineDash(value: any): void
}

declare function THREE$RenderableObject(): void

declare function THREE$RenderableFace(): void

declare function THREE$RenderableVertex(): void

declare function THREE$RenderableLine(): void

declare function THREE$RenderableSprite(): void

declare function THREE$Projector(): void
declare var npm$namespace$OpenJsCad: {
    makeAbsoluteUrl: typeof OpenJsCad$makeAbsoluteUrl,
    isChrome: typeof OpenJsCad$isChrome,
    runMainInWorker: typeof OpenJsCad$runMainInWorker,
    expandResultObjectArray: typeof OpenJsCad$expandResultObjectArray,
    checkResult: typeof OpenJsCad$checkResult,
    resultToCompactBinary: typeof OpenJsCad$resultToCompactBinary,
    resultFromCompactBinary: typeof OpenJsCad$resultFromCompactBinary,
    parseJsCadScriptSync: typeof OpenJsCad$parseJsCadScriptSync,
    parseJsCadScriptASync: typeof OpenJsCad$parseJsCadScriptASync,
    getWindowURL: typeof OpenJsCad$getWindowURL,
    textToBlobUrl: typeof OpenJsCad$textToBlobUrl,
    revokeBlobUrl: typeof OpenJsCad$revokeBlobUrl,
    FileSystemApiErrorHandler: typeof OpenJsCad$FileSystemApiErrorHandler,
    AlertUserOfUncaughtExceptions: typeof OpenJsCad$AlertUserOfUncaughtExceptions,
    getParamDefinitions: typeof OpenJsCad$getParamDefinitions,
}
declare interface OpenJsCad$ILog {
    (x: string): void,
    prevLogTime?: number
}

declare var log: OpenJsCad$ILog;

declare interface OpenJsCad$IViewerOptions {
    drawLines?: boolean,
        drawFaces?: boolean,
        color?: number[],
        bgColor?: number,
        noWebGL?: boolean
}

declare type OpenJsCad$ProcessorOptions = {
    verbose?: boolean,
    viewerwidth?: number,
    viewerheight?: number,
    viewerheightratio?: number
} & OpenJsCad$IViewerOptions


declare class Viewer {
    constructor(containerElm: any, size: any, options: OpenJsCad$IViewerOptions): this;
    createScene(drawAxes: any, axLen: any): void;
    createCamera(): void;
    createControls(canvas: any): void;
    webGLAvailable(): boolean;
    createRenderer(bool_noWebGL: any): void;
    render(): void;
    animate(): void;
    cancelAnimate(): void;
    refreshRenderer(bool_noWebGL: any): void;
    drawAxes(axLen: any): void;
    setCsg(csg: any, resetZoom: any): void;
    applyDrawOptions(): void;
    clear(): void;
    getUserMeshes(str?: any): THREE$Object3D[];
    resetZoom(r: any): void;
    parseSizeParams(): void;
    handleResize(): void
}

declare function OpenJsCad$makeAbsoluteUrl(url: any, baseurl: any): any

declare function OpenJsCad$isChrome(): boolean

declare function OpenJsCad$runMainInWorker(mainParameters: any): void

declare function OpenJsCad$expandResultObjectArray(result: any): any

declare function OpenJsCad$checkResult(result: any): void

declare function OpenJsCad$resultToCompactBinary(resultin: any): any

declare function OpenJsCad$resultFromCompactBinary(resultin: any): any

declare function OpenJsCad$parseJsCadScriptSync(script: any, mainParameters: any, debugging: any): any

declare function OpenJsCad$parseJsCadScriptASync(script: any, mainParameters: any, options: any, callback: any): Worker

declare function OpenJsCad$getWindowURL(): URL

declare function OpenJsCad$textToBlobUrl(txt: any): string

declare function OpenJsCad$revokeBlobUrl(url: any): void

declare function OpenJsCad$FileSystemApiErrorHandler(fileError: any, operation: any): void

declare function OpenJsCad$AlertUserOfUncaughtExceptions(): void

declare function OpenJsCad$getParamDefinitions(script: any): any[]

declare interface OpenJsCad$EventHandler {
    (ev?: Event): any
}


/**
 * options parameter:
 * - drawLines: display wireframe lines
- drawFaces: display surfaces
- bgColor: canvas background color
- color: object color
- viewerwidth, viewerheight: set rendering size. Works with any css unit.
     viewerheight can also be specified as a ratio to width, ie number e (0, 1]
- noWebGL: force render without webGL
- verbose: show additional info (currently only time used for rendering)
*/
declare interface OpenJsCad$ViewerSize {
    widthDefault: string,
        heightDefault: string,
        width: number,
        height: number,
        heightratio: number
}

declare class Processor {
    constructor(containerdiv: HTMLDivElement, options?: OpenJsCad$ProcessorOptions, onchange?: OpenJsCad$EventHandler): this;
    convertToSolid(obj: any): any;
    cleanOption(option: any, deflt: any): any;
    toggleDrawOption(str: any): boolean;
    setDrawOption(str: any, bool: any): void;
    handleResize(): void;
    createElements(): void;
    getFilenameForRenderedObject(): string;
    setRenderedObjects(obj: any): void;
    setSelectedObjectIndex(index: number): void;
    selectedFormat(): any;
    selectedFormatInfo(): any;
    updateDownloadLink(): void;
    clearViewer(): void;
    abort(): void;
    enableItems(): void;
    setOpenJsCadPath(path: string): void;
    addLibrary(lib: any): void;
    setError(txt: string): void;
    setDebugging(debugging: boolean): void;
    setJsCad(script: string, filename?: string): void;
    getParamValues(): {};
    rebuildSolid(): void;
    hasSolid(): boolean;
    isProcessing(): boolean;
    clearOutputFile(): void;
    generateOutputFile(): void;
    currentObjectToBlob(): any;
    supportedFormatsForCurrentObject(): string[];
    formatInfo(format: any): any;
    downloadLinkTextForCurrentObject(): string;
    generateOutputFileBlobUrl(): void;
    generateOutputFileFileSystem(): void;
    createParamControls(): void
}
declare interface Window {
    Worker: Worker,
        webkitURL: URL,
        requestFileSystem: any,
        webkitRequestFileSystem: any
}
declare interface IAMFStringOptions {
    unit: string
}
declare class CxG {
    toStlString(): string;
    toStlBinary(): void;
    toAMFString(AMFStringOptions?: IAMFStringOptions): void;
    getBounds(): CxG[];
    transform(matrix4x4: CSG$Matrix4x4): CxG;
    mirrored(plane: CSG$Plane): CxG;
    mirroredX(): CxG;
    mirroredY(): CxG;
    mirroredZ(): CxG;
    translate(v: number[]): CxG;
    translate(v: CSG$Vector3D): CxG;
    scale(f: CSG$Vector3D): CxG;
    rotateX(deg: number): CxG;
    rotateY(deg: number): CxG;
    rotateZ(deg: number): CxG;
    rotate(rotationCenter: CSG$Vector3D, rotationAxis: CSG$Vector3D, degrees: number): CxG;
    rotateEulerAngles(alpha: number, beta: number, gamma: number, position: number[]): CxG
}
declare interface ICenter {
    center(cAxes: string[]): CxG
}
declare class CSG mixins CxG, ICenter {
    polygons: CSG$Polygon[];
    properties: CSG$Properties;
    isCanonicalized: boolean;
    isRetesselated: boolean;
    cachedBoundingBox: CSG$Vector3D[];
    defaultResolution2D: number;
    defaultResolution3D: number;
    fromPolygons(polygons: CSG$Polygon[]): CSG;
    fromSlices(options: any): CSG;
    fromObject(obj: any): CSG;
    fromCompactBinary(bin: any): CSG;
    toPolygons(): CSG$Polygon[];
    union(csg: CSG[]): CSG;
    union(csg: CSG): CSG;
    unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    unionForNonIntersecting(csg: CSG): CSG;
    subtract(csg: CSG[]): CSG;
    subtract(csg: CSG): CSG;
    subtractSub(csg: CSG, retesselate: boolean, canonicalize: boolean): CSG;
    intersect(csg: CSG[]): CSG;
    intersect(csg: CSG): CSG;
    intersectSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean): CSG;
    invert(): CSG;
    transform1(matrix4x4: CSG$Matrix4x4): CSG;
    transform(matrix4x4: CSG$Matrix4x4): CSG;
    toString(): string;
    expand(radius: number, resolution: number): CSG;
    contract(radius: number, resolution: number): CSG;
    stretchAtPlane(normal: number[], point: number[], length: number): CSG;
    expandedShell(radius: number, resolution: number, unionWithThis: boolean): CSG;
    canonicalized(): CSG;
    reTesselated(): CSG;
    getBounds(): CSG$Vector3D[];
    mayOverlap(csg: CSG): boolean;
    cutByPlane(plane: CSG$Plane): CSG;
    connectTo(
        myConnector: CSG$Connector,
        otherConnector: CSG$Connector,
        mirror: boolean,
        normalrotation: number): CSG;
    setShared(shared: undefined.Shared): CSG;
    setColor(args: any): CSG;
    toCompactBinary(): {
        class: string,
        numPolygons: number,
        numVerticesPerPolygon: Uint32Array,
        polygonPlaneIndexes: Uint32Array,
        polygonSharedIndexes: Uint32Array,
        polygonVertices: Uint32Array,
        vertexData: Float64Array,
        planeData: Float64Array,
        shared: undefined.Shared[]
    };
    toPointCloud(cuberadius: any): CSG;
    getTransformationAndInverseTransformationToFlatLying(): any;
    getTransformationToFlatLying(): any;
    lieFlat(): CSG;
    projectToOrthoNormalBasis(orthobasis: CSG$OrthoNormalBasis): CAG;
    sectionCut(orthobasis: CSG$OrthoNormalBasis): CAG;
    fixTJunctions(): CSG;
    toTriangles(): any[];
    getFeatures(features: any): any;
    center(cAxes: string[]): CxG;
    toX3D(): Blob;
    toStlBinary(): Blob;
    toStlString(): string;
    toAMFString(m: IAMFStringOptions): Blob
}
declare class Polygon2D mixins CAG {
    constructor(points: CSG$Vector2D[]): this
}
declare class CAG mixins CxG, ICenter {
    sides: CAG$Side[];
    isCanonicalized: boolean;
    constructor(): this;
    fromSides(sides: CAG$Side[]): CAG;
    fromPoints(points: CSG$Vector2D[]): CAG;
    fromPointsNoCheck(points: CSG$Vector2D[]): CAG;
    fromFakeCSG(csg: CSG): CAG;
    linesIntersect(
        p0start: CSG$Vector2D,
        p0end: CSG$Vector2D,
        p1start: CSG$Vector2D,
        p1end: CSG$Vector2D): boolean;
    circle(options: CSG$ICircleOptions): CAG;
    rectangle(options: CSG$IRectangleOptions): CAG;
    roundedRectangle(options: any): CAG;
    fromCompactBinary(bin: any): CAG;
    toString(): string;
    _toCSGWall(z0: any, z1: any): CSG;
    _toVector3DPairs(m: CSG$Matrix4x4): CSG$Vector3D[][];
    _toPlanePolygons(options: any): CSG$Polygon[];
    _toWallPolygons(options: any): any[];
    union(cag: CAG[]): CAG;
    union(cag: CAG): CAG;
    subtract(cag: CAG[]): CAG;
    subtract(cag: CAG): CAG;
    intersect(cag: CAG[]): CAG;
    intersect(cag: CAG): CAG;
    transform(matrix4x4: CSG$Matrix4x4): CAG;
    area(): number;
    flipped(): CAG;
    getBounds(): CSG$Vector2D[];
    isSelfIntersecting(): boolean;
    expandedShell(radius: number, resolution: number): CAG;
    expand(radius: number, resolution: number): CAG;
    contract(radius: number, resolution: number): CAG;
    extrudeInOrthonormalBasis(orthonormalbasis: CSG$OrthoNormalBasis, depth: number, options?: any): CSG;
    extrudeInPlane(axis1: any, axis2: any, depth: any, options: any): CSG;
    extrude(options: CAG_extrude_options): CSG;
    rotateExtrude(options: any): CSG;
    check(): void;
    canonicalized(): CAG;
    toCompactBinary(): {
        class: string,
        sideVertexIndices: Uint32Array,
        vertexData: Float64Array
    };
    getOutlinePaths(): CSG$Path2D[];
    overCutInsideCorners(cutterradius: any): CAG;
    center(cAxes: string[]): CxG;
    toDxf(): Blob;
    PathsToDxf(paths: CSG$Path2D[]): Blob
}
declare class Vertex {
    pos: CSG$Vector2D;
    tag: number;
    constructor(pos: CSG$Vector2D): this;
    toString(): string;
    getTag(): number
}

declare class Side mixins CxG {
    vertex0: CAG$Vertex;
    vertex1: CAG$Vertex;
    tag: number;
    constructor(vertex0: CAG$Vertex, vertex1: CAG$Vertex): this;
    _fromFakePolygon(polygon: CSG$Polygon): CAG$Side;
    toString(): string;
    toPolygon3D(z0: any, z1: any): CSG$Polygon;
    transform(matrix4x4: CSG$Matrix4x4): CAG$Side;
    flipped(): CAG$Side;
    direction(): CSG$Vector2D;
    getTag(): number;
    lengthSquared(): number;
    length(): number
}

declare class fuzzyCAGFactory {
    vertexfactory: CSG$fuzzyFactory;
    constructor(): this;
    getVertex(sourcevertex: CAG$Vertex): CAG$Vertex;
    getSide(sourceside: CAG$Side): CAG$Side;
    getCAG(sourcecag: CAG): CAG
}
declare interface CAG_extrude_options {
    offset?: number[],
        twistangle?: number,
        twiststeps?: number
}