/**
 * Flowtype definitions for applicationinsights
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface AutoCollectConsole {
    constructor(client: Client): AutoCollectConsole,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface AutoCollectExceptions {
    constructor(client: Client): AutoCollectExceptions,
        isInitialized(): boolean,
        enable(isEnabled: boolean): void
}
declare interface AutoCollectPerformance {
    constructor(client: Client): AutoCollectPerformance,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface AutoCollectRequests {
    constructor(client: Client): AutoCollectRequests,
        enable(isEnabled: boolean): void,
        isInitialized(): boolean
}
declare interface ContractsModule$ContextTagKeys {
    applicationVersion: string,
        applicationBuild: string,
        deviceId: string,
        deviceIp: string,
        deviceLanguage: string,
        deviceLocale: string,
        deviceModel: string,
        deviceNetwork: string,
        deviceOEMName: string,
        deviceOS: string,
        deviceOSVersion: string,
        deviceRoleInstance: string,
        deviceRoleName: string,
        deviceScreenResolution: string,
        deviceType: string,
        deviceMachineName: string,
        locationIp: string,
        operationId: string,
        operationName: string,
        operationParentId: string,
        operationRootId: string,
        operationSyntheticSource: string,
        operationIsSynthetic: string,
        sessionId: string,
        sessionIsFirst: string,
        sessionIsNew: string,
        userAccountAcquisitionDate: string,
        userAccountId: string,
        userAgent: string,
        userId: string,
        userStoreRegion: string,
        sampleRate: string,
        internalSdkVersion: string,
        internalAgentVersion: string,
        constructor(): ContractsModule$ContextTagKeys
}

declare interface ContractsModule$Domain {
    ver: number,
        properties: any,
        constructor(): ContractsModule$Domain
}

declare interface ContractsModule$Data<TDomain>{
    baseType: string,
    baseData: TDomain,
    constructor(): ContractsModule$Data<TDomain >
}

declare interface ContractsModule$Envelope {
    ver: number,
        name: string,
        time: string,
        sampleRate: number,
        seq: string,
        iKey: string,
        flags: number,
        deviceId: string,
        os: string,
        osVer: string,
        appId: string,
        appVer: string,
        userId: string,
        tags: {
            [key: string]: string
        },
        data: ContractsModule$Data<ContractsModule$Domain>,
        constructor(): ContractsModule$Envelope
}

declare type ContractsModule$EventData = {
    ver: number,
    name: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$EventData
}

declare type ContractsModule$MessageData = {
    ver: number,
    message: string,
    severityLevel: ContractsModule$SeverityLevel,
    properties: any,
    constructor(): ContractsModule$MessageData
}

declare type ContractsModule$ExceptionData = {
    ver: number,
    handledAt: string,
    exceptions: ContractsModule$ExceptionDetails[],
    severityLevel: ContractsModule$SeverityLevel,
    problemId: string,
    crashThreadId: number,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$ExceptionData
}

declare interface ContractsModule$StackFrame {
    level: number,
        method: string,
        assembly: string,
        fileName: string,
        line: number,
        constructor(): ContractsModule$StackFrame
}

declare interface ContractsModule$ExceptionDetails {
    id: number,
        outerId: number,
        typeName: string,
        message: string,
        hasFullStack: boolean,
        stack: string,
        parsedStack: ContractsModule$StackFrame[],
        constructor(): ContractsModule$ExceptionDetails
}

declare interface ContractsModule$DataPoint {
    name: string,
        kind: ContractsModule$DataPointType,
        value: number,
        count: number,
        min: number,
        max: number,
        stdDev: number,
        constructor(): ContractsModule$DataPoint
}

declare type ContractsModule$MetricData = {
    ver: number,
    metrics: ContractsModule$DataPoint[],
    properties: any,
    constructor(): ContractsModule$MetricData
}

declare type ContractsModule$PageViewData = {
    ver: number,
    url: string,
    name: string,
    duration: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$PageViewData
}

declare type ContractsModule$PageViewPerfData = {
    ver: number,
    url: string,
    perfTotal: string,
    name: string,
    duration: string,
    networkConnect: string,
    sentRequest: string,
    receivedResponse: string,
    domProcessing: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$PageViewPerfData
}

declare type ContractsModule$RemoteDependencyData = {
    ver: number,
    name: string,
    kind: ContractsModule$DataPointType,
    value: number,
    count: number,
    min: number,
    max: number,
    stdDev: number,
    dependencyKind: ContractsModule$DependencyKind,
    success: boolean,
    async: boolean,
    dependencySource: ContractsModule$DependencySourceType,
    commandName: string,
    dependencyTypeName: string,
    properties: any,
    constructor(): ContractsModule$RemoteDependencyData
}

declare type ContractsModule$AjaxCallData = {
    ver: number,
    url: string,
    ajaxUrl: string,
    name: string,
    duration: string,
    requestSize: number,
    responseSize: number,
    timeToFirstByte: string,
    timeToLastByte: string,
    callbackDuration: string,
    responseCode: string,
    success: boolean,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$AjaxCallData
}

declare type ContractsModule$RequestData = {
    ver: number,
    id: string,
    name: string,
    startTime: string,
    duration: string,
    responseCode: string,
    success: boolean,
    httpMethod: string,
    url: string,
    properties: any,
    measurements: any,
    constructor(): ContractsModule$RequestData
}

declare type ContractsModule$SessionStateData = {
    ver: number,
    state: ContractsModule$SessionState,
    constructor(): ContractsModule$SessionStateData
}

declare type ContractsModule$PerformanceCounterData = {
    ver: number,
    categoryName: string,
    counterName: string,
    instanceName: string,
    kind: DataPointType,
    count: number,
    min: number,
    max: number,
    stdDev: number,
    value: number,
    properties: any,
    constructor(): ContractsModule$PerformanceCounterData
}
declare interface Channel {
    constructor(
            isDisabled: () => boolean,
            getBatchSize: () => number,
            getBatchIntervalMs: () => number,
            sender: Sender): Channel,

        /**
         * Add a telemetry item to the send buffer
         */
        send(envelope: ContractsModule$Envelope): void,
        handleCrash(envelope: ContractsModule$Envelope): void,

        /**
         * Immediately send buffered data
         */
        triggerSend(isNodeCrashing?: boolean): void
}
declare interface Client {
    config: Config,
        context: Context,
        commonProperties: {
            [key: string]: string
        },
        channel: Channel,

        /**
         * Constructs a new client of the client
         * @param iKey the instrumentation key to use (read from environment variable if not specified)
         */
        constructor(iKey?: string): Client,

        /**
         * Log a user action or other occurrence.
         * @param name A string to identify this event in the portal.
         * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
         * @param measurements map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
         */
        trackEvent(
            name: string,
            properties?: {
                [key: string]: string
            },
            measurements?: {
                [key: string]: number
            }): void,

        /**
         * Log a trace message
         * @param message A string to identify this event in the portal.
         * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
         */
        trackTrace(
            message: string,
            severityLevel?: ContractsModule$SeverityLevel,
            properties?: {
                [key: string]: string
            }): void,

        /**
         * Log an exception you have caught.
         * @param exception An Error from a catch clause, or the string error message.
         * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
         * @param measurements map[string, number] - metrics associated with this event, displayed in Metrics Explorer on the portal. Defaults to empty.
         */
        trackException(exception: Error, properties?: {
            [key: string]: string
        }): void,

        /**
         * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.
         * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the
        telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.
         * @param name A string that identifies the metric.
         * @param value The value of the metric
         * @param count the number of samples used to get this value
         * @param min the min sample for this set
         * @param max the max sample for this set
         * @param stdDev the standard deviation of the set
        */
        trackMetric(
            name: string,
            value: number,
            count?: number,
            min?: number,
            max?: number,
            stdDev?: number,
            properties?: {
                [key: string]: string
            }): void,

        /**
         * Log an incoming http request to your server. The request data will be tracked during the response "finish" event if it is successful or the request "error" 
         * event if it fails. The request duration is automatically calculated as the timespan between when the trackRequest method was called, and when the response "finish"
        or request "error" events were fired.
         * @param request The http.IncomingMessage object to track
         * @param response The http.ServerResponse object for this request
         * @param properties map[string, string] - additional data used to filter requests in the portal. Defaults to empty.
        */
        trackRequest(request: any, response: any, properties?: {
            [key: string]: string
        }): void,

        /**
         * Log an incoming http request to your server. The request data is tracked synchronously rather than waiting for the response "finish"" or request "error"" events.
         * Use this if you need your request telemetry to respect custom app insights operation and user context (for example if you set any appInsights.client.context.tags).
         * @param request The http.IncomingMessage object to track
         * @param response The http.ServerResponse object for this request
         * @param ellapsedMilliseconds The duration for this request. Defaults to 0.
         * @param properties map[string, string] - additional data used to filter requests in the portal. Defaults to empty.
         * @param error An error that was returned for this request if it was unsuccessful. Defaults to null.
         */
        trackRequestSync(
            request: any,
            response: any,
            ellapsedMilliseconds?: number,
            properties?: {
                [key: string]: string
            },
            error?: any): void,

        /**
         * Log information about a dependency of your app. Typically used to track the time database calls or outgoing http requests take from your server.
         * @param name The name of the dependency (i.e. "myDatabse")
         * @param commandname The name of the command executed on the dependency
         * @param elapsedTimeMs The amount of time in ms that the dependency took to return the result
         * @param success True if the dependency succeeded, false otherwise
         * @param dependencyTypeName The type of the dependency (i.e. "SQL" "HTTP"). Defaults to empty.
         * @param properties map[string, string] - additional data used to filter events and metrics in the portal. Defaults to empty.
         * @param dependencyKind ContractsModule.DependencyKind of this dependency. Defaults to Other.
         * @param async True if the dependency was executed asynchronously, false otherwise. Defaults to false
         * @param dependencySource ContractsModule.DependencySourceType of this dependency. Defaults to Undefined.
         */
        trackDependency(
            name: string,
            commandName: string,
            elapsedTimeMs: number,
            success: boolean,
            dependencyTypeName?: string,
            properties?: {},
            dependencyKind?: any,
            async?: boolean,
            dependencySource?: number): void,

        /**
         * Immediately send all queued telemetry.
         */
        sendPendingData(callback?: (response: string) => void): void,
        getEnvelope(
            data: ContractsModule$Data<ContractsModule$Domain>,
            tagOverrides?: {
                [key: string]: string
            }): ContractsModule$Envelope,

        /**
         * Generic track method for all telemetry types
         * @param data the telemetry to send
         * @param tagOverrides the context tags to use for this telemetry which overwrite default context values
         */
        track(
            data: ContractsModule$Data<ContractsModule$Domain>,
            tagOverrides?: {
                [key: string]: string
            }): void
}
declare interface Config {
    instrumentationKey: string,
        sessionRenewalMs: number,
        sessionExpirationMs: number,
        endpointUrl: string,
        maxBatchSize: number,
        maxBatchIntervalMs: number,
        disableAppInsights: boolean,
        constructor(instrumentationKey?: string): Config
}
declare interface Context {
    keys: ContractsModule$ContextTagKeys,
        tags: {
            [key: string]: string
        },
        constructor(packageJsonPath?: string): Context
}
declare interface Sender {
    constructor(
            getUrl: () => string,
            onSuccess?: (response: string) => void,
            onError?: (error: Error) => void): Sender,
        send(payload: any): void,
        saveOnCrash(payload: string): void,

        /**
         * enable caching events locally on error
         */
        enableCacheOnError(): void,

        /**
         * disable caching events locally on error
         */
        disableCacheOnError(): void
}
/**
 * The singleton meta interface for the default client of the client. This interface is used to setup/start and configure
 * the auto-collection behavior of the application insights module.
 */
declare interface ApplicationInsights {
    client: Client,

        /**
         * Initializes a client with the given instrumentation key, if this is not specified, the value will be
         * read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY
         * @returns  /Client} a new client
         */
        getClient(instrumentationKey?: string): Client,

        /**
         * Initializes the default client of the client and sets the default configuration
         * @param instrumentationKey the instrumentation key to use. Optional, if this is not specified, the value will be
        read from the environment variable APPINSIGHTS_INSTRUMENTATIONKEY
         * @returns  this interface
        */
        setup(instrumentationKey?: string): ApplicationInsights,

        /**
         * Starts automatic collection of telemetry. Prior to calling start no telemetry will be collected
         * @returns  this interface
         */
        start(): ApplicationInsights,

        /**
         * Sets the state of console tracking (enabled by default)
         * @param value if true console activity will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectConsole(value: boolean): ApplicationInsights,

        /**
         * Sets the state of exception tracking (enabled by default)
         * @param value if true uncaught exceptions will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectExceptions(value: boolean): ApplicationInsights,

        /**
         * Sets the state of performance tracking (enabled by default)
         * @param value if true performance counters will be collected every second and sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectPerformance(value: boolean): ApplicationInsights,

        /**
         * Sets the state of request tracking (enabled by default)
         * @param value if true requests will be sent to Application Insights
         * @returns  this interface
         */
        setAutoCollectRequests(value: boolean): ApplicationInsights,

        /**
         * Enables verbose debug logging
         * @returns  this interface
         */
        enableVerboseLogging(): ApplicationInsights
}
declare module 'applicationinsights' {
    declare var applicationinsights: ApplicationInsights;
    declare module.exports: typeof applicationinsights
}