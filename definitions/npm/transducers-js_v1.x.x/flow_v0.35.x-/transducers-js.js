/**
 * Flowtype definitions for transducers-js
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'transducers-js' {
    declare export interface IteratorResult<T>{
        done: boolean,
        value?: T
    }
    declare export interface Iterator<T>{
        next(value?: any): IteratorResult<T>,
        return (value?: any): IteratorResult<T>,
        throw (e?: any): IteratorResult<T >
    }
    declare export interface Reduced<TResult>{
        undefined: boolean,
        undefined: TResult
    }
    declare export interface Reducer<TResult, TInput>{
        (result: TResult, input: TInput): TResult
    }
    declare export interface Transducer<TResult, TInput, TOutput>{
        (xf: Transformer<TResult, TOutput>): Transformer<TResult,
        TInput >
    }
    declare export interface CompletingTransformer<TResult, TCompleteResult, TInput>{
        undefined(): TResult | void,
        undefined(result: TResult, input: TInput): TResult | Reduced<TResult>,
        undefined(result: TResult): TCompleteResult
    }
    declare export type Transformer<TResult, TInput>= {} & CompletingTransformer


    /**
     * Return a reduced value. Reduced values short circuit transduce.
     */
    declare export function reduced<TResult>(x: TResult): Reduced<TResult >

        /**
         * Check if a value is reduced.
         */
        declare export function isReduced(x: any): Boolean

    /**
     * Function composition. Take N function and return their composition.
     */
    declare export function comp<T>(...args: T[]): T

    /**
     * Take a predicate function and return its complement.
     */
    declare export function complement(f: Function): Function

    /**
     * Identity function.
     */
    declare export function identity<T>(arg: T): T
    declare export class Map<TResult, TInput, TOutput>mixins Transformer<TResult, TInput>{
        constructor(f: (x: TInput) => TOutput, xf: Transformer<TResult, TOutput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * Mapping transducer constructor
     */
    declare export function map<TResult, TInput, TOutput>(
            f: (x: TInput) => TOutput): Transducer<TResult, TInput, TOutput >
        declare export class Filter<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(pred: (x: TInput) => boolean, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * Filtering transducer constructor
     */
    declare export function filter<TResult, TInput>(
            pred: (x: TInput) => boolean): Transducer<TResult, TInput, TInput >

        /**
         * Similar to filter except the predicate is used to
         * eliminate values.
         */
        declare export function remove<TResult, TInput>(
            pred: (x: TInput) => boolean): Transducer<TResult, TInput, TInput >
        declare export class Keep<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(f: (x: TInput) => any, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A keeping transducer. Keep inputs as long as the provided
     * function does not return null or undefined.
     */
    declare export function keep<TResult, TInput>(f: (x: TInput) => any): Transducer<TResult, TInput, TInput >
        declare export class KeepIndexed<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(f: (i: number, x: TInput) => any, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * Like keep but the provided function will be passed the
     * index as the fist argument.
     */
    declare export function keepIndexed<TResult, TInput>(
            f: (i: number, x: TInput) => any): Transducer<TResult, TInput, TInput >
        declare export class Take<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(n: number, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult | Reduced<TResult>;
        undefined(result: TResult): TResult
    }

    /**
     * A take transducer constructor. Will take n values before
     * returning a reduced result.
     */
    declare export function take<TResult, TInput>(n: number): Transducer<TResult, TInput, TInput >
        declare export class TakeWhile<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(pred: (n: TInput) => boolean, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult | Reduced<TResult>;
        undefined(result: TResult): TResult
    }

    /**
     * Like the take transducer except takes as long as the pred
     * return true for inputs.
     */
    declare export function takeWhile<TResult, TInput>(
            pred: (n: TInput) => boolean): Transducer<TResult, TInput, TInput >
        declare export class TakeNth<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(n: number, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A transducer that takes every Nth input
     */
    declare export function takeNth<TResult, TInput>(n: number): Transducer<TResult, TInput, TInput >
        declare export class Drop<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(n: number, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A dropping transducer constructor
     */
    declare export function drop<TResult, TInput>(n: number): Transducer<TResult, TInput, TInput >
        declare export class DropWhile<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(pred: (input: TInput) => boolean, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A dropping transducer that drop inputs as long as
     * pred is true.
     */
    declare export function dropWhile<TResult, TInput>(
            pred: (input: TInput) => boolean): Transducer<TResult, TInput, TInput >
        declare export class PartitionBy<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(f: (input: TInput) => any, xf: Transformer<TResult, TInput[]>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A partitioning transducer. Collects inputs into
     * arrays as long as predicate remains true for contiguous
    inputs.
    */
    declare export function partitionBy<TResult, TInput>(
            f: (input: TInput) => any): Transducer<TResult, TInput, TInput[] >
        declare export class PartitionAll<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(n: number, xf: Transformer<TResult, TInput[]>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * A partitioning transducer. Collects inputs into
     * arrays of size N.
     */
    declare export function partitionAll<TResult, TInput>(n: number): Transducer<TResult, TInput, TInput[] >
        declare export class Completing<TResult, TCompleteResult, TInput>mixins CompletingTransformer<TResult, TCompleteResult, TInput>{
        constructor(cf: (result: TResult) => TCompleteResult, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TCompleteResult
    }

    /**
     * A completing transducer constructor. Useful to provide cleanup
     * logic at the end of a reduction/transduction.
     */
    declare export function completing<TResult, TCompleteResult, TInput>(
            cf: (result: TResult) => TCompleteResult): CompletingTransformer<TResult, TCompleteResult, TInput >
        declare export class Wrap<TResult, TInput>mixins Transformer<TResult, TInput>{
        constructor(stepFn: Reducer<TResult, TInput>, xf: Transformer<TResult, TInput>): this;
        undefined(): TResult;
        undefined(result: TResult, input: TInput): TResult;
        undefined(result: TResult): TResult
    }

    /**
     * Take a two-arity reducing function where the first argument is the
     * accumluation and the second argument is the next input and convert
    it into a transducer transformer object.
    */
    declare export function wrap<TResult, TInput>(
            stepFn: Reducer<TResult, TInput>): Transducer<TResult, TInput, TInput >

        /**
         * Given a transformer return a concatenating transformer
         */
        declare export function cat<TResult, TInput>(
            xf: Transformer<TResult, TInput>): Transformer<TResult, TInput >

        /**
         * A mapping concatenating transformer
         */
        declare export function mapcat<TResult, TInput, TOutput>(
            f: (arr: TInput[]) => TOutput[]): Transducer<TResult, TInput[], TOutput >

        /**
         * Given a transducer, a builder function, an initial value
         * and a iterable collection - returns the reduction.
         */
        declare export function transduce<TResult, TInput, TOutput>(
        xf: Transducer<TResult, TInput, TOutput>,
        f: Transformer<TResult, TInput>| Reducer<TResult, TInput>,
        init: TResult,
        coll: TInput[] | Iterator<TInput>| string | Object): TResult

    /**
     * Given a transducer, an intial value and a
     * collection - returns the reduction.
     */
    declare export function reduce<TResult, TInput, TOutput>(
        xf: Transducer<TResult, TInput, TOutput>,
        init: TResult,
        coll: TInput[] | Iterator<TInput>| string | Object): TResult

    /**
     * Reduce a value into the given empty value using a transducer.
     */
    declare export function into<TResult, TInput, TOutput>(
        empty: TResult,
        xf: Transducer<TResult, TInput, TOutput>,
        coll: TInput[] | Iterator<TInput>| string | Object): TResult

    /**
     * Convert a transducer transformer object into a function so
     * that it can be used with existing reduce implementation i.e. native,
    Underscore, lodash
    */
    declare export function toFn<TResult, TInput, TOutput>(
            xf: Transducer<TResult, TInput, TOutput>,
            builder: Reducer<TResult, TInput>| Transformer<TResult, TInput>): Reducer<TResult, TInput >

        /**
         * A transformer which simply returns the first input.
         */
        declare export function first<TResult, TInput>(): Wrap<TResult, TInput >

        /**
         * Ensure that a value is reduced. If already reduced will not re-wrap.
         */
        declare export function ensureReduced<TResult>(x: TResult | Reduced<TResult>): Reduced<TResult >

        /**
         * Ensure a value is not reduced. Unwraps if reduced.
         */
        declare export function unreduced<TResult>(x: TResult | Reduced<TResult>): TResult

    /**
     * Returns the value of a reduced result.
     */
    declare export function deref<TResult>(x: Reduced<TResult>): TResult
}