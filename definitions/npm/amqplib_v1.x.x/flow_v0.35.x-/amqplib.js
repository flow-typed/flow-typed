/**
 * Flowtype definitions for amqplib
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'amqplib/properties' {
    declare interface Replies$Empty {}

    declare interface Replies$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Replies$PurgeQueue {
        messageCount: number
    }

    declare interface Replies$DeleteQueue {
        messageCount: number
    }

    declare interface Replies$AssertExchange {
        exchange: string
    }

    declare interface Replies$Consume {
        consumerTag: string
    }
    declare interface Options$AssertQueue {
        queue: string,
            messageCount: number,
            consumerCount: number
    }

    declare interface Options$DeleteQueue {
        messageCount: number
    }

    declare interface Options$AssertExchange {
        exchange: string
    }

    declare interface Options$DeleteExchange {
        ifUnused?: boolean
    }

    declare interface Options$Publish {
        expiration?: string,
            userId?: string,
            CC?: string | string[],
            mandatory?: boolean,
            persistent?: boolean,
            deliveryMode?: boolean | number,
            BCC?: string | string[],
            contentType?: string,
            contentEncoding?: string,
            headers?: any,
            priority?: number,
            correlationId?: string,
            replyTo?: string,
            messageId?: string,
            timestamp?: number,
            type?: string,
            appId?: string
    }

    declare interface Options$Consume {
        consumerTag: string
    }

    declare interface Options$Get {
        noAck?: boolean
    }
    declare interface Message {
        content: Buffer,
            fields: any,
            properties: any
    }
}
declare module 'amqplib' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare function connect(url: string, socketOptions?: any): when.Promise<Connection >
}
declare module 'amqplib/callback_api' {
    declare type Connection = {
        close(): when.Promise<void>,
        createChannel(): when.Promise<Channel>,
        createConfirmChannel(): when.Promise<Channel >
    }
    declare type Channel = {
        close(): when.Promise<void>,
        assertQueue(
            queue: string,
            options?: Options$AssertQueue): when.Promise<Replies$AssertQueue>,
        checkQueue(queue: string): when.Promise<Replies$AssertQueue>,
        deleteQueue(
            queue: string,
            options?: Options$DeleteQueue): when.Promise<Replies$DeleteQueue>,
        purgeQueue(queue: string): when.Promise<Replies$PurgeQueue>,
        bindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindQueue(
            queue: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        assertExchange(
            exchange: string,
            type: string,
            options?: Options$AssertExchange): when.Promise<Replies$AssertExchange>,
        checkExchange(exchange: string): when.Promise<Replies$Empty>,
        deleteExchange(
            exchange: string,
            options?: Options$DeleteExchange): when.Promise<Replies$Empty>,
        bindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        unbindExchange(
            destination: string,
            source: string,
            pattern: string,
            args?: any): when.Promise<Replies$Empty>,
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish): boolean,
        sendToQueue(queue: string, content: Buffer, options?: Options$Publish): boolean,
        consume(
            queue: string,
            onMessage: (msg: Message) => any,
            options?: Options$Consume): when.Promise<Replies$Consume>,
        cancel(consumerTag: string): when.Promise<Replies$Empty>,
        get(queue: string, options?: Options$Get): when.Promise<Message | boolean>,
        ack(message: Message, allUpTo?: boolean): void,
        ackAll(): void,
        nack(message: Message, allUpTo?: boolean, requeue?: boolean): void,
        nackAll(requeue?: boolean): void,
        reject(message: Message, requeue?: boolean): void,
        prefetch(count: number, global?: boolean): when.Promise<Replies$Empty>,
        recover(): when.Promise<Replies$Empty >
    }
    declare type ConfirmChannel = {
        publish(
            exchange: string,
            routingKey: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        sendToQueue(
            queue: string,
            content: Buffer,
            options?: Options$Publish,
            callback?: (err: any, ok: Replies$Empty) => void): boolean,
        waitForConfirms(callback?: (err: any) => void): void
    } & Channel

    declare function connect(url: string, socketOptions?: any): when.Promise<Connection >
}