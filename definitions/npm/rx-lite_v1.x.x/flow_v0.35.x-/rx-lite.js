/**
 * Flowtype definitions for rx-lite
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module 'internals' {
    declare function isEqual(left: any, right: any): boolean
    declare function addRef<T>(
            xs: Rx$Observable<T>,
            r: {
                getDisposable(): Rx$IDisposable
            }): Rx$Observable<T >
        declare export class PriorityQueue<TTime>{
        constructor(capacity: number): this;
        length: number;
        isHigherPriority(left: number, right: number): boolean;
        percolate(index: number): void;
        heapify(index: number): void;
        peek(): ScheduledItem<TTime>;
        removeAt(index: number): void;
        dequeue(): ScheduledItem<TTime>;
        enqueue(item: ScheduledItem<TTime>): void;
        remove(item: ScheduledItem<TTime>): boolean;
        count: number
    }
    declare export class ScheduledItem<TTime>{
        constructor(scheduler: Rx$IScheduler, state: any, action: (scheduler: Rx$IScheduler, state: any) => Rx$IDisposable, dueTime: TTime, comparer?: (x: TTime, y: TTime) => number): this;
        scheduler: Rx$IScheduler;
        state: TTime;
        action: (scheduler: Rx$IScheduler, state: any) => Rx$IDisposable;
        dueTime: TTime;
        comparer: (x: TTime, y: TTime) => number;
        disposable: Rx$SingleAssignmentDisposable;
        invoke(): void;
        compareTo(other: ScheduledItem<TTime>): number;
        isCancelled(): boolean;
        invokeCore(): Rx$IDisposable
    }
}


declare module 'config' {
    declare export var Promise: {
        new<T>(
            resolver: (
                resolvePromise: (value: T) => void,
                rejectPromise: (reason: any) => void) => void): Rx$IPromise<T >
    };
}


declare module 'helpers' {
    declare function noop(): void
    declare function notDefined(value: any): boolean
    declare function identity<T>(value: T): T
    declare function defaultNow(): number
    declare function defaultComparer(left: any, right: any): boolean
    declare function defaultSubComparer(left: any, right: any): number
    declare function defaultKeySerializer(key: any): string
    declare function defaultError(err: any): void
    declare function isPromise(p: any): boolean
    declare function asArray<T>(...args: T[]): T[]
    declare function not(value: any): boolean
    declare function isFunction(value: any): boolean
}


declare
export interface Rx$IDisposable {
    dispose(): void
}

declare
export class CompositeDisposable mixins IDisposable {
    constructor(...disposables: Rx$IDisposable[]): this;
    constructor(disposables: Rx$IDisposable[]): this;
    isDisposed: boolean;
    length: number;
    dispose(): void;
    add(item: Rx$IDisposable): void;
    remove(item: Rx$IDisposable): boolean;
    toArray(): Rx$IDisposable[]
}

declare
export class Disposable mixins IDisposable {
    constructor(action: () => void): this;
    create(action: () => void): Rx$IDisposable;
    empty: Rx$IDisposable;
    dispose(): void
}

declare
export class SingleAssignmentDisposable mixins IDisposable {
    constructor(): this;
    isDisposed: boolean;
    current: Rx$IDisposable;
    dispose(): void;
    getDisposable(): Rx$IDisposable;
    setDisposable(value: Rx$IDisposable): void
}

declare
export class SerialDisposable mixins SingleAssignmentDisposable {
    constructor(): this
}

declare
export class RefCountDisposable mixins IDisposable {
    constructor(disposable: Rx$IDisposable): this;
    dispose(): void;
    isDisposed: boolean;
    getDisposable(): Rx$IDisposable
}

declare
export interface Rx$IScheduler {
    now(): number,
        isScheduler(value: any): boolean,
        schedule(action: () => void): Rx$IDisposable,
        scheduleWithState<TState>(
            state: TState,
            action: (scheduler: Rx$IScheduler, state: TState) => Rx$IDisposable): Rx$IDisposable,
        scheduleWithAbsolute(dueTime: number, action: () => void): Rx$IDisposable,
        scheduleWithAbsoluteAndState<TState>(
            state: TState,
            dueTime: number,
            action: (scheduler: Rx$IScheduler, state: TState) => Rx$IDisposable): Rx$IDisposable,
        scheduleWithRelative(dueTime: number, action: () => void): Rx$IDisposable,
        scheduleWithRelativeAndState<TState>(
            state: TState,
            dueTime: number,
            action: (scheduler: Rx$IScheduler, state: TState) => Rx$IDisposable): Rx$IDisposable,
        scheduleRecursive(action: (action: () => void) => void): Rx$IDisposable,
        scheduleRecursiveWithState<TState>(
            state: TState,
            action: (state: TState, action: (state: TState) => void) => void): Rx$IDisposable,
        scheduleRecursiveWithAbsolute(
            dueTime: number,
            action: (action: (dueTime: number) => void) => void): Rx$IDisposable,
        scheduleRecursiveWithAbsoluteAndState<TState>(
            state: TState,
            dueTime: number,
            action: (state: TState, action: (state: TState, dueTime: number) => void) => void): Rx$IDisposable,
        scheduleRecursiveWithRelative(
            dueTime: number,
            action: (action: (dueTime: number) => void) => void): Rx$IDisposable,
        scheduleRecursiveWithRelativeAndState<TState>(
            state: TState,
            dueTime: number,
            action: (state: TState, action: (state: TState, dueTime: number) => void) => void): Rx$IDisposable,
        schedulePeriodic(period: number, action: () => void): Rx$IDisposable,
        schedulePeriodicWithState<TState>(
            state: TState,
            period: number,
            action: (state: TState) => TState): Rx$IDisposable
}

declare
export type Rx$Scheduler = {} & Rx$IScheduler


declare
export interface Rx$SchedulerStatic {
    new(
        now: () => number,
        schedule: (
            state: any,
            action: (scheduler: Rx$IScheduler, state: any) => Rx$IDisposable) => Rx$IDisposable,
        scheduleRelative: (
            state: any,
            dueTime: number,
            action: (scheduler: Rx$IScheduler, state: any) => Rx$IDisposable) => Rx$IDisposable,
        scheduleAbsolute: (
            state: any,
            dueTime: number,
            action: (scheduler: Rx$IScheduler, state: any) => Rx$IDisposable) => Rx$IDisposable): Rx$Scheduler,
    normalize(timeSpan: number): number,
        immediate: Rx$IScheduler,
        currentThread: Rx$ICurrentThreadScheduler,
        default: Rx$IScheduler,
        timeout: Rx$IScheduler
}

declare
export var Scheduler: Rx$SchedulerStatic;

declare type Rx$ICurrentThreadScheduler = {
    scheduleRequired(): boolean
} & Rx$IScheduler


declare
export class Notification<T>{
    accept(observer: Rx$IObserver<T>): void;
    accept<TResult>(
        onNext: (value: T) => TResult,
        onError?: (exception: any) => TResult,
        onCompleted?: () => TResult): TResult;
    toObservable(scheduler?: Rx$IScheduler): Rx$Observable<T>;
    hasValue: boolean;
    equals(other: Rx$Notification<T>): boolean;
    kind: string;
    value: T;
    exception: any;
    createOnNext<T>(value: T): Rx$Notification<T>;
    createOnError<T>(exception: any): Rx$Notification<T>;
    createOnCompleted<T>(): Rx$Notification<T >
}


/**
 * Promise A+
 */
declare
export interface Rx$IPromise<T>{
    then<R>(
        onFulfilled: (value: T) => Rx$IPromise<R>,
        onRejected: (reason: any) => Rx$IPromise<R>): Rx$IPromise<R>,
    then<R>(
        onFulfilled: (value: T) => Rx$IPromise<R>,
        onRejected?: (reason: any) => R): Rx$IPromise<R>,
    then<R>(
        onFulfilled: (value: T) => R,
        onRejected: (reason: any) => Rx$IPromise<R>): Rx$IPromise<R>,
    then<R>(
        onFulfilled?: (value: T) => R,
        onRejected?: (reason: any) => R): Rx$IPromise<R >
}

declare
export interface Rx$IObserver<T>{
    onNext(value: T): void,
    onError(exception: any): void,
    onCompleted(): void
}

declare
export type Rx$Observer<T>= {
    toNotifier(): (notification: Rx$Notification<T>) => void,
    asObserver(): Rx$Observer<T >
} & Rx$IObserver


declare interface Rx$ObserverStatic {
    create<T>(
            onNext?: (value: T) => void,
            onError?: (exception: any) => void,
            onCompleted?: () => void): Rx$Observer<T>,
        fromNotifier<T>(
            handler: (notification: Rx$Notification<T>, thisArg?: any) => void): Rx$Observer<T >
}

declare
export var Observer: Rx$ObserverStatic;

declare
export interface Rx$IObservable<T>{
    subscribe(observer: Rx$Observer<T>): Rx$IDisposable,
    subscribe(
        onNext?: (value: T) => void,
        onError?: (exception: any) => void,
        onCompleted?: () => void): Rx$IDisposable,
    subscribeOnNext(onNext: (value: T) => void, thisArg?: any): Rx$IDisposable,
    subscribeOnError(onError: (exception: any) => void, thisArg?: any): Rx$IDisposable,
    subscribeOnCompleted(onCompleted: () => void, thisArg?: any): Rx$IDisposable
}

declare
export type Rx$Observable<T>= {
    forEach(
        onNext?: (value: T) => void,
        onError?: (exception: any) => void,
        onCompleted?: () => void): Rx$IDisposable,
    toArray(): Rx$Observable<T[]>,
    catch (handler: (exception: any) => Rx$Observable<T>): Rx$Observable<T>,
    catchException(handler: (exception: any) => Rx$Observable<T>): Rx$Observable<T>,
    catch (handler: (exception: any) => Rx$IPromise<T>): Rx$Observable<T>,
    catchException(handler: (exception: any) => Rx$IPromise<T>): Rx$Observable<T>,
    catch (second: Rx$Observable<T>): Rx$Observable<T>,
    catchException(second: Rx$Observable<T>): Rx$Observable<T>,
    combineLatest<T2>(second: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T, T2]>,
    combineLatest<T2,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        resultSelector: (v1: T, v2: T2) => TResult): Rx$Observable<TResult>,
    combineLatest<T2,
    T3>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T, T2, T3]>,
    combineLatest<T2,
    T3,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Rx$Observable<TResult>,
    combineLatest<T2,
    T3,
    T4>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T, T2, T3, T4]>,
    combineLatest<T2,
    T3,
    T4,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Rx$Observable<TResult>,
    combineLatest<T2,
    T3,
    T4,
    T5>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T, T2, T3, T4, T5]>,
    combineLatest<T2,
    T3,
    T4,
    T5,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Rx$Observable<TResult>,
    combineLatest<TOther,
    TResult>(
        souces: (Rx$Observable<TOther>| Rx$IPromise<TOther>)[],
        resultSelector: (firstValue: T, ...otherValues: TOther[]) => TResult): Rx$Observable<TResult>,
    withLatestFrom<T2>(second: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T, T2]>,
    withLatestFrom<T2,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        resultSelector: (v1: T, v2: T2) => TResult): Rx$Observable<TResult>,
    withLatestFrom<T2,
    T3>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T, T2, T3]>,
    withLatestFrom<T2,
    T3,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Rx$Observable<TResult>,
    withLatestFrom<T2,
    T3,
    T4>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T, T2, T3, T4]>,
    withLatestFrom<T2,
    T3,
    T4,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Rx$Observable<TResult>,
    withLatestFrom<T2,
    T3,
    T4,
    T5>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T, T2, T3, T4, T5]>,
    withLatestFrom<T2,
    T3,
    T4,
    T5,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Rx$Observable<TResult>,
    withLatestFrom<TOther,
    TResult>(
        souces: (Rx$Observable<TOther>| Rx$IPromise<TOther>)[],
        resultSelector: (firstValue: T, ...otherValues: TOther[]) => TResult): Rx$Observable<TResult>,
    concat(...sources: (Rx$Observable<T>| Rx$IPromise<T>)[]): Rx$Observable<T>,
    concat(sources: (Rx$Observable<T>| Rx$IPromise<T>)[]): Rx$Observable<T>,
    concatAll(): Rx$Observable<T>,
    concatObservable(): Rx$Observable<T>,
    concatMap<T2,
    R>(
        selector: (value: T, index: number) => Rx$Observable<T2>,
        resultSelector: (value1: T, value2: T2, index: number) => R): Rx$Observable<R>,
    concatMap<T2,
    R>(
        selector: (value: T, index: number) => Rx$IPromise<T2>,
        resultSelector: (value1: T, value2: T2, index: number) => R): Rx$Observable<R>,
    concatMap<R>(selector: (value: T, index: number) => Rx$Observable<R>): Rx$Observable<R>,
    concatMap<R>(selector: (value: T, index: number) => Rx$IPromise<R>): Rx$Observable<R>,
    concatMap<R>(selector: (value: T, index: number) => R[]): Rx$Observable<R>,
    concatMap<R>(sequence: Rx$Observable<R>): Rx$Observable<R>,
    concatMap<R>(sequence: R[]): Rx$Observable<R>,
    merge(maxConcurrent: number): T,
    merge(other: Rx$Observable<T>): Rx$Observable<T>,
    merge(other: Rx$IPromise<T>): Rx$Observable<T>,
    mergeAll(): Rx$Observable<T>,
    mergeObservable(): Rx$Observable<T>,
    skipUntil<T2>(other: Rx$Observable<T2>): Rx$Observable<T>,
    skipUntil<T2>(other: Rx$IPromise<T2>): Rx$Observable<T>,
    switch (): T,
    switchLatest(): T,
    takeUntil<T2>(other: Rx$Observable<T2>): Rx$Observable<T>,
    takeUntil<T2>(other: Rx$IPromise<T2>): Rx$Observable<T>,
    zip<T2>(second: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T, T2]>,
    zip<T2,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        resultSelector: (v1: T, v2: T2) => TResult): Rx$Observable<TResult>,
    zip<T2,
    T3>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T, T2, T3]>,
    zip<T2,
    T3,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Rx$Observable<TResult>,
    zip<T2,
    T3,
    T4>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T, T2, T3, T4]>,
    zip<T2,
    T3,
    T4,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Rx$Observable<TResult>,
    zip<T2,
    T3,
    T4,
    T5>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T, T2, T3, T4, T5]>,
    zip<T2,
    T3,
    T4,
    T5,
    TResult>(
        second: Rx$Observable<T2>| Rx$IPromise<T2>,
        third: Rx$Observable<T3>| Rx$IPromise<T3>,
        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
        fifth: Rx$Observable<T5>| Rx$IPromise<T5>,
        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Rx$Observable<TResult>,
    zip<TOther,
    TResult>(
        second: (Rx$Observable<TOther>| Rx$IPromise<TOther>)[],
        resultSelector: (left: T, ...right: TOther[]) => TResult): Rx$Observable<TResult>,
    asObservable(): Rx$Observable<T>,
    dematerialize<TOrigin>(): Rx$Observable<TOrigin>,
    distinctUntilChanged(skipParameter: boolean, comparer: (x: T, y: T) => boolean): Rx$Observable<T>,
    distinctUntilChanged<TValue>(
        keySelector?: (value: T) => TValue,
        comparer?: (x: TValue, y: TValue) => boolean): Rx$Observable<T>,
    do(observer: Rx$Observer<T>): Rx$Observable<T>,
    doAction(observer: Rx$Observer<T>): Rx$Observable<T>,
    tap(observer: Rx$Observer<T>): Rx$Observable<T>,
    do(
        onNext?: (value: T) => void,
        onError?: (exception: any) => void,
        onCompleted?: () => void): Rx$Observable<T>,
    doAction(
        onNext?: (value: T) => void,
        onError?: (exception: any) => void,
        onCompleted?: () => void): Rx$Observable<T>,
    tap(
        onNext?: (value: T) => void,
        onError?: (exception: any) => void,
        onCompleted?: () => void): Rx$Observable<T>,
    doOnNext(onNext: (value: T) => void, thisArg?: any): Rx$Observable<T>,
    doOnError(onError: (exception: any) => void, thisArg?: any): Rx$Observable<T>,
    doOnCompleted(onCompleted: () => void, thisArg?: any): Rx$Observable<T>,
    tapOnNext(onNext: (value: T) => void, thisArg?: any): Rx$Observable<T>,
    tapOnError(onError: (exception: any) => void, thisArg?: any): Rx$Observable<T>,
    tapOnCompleted(onCompleted: () => void, thisArg?: any): Rx$Observable<T>,
    finally(action: () => void): Rx$Observable<T>,
    finallyAction(action: () => void): Rx$Observable<T>,
    ignoreElements(): Rx$Observable<T>,
    materialize(): Rx$Observable<Rx$Notification<T >> ,
    repeat(repeatCount?: number): Rx$Observable<T>,
    retry(retryCount?: number): Rx$Observable<T>,
    retryWhen<TError>(
        notifier: (errors: Rx$Observable<TError>) => Rx$Observable<any>): Rx$Observable<T>,

    /**
     * Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.
     * For aggregation behavior with no intermediate results, see Observable.aggregate.
     * @example  *  var res = source.scan(function (acc, x) { return acc + x; });
    var res = source.scan(function (acc, x) { return acc + x; }, 0);
     * @param accumulator An accumulator function to be invoked on each element.
     * @param seed The initial accumulator value.
     * @returns  An observable sequence containing the accumulated values.
    */
    scan<TAcc>(
        accumulator: (acc: TAcc, value: T, index?: number, source?: Rx$Observable<TAcc>) => TAcc,
        seed: TAcc): Rx$Observable<TAcc>,
    scan(
        accumulator: (acc: T, value: T, index?: number, source?: Rx$Observable<T>) => T): Rx$Observable<T>,
    skipLast(count: number): Rx$Observable<T>,
    startWith(...values: T[]): Rx$Observable<T>,
    startWith(scheduler: Rx$IScheduler, ...values: T[]): Rx$Observable<T>,
    takeLast(count: number): Rx$Observable<T>,
    takeLastBuffer(count: number): Rx$Observable<T[]>,
    select<TResult>(
        selector: (value: T, index: number, source: Rx$Observable<T>) => TResult,
        thisArg?: any): Rx$Observable<TResult>,
    map<TResult>(
        selector: (value: T, index: number, source: Rx$Observable<T>) => TResult,
        thisArg?: any): Rx$Observable<TResult>,
    pluck<TResult>(prop: string): Rx$Observable<TResult>,
    selectMany<TOther,
    TResult>(
        selector: (value: T) => Rx$Observable<TOther>,
        resultSelector: (item: T, other: TOther) => TResult): Rx$Observable<TResult>,
    selectMany<TOther,
    TResult>(
        selector: (value: T) => Rx$IPromise<TOther>,
        resultSelector: (item: T, other: TOther) => TResult): Rx$Observable<TResult>,
    selectMany<TResult>(
        selector: (value: T) => Rx$Observable<TResult>): Rx$Observable<TResult>,
    selectMany<TResult>(selector: (value: T) => Rx$IPromise<TResult>): Rx$Observable<TResult>,
    selectMany<TResult>(other: Rx$Observable<TResult>): Rx$Observable<TResult>,
    selectMany<TResult>(other: Rx$IPromise<TResult>): Rx$Observable<TResult>,
    selectMany<TResult>(selector: (value: T) => TResult[]): Rx$Observable<TResult>,
    flatMap<TOther,
    TResult>(
        selector: (value: T) => Rx$Observable<TOther>,
        resultSelector: (item: T, other: TOther) => TResult): Rx$Observable<TResult>,
    flatMap<TOther,
    TResult>(
        selector: (value: T) => Rx$IPromise<TOther>,
        resultSelector: (item: T, other: TOther) => TResult): Rx$Observable<TResult>,
    flatMap<TResult>(
        selector: (value: T) => Rx$Observable<TResult>): Rx$Observable<TResult>,
    flatMap<TResult>(selector: (value: T) => Rx$IPromise<TResult>): Rx$Observable<TResult>,
    flatMap<TResult>(other: Rx$Observable<TResult>): Rx$Observable<TResult>,
    flatMap<TResult>(other: Rx$IPromise<TResult>): Rx$Observable<TResult>,
    flatMap<TResult>(selector: (value: T) => TResult[]): Rx$Observable<TResult>,

    /**
     * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
     * @param  A transform function to apply to each element; the second parameter of the function represents the index of the source element.
     * @param  A transform function to apply when an error occurs in the source sequence.
     * @param  A transform function to apply when the end of the source sequence is reached.
     * @param  An optional "this" to use to invoke each transform.
     * @returns  An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
     */
    selectManyObserver<T2,
    T3,
    T4>(
        onNext: (value: T, index: number) => Rx$Observable<T2>,
        onError: (exception: any) => Rx$Observable<T3>,
        onCompleted: () => Rx$Observable<T4>,
        thisArg?: any): Rx$Observable<T2 | T3 | T4>,

    /**
     * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
     * @param  A transform function to apply to each element; the second parameter of the function represents the index of the source element.
     * @param  A transform function to apply when an error occurs in the source sequence.
     * @param  A transform function to apply when the end of the source sequence is reached.
     * @param  An optional "this" to use to invoke each transform.
     * @returns  An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
     */
    flatMapObserver<T2,
    T3,
    T4>(
        onNext: (value: T, index: number) => Rx$Observable<T2>,
        onError: (exception: any) => Rx$Observable<T3>,
        onCompleted: () => Rx$Observable<T4>,
        thisArg?: any): Rx$Observable<T2 | T3 | T4>,
    selectConcat<T2,
    R>(
        selector: (value: T, index: number) => Rx$Observable<T2>,
        resultSelector: (value1: T, value2: T2, index: number) => R): Rx$Observable<R>,
    selectConcat<T2,
    R>(
        selector: (value: T, index: number) => Rx$IPromise<T2>,
        resultSelector: (value1: T, value2: T2, index: number) => R): Rx$Observable<R>,
    selectConcat<R>(selector: (value: T, index: number) => Rx$Observable<R>): Rx$Observable<R>,
    selectConcat<R>(selector: (value: T, index: number) => Rx$IPromise<R>): Rx$Observable<R>,
    selectConcat<R>(sequence: Rx$Observable<R>): Rx$Observable<R>,

    /**
     * Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
     * transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
     * @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
     * @param thisArg Object to use as this when executing callback.
     * @returns  An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
    and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
    */
    selectSwitch<TResult>(
        selector: (value: T, index: number, source: Rx$Observable<T>) => Rx$Observable<TResult>,
        thisArg?: any): Rx$Observable<TResult>,

    /**
     * Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
     * transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
     * @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
     * @param thisArg Object to use as this when executing callback.
     * @returns  An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
    and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
    */
    flatMapLatest<TResult>(
        selector: (value: T, index: number, source: Rx$Observable<T>) => Rx$Observable<TResult>,
        thisArg?: any): Rx$Observable<TResult>,

    /**
     * Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then
     * transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
     * @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
     * @param thisArg Object to use as this when executing callback.
     * @since  2.2.28
     * @returns  An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences
    and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
    */
    switchMap<TResult>(
        selector: (value: T, index: number, source: Rx$Observable<T>) => TResult,
        thisArg?: any): Rx$Observable<TResult>,
    skip(count: number): Rx$Observable<T>,
    skipWhile(
        predicate: (value: T, index: number, source: Rx$Observable<T>) => boolean,
        thisArg?: any): Rx$Observable<T>,
    take(count: number, scheduler?: Rx$IScheduler): Rx$Observable<T>,
    takeWhile(
        predicate: (value: T, index: number, source: Rx$Observable<T>) => boolean,
        thisArg?: any): Rx$Observable<T>,
    where(
        predicate: (value: T, index: number, source: Rx$Observable<T>) => boolean,
        thisArg?: any): Rx$Observable<T>,
    filter(
        predicate: (value: T, index: number, source: Rx$Observable<T>) => boolean,
        thisArg?: any): Rx$Observable<T>,

    /**
     * Converts an existing observable sequence to an ES6 Compatible Promise
     * @example  * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
     * @param promiseCtor The constructor of the promise.
     * @returns  An ES6 compatible promise with the last value from the observable sequence.
     */
    toPromise<TPromise>(
        promiseCtor: {
            new(
                resolver: (
                    resolvePromise: (value: T) => void,
                    rejectPromise: (reason: any) => void) => void): TPromise
        }): TPromise,

    /**
     * Converts an existing observable sequence to an ES6 Compatible Promise
     * @example  * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);

    // With config
    Rx.config.Promise = RSVP.Promise;
    var promise = Rx.Observable.return(42).toPromise();
     * @param promiseCtor The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
     * @returns  An ES6 compatible promise with the last value from the observable sequence.
    */
    toPromise(
        promiseCtor?: {
            new(
                resolver: (
                    resolvePromise: (value: T) => void,
                    rejectPromise: (reason: any) => void) => void): Rx$IPromise<T >
        }): Rx$IPromise<T>,

    /**
     * Performs a exclusive waiting for the first to finish before subscribing to another observable.
     * Observables that come in between subscriptions will be dropped on the floor.
    Can be applied on `Observable<Observable<R>>` or `Observable<IPromise<R>>`.
     * @since  2.2.28
     * @returns  A exclusive observable with only the results that happen when subscribed.
    */
    exclusive<R>(): Rx$Observable<R>,

    /**
     * Performs a exclusive map waiting for the first to finish before subscribing to another observable.
     * Observables that come in between subscriptions will be dropped on the floor.
    Can be applied on `Observable<Observable<I>>` or `Observable<IPromise<I>>`.
     * @since  2.2.28
     * @param selector Selector to invoke for every item in the current subscription.
     * @param thisArg An optional context to invoke with the selector parameter.
     * @returns  exclusive observable with only the results that happen when subscribed.
    */
    exclusiveMap<I,
    R>(
        selector: (value: I, index: number, source: Rx$Observable<I>) => R,
        thisArg?: any): Rx$Observable<R >
} & Rx$IObservable


declare interface Rx$ObservableStatic {
    create<T>(subscribe: (observer: Rx$Observer<T>) => Rx$IDisposable): Rx$Observable<T>,
        create<T>(subscribe: (observer: Rx$Observer<T>) => () => void): Rx$Observable<T>,
        create<T>(subscribe: (observer: Rx$Observer<T>) => void): Rx$Observable<T>,
        createWithDisposable<T>(subscribe: (observer: Rx$Observer<T>) => Rx$IDisposable): Rx$Observable<T>,
        defer<T>(observableFactory: () => Rx$Observable<T>): Rx$Observable<T>,
        defer<T>(observableFactory: () => Rx$IPromise<T>): Rx$Observable<T>,
        empty<T>(scheduler?: Rx$IScheduler): Rx$Observable<T>,

        /**
         * This method creates a new Observable sequence from an array object.
         * @param array An array-like or iterable object to convert to an Observable sequence.
         * @param mapFn Map function to call on every element of the array.
         * @param thisArg The context to use calling the mapFn if provided.
         * @param scheduler Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
         */
        from<T, TResult>(
            array: T[],
            mapFn: (value: T, index: number) => TResult,
            thisArg?: any,
            scheduler?: Rx$IScheduler): Rx$Observable<TResult>,

        /**
         * This method creates a new Observable sequence from an array object.
         * @param array An array-like or iterable object to convert to an Observable sequence.
         * @param mapFn Map function to call on every element of the array.
         * @param thisArg The context to use calling the mapFn if provided.
         * @param scheduler Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
         */
        from<T>(
            array: T[],
            mapFn?: (value: T, index: number) => T,
            thisArg?: any,
            scheduler?: Rx$IScheduler): Rx$Observable<T>,

        /**
         * This method creates a new Observable sequence from an array-like object.
         * @param array An array-like or iterable object to convert to an Observable sequence.
         * @param mapFn Map function to call on every element of the array.
         * @param thisArg The context to use calling the mapFn if provided.
         * @param scheduler Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
         */
        from<T, TResult>(
            array: {
                length: number,
                [index: number]: T
            },
            mapFn: (value: T, index: number) => TResult,
            thisArg?: any,
            scheduler?: Rx$IScheduler): Rx$Observable<TResult>,

        /**
         * This method creates a new Observable sequence from an array-like object.
         * @param array An array-like or iterable object to convert to an Observable sequence.
         * @param mapFn Map function to call on every element of the array.
         * @param thisArg The context to use calling the mapFn if provided.
         * @param scheduler Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
         */
        from<T>(
            array: {
                length: number,
                [index: number]: T
            },
            mapFn?: (value: T, index: number) => T,
            thisArg?: any,
            scheduler?: Rx$IScheduler): Rx$Observable<T>,

        /**
         * This method creates a new Observable sequence from an array-like or iterable object.
         * @param array An array-like or iterable object to convert to an Observable sequence.
         * @param mapFn Map function to call on every element of the array.
         * @param thisArg The context to use calling the mapFn if provided.
         * @param scheduler Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
         */
        from<T>(
            iterable: any,
            mapFn?: (value: any, index: number) => T,
            thisArg?: any,
            scheduler?: Rx$IScheduler): Rx$Observable<T>,
        fromArray<T>(array: T[], scheduler?: Rx$IScheduler): Rx$Observable<T>,
        fromArray<T>(
            array: {
                length: number,
                [index: number]: T
            },
            scheduler?: Rx$IScheduler): Rx$Observable<T>,
        generate<TState, TResult>(
            initialState: TState,
            condition: (state: TState) => boolean,
            iterate: (state: TState) => TState,
            resultSelector: (state: TState) => TResult,
            scheduler?: Rx$IScheduler): Rx$Observable<TResult>,
        never<T>(): Rx$Observable<T>,

        /**
         * This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
         * @example  *  var res = Rx.Observable.of(1, 2, 3);
         * @since  2.2.28
         * @returns  The observable sequence whose elements are pulled from the given arguments.
         */
        of<T>(...values: T[]): Rx$Observable<T>,

        /**
         * This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
         * @example  *  var res = Rx.Observable.ofWithScheduler(Rx.Scheduler.timeout, 1, 2, 3);
         * @since  2.2.28
         * @param scheduler A scheduler to use for scheduling the arguments.
         * @returns  The observable sequence whose elements are pulled from the given arguments.
         */
        ofWithScheduler<T>(scheduler?: Rx$IScheduler, ...values: T[]): Rx$Observable<T>,
        range(start: number, count: number, scheduler?: Rx$IScheduler): Rx$Observable<number>,
        repeat<T>(value: T, repeatCount?: number, scheduler?: Rx$IScheduler): Rx$Observable<T>,
        return <T>(value: T, scheduler?: Rx$IScheduler): Rx$Observable<T>,

            /**
             * 
             * @since  2.2.28
             */
            just<T>(value: T, scheduler?: Rx$IScheduler): Rx$Observable<T>,
            returnValue<T>(value: T, scheduler?: Rx$IScheduler): Rx$Observable<T>,
            throw <T>(exception: Error, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                throw <T>(exception: any, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                    throwException<T>(exception: Error, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                    throwException<T>(exception: any, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                    throwError<T>(error: Error, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                    throwError<T>(error: any, scheduler?: Rx$IScheduler): Rx$Observable<T>,
                    catch<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catch<T>(sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    catchException<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catchException<T>(sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    catchError<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catchError<T>(sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    catch<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catch<T>(...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    catchException<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catchException<T>(...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    catchError<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    catchError<T>(...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    combineLatest<T, T2>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T, T2]>,
                    combineLatest<T, T2, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        resultSelector: (v1: T, v2: T2) => TResult): Rx$Observable<TResult>,
                    combineLatest<T, T2, T3>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T, T2, T3]>,
                    combineLatest<T, T2, T3, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Rx$Observable<TResult>,
                    combineLatest<T, T2, T3, T4>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T, T2, T3, T4]>,
                    combineLatest<T, T2, T3, T4, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Rx$Observable<TResult>,
                    combineLatest<T, T2, T3, T4, T5>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        fifth: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T, T2, T3, T4, T5]>,
                    combineLatest<T, T2, T3, T4, T5, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        fifth: Rx$Observable<T5>| Rx$IPromise<T5>,
                        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Rx$Observable<TResult>,
                    combineLatest<T>(sources: (Rx$Observable<T>| Rx$IPromise<T>)[]): Rx$Observable<T[]>,
                    combineLatest<TOther, TResult>(
                        sources: (Rx$Observable<TOther>| Rx$IPromise<TOther>)[],
                        resultSelector: (...otherValues: TOther[]) => TResult): Rx$Observable<TResult>,
                    withLatestFrom<T, T2>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T, T2]>,
                    withLatestFrom<T, T2, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        resultSelector: (v1: T, v2: T2) => TResult): Rx$Observable<TResult>,
                    withLatestFrom<T, T2, T3>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T, T2, T3]>,
                    withLatestFrom<T, T2, T3, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Rx$Observable<TResult>,
                    withLatestFrom<T, T2, T3, T4>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T, T2, T3, T4]>,
                    withLatestFrom<T, T2, T3, T4, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Rx$Observable<TResult>,
                    withLatestFrom<T, T2, T3, T4, T5>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        fifth: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T, T2, T3, T4, T5]>,
                    withLatestFrom<T, T2, T3, T4, T5, TResult>(
                        first: Rx$Observable<T>| Rx$IPromise<T>,
                        second: Rx$Observable<T2>| Rx$IPromise<T2>,
                        third: Rx$Observable<T3>| Rx$IPromise<T3>,
                        fourth: Rx$Observable<T4>| Rx$IPromise<T4>,
                        fifth: Rx$Observable<T5>| Rx$IPromise<T5>,
                        resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Rx$Observable<TResult>,
                    withLatestFrom<TOther, TResult>(
                        souces: (Rx$Observable<TOther>| Rx$IPromise<TOther>)[],
                        resultSelector: (...otherValues: TOther[]) => TResult): Rx$Observable<TResult>,
                    concat<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    concat<T>(...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    concat<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    concat<T>(sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    merge<T>(...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    merge<T>(...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    merge<T>(sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    merge<T>(sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    merge<T>(scheduler: Rx$IScheduler, ...sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    merge<T>(scheduler: Rx$IScheduler, ...sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    merge<T>(scheduler: Rx$IScheduler, sources: Rx$Observable<T>[]): Rx$Observable<T>,
                    merge<T>(scheduler: Rx$IScheduler, sources: Rx$IPromise<T>[]): Rx$Observable<T>,
                    pairs<T>(
                        obj: {
                            [key: string]: T
                        },
                        scheduler?: Rx$IScheduler): Rx$Observable<[string, T]>,
                    zip<T1, T2>(
                        first: Rx$Observable<T1>| Rx$IPromise<T1>,
                        sources: (Rx$Observable<T2>| Rx$IPromise<T2>)[]): Rx$Observable<[T1, T2]>,
                    zip<T1, T2, TResult>(
                        first: Rx$Observable<T1>| Rx$IPromise<T1>,
                        sources: (Rx$Observable<T2>| Rx$IPromise<T2>)[],
                        resultSelector: (item1: T1, ...right: T2[]) => TResult): Rx$Observable<TResult>,
                    zip<T1, T2>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>): Rx$Observable<[T1, T2]>,
                    zip<T1, T2, TResult>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        resultSelector: (item1: T1, item2: T2) => TResult): Rx$Observable<TResult>,
                    zip<T1, T2, T3>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>): Rx$Observable<[T1, T2, T3]>,
                    zip<T1, T2, T3, TResult>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>,
                        resultSelector: (item1: T1, item2: T2, item3: T3) => TResult): Rx$Observable<TResult>,
                    zip<T1, T2, T3, T4>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>,
                        source4: Rx$Observable<T4>| Rx$IPromise<T4>): Rx$Observable<[T1, T2, T3, T4]>,
                    zip<T1, T2, T3, T4, TResult>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>,
                        source4: Rx$Observable<T4>| Rx$IPromise<T4>,
                        resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Rx$Observable<TResult>,
                    zip<T1, T2, T3, T4, T5>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>,
                        source4: Rx$Observable<T4>| Rx$IPromise<T4>,
                        source5: Rx$Observable<T5>| Rx$IPromise<T5>): Rx$Observable<[T1, T2, T3, T4, T5]>,
                    zip<T1, T2, T3, T4, T5, TResult>(
                        source1: Rx$Observable<T1>| Rx$IPromise<T1>,
                        source2: Rx$Observable<T2>| Rx$IPromise<T2>,
                        source3: Rx$Observable<T3>| Rx$IPromise<T3>,
                        source4: Rx$Observable<T4>| Rx$IPromise<T4>,
                        source5: Rx$Observable<T5>| Rx$IPromise<T5>,
                        resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5) => TResult): Rx$Observable<TResult>,
                    zipArray<T>(...sources: (Rx$Observable<T>| Rx$IPromise<T>)[]): Rx$Observable<T[]>,
                    zipArray<T>(sources: (Rx$Observable<T>| Rx$IPromise<T>)[]): Rx$Observable<T[]>,

                    /**
                     * Converts a Promise to an Observable sequence
                     * @param promise An ES6 Compliant promise.
                     * @returns  An Observable sequence which wraps the existing promise success and failure.
                     */
                    fromPromise<T>(promise: Rx$IPromise<T>): Rx$Observable<T>,
                    prototype: any
}

declare
export var Observable: Rx$ObservableStatic;

declare type Rx$ISubject<T>= {
    hasObservers(): boolean
} & Rx$Observable & Rx$Observer & Rx$IDisposable


declare
export type Rx$Subject<T>= {} & Rx$ISubject


declare interface Rx$SubjectStatic {
    new<T>(): Rx$Subject<T>,
        create<T>(observer?: Rx$Observer<T>, observable?: Rx$Observable<T>): Rx$ISubject<T >
}

declare
export var Subject: Rx$SubjectStatic;

declare
export type Rx$AsyncSubject<T>= {} & Rx$Subject


declare interface Rx$AsyncSubjectStatic {
    new<T>(): Rx$AsyncSubject<T >
}

declare
export var AsyncSubject: Rx$AsyncSubjectStatic;