// @flow
/**
 * Flowtype definitions for three
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */


declare var npm$namespace$THREE: {
    warn: typeof THREE$warn,
    error: typeof THREE$error,
    log: typeof THREE$log,
}
declare export var REVISION: string;

declare export var CullFaceNone: CullFace;

declare export var CullFaceBack: CullFace;

declare export var CullFaceFront: CullFace;

declare export var CullFaceFrontBack: CullFace;

declare export var FrontFaceDirectionCW: FrontFaceDirection;

declare export var FrontFaceDirectionCCW: FrontFaceDirection;

declare export var BasicShadowMap: ShadowMapType;

declare export var PCFShadowMap: ShadowMapType;

declare export var PCFSoftShadowMap: ShadowMapType;

declare export var FrontSide: Side;

declare export var BackSide: Side;

declare export var DoubleSide: Side;

declare export var FlatShading: Shading;

declare export var SmoothShading: Shading;

declare export var NoColors: Colors;

declare export var FaceColors: Colors;

declare export var VertexColors: Colors;

declare export var NoBlending: Blending;

declare export var NormalBlending: Blending;

declare export var AdditiveBlending: Blending;

declare export var SubtractiveBlending: Blending;

declare export var MultiplyBlending: Blending;

declare export var CustomBlending: Blending;

declare export var AddEquation: BlendingEquation;

declare export var SubtractEquation: BlendingEquation;

declare export var ReverseSubtractEquation: BlendingEquation;

declare export var MinEquation: BlendingEquation;

declare export var MaxEquation: BlendingEquation;

declare export var ZeroFactor: BlendingDstFactor;

declare export var OneFactor: BlendingDstFactor;

declare export var SrcColorFactor: BlendingDstFactor;

declare export var OneMinusSrcColorFactor: BlendingDstFactor;

declare export var SrcAlphaFactor: BlendingDstFactor;

declare export var OneMinusSrcAlphaFactor: BlendingDstFactor;

declare export var DstAlphaFactor: BlendingDstFactor;

declare export var OneMinusDstAlphaFactor: BlendingDstFactor;

declare export var DstColorFactor: BlendingSrcFactor;

declare export var OneMinusDstColorFactor: BlendingSrcFactor;

declare export var SrcAlphaSaturateFactor: BlendingSrcFactor;

declare export var NeverDepth: DepthModes;

declare export var AlwaysDepth: DepthModes;

declare export var LessDepth: DepthModes;

declare export var LessEqualDepth: DepthModes;

declare export var EqualDepth: DepthModes;

declare export var GreaterEqualDepth: DepthModes;

declare export var GreaterDepth: DepthModes;

declare export var NotEqualDepth: DepthModes;

declare export var MultiplyOperation: Combine;

declare export var MixOperation: Combine;

declare export var AddOperation: Combine;

declare export var NoToneMapping: ToneMapping;

declare export var LinearToneMapping: ToneMapping;

declare export var ReinhardToneMapping: ToneMapping;

declare export var Uncharted2ToneMapping: ToneMapping;

declare export var CineonToneMapping: ToneMapping;

declare export var UVMapping: Mapping;

declare export var CubeReflectionMapping: Mapping;

declare export var CubeRefractionMapping: Mapping;

declare export var EquirectangularReflectionMapping: Mapping;

declare export var EquirectangularRefractionMapping: Mapping;

declare export var SphericalReflectionMapping: Mapping;

declare export var CubeUVReflectionMapping: Mapping;

declare export var CubeUVRefractionMapping: Mapping;

declare export var RepeatWrapping: Wrapping;

declare export var ClampToEdgeWrapping: Wrapping;

declare export var MirroredRepeatWrapping: Wrapping;

declare export var NearestFilter: TextureFilter;

declare export var NearestMipMapNearestFilter: TextureFilter;

declare export var NearestMipMapLinearFilter: TextureFilter;

declare export var LinearFilter: TextureFilter;

declare export var LinearMipMapNearestFilter: TextureFilter;

declare export var LinearMipMapLinearFilter: TextureFilter;

declare export var UnsignedByteType: TextureDataType;

declare export var ByteType: TextureDataType;

declare export var ShortType: TextureDataType;

declare export var UnsignedShortType: TextureDataType;

declare export var IntType: TextureDataType;

declare export var UnsignedIntType: TextureDataType;

declare export var FloatType: TextureDataType;

declare export var HalfFloatType: TextureDataType;

declare export var UnsignedShort4444Type: PixelType;

declare export var UnsignedShort5551Type: PixelType;

declare export var UnsignedShort565Type: PixelType;

declare export var UnsignedInt248Type: PixelType;

declare export var AlphaFormat: PixelFormat;

declare export var RGBFormat: PixelFormat;

declare export var RGBAFormat: PixelFormat;

declare export var LuminanceFormat: PixelFormat;

declare export var LuminanceAlphaFormat: PixelFormat;

declare export var RGBEFormat: PixelFormat;

declare export var DepthFormat: PixelFormat;

declare export var DepthStencilFormat: PixelFormat;

declare export var RGB_S3TC_DXT1_Format: CompressedPixelFormat;

declare export var RGBA_S3TC_DXT1_Format: CompressedPixelFormat;

declare export var RGBA_S3TC_DXT3_Format: CompressedPixelFormat;

declare export var RGBA_S3TC_DXT5_Format: CompressedPixelFormat;

declare export var RGB_PVRTC_4BPPV1_Format: CompressedPixelFormat;

declare export var RGB_PVRTC_2BPPV1_Format: CompressedPixelFormat;

declare export var RGBA_PVRTC_4BPPV1_Format: CompressedPixelFormat;

declare export var RGBA_PVRTC_2BPPV1_Format: CompressedPixelFormat;

declare export var RGB_ETC1_Format: CompressedPixelFormat;

declare export var LoopOnce: AnimationActionLoopStyles;

declare export var LoopRepeat: AnimationActionLoopStyles;

declare export var LoopPingPong: AnimationActionLoopStyles;

declare export var InterpolateDiscrete: InterpolationModes;

declare export var InterpolateLinear: InterpolationModes;

declare export var InterpolateSmooth: InterpolationModes;

declare export var ZeroCurvatureEnding: InterpolationEndingModes;

declare export var ZeroSlopeEnding: InterpolationEndingModes;

declare export var WrapAroundEnding: InterpolationEndingModes;

declare export var TrianglesDrawModesMode: TrianglesDrawModes;

declare export var TriangleStripDrawMode: TrianglesDrawModes;

declare export var TriangleFanDrawMode: TrianglesDrawModes;

declare export var LinearEncoding: TextureEncoding;

declare export var sRGBEncoding: TextureEncoding;

declare export var GammaEncoding: TextureEncoding;

declare export var RGBEEncoding: TextureEncoding;

declare export var LogLuvEncoding: TextureEncoding;

declare export var RGBM7Encoding: TextureEncoding;

declare export var RGBM16Encoding: TextureEncoding;

declare export var RGBDEncoding: TextureEncoding;

declare export var BasicDepthPacking: DepthPackingStrategies;

declare export var RGBADepthPacking: DepthPackingStrategies;

declare export function THREE$warn(message?: any, ...optionalParams: any[]): void

declare export function THREE$error(message?: any, ...optionalParams: any[]): void

declare export function THREE$log(message?: any, ...optionalParams: any[]): void

declare export class AnimationAction {
    loop: boolean;
    time: number;
    timeScale: number;
    weight: number;
    repetitions: number;
    paused: boolean;
    enabled: boolean;
    clampWhenFinished: boolean;
    zeroSlopeAtStart: boolean;
    zeroSlopeAtEnd: boolean;
    play(): THREE$AnimationAction;
    stop(): THREE$AnimationAction;
    reset(): THREE$AnimationAction;
    isRunning(): boolean;
    startAt(time: number): THREE$AnimationAction;
    setLoop(mode: boolean, repetitions: number): THREE$AnimationAction;
    setEffectiveWeight(weight: number): THREE$AnimationAction;
    getEffectiveWeight(): number;
    fadeIn(duration: number): THREE$AnimationAction;
    fadeOut(duration: number): THREE$AnimationAction;
    crossFadeFrom(
        fadeOutAction: THREE$AnimationAction,
        duration: number,
        warp: boolean): THREE$AnimationAction;
    crossFadeTo(
        fadeInAction: THREE$AnimationAction,
        duration: number,
        warp: boolean): THREE$AnimationAction;
    stopFading(): THREE$AnimationAction;
    setEffectiveTimeScale(timeScale: number): THREE$AnimationAction;
    getEffectiveTimeScale(): number;
    setDuration(duration: number): THREE$AnimationAction;
    syncWith(action: THREE$AnimationAction): THREE$AnimationAction;
    halt(duration: number): THREE$AnimationAction;
    warp(
        statTimeScale: number,
        endTimeScale: number,
        duration: number): THREE$AnimationAction;
    stopWarping(): THREE$AnimationAction;
    getMixer(): THREE$AnimationMixer;
    getClip(): THREE$AnimationClip;
    getRoot(): any
}

declare export class AnimationClip {
    constructor(name?: string, duration?: number, tracks?: THREE$KeyframeTrack[]): this;
    name: string;
    tracks: THREE$KeyframeTrack[];
    duration: number;
    uuid: string;
    results: any[];
    resetDuration(): void;
    trim(): THREE$AnimationClip;
    optimize(): THREE$AnimationClip;
    CreateFromMorphTargetSequence(
        name: string,
        morphTargetSequence: THREE$MorphTarget[],
        fps: number,
        noLoop: boolean): THREE$AnimationClip;
    findByName(clipArray: THREE$AnimationClip, name: string): THREE$AnimationClip;
    CreateClipsFromMorphTargetSequences(
        morphTargets: THREE$MorphTarget[],
        fps: number,
        noLoop: boolean): THREE$AnimationClip[];
    parse(json: any): THREE$AnimationClip;
    parseAnimation(animation: any, bones: THREE$Bone[], nodeName: string): THREE$AnimationClip;
    toJSON(): any
}

declare export class AnimationMixer mixins EventDispatcher {
    constructor(root: any): this;
    time: number;
    timeScale: number;
    clipAction(clip: THREE$AnimationClip, root?: any): THREE$AnimationAction;
    existingAction(clip: THREE$AnimationClip, root?: any): THREE$AnimationAction;
    stopAllAction(clip: THREE$AnimationClip, root?: any): THREE$AnimationMixer;
    update(deltaTime: number): THREE$AnimationMixer;
    getRoot(): any;
    uncacheClip(clip: THREE$AnimationClip): void;
    uncacheRoot(root: any): void;
    uncacheAction(clip: THREE$AnimationClip, root?: any): void
}

declare export class AnimationObjectGroup {
    constructor(...args: any[]): this;
    uuid: string;
    stats: {
        bindingsPerObject: number,
        objects: {
            total: number,
            inUse: number
        }
    };
    add(...args: any[]): void;
    remove(...args: any[]): void;
    uncache(...args: any[]): void
}


declare var npm$namespace$AnimationUtils: {
    arraySlice: typeof AnimationUtils$arraySlice,
    convertArray: typeof AnimationUtils$convertArray,
    isTypedArray: typeof AnimationUtils$isTypedArray,
    getKeyFrameOrder: typeof AnimationUtils$getKeyFrameOrder,
    sortedArray: typeof AnimationUtils$sortedArray,
    flattenJSON: typeof AnimationUtils$flattenJSON,
}
declare export function AnimationUtils$arraySlice(array: any, from: number, to: number): any

declare export function AnimationUtils$convertArray(array: any, type: any, forceClone: boolean): any

declare export function AnimationUtils$isTypedArray(object: any): boolean

declare export function AnimationUtils$getKeyFrameOrder(times: number): number[]

declare export function AnimationUtils$sortedArray(values: any[], stride: number, order: number[]): any[]

declare export function AnimationUtils$flattenJSON(
    jsonKeys: string[],
    times: any[],
    values: any[],
    valuePropertyName: string): void

declare export class KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this;
    name: string;
    times: any[];
    values: any[];
    ValueTypeName: string;
    TimeBufferType: Float32Array;
    ValueBufferType: Float32Array;
    DefaultInterpolation: InterpolationModes;
    InterpolantFactoryMethodDiscrete(result: any): THREE$DiscreteInterpolant;
    InterpolantFactoryMethodLinear(result: any): THREE$LinearInterpolant;
    InterpolantFactoryMethodSmooth(result: any): THREE$CubicInterpolant;
    setInterpolation(interpolation: InterpolationModes): void;
    getInterpolation(): InterpolationModes;
    getValuesize(): number;
    shift(timeOffset: number): THREE$KeyframeTrack;
    scale(timeScale: number): THREE$KeyframeTrack;
    trim(startTime: number, endTime: number): THREE$KeyframeTrack;
    validate(): boolean;
    optimize(): THREE$KeyframeTrack;
    parse(json: any): THREE$KeyframeTrack;
    toJSON(track: THREE$KeyframeTrack): any
}

declare export class PropertyBinding {
    constructor(rootNode: any, path: string, parsedPath?: any): this;
    path: string;
    parsedPath: any;
    node: any;
    rootNode: any;
    getValue(targetArray: any, offset: number): any;
    setValue(sourceArray: any, offset: number): void;
    bind(): void;
    unbind(): void;
    BindingType: {
        [bindingType: string]: number
    };
    Versioning: {
        [versioning: string]: number
    };
    GetterByBindingType: Function[];
    SetterByBindingTypeAndVersioning: Array<Function[]>;
    create(
        root: any,
        path: any,
        parsedPath?: any): THREE$PropertyBinding | PropertyBinding$Composite;
    parseTrackName(trackName: string): any;
    findNode(root: any, nodeName: string): any
}

declare export class Composite {
    constructor(targetGroup: any, path: any, parsedPath?: any): this;
    getValue(array: any, offset: number): any;
    setValue(array: any, offset: number): void;
    bind(): void;
    unbind(): void
}

declare export class PropertyMixer {
    constructor(binding: any, typeName: string, valueSize: number): this;
    binding: any;
    valueSize: number;
    buffer: any;
    cumulativeWeight: number;
    useCount: number;
    referenceCount: number;
    accumulate(accuIndex: number, weight: number): void;
    apply(accuIndex: number): void;
    saveOriginalState(): void;
    restoreOriginalState(): void
}

declare export class BooleanKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[]): this
}

declare export class ColorKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this
}

declare export class NumberKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this
}

declare export class QuaternionKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this
}

declare export class StringKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this
}

declare export class VectorKeyframeTrack mixins KeyframeTrack {
    constructor(name: string, times: any[], values: any[], interpolation: InterpolationModes): this
}


/**
 * Abstract base class for cameras. This class should always be inherited when you build a new camera.
 */
declare export class Camera mixins Object3D {

    /**
     * This constructor sets following properties to the correct type: matrixWorldInverse, projectionMatrix and projectionMatrixInverse.
     */
    constructor(): this;

    /**
     * This is the inverse of matrixWorld. MatrixWorld contains the Matrix which has the world transform of the Camera.
     */
    matrixWorldInverse: THREE$Matrix4;

    /**
     * This is the matrix which contains the projection.
     */
    projectionMatrix: THREE$Matrix4;
    getWorldDirection(optionalTarget?: THREE$Vector3): THREE$Vector3;

    /**
     * This make the camera look at the vector position in local space.
     * @param vector point to look at
     */
    lookAt(vector: THREE$Vector3): void
}

declare export class CubeCamera mixins Object3D {
    constructor(near?: number, far?: number, cubeResolution?: number): this;
    renderTarget: THREE$WebGLRenderTargetCube;
    updateCubeMap(renderer: THREE$Renderer, scene: THREE$Scene): void
}


/**
 * Camera with orthographic projection
 * @example  * var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
scene.add( camera );
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/cameras/OrthographicCamera.js">src/cameras/OrthographicCamera.js</a>
*/
declare export class OrthographicCamera mixins Camera {

    /**
     * 
     * @param left Camera frustum left plane.
     * @param right Camera frustum right plane.
     * @param top Camera frustum top plane.
     * @param bottom Camera frustum bottom plane.
     * @param near Camera frustum near plane.
     * @param far Camera frustum far plane.
     */
    constructor(left: number, right: number, top: number, bottom: number, near?: number, far?: number): this;
    zoom: number;
    view: {
        fullWidth: number,
        fullHeight: number,
        offsetX: number,
        offsetY: number,
        width: number,
        height: number
    };

    /**
     * Camera frustum left plane.
     */
    left: number;

    /**
     * Camera frustum right plane.
     */
    right: number;

    /**
     * Camera frustum top plane.
     */
    top: number;

    /**
     * Camera frustum bottom plane.
     */
    bottom: number;

    /**
     * Camera frustum near plane.
     */
    near: number;

    /**
     * Camera frustum far plane.
     */
    far: number;

    /**
     * Updates the camera projection matrix. Must be called after change of parameters.
     */
    updateProjectionMatrix(): void;
    setViewOffset(
        fullWidth: number,
        fullHeight: number,
        offsetX: number,
        offsetY: number,
        width: number,
        height: number): void;
    clearViewOffset(): void;
    toJSON(meta?: any): any
}


/**
 * Camera with perspective projection.
 * 
# example
     var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
     scene.add( camera );
 * @source  https://github.com/mrdoob/three.js/blob/master/src/cameras/PerspectiveCamera.js
*/
declare export class PerspectiveCamera mixins Camera {

    /**
     * 
     * @param fov Camera frustum vertical field of view. Default value is 50.
     * @param aspect Camera frustum aspect ratio. Default value is 1.
     * @param near Camera frustum near plane. Default value is 0.1.
     * @param far Camera frustum far plane. Default value is 2000.
     */
    constructor(fov?: number, aspect?: number, near?: number, far?: number): this;
    zoom: number;

    /**
     * Camera frustum vertical field of view, from bottom to top of view, in degrees.
     */
    fov: number;

    /**
     * Camera frustum aspect ratio, window width divided by window height.
     */
    aspect: number;

    /**
     * Camera frustum near plane.
     */
    near: number;

    /**
     * Camera frustum far plane.
     */
    far: number;
    focus: number;
    view: {
        fullWidth: number,
        fullHeight: number,
        offsetX: number,
        offsetY: number,
        width: number,
        height: number
    };
    filmGauge: number;
    filmOffset: number;
    setFocalLength(focalLength: number): void;
    getFocalLength(): number;
    getEffectiveFOV(): number;
    getFilmWidth(): number;
    getFilmHeight(): number;

    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:

         +---+---+---+
         | A | B | C |
         +---+---+---+
         | D | E | F |
         +---+---+---+

    then for each monitor you would call it like this:

         var w = 1920;
         var h = 1080;
         var fullWidth = w  3;
         var fullHeight = h  2;

         // A
         camera.setViewOffset( fullWidth, fullHeight, w  0, h  0, w, h );
         // B
         camera.setViewOffset( fullWidth, fullHeight, w  1, h  0, w, h );
         // C
         camera.setViewOffset( fullWidth, fullHeight, w  2, h  0, w, h );
         // D
         camera.setViewOffset( fullWidth, fullHeight, w  0, h  1, w, h );
         // E
         camera.setViewOffset( fullWidth, fullHeight, w  1, h  1, w, h );
         // F
         camera.setViewOffset( fullWidth, fullHeight, w  2, h  1, w, h ); Note there is no reason monitors have to be the same size or in a grid.
     * @param fullWidth full width of multiview setup
     * @param fullHeight full height of multiview setup
     * @param x horizontal offset of subcamera
     * @param y vertical offset of subcamera
     * @param width width of subcamera
     * @param height height of subcamera
    */
    setViewOffset(
        fullWidth: number,
        fullHeight: number,
        x: number,
        y: number,
        width: number,
        height: number): void;
    clearViewOffset(): void;

    /**
     * Updates the camera projection matrix. Must be called after change of parameters.
     */
    updateProjectionMatrix(): void;
    toJSON(meta?: any): any;
    setLens(focalLength: number, frameHeight?: number): void
}

declare export class StereoCamera mixins Camera {
    constructor(): this;
    aspect: number;
    cameraL: THREE$PerspectiveCamera;
    cameraR: THREE$PerspectiveCamera;
    update(camera: THREE$PerspectiveCamera): void
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferAttribute.js">src/core/BufferAttribute.js</a>
 */
declare export class BufferAttribute {
    constructor(array: ArrayLike<number>, itemSize: number, normalized?: boolean): this;
    uuid: string;
    array: ArrayLike<number>;
    itemSize: number;
    dynamic: boolean;
    updateRange: {
        offset: number,
        count: number
    };
    version: number;
    normalized: boolean;
    needsUpdate: boolean;
    count: number;
    setDynamic(dynamic: boolean): THREE$BufferAttribute;
    clone(): this;
    copy(source: this): this;
    copyAt(
        index1: number,
        attribute: THREE$BufferAttribute,
        index2: number): THREE$BufferAttribute;
    copyArray(array: ArrayLike<number>): THREE$BufferAttribute;
    copyColorsArray(colors: {
        r: number,
        g: number,
        b: number
    }[]): THREE$BufferAttribute;
    copyIndicesArray(indices: {
        a: number,
        b: number,
        c: number
    }[]): THREE$BufferAttribute;
    copyVector2sArray(vectors: {
        x: number,
        y: number
    }[]): THREE$BufferAttribute;
    copyVector3sArray(vectors: {
        x: number,
        y: number,
        z: number
    }[]): THREE$BufferAttribute;
    copyVector4sArray(
        vectors: {
            x: number,
            y: number,
            z: number,
            w: number
        }[]): THREE$BufferAttribute;
    set(value: ArrayLike<number>, offset?: number): THREE$BufferAttribute;
    getX(index: number): number;
    setX(index: number, x: number): THREE$BufferAttribute;
    getY(index: number): number;
    setY(index: number, y: number): THREE$BufferAttribute;
    getZ(index: number): number;
    setZ(index: number, z: number): THREE$BufferAttribute;
    getW(index: number): number;
    setW(index: number, z: number): THREE$BufferAttribute;
    setXY(index: number, x: number, y: number): THREE$BufferAttribute;
    setXYZ(index: number, x: number, y: number, z: number): THREE$BufferAttribute;
    setXYZW(
        index: number,
        x: number,
        y: number,
        z: number,
        w: number): THREE$BufferAttribute;
    length: number
}

declare export class Int8Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Uint8Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Uint8ClampedAttribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Int16Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Uint16Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Int32Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Uint32Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Float32Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class Float64Attribute mixins BufferAttribute {
    constructor(array: any, itemSize: number): this
}

declare export class DynamicBufferAttribute mixins BufferAttribute {}


/**
 * This is a superefficent class for geometries because it saves all data in buffers.
 * It reduces memory costs and cpu cycles. But it is not as easy to work with because of all the nessecary buffer calculations.
It is mainly interesting when working with static objects.
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js">src/core/BufferGeometry.js</a>
*/
declare export class BufferGeometry mixins EventDispatcher {

    /**
     * This creates a new BufferGeometry. It also sets several properties to an default value.
     */
    constructor(): this;
    MaxIndex: number;

    /**
     * Unique number of this buffergeometry instance
     */
    id: number;
    uuid: string;
    name: string;
    type: string;
    index: THREE$BufferAttribute;
    attributes: THREE$BufferAttribute | THREE$InterleavedBufferAttribute[];
    morphAttributes: any;
    groups: {
        start: number,
        count: number,
        materialIndex?: number
    }[];
    boundingBox: THREE$Box3;
    boundingSphere: THREE$Sphere;
    drawRange: {
        start: number,
        count: number
    };
    getIndex(): THREE$BufferAttribute;
    setIndex(index: THREE$BufferAttribute): void;
    addAttribute(
        name: string,
        attribute: THREE$BufferAttribute | THREE$InterleavedBufferAttribute): THREE$BufferGeometry;
    getAttribute(name: string): THREE$BufferAttribute | THREE$InterleavedBufferAttribute;
    removeAttribute(name: string): THREE$BufferGeometry;
    addGroup(start: number, count: number, materialIndex?: number): void;
    clearGroups(): void;
    setDrawRange(start: number, count: number): void;

    /**
     * Bakes matrix transform directly into vertex coordinates.
     */
    applyMatrix(matrix: THREE$Matrix4): THREE$BufferGeometry;
    rotateX(angle: number): THREE$BufferGeometry;
    rotateY(angle: number): THREE$BufferGeometry;
    rotateZ(angle: number): THREE$BufferGeometry;
    translate(x: number, y: number, z: number): THREE$BufferGeometry;
    scale(x: number, y: number, z: number): THREE$BufferGeometry;
    lookAt(v: THREE$Vector3): void;
    center(): THREE$Vector3;
    setFromObject(object: THREE$Object3D): void;
    updateFromObject(object: THREE$Object3D): void;
    fromGeometry(geometry: THREE$Geometry, settings?: any): THREE$BufferGeometry;
    fromDirectGeometry(geometry: THREE$DirectGeometry): THREE$BufferGeometry;

    /**
     * Computes bounding box of the geometry, updating Geometry.boundingBox attribute.
     * Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null.
     */
    computeBoundingBox(): void;

    /**
     * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
     * Bounding spheres aren't' computed by default. They need to be explicitly computed, otherwise they are null.
     */
    computeBoundingSphere(): void;

    /**
     * Computes vertex normals by averaging face normals.
     */
    computeVertexNormals(): void;
    merge(geometry: THREE$BufferGeometry, offset: number): THREE$BufferGeometry;
    normalizeNormals(): void;
    toNonIndexed(): THREE$BufferGeometry;
    toJSON(): any;
    clone(): this;
    copy(source: this): this;

    /**
     * Disposes the object from memory.
     * You need to call this when you want the bufferGeometry removed while the application is running.
     */
    dispose(): void;
    drawcalls: any;
    offsets: any;
    addIndex(index: any): void;
    addDrawCall(start: any, count: any, indexOffset?: any): void;
    clearDrawCalls(): void;
    addAttribute(name: any, array: any, itemSize: any): any
}


/**
 * Object for keeping track of time.
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/Clock.js">src/core/Clock.js</a>
 */
declare export class Clock {

    /**
     * 
     * @param autoStart Automatically start the clock.
     */
    constructor(autoStart?: boolean): this;

    /**
     * If set, starts the clock automatically when the first update is called.
     */
    autoStart: boolean;

    /**
     * When the clock is running, It holds the starttime of the clock.
     * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
     */
    startTime: number;

    /**
     * When the clock is running, It holds the previous time from a update.
     * This counted from the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
     */
    oldTime: number;

    /**
     * When the clock is running, It holds the time elapsed between the start of the clock to the previous update.
     * This parameter is in seconds of three decimal places.
     */
    elapsedTime: number;

    /**
     * This property keeps track whether the clock is running or not.
     */
    running: boolean;

    /**
     * Starts clock.
     */
    start(): void;

    /**
     * Stops clock.
     */
    stop(): void;

    /**
     * Get the seconds passed since the clock started.
     */
    getElapsedTime(): number;

    /**
     * Get the seconds passed since the last call to this method.
     */
    getDelta(): number
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/DirectGeometry.js">src/core/DirectGeometry.js</a>
 */
declare export class DirectGeometry mixins EventDispatcher {
    constructor(): this;
    id: number;
    uuid: string;
    name: string;
    type: string;
    indices: number[];
    vertices: THREE$Vector3[];
    normals: THREE$Vector3[];
    colors: THREE$Color[];
    uvs: THREE$Vector2[];
    uvs2: THREE$Vector2[];
    groups: {
        start: number,
        materialIndex: number
    }[];
    morphTargets: THREE$MorphTarget[];
    skinWeights: number[];
    skinIndices: number[];
    boundingBox: THREE$Box3;
    boundingSphere: THREE$Sphere;
    verticesNeedUpdate: boolean;
    normalsNeedUpdate: boolean;
    colorsNeedUpdate: boolean;
    uvsNeedUpdate: boolean;
    groupsNeedUpdate: boolean;
    computeBoundingBox(): void;
    computeBoundingSphere(): void;
    computeGroups(geometry: THREE$Geometry): void;
    fromGeometry(geometry: THREE$Geometry): THREE$DirectGeometry;
    dispose(): void;
    addEventListener(type: string, listener: (event: THREE$Event) => void): void;
    hasEventListener(type: string, listener: (event: THREE$Event) => void): void;
    removeEventListener(type: string, listener: (event: THREE$Event) => void): void;
    dispatchEvent(event: {
        type: string,
        [attachment: string]: any
    }): void
}


/**
 * JavaScript events for custom objects
 * 
# Example
     var Car = function () {

         EventDispatcher.call( this );
         this.start = function () {

             this.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );

         };

     };

     var car = new Car();
     car.addEventListener( 'start', function ( event ) {

         alert( event.message );

     } );
     car.start();
 * @source  src/core/EventDispatcher.js
*/
declare export class EventDispatcher {

    /**
     * Creates eventDispatcher object. It needs to be call with '.call' to add the functionality to an object.
     */
    constructor(): this;

    /**
     * Adds a listener to an event type.
     * @param type The type of the listener that gets removed.
     * @param listener The listener function that gets removed.
     */
    addEventListener(type: string, listener: (event: THREE$Event) => void): void;

    /**
     * Adds a listener to an event type.
     * @param type The type of the listener that gets removed.
     * @param listener The listener function that gets removed.
     */
    hasEventListener(type: string, listener: (event: THREE$Event) => void): void;

    /**
     * Removes a listener from an event type.
     * @param type The type of the listener that gets removed.
     * @param listener The listener function that gets removed.
     */
    removeEventListener(type: string, listener: (event: THREE$Event) => void): void;

    /**
     * Fire an event type.
     * @param type The type of event that gets fired.
     */
    dispatchEvent(event: {
        type: string,
        [attachment: string]: any
    }): void;
    apply(target: any): void
}

declare export interface THREE$Event {
    type: string,
        target: any
}


/**
 * Triangle face.
 * 
# Example
     var normal = new THREE.Vector3( 0, 1, 0 );
     var color = new THREE.Color( 0xffaa00 );
     var face = new THREE.Face3( 0, 1, 2, normal, color, 0 );
 * @source  https://github.com/mrdoob/three.js/blob/master/src/core/Face3.js
*/
declare export class Face3 {

    /**
     * 
     * @param a Vertex A index.
     * @param b Vertex B index.
     * @param c Vertex C index.
     * @param normal Face normal or array of vertex normals.
     * @param color Face color or array of vertex colors.
     * @param materialIndex Material index.
     */
    constructor(a: number, b: number, c: number, normal?: THREE$Vector3, color?: THREE$Color, materialIndex?: number): this;
    constructor(a: number, b: number, c: number, normal?: THREE$Vector3, vertexColors?: THREE$Color[], materialIndex?: number): this;
    constructor(a: number, b: number, c: number, vertexNormals?: THREE$Vector3[], color?: THREE$Color, materialIndex?: number): this;
    constructor(a: number, b: number, c: number, vertexNormals?: THREE$Vector3[], vertexColors?: THREE$Color[], materialIndex?: number): this;

    /**
     * Vertex A index.
     */
    a: number;

    /**
     * Vertex B index.
     */
    b: number;

    /**
     * Vertex C index.
     */
    c: number;

    /**
     * Face normal.
     */
    normal: THREE$Vector3;

    /**
     * Array of 4 vertex normals.
     */
    vertexNormals: THREE$Vector3[];

    /**
     * Face color.
     */
    color: THREE$Color;

    /**
     * Array of 4 vertex normals.
     */
    vertexColors: THREE$Color[];

    /**
     * Material index (points to {@link Geometry.materials}).
     */
    materialIndex: number;
    clone(): this;
    copy(source: this): this
}

declare export class Face4 mixins Face3 {}

declare export interface THREE$MorphTarget {
    name: string,
        vertices: THREE$Vector3[]
}

declare export interface THREE$MorphColor {
    name: string,
        colors: THREE$Color[]
}

declare export interface THREE$MorphNormals {
    name: string,
        normals: THREE$Vector3[]
}

declare export var GeometryIdCount: number;


/**
 * Base class for geometries
 * 
# Example
     var geometry = new THREE.Geometry();
     geometry.vertices.push( new THREE.Vector3( -10, 10, 0 ) );
     geometry.vertices.push( new THREE.Vector3( -10, -10, 0 ) );
     geometry.vertices.push( new THREE.Vector3( 10, -10, 0 ) );
     geometry.faces.push( new THREE.Face3( 0, 1, 2 ) );
     geometry.computeBoundingSphere();
 * @see  https://github.com/mrdoob/three.js/blob/master/src/core/Geometry.js
*/
declare export class Geometry mixins EventDispatcher {
    constructor(): this;

    /**
     * Unique number of this geometry instance
     */
    id: number;
    uuid: string;

    /**
     * Name for this geometry. Default is an empty string.
     */
    name: string;
    type: string;

    /**
     * The array of vertices hold every position of points of the model.
     * To signal an update in this array, Geometry.verticesNeedUpdate needs to be set to true.
     */
    vertices: THREE$Vector3[];

    /**
     * Array of vertex colors, matching number and order of vertices.
     * Used in ParticleSystem, Line and Ribbon.
    Meshes use per-face-use-of-vertex colors embedded directly in faces.
    To signal an update in this array, Geometry.colorsNeedUpdate needs to be set to true.
    */
    colors: THREE$Color[];

    /**
     * Array of triangles or/and quads.
     * The array of faces describe how each vertex in the model is connected with each other.
    To signal an update in this array, Geometry.elementsNeedUpdate needs to be set to true.
    */
    faces: THREE$Face3[];

    /**
     * Array of face UV layers.
     * Each UV layer is an array of UV matching order and number of vertices in faces.
    To signal an update in this array, Geometry.uvsNeedUpdate needs to be set to true.
    */
    faceVertexUvs: THREE$Vector2[][][];

    /**
     * Array of morph targets. Each morph target is a Javascript object:
     * 
         { name: "targetName", vertices: [ new THREE.Vector3(), ... ] }

    Morph vertices match number and order of primary vertices.
    */
    morphTargets: THREE$MorphTarget[];

    /**
     * Array of morph normals. Morph normals have similar structure as morph targets, each normal set is a Javascript object:
     * 
         morphNormal = { name: "NormalName", normals: [ new THREE.Vector3(), ... ] }
    */
    morphNormals: THREE$MorphNormals[];

    /**
     * Array of skinning weights, matching number and order of vertices.
     */
    skinWeights: number[];

    /**
     * Array of skinning indices, matching number and order of vertices.
     */
    skinIndices: number[];

    /**
     * 
     */
    lineDistances: number[];

    /**
     * Bounding box.
     */
    boundingBox: THREE$Box3;

    /**
     * Bounding sphere.
     */
    boundingSphere: THREE$Sphere;

    /**
     * Set to true if the vertices array has been updated.
     */
    verticesNeedUpdate: boolean;

    /**
     * Set to true if the faces array has been updated.
     */
    elementsNeedUpdate: boolean;

    /**
     * Set to true if the uvs array has been updated.
     */
    uvsNeedUpdate: boolean;

    /**
     * Set to true if the normals array has been updated.
     */
    normalsNeedUpdate: boolean;

    /**
     * Set to true if the colors array has been updated.
     */
    colorsNeedUpdate: boolean;

    /**
     * Set to true if the linedistances array has been updated.
     */
    lineDistancesNeedUpdate: boolean;

    /**
     * 
     */
    groupsNeedUpdate: boolean;

    /**
     * Bakes matrix transform directly into vertex coordinates.
     */
    applyMatrix(matrix: THREE$Matrix4): THREE$Geometry;
    rotateX(angle: number): THREE$Geometry;
    rotateY(angle: number): THREE$Geometry;
    rotateZ(angle: number): THREE$Geometry;
    translate(x: number, y: number, z: number): THREE$Geometry;
    scale(x: number, y: number, z: number): THREE$Geometry;
    lookAt(vector: THREE$Vector3): void;
    fromBufferGeometry(geometry: THREE$BufferGeometry): THREE$Geometry;
    center(): THREE$Vector3;
    normalize(): THREE$Geometry;

    /**
     * Computes face normals.
     */
    computeFaceNormals(): void;

    /**
     * Computes vertex normals by averaging face normals.
     * Face normals must be existing / computed beforehand.
     */
    computeVertexNormals(areaWeighted?: boolean): void;

    /**
     * Computes morph normals.
     */
    computeMorphNormals(): void;
    computeLineDistances(): void;

    /**
     * Computes bounding box of the geometry, updating {@link Geometry.boundingBox} attribute.
     */
    computeBoundingBox(): void;

    /**
     * Computes bounding sphere of the geometry, updating Geometry.boundingSphere attribute.
     * Neither bounding boxes or bounding spheres are computed by default. They need to be explicitly computed, otherwise they are null.
     */
    computeBoundingSphere(): void;
    merge(
        geometry: THREE$Geometry,
        matrix: THREE$Matrix,
        materialIndexOffset?: number): void;
    mergeMesh(mesh: THREE$Mesh): void;

    /**
     * Checks for duplicate vertices using hashmap.
     * Duplicated vertices are removed and faces' vertices are updated.
     */
    mergeVertices(): number;
    sortFacesByMaterialIndex(): void;
    toJSON(): any;

    /**
     * Creates a new clone of the Geometry.
     */
    clone(): this;
    copy(source: this): this;

    /**
     * Removes The object from memory.
     * Don't forget to call this method when you remove an geometry because it can cuase meomory leaks.
     */
    dispose(): void;
    bones: THREE$Bone[];
    animation: THREE$AnimationClip;
    animations: THREE$AnimationClip[];
    addEventListener(type: string, listener: (event: THREE$Event) => void): void;
    hasEventListener(type: string, listener: (event: THREE$Event) => void): void;
    removeEventListener(type: string, listener: (event: THREE$Event) => void): void;
    dispatchEvent(event: {
        type: string,
        [attachment: string]: any
    }): void
}


declare var npm$namespace$GeometryUtils: {
    merge: typeof GeometryUtils$merge,
    center: typeof GeometryUtils$center,
}
declare export function GeometryUtils$merge(geometry1: any, geometry2: any, materialIndexOffset?: any): any

declare export function GeometryUtils$center(geometry: any): any


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferAttribute.js">src/core/InstancedBufferAttribute.js</a>
 */
declare export class InstancedBufferAttribute mixins BufferAttribute {
    constructor(data: ArrayLike<number>, itemSize: number, meshPerAttribute?: number): this;
    meshPerAttribute: number
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedBufferGeometry.js">src/core/InstancedBufferGeometry.js</a>
 */
declare export class InstancedBufferGeometry mixins BufferGeometry {
    constructor(): this;
    groups: {
        start: number,
        count: number,
        instances: number
    }[];
    maxInstancedCount: number;
    addGroup(start: number, count: number, instances: number): void
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBuffer.js">src/core/InterleavedBuffer.js</a>
 */
declare export class InterleavedBuffer {
    constructor(array: ArrayLike<number>, stride: number): this;
    array: ArrayLike<number>;
    stride: number;
    dynamic: boolean;
    updateRange: {
        offset: number,
        count: number
    };
    version: number;
    length: number;
    count: number;
    needsUpdate: boolean;
    setDynamic(dynamic: boolean): THREE$InterleavedBuffer;
    clone(): this;
    copy(source: this): this;
    copyAt(
        index1: number,
        attribute: THREE$InterleavedBufferAttribute,
        index2: number): THREE$InterleavedBuffer;
    set(value: ArrayLike<number>, index: number): THREE$InterleavedBuffer;
    clone(): this
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InstancedInterleavedBuffer.js">src/core/InstancedInterleavedBuffer.js</a>
 */
declare export class InstancedInterleavedBuffer mixins InterleavedBuffer {
    constructor(array: ArrayLike<number>, stride: number, meshPerAttribute?: number): this;
    meshPerAttribute: number
}


/**
 * 
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/core/InterleavedBufferAttribute.js">src/core/InterleavedBufferAttribute.js</a>
 */
declare export class InterleavedBufferAttribute {
    constructor(interleavedBuffer: THREE$InterleavedBuffer, itemSize: number, offset: number, normalized: boolean): this;
    uuid: string;
    data: THREE$InterleavedBuffer;
    itemSize: number;
    offset: number;
    count: number;
    normalized: boolean;
    array: any[];
    getX(index: number): number;
    setX(index: number, x: number): THREE$InterleavedBufferAttribute;
    getY(index: number): number;
    setY(index: number, y: number): THREE$InterleavedBufferAttribute;
    getZ(index: number): number;
    setZ(index: number, z: number): THREE$InterleavedBufferAttribute;
    getW(index: number): number;
    setW(index: number, z: number): THREE$InterleavedBufferAttribute;
    setXY(index: number, x: number, y: number): THREE$InterleavedBufferAttribute;
    setXYZ(
        index: number,
        x: number,
        y: number,
        z: number): THREE$InterleavedBufferAttribute;
    setXYZW(
        index: number,
        x: number,
        y: number,
        z: number,
        w: number): THREE$InterleavedBufferAttribute;
    length: number
}

declare export var Object3DIdCount: number;


/**
 * Base class for scene graph objects
 */
declare export class Object3D mixins EventDispatcher {
    constructor(): this;

    /**
     * Unique number of this object instance.
     */
    id: number;

    /**
     * 
     */
    uuid: string;

    /**
     * Optional name of the object (doesn't need to be unique).
     */
    name: string;
    type: string;

    /**
     * Object's parent in the scene graph.
     */
    parent: THREE$Object3D;

    /**
     * Array with object's children.
     */
    children: THREE$Object3D[];

    /**
     * Up direction.
     */
    up: THREE$Vector3;

    /**
     * Object's local position.
     */
    position: THREE$Vector3;

    /**
     * Object's local rotation (Euler angles), in radians.
     */
    rotation: THREE$Euler;

    /**
     * Global rotation.
     */
    quaternion: THREE$Quaternion;

    /**
     * Object's local scale.
     */
    scale: THREE$Vector3;
    modelViewMatrix: THREE$Matrix4;
    normalMatrix: THREE$Matrix3;

    /**
     * Local transform.
     */
    matrix: THREE$Matrix4;

    /**
     * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.
     */
    matrixWorld: THREE$Matrix4;

    /**
     * When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property.
     */
    matrixAutoUpdate: boolean;

    /**
     * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
     */
    matrixWorldNeedsUpdate: boolean;
    layers: THREE$Layers;

    /**
     * Object gets rendered if true.
     */
    visible: boolean;

    /**
     * Gets rendered into shadow map.
     */
    castShadow: boolean;

    /**
     * Material gets baked in shadow receiving.
     */
    receiveShadow: boolean;

    /**
     * When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible.
     */
    frustumCulled: boolean;
    renderOrder: number;

    /**
     * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.
     */
    userData: any;

    /**
     * 
     */
    DefaultUp: THREE$Vector3;
    DefaultMatrixAutoUpdate: boolean;

    /**
     * This updates the position, rotation and scale with the matrix.
     */
    applyMatrix(matrix: THREE$Matrix4): void;

    /**
     * 
     */
    setRotationFromAxisAngle(axis: THREE$Vector3, angle: number): void;

    /**
     * 
     */
    setRotationFromEuler(euler: THREE$Euler): void;

    /**
     * 
     */
    setRotationFromMatrix(m: THREE$Matrix4): void;

    /**
     * 
     */
    setRotationFromQuaternion(q: THREE$Quaternion): void;

    /**
     * Rotate an object along an axis in object space. The axis is assumed to be normalized.
     * @param axis A normalized vector in object space.
     * @param angle The angle in radians.
     */
    rotateOnAxis(axis: THREE$Vector3, angle: number): THREE$Object3D;

    /**
     * 
     * @param angle 
     */
    rotateX(angle: number): THREE$Object3D;

    /**
     * 
     * @param angle 
     */
    rotateY(angle: number): THREE$Object3D;

    /**
     * 
     * @param angle 
     */
    rotateZ(angle: number): THREE$Object3D;

    /**
     * 
     * @param axis A normalized vector in object space.
     * @param distance The distance to translate.
     */
    translateOnAxis(axis: THREE$Vector3, distance: number): THREE$Object3D;

    /**
     * Translates object along x axis by distance.
     * @param distance Distance.
     */
    translateX(distance: number): THREE$Object3D;

    /**
     * Translates object along y axis by distance.
     * @param distance Distance.
     */
    translateY(distance: number): THREE$Object3D;

    /**
     * Translates object along z axis by distance.
     * @param distance Distance.
     */
    translateZ(distance: number): THREE$Object3D;

    /**
     * Updates the vector from local space to world space.
     * @param vector A local vector.
     */
    localToWorld(vector: THREE$Vector3): THREE$Vector3;

    /**
     * Updates the vector from world space to local space.
     * @param vector A world vector.
     */
    worldToLocal(vector: THREE$Vector3): THREE$Vector3;

    /**
     * Rotates object to face point in space.
     * @param vector A world vector to look at.
     */
    lookAt(vector: THREE$Vector3): void;

    /**
     * Adds object as child of this object.
     */
    add(object: THREE$Object3D): void;

    /**
     * Removes object as child of this object.
     */
    remove(object: THREE$Object3D): void;

    /**
     * Searches through the object's children and returns the first with a matching id, optionally recursive.
     * @param id Unique number of the object instance
     */
    getObjectById(id: number): THREE$Object3D;

    /**
     * Searches through the object's children and returns the first with a matching name, optionally recursive.
     * @param name String to match to the children's Object3d.name property.
     */
    getObjectByName(name: string): THREE$Object3D;
    getObjectByProperty(name: string, value: string): THREE$Object3D;
    getWorldPosition(optionalTarget?: THREE$Vector3): THREE$Vector3;
    getWorldQuaternion(optionalTarget?: THREE$Quaternion): THREE$Quaternion;
    getWorldRotation(optionalTarget?: THREE$Euler): THREE$Euler;
    getWorldScale(optionalTarget?: THREE$Vector3): THREE$Vector3;
    getWorldDirection(optionalTarget?: THREE$Vector3): THREE$Vector3;
    raycast(raycaster: THREE$Raycaster, intersects: any): void;
    traverse(callback: (object: THREE$Object3D) => any): void;
    traverseVisible(callback: (object: THREE$Object3D) => any): void;
    traverseAncestors(callback: (object: THREE$Object3D) => any): void;

    /**
     * Updates local transform.
     */
    updateMatrix(): void;

    /**
     * Updates global transform of the object and its children.
     */
    updateMatrixWorld(force: boolean): void;
    toJSON(meta?: {
        geometries: any,
        materials: any,
        textures: any,
        images: any
    }): any;
    clone(recursive?: boolean): this;

    /**
     * 
     * @param object 
     * @param recursive 
     */
    copy(source: this, recursive?: boolean): this;
    eulerOrder: string;
    getChildByName(name: string): THREE$Object3D;
    translate(distance: number, axis: THREE$Vector3): THREE$Object3D
}

declare export interface THREE$Intersection {
    distance: number,
        distanceToRay: number,
        point: THREE$Vector3,
        index: number,
        face: THREE$Face3,
        faceIndex: number,
        object: THREE$Object3D
}

declare export interface THREE$RaycasterParameters {
    Mesh?: any,
        Line?: any,
        LOD?: any,
        Points?: {
            threshold: number
        },
        Sprite?: any
}

declare export class Raycaster {
    constructor(origin?: THREE$Vector3, direction?: THREE$Vector3, near?: number, far?: number): this;
    ray: THREE$Ray;
    near: number;
    far: number;
    params: THREE$RaycasterParameters;
    precision: number;
    linePrecision: number;
    set(origin: THREE$Vector3, direction: THREE$Vector3): void;
    setFromCamera(coords: {
        x: number,
        y: number
    }, camera: THREE$Camera): void;
    intersectObject(object: THREE$Object3D, recursive?: boolean): THREE$Intersection[];
    intersectObjects(objects: THREE$Object3D[], recursive?: boolean): THREE$Intersection[]
}

declare export class Layers {
    constructor(): this;
    mask: number;
    set(channel: number): void;
    enable(channel: number): void;
    toggle(channel: number): void;
    disable(channel: number): void;
    test(layers: THREE$Layers): boolean
}

declare export class Font {
    constructor(jsondata: string): this;
    data: string;
    generateShapes(text: string, size: number, divisions: number): any[]
}


/**
 * Abstract base class for lights.
 */
declare export class Light mixins Object3D {
    constructor(hex?: number | string, intensity?: number): this;
    color: THREE$Color;
    intensity: number;
    receiveShadow: boolean;
    shadow: THREE$LightShadow;
    shadowCameraFov: any;
    shadowCameraLeft: any;
    shadowCameraRight: any;
    shadowCameraTop: any;
    shadowCameraBottom: any;
    shadowCameraNear: any;
    shadowCameraFar: any;
    shadowBias: any;
    shadowMapWidth: any;
    shadowMapHeight: any
}

declare export class LightShadow {
    constructor(camera: THREE$Camera): this;
    camera: THREE$Camera;
    bias: number;
    radius: number;
    mapSize: THREE$Vector2;
    map: THREE$RenderTarget;
    matrix: THREE$Matrix4;
    copy(source: this): this;
    clone(recursive?: boolean): this;
    toJSON(): any
}


/**
 * This light's color gets applied to all the objects in the scene globally.
 * 
# example
     var light = new THREE.AmbientLight( 0x404040 ); // soft white light
     scene.add( light );
 * @source  https://github.com/mrdoob/three.js/blob/master/src/lights/AmbientLight.js
*/
declare export class AmbientLight mixins Light {

    /**
     * This creates a Ambientlight with a color.
     * @param hex Numeric value of the RGB component of the color.
     */
    constructor(hex?: number | string, intensity?: number): this;
    castShadow: boolean
}


/**
 * Affects objects using MeshLambertMaterial or MeshPhongMaterial.
 * @example  * // White directional light at half intensity shining from the top.
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
directionalLight.position.set( 0, 1, 0 );
scene.add( directionalLight );
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/lights/DirectionalLight.js">src/lights/DirectionalLight.js</a>
*/
declare export class DirectionalLight mixins Light {
    constructor(hex?: number | string, intensity?: number): this;

    /**
     * Target used for shadow camera orientation.
     */
    target: THREE$Object3D;

    /**
     * Light's intensity.
     * Default  1.0.
     */
    intensity: number;
    shadow: THREE$LightShadow
}

declare export class DirectionalLightShadow mixins LightShadow {}

declare export class HemisphereLight mixins Light {
    constructor(skyColorHex?: number | string, groundColorHex?: number | string, intensity?: number): this;
    groundColor: THREE$Color;
    intensity: number
}


/**
 * Affects objects using {@link MeshLambertMaterial} or {@link MeshPhongMaterial}.
 * @example  * var light = new THREE.PointLight( 0xff0000, 1, 100 );
light.position.set( 50, 50, 50 );
scene.add( light );
*/
declare export class PointLight mixins Light {
    constructor(hex?: number | string, intensity?: number, distance?: number, decay?: number): this;
    intensity: number;

    /**
     * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
     * Default  0.0.
     */
    distance: number;
    decay: number;
    shadow: THREE$LightShadow;
    power: number
}


/**
 * A point light that can cast shadow in one direction.
 */
declare export class SpotLight mixins Light {
    constructor(hex?: number | string, intensity?: number, distance?: number, angle?: number, exponent?: number, decay?: number): this;

    /**
     * Spotlight focus points at target.position.
     * Default position  (0,0,0).
     */
    target: THREE$Object3D;

    /**
     * Light's intensity.
     * Default  1.0.
     */
    intensity: number;

    /**
     * If non-zero, light will attenuate linearly from maximum intensity at light position down to zero at distance.
     * Default  0.0.
     */
    distance: number;
    angle: number;

    /**
     * Rapidity of the falloff of light from its target direction.
     * Default  10.0.
     */
    exponent: number;
    decay: number;
    shadow: THREE$SpotLightShadow;
    power: number;
    penumbra: number
}

declare export class SpotLightShadow mixins LightShadow {
    update(light: THREE$Light): void
}


/**
 * Base class for implementing loaders.
 * 
Events:
     load
         Dispatched when the image has completed loading
         content  loaded image

     error

          Dispatched when the image can't be loaded
          message  error message
*/
declare export class Loader {
    constructor(): this;

    /**
     * Will be called when load starts.
     * The default is a function with empty body.
     */
    onLoadStart: () => void;

    /**
     * Will be called while load progresses.
     * The default is a function with empty body.
     */
    onLoadProgress: () => void;

    /**
     * Will be called when load completes.
     * The default is a function with empty body.
     */
    onLoadComplete: () => void;

    /**
     * default  null.
     * If set, assigns the crossOrigin attribute of the image to the value of crossOrigin, prior to starting the load.
     */
    crossOrigin: string;
    extractUrlBase(url: string): string;
    initMaterials(materials: THREE$Material[], texturePath: string): THREE$Material[];
    createMaterial(m: THREE$Material, texturePath: string, crossOrigin?: string): boolean;
    Handlers: THREE$LoaderHandler
}

declare export interface THREE$LoaderHandler {
    handlers: (RegExp | THREE$Loader)[],
        add(regex: RegExp, loader: THREE$Loader): void,
        get(file: string): THREE$Loader
}

declare export class XHRLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    path: string;
    responseType: string;
    withCredentials: boolean;
    load(
        url: string,
        onLoad?: (responseText: string) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): any;
    setPath(path: string): THREE$XHRLoader;
    setResponseType(responseType: string): THREE$XHRLoader;
    setWithCredentials(withCredentials: boolean): THREE$XHRLoader
}

declare export class FontLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    load(
        url: string,
        onLoad?: (responseText: string) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void;
    parse(json: string): THREE$Font
}


/**
 * A loader for loading an image.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
declare export class ImageLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    crossOrigin: string;
    withCredentials: string;
    path: string;

    /**
     * Begin loading from url
     * @param url 
     */
    load(
        url: string,
        onLoad?: (image: HTMLImageElement) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): HTMLImageElement;
    setCrossOrigin(crossOrigin: string): THREE$ImageLoader;
    setWithCredentials(value: string): THREE$ImageLoader;
    setPath(value: string): THREE$ImageLoader
}


/**
 * A loader for loading objects in JSON format.
 */
declare export class JSONLoader mixins Loader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    withCredentials: boolean;
    load(
        url: string,
        onLoad?: (geometry: THREE$Geometry, materials: THREE$Material[]) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void;
    setTexturePath(value: string): void;
    parse(
        json: any,
        texturePath?: string): {
        geometry: THREE$Geometry,
        materials?: THREE$Material[]
    }
}


/**
 * Handles and keeps track of loaded and pending data.
 */
declare export class LoadingManager {
    constructor(onLoad?: () => void, onProgress?: (url: string, loaded: number, total: number) => void, onError?: () => void): this;
    onStart: () => void;

    /**
     * Will be called when load starts.
     * The default is a function with empty body.
     */
    onLoad: () => void;

    /**
     * Will be called while load progresses.
     * The default is a function with empty body.
     */
    onProgress: (item: any, loaded: number, total: number) => void;

    /**
     * Will be called when each element in the scene completes loading.
     * The default is a function with empty body.
     */
    onError: () => void;
    itemStart(url: string): void;
    itemEnd(url: string): void;
    itemError(url: string): void
}

declare export var DefaultLoadingManager: THREE$LoadingManager;

declare export class BufferGeometryLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    load(
        url: string,
        onLoad: (bufferGeometry: THREE$BufferGeometry) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void;
    parse(json: any): THREE$BufferGeometry
}

declare export class MaterialLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    textures: {
        [key: string]: THREE$Texture
    };
    load(url: string, onLoad: (material: THREE$Material) => void): void;
    setTextures(textures: {
        [key: string]: THREE$Texture
    }): void;
    getTexture(name: string): THREE$Texture;
    parse(json: any): THREE$Material
}

declare export class ObjectLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    texturePass: string;
    crossOrigin: string;
    load(url: string, onLoad?: (object: THREE$Object3D) => void): void;
    setTexturePath(value: string): void;
    setCrossOrigin(crossOrigin: string): void;
    parse<T>(json: any, onLoad?: (object: THREE$Object3D) => void): T;
    parseGeometries(json: any): any[];
    parseMaterials(json: any, textures: THREE$Texture[]): THREE$Material[];
    parseAnimations(json: any): THREE$AnimationClip[];
    parseImages(json: any, onLoad: () => void): any[];
    parseTextures(json: any, images: any): THREE$Texture[];
    parseObject<T>(data: any, geometries: any[], materials: THREE$Material[]): T
}


/**
 * Class for loading a texture.
 * Unlike other loaders, this one emits events instead of using predefined callbacks. So if you're interested in getting notified when things happen, you need to add listeners to the object.
 */
declare export class TextureLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    crossOrigin: string;
    withCredentials: string;
    path: string;

    /**
     * Begin loading from url
     * @param url 
     */
    load(url: string, onLoad?: (texture: THREE$Texture) => void): THREE$Texture;
    setCrossOrigin(crossOrigin: string): THREE$TextureLoader;
    setWithCredentials(value: string): THREE$TextureLoader;
    setPath(path: string): THREE$TextureLoader
}

declare export class CubeTextureLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    corssOrigin: string;
    path: string;
    load(
        urls: Array<string>,
        onLoad?: (texture: THREE$CubeTexture) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void;
    setCrossOrigin(crossOrigin: string): THREE$CubeTextureLoader;
    setPath(path: string): THREE$CubeTextureLoader
}

declare export class BinaryTextureLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    load(
        url: string,
        onLoad: (dataTexture: THREE$DataTexture) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void
}

declare export class DataTextureLoader mixins BinaryTextureLoader {}

declare export class CompressedTextureLoader {
    constructor(manager?: THREE$LoadingManager): this;
    manager: THREE$LoadingManager;
    path: string;
    load(
        url: string,
        onLoad: (texture: THREE$CompressedTexture) => void,
        onProgress?: (event: any) => void,
        onError?: (event: any) => void): void;
    setPath(path: string): THREE$CompressedTextureLoader
}

declare export class AudioLoader {
    constructor(manager?: THREE$LoadingManager): this;
    load(url: string, onLoad: Function, onPrgress: Function, onError: Function): void
}


declare var npm$namespace$Cache: {
    add: typeof Cache$add,
    get: typeof Cache$get,
    remove: typeof Cache$remove,
    clear: typeof Cache$clear,
}
declare export var enabled: boolean;

declare export var files: any;

declare export function Cache$add(key: string, file: any): void

declare export function Cache$get(key: string): any

declare export function Cache$remove(key: string): void

declare export function Cache$clear(): void

declare export var MaterialIdCount: number;

declare export interface THREE$MaterialParameters {
    name?: string,
        side?: Side,
        opacity?: number,
        transparent?: boolean,
        blending?: Blending,
        blendSrc?: BlendingDstFactor,
        blendDst?: BlendingSrcFactor,
        blendEquation?: BlendingEquation,
        blendSrcAlpha?: number,
        blendDstAlpha?: number,
        blendEquationAlpha?: number,
        depthFunc?: DepthModes,
        depthTest?: boolean,
        depthWrite?: boolean,
        colorWrite?: boolean,
        precision?: number,
        polygonOffset?: boolean,
        polygonOffsetFactor?: number,
        polygonOffsetUnits?: number,
        alphaTest?: number,
        premultipliedAlpha?: boolean,
        overdraw?: number,
        visible?: boolean,
        fog?: boolean,
        lights?: boolean,
        shading?: Shading,
        vertexColors?: Colors
}


/**
 * Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.
 */
declare export class Material mixins EventDispatcher {
    constructor(): this;

    /**
     * Unique number of this material instance.
     */
    id: number;
    uuid: string;

    /**
     * Material name. Default is an empty string.
     */
    name: string;
    type: string;

    /**
     * Defines which of the face sides will be rendered - front, back or both.
     * Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.
     */
    side: Side;

    /**
     * Opacity. Default is 1.
     */
    opacity: number;

    /**
     * Defines whether this material is transparent. This has an effect on rendering, as transparent objects need an special treatment, and are rendered after the opaque (i.e. non transparent) objects. For a working example of this behaviour, check the {@link WebGLRenderer} code.
     * Default is false.
     */
    transparent: boolean;

    /**
     * Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.
     */
    blending: Blending;

    /**
     * Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.
     */
    blendSrc: BlendingDstFactor;

    /**
     * Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.
     */
    blendDst: BlendingSrcFactor;

    /**
     * Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is AddEquation.
     */
    blendEquation: BlendingEquation;
    blendSrcAlpha: number;
    blendDstAlpha: number;
    blendEquationAlpha: number;
    depthFunc: DepthModes;

    /**
     * Whether to have depth test enabled when rendering this material. Default is true.
     */
    depthTest: boolean;

    /**
     * Whether rendering this material has any effect on the depth buffer. Default is true.
     * When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.
     */
    depthWrite: boolean;
    clippingPlanes: any;
    clipShadows: boolean;
    colorWrite: boolean;
    precision: any;

    /**
     * Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.
     */
    polygonOffset: boolean;

    /**
     * Sets the polygon offset factor. Default is 0.
     */
    polygonOffsetFactor: number;

    /**
     * Sets the polygon offset units. Default is 0.
     */
    polygonOffsetUnits: number;

    /**
     * Sets the alpha value to be used when running an alpha test. Default is 0.
     */
    alphaTest: number;
    premultipliedAlpha: boolean;

    /**
     * Enables/disables overdraw. If greater than zero, polygons are drawn slightly bigger in order to fix antialiasing gaps when using the CanvasRenderer. Default is 0.
     */
    overdraw: number;

    /**
     * Defines whether this material is visible. Default is true.
     */
    visible: boolean;

    /**
     * Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.
     * This property is automatically set to true when instancing a new material.
     */
    needsUpdate: boolean;
    fog: boolean;
    lights: boolean;
    shading: Shading;
    vertexColors: Colors;
    setValues(parameters: THREE$MaterialParameters): void;
    toJSON(meta?: any): any;
    clone(): this;
    copy(source: this): this;
    update(): void;
    dispose(): void;
    warpRGB: THREE$Color
}

declare export type THREE$LineBasicMaterialParameters = {
    color?: number | string,
    linewidth?: number,
    linecap?: string,
    linejoin?: string
} & THREE$MaterialParameters


declare export class LineBasicMaterial mixins Material {
    constructor(parameters?: THREE$LineBasicMaterialParameters): this;
    color: THREE$Color;
    linewidth: number;
    linecap: string;
    linejoin: string;
    setValues(parameters: THREE$LineBasicMaterialParameters): void
}

declare export type THREE$LineDashedMaterialParameters = {
    color?: number | string,
    linewidth?: number,
    scale?: number,
    dashSize?: number,
    gapSize?: number
} & THREE$MaterialParameters


declare export class LineDashedMaterial mixins Material {
    constructor(parameters?: THREE$LineDashedMaterialParameters): this;
    color: THREE$Color;
    linewidth: number;
    scale: number;
    dashSize: number;
    gapSize: number;
    setValues(parameters: THREE$LineDashedMaterialParameters): void
}


/**
 * parameters is an object with one or more properties defining the material's appearance.
 */
declare export type THREE$MeshBasicMaterialParameters = {
    color?: number | string,
    opacity?: number,
    map?: THREE$Texture,
    aoMap?: THREE$Texture,
    aoMapIntensity?: number,
    specularMap?: THREE$Texture,
    alphaMap?: THREE$Texture,
    envMap?: THREE$Texture,
    combine?: Combine,
    reflectivity?: number,
    refractionRatio?: number,
    shading?: Shading,
    wireframe?: boolean,
    wireframeLinewidth?: number,
    wireframeLinecap?: string,
    wireframeLinejoin?: string,
    skinning?: boolean,
    morphTargets?: boolean
} & THREE$MaterialParameters


declare export class MeshBasicMaterial mixins Material {
    constructor(parameters?: THREE$MeshBasicMaterialParameters): this;
    color: THREE$Color;
    map: THREE$Texture;
    aoMap: THREE$Texture;
    aoMapIntensity: number;
    specularMap: THREE$Texture;
    alphaMap: THREE$Texture;
    envMap: THREE$Texture;
    combine: Combine;
    reflectivity: number;
    refractionRatio: number;
    shading: Shading;
    wireframe: boolean;
    wireframeLinewidth: number;
    wireframeLinecap: string;
    wireframeLinejoin: string;
    skinning: boolean;
    morphTargets: boolean;
    setValues(parameters: THREE$MeshBasicMaterialParameters): void
}

declare export type THREE$MeshDepthMaterialParameters = {
    wireframe?: boolean,
    wireframeLinewidth?: number
} & THREE$MaterialParameters


declare export class MeshDepthMaterial mixins Material {
    constructor(parameters?: THREE$MeshDepthMaterialParameters): this;
    wireframe: boolean;
    wireframeLinewidth: number;
    setValues(parameters: THREE$MeshDepthMaterialParameters): void
}

declare export type THREE$MeshLambertMaterialParameters = {
    color?: number | string,
    emissive?: number | string,
    emissiveIntensity?: number,
    emissiveMap?: THREE$Texture,
    map?: THREE$Texture,
    lighhtMap?: THREE$Texture,
    lightMapIntensity?: number,
    aoMap?: THREE$Texture,
    aoMapIntensity?: number,
    specularMap?: THREE$Texture,
    alphaMap?: THREE$Texture,
    envMap?: THREE$Texture,
    combine?: Combine,
    reflectivity?: number,
    refractionRatio?: number,
    wireframe?: boolean,
    wireframeLinewidth?: number,
    wireframeLinecap?: string,
    wireframeLinejoin?: string,
    skinning?: boolean,
    morphTargets?: boolean,
    morphNormals?: boolean
} & THREE$MaterialParameters


declare export class MeshLambertMaterial mixins Material {
    constructor(parameters?: THREE$MeshLambertMaterialParameters): this;
    color: THREE$Color;
    emissive: number | string;
    emissiveIntensity: number;
    emissiveMap: THREE$Texture;
    map: THREE$Texture;
    lighhtMap: THREE$Texture;
    lightMapIntensity: number;
    aoMap: THREE$Texture;
    aoMapIntensity: number;
    specularMap: THREE$Texture;
    alphaMap: THREE$Texture;
    envMap: THREE$Texture;
    combine: Combine;
    reflectivity: number;
    refractionRatio: number;
    wireframe: boolean;
    wireframeLinewidth: number;
    wireframeLinecap: string;
    wireframeLinejoin: string;
    skinning: boolean;
    morphTargets: boolean;
    morphNormals: boolean;
    setValues(parameters: THREE$MeshLambertMaterialParameters): void
}

declare export type THREE$MeshStandardMaterialParameters = {
    color?: number | string,
    roughness?: number,
    metalness?: number,
    map?: THREE$Texture,
    lighhtMap?: THREE$Texture,
    lightMapIntensity?: number,
    aoMap?: THREE$Texture,
    aoMapIntensity?: number,
    emissive?: THREE$Color,
    emissiveIntensity?: number,
    emissiveMap?: THREE$Texture,
    bumpMap?: THREE$Texture,
    bumpScale?: number,
    normalMap?: THREE$Texture,
    normalScale?: number,
    displacementMap?: THREE$Texture,
    displacementScale?: number,
    displacementBias?: number,
    roughnessMap?: THREE$Texture,
    metalMap?: THREE$Texture,
    alphaMap?: THREE$Texture,
    envMap?: THREE$Texture,
    envMapIntensity?: number,
    refractionRatio?: number,
    wireframe?: boolean,
    wireframeLinewidth?: number,
    skinning?: boolean,
    morphTargets?: boolean,
    morphNormals?: boolean
} & THREE$MaterialParameters


declare export class MeshStandardMaterial mixins Material {
    constructor(parameters?: THREE$MeshStandardMaterialParameters): this;
    defines: any;
    color: THREE$Color;
    roughness: number;
    metalness: number;
    map: THREE$Texture;
    lighhtMap: THREE$Texture;
    lightMapIntensity: number;
    aoMap: THREE$Texture;
    aoMapIntensity: number;
    emissive: THREE$Color;
    emissiveIntensity: number;
    emissiveMap: THREE$Texture;
    bumpMap: THREE$Texture;
    bumpScale: number;
    normalMap: THREE$Texture;
    normalScale: number;
    displacementMap: THREE$Texture;
    displacementScale: number;
    displacementBias: number;
    roughnessMap: THREE$Texture;
    metalMap: THREE$Texture;
    alphaMap: THREE$Texture;
    envMap: THREE$Texture;
    envMapIntensity: number;
    refractionRatio: number;
    wireframe: boolean;
    wireframeLinewidth: number;
    skinning: boolean;
    morphTargets: boolean;
    morphNormals: boolean;
    setValues(parameters: THREE$MeshStandardMaterialParameters): void
}

declare export type THREE$MeshNormalMaterialParameters = {

    /**
     * Render geometry as wireframe. Default is false (i.e. render as smooth shaded). 
     */
    wireframe?: boolean,

    /**
     * Controls wireframe thickness. Default is 1. 
     */
    wireframeLinewidth?: number,
    morphTargets?: boolean
} & THREE$MaterialParameters


declare export class MeshNormalMaterial mixins Material {
    constructor(parameters?: THREE$MeshNormalMaterialParameters): this;
    wireframe: boolean;
    wireframeLinewidth: number;
    morphTargets: boolean;
    setValues(parameters: THREE$MeshNormalMaterialParameters): void
}

declare export type THREE$MeshPhongMaterialParameters = {

    /**
     * geometry color in hexadecimal. Default is 0xffffff. 
     */
    color?: number | string,
    specular?: number,
    shininess?: number,
    opacity?: number,
    map?: THREE$Texture,
    lightMap?: THREE$Texture,
    lightMapIntensity?: number,
    aoMap?: THREE$Texture,
    aoMapIntensity?: number,
    emissive?: number,
    emissiveIntensity?: number,
    emissiveMap?: THREE$Texture,
    bumpMap?: THREE$Texture,
    bumpScale?: number,
    normalMap?: THREE$Texture,
    normalScale?: THREE$Vector2,
    displacementMap?: THREE$Texture,
    displacementScale?: number,
    displacementBias?: number,
    specularMap?: THREE$Texture,
    alphaMap?: THREE$Texture,
    envMap?: THREE$Texture,
    combine?: Combine,
    reflectivity?: number,
    refractionRatio?: number,
    wireframe?: boolean,
    wireframeLinewidth?: number,
    wireframeLinecap?: string,
    wireframeLinejoin?: string,
    skinning?: boolean,
    morphTargets?: boolean,
    morphNormals?: boolean
} & THREE$MaterialParameters


declare export class MeshPhongMaterial mixins Material {
    constructor(parameters?: THREE$MeshPhongMaterialParameters): this;
    color: THREE$Color;
    specular: THREE$Color;
    shininess: number;
    map: THREE$Texture;
    lightMap: THREE$Texture;
    lightMapIntensity: number;
    aoMap: THREE$Texture;
    aoMapIntensity: number;
    emissive: THREE$Color;
    emissiveIntensity: number;
    emissiveMap: THREE$Texture;
    bumpMap: THREE$Texture;
    bumpScale: number;
    normalMap: THREE$Texture;
    normalScale: THREE$Vector2;
    displacementMap: THREE$Texture;
    displacementScale: number;
    displacementBias: number;
    specularMap: THREE$Texture;
    alphaMap: THREE$Texture;
    envMap: THREE$Texture;
    combine: Combine;
    reflectivity: number;
    refractionRatio: number;
    wireframe: boolean;
    wireframeLinewidth: number;
    wireframeLinecap: string;
    wireframeLinejoin: string;
    skinning: boolean;
    morphTargets: boolean;
    morphNormals: boolean;
    metal: boolean;
    setValues(parameters: THREE$MeshPhongMaterialParameters): void
}

declare export type THREE$MeshPhysicalMaterialParameters = {
    reflectivity?: number,
    clearCoat?: number,
    clearCoatRoughness?: number
} & THREE$MeshStandardMaterialParameters


declare export class MeshPhysicalMaterial mixins MeshStandardMaterial {
    constructor(parameters: THREE$MeshPhysicalMaterialParameters): this;
    defines: any;
    reflectivity: number;
    clearCoat: number;
    clearCoatRoughness: number
}

declare export class MultiMaterial mixins Material {
    constructor(materials?: THREE$Material[]): this;
    materials: THREE$Material[];
    toJSON(meta: any): any
}

declare export class MeshFaceMaterial mixins MultiMaterial {}

declare export type THREE$PointsMaterialParameters = {
    color?: number | string,
    map?: THREE$Texture,
    size?: number,
    sizeAttenuation?: boolean
} & THREE$MaterialParameters


declare export class PointsMaterial mixins Material {
    constructor(parameters?: THREE$PointsMaterialParameters): this;
    color: THREE$Color;
    map: THREE$Texture;
    size: number;
    sizeAttenuation: boolean;
    setValues(parameters: THREE$PointsMaterialParameters): void
}

declare export class PointCloudMaterial mixins PointsMaterial {}

declare export class ParticleBasicMaterial mixins PointsMaterial {}

declare export class ParticleSystemMaterial mixins PointsMaterial {}

declare export type THREE$ShaderMaterialParameters = {
    defines?: any,
    uniforms?: any,
    vertexShader?: string,
    fragmentShader?: string,
    lineWidth?: number,
    wireframe?: boolean,
    wireframeLinewidth?: number,
    lights?: boolean,
    clipping?: boolean,
    skinning?: boolean,
    morphTargets?: boolean,
    morphNormals?: boolean
} & THREE$MaterialParameters


declare export class ShaderMaterial mixins Material {
    constructor(parameters?: THREE$ShaderMaterialParameters): this;
    defines: any;
    uniforms: any;
    vertexShader: string;
    fragmentShader: string;
    linewidth: number;
    wireframe: boolean;
    wireframeLinewidth: number;
    lights: boolean;
    clipping: boolean;
    skinning: boolean;
    morphTargets: boolean;
    morphNormals: boolean;
    derivatives: any;
    extensions: {
        derivatives: boolean,
        fragDepth: boolean,
        drawBuffers: boolean,
        shaderTextureLOD: boolean
    };
    defaultAttributeValues: any;
    index0AttributeName: string;
    setValues(parameters: THREE$ShaderMaterialParameters): void;
    toJSON(meta: any): any
}

declare export class RawShaderMaterial mixins ShaderMaterial {
    constructor(parameters?: THREE$ShaderMaterialParameters): this
}

declare export type THREE$SpriteMaterialParameters = {
    color?: number | string,
    map?: THREE$Texture,
    rotation?: number
} & THREE$MaterialParameters


declare export class SpriteMaterial mixins Material {
    constructor(parameters?: THREE$SpriteMaterialParameters): this;
    color: THREE$Color;
    map: THREE$Texture;
    rotation: number;
    setValues(parameters: THREE$SpriteMaterialParameters): void
}

declare export class ShadowMaterial mixins ShaderMaterial {
    constructor(parameters?: THREE$ShaderMaterialParameters): this
}

declare export class Box2 {
    constructor(min?: THREE$Vector2, max?: THREE$Vector2): this;
    max: THREE$Vector2;
    min: THREE$Vector2;
    set(min: THREE$Vector2, max: THREE$Vector2): THREE$Box2;
    setFromPoints(points: THREE$Vector2[]): THREE$Box2;
    setFromCenterAndSize(center: THREE$Vector2, size: THREE$Vector2): THREE$Box2;
    clone(): this;
    copy(box: this): this;
    makeEmpty(): THREE$Box2;
    isEmpty(): boolean;
    getCenter(optionalTarget?: THREE$Vector2): THREE$Vector2;
    getSize(optionalTarget?: THREE$Vector2): THREE$Vector2;
    expandByPoint(point: THREE$Vector2): THREE$Box2;
    expandByVector(vector: THREE$Vector2): THREE$Box2;
    expandByScalar(scalar: number): THREE$Box2;
    containsPoint(point: THREE$Vector2): boolean;
    containsBox(box: THREE$Box2): boolean;
    getParameter(point: THREE$Vector2): THREE$Vector2;
    intersectsBox(box: THREE$Box2): boolean;
    clampPoint(point: THREE$Vector2, optionalTarget?: THREE$Vector2): THREE$Vector2;
    distanceToPoint(point: THREE$Vector2): number;
    intersect(box: THREE$Box2): THREE$Box2;
    union(box: THREE$Box2): THREE$Box2;
    translate(offset: THREE$Vector2): THREE$Box2;
    equals(box: THREE$Box2): boolean;
    empty(): any;
    isIntersectionBox(b: any): any
}

declare export class Box3 {
    constructor(min?: THREE$Vector3, max?: THREE$Vector3): this;
    max: THREE$Vector3;
    min: THREE$Vector3;
    set(min: THREE$Vector3, max: THREE$Vector3): THREE$Box3;
    setFromArray(array: ArrayLike<number>): THREE$Box3;
    setFromPoints(points: THREE$Vector3[]): THREE$Box3;
    setFromCenterAndSize(center: THREE$Vector3, size: THREE$Vector3): THREE$Box3;
    setFromObject(object: THREE$Object3D): THREE$Box3;
    clone(): this;
    copy(box: this): this;
    makeEmpty(): THREE$Box3;
    isEmpty(): boolean;
    getCenter(optionalTarget?: THREE$Vector3): THREE$Vector3;
    getSize(optionalTarget?: THREE$Vector3): THREE$Vector3;
    expandByPoint(point: THREE$Vector3): THREE$Box3;
    expandByVector(vector: THREE$Vector3): THREE$Box3;
    expandByScalar(scalar: number): THREE$Box3;
    containsPoint(point: THREE$Vector3): boolean;
    containsBox(box: THREE$Box3): boolean;
    getParameter(point: THREE$Vector3): THREE$Vector3;
    intersectsBox(box: THREE$Box3): boolean;
    intersectsSphere(sphere: THREE$Sphere): boolean;
    intersectsPlane(plane: THREE$Plane): boolean;
    clampPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    distanceToPoint(point: THREE$Vector3): number;
    getBoundingSphere(optionalTarget?: THREE$Sphere): THREE$Sphere;
    intersect(box: THREE$Box3): THREE$Box3;
    union(box: THREE$Box3): THREE$Box3;
    applyMatrix4(matrix: THREE$Matrix4): THREE$Box3;
    translate(offset: THREE$Vector3): THREE$Box3;
    equals(box: THREE$Box3): boolean;
    empty(): any;
    isIntersectionBox(b: any): any;
    isIntersectionSphere(s: any): any
}

declare export interface THREE$HSL {
    h: number,
        s: number,
        l: number
}


/**
 * Represents a color. See also {@link ColorUtils}.
 * @example  * var color = new THREE.Color( 0xff0000 );
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Color.js">src/math/Color.js</a>
 */
declare export class Color {
    constructor(color?: THREE$Color): this;
    constructor(color?: string): this;
    constructor(color?: number): this;
    constructor(r: number, g: number, b: number): this;

    /**
     * Red channel value between 0 and 1. Default is 1.
     */
    r: number;

    /**
     * Green channel value between 0 and 1. Default is 1.
     */
    g: number;

    /**
     * Blue channel value between 0 and 1. Default is 1.
     */
    b: number;
    set(color: THREE$Color): THREE$Color;
    set(color: number): THREE$Color;
    set(color: string): THREE$Color;
    setScalar(scalar: number): THREE$Color;
    setHex(hex: number): THREE$Color;

    /**
     * Sets this color from RGB values.
     * @param r Red channel value between 0 and 1.
     * @param g Green channel value between 0 and 1.
     * @param b Blue channel value between 0 and 1.
     */
    setRGB(r: number, g: number, b: number): THREE$Color;

    /**
     * Sets this color from HSL values.
     * Based on MochiKit implementation by Bob Ippolito.
     * @param h Hue channel value between 0 and 1.
     * @param s Saturation value channel between 0 and 1.
     * @param l Value channel value between 0 and 1.
     */
    setHSL(h: number, s: number, l: number): THREE$Color;

    /**
     * Sets this color from a CSS context style string.
     * @param contextStyle Color in CSS context style format.
     */
    setStyle(style: string): THREE$Color;

    /**
     * Clones this color.
     */
    clone(): this;

    /**
     * Copies given color.
     * @param color Color to copy.
     */
    copy(color: this): this;

    /**
     * Copies given color making conversion from gamma to linear space.
     * @param color Color to copy.
     */
    copyGammaToLinear(color: THREE$Color, gammaFactor?: number): THREE$Color;

    /**
     * Copies given color making conversion from linear to gamma space.
     * @param color Color to copy.
     */
    copyLinearToGamma(color: THREE$Color, gammaFactor?: number): THREE$Color;

    /**
     * Converts this color from gamma to linear space.
     */
    convertGammaToLinear(): THREE$Color;

    /**
     * Converts this color from linear to gamma space.
     */
    convertLinearToGamma(): THREE$Color;

    /**
     * Returns the hexadecimal value of this color.
     */
    getHex(): number;

    /**
     * Returns the string formated hexadecimal value of this color.
     */
    getHexString(): string;
    getHSL(): THREE$HSL;

    /**
     * Returns the value of this color in CSS context style.
     * Example: rgb(r, g, b)
     */
    getStyle(): string;
    offsetHSL(h: number, s: number, l: number): THREE$Color;
    add(color: THREE$Color): THREE$Color;
    addColors(color1: THREE$Color, color2: THREE$Color): THREE$Color;
    addScalar(s: number): THREE$Color;
    sub(color: THREE$Color): THREE$Color;
    multiply(color: THREE$Color): THREE$Color;
    multiplyScalar(s: number): THREE$Color;
    lerp(color: THREE$Color, alpha: number): THREE$Color;
    equals(color: THREE$Color): boolean;
    fromArray(rgb: number[], offset?: number): THREE$Color;
    toArray(array?: number[], offset?: number): number[]
}

declare export var aliceblue: number;

declare export var antiquewhite: number;

declare export var aqua: number;

declare export var aquamarine: number;

declare export var azure: number;

declare export var beige: number;

declare export var bisque: number;

declare export var black: number;

declare export var blanchedalmond: number;

declare export var blue: number;

declare export var blueviolet: number;

declare export var brown: number;

declare export var burlywood: number;

declare export var cadetblue: number;

declare export var chartreuse: number;

declare export var chocolate: number;

declare export var coral: number;

declare export var cornflowerblue: number;

declare export var cornsilk: number;

declare export var crimson: number;

declare export var cyan: number;

declare export var darkblue: number;

declare export var darkcyan: number;

declare export var darkgoldenrod: number;

declare export var darkgray: number;

declare export var darkgreen: number;

declare export var darkgrey: number;

declare export var darkkhaki: number;

declare export var darkmagenta: number;

declare export var darkolivegreen: number;

declare export var darkorange: number;

declare export var darkorchid: number;

declare export var darkred: number;

declare export var darksalmon: number;

declare export var darkseagreen: number;

declare export var darkslateblue: number;

declare export var darkslategray: number;

declare export var darkslategrey: number;

declare export var darkturquoise: number;

declare export var darkviolet: number;

declare export var deeppink: number;

declare export var deepskyblue: number;

declare export var dimgray: number;

declare export var dimgrey: number;

declare export var dodgerblue: number;

declare export var firebrick: number;

declare export var floralwhite: number;

declare export var forestgreen: number;

declare export var fuchsia: number;

declare export var gainsboro: number;

declare export var ghostwhite: number;

declare export var gold: number;

declare export var goldenrod: number;

declare export var gray: number;

declare export var green: number;

declare export var greenyellow: number;

declare export var grey: number;

declare export var honeydew: number;

declare export var hotpink: number;

declare export var indianred: number;

declare export var indigo: number;

declare export var ivory: number;

declare export var khaki: number;

declare export var lavender: number;

declare export var lavenderblush: number;

declare export var lawngreen: number;

declare export var lemonchiffon: number;

declare export var lightblue: number;

declare export var lightcoral: number;

declare export var lightcyan: number;

declare export var lightgoldenrodyellow: number;

declare export var lightgray: number;

declare export var lightgreen: number;

declare export var lightgrey: number;

declare export var lightpink: number;

declare export var lightsalmon: number;

declare export var lightseagreen: number;

declare export var lightskyblue: number;

declare export var lightslategray: number;

declare export var lightslategrey: number;

declare export var lightsteelblue: number;

declare export var lightyellow: number;

declare export var lime: number;

declare export var limegreen: number;

declare export var linen: number;

declare export var magenta: number;

declare export var maroon: number;

declare export var mediumaquamarine: number;

declare export var mediumblue: number;

declare export var mediumorchid: number;

declare export var mediumpurple: number;

declare export var mediumseagreen: number;

declare export var mediumslateblue: number;

declare export var mediumspringgreen: number;

declare export var mediumturquoise: number;

declare export var mediumvioletred: number;

declare export var midnightblue: number;

declare export var mintcream: number;

declare export var mistyrose: number;

declare export var moccasin: number;

declare export var navajowhite: number;

declare export var navy: number;

declare export var oldlace: number;

declare export var olive: number;

declare export var olivedrab: number;

declare export var orange: number;

declare export var orangered: number;

declare export var orchid: number;

declare export var palegoldenrod: number;

declare export var palegreen: number;

declare export var paleturquoise: number;

declare export var palevioletred: number;

declare export var papayawhip: number;

declare export var peachpuff: number;

declare export var peru: number;

declare export var pink: number;

declare export var plum: number;

declare export var powderblue: number;

declare export var purple: number;

declare export var red: number;

declare export var rosybrown: number;

declare export var royalblue: number;

declare export var saddlebrown: number;

declare export var salmon: number;

declare export var sandybrown: number;

declare export var seagreen: number;

declare export var seashell: number;

declare export var sienna: number;

declare export var silver: number;

declare export var skyblue: number;

declare export var slateblue: number;

declare export var slategray: number;

declare export var slategrey: number;

declare export var snow: number;

declare export var springgreen: number;

declare export var steelblue: number;

declare export var tan: number;

declare export var teal: number;

declare export var thistle: number;

declare export var tomato: number;

declare export var turquoise: number;

declare export var violet: number;

declare export var wheat: number;

declare export var white: number;

declare export var whitesmoke: number;

declare export var yellow: number;

declare export var yellowgreen: number;

declare export class Euler {
    constructor(x?: number, y?: number, z?: number, order?: string): this;
    x: number;
    y: number;
    z: number;
    order: string;
    onChangeCallback: Function;
    set(x: number, y: number, z: number, order?: string): THREE$Euler;
    clone(): this;
    copy(euler: this): this;
    setFromRotationMatrix(m: THREE$Matrix4, order?: string, update?: boolean): THREE$Euler;
    setFromQuaternion(q: THREE$Quaternion, order?: string, update?: boolean): THREE$Euler;
    setFromVector3(v: THREE$Vector3, order?: string): THREE$Euler;
    reorder(newOrder: string): THREE$Euler;
    equals(euler: THREE$Euler): boolean;
    fromArray(xyzo: any[]): THREE$Euler;
    toArray(array?: number[], offset?: number): number[];
    toVector3(optionalResult?: THREE$Vector3): THREE$Vector3;
    onChange(callback: Function): void;
    RotationOrders: string[];
    DefaultOrder: string
}


/**
 * Frustums are used to determine what is inside the camera's field of view. They help speed up the rendering process.
 */
declare export class Frustum {
    constructor(p0?: THREE$Plane, p1?: THREE$Plane, p2?: THREE$Plane, p3?: THREE$Plane, p4?: THREE$Plane, p5?: THREE$Plane): this;

    /**
     * Array of 6 vectors.
     */
    planes: THREE$Plane[];
    set(
        p0?: number,
        p1?: number,
        p2?: number,
        p3?: number,
        p4?: number,
        p5?: number): THREE$Frustum;
    clone(): this;
    copy(frustum: this): this;
    setFromMatrix(m: THREE$Matrix4): THREE$Frustum;
    intersectsObject(object: THREE$Object3D): boolean;
    intersectsObject(sprite: THREE$Sprite): boolean;
    intersectsSphere(sphere: THREE$Sphere): boolean;
    intersectsBox(box: THREE$Box3): boolean;
    containsPoint(point: THREE$Vector3): boolean
}

declare export class Line3 {
    constructor(start?: THREE$Vector3, end?: THREE$Vector3): this;
    start: THREE$Vector3;
    end: THREE$Vector3;
    set(start?: THREE$Vector3, end?: THREE$Vector3): THREE$Line3;
    clone(): this;
    copy(line: this): this;
    getCenter(optionalTarget?: THREE$Vector3): THREE$Vector3;
    delta(optionalTarget?: THREE$Vector3): THREE$Vector3;
    distanceSq(): number;
    distance(): number;
    at(t: number, optionalTarget?: THREE$Vector3): THREE$Vector3;
    closestPointToPointParameter(point: THREE$Vector3, clampToLine?: boolean): number;
    closestPointToPoint(
        point: THREE$Vector3,
        clampToLine?: boolean,
        optionalTarget?: THREE$Vector3): THREE$Vector3;
    applyMatrix4(matrix: THREE$Matrix4): THREE$Line3;
    equals(line: THREE$Line3): boolean
}


declare var npm$namespace$Math: {
    generateUUID: typeof Math$generateUUID,
    clamp: typeof Math$clamp,
    euclideanModulo: typeof Math$euclideanModulo,
    mapLinear: typeof Math$mapLinear,
    smoothstep: typeof Math$smoothstep,
    smootherstep: typeof Math$smootherstep,
    random16: typeof Math$random16,
    randInt: typeof Math$randInt,
    randFloat: typeof Math$randFloat,
    randFloatSpread: typeof Math$randFloatSpread,
    degToRad: typeof Math$degToRad,
    radToDeg: typeof Math$radToDeg,
    isPowerOfTwo: typeof Math$isPowerOfTwo,
    nearestPowerOfTwo: typeof Math$nearestPowerOfTwo,
    nextPowerOfTwo: typeof Math$nextPowerOfTwo,
}
declare export var DEG2RAD: number;

declare export var RAD2DEG: number;

declare export function Math$generateUUID(): string


/**
 * Clamps the x to be between a and b.
 * @param value Value to be clamped.
 * @param min Minimum value
 * @param max Maximum value.
 */
declare export function Math$clamp(value: number, min: number, max: number): number

declare export function Math$euclideanModulo(n: number, m: number): number


/**
 * Linear mapping of x from range [a1, a2] to range [b1, b2].
 * @param x Value to be mapped.
 * @param a1 Minimum value for range A.
 * @param a2 Maximum value for range A.
 * @param b1 Minimum value for range B.
 * @param b2 Maximum value for range B.
 */
declare export function Math$mapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number

declare export function Math$smoothstep(x: number, min: number, max: number): number

declare export function Math$smootherstep(x: number, min: number, max: number): number


/**
 * Random float from 0 to 1 with 16 bits of randomness.
 * Standard Math.random() creates repetitive patterns when applied over larger space.
 */
declare export function Math$random16(): number


/**
 * Random integer from low to high interval.
 */
declare export function Math$randInt(low: number, high: number): number


/**
 * Random float from low to high interval.
 */
declare export function Math$randFloat(low: number, high: number): number


/**
 * Random float from - range / 2 to range / 2 interval.
 */
declare export function Math$randFloatSpread(range: number): number

declare export function Math$degToRad(degrees: number): number

declare export function Math$radToDeg(radians: number): number

declare export function Math$isPowerOfTwo(value: number): boolean

declare export function Math$nearestPowerOfTwo(value: number): number

declare export function Math$nextPowerOfTwo(value: number): number


/**
 * ( interface Matrix&lt;T&gt; )
 */
declare export interface THREE$Matrix {

    /**
     * Float32Array with matrix values.
     */
    elements: Float32Array,

        /**
         * identity():T;
         */
        identity(): THREE$Matrix,

        /**
         * copy(m:T):T;
         */
        copy(m: this): this,

        /**
         * multiplyScalar(s:number):T;
         */
        multiplyScalar(s: number): THREE$Matrix,
        determinant(): number,

        /**
         * getInverse(matrix:T, throwOnInvertible?:boolean):T;
         */
        getInverse(matrix: THREE$Matrix, throwOnInvertible?: boolean): THREE$Matrix,

        /**
         * transpose():T;
         */
        transpose(): THREE$Matrix,

        /**
         * clone():T;
         */
        clone(): this
}


/**
 * ( class Matrix3 implements Matrix&lt;Matrix3&gt; )
 */
declare export class Matrix3 mixins Matrix {

    /**
     * Creates an identity matrix.
     */
    constructor(): this;

    /**
     * Float32Array with matrix values.
     */
    elements: Float32Array;
    set(
        n11: number,
        n12: number,
        n13: number,
        n21: number,
        n22: number,
        n23: number,
        n31: number,
        n32: number,
        n33: number): THREE$Matrix3;
    identity(): THREE$Matrix3;
    clone(): this;
    copy(m: this): this;
    setFromMatrix4(m: THREE$Matrix4): THREE$Matrix3;
    applyToVector3Array(array: ArrayLike<number>, offset?: number, length?: number): ArrayLike<number>;
    applyToBuffer(
        buffer: THREE$BufferAttribute,
        offset?: number,
        length?: number): THREE$BufferAttribute;
    multiplyScalar(s: number): THREE$Matrix3;
    determinant(): number;
    getInverse(matrix: THREE$Matrix3, throwOnDegenerate?: boolean): THREE$Matrix3;

    /**
     * Transposes this matrix in place.
     */
    transpose(): THREE$Matrix3;
    getNormalMatrix(matrix4: THREE$Matrix4): THREE$Matrix3;

    /**
     * Transposes this matrix into the supplied array r, and returns itself.
     */
    transposeIntoArray(r: number[]): number[];
    fromArray(array: number[], offset?: number): THREE$Matrix3;
    toArray(): number[];
    multiplyVector3(vector: THREE$Vector3): any;
    multiplyVector3Array(a: any): any;
    getInverse(matrix: THREE$Matrix4, throwOnDegenerate?: boolean): THREE$Matrix3;
    flattenToArrayOffset(array: number[], offset: number): number[]
}


/**
 * A 4x4 Matrix.
 * @example  * // Simple rig for rotating around 3 axes
var m = new THREE.Matrix4();
var m1 = new THREE.Matrix4();
var m2 = new THREE.Matrix4();
var m3 = new THREE.Matrix4();
var alpha = 0;
var beta = Math.PI;
var gamma = Math.PI/2;
m1.makeRotationX( alpha );
m2.makeRotationY( beta );
m3.makeRotationZ( gamma );
m.multiplyMatrices( m1, m2 );
m.multiply( m3 );
*/
declare export class Matrix4 mixins Matrix {
    constructor(): this;

    /**
     * Float32Array with matrix values.
     */
    elements: Float32Array;

    /**
     * Sets all fields of this matrix.
     */
    set(
        n11: number,
        n12: number,
        n13: number,
        n14: number,
        n21: number,
        n22: number,
        n23: number,
        n24: number,
        n31: number,
        n32: number,
        n33: number,
        n34: number,
        n41: number,
        n42: number,
        n43: number,
        n44: number): THREE$Matrix4;

    /**
     * Resets this matrix to identity.
     */
    identity(): THREE$Matrix4;
    clone(): this;
    copy(m: this): this;
    copyPosition(m: THREE$Matrix4): THREE$Matrix4;
    extractBasis(
        xAxis: THREE$Vector3,
        yAxis: THREE$Vector3,
        zAxis: THREE$Vector3): THREE$Matrix4;
    makeBasis(
        xAxis: THREE$Vector3,
        yAxis: THREE$Vector3,
        zAxis: THREE$Vector3): THREE$Matrix4;

    /**
     * Copies the rotation component of the supplied matrix m into this matrix rotation component.
     */
    extractRotation(m: THREE$Matrix4): THREE$Matrix4;
    makeRotationFromEuler(euler: THREE$Euler): THREE$Matrix4;
    makeRotationFromQuaternion(q: THREE$Quaternion): THREE$Matrix4;

    /**
     * Constructs a rotation matrix, looking from eye towards center with defined up vector.
     */
    lookAt(eye: THREE$Vector3, target: THREE$Vector3, up: THREE$Vector3): THREE$Matrix4;

    /**
     * Multiplies this matrix by m.
     */
    multiply(m: THREE$Matrix4): THREE$Matrix4;
    premultiply(m: THREE$Matrix4): THREE$Matrix4;

    /**
     * Sets this matrix to a x b.
     */
    multiplyMatrices(a: THREE$Matrix4, b: THREE$Matrix4): THREE$Matrix4;

    /**
     * Sets this matrix to a x b and stores the result into the flat array r.
     * r can be either a regular Array or a TypedArray.
     */
    multiplyToArray(a: THREE$Matrix4, b: THREE$Matrix4, r: number[]): THREE$Matrix4;

    /**
     * Multiplies this matrix by s.
     */
    multiplyScalar(s: number): THREE$Matrix4;
    applyToVector3Array(array: ArrayLike<number>, offset?: number, length?: number): ArrayLike<number>;
    applyToBuffer(
        buffer: THREE$BufferAttribute,
        offset?: number,
        length?: number): THREE$BufferAttribute;

    /**
     * Computes determinant of this matrix.
     * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
     */
    determinant(): number;

    /**
     * Transposes this matrix.
     */
    transpose(): THREE$Matrix4;

    /**
     * Sets the position component for this matrix from vector v.
     */
    setPosition(v: THREE$Vector3): THREE$Matrix4;

    /**
     * Sets this matrix to the inverse of matrix m.
     * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm.
     */
    getInverse(m: THREE$Matrix4, throwOnDegeneratee?: boolean): THREE$Matrix4;

    /**
     * Multiplies the columns of this matrix by vector v.
     */
    scale(v: THREE$Vector3): THREE$Matrix4;
    getMaxScaleOnAxis(): number;

    /**
     * Sets this matrix as translation transform.
     */
    makeTranslation(x: number, y: number, z: number): THREE$Matrix4;

    /**
     * Sets this matrix as rotation transform around x axis by theta radians.
     * @param theta Rotation angle in radians.
     */
    makeRotationX(theta: number): THREE$Matrix4;

    /**
     * Sets this matrix as rotation transform around y axis by theta radians.
     * @param theta Rotation angle in radians.
     */
    makeRotationY(theta: number): THREE$Matrix4;

    /**
     * Sets this matrix as rotation transform around z axis by theta radians.
     * @param theta Rotation angle in radians.
     */
    makeRotationZ(theta: number): THREE$Matrix4;

    /**
     * Sets this matrix as rotation transform around axis by angle radians.
     * Based on http://www.gamedev.net/reference/articles/article1199.asp.
     * @param axis Rotation axis.
     * @param theta Rotation angle in radians.
     */
    makeRotationAxis(axis: THREE$Vector3, angle: number): THREE$Matrix4;

    /**
     * Sets this matrix as scale transform.
     */
    makeScale(x: number, y: number, z: number): THREE$Matrix4;

    /**
     * Sets this matrix to the transformation composed of translation, rotation and scale.
     */
    compose(
        translation: THREE$Vector3,
        rotation: THREE$Quaternion,
        scale: THREE$Vector3): THREE$Matrix4;

    /**
     * Decomposes this matrix into the translation, rotation and scale components.
     * If parameters are not passed, new instances will be created.
     */
    decompose(
        translation?: THREE$Vector3,
        rotation?: THREE$Quaternion,
        scale?: THREE$Vector3): Object[];

    /**
     * Creates a frustum matrix.
     */
    makeFrustum(
        left: number,
        right: number,
        bottom: number,
        top: number,
        near: number,
        far: number): THREE$Matrix4;

    /**
     * Creates a perspective projection matrix.
     */
    makePerspective(fov: number, aspect: number, near: number, far: number): THREE$Matrix4;

    /**
     * Creates an orthographic projection matrix.
     */
    makeOrthographic(
        left: number,
        right: number,
        top: number,
        bottom: number,
        near: number,
        far: number): THREE$Matrix4;
    equals(matrix: THREE$Matrix4): boolean;
    fromArray(array: number[], offset?: number): THREE$Matrix4;
    toArray(): number[];
    extractPosition(m: THREE$Matrix4): THREE$Matrix4;
    setRotationFromQuaternion(q: THREE$Quaternion): THREE$Matrix4;
    multiplyVector3(v: any): any;
    multiplyVector4(v: any): any;
    multiplyVector3Array(array: number[]): number[];
    rotateAxis(v: any): void;
    crossVector(v: any): void;
    flattenToArrayOffset(array: number[], offset: number): number[]
}

declare export class Plane {
    constructor(normal?: THREE$Vector3, constant?: number): this;
    normal: THREE$Vector3;
    constant: number;
    set(normal: THREE$Vector3, constant: number): THREE$Plane;
    setComponents(x: number, y: number, z: number, w: number): THREE$Plane;
    setFromNormalAndCoplanarPoint(normal: THREE$Vector3, point: THREE$Vector3): THREE$Plane;
    setFromCoplanarPoints(a: THREE$Vector3, b: THREE$Vector3, c: THREE$Vector3): THREE$Plane;
    clone(): this;
    copy(plane: this): this;
    normalize(): THREE$Plane;
    negate(): THREE$Plane;
    distanceToPoint(point: THREE$Vector3): number;
    distanceToSphere(sphere: THREE$Sphere): number;
    projectPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    orthoPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    intersectLine(line: THREE$Line3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    intersectsLine(line: THREE$Line3): boolean;
    intersectsBox(box: THREE$Box3): boolean;
    coplanarPoint(optionalTarget?: boolean): THREE$Vector3;
    applyMatrix4(matrix: THREE$Matrix4, optionalNormalMatrix?: THREE$Matrix3): THREE$Plane;
    translate(offset: THREE$Vector3): THREE$Plane;
    equals(plane: THREE$Plane): boolean;
    isIntersectionLine(l: any): any
}

declare export class Spherical {
    constructor(radius?: number, phi?: number, theta?: number): this;
    set(radius: number, phi: number, theta: number): THREE$Spherical;
    clone(): this;
    copy(other: this): this;
    makeSafe(): void;
    setFromVector3(vec3: THREE$Vector3): THREE$Spherical
}


/**
 * Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.
 * @example  * var quaternion = new THREE.Quaternion();
quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
var vector = new THREE.Vector3( 1, 0, 0 );
vector.applyQuaternion( quaternion );
*/
declare export class Quaternion {

    /**
     * 
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     */
    constructor(x?: number, y?: number, z?: number, w?: number): this;
    x: number;
    y: number;
    z: number;
    w: number;

    /**
     * Sets values of this quaternion.
     */
    set(x: number, y: number, z: number, w: number): THREE$Quaternion;

    /**
     * Clones this quaternion.
     */
    clone(): this;

    /**
     * Copies values of q to this quaternion.
     */
    copy(q: this): this;

    /**
     * Sets this quaternion from rotation specified by Euler angles.
     */
    setFromEuler(euler: THREE$Euler, update?: boolean): THREE$Quaternion;

    /**
     * Sets this quaternion from rotation specified by axis and angle.
     * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
    Axis have to be normalized, angle is in radians.
    */
    setFromAxisAngle(axis: THREE$Vector3, angle: number): THREE$Quaternion;

    /**
     * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
     */
    setFromRotationMatrix(m: THREE$Matrix4): THREE$Quaternion;
    setFromUnitVectors(vFrom: THREE$Vector3, vTo: THREE$Vector3): THREE$Quaternion;

    /**
     * Inverts this quaternion.
     */
    inverse(): THREE$Quaternion;
    conjugate(): THREE$Quaternion;
    dot(v: THREE$Vector3): number;
    lengthSq(): number;

    /**
     * Computes length of this quaternion.
     */
    length(): number;

    /**
     * Normalizes this quaternion.
     */
    normalize(): THREE$Quaternion;

    /**
     * Multiplies this quaternion by b.
     */
    multiply(q: THREE$Quaternion): THREE$Quaternion;
    premultiply(q: THREE$Quaternion): THREE$Quaternion;

    /**
     * Sets this quaternion to a x b
     * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
     */
    multiplyQuaternions(a: THREE$Quaternion, b: THREE$Quaternion): THREE$Quaternion;
    slerp(qb: THREE$Quaternion, t: number): THREE$Quaternion;
    equals(v: THREE$Quaternion): boolean;
    fromArray(n: number[]): THREE$Quaternion;
    toArray(): number[];
    fromArray(xyzw: number[], offset?: number): THREE$Quaternion;
    toArray(xyzw?: number[], offset?: number): number[];
    onChange(callback: Function): THREE$Quaternion;
    onChangeCallback: Function;

    /**
     * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/.
     */
    slerp(
        qa: THREE$Quaternion,
        qb: THREE$Quaternion,
        qm: THREE$Quaternion,
        t: number): THREE$Quaternion;
    slerpFlat(
        dst: number[],
        dstOffset: number,
        src0: number[],
        srcOffset: number,
        src1: number[],
        stcOffset1: number,
        t: number): THREE$Quaternion;
    multiplyVector3(v: any): any
}

declare export class Ray {
    constructor(origin?: THREE$Vector3, direction?: THREE$Vector3): this;
    origin: THREE$Vector3;
    direction: THREE$Vector3;
    set(origin: THREE$Vector3, direction: THREE$Vector3): THREE$Ray;
    clone(): this;
    copy(ray: this): this;
    at(t: number, optionalTarget?: THREE$Vector3): THREE$Vector3;
    lookAt(v: THREE$Vector3): THREE$Vector3;
    recast(t: number): THREE$Ray;
    closestPointToPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    distanceToPoint(point: THREE$Vector3): number;
    distanceSqToPoint(point: THREE$Vector3): number;
    distanceSqToSegment(
        v0: THREE$Vector3,
        v1: THREE$Vector3,
        optionalPointOnRay?: THREE$Vector3,
        optionalPointOnSegment?: THREE$Vector3): number;
    intersectSphere(sphere: THREE$Sphere, optionalTarget?: THREE$Vector3): THREE$Vector3;
    intersectsSphere(sphere: THREE$Sphere): boolean;
    distanceToPlane(plane: THREE$Plane): number;
    intersectPlane(plane: THREE$Plane, optionalTarget?: THREE$Vector3): THREE$Vector3;
    intersectsPlane(plane: THREE$Plane): boolean;
    intersectBox(box: THREE$Box3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    intersectsBox(box: THREE$Box3): boolean;
    intersectTriangle(
        a: THREE$Vector3,
        b: THREE$Vector3,
        c: THREE$Vector3,
        backfaceCulling: boolean,
        optionalTarget?: THREE$Vector3): THREE$Vector3;
    applyMatrix4(matrix4: THREE$Matrix4): THREE$Ray;
    equals(ray: THREE$Ray): boolean;
    isIntersectionBox(b: any): any;
    isIntersectionPlane(p: any): any;
    isIntersectionSphere(s: any): any
}

declare export class Sphere {
    constructor(center?: THREE$Vector3, radius?: number): this;
    center: THREE$Vector3;
    radius: number;
    set(center: THREE$Vector3, radius: number): THREE$Sphere;
    setFromPoints(points: THREE$Vector3[], optionalCenter?: THREE$Vector3): THREE$Sphere;
    clone(): this;
    copy(sphere: this): this;
    empty(): boolean;
    containsPoint(point: THREE$Vector3): boolean;
    distanceToPoint(point: THREE$Vector3): number;
    intersectsSphere(sphere: THREE$Sphere): boolean;
    intersectsBox(box: THREE$Box3): boolean;
    intersectsPlane(plane: THREE$Plane): boolean;
    clampPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    getBoundingBox(optionalTarget?: THREE$Box3): THREE$Box3;
    applyMatrix4(matrix: THREE$Matrix4): THREE$Sphere;
    translate(offset: THREE$Vector3): THREE$Sphere;
    equals(sphere: THREE$Sphere): boolean
}

declare export interface THREE$SplineControlPoint {
    x: number,
        y: number,
        z: number
}


/**
 * Represents a spline.
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Spline.js">src/math/Spline.js</a>
 */
declare export class Spline {

    /**
     * Initialises the spline with points, which are the places through which the spline will go.
     */
    constructor(points: THREE$SplineControlPoint[]): this;
    points: THREE$SplineControlPoint[];

    /**
     * Initialises using the data in the array as a series of points. Each value in a must be another array with three values, where a[n] is v, the value for the nth point, and v[0], v[1] and v[2] are the x, y and z coordinates of that point n, respectively.
     * @param a array of triplets containing x, y, z coordinates
     */
    initFromArray(a: number[][]): void;

    /**
     * Return the interpolated point at k.
     * @param k point index
     */
    getPoint(k: number): THREE$SplineControlPoint;

    /**
     * Returns an array with triplets of x, y, z coordinates that correspond to the current control points.
     */
    getControlPointsArray(): number[][];

    /**
     * Returns the length of the spline when using nSubDivisions.
     * @param nSubDivisions number of subdivisions between control points. Default is 100.
     */
    getLength(nSubDivisions?: number): {
        chunks: number[],
        total: number
    };

    /**
     * Modifies the spline so that it looks similar to the original but has its points distributed in such way that moving along the spline it's done at a more or less constant speed. The points should also appear more uniformly spread along the curve.
     * This is done by resampling the original spline, with the density of sampling controlled by samplingCoef. Here it's interesting to note that denser sampling is not necessarily better: if sampling is too high, you may get weird kinks in curvature.
     * @param samplingCoef how many intermediate values to use between spline points
     */
    reparametrizeByArcLength(samplingCoef: number): void
}

declare class Triangle {
    constructor(a?: THREE$Vector3, b?: THREE$Vector3, c?: THREE$Vector3): this;
    a: THREE$Vector3;
    b: THREE$Vector3;
    c: THREE$Vector3;
    set(a: THREE$Vector3, b: THREE$Vector3, c: THREE$Vector3): THREE$Triangle;
    setFromPointsAndIndices(points: THREE$Vector3[], i0: number, i1: number, i2: number): THREE$Triangle;
    clone(): this;
    copy(triangle: this): this;
    area(): number;
    midpoint(optionalTarget?: THREE$Vector3): THREE$Vector3;
    normal(optionalTarget?: THREE$Vector3): THREE$Vector3;
    plane(optionalTarget?: THREE$Vector3): THREE$Plane;
    barycoordFromPoint(point: THREE$Vector3, optionalTarget?: THREE$Vector3): THREE$Vector3;
    containsPoint(point: THREE$Vector3): boolean;
    closestPointToPoint(): THREE$Vector3;
    equals(triangle: THREE$Triangle): boolean;
    normal(
        a: THREE$Vector3,
        b: THREE$Vector3,
        c: THREE$Vector3,
        optionalTarget?: THREE$Vector3): THREE$Vector3;
    barycoordFromPoint(
        point: THREE$Vector3,
        a: THREE$Vector3,
        b: THREE$Vector3,
        c: THREE$Vector3,
        optionalTarget: THREE$Vector3): THREE$Vector3;
    containsPoint(
        point: THREE$Vector3,
        a: THREE$Vector3,
        b: THREE$Vector3,
        c: THREE$Vector3): boolean
}


/**
 * ( interface Vector&lt;T&gt; )
 * 
Abstract interface of Vector2, Vector3 and Vector4.
Currently the members of Vector is NOT type safe because it accepts different typed vectors.
Those definitions will be changed when TypeScript innovates Generics to be type safe.
 * @example  * var v:THREE.Vector = new THREE.Vector3();
v.addVectors(new THREE.Vector2(0, 1), new THREE.Vector2(2, 3));    // invalid but compiled successfully
*/
declare export interface THREE$Vector {
    setComponent(index: number, value: number): void,
        getComponent(index: number): number,

        /**
         * copy(v:T):T;
         */
        copy(v: this): this,

        /**
         * add(v:T):T;
         */
        add(v: THREE$Vector): THREE$Vector,

        /**
         * addVectors(a:T, b:T):T;
         */
        addVectors(a: THREE$Vector, b: THREE$Vector): THREE$Vector,

        /**
         * sub(v:T):T;
         */
        sub(v: THREE$Vector): THREE$Vector,

        /**
         * subVectors(a:T, b:T):T;
         */
        subVectors(a: THREE$Vector, b: THREE$Vector): THREE$Vector,

        /**
         * multiplyScalar(s:number):T;
         */
        multiplyScalar(s: number): THREE$Vector,

        /**
         * divideScalar(s:number):T;
         */
        divideScalar(s: number): THREE$Vector,

        /**
         * negate():T;
         */
        negate(): THREE$Vector,

        /**
         * dot(v:T):T;
         */
        dot(v: THREE$Vector): number,

        /**
         * lengthSq():number;
         */
        lengthSq(): number,

        /**
         * length():number;
         */
        length(): number,

        /**
         * normalize():T;
         */
        normalize(): THREE$Vector,

        /**
         * NOTE: Vector4 doesn't have the property.
         * 
        distanceTo(v:T):number;
        */
        distanceTo(v: THREE$Vector): number,

        /**
         * NOTE: Vector4 doesn't have the property.
         * 
        distanceToSquared(v:T):number;
        */
        distanceToSquared(v: THREE$Vector): number,

        /**
         * setLength(l:number):T;
         */
        setLength(l: number): THREE$Vector,

        /**
         * lerp(v:T, alpha:number):T;
         */
        lerp(v: THREE$Vector, alpha: number): THREE$Vector,

        /**
         * equals(v:T):boolean;
         */
        equals(v: THREE$Vector): boolean,

        /**
         * clone():T;
         */
        clone(): this
}


/**
 * 2D vector.
 * 
( class Vector2 implements Vector<Vector2> )
*/
declare export class Vector2 mixins Vector {
    constructor(x?: number, y?: number): this;
    x: number;
    y: number;
    width: number;
    height: number;

    /**
     * Sets value of this vector.
     */
    set(x: number, y: number): THREE$Vector2;
    setScalar(scalar: number): THREE$Vector2;

    /**
     * Sets X component of this vector.
     */
    setX(x: number): THREE$Vector2;

    /**
     * Sets Y component of this vector.
     */
    setY(y: number): THREE$Vector2;

    /**
     * Sets a component of this vector.
     */
    setComponent(index: number, value: number): void;

    /**
     * Gets a component of this vector.
     */
    getComponent(index: number): number;

    /**
     * Clones this vector.
     */
    clone(): this;

    /**
     * Copies value of v to this vector.
     */
    copy(v: this): this;

    /**
     * Adds v to this vector.
     */
    add(v: THREE$Vector2): THREE$Vector2;

    /**
     * Sets this vector to a + b.
     */
    addScalar(s: number): THREE$Vector2;
    addVectors(a: THREE$Vector2, b: THREE$Vector2): THREE$Vector2;
    addScaledVector(v: THREE$Vector2, s: number): THREE$Vector2;

    /**
     * Subtracts v from this vector.
     */
    sub(v: THREE$Vector2): THREE$Vector2;

    /**
     * Sets this vector to a - b.
     */
    subVectors(a: THREE$Vector2, b: THREE$Vector2): THREE$Vector2;
    multiply(v: THREE$Vector2): THREE$Vector2;

    /**
     * Multiplies this vector by scalar s.
     */
    multiplyScalar(scalar: number): THREE$Vector2;
    divide(v: THREE$Vector2): THREE$Vector2;

    /**
     * Divides this vector by scalar s.
     * Set vector to ( 0, 0 ) if s == 0.
     */
    divideScalar(s: number): THREE$Vector2;
    min(v: THREE$Vector2): THREE$Vector2;
    max(v: THREE$Vector2): THREE$Vector2;
    clamp(min: THREE$Vector2, max: THREE$Vector2): THREE$Vector2;
    clampScalar(min: number, max: number): THREE$Vector2;
    clampLength(min: number, max: number): THREE$Vector2;
    floor(): THREE$Vector2;
    ceil(): THREE$Vector2;
    round(): THREE$Vector2;
    roundToZero(): THREE$Vector2;

    /**
     * Inverts this vector.
     */
    negate(): THREE$Vector2;

    /**
     * Computes dot product of this vector and v.
     */
    dot(v: THREE$Vector2): number;

    /**
     * Computes squared length of this vector.
     */
    lengthSq(): number;

    /**
     * Computes length of this vector.
     */
    length(): number;
    lengthManhattan(): number;

    /**
     * Normalizes this vector.
     */
    normalize(): THREE$Vector2;

    /**
     * computes the angle in radians with respect to the positive x-axis
     */
    angle(): number;

    /**
     * Computes distance of this vector to v.
     */
    distanceTo(v: THREE$Vector2): number;

    /**
     * Computes squared distance of this vector to v.
     */
    distanceToSquared(v: THREE$Vector2): number;
    distanceToManhattan(v: THREE$Vector2): number;

    /**
     * Normalizes this vector and multiplies it by l.
     */
    setLength(length: number): THREE$Vector2;
    lerp(v: THREE$Vector2, alpha: number): THREE$Vector2;
    lerpVectors(v1: THREE$Vector2, v2: THREE$Vector2, alpha: number): THREE$Vector2;

    /**
     * Checks for strict equality of this vector and v.
     */
    equals(v: THREE$Vector2): boolean;
    fromArray(xy: number[], offset?: number): THREE$Vector2;
    toArray(xy?: number[], offset?: number): number[];
    fromAttribute(
        attribute: THREE$BufferAttribute,
        index: number,
        offset?: number): THREE$Vector2;
    rotateAround(center: THREE$Vector2, angle: number): THREE$Vector2
}


/**
 * 3D vector.
 * @example  * var a = new THREE.Vector3( 1, 0, 0 );
var b = new THREE.Vector3( 0, 1, 0 );
var c = new THREE.Vector3();
c.crossVectors( a, b );
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js">src/math/Vector3.js</a>

( class Vector3 implements Vector<Vector3> )
*/
declare export class Vector3 mixins Vector {
    constructor(x?: number, y?: number, z?: number): this;
    x: number;
    y: number;
    z: number;

    /**
     * Sets value of this vector.
     */
    set(x: number, y: number, z: number): THREE$Vector3;

    /**
     * Sets all values of this vector.
     */
    setScalar(scalar: number): THREE$Vector3;

    /**
     * Sets x value of this vector.
     */
    setX(x: number): THREE$Vector3;

    /**
     * Sets y value of this vector.
     */
    setY(y: number): THREE$Vector3;

    /**
     * Sets z value of this vector.
     */
    setZ(z: number): THREE$Vector3;
    setComponent(index: number, value: number): void;
    getComponent(index: number): number;

    /**
     * Clones this vector.
     */
    clone(): this;

    /**
     * Copies value of v to this vector.
     */
    copy(v: this): this;

    /**
     * Adds v to this vector.
     */
    add(a: THREE$Vector3): THREE$Vector3;
    addScalar(s: number): THREE$Vector3;
    addScaledVector(v: THREE$Vector3, s: number): THREE$Vector3;

    /**
     * Sets this vector to a + b.
     */
    addVectors(a: THREE$Vector3, b: THREE$Vector3): THREE$Vector3;

    /**
     * Subtracts v from this vector.
     */
    sub(a: THREE$Vector3): THREE$Vector3;
    subScalar(s: number): THREE$Vector3;

    /**
     * Sets this vector to a - b.
     */
    subVectors(a: THREE$Vector3, b: THREE$Vector3): THREE$Vector3;
    multiply(v: THREE$Vector3): THREE$Vector3;

    /**
     * Multiplies this vector by scalar s.
     */
    multiplyScalar(s: number): THREE$Vector3;
    multiplyVectors(a: THREE$Vector3, b: THREE$Vector3): THREE$Vector3;
    applyEuler(euler: THREE$Euler): THREE$Vector3;
    applyAxisAngle(axis: THREE$Vector3, angle: number): THREE$Vector3;
    applyMatrix3(m: THREE$Matrix3): THREE$Vector3;
    applyMatrix4(m: THREE$Matrix4): THREE$Vector3;
    applyProjection(m: THREE$Matrix4): THREE$Vector3;
    applyQuaternion(q: THREE$Quaternion): THREE$Vector3;
    project(camrea: THREE$Camera): THREE$Vector3;
    unproject(camera: THREE$Camera): THREE$Vector3;
    transformDirection(m: THREE$Matrix4): THREE$Vector3;
    divide(v: THREE$Vector3): THREE$Vector3;

    /**
     * Divides this vector by scalar s.
     * Set vector to ( 0, 0, 0 ) if s == 0.
     */
    divideScalar(s: number): THREE$Vector3;
    min(v: THREE$Vector3): THREE$Vector3;
    max(v: THREE$Vector3): THREE$Vector3;
    clamp(min: THREE$Vector3, max: THREE$Vector3): THREE$Vector3;
    clampScalar(min: number, max: number): THREE$Vector3;
    clampLength(min: number, max: number): THREE$Vector3;
    floor(): THREE$Vector3;
    ceil(): THREE$Vector3;
    round(): THREE$Vector3;
    roundToZero(): THREE$Vector3;

    /**
     * Inverts this vector.
     */
    negate(): THREE$Vector3;

    /**
     * Computes dot product of this vector and v.
     */
    dot(v: THREE$Vector3): number;

    /**
     * Computes squared length of this vector.
     */
    lengthSq(): number;

    /**
     * Computes length of this vector.
     */
    length(): number;

    /**
     * Computes Manhattan length of this vector.
     * http://en.wikipedia.org/wiki/Taxicab_geometry
     */
    lengthManhattan(): number;

    /**
     * Normalizes this vector.
     */
    normalize(): THREE$Vector3;

    /**
     * Normalizes this vector and multiplies it by l.
     */
    setLength(l: number): THREE$Vector3;
    lerp(v: THREE$Vector3, alpha: number): THREE$Vector3;
    lerpVectors(v1: THREE$Vector3, v2: THREE$Vector3, alpha: number): THREE$Vector3;

    /**
     * Sets this vector to cross product of itself and v.
     */
    cross(a: THREE$Vector3): THREE$Vector3;

    /**
     * Sets this vector to cross product of a and b.
     */
    crossVectors(a: THREE$Vector3, b: THREE$Vector3): THREE$Vector3;
    projectOnVector(v: THREE$Vector3): THREE$Vector3;
    projectOnPlane(planeNormal: THREE$Vector3): THREE$Vector3;
    reflect(vector: THREE$Vector3): THREE$Vector3;
    angleTo(v: THREE$Vector3): number;

    /**
     * Computes distance of this vector to v.
     */
    distanceTo(v: THREE$Vector3): number;

    /**
     * Computes squared distance of this vector to v.
     */
    distanceToSquared(v: THREE$Vector3): number;
    distanceToManhattan(v: THREE$Vector3): number;
    setFromSpherical(s: THREE$Spherical): THREE$Matrix3;
    setFromMatrixPosition(m: THREE$Matrix4): THREE$Vector3;
    setFromMatrixScale(m: THREE$Matrix4): THREE$Vector3;
    setFromMatrixColumn(matrix: THREE$Matrix4, index: number): THREE$Vector3;

    /**
     * Checks for strict equality of this vector and v.
     */
    equals(v: THREE$Vector3): boolean;
    fromArray(xyz: number[], offset?: number): THREE$Vector3;
    toArray(xyz?: number[], offset?: number): number[];
    fromAttribute(
        attribute: THREE$BufferAttribute,
        index: number,
        offset?: number): THREE$Vector3;
    getPositionFromMatrix(m: THREE$Matrix4): THREE$Vector3;
    getScaleFromMatrix(m: THREE$Matrix4): THREE$Vector3;
    getColumnFromMatrix(index: number, matrix: THREE$Matrix4): THREE$Vector3
}

declare export class Vertex mixins Vector3 {}


/**
 * 4D vector.
 * 
( class Vector4 implements Vector<Vector4> )
*/
declare export class Vector4 mixins Vector {
    constructor(x?: number, y?: number, z?: number, w?: number): this;
    x: number;
    y: number;
    z: number;
    w: number;

    /**
     * Sets value of this vector.
     */
    set(x: number, y: number, z: number, w: number): THREE$Vector4;

    /**
     * Sets all values of this vector.
     */
    setScalar(scalar: number): THREE$Vector4;

    /**
     * Sets X component of this vector.
     */
    setX(x: number): THREE$Vector4;

    /**
     * Sets Y component of this vector.
     */
    setY(y: number): THREE$Vector4;

    /**
     * Sets Z component of this vector.
     */
    setZ(z: number): THREE$Vector4;

    /**
     * Sets w component of this vector.
     */
    setW(w: number): THREE$Vector4;
    setComponent(index: number, value: number): void;
    getComponent(index: number): number;

    /**
     * Clones this vector.
     */
    clone(): this;

    /**
     * Copies value of v to this vector.
     */
    copy(v: this): this;

    /**
     * Adds v to this vector.
     */
    add(v: THREE$Vector4): THREE$Vector4;
    addScalar(s: number): THREE$Vector4;

    /**
     * Sets this vector to a + b.
     */
    addVectors(a: THREE$Vector4, b: THREE$Vector4): THREE$Vector4;
    addScaledVector(v: THREE$Vector4, s: number): THREE$Vector4;

    /**
     * Subtracts v from this vector.
     */
    sub(v: THREE$Vector4): THREE$Vector4;
    subScalar(s: number): THREE$Vector4;

    /**
     * Sets this vector to a - b.
     */
    subVectors(a: THREE$Vector4, b: THREE$Vector4): THREE$Vector4;

    /**
     * Multiplies this vector by scalar s.
     */
    multiplyScalar(s: number): THREE$Vector4;
    applyMatrix4(m: THREE$Matrix4): THREE$Vector4;

    /**
     * Divides this vector by scalar s.
     * Set vector to ( 0, 0, 0 ) if s == 0.
     */
    divideScalar(s: number): THREE$Vector4;

    /**
     * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
     * @param q is assumed to be normalized
     */
    setAxisAngleFromQuaternion(q: THREE$Quaternion): THREE$Vector4;

    /**
     * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
     * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
     */
    setAxisAngleFromRotationMatrix(m: THREE$Matrix3): THREE$Vector4;
    min(v: THREE$Vector4): THREE$Vector4;
    max(v: THREE$Vector4): THREE$Vector4;
    clamp(min: THREE$Vector4, max: THREE$Vector4): THREE$Vector4;
    clampScalar(min: number, max: number): THREE$Vector4;
    floor(): THREE$Vector4;
    ceil(): THREE$Vector4;
    round(): THREE$Vector4;
    roundToZero(): THREE$Vector4;

    /**
     * Inverts this vector.
     */
    negate(): THREE$Vector4;

    /**
     * Computes dot product of this vector and v.
     */
    dot(v: THREE$Vector4): number;

    /**
     * Computes squared length of this vector.
     */
    lengthSq(): number;

    /**
     * Computes length of this vector.
     */
    length(): number;
    lengthManhattan(): number;

    /**
     * Normalizes this vector.
     */
    normalize(): THREE$Vector4;

    /**
     * Normalizes this vector and multiplies it by l.
     */
    setLength(length: number): THREE$Vector4;

    /**
     * Linearly interpolate between this vector and v with alpha factor.
     */
    lerp(v: THREE$Vector4, alpha: number): THREE$Vector4;
    lerpVectors(v1: THREE$Vector4, v2: THREE$Vector4, alpha: number): THREE$Vector4;

    /**
     * Checks for strict equality of this vector and v.
     */
    equals(v: THREE$Vector4): boolean;
    fromArray(xyzw: number[], offset?: number): THREE$Vector4;
    toArray(xyzw?: number[], offset?: number): number[];
    fromAttribute(
        attribute: THREE$BufferAttribute,
        index: number,
        offset?: number): THREE$Vector4
}

declare export class Interpolant {
    constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any): this;
    parameterPositions: any;
    samplesValues: any;
    valueSize: number;
    resultBuffer: any;
    evaluate(time: number): any
}

declare export class CubicInterpolant mixins Interpolant {
    constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any): this;
    interpolate_(i1: number, t0: number, t: number, t1: number): any
}

declare export class DiscreteInterpolant mixins Interpolant {
    constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any): this;
    interpolate_(i1: number, t0: number, t: number, t1: number): any
}

declare export class LinearInterpolant mixins Interpolant {
    constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any): this;
    interpolate_(i1: number, t0: number, t: number, t1: number): any
}

declare export class QuaternionLinearInterpolant mixins Interpolant {
    constructor(parameterPositions: any, samplesValues: any, sampleSize: number, resultBuffer?: any): this;
    interpolate_(i1: number, t0: number, t: number, t1: number): any
}

declare export class Bone mixins Object3D {
    constructor(skin: THREE$SkinnedMesh): this;
    skin: THREE$SkinnedMesh
}

declare export class Group mixins Object3D {
    constructor(): this
}

declare export class LOD mixins Object3D {
    constructor(): this;
    levels: any[];
    addLevel(object: THREE$Object3D, distance?: number): void;
    getObjectForDistance(distance: number): THREE$Object3D;
    raycast(raycaster: THREE$Raycaster, intersects: any): void;
    update(camera: THREE$Camera): void;
    toJSON(meta: any): any;
    objects: any[]
}

declare export interface THREE$LensFlareProperty {
    texture: THREE$Texture,
        size: number,
        distance: number,
        x: number,
        y: number,
        z: number,
        scale: number,
        rotation: number,
        opacity: number,
        color: THREE$Color,
        blending: Blending
}

declare export class LensFlare mixins Object3D {
    constructor(texture?: THREE$Texture, size?: number, distance?: number, blending?: Blending, color?: THREE$Color): this;
    lensFlares: THREE$LensFlareProperty[];
    positionScreen: THREE$Vector3;
    customUpdateCallback: (object: THREE$LensFlare) => void;
    add(object: THREE$Object3D): void;
    add(
        texture: THREE$Texture,
        size?: number,
        distance?: number,
        blending?: Blending,
        color?: THREE$Color): void;
    updateLensFlares(): void
}

declare export class Line mixins Object3D {
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$LineDashedMaterial | THREE$LineBasicMaterial | THREE$ShaderMaterial, mode?: number): this;
    geometry: THREE$Geometry | THREE$BufferGeometry;
    material: THREE$Material;
    raycast(raycaster: THREE$Raycaster, intersects: any): void
}

declare export var LineStrip: number;

declare export var LinePieces: number;

declare export class LineSegments mixins Line {
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$LineDashedMaterial | THREE$LineBasicMaterial | THREE$ShaderMaterial, mode?: number): this
}

declare export class Mesh mixins Object3D {
    constructor(geometry?: THREE$Geometry, material?: THREE$Material): this;
    constructor(geometry?: THREE$BufferGeometry, material?: THREE$Material): this;
    geometry: THREE$Geometry | THREE$BufferGeometry;
    material: THREE$Material;
    drawMode: TrianglesDrawModes;
    setDrawMode(drawMode: TrianglesDrawModes): void;
    updateMorphTargets(): void;
    getMorphTargetIndexByName(name: string): number;
    raycast(raycaster: THREE$Raycaster, intersects: any): void
}


/**
 * A class for displaying particles in the form of variable size points. For example, if using the WebGLRenderer, the particles are displayed using GL_POINTS.
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/objects/ParticleSystem.js">src/objects/ParticleSystem.js</a>
 */
declare export class Points mixins Object3D {

    /**
     * 
     * @param geometry An instance of Geometry or BufferGeometry.
     * @param material An instance of Material (optional).
     */
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$Material): this;

    /**
     * An instance of Geometry or BufferGeometry, where each vertex designates the position of a particle in the system.
     */
    geometry: THREE$Geometry | THREE$BufferGeometry;

    /**
     * An instance of Material, defining the object's appearance. Default is a PointsMaterial with randomised colour.
     */
    material: THREE$Material;
    raycast(raycaster: THREE$Raycaster, intersects: any): void
}

declare export class PointCloud mixins Points {}

declare export class ParticleSystem mixins Points {}

declare export class Skeleton {
    constructor(bones: THREE$Bone[], boneInverses?: THREE$Matrix4[], useVertexTexture?: boolean): this;
    useVertexTexture: boolean;
    identityMatrix: THREE$Matrix4;
    bones: THREE$Bone[];
    boneTextureWidth: number;
    boneTextureHeight: number;
    boneMatrices: Float32Array;
    boneTexture: THREE$DataTexture;
    boneInverses: THREE$Matrix4[];
    calculateInverses(bone: THREE$Bone): void;
    pose(): void;
    update(): void;
    clone(): this
}

declare export class SkinnedMesh mixins Mesh {
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MeshBasicMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MeshDepthMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MultiMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MeshLambertMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MeshNormalMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$MeshPhongMaterial, useVertexTexture?: boolean): this;
    constructor(geometry?: THREE$Geometry | THREE$BufferGeometry, material?: THREE$ShaderMaterial, useVertexTexture?: boolean): this;
    bindMode: string;
    bindMatrix: THREE$Matrix4;
    bindMatrixInverse: THREE$Matrix4;
    skeleton: THREE$Skeleton;
    bind(skeleton: THREE$Skeleton, bindMatrix?: THREE$Matrix4): void;
    pose(): void;
    normalizeSkinWeights(): void;
    updateMatrixWorld(force?: boolean): void
}

declare export class Sprite mixins Object3D {
    constructor(material?: THREE$Material): this;
    geometry: THREE$BufferGeometry;
    material: THREE$SpriteMaterial;
    raycast(raycaster: THREE$Raycaster, intersects: any): void
}

declare export class Particle mixins Sprite {}

declare export interface THREE$Renderer {
    domElement: HTMLCanvasElement,
        render(scene: THREE$Scene, camera: THREE$Camera): void,
        setSize(width: number, height: number, updateStyle?: boolean): void
}

declare export interface THREE$WebGLRendererParameters {

    /**
     * A Canvas where the renderer draws its output.
     */
    canvas?: HTMLCanvasElement,

        /**
         * shader precision. Can be "highp", "mediump" or "lowp".
         */
        precision?: string,

        /**
         * default is true.
         */
        alpha?: boolean,

        /**
         * default is true.
         */
        premultipliedAlpha?: boolean,

        /**
         * default is false.
         */
        antialias?: boolean,

        /**
         * default is true.
         */
        stencil?: boolean,

        /**
         * default is false.
         */
        preserveDrawingBuffer?: boolean,

        /**
         * default is 0x000000.
         */
        clearColor?: number,

        /**
         * default is 0.
         */
        clearAlpha?: number,
        devicePixelRatio?: number,

        /**
         * default is false.
         */
        logarithmicDepthBuffer?: boolean
}


/**
 * The WebGL renderer displays your beautifully crafted scenes using WebGL, if your device supports it.
 * This renderer has way better performance than CanvasRenderer.
 * @see  <a href="https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js">src/renderers/WebGLRenderer.js</a>
 */
declare export class WebGLRenderer mixins Renderer {

    /**
     * parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.
     */
    constructor(parameters?: THREE$WebGLRendererParameters): this;

    /**
     * A Canvas where the renderer draws its output.
     * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
     */
    domElement: HTMLCanvasElement;

    /**
     * The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.
     */
    context: WebGLRenderingContext;

    /**
     * Defines whether the renderer should automatically clear its output before rendering.
     */
    autoClear: boolean;

    /**
     * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
     */
    autoClearColor: boolean;

    /**
     * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
     */
    autoClearDepth: boolean;

    /**
     * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
     */
    autoClearStencil: boolean;

    /**
     * Defines whether the renderer should sort objects. Default is true.
     */
    sortObjects: boolean;
    clippingPlanes: any[];
    localClippingEnabled: boolean;
    extensions: THREE$WebGLExtensions;

    /**
     * Default is false.
     */
    gammaInput: boolean;

    /**
     * Default is false.
     */
    gammaOutput: boolean;
    physicallyCorrectLights: boolean;
    toneMapping: ToneMapping;
    toneMappingExposure: number;
    toneMappingWhitePoint: number;

    /**
     * Default is false.
     */
    shadowMapDebug: boolean;

    /**
     * Default is 8.
     */
    maxMorphTargets: number;

    /**
     * Default is 4.
     */
    maxMorphNormals: number;

    /**
     * An object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:
     */
    info: {
        memory: {
            geometries: number,
            textures: number
        },
        render: {
            calls: number,
            vertices: number,
            faces: number,
            points: number
        },
        programs: number
    };
    shadowMap: THREE$WebGLShadowMap;
    pixelRation: number;
    capabilities: THREE$WebGLCapabilities;
    properties: THREE$WebGLProperties;
    state: THREE$WebGLState;
    allocTextureUnit: any;

    /**
     * Return the WebGL context.
     */
    getContext(): WebGLRenderingContext;
    getContextAttributes(): any;
    forceContextLoss(): void;
    getMaxAnisotropy(): number;
    getPrecision(): string;
    getPixelRatio(): number;
    setPixelRatio(value: number): void;
    getSize(): {
        width: number,
        height: number
    };

    /**
     * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
     */
    setSize(width: number, height: number, updateStyle?: boolean): void;

    /**
     * Sets the viewport to render from (x, y) to (x + width, y + height).
     */
    setViewport(x?: number, y?: number, width?: number, height?: number): void;

    /**
     * Sets the scissor area from (x, y) to (x + width, y + height).
     */
    setScissor(x: number, y: number, width: number, height: number): void;

    /**
     * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
     */
    setScissorTest(enable: boolean): void;

    /**
     * Returns a THREE.Color instance with the current clear color.
     */
    getClearColor(): THREE$Color;

    /**
     * Sets the clear color, using color for the color and alpha for the opacity.
     */
    setClearColor(color: THREE$Color, alpha?: number): void;
    setClearColor(color: string, alpha?: number): void;
    setClearColor(color: number, alpha?: number): void;

    /**
     * Returns a float with the current clear alpha. Ranges from 0 to 1.
     */
    getClearAlpha(): number;
    setClearAlpha(alpha: number): void;

    /**
     * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
     * Arguments default to true
     */
    clear(color?: boolean, depth?: boolean, stencil?: boolean): void;
    clearColor(): void;
    clearDepth(): void;
    clearStencil(): void;
    clearTarget(
        renderTarget: THREE$WebGLRenderTarget,
        color: boolean,
        depth: boolean,
        stencil: boolean): void;
    resetGLState(): void;
    dispose(): void;

    /**
     * Tells the shadow map plugin to update using the passed scene and camera parameters.
     * @param scene an instance of Scene
     * @param camera  an instance of Camera
     */
    renderBufferImmediate(object: THREE$Object3D, program: Object, material: THREE$Material): void;
    renderBufferDirect(
        camera: THREE$Camera,
        fog: THREE$Fog,
        material: THREE$Material,
        geometryGroup: any,
        object: THREE$Object3D): void;

    /**
     * Render a scene using a camera.
     * The render is done to the renderTarget (if specified) or to the canvas as usual.
    If forceClear is true, the canvas will be cleared before rendering, even if the renderer's autoClear property is false.
    */
    render(
        scene: THREE$Scene,
        camera: THREE$Camera,
        renderTarget?: THREE$RenderTarget,
        forceClear?: boolean): void;

    /**
     * Used for setting the gl frontFace, cullFace states in the GPU, thus enabling/disabling face culling when rendering.
     * If cullFace is false, culling will be disabled.
     * @param cullFace "back", "front", "front_and_back", or false.
     * @param frontFace "ccw" or "cw
     */
    setFaceCulling(cullFace?: CullFace, frontFace?: FrontFaceDirection): void;
    setTexture(texture: THREE$Texture, slot: number): void;
    setTexture2D(texture: THREE$Texture, slot: number): void;
    setTextureCube(texture: THREE$Texture, slot: number): void;
    getCurrentRenderTarget(): THREE$RenderTarget;
    setRenderTarget(renderTarget: THREE$RenderTarget): void;
    readRenderTargetPixels(
        renderTarget: THREE$RenderTarget,
        x: number,
        y: number,
        width: number,
        height: number,
        buffer: any): void;
    gammaFactor: number;
    shadowMapEnabled: boolean;
    shadowMapType: ShadowMapType;
    shadowMapCullFace: CullFace;
    supportsFloatTextures(): any;
    supportsHalfFloatTextures(): any;
    supportsStandardDerivatives(): any;
    supportsCompressedTextureS3TC(): any;
    supportsCompressedTexturePVRTC(): any;
    supportsBlendMinMax(): any;
    supportsVertexTextures(): any;
    supportsInstancedArrays(): any;
    enableScissorTest(boolean: any): any
}

declare export interface THREE$RenderTarget {}

declare export interface THREE$WebGLRenderTargetOptions {
    wrapS?: Wrapping,
        wrapT?: Wrapping,
        magFilter?: TextureFilter,
        minFilter?: TextureFilter,
        format?: number,
        type?: TextureDataType,
        anisotropy?: number,
        depthBuffer?: boolean,
        stencilBuffer?: boolean
}

declare export class WebGLRenderTarget mixins EventDispatcher {
    constructor(width: number, height: number, options?: THREE$WebGLRenderTargetOptions): this;
    uuid: string;
    width: number;
    height: number;
    scissor: THREE$Vector4;
    scissorTest: boolean;
    viewpport: THREE$Vector4;
    texture: THREE$Texture;
    depthBuffer: boolean;
    stencilBuffer: boolean;
    depthTexture: THREE$Texture;
    wrapS: any;
    wrapT: any;
    magFilter: any;
    minFilter: any;
    anisotropy: any;
    offset: any;
    repeat: any;
    format: any;
    type: any;
    generateMipmaps: any;
    setSize(width: number, height: number): void;
    clone(): this;
    copy(source: this): this;
    dispose(): void
}

declare export class WebGLRenderTargetCube mixins WebGLRenderTarget {
    constructor(width: number, height: number, options?: THREE$WebGLRenderTargetOptions): this;
    activeCubeFace: number;
    activeMipMapLevel: number
}

declare export var ShaderChunk: {
    [name: string]: string,
    alphamap_fragment: string,
    alphamap_pars_fragment: string,
    alphatest_fragment: string,
    aomap_fragment: string,
    aomap_pars_fragment: string,
    begin_vertex: string,
    beginnormal_vertex: string,
    bsdfs: string,
    bumpmap_pars_fragment: string,
    clipping_planes_fragment: string,
    clipping_planes_pars_fragment: string,
    clipping_planes_pars_vertex: string,
    clipping_planes_vertex: string,
    color_fragment: string,
    color_pars_fragment: string,
    color_pars_vertex: string,
    color_vertex: string,
    common: string,
    cube_frag: string,
    cube_vert: string,
    cube_uv_reflection_fragment: string,
    defaultnormal_vertex: string,
    depth_frag: string,
    depth_vert: string,
    distanceRGBA_frag: string,
    distanceRGBA_vert: string,
    displacementmap_vertex: string,
    displacementmap_pars_vertex: string,
    emissivemap_fragment: string,
    emissivemap_pars_fragment: string,
    encodings_pars_fragment: string,
    encodings_fragment: string,
    envmap_fragment: string,
    envmap_pars_fragment: string,
    envmap_pars_vertex: string,
    envmap_vertex: string,
    equirect_frag: string,
    equirect_vert: string,
    fog_fragment: string,
    fog_pars_fragment: string,
    linedashed_frag: string,
    linedashed_vert: string,
    lightmap_fragment: string,
    lightmap_pars_fragment: string,
    lights_lambert_vertex: string,
    lights_pars: string,
    lights_phong_fragment: string,
    lights_phong_pars_fragment: string,
    lights_physical_fragment: string,
    lights_physical_pars_fragment: string,
    lights_template: string,
    logdepthbuf_fragment: string,
    logdepthbuf_pars_fragment: string,
    logdepthbuf_pars_vertex: string,
    logdepthbuf_vertex: string,
    map_fragment: string,
    map_pars_fragment: string,
    map_particle_fragment: string,
    map_particle_pars_fragment: string,
    meshbasic_frag: string,
    meshbasic_vert: string,
    meshlambert_frag: string,
    meshlambert_vert: string,
    meshphong_frag: string,
    meshphong_vert: string,
    meshphysical_frag: string,
    meshphysical_vert: string,
    metalnessmap_fragment: string,
    metalnessmap_pars_fragment: string,
    morphnormal_vertex: string,
    morphtarget_pars_vertex: string,
    morphtarget_vertex: string,
    normal_flip: string,
    normal_frag: string,
    normal_fragment: string,
    normal_vert: string,
    normalmap_pars_fragment: string,
    packing: string,
    points_frag: string,
    points_vert: string,
    shadow_frag: string,
    shadow_vert: string,
    premultiplied_alpha_fragment: string,
    project_vertex: string,
    roughnessmap_fragment: string,
    roughnessmap_pars_fragment: string,
    shadowmap_pars_fragment: string,
    shadowmap_pars_vertex: string,
    shadowmap_vertex: string,
    shadowmask_pars_fragment: string,
    skinbase_vertex: string,
    skinning_pars_vertex: string,
    skinning_vertex: string,
    skinnormal_vertex: string,
    specularmap_fragment: string,
    specularmap_pars_fragment: string,
    tonemapping_fragment: string,
    tonemapping_pars_fragment: string,
    uv2_pars_fragment: string,
    uv2_pars_vertex: string,
    uv2_vertex: string,
    uv_pars_fragment: string,
    uv_pars_vertex: string,
    uv_vertex: string,
    worldpos_vertex: string
};

declare export interface THREE$Shader {
    uniforms: THREE$IUniform,
        vertexShader: string,
        fragmentShader: string
}

declare export var ShaderLib: {
    [name: string]: THREE$Shader,
    basic: THREE$Shader,
    lambert: THREE$Shader,
    phong: THREE$Shader,
    standard: THREE$Shader,
    points: THREE$Shader,
    dashed: THREE$Shader,
    depth: THREE$Shader,
    normal: THREE$Shader,
    cube: THREE$Shader,
    equirect: THREE$Shader,
    depthRGBA: THREE$Shader,
    distanceRGBA: THREE$Shader,
    physical: THREE$Shader
};

declare export interface THREE$IUniform {
    value: any
}

declare export var UniformsLib: {
    common: {
        diffuse: THREE$IUniform,
        opacity: THREE$IUniform,
        map: THREE$IUniform,
        offsetRepeat: THREE$IUniform,
        specularMap: THREE$IUniform,
        alphaMap: THREE$IUniform,
        envMap: THREE$IUniform,
        flipEnvMap: THREE$IUniform,
        reflectivity: THREE$IUniform,
        refractionRation: THREE$IUniform
    },
    aomap: {
        aoMap: THREE$IUniform,
        aoMapIntensity: THREE$IUniform
    },
    lightmap: {
        lightMap: THREE$IUniform,
        lightMapIntensity: THREE$IUniform
    },
    emissivemap: {
        emissiveMap: THREE$IUniform
    },
    bumpmap: {
        bumpMap: THREE$IUniform,
        bumpScale: THREE$IUniform
    },
    normalmap: {
        normalMap: THREE$IUniform,
        normalScale: THREE$IUniform
    },
    displacementmap: {
        displacementMap: THREE$IUniform,
        displacementScale: THREE$IUniform,
        displacementBias: THREE$IUniform
    },
    roughnessmap: {
        roughnessMap: THREE$IUniform
    },
    metalnessmap: {
        metalnessMap: THREE$IUniform
    },
    fog: {
        fogDensity: THREE$IUniform,
        fogNear: THREE$IUniform,
        fogFar: THREE$IUniform,
        fogColor: THREE$IUniform
    },
    lights: {
        ambientLightColor: THREE$IUniform,
        directionalLights: {
            value: any[],
            properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: THREE$IUniform,
        directionalShadowMatrix: THREE$IUniform,
        spotLights: {
            value: any[],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: THREE$IUniform,
        spotShadowMatrix: THREE$IUniform,
        pointLights: {
            value: any[],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        pointShadowMap: THREE$IUniform,
        pointShadowMatrix: THREE$IUniform,
        hemisphereLigtts: {
            value: any[],
            properties: {
                direction: {},
                skycolor: {},
                groundColor: {}
            }
        }
    },
    points: {
        diffuse: THREE$IUniform,
        opacity: THREE$IUniform,
        size: THREE$IUniform,
        scale: THREE$IUniform,
        map: THREE$IUniform,
        offsetRepeat: THREE$IUniform
    }
};


declare var npm$namespace$UniformsUtils: {
    merge: typeof UniformsUtils$merge,
    clone: typeof UniformsUtils$clone,
}
declare export function UniformsUtils$merge(geometry1: any, geometry2: any, materialIndexOffset?: any): any

declare export function UniformsUtils$clone(uniforms_src: any): any

declare export class Uniform {
    constructor(value: any): this;
    constructor(type: string, value: any): this;
    type: string;
    value: any;
    dynamic: boolean;
    onUpdateCallback: Function;
    onUpdate(callback: Function): THREE$Uniform
}

declare export class WebGLBufferRenderer {
    constructor(_gl: WebGLRenderingContext, extensions: any, _infoRender: any): this;
    setMode(value: any): void;
    render(start: any, count: number): void;
    renderInstances(geometry: any): void
}

declare export class WebGLClipping {
    uniform: {
        value: any,
        needsUpdate: boolean
    };
    numPlanes: number;
    init(planes: any[], enableLocalClipping: boolean, camera: THREE$Camera): boolean;
    beginShadows(): void;
    endShadows(): void;
    setState(
        planes: any[],
        clipShadows: boolean,
        camera: THREE$Camera,
        cache: boolean,
        fromCache: boolean): void
}

declare export interface THREE$WebGLCapabilitiesParameters {
    precision?: any,
        logarithmicDepthBuffer?: any
}

declare export class WebGLCapabilities {
    constructor(gl: WebGLRenderingContext, extensions: any, parameters: THREE$WebGLCapabilitiesParameters): this;
    precision: any;
    logarithmicDepthBuffer: any;
    maxTextures: any;
    maxVertexTextures: any;
    maxTextureSize: any;
    maxCubemapSize: any;
    maxAttributes: any;
    maxVertexUniforms: any;
    maxVaryings: any;
    maxFragmentUniforms: any;
    vertexTextures: any;
    floatFragmentTextures: any;
    floatVertexTextures: any;
    getMaxAnisotropy(): number;
    getMaxPrecision(precision: string): string
}

declare export class WebGLExtensions {
    constructor(gl: WebGLRenderingContext): this;
    get(name: string): any
}

declare export class WebGLGeometries {
    constructor(gl: WebGLRenderingContext, extensions: any, _infoRender: any): this;
    get(object: any): any
}

declare export class WebGLLights {
    constructor(gl: WebGLRenderingContext, properties: any, info: any): this;
    get(light: any): any
}

declare export class WebGLIndexedBufferRenderer {
    constructor(gl: WebGLRenderingContext, properties: any, info: any): this;
    setMode(value: any): void;
    setIndex(index: any): void;
    render(start: any, count: number): void;
    renderInstances(geometry: any, start: any, count: number): void
}

declare export class WebGLObjects {
    constructor(gl: WebGLRenderingContext, properties: any, info: any): this;
    getAttributeBuffer(attribute: any): any;
    getWireframeAttribute(geometry: any): any;
    update(object: any): void
}

declare export class WebGLProgram {
    constructor(renderer: THREE$WebGLRenderer, code: string, material: THREE$ShaderMaterial, parameters: THREE$WebGLRendererParameters): this;
    id: number;
    code: string;
    usedTimes: number;
    program: any;
    vertexShader: THREE$WebGLShader;
    fragmentShader: THREE$WebGLShader;
    uniforms: any;
    attributes: any;
    getUniforms(): THREE$WebGLUniforms;
    getAttributes(): any;
    destroy(): void
}

declare export class WebGLPrograms {
    constructor(renderer: THREE$WebGLRenderer, capabilities: any): this;
    programs: any[];
    getParameters(
        material: THREE$ShaderMaterial,
        lights: any,
        fog: any,
        nClipPlanes: number,
        object: any): any;
    getProgramCode(material: THREE$ShaderMaterial, parameters: any): string;
    acquireProgram(
        material: THREE$ShaderMaterial,
        parameters: any,
        code: string): THREE$WebGLProgram;
    releaseProgram(program: THREE$WebGLProgram): void
}

declare export class WebGLTextures {
    constructor(gl: any, extensions: any, state: any, properties: any, capabilities: any, paramThreeToGL: Function, info: any): this;
    setTexture2D(texture: any, slot: number): void;
    setTextureCube(texture: any, slot: number): void;
    setTextureCubeDynamic(texture: any, slot: number): void;
    setupRenderTarget(renderTarget: any): void;
    updateRenderTargetMipmap(renderTarget: any): void
}

declare export class WebGLUniforms {
    constructor(gl: any, program: THREE$WebGLProgram, renderer: THREE$WebGLRenderer): this;
    renderer: THREE$WebGLRenderer;
    setValue(gl: any, value: any, renderer?: any): void;
    set(gl: any, object: any, name: string): void;
    setOptional(gl: any, object: any, name: string): void;
    upload(gl: any, seq: any, values: any[], renderer: any): void;
    seqWithValue(seq: any, values: any[]): any[];
    splitDynamic(seq: any, values: any[]): any[];
    evalDynamic(seq: any, values: any[], object: any, camera: any): any[]
}

declare export class WebGLProperties {
    constructor(): this;
    get(object: any): any;
    delete(object: any): void;
    clear(): void
}

declare export class WebGLShader {
    constructor(gl: any, type: string, string: string): this
}

declare export class WebGLShadowMap {
    constructor(_renderer: THREE$Renderer, _lights: any[], _objects: any[], capabilities: any): this;
    enabled: boolean;
    autoUpdate: boolean;
    needsUpdate: boolean;
    type: ShadowMapType;
    renderReverseSided: boolean;
    renderSingleSided: boolean;
    render(scene: THREE$Scene, camera: THREE$Camera): void;
    cullFace: any
}

declare export class WebGLState {
    constructor(gl: any, extensions: any, paramThreeToGL: Function): this;
    buffers: {
        color: THREE$WebGLColorBuffer,
        depth: THREE$WebGLDepthBuffer,
        stencil: THREE$WebGLStencilBuffer
    };
    init(): void;
    initAttributes(): void;
    enableAttribute(attribute: string): void;
    enableAttributeAndDivisor(attribute: string, meshPerAttribute: any, extension: any): void;
    disableUnusedAttributes(): void;
    enable(id: string): void;
    disable(id: string): void;
    getCompressedTextureFormats(): any[];
    setBlending(
        blending: number,
        blendEquation: number,
        blendSrc: number,
        blendDst: number,
        blendEquationAlpha: number,
        blendSrcAlpha: number,
        blendDstAlpha: number): void;
    setColorWrite(colorWrite: number): void;
    setDepthTest(depthTest: number): void;
    setDepthWrite(depthWrite: number): void;
    setDepthFunc(depthFunc: Function): void;
    setStencilTest(stencilTest: boolean): void;
    setStencilWrite(stencilWrite: any): void;
    setStencilFunc(stencilFunc: Function, stencilRef: any, stencilMask: number): void;
    setStencilOp(stencilFail: any, stencilZFail: any, stencilZPass: any): void;
    setFlipSided(flipSided: number): void;
    setCullFace(cullFace: CullFace): void;
    setLineWidth(width: number): void;
    setPolygonOffset(polygonoffset: number, factor: number, units: number): void;
    setScissorTest(scissorTest: boolean): void;
    getScissorTest(): boolean;
    activeTexture(webglSlot: any): void;
    bindTexture(webglType: any, webglTexture: any): void;
    compressedTexImage2D(): void;
    texImage2D(): void;
    clearColor(r: number, g: number, b: number, a: number): void;
    clearDepth(depth: number): void;
    clearStencil(stencil: any): void;
    scissor(scissor: any): void;
    viewport(viewport: any): void;
    reset(): void
}

declare export class WebGLColorBuffer {
    constructor(gl: any, state: any): this;
    setMask(colorMask: number): void;
    setLocked(lock: boolean): void;
    setClear(r: number, g: number, b: number, a: number): void;
    reset(): void
}

declare export class WebGLDepthBuffer {
    constructor(gl: any, state: any): this;
    setTest(depthTest: boolean): void;
    sertMask(depthMask: number): void;
    setFunc(depthFunc: Function): void;
    setLocked(lock: boolean): void;
    setClear(depth: any): void;
    reset(): void
}

declare export class WebGLStencilBuffer {
    constructor(gl: any, state: any): this;
    setTest(stencilTest: boolean): void;
    sertMask(stencilMask: number): void;
    setFunc(stencilFunc: Function, stencilRef: any, stencilMask: number): void;
    setOp(stencilFail: any, stencilZFail: any, stencilZPass: any): void;
    setLocked(lock: boolean): void;
    setClear(stencil: any): void;
    reset(): void
}

declare export class LensFlarePlugin {
    constructor(renderer: THREE$WebGLRenderer, flares: any[]): this;
    render(
        scene: THREE$Scene,
        camera: THREE$Camera,
        viewportWidth: number,
        viewportHeight: number): void
}

declare export class SpritePlugin {
    constructor(renderer: THREE$WebGLRenderer, sprites: any[]): this;
    render(
        scene: THREE$Scene,
        camera: THREE$Camera,
        viewportWidth: number,
        viewportHeight: number): void
}


/**
 * Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
 */
declare export class Scene mixins Object3D {
    constructor(): this;

    /**
     * A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.
     */
    fog: THREE$IFog;

    /**
     * If not null, it will force everything in the scene to be rendered with that material. Default is null.
     */
    overrideMaterial: THREE$Material;
    autoUpdate: boolean;
    background: any;
    toJSON(meta?: any): any
}

declare export interface THREE$IFog {
    name: string,
        color: THREE$Color,
        clone(): this,
        toJSON(): any
}


/**
 * This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.
 */
declare export class Fog mixins IFog {
    constructor(hex: number, near?: number, far?: number): this;
    name: string;

    /**
     * Fog color.
     */
    color: THREE$Color;

    /**
     * The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
     */
    near: number;

    /**
     * The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.
     * Default is 1000.
     */
    far: number;
    clone(): this;
    toJSON(): any
}


/**
 * This class contains the parameters that define linear fog, i.e., that grows exponentially denser with the distance.
 */
declare export class FogExp2 mixins IFog {
    constructor(hex: number | string, density?: number): this;
    name: string;
    color: THREE$Color;

    /**
     * Defines how fast the fog will grow dense.
     * Default is 0.00025.
     */
    density: number;
    clone(): this;
    toJSON(): any
}

declare export var TextureIdCount: number;

declare export class Texture mixins EventDispatcher {
    constructor(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, encoding?: TextureEncoding): this;
    id: number;
    uuid: string;
    name: string;
    sourceFile: string;
    image: any;
    mipmaps: ImageData[];
    mapping: Mapping;
    wrapS: Wrapping;
    wrapT: Wrapping;
    magFilter: TextureFilter;
    minFilter: TextureFilter;
    anisotropy: number;
    format: PixelFormat;
    type: TextureDataType;
    offset: THREE$Vector2;
    repeat: THREE$Vector2;
    generateMipmaps: boolean;
    premultiplyAlpha: boolean;
    flipY: boolean;
    unpackAlignment: number;
    encoding: TextureEncoding;
    version: number;
    needsUpdate: boolean;
    onUpdate: () => void;
    DEFAULT_IMAGE: any;
    DEFAULT_MAPPING: any;
    clone(): this;
    copy(source: this): this;
    toJSON(meta: any): any;
    dispose(): void;
    transformUv(uv: THREE$Vector): void
}

declare export class DepthTexture mixins Texture {
    constructor(width: number, heighht: number, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number): this;
    image: {
        width: number,
        height: number
    }
}

declare export class CanvasTexture mixins Texture {
    constructor(canvas: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number): this
}

declare export class CubeTexture mixins Texture {
    constructor(images?: any[], mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number, encoding?: TextureEncoding): this;
    images: any
}

declare export class CompressedTexture mixins Texture {
    constructor(mipmaps: ImageData[], width: number, height: number, format?: PixelFormat, type?: TextureDataType, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, anisotropy?: number, encoding?: TextureEncoding): this;
    image: {
        width: number,
        height: number
    }
}

declare export class DataTexture mixins Texture {
    constructor(data: ArrayBuffer |
        Int8Array |
        Uint8Array |
        Uint8ClampedArray |
        Int16Array |
        Uint16Array |
        Int32Array |
        Uint32Array |
        Float32Array |
        Float64Array, width: number, height: number, format: PixelFormat, type: TextureDataType, mapping: Mapping, wrapS: Wrapping, wrapT: Wrapping, magFilter: TextureFilter, minFilter: TextureFilter, anisotropy?: number, encoding?: TextureEncoding): this;
    image: {
        data: ImageData,
        width: number,
        height: number
    }
}

declare export class VideoTexture mixins Texture {
    constructor(video: HTMLVideoElement, mapping?: Mapping, wrapS?: Wrapping, wrapT?: Wrapping, magFilter?: TextureFilter, minFilter?: TextureFilter, format?: PixelFormat, type?: TextureDataType, anisotropy?: number): this
}


declare var npm$namespace$CurveUtils: {
    tangentQuadraticBezier: typeof CurveUtils$tangentQuadraticBezier,
    tangentCubicBezier: typeof CurveUtils$tangentCubicBezier,
    tangentSpline: typeof CurveUtils$tangentSpline,
    interpolate: typeof CurveUtils$interpolate,
}
declare export function CurveUtils$tangentQuadraticBezier(t: number, p0: number, p1: number, p2: number): number

declare export function CurveUtils$tangentCubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number

declare export function CurveUtils$tangentSpline(t: number, p0: number, p1: number, p2: number, p3: number): number

declare export function CurveUtils$interpolate(p0: number, p1: number, p2: number, p3: number, t: number): number


declare var npm$namespace$ImageUtils: {
    loadTexture: typeof ImageUtils$loadTexture,
    loadTextureCube: typeof ImageUtils$loadTextureCube,
}
declare export var crossOrigin: string;

declare export function ImageUtils$loadTexture(
    url: string,
    mapping?: Mapping,
    onLoad?: (texture: THREE$Texture) => void,
    onError?: (message: string) => void): THREE$Texture

declare export function ImageUtils$loadTextureCube(
    array: string[],
    mapping?: Mapping,
    onLoad?: (texture: THREE$Texture) => void,
    onError?: (message: string) => void): THREE$Texture


declare var npm$namespace$SceneUtils: {
    createMultiMaterialObject: typeof SceneUtils$createMultiMaterialObject,
    detach: typeof SceneUtils$detach,
    attach: typeof SceneUtils$attach,
}
declare export function SceneUtils$createMultiMaterialObject(geometry: THREE$Geometry, materials: THREE$Material[]): THREE$Object3D

declare export function SceneUtils$detach(child: THREE$Object3D, parent: THREE$Object3D, scene: THREE$Scene): void

declare export function SceneUtils$attach(child: THREE$Object3D, scene: THREE$Scene, parent: THREE$Object3D): void


declare var npm$namespace$ShapeUtils: {
    area: typeof ShapeUtils$area,
    triangulate: typeof ShapeUtils$triangulate,
    triangulateShape: typeof ShapeUtils$triangulateShape,
    isClockWise: typeof ShapeUtils$isClockWise,
    b2: typeof ShapeUtils$b2,
    b3: typeof ShapeUtils$b3,
}
declare export function ShapeUtils$area(contour: number[]): number

declare export function ShapeUtils$triangulate(contour: number[], indices: boolean): number[]

declare export function ShapeUtils$triangulateShape(contour: number[], holes: any[]): number[]

declare export function ShapeUtils$isClockWise(pts: number[]): boolean

declare export function ShapeUtils$b2(t: number, p0: number, p1: number, p2: number): number

declare export function ShapeUtils$b3(t: number, p0: number, p1: number, p2: number, p3: number): number

declare export class Audio mixins Object3D {
    constructor(listener: THREE$AudioListener): this;
    type: string;
    context: AudioContext;
    source: AudioBufferSourceNode;
    gain: GainNode;
    autoplay: boolean;
    startTime: number;
    playbackRate: number;
    hasPlaybackControl: boolean;
    isPlaying: boolean;
    sourceType: string;
    filters: any[];
    getOutput(): GainNode;
    setNodeSource(audioNode: AudioBufferSourceNode): THREE$Audio;
    setBuffer(audioBuffer: THREE$AudioBuffer): THREE$Audio;
    play(): THREE$Audio;
    pause(): THREE$Audio;
    stop(): THREE$Audio;
    connect(): THREE$Audio;
    disconnect(): THREE$Audio;
    getFilters(): any[];
    setFilter(value: any[]): THREE$Audio;
    getFilter(): any;
    setFilter(filter: any): THREE$Audio;
    setPlaybackRate(value: number): THREE$Audio;
    getPlaybackRate(): number;
    onEnded(): void;
    getLoop(): boolean;
    setLoop(value: boolean): void;
    getVolume(): number;
    setVolume(value: number): THREE$Audio;
    load(file: string): THREE$Audio
}

declare export class AudioAnalyser {
    constructor(audio: any, fftSize: number): this;
    analyser: any;
    data: Uint8Array;
    getFrequencyData(): Uint8Array;
    getAverageFrequency(): number;
    getData(file: any): any
}

declare export var AudioContext: AudioContext;

declare export class AudioBuffer {
    constructor(context: any): this;
    context: any;
    ready: boolean;
    readyCallbacks: Function[];
    load(file: string): THREE$AudioBuffer;
    onReady(callback: Function): void
}

declare export class PositionalAudio mixins Audio {
    constructor(listener: THREE$AudioListener): this;
    panner: PannerNode;
    setRefDistance(value: number): void;
    getRefDistance(): number;
    setRolloffFactor(value: number): void;
    getRolloffFactor(): number;
    setDistanceModel(value: number): void;
    getDistanceModel(): number;
    setMaxDistance(value: number): void;
    getMaxDistance(): number
}

declare export class AudioListener mixins Object3D {
    constructor(): this;
    type: string;
    context: AudioContext;
    gain: GainNode;
    getInput(): GainNode;
    removeFilter(): void;
    setFilter(value: any): void;
    getFilter(): any;
    setMasterVolume(value: number): void;
    getMasterVolume(): number
}


/**
 * An extensible curve object which contains methods for interpolation
 * class Curve&lt;T extends Vector&gt;
 */
declare export class Curve<T>{

    /**
     * Returns a vector for point t of the curve where t is between 0 and 1
     * getPoint(t: number): T;
     */
    getPoint(t: number): T;

    /**
     * Returns a vector for point at relative position in curve according to arc length
     * getPointAt(u: number): T;
     */
    getPointAt(u: number): T;

    /**
     * Get sequence of points using getPoint( t )
     * getPoints(divisions?: number): T[];
     */
    getPoints(divisions?: number): T[];

    /**
     * Get sequence of equi-spaced points using getPointAt( u )
     * getSpacedPoints(divisions?: number): T[];
     */
    getSpacedPoints(divisions?: number): T[];

    /**
     * Get total curve arc length
     */
    getLength(): number;

    /**
     * Get list of cumulative segment lengths
     */
    getLengths(divisions?: number): number[];

    /**
     * Update the cumlative segment distance cache
     */
    updateArcLengths(): void;

    /**
     * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
     */
    getUtoTmapping(u: number, distance: number): number;

    /**
     * Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation
     * getTangent(t: number): T;
     */
    getTangent(t: number): T;

    /**
     * Returns tangent at equidistance point u on the curve
     * getTangentAt(u: number): T;
     */
    getTangentAt(u: number): T;
    create(constructorFunc: Function, getPointFunc: Function): Function
}

declare export class CurvePath<T>mixins Curve<T>{
    constructor(): this;
    curves: THREE$Curve<T>[];
    autoClose: boolean;
    add(curve: THREE$Curve<T>): void;
    checkConnection(): boolean;
    closePath(): void;
    getPoint(t: number): T;
    getLength(): number;
    updateArcLengths(): void;
    getCurveLengths(): number[];
    getSpacedPoints(divisions?: number): T[];
    getPoints(divisions?: number): T[];
    createPointsGeometry(divisions: number): THREE$Geometry;
    createSpacedPointsGeometry(divisions: number): THREE$Geometry;
    createGeometry(points: T[]): THREE$Geometry
}

declare export interface THREE$PathAction {
    action: PathActions,
        args: any
}


/**
 * a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
 */
declare export class Path mixins CurvePath<THREE$Vector2>{
    constructor(points?: THREE$Vector2[]): this;
    currentPoint: THREE$Vector2;
    fromPoints(vectors: THREE$Vector2[]): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): void;
    bezierCurveTo(
        aCP1x: number,
        aCP1y: number,
        aCP2x: number,
        aCP2y: number,
        aX: number,
        aY: number): void;
    splineThru(pts: THREE$Vector2[]): void;
    arc(
        aX: number,
        aY: number,
        aRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean): void;
    absarc(
        aX: number,
        aY: number,
        aRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean): void;
    ellipse(
        aX: number,
        aY: number,
        xRadius: number,
        yRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean,
        aRotation: number): void;
    absellipse(
        aX: number,
        aY: number,
        xRadius: number,
        yRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean,
        aRotation: number): void
}

declare export class ShapePath {
    constructor(): this;
    subPaths: any[];
    currentPath: any;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(aCPx: number, aCPy: number, aX: number, aY: number): void;
    bezierCurveTo(
        aCP1x: number,
        aCP1y: number,
        aCP2x: number,
        aCP2y: number,
        aX: number,
        aY: number): void;
    splineThru(pts: THREE$Vector2[]): void;
    toShapes(isCCW: boolean, noHoles: any): THREE$Shape[]
}


/**
 * Defines a 2d shape plane using paths.
 */
declare export class Shape mixins Path {
    constructor(points?: THREE$Vector2[]): this;
    holes: THREE$Path[];
    extrude(options?: any): THREE$ExtrudeGeometry;
    makeGeometry(options?: any): THREE$ShapeGeometry;
    getPointsHoles(divisions: number): THREE$Vector2[][];
    extractAllPoints(divisions: number): {
        shape: THREE$Vector2[],
        holes: THREE$Vector2[][]
    };
    extractPoints(divisions: number): THREE$Vector2[]
}

declare export class CatmullRomCurve3 mixins Curve<THREE$Vector3>{
    constructor(points?: THREE$Vector3[]): this;
    points: THREE$Vector3[];
    getPoint(t: number): THREE$Vector3
}

declare export class ClosedSplineCurve3 mixins CatmullRomCurve3 {}

declare export class SplineCurve3 mixins CatmullRomCurve3 {}

declare export class CubicBezierCurve mixins Curve<THREE$Vector2>{
    constructor(v0: THREE$Vector2, v1: THREE$Vector2, v2: THREE$Vector2, v3: THREE$Vector2): this;
    v0: THREE$Vector2;
    v1: THREE$Vector2;
    v2: THREE$Vector2;
    v3: THREE$Vector2
}

declare export class CubicBezierCurve3 mixins Curve<THREE$Vector3>{
    constructor(v0: THREE$Vector3, v1: THREE$Vector3, v2: THREE$Vector3, v3: THREE$Vector3): this;
    v0: THREE$Vector3;
    v1: THREE$Vector3;
    v2: THREE$Vector3;
    v3: THREE$Vector3;
    getPoint(t: number): THREE$Vector3
}

declare export class EllipseCurve mixins Curve<THREE$Vector2>{
    constructor(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean, aRotation: number): this;
    aX: number;
    aY: number;
    xRadius: number;
    yRadius: number;
    aStartAngle: number;
    aEndAngle: number;
    aClockwise: boolean;
    aRotation: number
}

declare export class ArcCurve mixins EllipseCurve {
    constructor(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: boolean): this
}

declare export class LineCurve mixins Curve<THREE$Vector2>{
    constructor(v1: THREE$Vector2, v2: THREE$Vector2): this;
    v1: THREE$Vector2;
    v2: THREE$Vector2
}

declare export class LineCurve3 mixins Curve<THREE$Vector3>{
    constructor(v1: THREE$Vector3, v2: THREE$Vector3): this;
    v1: THREE$Vector3;
    v2: THREE$Vector3;
    getPoint(t: number): THREE$Vector3
}

declare export class QuadraticBezierCurve mixins Curve<THREE$Vector2>{
    constructor(v0: THREE$Vector2, v1: THREE$Vector2, v2: THREE$Vector2): this;
    v0: THREE$Vector2;
    v1: THREE$Vector2;
    v2: THREE$Vector2
}

declare export class QuadraticBezierCurve3 mixins Curve<THREE$Vector3>{
    constructor(v0: THREE$Vector3, v1: THREE$Vector3, v2: THREE$Vector3): this;
    v0: THREE$Vector3;
    v1: THREE$Vector3;
    v2: THREE$Vector3;
    getPoint(t: number): THREE$Vector3
}

declare export class SplineCurve mixins Curve<THREE$Vector2>{
    constructor(points?: THREE$Vector2[]): this;
    points: THREE$Vector2[]
}

declare export class BoxBufferGeometry mixins BufferGeometry {
    constructor(width: number, height: number, depth: number, widthSegments?: number, heightSegments?: number, depthSegments?: number): this;
    parameters: {
        width: number,
        height: number,
        depth: number,
        widthSegments: number,
        heightSegments: number,
        depthSegments: number
    }
}


/**
 * BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided within the (optional) 'width', 'height', & 'depth' constructor arguments.
 */
declare export class BoxGeometry mixins Geometry {

    /**
     * 
     * @param width  Width of the sides on the X axis.
     * @param height  Height of the sides on the Y axis.
     * @param depth  Depth of the sides on the Z axis.
     * @param widthSegments  Number of segmented faces along the width of the sides.
     * @param heightSegments  Number of segmented faces along the height of the sides.
     * @param depthSegments  Number of segmented faces along the depth of the sides.
     */
    constructor(width: number, height: number, depth: number, widthSegments?: number, heightSegments?: number, depthSegments?: number): this;
    parameters: {
        width: number,
        height: number,
        depth: number,
        widthSegments: number,
        heightSegments: number,
        depthSegments: number
    }
}

declare export class CubeGeometry mixins BoxGeometry {}

declare export class CircleBufferGeometry mixins BufferGeometry {
    constructor(radius?: number, segments?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radius: number,
        segments: number,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class CircleGeometry mixins Geometry {
    constructor(radius?: number, segments?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radius: number,
        segments: number,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class CylinderBufferGeometry mixins BufferGeometry {
    constructor(radiusTop?: number, radiusBottom?: number, height?: number, radialSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radiusTop: number,
        radiusBottom: number,
        height: number,
        radialSegments: number,
        heightSegments: number,
        openEnded: boolean,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class CylinderGeometry mixins Geometry {

    /**
     * 
     * @param radiusTop  Radius of the cylinder at the top.
     * @param radiusBottom  Radius of the cylinder at the bottom.
     * @param height  Height of the cylinder.
     * @param radiusSegments  Number of segmented faces around the circumference of the cylinder.
     * @param heightSegments  Number of rows of faces along the height of the cylinder.
     * @param openEnded - A Boolean indicating whether or not to cap the ends of the cylinder.
     */
    constructor(radiusTop?: number, radiusBottom?: number, height?: number, radiusSegments?: number, heightSegments?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radiusTop: number,
        radiusBottom: number,
        height: number,
        radialSegments: number,
        heightSegments: number,
        openEnded: boolean,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class ConeBufferGeometry mixins BufferGeometry {
    constructor(radius?: number, height?: number, radialSegment?: number, heightSegment?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number): this
}

declare export class ConeGeometry mixins CylinderGeometry {
    constructor(radius?: number, height?: number, radialSegment?: number, heightSegment?: number, openEnded?: boolean, thetaStart?: number, thetaLength?: number): this
}

declare export class DodecahedronGeometry mixins Geometry {
    constructor(radius: number, detail: number): this;
    parameters: {
        radius: number,
        detail: number
    }
}

declare export class EdgesGeometry mixins BufferGeometry {
    constructor(geometry: THREE$BufferGeometry, thresholdAngle: number): this
}

declare export class ExtrudeGeometry mixins Geometry {
    constructor(shape?: THREE$Shape, options?: any): this;
    constructor(shapes?: THREE$Shape[], options?: any): this;
    WorldUVGenerator: {
        generateTopUV(
            geometry: THREE$Geometry,
            indexA: number,
            indexB: number,
            indexC: number): THREE$Vector2[],
        generateSideWallUV(
            geometry: THREE$Geometry,
            indexA: number,
            indexB: number,
            indexC: number,
            indexD: number): THREE$Vector2[]
    };
    addShapeList(shapes: THREE$Shape[], options?: any): void;
    addShape(shape: THREE$Shape, options?: any): void
}

declare export class IcosahedronGeometry mixins PolyhedronGeometry {
    constructor(radius: number, detail: number): this
}

declare export class LatheBufferGeometry mixins BufferGeometry {
    constructor(points: THREE$Vector3[], segments?: number, phiStart?: number, phiLength?: number): this;
    parameters: {
        points: THREE$Vector3[],
        segments: number,
        phiStart: number,
        phiLength: number
    }
}

declare export class LatheGeometry mixins Geometry {
    constructor(points: THREE$Vector3[], segments?: number, phiStart?: number, phiLength?: number): this;
    parameters: {
        points: THREE$Vector3[],
        segments: number,
        phiStart: number,
        phiLength: number
    }
}

declare export class OctahedronGeometry mixins PolyhedronGeometry {
    constructor(radius: number, detail: number): this
}

declare export class ParametricGeometry mixins Geometry {
    constructor(func: (u: number, v: number) => THREE$Vector3, slices: number, stacks: number): this;
    parameters: {
        func: (u: number, v: number) => THREE$Vector3,
        slices: number,
        stacks: number
    }
}

declare export class PlaneBufferGeometry mixins BufferGeometry {
    constructor(width: number, height: number, widthSegments?: number, heightSegments?: number): this;
    parameters: {
        width: number,
        height: number,
        widthSegments: number,
        heightSegments: number
    }
}

declare export class PlaneGeometry mixins Geometry {
    constructor(width: number, height: number, widthSegments?: number, heightSegments?: number): this;
    parameters: {
        width: number,
        height: number,
        widthSegments: number,
        heightSegments: number
    }
}

declare export class PolyhedronGeometry mixins Geometry {
    constructor(vertices: THREE$Vector3[], faces: THREE$Face3[], radius?: number, detail?: number): this;
    parameters: {
        vertices: THREE$Vector3[],
        faces: THREE$Face3[],
        radius: number,
        detail: number
    };
    boundingSphere: THREE$Sphere
}

declare export class RingBufferGeometry mixins BufferGeometry {
    constructor(innerRadius?: number, outerRadius?: number, thetaSegments?: number, phiSegments?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        innerRadius: number,
        outerRadius: number,
        thetaSegments: number,
        phiSegments: number,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class RingGeometry mixins Geometry {
    constructor(innerRadius?: number, outerRadius?: number, thetaSegments?: number, phiSegments?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        innerRadius: number,
        outerRadius: number,
        thetaSegments: number,
        phiSegments: number,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class ShapeGeometry mixins Geometry {
    constructor(shape: THREE$Shape, options?: any): this;
    constructor(shapes: THREE$Shape[], options?: any): this;
    addShapeList(shapes: THREE$Shape[], options: any): THREE$ShapeGeometry;
    addShape(shape: THREE$Shape, options?: any): void
}

declare export class SphereBufferGeometry mixins BufferGeometry {
    constructor(radius: number, widthSegments?: number, heightSegments?: number, phiStart?: number, phiLength?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radius: number,
        widthSegments: number,
        heightSegments: number,
        phiStart: number,
        phiLength: number,
        thetaStart: number,
        thetaLength: number
    }
}


/**
 * A class for generating sphere geometries
 */
declare export class SphereGeometry mixins Geometry {

    /**
     * The geometry is created by sweeping and calculating vertexes around the Y axis (horizontal sweep) and the Z axis (vertical sweep). Thus, incomplete spheres (akin to 'sphere slices') can be created through the use of different values of phiStart, phiLength, thetaStart and thetaLength, in order to define the points in which we start (or end) calculating those vertices.
     * @param radius  sphere radius. Default is 50.
     * @param widthSegments  number of horizontal segments. Minimum value is 3, and the default is 8.
     * @param heightSegments  number of vertical segments. Minimum value is 2, and the default is 6.
     * @param phiStart  specify horizontal starting angle. Default is 0.
     * @param phiLength  specify horizontal sweep angle size. Default is Math.PI * 2.
     * @param thetaStart  specify vertical starting angle. Default is 0.
     * @param thetaLength  specify vertical sweep angle size. Default is Math.PI.
     */
    constructor(radius: number, widthSegments?: number, heightSegments?: number, phiStart?: number, phiLength?: number, thetaStart?: number, thetaLength?: number): this;
    parameters: {
        radius: number,
        widthSegments: number,
        heightSegments: number,
        phiStart: number,
        phiLength: number,
        thetaStart: number,
        thetaLength: number
    }
}

declare export class TetrahedronGeometry mixins PolyhedronGeometry {
    constructor(radius?: number, detail?: number): this
}

declare export interface THREE$TextGeometryParameters {
    font: THREE$Font,
        size: number,
        height: number,
        curveSegments: number,
        bevelEnabled: boolean,
        bevelThickness: number,
        bevelSize: number
}

declare export class TextGeometry mixins ExtrudeGeometry {
    constructor(text: string, parameters?: THREE$TextGeometryParameters): this;
    parameters: {
        font: THREE$Font,
        size: number,
        height: number,
        curveSegments: number,
        bevelEnabled: boolean,
        bevelThickness: number,
        bevelSize: number
    }
}

declare export class TorusBufferGeometry mixins BufferGeometry {
    constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number): this;
    parameters: {
        radius: number,
        tube: number,
        radialSegments: number,
        tubularSegments: number,
        arc: number
    }
}

declare export class TorusGeometry mixins Geometry {
    constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, arc?: number): this;
    parameters: {
        radius: number,
        tube: number,
        radialSegments: number,
        tubularSegments: number,
        arc: number
    }
}

declare export class TorusKnotBufferGeometry mixins BufferGeometry {
    constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, heightScale?: number): this;
    parameters: {
        radius: number,
        tube: number,
        radialSegments: number,
        tubularSegments: number,
        p: number,
        q: number,
        heightScale: number
    }
}

declare export class TorusKnotGeometry mixins Geometry {
    constructor(radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, heightScale?: number): this;
    parameters: {
        radius: number,
        tube: number,
        radialSegments: number,
        tubularSegments: number,
        p: number,
        q: number,
        heightScale: number
    }
}

declare export class TubeGeometry mixins Geometry {
    constructor(path: THREE$Path, segments?: number, radius?: number, radiusSegments?: number, closed?: boolean, taper?: (u: number) => number): this;
    parameters: {
        path: THREE$Path,
        segments: number,
        radius: number,
        radialSegments: number,
        closed: boolean,
        taper: (u: number) => number
    };
    tangents: THREE$Vector3[];
    normals: THREE$Vector3[];
    binormals: THREE$Vector3[];
    NoTaper(u?: number): number;
    SinusoidalTaper(u: number): number;
    FrenetFrames(path: THREE$Path, segments: number, closed: boolean): void
}

declare export class WireframeGeometry mixins BufferGeometry {
    constructor(geometry: THREE$Geometry | THREE$BufferGeometry): this
}

declare export class ArrowHelper mixins Object3D {
    constructor(dir: THREE$Vector3, origin?: THREE$Vector3, length?: number, hex?: number, headLength?: number, headWidth?: number): this;
    line: THREE$Line;
    cone: THREE$Mesh;
    setDirection(dir: THREE$Vector3): void;
    setLength(length: number, headLength?: number, headWidth?: number): void;
    setColor(hex: number): void
}

declare export class AxisHelper mixins LineSegments {
    constructor(size?: number): this
}

declare export class BoundingBoxHelper mixins Mesh {
    constructor(object?: THREE$Object3D, hex?: number): this;
    object: THREE$Object3D;
    box: THREE$Box3;
    update(): void
}

declare export class BoxHelper mixins LineSegments {
    constructor(object?: THREE$Object3D, color?: THREE$Color): this;
    update(object?: THREE$Object3D): void
}

declare export class CameraHelper mixins LineSegments {
    constructor(camera: THREE$Camera): this;
    camera: THREE$Camera;
    pointMap: {
        [id: string]: number[]
    };
    update(): void
}

declare export class DirectionalLightHelper mixins Object3D {
    constructor(light: THREE$Light, size?: number): this;
    light: THREE$Light;
    lightPlane: THREE$Line;
    dispose(): void;
    update(): void
}

declare export class EdgesHelper mixins LineSegments {
    constructor(object: THREE$Object3D, hex?: number, thresholdAngle?: number): this
}

declare export class FaceNormalsHelper mixins LineSegments {
    constructor(object: THREE$Object3D, size?: number, hex?: number, linewidth?: number): this;
    object: THREE$Object3D;
    size: number;
    update(object?: THREE$Object3D): void
}

declare export class GridHelper mixins LineSegments {
    constructor(size: number, divisions: number, color1?: THREE$Color | number, color2?: THREE$Color | number): this;
    setColors(color1?: THREE$Color | number, color2?: THREE$Color | number): void
}

declare export class HemisphereLightHelper mixins Object3D {
    constructor(light: THREE$Light, sphereSize: number): this;
    light: THREE$Light;
    colors: THREE$Color[];
    lightSphere: THREE$Mesh;
    dispose(): void;
    update(): void
}

declare export class PointLightHelper mixins Object3D {
    constructor(light: THREE$Light, sphereSize: number): this;
    light: THREE$Light;
    dispose(): void;
    update(): void
}

declare export class SkeletonHelper mixins LineSegments {
    constructor(bone: THREE$Object3D): this;
    bones: THREE$Bone[];
    root: THREE$Object3D;
    getBoneList(object: THREE$Object3D): THREE$Bone[];
    update(): void
}

declare export class SpotLightHelper mixins Object3D {
    constructor(light: THREE$Light): this;
    light: THREE$Light;
    dispose(): void;
    update(): void
}

declare export class VertexNormalsHelper mixins LineSegments {
    constructor(object: THREE$Object3D, size?: number, hex?: number, linewidth?: number): this;
    object: THREE$Object3D;
    size: number;
    update(object?: THREE$Object3D): void
}

declare export class WireframeHelper mixins LineSegments {
    constructor(object: THREE$Object3D, hex?: number): this
}

declare export class ImmediateRenderObject mixins Object3D {
    constructor(material: THREE$Material): this;
    material: THREE$Material;
    render(renderCallback: Function): void
}

declare export interface THREE$MorphBlendMeshAnimation {
    start: number,
        end: number,
        length: number,
        fps: number,
        duration: number,
        lastFrame: number,
        currentFrame: number,
        active: boolean,
        time: number,
        direction: number,
        weight: number,
        directionBackwards: boolean,
        mirroredLoop: boolean
}

declare export class MorphBlendMesh mixins Mesh {
    constructor(geometry: THREE$Geometry, material: THREE$Material): this;
    animationsMap: {
        [name: string]: THREE$MorphBlendMeshAnimation
    };
    animationsList: THREE$MorphBlendMeshAnimation[];
    createAnimation(name: string, start: number, end: number, fps: number): void;
    autoCreateAnimations(fps: number): void;
    setAnimationDirectionForward(name: string): void;
    setAnimationDirectionBackward(name: string): void;
    setAnimationFPS(name: string, fps: number): void;
    setAnimationDuration(name: string, duration: number): void;
    setAnimationWeight(name: string, weight: number): void;
    setAnimationTime(name: string, time: number): void;
    getAnimationTime(name: string): number;
    getAnimationDuration(name: string): number;
    playAnimation(name: string): void;
    stopAnimation(name: string): void;
    update(delta: number): void
}
declare module 'three' {
    declare module.exports: typeof THREE
}