/**
 * Flowtype definitions for ss-utils
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface ssutils$Static {
    handlers: {
            [index: string]: Function
        },
        onSubmitDisable: string,
        validation: ssutils$Validation,
        clearAdjacentError: () => void,
        todate: (s: string) => Date,
        todfmt: (s: string) => string,
        dfmt: (d: Date) => string,
        dfmthm: (d: Date) => string,
        tfmt12: (d: Date) => string,
        splitOnFirst: (s: string, delimiter: string) => string[],
        splitOnLast: (s: string, delimiter: string) => string[],
        getSelection: () => string,
        combinePaths: (...paths: string[]) => string,
        queryString: (url: string) => {
            [index: string]: string
        },
        createPath: (route: string, args: any) => string,
        createUrl: (route: string, args: any) => string,
        humanize: (s: string) => string,
        normalizeKey: (key: string) => string,
        normalize: (dto: any, deep?: boolean) => any,
        parseResponseStatus: (json: string, defaultMsg?: string) => any,
        postJSON: (
            url: string,
            data: Object | String,
            success?: Function,
            error?: Function) => any,
        listenOn: string,
        eventReceivers: any,
        eventChannels: string[],
        eventSourceUrl: string,
        updateSubscriberUrl: string,
        updateChannels: (channels: string[]) => void,
        updateSubscriber: (
            data: ssutils$UpdateSubscriberOptions,
            cb?: (user: ssutils$SSEUpdate) => void,
            cbError?: Function) => any,
        subscribeToChannels: (
            channels: string[],
            cb?: (user: ssutils$SSEUpdate) => void,
            cbError?: Function) => any,
        unsubscribeFromChannels: (
            channels: string[],
            cb?: (user: ssutils$SSEUpdate) => void,
            cbError?: Function) => any,
        reconnectServerEvents: (opt: ssutils$ReconnectServerEventsOptions) => any
}

declare interface ssutils$Validation {
    overrideMessages: boolean,
        messages: {
            [index: string]: string
        },
        errorFilter: (errorMsg: string, errorCode: string, type: string) => void
}

declare interface ssutils$ValidationOptional {
    overrideMessages?: boolean,
        messages?: {
            [index: string]: string
        },
        errorFilter?: (errorMsg: string, errorCode: string, type: string) => void
}

declare type ssutils$ApplyErrorsOptions = {} & ssutils$ValidationOptional


declare interface ssutils$BindFormOptions {
    validation?: ssutils$ValidationOptional,
        validate?: (form: HTMLFormElement) => boolean,
        onSubmitDisable?: string,
        complete?: (...args: any[]) => void,
        error?: (...args: any[]) => void
}

declare interface ssutils$HandleServerEventsOptions {
    handlers?: {
            [index: string]: Function
        },
        validate?: (op?: string, target?: string, msg?: string, json?: string) => boolean,
        heartbeatUrl?: string,
        heartbeatIntervalMs?: number,
        unRegisterUrl?: string,
        receivers?: {
            [index: string]: any
        },
        success?: (selector: string, msg: string, e: any) => void
}

declare interface ssutils$UpdateSubscriberOptions {
    SubscribeChannels?: string,
        UnsubscribeChannels?: string
}

declare interface ssutils$ResponseStatus {
    errorCode: string,
        message: string,
        stackTrace: string,
        errors: ssutils$ResponseError[]
}

declare interface ssutils$ResponseError {
    errorCode: string,
        fieldName: string,
        message: string
}

declare interface ssutils$SSECommand {
    userId: string,
        displayName: string,
        channels: string,
        profileUrl: string
}

declare type ssutils$SSEHeartbeat = {} & ssutils$SSECommand


declare type ssutils$SSEJoin = {} & ssutils$SSECommand


declare type ssutils$SSELeave = {} & ssutils$SSECommand


declare type ssutils$SSEUpdate = {} & ssutils$SSECommand


declare type ssutils$SSEConnect = {
    id: string,
    unRegisterUrl: string,
    heartbeatUrl: string,
    updateSubscriberUrl: string,
    heartbeatIntervalMs: number,
    idleTimeoutMs: number
} & ssutils$SSECommand


declare interface ssutils$ReconnectServerEventsOptions {
    url?: string,
        onerror?: (...args: any[]) => void,
        onmessage?: (...args: any[]) => void,
        errorArgs?: any[]
}

declare type ssutils$IEventSourceStatic = {
    new(
        url: string,
        eventSourceInitDict?: ssutils$IEventSourceInit): ssutils$IEventSourceStatic,
    url: string,
    withCredentials: boolean,
    CONNECTING: ReadyState,
    OPEN: ReadyState,
    CLOSED: ReadyState,
    readyState: ReadyState,
    onopen: Function,
    onmessage: (event: ssutils$IOnMessageEvent) => void,
    onerror: Function,
    close: () => void
} & EventTarget


declare interface ssutils$IEventSourceInit {
    withCredentials?: boolean
}

declare interface ssutils$IOnMessageEvent {
    data: string
}
declare interface JQuery {
    setFieldError: (name: string, msg: string) => void,
        serializeMap: () => {
            [index: string]: any
        },
        applyErrors: (status: ssutils$ResponseStatus, opt?: ssutils$ApplyErrorsOptions) => JQuery,
        clearErrors: () => JQuery,
        bindForm: (opt?: ssutils$ApplyErrorsOptions) => JQuery,
        applyValues: (values: {
            [index: string]: string
        }) => JQuery,
        bindHandlers: (handlers: {
            [index: string]: Function
        }) => JQuery,
        setActiveLinks: () => JQuery,
        handleServerEvents: (opt?: ssutils$HandleServerEventsOptions) => void
}
declare interface JQueryStatic {
    ss: ssutils$Static
}
declare module 'ss-utils' {
    declare module.exports: typeof ssutils
}