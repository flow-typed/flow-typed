/**
 * Flowtype definitions for text-buffer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare interface TextBuffer$IPointStatic {
    new(row?: number, column?: number): TextBuffer$IPoint,
    fromObject(point: TextBuffer$IPoint, copy?: boolean): TextBuffer$IPoint,
        fromObject(object: number[]): TextBuffer$IPoint,
        fromObject(object: {
            row: number,
            column: number
        }): TextBuffer$IPoint,
        min(point1: TextBuffer$IPoint, point2: TextBuffer$IPoint): TextBuffer$IPoint,
        min(point1: number[], point2: TextBuffer$IPoint): TextBuffer$IPoint,
        min(
            point1: {
                row: number,
                column: number
            },
            point2: TextBuffer$IPoint): TextBuffer$IPoint,
        min(point1: TextBuffer$IPoint, point2: number[]): TextBuffer$IPoint,
        min(point1: number[], point2: number[]): TextBuffer$IPoint,
        min(point1: {
            row: number,
            column: number
        }, point2: number[]): TextBuffer$IPoint,
        min(
            point1: TextBuffer$IPoint,
            point2: {
                row: number,
                column: number
            }): TextBuffer$IPoint,
        min(point1: number[], point2: {
            row: number,
            column: number
        }): TextBuffer$IPoint,
        min(
            point1: {
                row: number,
                column: number
            },
            point2: {
                row: number,
                column: number
            }): TextBuffer$IPoint
}

declare interface TextBuffer$IPoint {
    constructor: TextBuffer$IPointStatic,
        row: number,
        column: number,
        copy(): TextBuffer$IPoint,
        freeze(): TextBuffer$IPoint,
        translate(delta: TextBuffer$IPoint): TextBuffer$IPoint,
        translate(delta: number[]): TextBuffer$IPoint,
        translate(delta: {
            row: number,
            column: number
        }): TextBuffer$IPoint,
        add(other: TextBuffer$IPoint): TextBuffer$IPoint,
        add(other: number[]): TextBuffer$IPoint,
        add(other: {
            row: number,
            column: number
        }): TextBuffer$IPoint,
        splitAt(column: number): TextBuffer$IPoint[],
        compare(other: TextBuffer$IPoint): number,
        isEqual(other: TextBuffer$IPoint): boolean,
        isLessThan(other: TextBuffer$IPoint): boolean,
        isLessThanOrEqual(other: TextBuffer$IPoint): boolean,
        isGreaterThan(other: TextBuffer$IPoint): boolean,
        isGreaterThanOrEqual(other: TextBuffer$IPoint): boolean,
        toArray(): number[],
        serialize(): number[]
}

declare interface TextBuffer$IRangeStatic {
    deserialize(array: TextBuffer$IPoint[]): TextBuffer$IRange,
        fromObject(object: TextBuffer$IPoint[]): TextBuffer$IRange,
        fromObject(object: TextBuffer$IRange, copy?: boolean): TextBuffer$IRange,
        fromObject(
            object: {
                start: TextBuffer$IPoint,
                end: TextBuffer$IPoint
            }): TextBuffer$IRange,
        fromObject(object: {
            start: number[],
            end: TextBuffer$IPoint
        }): TextBuffer$IRange,
        fromObject(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: TextBuffer$IPoint
            }): TextBuffer$IRange,
        fromObject(object: {
            start: TextBuffer$IPoint,
            end: number[]
        }): TextBuffer$IRange,
        fromObject(object: {
            start: number[],
            end: number[]
        }): TextBuffer$IRange,
        fromObject(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: number[]
            }): TextBuffer$IRange,
        fromObject(
            object: {
                start: TextBuffer$IPoint,
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        fromObject(
            object: {
                start: number[],
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        fromObject(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        fromText(point: TextBuffer$IPoint, text: string): TextBuffer$IRange,
        fromText(point: number[], text: string): TextBuffer$IRange,
        fromText(point: {
            row: number,
            column: number
        }, text: string): TextBuffer$IRange,
        fromText(text: string): TextBuffer$IRange,
        fromPointWithDelta(
            startPoint: TextBuffer$IPoint,
            rowDelta: number,
            columnDelta: number): TextBuffer$IRange,
        fromPointWithDelta(startPoint: number[], rowDelta: number, columnDelta: number): TextBuffer$IRange,
        fromPointWithDelta(
            startPoint: {
                row: number,
                column: number
            },
            rowDelta: number,
            columnDelta: number): TextBuffer$IRange,
        new(point1: TextBuffer$IPoint, point2: TextBuffer$IPoint): TextBuffer$IRange,
        new(point1: number[], point2: TextBuffer$IPoint): TextBuffer$IRange,
        new(
            point1: {
                row: number,
                column: number
            },
            point2: TextBuffer$IPoint): TextBuffer$IRange,
        new(point1: TextBuffer$IPoint, point2: number[]): TextBuffer$IRange,
        new(point1: number[], point2: number[]): TextBuffer$IRange,
        new(point1: {
            row: number,
            column: number
        }, point2: number[]): TextBuffer$IRange,
        new(
            point1: TextBuffer$IPoint,
            point2: {
                row: number,
                column: number
            }): TextBuffer$IRange,
        new(point1: number[], point2: {
            row: number,
            column: number
        }): TextBuffer$IRange,
        new(
            point1: {
                row: number,
                column: number
            },
            point2: {
                row: number,
                column: number
            }): TextBuffer$IRange
}

declare interface TextBuffer$IRange {
    constructor: TextBuffer$IRangeStatic,
        start: TextBuffer$IPoint,
        end: TextBuffer$IPoint,
        serialize(): number[][],
        copy(): TextBuffer$IRange,
        freeze(): TextBuffer$IRange,
        isEqual(other: TextBuffer$IRange): boolean,
        isEqual(other: TextBuffer$IPoint[]): boolean,
        compare(object: TextBuffer$IPoint[]): number,
        compare(object: {
            start: TextBuffer$IPoint,
            end: TextBuffer$IPoint
        }): number,
        compare(object: {
            start: number[],
            end: TextBuffer$IPoint
        }): number,
        compare(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: TextBuffer$IPoint
            }): number,
        compare(object: {
            start: TextBuffer$IPoint,
            end: number[]
        }): number,
        compare(object: {
            start: number[],
            end: number[]
        }): number,
        compare(object: {
            start: {
                row: number,
                column: number
            },
            end: number[]
        }): number,
        compare(
            object: {
                start: TextBuffer$IPoint,
                end: {
                    row: number,
                    column: number
                }
            }): number,
        compare(object: {
            start: number[],
            end: {
                row: number,
                column: number
            }
        }): number,
        compare(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: {
                    row: number,
                    column: number
                }
            }): number,
        isSingleLine(): boolean,
        coversSameRows(other: TextBuffer$IRange): boolean,
        add(object: TextBuffer$IPoint[]): TextBuffer$IRange,
        add(
            object: {
                start: TextBuffer$IPoint,
                end: TextBuffer$IPoint
            }): TextBuffer$IRange,
        add(object: {
            start: number[],
            end: TextBuffer$IPoint
        }): TextBuffer$IRange,
        add(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: TextBuffer$IPoint
            }): TextBuffer$IRange,
        add(object: {
            start: TextBuffer$IPoint,
            end: number[]
        }): TextBuffer$IRange,
        add(object: {
            start: number[],
            end: number[]
        }): TextBuffer$IRange,
        add(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: number[]
            }): TextBuffer$IRange,
        add(
            object: {
                start: TextBuffer$IPoint,
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        add(
            object: {
                start: number[],
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        add(
            object: {
                start: {
                    row: number,
                    column: number
                },
                end: {
                    row: number,
                    column: number
                }
            }): TextBuffer$IRange,
        translate(startPoint: TextBuffer$IPoint, endPoint: TextBuffer$IPoint): TextBuffer$IRange,
        translate(startPoint: TextBuffer$IPoint): TextBuffer$IRange,
        intersectsWith(otherRange: TextBuffer$IRange): boolean,
        containsRange(otherRange: TextBuffer$IRange, exclusive: boolean): boolean,
        containsPoint(point: TextBuffer$IPoint, exclusive: boolean): boolean,
        containsPoint(point: number[], exclusive: boolean): boolean,
        containsPoint(point: {
            row: number,
            column: number
        }, exclusive: boolean): boolean,
        intersectsRow(row: number): boolean,
        intersectsRowRange(startRow: number, endRow: number): boolean,
        union(otherRange: TextBuffer$IRange): TextBuffer$IRange,
        isEmpty(): boolean,
        toDelta(): TextBuffer$IPoint,
        getRowCount(): number,
        getRows(): number[]
}

declare interface TextBuffer$IHistory {}

declare interface TextBuffer$IMarkerManager {}

declare interface TextBuffer$IMarker {}

declare interface TextBuffer$IBufferPatch {}

declare interface TextBuffer$ITextBufferStatic {
    Point: TextBuffer$IPointStatic,
        Range: TextBuffer$IRangeStatic,
        newlineRegex: any,
        new(text: string): TextBuffer$ITextBuffer,
        new(params: any): TextBuffer$ITextBuffer
}

declare type TextBuffer$ITextBuffer = {
        cachedText: string,
        stoppedChangingDelay: number,
        stoppedChangingTimeout: any,
        cachedDiskContents: string,
        conflict: boolean,
        file: any,
        refcount: number,
        lines: string[],
        lineEndings: string[],
        offsetIndex: any,
        history: TextBuffer$IHistory,
        markers: TextBuffer$IMarkerManager,
        loaded: boolean,
        digestWhenLastPersisted: string,
        modifiedWhenLastPersisted: boolean,
        useSerializedText: boolean,
        deserializeParams(params: any): any,
        serializeParams(): any,
        getText(): string,
        getLines(): string,
        isEmpty(): boolean,
        getLineCount(): number,
        getLastRow(): number,
        lineForRow(row: number): string,
        getLastLine(): string,
        lineEndingForRow(row: number): string,
        lineLengthForRow(row: number): number,
        setText(text: string): TextBuffer$IRange,
        setTextViaDiff(text: any): any[],
        setTextInRange(
            range: TextBuffer$IRange,
            text: string,
            normalizeLineEndings?: boolean): TextBuffer$IRange,
        insert(
            position: TextBuffer$IPoint,
            text: string,
            normalizeLineEndings?: boolean): TextBuffer$IRange,
        append(text: string, normalizeLineEndings?: boolean): TextBuffer$IRange,
        delete(range: TextBuffer$IRange): TextBuffer$IRange,
        deleteRow(row: number): TextBuffer$IRange,
        deleteRows(startRow: number, endRow: number): TextBuffer$IRange,
        buildPatch(
            oldRange: TextBuffer$IRange,
            newText: string,
            normalizeLineEndings?: boolean): TextBuffer$IBufferPatch,
        applyPatch(patch: TextBuffer$IBufferPatch): any,
        getTextInRange(range: TextBuffer$IRange): string,
        clipRange(range: TextBuffer$IRange): TextBuffer$IRange,
        clipPosition(position: TextBuffer$IPoint): TextBuffer$IPoint,
        getFirstPosition(): TextBuffer$IPoint,
        getEndPosition(): TextBuffer$IPoint,
        getRange(): TextBuffer$IRange,
        rangeForRow(row: number, includeNewline?: boolean): TextBuffer$IRange,
        characterIndexForPosition(position: TextBuffer$IPoint): number,
        positionForCharacterIndex(offset: number): TextBuffer$IPoint,
        getMaxCharacterIndex(): number,
        loadSync(): TextBuffer$ITextBuffer,
        load(): Q.IPromise<TextBuffer$ITextBuffer>,
        finishLoading(): TextBuffer$ITextBuffer,
        handleTextChange(event: any): any,
        destroy(): any,
        isAlive(): boolean,
        isDestroyed(): boolean,
        isRetained(): boolean,
        retain(): TextBuffer$ITextBuffer,
        release(): TextBuffer$ITextBuffer,
        subscribeToFile(): any,
        hasMultipleEditors(): boolean,
        reload(): any,
        updateCachedDiskContentsSync(): string,
        updateCachedDiskContents(): Q.IPromise<string>,
        getBaseName(): string,
        getPath(): string,
        getUri(): string,
        setPath(filePath: string): any,
        save(): void,
        saveAs(filePath: string): any,
        isModified(): boolean,
        isInConflict(): boolean,
        destroyMarker(id: any): any,
        matchesInCharacterRange(regex: any, startIndex: any, endIndex: any): any[],
        scan(regex: any, iterator: any): any,
        backwardsScan(regex: any, iterator: any): any,
        replace(regex: any, replacementText: any): any,
        scanInRange(regex: any, range: any, iterator: any, reverse: any): any,
        backwardsScanInRange(regex: any, range: any, iterator: any): any,
        isRowBlank(row: number): boolean,
        previousNonBlankRow(startRow: number): number,
        nextNonBlankRow(startRow: number): number,
        usesSoftTabs(): boolean,
        cancelStoppedChangingTimeout(): any,
        scheduleModifiedEvents(): any,
        emitModifiedStatusChanged(modifiedStatus: any): any,
        logLines(start: number, end: number): void,
        undo(): any,
        redo(): any,
        transact(fn: Function): any,
        beginTransaction(): any,
        commitTransaction(): any,
        abortTransaction(): any,
        clearUndoStack(): any,
        markRange(range: any, properties: any): any,
        markPosition(range: any, properties: any): any,
        getMarker(id: number): TextBuffer$IMarker,
        getMarkers(): TextBuffer$IMarker[],
        getMarkerCount(): number
    } & &
    declare module 'text-buffer' {
        declare     var _: TextBuffer$ITextBufferStatic;
        declare module.exports: typeof _
    }