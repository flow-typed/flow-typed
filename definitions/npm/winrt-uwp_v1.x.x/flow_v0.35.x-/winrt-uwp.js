

declare module 'winrt-uwp' {
					
}

declare module 'npm$namespace$Windows' {
		declare interface WinRTError {
		description: string,
		number: number
	}

	declare interface WinRTEvent<TSender> {
		detail: any[],
		target: TSender,
		type: string
	}

	declare interface IInspectable {
		
	}

			
}

declare module 'Foundation' {
	declare type IPromiseWithIAsyncAction = IPromiseWithOperation<void, IAsyncAction>;

	declare type IPromiseWithIAsyncActionWithProgress<TProgress> = IPromiseWithOperation<void, IAsyncActionWithProgress<TProgress>>;

	declare type IPromiseWithIAsyncOperation<TResult> = IPromiseWithOperation<TResult, IAsyncOperation<TResult>>;

	declare type IPromiseWithIAsyncOperationWithProgress<TResult, TProgress> = IPromiseWithOperation<TResult, IAsyncOperationWithProgress<TResult, TProgress>>;

	declare type EventHandler<T> = (ev: T & WinRTEvent<any>) => void;

	declare type TypedEventHandler<TSender, TResult> = (ev: TResult & WinRTEvent<TSender>) => void;

	declare type AsyncActionCompletedHandler = (
		asyncInfo: Windows.Foundation.IAsyncAction, asyncStatus: Windows.Foundation.AsyncStatus
	) => void;

	declare type AsyncOperationCompletedHandler<TResult> = (
		asyncInfo: Windows.Foundation.IAsyncOperation<TResult>, asyncStatus: Windows.Foundation.AsyncStatus
	) => void;

	declare type AsyncOperationWithProgressCompletedHandler<TResult, TProgress> = (
		asyncInfo: Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>, asyncStatus: Windows.Foundation.AsyncStatus
	) => void;

	declare type AsyncOperationProgressHandler<TResult, TProgress> = (
		asyncInfo: Windows.Foundation.IAsyncOperationWithProgress<TResult, TProgress>, progressInfo: TProgress
	) => void;

	declare type DeferralCompletedHandler = () => void;

	declare type AsyncActionWithProgressCompletedHandler<TProgress> = (
		asyncInfo: Windows.Foundation.IAsyncActionWithProgress<TProgress>, asyncStatus: Windows.Foundation.AsyncStatus
	) => void;

	declare type AsyncActionProgressHandler<TProgress> = (
		asyncInfo: Windows.Foundation.IAsyncActionWithProgress<TProgress>, progressInfo: TProgress
	) => void;

	declare interface IPromise<TResult> {
		then<U>(
		success?: (value: TResult) => IPromise<U>, error?: (error: any) => IPromise<U>, progress?: (progress: any) => void
	): IPromise<U>,
		then<U>(
		success?: (value: TResult) => IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void
	): IPromise<U>,
		then<U>(
		success?: (value: TResult) => U, error?: (error: any) => IPromise<U>, progress?: (progress: any) => void
	): IPromise<U>,
		then<U>(
		success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void
	): IPromise<U>,
		done<U>(
		success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void
	): void,
		cancel(): void
	}

	declare interface IPromiseWithOperation<TResult, TOperation> {
		operation: TOperation
	}

	declare interface Rect {
		height: number,
		width: number,
		x: number,
		y: number
	}

	declare interface Size {
		height: number,
		width: number
	}

	declare interface IAsyncOperation<TResult> {
		getResults(): TResult,
		completed: Windows.Foundation.AsyncOperationCompletedHandler<TResult>
	}

	declare interface IAsyncAction {
		getResults(): void,
		completed: Windows.Foundation.AsyncActionCompletedHandler
	}

	declare interface IAsyncOperationWithProgress<TResult, TProgress> {
		getResults(): TResult,
		completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult, TProgress>,
		progress: Windows.Foundation.AsyncOperationProgressHandler<TResult, TProgress>
	}

	declare interface Point {
		x: number,
		y: number
	}

	declare interface IMemoryBuffer {
		createReference(): Windows.Foundation.IMemoryBufferReference
	}

	declare interface IMemoryBufferReference {
		capacity: number
	}

	declare interface IWwwFormUrlDecoderEntry {
		name: string,
		value: string
	}

	declare interface IAsyncActionWithProgress<TProgress> {
		getResults(): void,
		completed: Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>,
		progress: Windows.Foundation.AsyncActionProgressHandler<TProgress>
	}

	declare interface IAsyncInfo {
		cancel(): void,
		close(): void,
		errorCode: WinRTError,
		id: number,
		status: Windows.Foundation.AsyncStatus
	}

	declare interface IClosable {
		close(): void
	}

	declare interface IStringable {
		toString(): string
	}

		declare class Deferral  {
		constructor(handler: Windows.Foundation.DeferralCompletedHandler): this;
		close(): void;
		complete(): void
	}

	declare class MemoryBuffer  {
		constructor(capacity: number): this;
		close(): void;
		createReference(): Windows.Foundation.IMemoryBufferReference
	}

	declare class Uri  {
		escapeComponent(toEscape: string): string;
		unescapeComponent(toUnescape: string): string;
		constructor(baseUri: string, relativeUri: string): this;
		constructor(uri: string): this;
		absoluteCanonicalUri: string;
		absoluteUri: string;
		combineUri(relativeUri: string): Windows.Foundation.Uri;
		displayIri: string;
		displayUri: string;
		domain: string;
		equals(pUri: Windows.Foundation.Uri): boolean;
		extension: string;
		fragment: string;
		host: string;
		password: string;
		path: string;
		port: number;
		query: string;
		queryParsed: Windows.Foundation.WwwFormUrlDecoder;
		rawUri: string;
		schemeName: string;
		suspicious: boolean;
		userName: string
	}

	declare class WwwFormUrlDecoder extends Array<Windows.Foundation.IWwwFormUrlDecoderEntry> {
		constructor(query: string): this;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.IWwwFormUrlDecoderEntry>;
		getAt(index: number): Windows.Foundation.IWwwFormUrlDecoderEntry;
		getFirstValueByName(name: string): string;
		getMany(
		startIndex: number
	): {
		items: Windows.Foundation.IWwwFormUrlDecoderEntry,
		returnValue: number
	};
		indexOf(
		value: Windows.Foundation.IWwwFormUrlDecoderEntry
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Foundation.IWwwFormUrlDecoderEntry, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Foundation.IWwwFormUrlDecoderEntry, fromIndex?: number
	): number
	}

	declare class WwwFormUrlDecoderEntry  {
		name: string;
		value: string
	}

	
}

declare module 'Collections' {
	declare type MapChangedEventHandler<K, V> = (
		ev: Windows.Foundation.Collections.IMapChangedEventArgs<K> & WinRTEvent<Windows.Foundation.Collections.IObservableMap<K, V>>
	) => void;

	declare interface IVector<T> {
		indexOf(value: T, ...extra: any[]): {
		index: number,
		returnValue: boolean
	},
		indexOf(searchElement: T, fromIndex?: number): number
	}

	declare interface IVectorView<T> {
		indexOf(value: T, ...extra: any[]): {
		index: number,
		returnValue: boolean
	},
		indexOf(searchElement: T, fromIndex?: number): number
	}

	declare interface IVectorView<T> {
		getAt(index: number): T,
		getMany(startIndex: number): {
		items: T,
		returnValue: number
	},
		indexOf(value: T): {
		index: number,
		returnValue: boolean
	},
		size: number
	}

	declare interface IVector<T> {
		append(value: T): void,
		clear(): void,
		getAt(index: number): T,
		getMany(startIndex: number): {
		items: T,
		returnValue: number
	},
		getView(): Windows.Foundation.Collections.IVectorView<T>,
		indexOf(value: T): {
		index: number,
		returnValue: boolean
	},
		insertAt(index: number, value: T): void,
		removeAt(index: number): void,
		removeAtEnd(): void,
		replaceAll(items: T): void,
		setAt(index: number, value: T): void,
		size: number
	}

	declare interface IIterable<T> {
		first(): Windows.Foundation.Collections.IIterator<T>
	}

	declare interface IMapView<K, V> {
		hasKey(key: K): boolean,
		lookup(key: K): V,
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<K, V>,
		second: Windows.Foundation.Collections.IMapView<K, V>
	},
		size: number
	}

	declare interface IPropertySet {
		
	}

	declare interface IMap<K, V> {
		clear(): void,
		getView(): Windows.Foundation.Collections.IMapView<K, V>,
		hasKey(key: K): boolean,
		insert(key: K, value: V): boolean,
		lookup(key: K): V,
		remove(key: K): void,
		size: number
	}

	declare interface IIterator<T> {
		getMany(): {
		items: T,
		returnValue: number
	},
		moveNext(): boolean,
		current: T,
		hasCurrent: boolean
	}

	declare interface IKeyValuePair<K, V> {
		key: K,
		value: V
	}

	declare interface IObservableMap<K, V> {
		
	}

	declare interface IObservableVector<T> {
		
	}

	declare interface IVectorChangedEventArgs {
		collectionChange: Windows.Foundation.Collections.CollectionChange,
		index: number
	}

	declare interface IMapChangedEventArgs<K> {
		collectionChange: Windows.Foundation.Collections.CollectionChange,
		key: K
	}

		declare class PropertySet  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, any>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StringMap  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, string>;
		hasKey(key: string): boolean;
		insert(key: string, value: string): boolean;
		lookup(key: string): string;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, string>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, string>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, string>
	): void;
		remove(key: string): void;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ValueSet  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, any>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		remove(key: string): boolean;
		remove(key: string): void;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Core' {
		declare interface MseStreamSource {
		
	}

	declare interface ResourceLayoutInfo {
		checksum: number,
		majorVersion: number,
		minorVersion: number,
		namedResourceCount: number,
		resourceSubtreeCount: number
	}

	declare interface IMediaSource {
		
	}

	declare interface IMediaCue {
		duration: number,
		id: string,
		startTime: number
	}

	declare interface IMediaStreamDescriptor {
		isSelected: boolean,
		language: string,
		name: string
	}

	declare interface TimedTextSize {
		height: number,
		unit: Windows.Media.Core.TimedTextUnit,
		width: number
	}

	declare interface TimedTextDouble {
		unit: Windows.Media.Core.TimedTextUnit,
		value: number
	}

	declare interface TimedTextPadding {
		after: number,
		before: number,
		end: number,
		start: number,
		unit: Windows.Media.Core.TimedTextUnit
	}

	declare interface TimedTextPoint {
		unit: Windows.Media.Core.TimedTextUnit,
		x: number,
		y: number
	}

	declare interface ISingleSelectMediaTrackList {
		selectedIndex: number
	}

	declare interface CoreTextRange {
		endCaretPosition: number,
		startCaretPosition: number
	}

		declare class AppListEntry  {
		displayInfo: Windows.ApplicationModel.AppDisplayInfo;
		launchAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class NamedResource  {
		candidates: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
		resolve(
		resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext
	): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
		resolve(): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
		resolveAll(
		resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
		resolveAll(
		
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
		uri: Windows.Foundation.Uri
	}

	declare class ResourceCandidate  {
		getQualifierValue(qualifierName: string): string;
		getValueAsFileAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getValueAsStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		isDefault: boolean;
		isMatch: boolean;
		isMatchAsDefault: boolean;
		qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
		valueAsString: string
	}

	declare class ResourceCandidateVectorView extends Array<Windows.ApplicationModel.Resources.Core.ResourceCandidate> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
		getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
		getMany(
		startIndex: number
	): {
		items: Windows.ApplicationModel.Resources.Core.ResourceCandidate,
		returnValue: number
	};
		indexOf(
		value: Windows.ApplicationModel.Resources.Core.ResourceCandidate
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.ApplicationModel.Resources.Core.ResourceCandidate, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.ApplicationModel.Resources.Core.ResourceCandidate, fromIndex?: number
	): number
	}

	declare class ResourceContext  {
		createMatchingContext(
		result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>
	): Windows.ApplicationModel.Resources.Core.ResourceContext;
		getForCurrentView(): Windows.ApplicationModel.Resources.Core.ResourceContext;
		getForViewIndependentUse(): Windows.ApplicationModel.Resources.Core.ResourceContext;
		resetGlobalQualifierValues(): void;
		resetGlobalQualifierValues(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
		setGlobalQualifierValue(key: string, value: string): void;
		setGlobalQualifierValue(
		key: string, value: string, persistence: Windows.ApplicationModel.Resources.Core.ResourceQualifierPersistence
	): void;
		constructor(): this;
		clone(): Windows.ApplicationModel.Resources.Core.ResourceContext;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		overrideToMatch(
		result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>
	): void;
		qualifierValues: Windows.Foundation.Collections.IObservableMap<string, string>;
		reset(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
		reset(): void
	}

	declare class ResourceContextLanguagesVectorView extends Array<string> {
		first(): Windows.Foundation.Collections.IIterator<string>;
		getAt(index: number): string;
		getMany(startIndex: number): {
		items: string[],
		returnValue: number
	};
		indexOf(value: string): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(value: string, ...extra: any[]): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: string, fromIndex?: number): number
	}

	declare class ResourceManager  {
		current: Windows.ApplicationModel.Resources.Core.ResourceManager;
		isResourceReference(resourceReference: string): boolean;
		allResourceMaps: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Resources.Core.ResourceMap>;
		defaultContext: Windows.ApplicationModel.Resources.Core.ResourceContext;
		getAllNamedResourcesForPackage(
		packageName: string, resourceLayoutInfo: Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.NamedResource>;
		getAllSubtreesForPackage(
		packageName: string, resourceLayoutInfo: Windows.ApplicationModel.Resources.Core.ResourceLayoutInfo
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceMap>;
		loadPriFiles(
		files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>
	): void;
		mainResourceMap: Windows.ApplicationModel.Resources.Core.ResourceMap;
		unloadPriFiles(
		files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>
	): void
	}

	declare class ResourceMap  {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getSubtree(reference: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
		getValue(
		resource: string, context: Windows.ApplicationModel.Resources.Core.ResourceContext
	): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
		getValue(resource: string): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
		hasKey(key: string): boolean;
		lookup(key: string): Windows.ApplicationModel.Resources.Core.NamedResource;
		size: number;
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Resources.Core.NamedResource>,
		second: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Resources.Core.NamedResource>
	};
		uri: Windows.Foundation.Uri
	}

	declare class ResourceMapIterator  {
		current: Windows.Foundation.Collections.IKeyValuePair<string, Windows.ApplicationModel.Resources.Core.NamedResource>;
		getMany(
		
	): {
		items: Windows.Foundation.Collections.IKeyValuePair<any, any>,
		returnValue: number
	};
		hasCurrent: boolean;
		moveNext(): boolean
	}

	declare class ResourceMapMapView  {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		hasKey(key: string): boolean;
		lookup(key: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
		size: number;
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Resources.Core.ResourceMap>,
		second: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Resources.Core.ResourceMap>
	}
	}

	declare class ResourceMapMapViewIterator  {
		current: Windows.Foundation.Collections.IKeyValuePair<string, Windows.ApplicationModel.Resources.Core.ResourceMap>;
		getMany(
		
	): {
		items: Windows.Foundation.Collections.IKeyValuePair<any, any>,
		returnValue: number
	};
		hasCurrent: boolean;
		moveNext(): boolean
	}

	declare class ResourceQualifier  {
		isDefault: boolean;
		isMatch: boolean;
		qualifierName: string;
		qualifierValue: string;
		score: number
	}

	declare class ResourceQualifierMapView  {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		hasKey(key: string): boolean;
		lookup(key: string): string;
		size: number;
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<string, string>,
		second: Windows.Foundation.Collections.IMapView<string, string>
	}
	}

	declare class ResourceQualifierObservableMap  {
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, string>;
		hasKey(key: string): boolean;
		insert(key: string, value: string): boolean;
		lookup(key: string): string;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, string>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, string>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, string>
	): void;
		remove(key: string): void;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ResourceQualifierVectorView extends Array<Windows.ApplicationModel.Resources.Core.ResourceQualifier> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
		getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceQualifier;
		getMany(
		startIndex: number
	): {
		items: Windows.ApplicationModel.Resources.Core.ResourceQualifier,
		returnValue: number
	};
		indexOf(
		value: Windows.ApplicationModel.Resources.Core.ResourceQualifier
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.ApplicationModel.Resources.Core.ResourceQualifier, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.ApplicationModel.Resources.Core.ResourceQualifier, fromIndex?: number
	): number
	}

	declare class RequestingFocusOnKeyboardInputEventArgs  {
		
	}

	declare class SearchSuggestion  {
		detailText: string;
		image: Windows.Storage.Streams.IRandomAccessStreamReference;
		imageAlternateText: string;
		kind: Windows.ApplicationModel.Search.Core.SearchSuggestionKind;
		tag: string;
		text: string
	}

	declare class SearchSuggestionManager  {
		constructor(): this;
		addToHistory(queryText: string, language: string): void;
		addToHistory(queryText: string): void;
		clearHistory(): void;
		onrequestingfocusonkeyboardinput: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.RequestingFocusOnKeyboardInputEventArgs>;
		addEventListener(
		type: "requestingfocusonkeyboardinput", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.RequestingFocusOnKeyboardInputEventArgs>
	): void;
		removeEventListener(
		type: "requestingfocusonkeyboardinput", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.RequestingFocusOnKeyboardInputEventArgs>
	): void;
		onsuggestionsrequested: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs>;
		addEventListener(
		type: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.Core.SearchSuggestionManager, Windows.ApplicationModel.Search.Core.SearchSuggestionsRequestedEventArgs>
	): void;
		searchHistoryContext: string;
		searchHistoryEnabled: boolean;
		setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
		setQuery(
		queryText: string, language: string, linguisticDetails: Windows.ApplicationModel.Search.SearchQueryLinguisticDetails
	): void;
		setQuery(queryText: string): void;
		setQuery(queryText: string, language: string): void;
		suggestions: Windows.Foundation.Collections.IObservableVector<Windows.ApplicationModel.Search.Core.SearchSuggestion>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SearchSuggestionsRequestedEventArgs  {
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchQueryLinguisticDetails;
		queryText: string;
		request: Windows.ApplicationModel.Search.SearchSuggestionsRequest
	}

	declare class ApplicationDataManager  {
		createForPackageFamily(packageFamilyName: string): Windows.Storage.ApplicationData
	}

	declare class VariablePhotoCapturedEventArgs  {
		captureTimeOffset: number;
		capturedFrameControlValues: Windows.Media.Capture.CapturedFrameControlValues;
		frame: Windows.Media.Capture.CapturedFrame;
		usedFrameControllerIndex: number
	}

	declare class VariablePhotoSequenceCapture  {
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		onphotocaptured: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs>;
		addEventListener(
		type: "photocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs>
	): void;
		removeEventListener(
		type: "photocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, Windows.Media.Capture.Core.VariablePhotoCapturedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.Core.VariablePhotoSequenceCapture, any>
	): void;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		updateSettingsAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AudioStreamDescriptor  {
		constructor(encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties): this;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		isSelected: boolean;
		language: string;
		name: string
	}

	declare class AudioTrack  {
		id: string;
		label: string;
		language: string;
		trackKind: Windows.Media.Core.MediaTrackKind
	}

	declare class DataCue  {
		constructor(): this;
		data: Windows.Storage.Streams.IBuffer;
		duration: number;
		id: string;
		startTime: number
	}

	declare class FaceDetectedEventArgs  {
		resultFrame: Windows.Media.Core.FaceDetectionEffectFrame
	}

	declare class FaceDetectionEffect  {
		desiredDetectionInterval: number;
		enabled: boolean;
		onfacedetected: Windows.Foundation.TypedEventHandler<Windows.Media.Core.FaceDetectionEffect, Windows.Media.Core.FaceDetectedEventArgs>;
		addEventListener(
		type: "facedetected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.FaceDetectionEffect, Windows.Media.Core.FaceDetectedEventArgs>
	): void;
		removeEventListener(
		type: "facedetected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.FaceDetectionEffect, Windows.Media.Core.FaceDetectedEventArgs>
	): void;
		setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class FaceDetectionEffectDefinition  {
		constructor(): this;
		activatableClassId: string;
		detectionMode: Windows.Media.Core.FaceDetectionMode;
		properties: Windows.Foundation.Collections.IPropertySet;
		synchronousDetectionEnabled: boolean
	}

	declare class FaceDetectionEffectFrame  {
		close(): void;
		detectedFaces: Windows.Foundation.Collections.IVectorView<Windows.Media.FaceAnalysis.DetectedFace>;
		duration: number;
		extendedProperties: Windows.Foundation.Collections.IPropertySet;
		isDiscontinuous: boolean;
		isReadOnly: boolean;
		relativeTime: number;
		systemRelativeTime: number;
		type: string
	}

	declare class HighDynamicRangeControl  {
		enabled: boolean
	}

	declare class HighDynamicRangeOutput  {
		certainty: number;
		frameControllers: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.Core.FrameController>
	}

	declare class MediaBinder  {
		constructor(): this;
		onbinding: Windows.Foundation.TypedEventHandler<MediaBinder, MediaBindingEventArgs>;
		addEventListener(
		type: "binding", listener: Windows.Foundation.TypedEventHandler<MediaBinder, MediaBindingEventArgs>
	): void;
		removeEventListener(
		type: "binding", listener: Windows.Foundation.TypedEventHandler<MediaBinder, MediaBindingEventArgs>
	): void;
		source: Windows.Media.Core.MediaSource;
		token: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaBindingEventArgs  {
		getDeferral(): Windows.Foundation.Deferral;
		mediaBinder: Windows.Media.Core.MediaBinder;
		oncanceled: Windows.Foundation.TypedEventHandler<MediaBindingEventArgs, any>;
		addEventListener(
		type: "canceled", listener: Windows.Foundation.TypedEventHandler<MediaBindingEventArgs, any>
	): void;
		removeEventListener(
		type: "canceled", listener: Windows.Foundation.TypedEventHandler<MediaBindingEventArgs, any>
	): void;
		setStream(stream: Windows.Storage.Streams.IRandomAccessStream, contentType: string): void;
		setStreamReference(
		stream: Windows.Storage.Streams.IRandomAccessStreamReference, contentType: string
	): void;
		setUri(uri: Windows.Foundation.Uri): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaCueEventArgs  {
		cue: Windows.Media.Core.IMediaCue
	}

	declare class MediaSource  {
		createFromAdaptiveMediaSource(
		mediaSource: Windows.Media.Streaming.Adaptive.AdaptiveMediaSource
	): Windows.Media.Core.MediaSource;
		createFromIMediaSource(mediaSource: Windows.Media.Core.IMediaSource): Windows.Media.Core.MediaSource;
		createFromMediaBinder(binder: Windows.Media.Core.MediaBinder): Windows.Media.Core.MediaSource;
		createFromMediaStreamSource(
		mediaSource: Windows.Media.Core.MediaStreamSource
	): Windows.Media.Core.MediaSource;
		createFromMseStreamSource(
		mediaSource: Windows.Media.Core.MseStreamSource
	): Windows.Media.Core.MediaSource;
		createFromStorageFile(file: Windows.Storage.IStorageFile): Windows.Media.Core.MediaSource;
		createFromStream(
		stream: Windows.Storage.Streams.IRandomAccessStream, contentType: string
	): Windows.Media.Core.MediaSource;
		createFromStreamReference(
		stream: Windows.Storage.Streams.IRandomAccessStreamReference, contentType: string
	): Windows.Media.Core.MediaSource;
		createFromUri(uri: Windows.Foundation.Uri): Windows.Media.Core.MediaSource;
		close(): void;
		customProperties: Windows.Foundation.Collections.ValueSet;
		duration: number;
		externalTimedMetadataTracks: Windows.Foundation.Collections.IObservableVector<Windows.Media.Core.TimedMetadataTrack>;
		externalTimedTextSources: Windows.Foundation.Collections.IObservableVector<Windows.Media.Core.TimedTextSource>;
		isOpen: boolean;
		onopenoperationcompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs>;
		addEventListener(
		type: "openoperationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs>
	): void;
		removeEventListener(
		type: "openoperationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, Windows.Media.Core.MediaSourceOpenOperationCompletedEventArgs>
	): void;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, MediaSourceStateChangedEventArgs>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, MediaSourceStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaSource, MediaSourceStateChangedEventArgs>
	): void;
		reset(): void;
		state: Windows.Media.Core.MediaSourceState;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaSourceError  {
		extendedError: WinRTError
	}

	declare class MediaSourceOpenOperationCompletedEventArgs  {
		error: Windows.Media.Core.MediaSourceError
	}

	declare class MediaSourceStateChangedEventArgs  {
		newState: Windows.Media.Core.MediaSourceState;
		oldState: Windows.Media.Core.MediaSourceState
	}

	declare class MediaStreamSample  {
		createFromBuffer(
		buffer: Windows.Storage.Streams.IBuffer, timestamp: number
	): Windows.Media.Core.MediaStreamSample;
		createFromStreamAsync(
		stream: Windows.Storage.Streams.IInputStream, count: number, timestamp: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Core.MediaStreamSample>;
		buffer: Windows.Storage.Streams.Buffer;
		decodeTimestamp: number;
		discontinuous: boolean;
		duration: number;
		extendedProperties: Windows.Media.Core.MediaStreamSamplePropertySet;
		keyFrame: boolean;
		onprocessed: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSample, any>;
		addEventListener(
		type: "processed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSample, any>
	): void;
		removeEventListener(
		type: "processed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSample, any>
	): void;
		protection: Windows.Media.Core.MediaStreamSampleProtectionProperties;
		timestamp: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaStreamSamplePropertySet  {
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		remove(key: string): void;
		size: number
	}

	declare class MediaStreamSampleProtectionProperties  {
		getInitializationVector(): number[];
		getKeyIdentifier(): number[];
		getSubSampleMapping(): number[];
		setInitializationVector(value: number[]): void;
		setKeyIdentifier(value: number[]): void;
		setSubSampleMapping(value: number[]): void
	}

	declare class MediaStreamSource  {
		constructor(descriptor: Windows.Media.Core.IMediaStreamDescriptor): this;
		constructor(descriptor: Windows.Media.Core.IMediaStreamDescriptor, descriptor2: Windows.Media.Core.IMediaStreamDescriptor): this;
		addProtectionKey(
		streamDescriptor: Windows.Media.Core.IMediaStreamDescriptor, keyIdentifier: number[], licenseData: number[]
	): void;
		addStreamDescriptor(descriptor: Windows.Media.Core.IMediaStreamDescriptor): void;
		bufferTime: number;
		canSeek: boolean;
		duration: number;
		mediaProtectionManager: Windows.Media.Protection.MediaProtectionManager;
		musicProperties: Windows.Storage.FileProperties.MusicProperties;
		notifyError(errorStatus: Windows.Media.Core.MediaStreamSourceErrorStatus): void;
		onclosed: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceClosedEventArgs>;
		addEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceClosedEventArgs>
	): void;
		removeEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceClosedEventArgs>
	): void;
		onpaused: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, any>;
		addEventListener(
		type: "paused", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, any>
	): void;
		removeEventListener(
		type: "paused", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, any>
	): void;
		onsamplerequested: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs>;
		addEventListener(
		type: "samplerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs>
	): void;
		removeEventListener(
		type: "samplerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSampleRequestedEventArgs>
	): void;
		onstarting: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceStartingEventArgs>;
		addEventListener(
		type: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceStartingEventArgs>
	): void;
		removeEventListener(
		type: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceStartingEventArgs>
	): void;
		onswitchstreamsrequested: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs>;
		addEventListener(
		type: "switchstreamsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "switchstreamsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.MediaStreamSource, Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestedEventArgs>
	): void;
		setBufferedRange(startOffset: number, endOffset: number): void;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		videoProperties: Windows.Storage.FileProperties.VideoProperties;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaStreamSourceClosedEventArgs  {
		request: Windows.Media.Core.MediaStreamSourceClosedRequest
	}

	declare class MediaStreamSourceClosedRequest  {
		reason: Windows.Media.Core.MediaStreamSourceClosedReason
	}

	declare class MediaStreamSourceSampleRequest  {
		getDeferral(): Windows.Media.Core.MediaStreamSourceSampleRequestDeferral;
		reportSampleProgress(progress: number): void;
		sample: Windows.Media.Core.MediaStreamSample;
		streamDescriptor: Windows.Media.Core.IMediaStreamDescriptor
	}

	declare class MediaStreamSourceSampleRequestDeferral  {
		complete(): void
	}

	declare class MediaStreamSourceSampleRequestedEventArgs  {
		request: Windows.Media.Core.MediaStreamSourceSampleRequest
	}

	declare class MediaStreamSourceStartingEventArgs  {
		request: Windows.Media.Core.MediaStreamSourceStartingRequest
	}

	declare class MediaStreamSourceStartingRequest  {
		getDeferral(): Windows.Media.Core.MediaStreamSourceStartingRequestDeferral;
		setActualStartPosition(position: number): void;
		startPosition: number
	}

	declare class MediaStreamSourceStartingRequestDeferral  {
		complete(): void
	}

	declare class MediaStreamSourceSwitchStreamsRequest  {
		getDeferral(): Windows.Media.Core.MediaStreamSourceSwitchStreamsRequestDeferral;
		newStreamDescriptor: Windows.Media.Core.IMediaStreamDescriptor;
		oldStreamDescriptor: Windows.Media.Core.IMediaStreamDescriptor
	}

	declare class MediaStreamSourceSwitchStreamsRequestDeferral  {
		complete(): void
	}

	declare class MediaStreamSourceSwitchStreamsRequestedEventArgs  {
		request: Windows.Media.Core.MediaStreamSourceSwitchStreamsRequest
	}

	declare class SceneAnalysisEffect  {
		desiredAnalysisInterval: number;
		highDynamicRangeAnalyzer: Windows.Media.Core.HighDynamicRangeControl;
		onsceneanalyzed: Windows.Foundation.TypedEventHandler<Windows.Media.Core.SceneAnalysisEffect, Windows.Media.Core.SceneAnalyzedEventArgs>;
		addEventListener(
		type: "sceneanalyzed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.SceneAnalysisEffect, Windows.Media.Core.SceneAnalyzedEventArgs>
	): void;
		removeEventListener(
		type: "sceneanalyzed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.SceneAnalysisEffect, Windows.Media.Core.SceneAnalyzedEventArgs>
	): void;
		setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SceneAnalysisEffectDefinition  {
		constructor(): this;
		activatableClassId: string;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class SceneAnalysisEffectFrame  {
		close(): void;
		duration: number;
		extendedProperties: Windows.Foundation.Collections.IPropertySet;
		frameControlValues: Windows.Media.Capture.CapturedFrameControlValues;
		highDynamicRange: Windows.Media.Core.HighDynamicRangeOutput;
		isDiscontinuous: boolean;
		isReadOnly: boolean;
		relativeTime: number;
		systemRelativeTime: number;
		type: string
	}

	declare class SceneAnalyzedEventArgs  {
		resultFrame: Windows.Media.Core.SceneAnalysisEffectFrame
	}

	declare class TimedMetadataTrack  {
		constructor(id: string, language: string, kind: Windows.Media.Core.TimedMetadataKind): this;
		activeCues: Windows.Foundation.Collections.IVectorView<Windows.Media.Core.IMediaCue>;
		addCue(cue: Windows.Media.Core.IMediaCue): void;
		cues: Windows.Foundation.Collections.IVectorView<Windows.Media.Core.IMediaCue>;
		dispatchType: string;
		id: string;
		label: string;
		language: string;
		oncueentered: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>;
		addEventListener(
		type: "cueentered", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>
	): void;
		removeEventListener(
		type: "cueentered", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>
	): void;
		oncueexited: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>;
		addEventListener(
		type: "cueexited", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>
	): void;
		removeEventListener(
		type: "cueexited", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.MediaCueEventArgs>
	): void;
		ontrackfailed: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.TimedMetadataTrackFailedEventArgs>;
		addEventListener(
		type: "trackfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.TimedMetadataTrackFailedEventArgs>
	): void;
		removeEventListener(
		type: "trackfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedMetadataTrack, Windows.Media.Core.TimedMetadataTrackFailedEventArgs>
	): void;
		removeCue(cue: Windows.Media.Core.IMediaCue): void;
		timedMetadataKind: Windows.Media.Core.TimedMetadataKind;
		trackKind: Windows.Media.Core.MediaTrackKind;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class TimedMetadataTrackError  {
		errorCode: Windows.Media.Core.TimedMetadataTrackErrorCode;
		extendedError: WinRTError
	}

	declare class TimedMetadataTrackFailedEventArgs  {
		error: Windows.Media.Core.TimedMetadataTrackError
	}

	declare class TimedTextCue  {
		constructor(): this;
		cueRegion: Windows.Media.Core.TimedTextRegion;
		cueStyle: Windows.Media.Core.TimedTextStyle;
		duration: number;
		id: string;
		lines: Windows.Foundation.Collections.IVector<Windows.Media.Core.TimedTextLine>;
		startTime: number
	}

	declare class TimedTextLine  {
		constructor(): this;
		subformats: Windows.Foundation.Collections.IVector<Windows.Media.Core.TimedTextSubformat>;
		text: string
	}

	declare class TimedTextRegion  {
		constructor(): this;
		background: Windows.UI.Color;
		displayAlignment: Windows.Media.Core.TimedTextDisplayAlignment;
		extent: Windows.Media.Core.TimedTextSize;
		isOverflowClipped: boolean;
		lineHeight: Windows.Media.Core.TimedTextDouble;
		name: string;
		padding: Windows.Media.Core.TimedTextPadding;
		position: Windows.Media.Core.TimedTextPoint;
		scrollMode: Windows.Media.Core.TimedTextScrollMode;
		textWrapping: Windows.Media.Core.TimedTextWrapping;
		writingMode: Windows.Media.Core.TimedTextWritingMode;
		zindex: number
	}

	declare class TimedTextSource  {
		createFromStream(
		stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Media.Core.TimedTextSource;
		createFromStream(
		stream: Windows.Storage.Streams.IRandomAccessStream, defaultLanguage: string
	): Windows.Media.Core.TimedTextSource;
		createFromUri(uri: Windows.Foundation.Uri): Windows.Media.Core.TimedTextSource;
		createFromUri(
		uri: Windows.Foundation.Uri, defaultLanguage: string
	): Windows.Media.Core.TimedTextSource;
		onresolved: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedTextSource, Windows.Media.Core.TimedTextSourceResolveResultEventArgs>;
		addEventListener(
		type: "resolved", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedTextSource, Windows.Media.Core.TimedTextSourceResolveResultEventArgs>
	): void;
		removeEventListener(
		type: "resolved", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.TimedTextSource, Windows.Media.Core.TimedTextSourceResolveResultEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class TimedTextSourceResolveResultEventArgs  {
		error: Windows.Media.Core.TimedMetadataTrackError;
		tracks: Windows.Foundation.Collections.IVectorView<Windows.Media.Core.TimedMetadataTrack>
	}

	declare class TimedTextStyle  {
		constructor(): this;
		background: Windows.UI.Color;
		flowDirection: Windows.Media.Core.TimedTextFlowDirection;
		fontFamily: string;
		fontSize: Windows.Media.Core.TimedTextDouble;
		fontWeight: Windows.Media.Core.TimedTextWeight;
		foreground: Windows.UI.Color;
		isBackgroundAlwaysShown: boolean;
		lineAlignment: Windows.Media.Core.TimedTextLineAlignment;
		name: string;
		outlineColor: Windows.UI.Color;
		outlineRadius: Windows.Media.Core.TimedTextDouble;
		outlineThickness: Windows.Media.Core.TimedTextDouble
	}

	declare class TimedTextSubformat  {
		constructor(): this;
		length: number;
		startIndex: number;
		subformatStyle: Windows.Media.Core.TimedTextStyle
	}

	declare class VideoStabilizationEffect  {
		enabled: boolean;
		getRecommendedStreamConfiguration(
		controller: Windows.Media.Devices.VideoDeviceController, desiredProperties: Windows.Media.MediaProperties.VideoEncodingProperties
	): Windows.Media.Capture.VideoStreamConfiguration;
		onenabledchanged: Windows.Foundation.TypedEventHandler<Windows.Media.Core.VideoStabilizationEffect, Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs>;
		addEventListener(
		type: "enabledchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.VideoStabilizationEffect, Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs>
	): void;
		removeEventListener(
		type: "enabledchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.VideoStabilizationEffect, Windows.Media.Core.VideoStabilizationEffectEnabledChangedEventArgs>
	): void;
		setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class VideoStabilizationEffectDefinition  {
		constructor(): this;
		activatableClassId: string;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class VideoStabilizationEffectEnabledChangedEventArgs  {
		reason: Windows.Media.Core.VideoStabilizationEffectEnabledChangedReason
	}

	declare class VideoStreamDescriptor  {
		constructor(encodingProperties: Windows.Media.MediaProperties.VideoEncodingProperties): this;
		encodingProperties: Windows.Media.MediaProperties.VideoEncodingProperties;
		isSelected: boolean;
		language: string;
		name: string
	}

	declare class VideoTrack  {
		id: string;
		label: string;
		language: string;
		trackKind: Windows.Media.Core.MediaTrackKind
	}

	declare class CameraIntrinsics  {
		constructor(focalLength: Windows.Foundation.Numerics.Vector2, principalPoint: Windows.Foundation.Numerics.Vector2, radialDistortion: Windows.Foundation.Numerics.Vector3, tangentialDistortion: Windows.Foundation.Numerics.Vector2, imageWidth: number, imageHeight: number): this;
		focalLength: Windows.Foundation.Numerics.Vector2;
		imageHeight: number;
		imageWidth: number;
		principalPoint: Windows.Foundation.Numerics.Vector2;
		projectManyOntoFrame(coordinates: Windows.Foundation.Numerics.Vector3): Windows.Foundation.Point;
		projectOntoFrame(coordinate: Windows.Foundation.Numerics.Vector3): Windows.Foundation.Point;
		radialDistortion: Windows.Foundation.Numerics.Vector3;
		tangentialDistortion: Windows.Foundation.Numerics.Vector2;
		unprojectAtUnitDepth(pixelCoordinate: Windows.Foundation.Point): Windows.Foundation.Numerics.Vector2;
		unprojectPixelsAtUnitDepth(
		pixelCoordinates: Windows.Foundation.Point
	): Windows.Foundation.Numerics.Vector2
	}

	declare class FrameControlCapabilities  {
		exposure: Windows.Media.Devices.Core.FrameExposureCapabilities;
		exposureCompensation: Windows.Media.Devices.Core.FrameExposureCompensationCapabilities;
		flash: Windows.Media.Devices.Core.FrameFlashCapabilities;
		focus: Windows.Media.Devices.Core.FrameFocusCapabilities;
		isoSpeed: Windows.Media.Devices.Core.FrameIsoSpeedCapabilities;
		photoConfirmationSupported: boolean
	}

	declare class FrameController  {
		constructor(): this;
		exposureCompensationControl: Windows.Media.Devices.Core.FrameExposureCompensationControl;
		exposureControl: Windows.Media.Devices.Core.FrameExposureControl;
		flashControl: Windows.Media.Devices.Core.FrameFlashControl;
		focusControl: Windows.Media.Devices.Core.FrameFocusControl;
		isoSpeedControl: Windows.Media.Devices.Core.FrameIsoSpeedControl;
		photoConfirmationEnabled: boolean
	}

	declare class FrameExposureCapabilities  {
		max: number;
		min: number;
		step: number;
		supported: boolean
	}

	declare class FrameExposureCompensationCapabilities  {
		max: number;
		min: number;
		step: number;
		supported: boolean
	}

	declare class FrameExposureCompensationControl  {
		value: number
	}

	declare class FrameExposureControl  {
		auto: boolean;
		value: number
	}

	declare class FrameFlashCapabilities  {
		powerSupported: boolean;
		redEyeReductionSupported: boolean;
		supported: boolean
	}

	declare class FrameFlashControl  {
		auto: boolean;
		mode: Windows.Media.Devices.Core.FrameFlashMode;
		powerPercent: number;
		redEyeReduction: boolean
	}

	declare class FrameFocusCapabilities  {
		max: number;
		min: number;
		step: number;
		supported: boolean
	}

	declare class FrameFocusControl  {
		value: number
	}

	declare class FrameIsoSpeedCapabilities  {
		max: number;
		min: number;
		step: number;
		supported: boolean
	}

	declare class FrameIsoSpeedControl  {
		auto: boolean;
		value: number
	}

	declare class VariablePhotoSequenceController  {
		desiredFrameControllers: Windows.Foundation.Collections.IVector<Windows.Media.Devices.Core.FrameController>;
		frameCapabilities: Windows.Media.Devices.Core.FrameControlCapabilities;
		getCurrentFrameRate(): Windows.Media.MediaProperties.MediaRatio;
		getHighestConcurrentFrameRate(
		captureProperties: Windows.Media.MediaProperties.IMediaEncodingProperties
	): Windows.Media.MediaProperties.MediaRatio;
		maxPhotosPerSecond: number;
		photosPerSecondLimit: number;
		supported: boolean
	}

	declare class WebAuthenticationCoreManager  {
		findAccountAsync(
		provider: Windows.Security.Credentials.WebAccountProvider, webAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccount>;
		findAccountProviderAsync(
		webAccountProviderId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccountProvider>;
		findAccountProviderAsync(
		webAccountProviderId: string, authority: string, user: Windows.System.User
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccountProvider>;
		findAccountProviderAsync(
		webAccountProviderId: string, authority: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccountProvider>;
		getTokenSilentlyAsync(
		request: Windows.Security.Authentication.Web.Core.WebTokenRequest
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.Core.WebTokenRequestResult>;
		getTokenSilentlyAsync(
		request: Windows.Security.Authentication.Web.Core.WebTokenRequest, webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.Core.WebTokenRequestResult>;
		requestTokenAsync(
		request: Windows.Security.Authentication.Web.Core.WebTokenRequest
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.Core.WebTokenRequestResult>;
		requestTokenAsync(
		request: Windows.Security.Authentication.Web.Core.WebTokenRequest, webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.Core.WebTokenRequestResult>
	}

	declare class WebProviderError  {
		constructor(errorCode: number, errorMessage: string): this;
		errorCode: number;
		errorMessage: string;
		properties: Windows.Foundation.Collections.IMap<string, string>
	}

	declare class WebTokenRequest  {
		constructor(provider: Windows.Security.Credentials.WebAccountProvider, scope: string): this;
		constructor(provider: Windows.Security.Credentials.WebAccountProvider, scope: string, clientId: string, promptType: Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType): this;
		constructor(provider: Windows.Security.Credentials.WebAccountProvider): this;
		constructor(provider: Windows.Security.Credentials.WebAccountProvider, scope: string, clientId: string): this;
		appProperties: any;
		clientId: string;
		promptType: Windows.Security.Authentication.Web.Core.WebTokenRequestPromptType;
		properties: Windows.Foundation.Collections.IMap<string, string>;
		scope: string;
		webAccountProvider: Windows.Security.Credentials.WebAccountProvider
	}

	declare class WebTokenRequestResult  {
		invalidateCacheAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		responseData: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.Web.Core.WebTokenResponse>;
		responseError: Windows.Security.Authentication.Web.Core.WebProviderError;
		responseStatus: Windows.Security.Authentication.Web.Core.WebTokenRequestStatus
	}

	declare class WebTokenResponse  {
		constructor(): this;
		constructor(token: string, webAccount: Windows.Security.Credentials.WebAccount): this;
		constructor(token: string, webAccount: Windows.Security.Credentials.WebAccount, error: Windows.Security.Authentication.Web.Core.WebProviderError): this;
		constructor(token: string): this;
		properties: Windows.Foundation.Collections.IMap<string, string>;
		providerError: Windows.Security.Authentication.Web.Core.WebProviderError;
		token: string;
		webAccount: Windows.Security.Credentials.WebAccount
	}

	declare class AsymmetricAlgorithmNames  {
		dsaSha1: string;
		dsaSha256: string;
		ecdsaP256Sha256: string;
		ecdsaP384Sha384: string;
		ecdsaP521Sha512: string;
		ecdsaSha256: string;
		ecdsaSha384: string;
		ecdsaSha512: string;
		rsaOaepSha1: string;
		rsaOaepSha256: string;
		rsaOaepSha384: string;
		rsaOaepSha512: string;
		rsaPkcs1: string;
		rsaSignPkcs1Sha1: string;
		rsaSignPkcs1Sha256: string;
		rsaSignPkcs1Sha384: string;
		rsaSignPkcs1Sha512: string;
		rsaSignPssSha1: string;
		rsaSignPssSha256: string;
		rsaSignPssSha384: string;
		rsaSignPssSha512: string
	}

	declare class AsymmetricKeyAlgorithmProvider  {
		openAlgorithm(
		algorithm: string
	): Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider;
		algorithmName: string;
		createKeyPair(keySize: number): Windows.Security.Cryptography.Core.CryptographicKey;
		createKeyPairWithCurveName(curveName: string): Windows.Security.Cryptography.Core.CryptographicKey;
		createKeyPairWithCurveParameters(parameters: number[]): Windows.Security.Cryptography.Core.CryptographicKey;
		importKeyPair(
		keyBlob: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicKey;
		importKeyPair(
		keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType
	): Windows.Security.Cryptography.Core.CryptographicKey;
		importPublicKey(
		keyBlob: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicKey;
		importPublicKey(
		keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType
	): Windows.Security.Cryptography.Core.CryptographicKey
	}

	declare class CryptographicEngine  {
		decrypt(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer
	): Windows.Storage.Streams.IBuffer;
		decryptAndAuthenticate(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticationTag: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer
	): Windows.Storage.Streams.IBuffer;
		decryptAsync(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		deriveKeyMaterial(
		key: Windows.Security.Cryptography.Core.CryptographicKey, parameters: Windows.Security.Cryptography.Core.KeyDerivationParameters, desiredKeySize: number
	): Windows.Storage.Streams.IBuffer;
		encrypt(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer
	): Windows.Storage.Streams.IBuffer;
		encryptAndAuthenticate(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData;
		sign(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer
	): Windows.Storage.Streams.IBuffer;
		signAsync(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		signHashedData(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer
	): Windows.Storage.Streams.IBuffer;
		signHashedDataAsync(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		verifySignature(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, signature: Windows.Storage.Streams.IBuffer
	): boolean;
		verifySignatureWithHashInput(
		key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, signature: Windows.Storage.Streams.IBuffer
	): boolean
	}

	declare class CryptographicHash  {
		append(data: Windows.Storage.Streams.IBuffer): void;
		getValueAndReset(): Windows.Storage.Streams.IBuffer
	}

	declare class CryptographicKey  {
		export(): Windows.Storage.Streams.IBuffer;
		export(
		BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType
	): Windows.Storage.Streams.IBuffer;
		exportPublicKey(): Windows.Storage.Streams.IBuffer;
		exportPublicKey(
		BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType
	): Windows.Storage.Streams.IBuffer;
		keySize: number
	}

	declare class EccCurveNames  {
		allEccCurveNames: Windows.Foundation.Collections.IVectorView<string>;
		brainpoolP160r1: string;
		brainpoolP160t1: string;
		brainpoolP192r1: string;
		brainpoolP192t1: string;
		brainpoolP224r1: string;
		brainpoolP224t1: string;
		brainpoolP256r1: string;
		brainpoolP256t1: string;
		brainpoolP320r1: string;
		brainpoolP320t1: string;
		brainpoolP384r1: string;
		brainpoolP384t1: string;
		brainpoolP512r1: string;
		brainpoolP512t1: string;
		curve25519: string;
		ec192wapi: string;
		nistP192: string;
		nistP224: string;
		nistP256: string;
		nistP384: string;
		nistP521: string;
		numsP256t1: string;
		numsP384t1: string;
		numsP512t1: string;
		secP160k1: string;
		secP160r1: string;
		secP160r2: string;
		secP192k1: string;
		secP192r1: string;
		secP224k1: string;
		secP224r1: string;
		secP256k1: string;
		secP256r1: string;
		secP384r1: string;
		secP521r1: string;
		wtls12: string;
		wtls7: string;
		wtls9: string;
		x962P192v1: string;
		x962P192v2: string;
		x962P192v3: string;
		x962P239v1: string;
		x962P239v2: string;
		x962P239v3: string;
		x962P256v1: string
	}

	declare class EncryptedAndAuthenticatedData  {
		authenticationTag: Windows.Storage.Streams.IBuffer;
		encryptedData: Windows.Storage.Streams.IBuffer
	}

	declare class HashAlgorithmNames  {
		md5: string;
		sha1: string;
		sha256: string;
		sha384: string;
		sha512: string
	}

	declare class HashAlgorithmProvider  {
		openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.HashAlgorithmProvider;
		algorithmName: string;
		createHash(): Windows.Security.Cryptography.Core.CryptographicHash;
		hashData(data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
		hashLength: number
	}

	declare class KeyDerivationAlgorithmNames  {
		capiKdfMd5: string;
		capiKdfSha1: string;
		capiKdfSha256: string;
		capiKdfSha384: string;
		capiKdfSha512: string;
		pbkdf2Md5: string;
		pbkdf2Sha1: string;
		pbkdf2Sha256: string;
		pbkdf2Sha384: string;
		pbkdf2Sha512: string;
		sp800108CtrHmacMd5: string;
		sp800108CtrHmacSha1: string;
		sp800108CtrHmacSha256: string;
		sp800108CtrHmacSha384: string;
		sp800108CtrHmacSha512: string;
		sp80056aConcatMd5: string;
		sp80056aConcatSha1: string;
		sp80056aConcatSha256: string;
		sp80056aConcatSha384: string;
		sp80056aConcatSha512: string
	}

	declare class KeyDerivationAlgorithmProvider  {
		openAlgorithm(
		algorithm: string
	): Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider;
		algorithmName: string;
		createKey(
		keyMaterial: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicKey
	}

	declare class KeyDerivationParameters  {
		buildForCapi1Kdf(
		capi1KdfTargetAlgorithm: Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm
	): Windows.Security.Cryptography.Core.KeyDerivationParameters;
		buildForPbkdf2(
		pbkdf2Salt: Windows.Storage.Streams.IBuffer, iterationCount: number
	): Windows.Security.Cryptography.Core.KeyDerivationParameters;
		buildForSP800108(
		label: Windows.Storage.Streams.IBuffer, context: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.KeyDerivationParameters;
		buildForSP80056a(
		algorithmId: Windows.Storage.Streams.IBuffer, partyUInfo: Windows.Storage.Streams.IBuffer, partyVInfo: Windows.Storage.Streams.IBuffer, suppPubInfo: Windows.Storage.Streams.IBuffer, suppPrivInfo: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.KeyDerivationParameters;
		capi1KdfTargetAlgorithm: Windows.Security.Cryptography.Core.Capi1KdfTargetAlgorithm;
		iterationCount: number;
		kdfGenericBinary: Windows.Storage.Streams.IBuffer
	}

	declare class MacAlgorithmNames  {
		aesCmac: string;
		hmacMd5: string;
		hmacSha1: string;
		hmacSha256: string;
		hmacSha384: string;
		hmacSha512: string
	}

	declare class MacAlgorithmProvider  {
		openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.MacAlgorithmProvider;
		algorithmName: string;
		createHash(
		keyMaterial: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicHash;
		createKey(
		keyMaterial: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicKey;
		macLength: number
	}

	declare class PersistedKeyProvider  {
		openKeyPairFromCertificateAsync(
		certificate: Windows.Security.Cryptography.Certificates.Certificate, hashAlgorithmName: string, padding: Windows.Security.Cryptography.Core.CryptographicPadding
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Cryptography.Core.CryptographicKey>;
		openPublicKeyFromCertificate(
		certificate: Windows.Security.Cryptography.Certificates.Certificate, hashAlgorithmName: string, padding: Windows.Security.Cryptography.Core.CryptographicPadding
	): Windows.Security.Cryptography.Core.CryptographicKey
	}

	declare class SymmetricAlgorithmNames  {
		aesCbc: string;
		aesCbcPkcs7: string;
		aesCcm: string;
		aesEcb: string;
		aesEcbPkcs7: string;
		aesGcm: string;
		desCbc: string;
		desCbcPkcs7: string;
		desEcb: string;
		desEcbPkcs7: string;
		rc2Cbc: string;
		rc2CbcPkcs7: string;
		rc2Ecb: string;
		rc2EcbPkcs7: string;
		rc4: string;
		tripleDesCbc: string;
		tripleDesCbcPkcs7: string;
		tripleDesEcb: string;
		tripleDesEcbPkcs7: string
	}

	declare class SymmetricKeyAlgorithmProvider  {
		openAlgorithm(
		algorithm: string
	): Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider;
		algorithmName: string;
		blockLength: number;
		createSymmetricKey(
		keyMaterial: Windows.Storage.Streams.IBuffer
	): Windows.Security.Cryptography.Core.CryptographicKey
	}

	declare class BackRequestedEventArgs  {
		handled: boolean
	}

	declare class SystemNavigationManager  {
		getForCurrentView(): Windows.UI.Core.SystemNavigationManager;
		appViewBackButtonVisibility: Windows.UI.Core.AppViewBackButtonVisibility;
		onbackrequested: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "backrequested", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "backrequested", listener: Windows.Foundation.EventHandler<any>): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CoreTextCompositionCompletedEventArgs  {
		compositionSegments: Windows.Foundation.Collections.IVectorView<Windows.UI.Text.Core.CoreTextCompositionSegment>;
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean
	}

	declare class CoreTextCompositionSegment  {
		preconversionString: string;
		range: Windows.UI.Text.Core.CoreTextRange
	}

	declare class CoreTextCompositionStartedEventArgs  {
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean
	}

	declare class CoreTextEditContext  {
		inputPaneDisplayPolicy: Windows.UI.Text.Core.CoreTextInputPaneDisplayPolicy;
		inputScope: Windows.UI.Text.Core.CoreTextInputScope;
		isReadOnly: boolean;
		name: string;
		notifyFocusEnter(): void;
		notifyFocusLeave(): void;
		notifyLayoutChanged(): void;
		notifySelectionChanged(selection: Windows.UI.Text.Core.CoreTextRange): void;
		notifyTextChanged(
		modifiedRange: Windows.UI.Text.Core.CoreTextRange, newLength: number, newSelection: Windows.UI.Text.Core.CoreTextRange
	): void;
		oncompositioncompleted: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs>;
		addEventListener(
		type: "compositioncompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs>
	): void;
		removeEventListener(
		type: "compositioncompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionCompletedEventArgs>
	): void;
		oncompositionstarted: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs>;
		addEventListener(
		type: "compositionstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs>
	): void;
		removeEventListener(
		type: "compositionstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextCompositionStartedEventArgs>
	): void;
		onfocusremoved: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>;
		addEventListener(
		type: "focusremoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>
	): void;
		removeEventListener(
		type: "focusremoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>
	): void;
		onformatupdating: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs>;
		addEventListener(
		type: "formatupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs>
	): void;
		removeEventListener(
		type: "formatupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextFormatUpdatingEventArgs>
	): void;
		onlayoutrequested: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs>;
		addEventListener(
		type: "layoutrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs>
	): void;
		removeEventListener(
		type: "layoutrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextLayoutRequestedEventArgs>
	): void;
		onnotifyfocusleavecompleted: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>;
		addEventListener(
		type: "notifyfocusleavecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>
	): void;
		removeEventListener(
		type: "notifyfocusleavecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, any>
	): void;
		onselectionrequested: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs>;
		addEventListener(
		type: "selectionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs>
	): void;
		removeEventListener(
		type: "selectionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionRequestedEventArgs>
	): void;
		onselectionupdating: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs>;
		addEventListener(
		type: "selectionupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs>
	): void;
		removeEventListener(
		type: "selectionupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextSelectionUpdatingEventArgs>
	): void;
		ontextrequested: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextRequestedEventArgs>;
		addEventListener(
		type: "textrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextRequestedEventArgs>
	): void;
		removeEventListener(
		type: "textrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextRequestedEventArgs>
	): void;
		ontextupdating: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs>;
		addEventListener(
		type: "textupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs>
	): void;
		removeEventListener(
		type: "textupdating", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextEditContext, Windows.UI.Text.Core.CoreTextTextUpdatingEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CoreTextFormatUpdatingEventArgs  {
		backgroundColor: Windows.UI.ViewManagement.UIElementType;
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean;
		range: Windows.UI.Text.Core.CoreTextRange;
		reason: Windows.UI.Text.Core.CoreTextFormatUpdatingReason;
		result: Windows.UI.Text.Core.CoreTextFormatUpdatingResult;
		textColor: Windows.UI.ViewManagement.UIElementType;
		underlineColor: Windows.UI.ViewManagement.UIElementType;
		underlineType: Windows.UI.Text.UnderlineType
	}

	declare class CoreTextLayoutBounds  {
		controlBounds: Windows.Foundation.Rect;
		textBounds: Windows.Foundation.Rect
	}

	declare class CoreTextLayoutRequest  {
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean;
		layoutBounds: Windows.UI.Text.Core.CoreTextLayoutBounds;
		range: Windows.UI.Text.Core.CoreTextRange
	}

	declare class CoreTextLayoutRequestedEventArgs  {
		request: Windows.UI.Text.Core.CoreTextLayoutRequest
	}

	declare class CoreTextSelectionRequest  {
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean;
		selection: Windows.UI.Text.Core.CoreTextRange
	}

	declare class CoreTextSelectionRequestedEventArgs  {
		request: Windows.UI.Text.Core.CoreTextSelectionRequest
	}

	declare class CoreTextSelectionUpdatingEventArgs  {
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean;
		result: Windows.UI.Text.Core.CoreTextSelectionUpdatingResult;
		selection: Windows.UI.Text.Core.CoreTextRange
	}

	declare class CoreTextServicesConstants  {
		hiddenCharacter: string
	}

	declare class CoreTextServicesManager  {
		getForCurrentView(): Windows.UI.Text.Core.CoreTextServicesManager;
		createEditContext(): Windows.UI.Text.Core.CoreTextEditContext;
		inputLanguage: Windows.Globalization.Language;
		oninputlanguagechanged: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextServicesManager, any>;
		addEventListener(
		type: "inputlanguagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextServicesManager, any>
	): void;
		removeEventListener(
		type: "inputlanguagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Text.Core.CoreTextServicesManager, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CoreTextTextRequest  {
		getDeferral(): Windows.Foundation.Deferral;
		isCanceled: boolean;
		range: Windows.UI.Text.Core.CoreTextRange;
		text: string
	}

	declare class CoreTextTextRequestedEventArgs  {
		request: Windows.UI.Text.Core.CoreTextTextRequest
	}

	declare class CoreTextTextUpdatingEventArgs  {
		getDeferral(): Windows.Foundation.Deferral;
		inputLanguage: Windows.Globalization.Language;
		isCanceled: boolean;
		newSelection: Windows.UI.Text.Core.CoreTextRange;
		range: Windows.UI.Text.Core.CoreTextRange;
		result: Windows.UI.Text.Core.CoreTextTextUpdatingResult;
		text: string
	}

	
}

declare module 'Sockets' {
		declare interface IWebSocket {
		close(): void
	}

	declare interface IWebSocket {
		close(code: number, reason: string): void,
		connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IPromiseWithIAsyncAction,
		setRequestHeader(headerName: string, headerValue: string): void,
		outputStream: Windows.Storage.Streams.IOutputStream
	}

	declare interface BandwidthStatistics {
		
	}

	declare interface RoundTripTimeStatistics {
		
	}

		declare class DatagramSocket  {
		getEndpointPairsAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string, sortOptions: Windows.Networking.HostNameSortOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getEndpointPairsAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		constructor(): this;
		bindEndpointAsync(
		localHostName: Windows.Networking.HostName, localServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		bindServiceNameAsync(localServiceName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		bindServiceNameAsync(
		localServiceName: string, adapter: Windows.Networking.Connectivity.NetworkAdapter
	): Windows.Foundation.IPromiseWithIAsyncAction;
		cancelIOAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		close(): void;
		connectAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		connectAsync(
		endpointPair: Windows.Networking.EndpointPair
	): Windows.Foundation.IPromiseWithIAsyncAction;
		control: Windows.Networking.Sockets.DatagramSocketControl;
		enableTransferOwnership(taskId: string): void;
		enableTransferOwnership(
		taskId: string, connectedStandbyAction: Windows.Networking.Sockets.SocketActivityConnectedStandbyAction
	): void;
		getOutputStreamAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IOutputStream>;
		getOutputStreamAsync(
		endpointPair: Windows.Networking.EndpointPair
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IOutputStream>;
		information: Windows.Networking.Sockets.DatagramSocketInformation;
		joinMulticastGroup(host: Windows.Networking.HostName): void;
		onmessagereceived: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket, Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>;
		addEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket, Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>
	): void;
		removeEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket, Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>
	): void;
		outputStream: Windows.Storage.Streams.IOutputStream;
		transferOwnership(socketId: string): void;
		transferOwnership(socketId: string, data: Windows.Networking.Sockets.SocketActivityContext): void;
		transferOwnership(
		socketId: string, data: Windows.Networking.Sockets.SocketActivityContext, keepAliveTime: number
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DatagramSocketControl  {
		dontFragment: boolean;
		inboundBufferSizeInBytes: number;
		multicastOnly: boolean;
		outboundUnicastHopLimit: number;
		qualityOfService: Windows.Networking.Sockets.SocketQualityOfService
	}

	declare class DatagramSocketInformation  {
		localAddress: Windows.Networking.HostName;
		localPort: string;
		remoteAddress: Windows.Networking.HostName;
		remotePort: string
	}

	declare class DatagramSocketMessageReceivedEventArgs  {
		getDataReader(): Windows.Storage.Streams.DataReader;
		getDataStream(): Windows.Storage.Streams.IInputStream;
		localAddress: Windows.Networking.HostName;
		remoteAddress: Windows.Networking.HostName;
		remotePort: string
	}

	declare class MessageWebSocket  {
		constructor(): this;
		close(): void;
		close(code: number, reason: string): void;
		connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IPromiseWithIAsyncAction;
		control: Windows.Networking.Sockets.MessageWebSocketControl;
		information: Windows.Networking.Sockets.MessageWebSocketInformation;
		onclosed: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>;
		addEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>
	): void;
		removeEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>
	): void;
		onmessagereceived: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket, Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>;
		addEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket, Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>
	): void;
		removeEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket, Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>
	): void;
		outputStream: Windows.Storage.Streams.IOutputStream;
		setRequestHeader(headerName: string, headerValue: string): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MessageWebSocketControl  {
		maxMessageSize: number;
		messageType: Windows.Networking.Sockets.SocketMessageType;
		outboundBufferSizeInBytes: number;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		supportedProtocols: Windows.Foundation.Collections.IVector<string>
	}

	declare class MessageWebSocketInformation  {
		bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
		localAddress: Windows.Networking.HostName;
		protocol: string
	}

	declare class MessageWebSocketMessageReceivedEventArgs  {
		getDataReader(): Windows.Storage.Streams.DataReader;
		getDataStream(): Windows.Storage.Streams.IInputStream;
		messageType: Windows.Networking.Sockets.SocketMessageType
	}

	declare class SocketActivityContext  {
		constructor(data: Windows.Storage.Streams.IBuffer): this;
		data: Windows.Storage.Streams.IBuffer
	}

	declare class SocketActivityInformation  {
		allSockets: Windows.Foundation.Collections.IMapView<string, Windows.Networking.Sockets.SocketActivityInformation>;
		context: Windows.Networking.Sockets.SocketActivityContext;
		datagramSocket: Windows.Networking.Sockets.DatagramSocket;
		id: string;
		socketKind: Windows.Networking.Sockets.SocketActivityKind;
		streamSocket: Windows.Networking.Sockets.StreamSocket;
		streamSocketListener: Windows.Networking.Sockets.StreamSocketListener;
		taskId: string
	}

	declare class SocketActivityTriggerDetails  {
		reason: Windows.Networking.Sockets.SocketActivityTriggerReason;
		socketInformation: Windows.Networking.Sockets.SocketActivityInformation
	}

	declare class SocketError  {
		getStatus(hresult: number): Windows.Networking.Sockets.SocketErrorStatus
	}

	declare class StreamSocket  {
		constructor(): this;
		cancelIOAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		close(): void;
		connectAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		connectAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel
	): Windows.Foundation.IPromiseWithIAsyncAction;
		connectAsync(
		endpointPair: Windows.Networking.EndpointPair, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel
	): Windows.Foundation.IPromiseWithIAsyncAction;
		connectAsync(
		endpointPair: Windows.Networking.EndpointPair
	): Windows.Foundation.IPromiseWithIAsyncAction;
		connectAsync(
		remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, adapter: Windows.Networking.Connectivity.NetworkAdapter
	): Windows.Foundation.IPromiseWithIAsyncAction;
		control: Windows.Networking.Sockets.StreamSocketControl;
		enableTransferOwnership(taskId: string): void;
		enableTransferOwnership(
		taskId: string, connectedStandbyAction: Windows.Networking.Sockets.SocketActivityConnectedStandbyAction
	): void;
		information: Windows.Networking.Sockets.StreamSocketInformation;
		inputStream: Windows.Storage.Streams.IInputStream;
		outputStream: Windows.Storage.Streams.IOutputStream;
		transferOwnership(socketId: string): void;
		transferOwnership(socketId: string, data: Windows.Networking.Sockets.SocketActivityContext): void;
		transferOwnership(
		socketId: string, data: Windows.Networking.Sockets.SocketActivityContext, keepAliveTime: number
	): void;
		upgradeToSslAsync(
		protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, validationHostName: Windows.Networking.HostName
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class StreamSocketControl  {
		clientCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		ignorableServerCertificateErrors: Windows.Foundation.Collections.IVector<Windows.Security.Cryptography.Certificates.ChainValidationResult>;
		keepAlive: boolean;
		noDelay: boolean;
		outboundBufferSizeInBytes: number;
		outboundUnicastHopLimit: number;
		qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
		serializeConnectionAttempts: boolean
	}

	declare class StreamSocketInformation  {
		bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
		localAddress: Windows.Networking.HostName;
		localPort: string;
		protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
		remoteAddress: Windows.Networking.HostName;
		remoteHostName: Windows.Networking.HostName;
		remotePort: string;
		remoteServiceName: string;
		roundTripTimeStatistics: Windows.Networking.Sockets.RoundTripTimeStatistics;
		serverCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		serverCertificateErrorSeverity: Windows.Networking.Sockets.SocketSslErrorSeverity;
		serverCertificateErrors: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>;
		serverIntermediateCertificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		sessionKey: Windows.Storage.Streams.IBuffer
	}

	declare class StreamSocketListener  {
		constructor(): this;
		bindEndpointAsync(
		localHostName: Windows.Networking.HostName, localServiceName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		bindServiceNameAsync(localServiceName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		bindServiceNameAsync(
		localServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, adapter: Windows.Networking.Connectivity.NetworkAdapter
	): Windows.Foundation.IPromiseWithIAsyncAction;
		bindServiceNameAsync(
		localServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel
	): Windows.Foundation.IPromiseWithIAsyncAction;
		cancelIOAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		close(): void;
		control: Windows.Networking.Sockets.StreamSocketListenerControl;
		enableTransferOwnership(taskId: string): void;
		enableTransferOwnership(
		taskId: string, connectedStandbyAction: Windows.Networking.Sockets.SocketActivityConnectedStandbyAction
	): void;
		information: Windows.Networking.Sockets.StreamSocketListenerInformation;
		onconnectionreceived: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener, Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>;
		addEventListener(
		type: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener, Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>
	): void;
		removeEventListener(
		type: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener, Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>
	): void;
		transferOwnership(socketId: string): void;
		transferOwnership(socketId: string, data: Windows.Networking.Sockets.SocketActivityContext): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StreamSocketListenerConnectionReceivedEventArgs  {
		socket: Windows.Networking.Sockets.StreamSocket
	}

	declare class StreamSocketListenerControl  {
		keepAlive: boolean;
		noDelay: boolean;
		outboundBufferSizeInBytes: number;
		outboundUnicastHopLimit: number;
		qualityOfService: Windows.Networking.Sockets.SocketQualityOfService
	}

	declare class StreamSocketListenerInformation  {
		localPort: string
	}

	declare class StreamWebSocket  {
		constructor(): this;
		close(): void;
		close(code: number, reason: string): void;
		connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IPromiseWithIAsyncAction;
		control: Windows.Networking.Sockets.StreamWebSocketControl;
		information: Windows.Networking.Sockets.StreamWebSocketInformation;
		inputStream: Windows.Storage.Streams.IInputStream;
		onclosed: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>;
		addEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>
	): void;
		removeEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket, Windows.Networking.Sockets.WebSocketClosedEventArgs>
	): void;
		outputStream: Windows.Storage.Streams.IOutputStream;
		setRequestHeader(headerName: string, headerValue: string): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StreamWebSocketControl  {
		noDelay: boolean;
		outboundBufferSizeInBytes: number;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		supportedProtocols: Windows.Foundation.Collections.IVector<string>
	}

	declare class StreamWebSocketInformation  {
		bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
		localAddress: Windows.Networking.HostName;
		protocol: string
	}

	declare class WebSocketClosedEventArgs  {
		code: number;
		reason: string
	}

	declare class WebSocketError  {
		getStatus(hresult: number): Windows.Web.WebErrorStatus
	}

	
}

declare module 'Activation' {
		declare interface IActivatedEventArgs {
		kind: Windows.ApplicationModel.Activation.ActivationKind,
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState,
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

		declare class AppointmentsProviderAddAppointmentActivatedEventArgs  {
		addAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class AppointmentsProviderRemoveAppointmentActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		removeAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class AppointmentsProviderReplaceAppointmentActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		replaceAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class AppointmentsProviderShowAppointmentDetailsActivatedEventArgs  {
		instanceStartDate: Date;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		localId: string;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		roamingId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class AppointmentsProviderShowTimeFrameActivatedEventArgs  {
		duration: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		timeToShow: Date;
		verb: string
	}

	declare class CachedFileUpdaterActivatedEventArgs  {
		cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class CameraSettingsActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		videoDeviceController: any;
		videoDeviceExtension: any
	}

	declare class ContactCallActivatedEventArgs  {
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class ContactMapActivatedEventArgs  {
		address: Windows.ApplicationModel.Contacts.ContactAddress;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class ContactMessageActivatedEventArgs  {
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class ContactPickerActivatedEventArgs  {
		contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class ContactPostActivatedEventArgs  {
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class ContactVideoCallActivatedEventArgs  {
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class DeviceActivatedEventArgs  {
		currentlyShownApplicationViewId: number;
		deviceInformationId: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class DevicePairingActivatedEventArgs  {
		deviceInformation: any;
		kind: any;
		previousExecutionState: any;
		splashScreen: any
	}

	declare class DialReceiverActivatedEventArgs  {
		appName: string;
		arguments: string;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class FileActivatedEventArgs  {
		callerPackageFamilyName: string;
		currentlyShownApplicationViewId: number;
		files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		neighboringFilesQuery: Windows.Storage.Search.StorageFileQueryResult;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class FileOpenPickerActivatedEventArgs  {
		callerPackageFamilyName: string;
		fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class FileOpenPickerContinuationEventArgs  {
		continuationData: Windows.Foundation.Collections.ValueSet;
		files: Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class FileSavePickerActivatedEventArgs  {
		callerPackageFamilyName: string;
		enterpriseId: string;
		fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class FileSavePickerContinuationEventArgs  {
		continuationData: Windows.Foundation.Collections.ValueSet;
		file: Windows.Storage.StorageFile;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class FolderPickerContinuationEventArgs  {
		continuationData: Windows.Foundation.Collections.ValueSet;
		folder: Windows.Storage.StorageFolder;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class LaunchActivatedEventArgs  {
		arguments: string;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		prelaunchActivated: boolean;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class LockScreenActivatedEventArgs  {
		info: any;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class LockScreenCallActivatedEventArgs  {
		arguments: string;
		callUI: Windows.ApplicationModel.Calls.LockScreenCallUI;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class PickerReturnedActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		pickerOperationId: string;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class Print3DWorkflowActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		workflow: Windows.Devices.Printers.Extensions.Print3DWorkflow
	}

	declare class PrintTaskSettingsActivatedEventArgs  {
		configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class ProtocolActivatedEventArgs  {
		callerPackageFamilyName: string;
		currentlyShownApplicationViewId: number;
		data: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		uri: Windows.Foundation.Uri;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class ProtocolForResultsActivatedEventArgs  {
		callerPackageFamilyName: string;
		currentlyShownApplicationViewId: number;
		data: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		protocolForResultsOperation: Windows.System.ProtocolForResultsOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		uri: Windows.Foundation.Uri;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class RestrictedLaunchActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		sharedContext: any;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class SearchActivatedEventArgs  {
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		queryText: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		viewSwitcher: Windows.UI.ViewManagement.ActivationViewSwitcher
	}

	declare class ShareTargetActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class SplashScreen  {
		imageLocation: Windows.Foundation.Rect;
		ondismissed: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen, any>;
		addEventListener(
		type: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen, any>
	): void;
		removeEventListener(
		type: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ToastNotificationActivatedEventArgs  {
		argument: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		userInput: Windows.Foundation.Collections.ValueSet
	}

	declare class VoiceCommandActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		result: Windows.Media.SpeechRecognition.SpeechRecognitionResult;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WalletActionActivatedEventArgs  {
		actionId: string;
		actionKind: Windows.ApplicationModel.Wallet.WalletActionKind;
		itemId: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebAccountProviderActivatedEventArgs  {
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		operation: Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebAuthenticationBrokerContinuationEventArgs  {
		continuationData: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		webAuthenticationResult: Windows.Security.Authentication.Web.WebAuthenticationResult
	}

	
}

declare module 'ApplicationModel' {
		declare interface PackageVersion {
		build: number,
		major: number,
		minor: number,
		revision: number
	}

	declare interface ISuspendingEventArgs {
		suspendingOperation: Windows.ApplicationModel.SuspendingOperation
	}

		declare class AppDisplayInfo  {
		description: string;
		displayName: string;
		getLogo(
		size: Windows.Foundation.Size
	): Windows.Storage.Streams.RandomAccessStreamReference
	}

	declare class AppInfo  {
		appUserModelId: string;
		displayInfo: Windows.ApplicationModel.AppDisplayInfo;
		id: string;
		packageFamilyName: string
	}

	declare class DesignMode  {
		designModeEnabled: boolean
	}

	declare class Package  {
		current: Windows.ApplicationModel.Package;
		dependencies: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Package>;
		description: string;
		displayName: string;
		getAppListEntriesAsync: any;
		getThumbnailToken(): string;
		id: Windows.ApplicationModel.PackageId;
		installDate: Date;
		installedDate: Date;
		installedLocation: Windows.Storage.StorageFolder;
		isBundle: boolean;
		isDevelopmentMode: boolean;
		isFramework: boolean;
		isResourcePackage: boolean;
		launch(parameters: string): void;
		logo: Windows.Foundation.Uri;
		publisherDisplayName: string;
		status: any
	}

	declare class PackageId  {
		architecture: Windows.System.ProcessorArchitecture;
		author: string;
		familyName: string;
		fullName: string;
		name: string;
		productId: string;
		publisher: string;
		publisherId: string;
		resourceId: string;
		version: Windows.ApplicationModel.PackageVersion
	}

	declare class PackageStatus  {
		dataOffline: boolean;
		dependencyIssue: boolean;
		deploymentInProgress: boolean;
		disabled: boolean;
		licenseIssue: boolean;
		modified: boolean;
		needsRemediation: boolean;
		notAvailable: boolean;
		packageOffline: boolean;
		servicing: boolean;
		tampered: boolean;
		verifyIsOK(): boolean
	}

	declare class SuspendingDeferral  {
		complete(): void
	}

	declare class SuspendingEventArgs  {
		suspendingOperation: Windows.ApplicationModel.SuspendingOperation
	}

	declare class SuspendingOperation  {
		deadline: Date;
		getDeferral(): Windows.ApplicationModel.SuspendingDeferral
	}

	
}

declare module 'AppService' {
				declare class AppServiceCatalog  {
		findAppServiceProvidersAsync: any
	}

	declare class AppServiceClosedEventArgs  {
		status: Windows.ApplicationModel.AppService.AppServiceClosedStatus
	}

	declare class AppServiceConnection  {
		constructor(): this;
		appServiceName: string;
		close(): void;
		onrequestreceived: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs>;
		addEventListener(
		type: "requestreceived", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs>
	): void;
		removeEventListener(
		type: "requestreceived", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceRequestReceivedEventArgs>
	): void;
		onserviceclosed: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceClosedEventArgs>;
		addEventListener(
		type: "serviceclosed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceClosedEventArgs>
	): void;
		removeEventListener(
		type: "serviceclosed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.AppService.AppServiceConnection, Windows.ApplicationModel.AppService.AppServiceClosedEventArgs>
	): void;
		openAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.AppService.AppServiceConnectionStatus>;
		packageFamilyName: string;
		sendMessageAsync(
		message: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.AppService.AppServiceResponse>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppServiceDeferral  {
		complete(): void
	}

	declare class AppServiceRequest  {
		message: Windows.Foundation.Collections.ValueSet;
		sendResponseAsync(
		message: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.AppService.AppServiceResponseStatus>
	}

	declare class AppServiceRequestReceivedEventArgs  {
		getDeferral(): Windows.ApplicationModel.AppService.AppServiceDeferral;
		request: Windows.ApplicationModel.AppService.AppServiceRequest
	}

	declare class AppServiceResponse  {
		message: Windows.Foundation.Collections.ValueSet;
		status: Windows.ApplicationModel.AppService.AppServiceResponseStatus
	}

	declare class AppServiceTriggerDetails  {
		appServiceConnection: Windows.ApplicationModel.AppService.AppServiceConnection;
		callerPackageFamilyName: string;
		name: string
	}

	
}

declare module 'Appointments' {
				declare class Appointment  {
		constructor(): this;
		allDay: boolean;
		allowNewTimeProposal: boolean;
		busyStatus: Windows.ApplicationModel.Appointments.AppointmentBusyStatus;
		calendarId: string;
		changeNumber: number;
		details: string;
		detailsKind: Windows.ApplicationModel.Appointments.AppointmentDetailsKind;
		duration: number;
		hasInvitees: boolean;
		invitees: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Appointments.AppointmentInvitee>;
		isCanceledMeeting: boolean;
		isOrganizedByUser: boolean;
		isResponseRequested: boolean;
		localId: string;
		location: string;
		onlineMeetingLink: string;
		organizer: Windows.ApplicationModel.Appointments.AppointmentOrganizer;
		originalStartTime: Date;
		recurrence: Windows.ApplicationModel.Appointments.AppointmentRecurrence;
		reminder: number;
		remoteChangeNumber: number;
		replyTime: Date;
		roamingId: string;
		sensitivity: Windows.ApplicationModel.Appointments.AppointmentSensitivity;
		startTime: Date;
		subject: string;
		uri: Windows.Foundation.Uri;
		userResponse: Windows.ApplicationModel.Appointments.AppointmentParticipantResponse
	}

	declare class AppointmentCalendar  {
		canCancelMeetings: boolean;
		canCreateOrUpdateAppointments: boolean;
		canForwardMeetings: boolean;
		canNotifyInvitees: boolean;
		canProposeNewTimeForMeetings: boolean;
		canUpdateMeetingResponses: boolean;
		deleteAppointmentAsync(localId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAppointmentInstanceAsync(
		localId: string, instanceStartTime: Date
	): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		displayColor: Windows.UI.Color;
		displayName: string;
		findAllInstancesAsync(
		masterLocalId: string, rangeStart: Date, rangeLength: number, pOptions: Windows.ApplicationModel.Appointments.FindAppointmentsOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllInstancesAsync(
		masterLocalId: string, rangeStart: Date, rangeLength: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAppointmentsAsync(
		rangeStart: Date, rangeLength: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAppointmentsAsync(
		rangeStart: Date, rangeLength: number, options: Windows.ApplicationModel.Appointments.FindAppointmentsOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findExceptionsFromMasterAsync(
		masterLocalId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findUnexpandedAppointmentsAsync(
		options: Windows.ApplicationModel.Appointments.FindAppointmentsOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findUnexpandedAppointmentsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAppointmentAsync(
		localId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.Appointment>;
		getAppointmentAsync(
		localId: string, prefetchProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.Appointment>;
		getAppointmentInstanceAsync(
		localId: string, instanceStartTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.Appointment>;
		isHidden: boolean;
		localId: string;
		mustNofityInvitees: boolean;
		otherAppReadAccess: Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppReadAccess;
		otherAppWriteAccess: Windows.ApplicationModel.Appointments.AppointmentCalendarOtherAppWriteAccess;
		remoteId: string;
		saveAppointmentAsync(
		pAppointment: Windows.ApplicationModel.Appointments.Appointment
	): Windows.Foundation.IPromiseWithIAsyncAction;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		sourceDisplayName: string;
		summaryCardView: Windows.ApplicationModel.Appointments.AppointmentSummaryCardView;
		syncManager: Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager;
		tryCancelMeetingAsync(
		meeting: Windows.ApplicationModel.Appointments.Appointment, subject: string, comment: string, notifyInvitees: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryCreateOrUpdateAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, notifyInvitees: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryForwardMeetingAsync(
		meeting: Windows.ApplicationModel.Appointments.Appointment, invitees: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Appointments.AppointmentInvitee>, subject: string, forwardHeader: string, comment: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryProposeNewTimeForMeetingAsync(
		meeting: Windows.ApplicationModel.Appointments.Appointment, newStartTime: Date, newDuration: number, subject: string, comment: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryUpdateMeetingResponseAsync(
		meeting: Windows.ApplicationModel.Appointments.Appointment, response: Windows.ApplicationModel.Appointments.AppointmentParticipantResponse, subject: string, comment: string, sendUpdate: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		userDataAccountId: string
	}

	declare class AppointmentCalendarSyncManager  {
		lastAttemptedSyncTime: Date;
		lastSuccessfulSyncTime: Date;
		onsyncstatuschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager, any>;
		addEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager, any>
	): void;
		removeEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentCalendarSyncManager, any>
	): void;
		status: Windows.ApplicationModel.Appointments.AppointmentCalendarSyncStatus;
		syncAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppointmentConflictResult  {
		date: Date;
		type: Windows.ApplicationModel.Appointments.AppointmentConflictType
	}

	declare class AppointmentException  {
		appointment: Windows.ApplicationModel.Appointments.Appointment;
		exceptionProperties: Windows.Foundation.Collections.IVectorView<string>;
		isDeleted: boolean
	}

	declare class AppointmentInvitee  {
		constructor(): this;
		address: string;
		displayName: string;
		response: Windows.ApplicationModel.Appointments.AppointmentParticipantResponse;
		role: Windows.ApplicationModel.Appointments.AppointmentParticipantRole
	}

	declare class AppointmentManager  {
		requestStoreAsync(
		options: Windows.ApplicationModel.Appointments.AppointmentStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentStore>;
		showAddAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showAddAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showAppointmentDetailsAsync(appointmentId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		showAppointmentDetailsAsync(
		appointmentId: string, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncAction;
		showEditNewAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showRemoveAppointmentAsync(
		appointmentId: string, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		showRemoveAppointmentAsync(
		appointmentId: string, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		showRemoveAppointmentAsync(
		appointmentId: string, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		showReplaceAppointmentAsync(
		appointmentId: string, appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showReplaceAppointmentAsync(
		appointmentId: string, appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showReplaceAppointmentAsync(
		appointmentId: string, appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showTimeFrameAsync(
		timeToShow: Date, duration: number
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class AppointmentOrganizer  {
		constructor(): this;
		address: string;
		displayName: string
	}

	declare class AppointmentProperties  {
		allDay: string;
		allowNewTimeProposal: string;
		busyStatus: string;
		changeNumber: string;
		defaultProperties: Windows.Foundation.Collections.IVector<string>;
		details: string;
		detailsKind: any;
		duration: string;
		hasInvitees: string;
		invitees: string;
		isCanceledMeeting: string;
		isOrganizedByUser: string;
		isResponseRequested: string;
		location: string;
		onlineMeetingLink: string;
		organizer: string;
		originalStartTime: string;
		recurrence: string;
		reminder: string;
		remoteChangeNumber: any;
		replyTime: string;
		sensitivity: string;
		startTime: string;
		subject: string;
		uri: string;
		userResponse: string
	}

	declare class AppointmentRecurrence  {
		constructor(): this;
		calendarIdentifier: any;
		day: number;
		daysOfWeek: Windows.ApplicationModel.Appointments.AppointmentDaysOfWeek;
		interval: number;
		month: number;
		occurrences: number;
		recurrenceType: Windows.ApplicationModel.Appointments.RecurrenceType;
		timeZone: string;
		unit: Windows.ApplicationModel.Appointments.AppointmentRecurrenceUnit;
		until: Date;
		weekOfMonth: Windows.ApplicationModel.Appointments.AppointmentWeekOfMonth
	}

	declare class AppointmentStore  {
		changeTracker: Windows.ApplicationModel.Appointments.AppointmentStoreChangeTracker;
		createAppointmentCalendarAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentCalendar>;
		createAppointmentCalendarAsync(
		name: string, userDataAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentCalendar>;
		findAppointmentCalendarsAsync(
		options: Windows.ApplicationModel.Appointments.FindAppointmentCalendarsOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAppointmentCalendarsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAppointmentsAsync(
		rangeStart: Date, rangeLength: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAppointmentsAsync(
		rangeStart: Date, rangeLength: number, options: Windows.ApplicationModel.Appointments.FindAppointmentsOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findConflictAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, instanceStartTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentConflictResult>;
		findConflictAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentConflictResult>;
		findLocalIdsFromRoamingIdAsync(
		roamingId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAppointmentAsync(
		localId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.Appointment>;
		getAppointmentCalendarAsync(
		calendarId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.AppointmentCalendar>;
		getAppointmentInstanceAsync(
		localId: string, instanceStartTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Appointments.Appointment>;
		moveAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, destinationCalendar: Windows.ApplicationModel.Appointments.AppointmentCalendar
	): Windows.Foundation.IPromiseWithIAsyncAction;
		onstorechanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentStore, Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs>;
		addEventListener(
		type: "storechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentStore, Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs>
	): void;
		removeEventListener(
		type: "storechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Appointments.AppointmentStore, Windows.ApplicationModel.Appointments.AppointmentStoreChangedEventArgs>
	): void;
		showAddAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showAppointmentDetailsAsync(localId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		showAppointmentDetailsAsync(
		localId: string, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncAction;
		showEditNewAppointmentAsync(
		appointment: Windows.ApplicationModel.Appointments.Appointment
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showRemoveAppointmentAsync(
		localId: string, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		showRemoveAppointmentAsync(
		localId: string, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		showReplaceAppointmentAsync(
		localId: string, appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		showReplaceAppointmentAsync(
		localId: string, appointment: Windows.ApplicationModel.Appointments.Appointment, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, instanceStartDate: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppointmentStoreChange  {
		appointment: Windows.ApplicationModel.Appointments.Appointment;
		appointmentCalendar: Windows.ApplicationModel.Appointments.AppointmentCalendar;
		changeType: Windows.ApplicationModel.Appointments.AppointmentStoreChangeType
	}

	declare class AppointmentStoreChangeReader  {
		acceptChanges(): void;
		acceptChangesThrough(
		lastChangeToAccept: Windows.ApplicationModel.Appointments.AppointmentStoreChange
	): void;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class AppointmentStoreChangeTracker  {
		enable: any;
		getChangeReader: any;
		reset: any
	}

	declare class AppointmentStoreChangedDeferral  {
		complete(): void
	}

	declare class AppointmentStoreChangedEventArgs  {
		getDeferral(): Windows.ApplicationModel.Appointments.AppointmentStoreChangedDeferral
	}

	declare class AppointmentStoreNotificationTriggerDetails  {
		
	}

	declare class FindAppointmentsOptions  {
		calendarIds: any;
		fetchProperties: any;
		includeHidden: any;
		maxCount: any
	}

	
}

declare module 'AppointmentsProvider' {
				declare class AddAppointmentOperation  {
		appointmentInformation: Windows.ApplicationModel.Appointments.Appointment;
		dismissUI(): void;
		reportCanceled(): void;
		reportCompleted(itemId: string): void;
		reportError(value: string): void;
		sourcePackageFamilyName: string
	}

	declare class AppointmentsProviderLaunchActionVerbs  {
		addAppointment: string;
		removeAppointment: string;
		replaceAppointment: string;
		showAppointmentDetails: string;
		showTimeFrame: string
	}

	declare class RemoveAppointmentOperation  {
		appointmentId: string;
		dismissUI(): void;
		instanceStartDate: Date;
		reportCanceled(): void;
		reportCompleted(): void;
		reportError(value: string): void;
		sourcePackageFamilyName: string
	}

	declare class ReplaceAppointmentOperation  {
		appointmentId: string;
		appointmentInformation: Windows.ApplicationModel.Appointments.Appointment;
		dismissUI(): void;
		instanceStartDate: Date;
		reportCanceled(): void;
		reportCompleted(itemId: string): void;
		reportError(value: string): void;
		sourcePackageFamilyName: string
	}

	
}

declare module 'Background' {
	declare type BackgroundTaskCompletedEventHandler = (
		ev: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventArgs & WinRTEvent<Windows.ApplicationModel.Background.BackgroundTaskRegistration>
	) => void;

	declare type BackgroundTaskProgressEventHandler = (
		ev: Windows.ApplicationModel.Background.BackgroundTaskProgressEventArgs & WinRTEvent<Windows.ApplicationModel.Background.BackgroundTaskRegistration>
	) => void;

	declare type BackgroundTaskCanceledEventHandler = (
		ev: Windows.ApplicationModel.Background.BackgroundTaskCancellationReason & WinRTEvent<Windows.ApplicationModel.Background.IBackgroundTaskInstance>
	) => void;

	declare interface IBackgroundCondition {
		
	}

	declare interface IBackgroundTrigger {
		
	}

	declare interface IBackgroundTaskRegistration {
		unregister(cancelTask: boolean): void,
		name: string,
		taskId: string,
		trigger: Windows.ApplicationModel.Background.IBackgroundTrigger
	}

	declare interface IBackgroundTaskInstance {
		getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral,
		instanceId: string,
		progress: number,
		suspendedCount: number,
		task: Windows.ApplicationModel.Background.BackgroundTaskRegistration,
		triggerDetails: any,
		getThrottleCount(
		counter: Windows.ApplicationModel.Background.BackgroundTaskThrottleCounter
	): number
	}

		declare class ActivitySensorTrigger  {
		constructor(reportIntervalInMilliseconds: number): this;
		minimumReportInterval: number;
		reportInterval: number;
		subscribedActivities: Windows.Foundation.Collections.IVector<Windows.Devices.Sensors.ActivityType>;
		supportedActivities: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ActivityType>
	}

	declare class AlarmApplicationManager  {
		getAccessStatus(): Windows.ApplicationModel.Background.AlarmAccessStatus;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.AlarmAccessStatus>
	}

	declare class ApplicationTrigger  {
		constructor(): this;
		requestAsync(
		args: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.ApplicationTriggerResult>;
		requestAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.ApplicationTriggerResult>
	}

	declare class ApplicationTriggerDetails  {
		arguments: Windows.Foundation.Collections.ValueSet
	}

	declare class AppointmentStoreNotificationTrigger  {
		constructor(): this
	}

	declare class BackgroundExecutionManager  {
		getAccessStatus(): Windows.ApplicationModel.Background.BackgroundAccessStatus;
		getAccessStatus(
		applicationId: string
	): Windows.ApplicationModel.Background.BackgroundAccessStatus;
		removeAccess(applicationId: string): void;
		removeAccess(): void;
		requestAccessAsync(
		applicationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>
	}

	declare class BackgroundTaskBuilder  {
		constructor(): this;
		addCondition(condition: Windows.ApplicationModel.Background.IBackgroundCondition): void;
		cancelOnConditionLoss: boolean;
		isNetworkRequested: boolean;
		name: string;
		register(): Windows.ApplicationModel.Background.BackgroundTaskRegistration;
		setTrigger(trigger: Windows.ApplicationModel.Background.IBackgroundTrigger): void;
		taskEntryPoint: string
	}

	declare class BackgroundTaskCompletedEventArgs  {
		checkResult(): void;
		instanceId: string
	}

	declare class BackgroundTaskDeferral  {
		complete(): void
	}

	declare class BackgroundTaskProgressEventArgs  {
		instanceId: string;
		progress: number
	}

	declare class BackgroundTaskRegistration  {
		allTasks: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Background.IBackgroundTaskRegistration>;
		name: string;
		oncompleted: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler;
		addEventListener(
		type: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler
	): void;
		removeEventListener(
		type: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler
	): void;
		onprogress: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler;
		addEventListener(
		type: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler
	): void;
		removeEventListener(
		type: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler
	): void;
		taskId: string;
		trigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
		unregister(cancelTask: boolean): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BackgroundWorkCost  {
		currentBackgroundWorkCost: Windows.ApplicationModel.Background.BackgroundWorkCostValue
	}

	declare class BluetoothLEAdvertisementPublisherTrigger  {
		constructor(): this;
		advertisement: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement
	}

	declare class BluetoothLEAdvertisementWatcherTrigger  {
		constructor(): this;
		advertisementFilter: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter;
		maxOutOfRangeTimeout: number;
		maxSamplingInterval: number;
		minOutOfRangeTimeout: number;
		minSamplingInterval: number;
		signalStrengthFilter: Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter
	}

	declare class CachedFileUpdaterTrigger  {
		constructor(): this
	}

	declare class CachedFileUpdaterTriggerDetails  {
		canRequestUserInput: boolean;
		updateRequest: Windows.Storage.Provider.FileUpdateRequest;
		updateTarget: Windows.Storage.Provider.CachedFileTarget
	}

	declare class ChatMessageNotificationTrigger  {
		constructor(): this
	}

	declare class ChatMessageReceivedNotificationTrigger  {
		constructor(): this
	}

	declare class ContactStoreNotificationTrigger  {
		constructor(): this
	}

	declare class ContentPrefetchTrigger  {
		constructor(): this;
		constructor(waitInterval: number): this;
		waitInterval: number
	}

	declare class DeviceConnectionChangeTrigger  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger>;
		canMaintainConnection: boolean;
		deviceId: string;
		maintainConnection: boolean
	}

	declare class DeviceManufacturerNotificationTrigger  {
		constructor(triggerQualifier: string, oneShot: boolean): this;
		oneShot: boolean;
		triggerQualifier: string
	}

	declare class DeviceServicingTrigger  {
		constructor(): this;
		requestAsync(
		deviceId: string, expectedDuration: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>;
		requestAsync(
		deviceId: string, expectedDuration: number, args: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>
	}

	declare class DeviceUseTrigger  {
		constructor(): this;
		requestAsync(
		deviceId: string, args: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>;
		requestAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.DeviceTriggerResult>
	}

	declare class DeviceWatcherTrigger  {
		
	}

	declare class EmailStoreNotificationTrigger  {
		constructor(): this
	}

	declare class GattCharacteristicNotificationTrigger  {
		constructor(characteristic: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic): this;
		characteristic: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic
	}

	declare class LocationTrigger  {
		constructor(triggerType: Windows.ApplicationModel.Background.LocationTriggerType): this;
		triggerType: Windows.ApplicationModel.Background.LocationTriggerType
	}

	declare class MaintenanceTrigger  {
		constructor(freshnessTime: number, oneShot: boolean): this;
		freshnessTime: number;
		oneShot: boolean
	}

	declare class MediaProcessingTrigger  {
		constructor(): this;
		requestAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.MediaProcessingTriggerResult>;
		requestAsync(
		args: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Background.MediaProcessingTriggerResult>
	}

	declare class MobileBroadbandDeviceServiceNotificationTrigger  {
		constructor(): this
	}

	declare class MobileBroadbandPinLockStateChangeTrigger  {
		constructor(): this
	}

	declare class MobileBroadbandRadioStateChangeTrigger  {
		constructor(): this
	}

	declare class MobileBroadbandRegistrationStateChangeTrigger  {
		constructor(): this
	}

	declare class NetworkOperatorHotspotAuthenticationTrigger  {
		constructor(): this
	}

	declare class NetworkOperatorNotificationTrigger  {
		constructor(networkAccountId: string): this;
		networkAccountId: string
	}

	declare class PhoneTrigger  {
		constructor(type: Windows.ApplicationModel.Calls.Background.PhoneTriggerType, oneShot: boolean): this;
		oneShot: boolean;
		triggerType: Windows.ApplicationModel.Calls.Background.PhoneTriggerType
	}

	declare class PushNotificationTrigger  {
		constructor(): this;
		constructor(applicationId: string): this
	}

	declare class RcsEndUserMessageAvailableTrigger  {
		constructor(): this
	}

	declare class RfcommConnectionTrigger  {
		constructor(): this;
		allowMultipleConnections: boolean;
		inboundConnection: Windows.Devices.Bluetooth.Background.RfcommInboundConnectionInformation;
		outboundConnection: Windows.Devices.Bluetooth.Background.RfcommOutboundConnectionInformation;
		protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
		remoteHostName: Windows.Networking.HostName
	}

	declare class SensorDataThresholdTrigger  {
		constructor(threshold: Windows.Devices.Sensors.ISensorDataThreshold): this
	}

	declare class SmsMessageReceivedTrigger  {
		constructor(filterRules: Windows.Devices.Sms.SmsFilterRules): this
	}

	declare class SocketActivityTrigger  {
		constructor(): this
	}

	declare class StorageLibraryContentChangedTrigger  {
		create(
		storageLibrary: Windows.Storage.StorageLibrary
	): Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger;
		createFromLibraries(
		storageLibraries: Windows.Foundation.Collections.IIterable<Windows.Storage.StorageLibrary>
	): Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger
	}

	declare class SystemCondition  {
		constructor(conditionType: Windows.ApplicationModel.Background.SystemConditionType): this;
		conditionType: Windows.ApplicationModel.Background.SystemConditionType
	}

	declare class SystemTrigger  {
		constructor(triggerType: Windows.ApplicationModel.Background.SystemTriggerType, oneShot: boolean): this;
		oneShot: boolean;
		triggerType: Windows.ApplicationModel.Background.SystemTriggerType
	}

	declare class TimeTrigger  {
		constructor(freshnessTime: number, oneShot: boolean): this;
		freshnessTime: number;
		oneShot: boolean
	}

	declare class ToastNotificationActionTrigger  {
		constructor(): this;
		constructor(applicationId: string): this
	}

	declare class ToastNotificationHistoryChangedTrigger  {
		constructor(): this;
		constructor(applicationId: string): this
	}

	declare class PhoneCallBlockedTriggerDetails  {
		callBlockedReason: Windows.ApplicationModel.Calls.Background.PhoneCallBlockedReason;
		lineId: string;
		phoneNumber: string
	}

	declare class PhoneCallOriginDataRequestTriggerDetails  {
		phoneNumber: string;
		requestId: string
	}

	declare class PhoneLineChangedTriggerDetails  {
		changeType: Windows.ApplicationModel.Calls.Background.PhoneLineChangeKind;
		hasLinePropertyChanged(
		lineProperty: Windows.ApplicationModel.Calls.Background.PhoneLineProperties
	): boolean;
		lineId: string
	}

	declare class PhoneNewVoicemailMessageTriggerDetails  {
		lineId: string;
		operatorMessage: string;
		voicemailCount: number
	}

	declare class DeviceServicingDetails  {
		arguments: string;
		deviceId: string;
		expectedDuration: number
	}

	declare class DeviceUseDetails  {
		arguments: string;
		deviceId: string
	}

	declare class BluetoothLEAdvertisementPublisherTriggerDetails  {
		error: Windows.Devices.Bluetooth.BluetoothError;
		status: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus
	}

	declare class BluetoothLEAdvertisementWatcherTriggerDetails  {
		advertisements: Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs>;
		error: Windows.Devices.Bluetooth.BluetoothError;
		signalStrengthFilter: Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter
	}

	declare class GattCharacteristicNotificationTriggerDetails  {
		characteristic: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic;
		value: Windows.Storage.Streams.IBuffer
	}

	declare class RfcommConnectionTriggerDetails  {
		incoming: boolean;
		remoteDevice: Windows.Devices.Bluetooth.BluetoothDevice;
		socket: Windows.Networking.Sockets.StreamSocket
	}

	declare class RfcommInboundConnectionInformation  {
		localServiceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		sdpRecord: Windows.Storage.Streams.IBuffer;
		serviceCapabilities: Windows.Devices.Bluetooth.BluetoothServiceCapabilities
	}

	declare class RfcommOutboundConnectionInformation  {
		remoteServiceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId
	}

	
}

declare module 'Calls' {
				declare class LockScreenCallEndCallDeferral  {
		complete(): void
	}

	declare class LockScreenCallEndRequestedEventArgs  {
		deadline: Date;
		getDeferral(): Windows.ApplicationModel.Calls.LockScreenCallEndCallDeferral
	}

	declare class LockScreenCallUI  {
		callTitle: string;
		dismiss(): void;
		onclosed: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, any>;
		addEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, any>
	): void;
		removeEventListener(
		type: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, any>
	): void;
		onendrequested: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs>;
		addEventListener(
		type: "endrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs>
	): void;
		removeEventListener(
		type: "endrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Calls.LockScreenCallUI, Windows.ApplicationModel.Calls.LockScreenCallEndRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PhoneCallHistoryEntry  {
		constructor(): this;
		address: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress;
		duration: number;
		id: string;
		isCallerIdBlocked: boolean;
		isEmergency: boolean;
		isIncoming: boolean;
		isMissed: boolean;
		isRinging: boolean;
		isSeen: boolean;
		isSuppressed: boolean;
		isVoicemail: boolean;
		media: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryMedia;
		otherAppReadAccess: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryOtherAppReadAccess;
		remoteId: string;
		sourceDisplayName: string;
		sourceId: string;
		sourceIdKind: Windows.ApplicationModel.Calls.PhoneCallHistorySourceIdKind;
		startTime: Date
	}

	declare class PhoneCallHistoryEntryAddress  {
		constructor(): this;
		constructor(rawAddress: string, rawAddressKind: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind): this;
		contactId: string;
		displayName: string;
		rawAddress: string;
		rawAddressKind: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryRawAddressKind
	}

	declare class PhoneCallHistoryEntryQueryOptions  {
		constructor(): this;
		desiredMedia: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryDesiredMedia;
		sourceIds: Windows.Foundation.Collections.IVector<string>
	}

	declare class PhoneCallHistoryEntryReader  {
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class PhoneCallHistoryManager  {
		requestStoreAsync(
		accessType: Windows.ApplicationModel.Calls.PhoneCallHistoryStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Calls.PhoneCallHistoryStore>
	}

	declare class PhoneCallHistoryStore  {
		deleteEntriesAsync(
		callHistoryEntries: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Calls.PhoneCallHistoryEntry>
	): any;
		deleteEntryAsync(callHistoryEntry: Windows.ApplicationModel.Calls.PhoneCallHistoryEntry): any;
		getEntryAsync(callHistoryEntryId: string): any;
		getEntryReader(
		queryOptions: Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions
	): Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader;
		getEntryReader(): Windows.ApplicationModel.Calls.PhoneCallHistoryEntryReader;
		getSourcesUnseenCountAsync(
		sourceIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		getUnseenCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		markAllAsSeenAsync(): any;
		markEntriesAsSeenAsync(
		callHistoryEntries: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Calls.PhoneCallHistoryEntry>
	): any;
		markEntryAsSeenAsync(callHistoryEntry: Windows.ApplicationModel.Calls.PhoneCallHistoryEntry): any;
		markSourcesAsSeenAsync(sourceIds: Windows.Foundation.Collections.IIterable<string>): any;
		saveEntryAsync(callHistoryEntry: Windows.ApplicationModel.Calls.PhoneCallHistoryEntry): any
	}

	
}

declare module 'Chat' {
				declare class ChatCapabilities  {
		isChatCapable: boolean;
		isFileTransferCapable: boolean;
		isGeoLocationPushCapable: boolean;
		isIntegratedMessagingCapable: boolean;
		isOnline: boolean
	}

	declare class ChatCapabilitiesManager  {
		getCachedCapabilitiesAsync(
		address: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatCapabilities>;
		getCapabilitiesFromNetworkAsync(
		address: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatCapabilities>
	}

	declare class ChatConversation  {
		canModifyParticipants: boolean;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		getMessageReader(): Windows.ApplicationModel.Chat.ChatMessageReader;
		hasUnreadMessages: boolean;
		id: string;
		isConversationMuted: boolean;
		markMessagesAsReadAsync(value: Date): Windows.Foundation.IPromiseWithIAsyncAction;
		markMessagesAsReadAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		mostRecentMessageId: string;
		notifyLocalParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;
		notifyRemoteParticipantComposing(transportId: string, participantAddress: string, isComposing: boolean): void;
		onremoteparticipantcomposingchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatConversation, Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs>;
		addEventListener(
		type: "remoteparticipantcomposingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatConversation, Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs>
	): void;
		removeEventListener(
		type: "remoteparticipantcomposingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatConversation, Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs>
	): void;
		participants: Windows.Foundation.Collections.IVector<string>;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		subject: string;
		threadingInfo: Windows.ApplicationModel.Chat.ChatConversationThreadingInfo;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ChatConversationReader  {
		readBatchAsync(
		count: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class ChatConversationThreadingInfo  {
		constructor(): this;
		contactId: string;
		conversationId: string;
		custom: string;
		kind: Windows.ApplicationModel.Chat.ChatConversationThreadingKind;
		participants: Windows.Foundation.Collections.IVector<string>
	}

	declare class ChatMessage  {
		constructor(): this;
		attachments: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Chat.ChatMessageAttachment>;
		body: string;
		estimatedDownloadSize: number;
		from: string;
		id: string;
		isAutoReply: boolean;
		isForwardingDisabled: boolean;
		isIncoming: boolean;
		isRead: boolean;
		isReceivedDuringQuietHours: boolean;
		isReplyDisabled: boolean;
		isSeen: boolean;
		isSimMessage: boolean;
		localTimestamp: Date;
		messageKind: Windows.ApplicationModel.Chat.ChatMessageKind;
		messageOperatorKind: Windows.ApplicationModel.Chat.ChatMessageOperatorKind;
		networkTimestamp: Date;
		recipientSendStatuses: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Chat.ChatMessageStatus>;
		recipients: Windows.Foundation.Collections.IVector<string>;
		recipientsDeliveryInfos: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo>;
		remoteId: string;
		shouldSuppressNotification: boolean;
		status: Windows.ApplicationModel.Chat.ChatMessageStatus;
		subject: string;
		threadingInfo: Windows.ApplicationModel.Chat.ChatConversationThreadingInfo;
		transportFriendlyName: string;
		transportId: string
	}

	declare class ChatMessageAttachment  {
		constructor(mimeType: string, dataStreamReference: Windows.Storage.Streams.IRandomAccessStreamReference): this;
		dataStreamReference: Windows.Storage.Streams.IRandomAccessStreamReference;
		groupId: number;
		mimeType: string;
		originalFileName: string;
		text: string;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		transferProgress: number
	}

	declare class ChatMessageBlocking  {
		markMessageAsBlockedAsync(
		localChatMessageId: string, blocked: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class ChatMessageChange  {
		changeType: Windows.ApplicationModel.Chat.ChatMessageChangeType;
		message: Windows.ApplicationModel.Chat.ChatMessage
	}

	declare class ChatMessageChangeReader  {
		acceptChanges(): void;
		acceptChangesThrough(lastChangeToAcknowledge: Windows.ApplicationModel.Chat.ChatMessageChange): void;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class ChatMessageChangeTracker  {
		enable(): void;
		getChangeReader(): Windows.ApplicationModel.Chat.ChatMessageChangeReader;
		reset(): void
	}

	declare class ChatMessageChangedDeferral  {
		complete(): void
	}

	declare class ChatMessageChangedEventArgs  {
		getDeferral(): Windows.ApplicationModel.Chat.ChatMessageChangedDeferral
	}

	declare class ChatMessageManager  {
		getTransportAsync(
		transportId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatMessageTransport>;
		getTransportsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		registerTransportAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		requestStoreAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatMessageStore>;
		showComposeSmsMessageAsync(
		message: Windows.ApplicationModel.Chat.ChatMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		showSmsSettings(): void
	}

	declare class ChatMessageNotificationTriggerDetails  {
		chatMessage: Windows.ApplicationModel.Chat.ChatMessage;
		shouldDisplayToast: boolean;
		shouldUpdateActionCenter: boolean;
		shouldUpdateBadge: boolean;
		shouldUpdateDetailText: boolean
	}

	declare class ChatMessageReader  {
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		readBatchAsync(
		count: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class ChatMessageStore  {
		changeTracker: Windows.ApplicationModel.Chat.ChatMessageChangeTracker;
		deleteMessageAsync(localMessageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		downloadMessageAsync(localChatMessageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		forwardMessageAsync(
		localChatMessageId: string, addresses: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatMessage>;
		getConversationAsync(
		conversationId: string, transportIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatConversation>;
		getConversationAsync(
		conversationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatConversation>;
		getConversationFromThreadingInfoAsync(
		threadingInfo: Windows.ApplicationModel.Chat.ChatConversationThreadingInfo
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatConversation>;
		getConversationReader(): Windows.ApplicationModel.Chat.ChatConversationReader;
		getConversationReader(
		transportIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.ApplicationModel.Chat.ChatConversationReader;
		getMessageAsync(
		localChatMessageId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatMessage>;
		getMessageByRemoteIdAsync(
		transportId: string, remoteId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.ChatMessage>;
		getMessageReader(): Windows.ApplicationModel.Chat.ChatMessageReader;
		getMessageReader(recentTimeLimit: number): Windows.ApplicationModel.Chat.ChatMessageReader;
		getSearchReader(
		value: Windows.ApplicationModel.Chat.ChatQueryOptions
	): Windows.ApplicationModel.Chat.ChatSearchReader;
		getUnseenCountAsync(
		transportIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		getUnseenCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		markAsSeenAsync(
		transportIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		markAsSeenAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		markMessageReadAsync(localChatMessageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		onmessagechanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs>;
		addEventListener(
		type: "messagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs>
	): void;
		removeEventListener(
		type: "messagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs>
	): void;
		onstorechanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs>;
		addEventListener(
		type: "storechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs>
	): void;
		removeEventListener(
		type: "storechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.ChatMessageStore, Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs>
	): void;
		retrySendMessageAsync(localChatMessageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		saveMessageAsync(
		chatMessage: Windows.ApplicationModel.Chat.ChatMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sendMessageAsync(
		chatMessage: Windows.ApplicationModel.Chat.ChatMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tryCancelDownloadMessageAsync(
		localChatMessageId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryCancelSendMessageAsync(
		localChatMessageId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		validateMessage(
		chatMessage: Windows.ApplicationModel.Chat.ChatMessage
	): Windows.ApplicationModel.Chat.ChatMessageValidationResult;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ChatMessageStoreChangedEventArgs  {
		id: string;
		kind: Windows.ApplicationModel.Chat.ChatStoreChangedEventKind
	}

	declare class ChatMessageTransport  {
		configuration: Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration;
		isActive: boolean;
		isAppSetAsNotificationProvider: boolean;
		requestSetAsNotificationProviderAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		transportFriendlyName: string;
		transportId: string;
		transportKind: Windows.ApplicationModel.Chat.ChatMessageTransportKind
	}

	declare class ChatMessageTransportConfiguration  {
		extendedProperties: Windows.Foundation.Collections.IMapView<string, any>;
		maxAttachmentCount: number;
		maxMessageSizeInKilobytes: number;
		maxRecipientCount: number;
		supportedVideoFormat: Windows.Media.MediaProperties.MediaEncodingProfile
	}

	declare class ChatMessageValidationResult  {
		maxPartCount: number;
		partCount: number;
		remainingCharacterCountInPart: number;
		status: Windows.ApplicationModel.Chat.ChatMessageValidationStatus
	}

	declare class ChatQueryOptions  {
		constructor(): this;
		searchString: string
	}

	declare class ChatRecipientDeliveryInfo  {
		constructor(): this;
		deliveryTime: Date;
		isErrorPermanent: boolean;
		readTime: Date;
		status: Windows.ApplicationModel.Chat.ChatMessageStatus;
		transportAddress: string;
		transportErrorCode: number;
		transportErrorCodeCategory: Windows.ApplicationModel.Chat.ChatTransportErrorCodeCategory;
		transportInterpretedErrorCode: Windows.ApplicationModel.Chat.ChatTransportInterpretedErrorCode
	}

	declare class ChatSearchReader  {
		readBatchAsync(
		count: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class RcsEndUserMessage  {
		actions: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Chat.RcsEndUserMessageAction>;
		isPinRequired: boolean;
		sendResponseAsync(
		action: Windows.ApplicationModel.Chat.RcsEndUserMessageAction
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sendResponseWithPinAsync(
		action: Windows.ApplicationModel.Chat.RcsEndUserMessageAction, pin: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		text: string;
		title: string;
		transportId: string
	}

	declare class RcsEndUserMessageAction  {
		label: string
	}

	declare class RcsEndUserMessageAvailableEventArgs  {
		isMessageAvailable: boolean;
		message: Windows.ApplicationModel.Chat.RcsEndUserMessage
	}

	declare class RcsEndUserMessageAvailableTriggerDetails  {
		text: string;
		title: string
	}

	declare class RcsEndUserMessageManager  {
		onmessageavailablechanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsEndUserMessageManager, Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs>;
		addEventListener(
		type: "messageavailablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsEndUserMessageManager, Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs>
	): void;
		removeEventListener(
		type: "messageavailablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsEndUserMessageManager, Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class RcsManager  {
		getEndUserMessageManager(): Windows.ApplicationModel.Chat.RcsEndUserMessageManager;
		getTransportAsync(
		transportId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Chat.RcsTransport>;
		getTransportsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		leaveConversationAsync(
		conversation: Windows.ApplicationModel.Chat.ChatConversation
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class RcsServiceKindSupportedChangedEventArgs  {
		serviceKind: Windows.ApplicationModel.Chat.RcsServiceKind
	}

	declare class RcsTransport  {
		configuration: Windows.ApplicationModel.Chat.RcsTransportConfiguration;
		extendedProperties: Windows.Foundation.Collections.IMapView<string, any>;
		isActive: boolean;
		isServiceKindSupported(serviceKind: Windows.ApplicationModel.Chat.RcsServiceKind): boolean;
		isStoreAndForwardEnabled(serviceKind: Windows.ApplicationModel.Chat.RcsServiceKind): boolean;
		onservicekindsupportedchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsTransport, Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs>;
		addEventListener(
		type: "servicekindsupportedchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsTransport, Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs>
	): void;
		removeEventListener(
		type: "servicekindsupportedchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Chat.RcsTransport, Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs>
	): void;
		transportFriendlyName: string;
		transportId: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class RcsTransportConfiguration  {
		maxAttachmentCount: number;
		maxFileSizeInKilobytes: number;
		maxGroupMessageSizeInKilobytes: number;
		maxMessageSizeInKilobytes: number;
		maxRecipientCount: number;
		warningFileSizeInKilobytes: number
	}

	declare class RemoteParticipantComposingChangedEventArgs  {
		isComposing: boolean;
		participantAddress: string;
		transportId: string
	}

	
}

declare module 'Contacts' {
		declare interface IContactField {
		category: Windows.ApplicationModel.Contacts.ContactFieldCategory,
		name: string,
		type: Windows.ApplicationModel.Contacts.ContactFieldType,
		value: string
	}

		declare class AggregateContactManager  {
		findRawContactsAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		tryLinkContactsAsync(
		primaryContact: Windows.ApplicationModel.Contacts.Contact, secondaryContact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		trySetPreferredSourceForPictureAsync(
		aggregateContact: Windows.ApplicationModel.Contacts.Contact, rawContact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		unlinkRawContactAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class Contact  {
		constructor(): this;
		addresses: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactAddress>;
		aggregateId: string;
		connectedServiceAccounts: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount>;
		contactListId: string;
		dataSuppliers: Windows.Foundation.Collections.IVector<string>;
		displayName: string;
		displayNameOverride: string;
		displayPictureUserUpdateTime: Date;
		emails: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactEmail>;
		fields: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.IContactField>;
		firstName: string;
		fullName: string;
		honorificNamePrefix: string;
		honorificNameSuffix: string;
		id: string;
		importantDates: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactDate>;
		isAggregate: boolean;
		isDisplayPictureManuallySet: boolean;
		isMe: boolean;
		jobInfo: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactJobInfo>;
		largeDisplayPicture: Windows.Storage.Streams.IRandomAccessStreamReference;
		lastName: string;
		middleName: string;
		name: string;
		nickname: string;
		notes: string;
		phones: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactPhone>;
		providerProperties: Windows.Foundation.Collections.IPropertySet;
		remoteId: string;
		ringToneToken: string;
		significantOthers: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactSignificantOther>;
		smallDisplayPicture: Windows.Storage.Streams.IRandomAccessStreamReference;
		sortName: string;
		sourceDisplayPicture: Windows.Storage.Streams.IRandomAccessStreamReference;
		textToneToken: string;
		thumbnail: any;
		websites: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactWebsite>;
		yomiDisplayName: string;
		yomiFamilyName: string;
		yomiGivenName: string
	}

	declare class ContactAddress  {
		constructor(): this;
		country: string;
		description: string;
		kind: Windows.ApplicationModel.Contacts.ContactAddressKind;
		locality: string;
		postalCode: string;
		region: string;
		streetAddress: string
	}

	declare class ContactAnnotation  {
		constructor(): this;
		annotationListId: string;
		contactId: string;
		id: string;
		isDisabled: boolean;
		providerProperties: Windows.Foundation.Collections.ValueSet;
		remoteId: string;
		supportedOperations: Windows.ApplicationModel.Contacts.ContactAnnotationOperations
	}

	declare class ContactAnnotationList  {
		deleteAnnotationAsync(
		annotation: Windows.ApplicationModel.Contacts.ContactAnnotation
	): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		findAnnotationsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAnnotationsByRemoteIdAsync(
		remoteId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAnnotationAsync(
		annotationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactAnnotation>;
		id: string;
		providerPackageFamilyName: string;
		trySaveAnnotationAsync(
		annotation: Windows.ApplicationModel.Contacts.ContactAnnotation
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		userDataAccountId: string
	}

	declare class ContactAnnotationStore  {
		createAnnotationListAsync(
		userDataAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactAnnotationList>;
		createAnnotationListAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactAnnotationList>;
		disableAnnotationAsync(
		annotation: Windows.ApplicationModel.Contacts.ContactAnnotation
	): Windows.Foundation.IPromiseWithIAsyncAction;
		findAnnotationListsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAnnotationsForContactAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findContactIdsByEmailAsync(
		emailAddress: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findContactIdsByPhoneNumberAsync(
		phoneNumber: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAnnotationListAsync(
		annotationListId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactAnnotationList>
	}

	declare class ContactBatch  {
		contacts: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.Contact>;
		status: Windows.ApplicationModel.Contacts.ContactBatchStatus
	}

	declare class ContactCardDelayedDataLoader  {
		close(): void;
		setData(contact: Windows.ApplicationModel.Contacts.Contact): void
	}

	declare class ContactCardOptions  {
		constructor(): this;
		headerKind: Windows.ApplicationModel.Contacts.ContactCardHeaderKind;
		initialTabKind: Windows.ApplicationModel.Contacts.ContactCardTabKind;
		serverSearchContactListIds: Windows.Foundation.Collections.IVector<string>
	}

	declare class ContactChange  {
		changeType: Windows.ApplicationModel.Contacts.ContactChangeType;
		contact: Windows.ApplicationModel.Contacts.Contact
	}

	declare class ContactChangeReader  {
		acceptChanges(): void;
		acceptChangesThrough(lastChangeToAccept: Windows.ApplicationModel.Contacts.ContactChange): void;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class ContactChangeTracker  {
		enable(): void;
		getChangeReader(): Windows.ApplicationModel.Contacts.ContactChangeReader;
		reset(): void
	}

	declare class ContactChangedDeferral  {
		complete(): void
	}

	declare class ContactChangedEventArgs  {
		getDeferral(): Windows.ApplicationModel.Contacts.ContactChangedDeferral
	}

	declare class ContactConnectedServiceAccount  {
		constructor(): this;
		id: string;
		serviceName: string
	}

	declare class ContactDate  {
		constructor(): this;
		day: number;
		description: string;
		kind: Windows.ApplicationModel.Contacts.ContactDateKind;
		month: number;
		year: number
	}

	declare class ContactEmail  {
		constructor(): this;
		address: string;
		description: string;
		kind: Windows.ApplicationModel.Contacts.ContactEmailKind
	}

	declare class ContactField  {
		constructor(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): this;
		constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): this;
		constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType): this;
		category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
		name: string;
		type: Windows.ApplicationModel.Contacts.ContactFieldType;
		value: string
	}

	declare class ContactFieldFactory  {
		constructor(): this;
		createField(
		value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory
	): Windows.ApplicationModel.Contacts.ContactField;
		createField(
		name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory
	): Windows.ApplicationModel.Contacts.ContactField;
		createField(
		value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType
	): Windows.ApplicationModel.Contacts.ContactField;
		createInstantMessage(
		userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory
	): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
		createInstantMessage(
		userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri
	): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
		createInstantMessage(userName: string): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
		createLocation(
		unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string
	): Windows.ApplicationModel.Contacts.ContactLocationField;
		createLocation(
		unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory
	): Windows.ApplicationModel.Contacts.ContactLocationField;
		createLocation(
		unstructuredAddress: string
	): Windows.ApplicationModel.Contacts.ContactLocationField
	}

	declare class ContactInformation  {
		customFields: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
		emails: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
		getThumbnailAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
		instantMessages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInstantMessageField>;
		locations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactLocationField>;
		name: string;
		phoneNumbers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
		queryCustomFields(
		customName: string
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>
	}

	declare class ContactInstantMessageField  {
		constructor(userName: string): this;
		constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): this;
		constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri): this;
		category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
		displayText: string;
		launchUri: Windows.Foundation.Uri;
		name: string;
		service: string;
		type: Windows.ApplicationModel.Contacts.ContactFieldType;
		userName: string;
		value: string
	}

	declare class ContactJobInfo  {
		constructor(): this;
		companyAddress: string;
		companyName: string;
		companyYomiName: string;
		department: string;
		description: string;
		manager: string;
		office: string;
		title: string
	}

	declare class ContactLaunchActionVerbs  {
		call: string;
		map: string;
		message: string;
		post: string;
		videoCall: string
	}

	declare class ContactList  {
		changeTracker: Windows.ApplicationModel.Contacts.ContactChangeTracker;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteContactAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		getContactAsync(
		contactId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		getContactFromRemoteIdAsync(
		remoteId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		getContactReader(
		options: Windows.ApplicationModel.Contacts.ContactQueryOptions
	): Windows.ApplicationModel.Contacts.ContactReader;
		getContactReader(): Windows.ApplicationModel.Contacts.ContactReader;
		getMeContactAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		id: string;
		isHidden: boolean;
		oncontactchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactList, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>;
		addEventListener(
		type: "contactchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactList, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>
	): void;
		removeEventListener(
		type: "contactchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactList, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>
	): void;
		otherAppReadAccess: Windows.ApplicationModel.Contacts.ContactListOtherAppReadAccess;
		otherAppWriteAccess: Windows.ApplicationModel.Contacts.ContactListOtherAppWriteAccess;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		saveContactAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sourceDisplayName: string;
		supportsServerSearch: boolean;
		syncManager: Windows.ApplicationModel.Contacts.ContactListSyncManager;
		userDataAccountId: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ContactListSyncManager  {
		lastAttemptedSyncTime: Date;
		lastSuccessfulSyncTime: Date;
		onsyncstatuschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactListSyncManager, any>;
		addEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactListSyncManager, any>
	): void;
		removeEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactListSyncManager, any>
	): void;
		status: Windows.ApplicationModel.Contacts.ContactListSyncStatus;
		syncAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ContactLocationField  {
		constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): this;
		constructor(unstructuredAddress: string): this;
		constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): this;
		category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
		city: string;
		country: string;
		name: string;
		postalCode: string;
		region: string;
		street: string;
		type: Windows.ApplicationModel.Contacts.ContactFieldType;
		unstructuredAddress: string;
		value: string
	}

	declare class ContactManager  {
		convertContactToVCardAsync(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
		convertContactToVCardAsync(
		contact: Windows.ApplicationModel.Contacts.Contact, maxBytes: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
		convertVCardToContactAsync(
		vCard: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		isShowContactCardSupported(): boolean;
		isShowDelayLoadedContactCardSupported(): boolean;
		requestAnnotationStoreAsync(
		accessType: Windows.ApplicationModel.Contacts.ContactAnnotationStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactAnnotationStore>;
		requestStoreAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactStore>;
		requestStoreAsync(
		accessType: Windows.ApplicationModel.Contacts.ContactStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactStore>;
		showContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, selection: Windows.Foundation.Rect
	): void;
		showContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): void;
		showContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, contactCardOptions: Windows.ApplicationModel.Contacts.ContactCardOptions
	): void;
		showDelayLoadedContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader;
		showDelayLoadedContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement, contactCardOptions: Windows.ApplicationModel.Contacts.ContactCardOptions
	): Windows.ApplicationModel.Contacts.ContactCardDelayedDataLoader;
		showFullContactCard(
		contact: Windows.ApplicationModel.Contacts.Contact, fullContactCardOptions: Windows.ApplicationModel.Contacts.FullContactCardOptions
	): void;
		systemDisplayNameOrder: Windows.ApplicationModel.Contacts.ContactNameOrder;
		systemSortOrder: Windows.ApplicationModel.Contacts.ContactNameOrder
	}

	declare class ContactMatchReason  {
		field: Windows.ApplicationModel.Contacts.ContactMatchReasonKind;
		segments: Windows.Foundation.Collections.IVectorView<Windows.Data.Text.TextSegment>;
		text: string
	}

	declare class ContactPhone  {
		constructor(): this;
		description: string;
		kind: Windows.ApplicationModel.Contacts.ContactPhoneKind;
		number: string
	}

	declare class ContactPicker  {
		constructor(): this;
		commitButtonText: string;
		desiredFields: Windows.Foundation.Collections.IVector<string>;
		desiredFieldsWithContactFieldType: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactFieldType>;
		pickContactAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		pickContactsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		pickMultipleContactsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		pickSingleContactAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactInformation>;
		selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode
	}

	declare class ContactQueryOptions  {
		constructor(): this;
		constructor(text: string, fields: Windows.ApplicationModel.Contacts.ContactQuerySearchFields): this;
		constructor(text: string): this;
		annotationListIds: Windows.Foundation.Collections.IVector<string>;
		contactListIds: Windows.Foundation.Collections.IVector<string>;
		desiredFields: Windows.ApplicationModel.Contacts.ContactQueryDesiredFields;
		desiredOperations: Windows.ApplicationModel.Contacts.ContactAnnotationOperations;
		includeContactsFromHiddenLists: boolean;
		textSearch: Windows.ApplicationModel.Contacts.ContactQueryTextSearch
	}

	declare class ContactQueryTextSearch  {
		fields: Windows.ApplicationModel.Contacts.ContactQuerySearchFields;
		searchScope: Windows.ApplicationModel.Contacts.ContactQuerySearchScope;
		text: string
	}

	declare class ContactReader  {
		getMatchingPropertiesWithMatchReason(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactMatchReason>;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactBatch>
	}

	declare class ContactSignificantOther  {
		constructor(): this;
		description: string;
		name: string;
		relationship: Windows.ApplicationModel.Contacts.ContactRelationship
	}

	declare class ContactStore  {
		aggregateContactManager: Windows.ApplicationModel.Contacts.AggregateContactManager;
		changeTracker: Windows.ApplicationModel.Contacts.ContactChangeTracker;
		createContactListAsync(
		displayName: string, userDataAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactList>;
		createContactListAsync(
		displayName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactList>;
		findContactListsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findContactsAsync(
		searchText: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.Contact>>;
		findContactsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.Contact>>;
		getContactAsync(
		contactId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		getContactListAsync(
		contactListId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.ContactList>;
		getContactReader(
		options: Windows.ApplicationModel.Contacts.ContactQueryOptions
	): Windows.ApplicationModel.Contacts.ContactReader;
		getContactReader(): Windows.ApplicationModel.Contacts.ContactReader;
		getMeContactAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Contacts.Contact>;
		oncontactchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactStore, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>;
		addEventListener(
		type: "contactchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactStore, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>
	): void;
		removeEventListener(
		type: "contactchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.ContactStore, Windows.ApplicationModel.Contacts.ContactChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ContactStoreNotificationTriggerDetails  {
		
	}

	declare class ContactWebsite  {
		constructor(): this;
		description: string;
		rawValue: any;
		uri: Windows.Foundation.Uri
	}

	declare class FullContactCardOptions  {
		constructor(): this;
		desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference
	}

	declare class KnownContactField  {
		convertNameToType(name: string): Windows.ApplicationModel.Contacts.ContactFieldType;
		convertTypeToName(type: Windows.ApplicationModel.Contacts.ContactFieldType): string;
		email: string;
		instantMessage: string;
		location: string;
		phoneNumber: string
	}

	
}

declare module 'Provider' {
	declare type PerceptionStartFaceAuthenticationHandler = (
		sender: Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup
	) => void;

	declare type PerceptionStopFaceAuthenticationHandler = (
		sender: Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup
	) => void;

	declare interface IAdcProvider {
		getControllers(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Adc.Provider.IAdcControllerProvider>
	}

	declare interface IAdcControllerProvider {
		acquireChannel(channel: number): void,
		isChannelModeSupported(channelMode: Windows.Devices.Adc.Provider.ProviderAdcChannelMode): boolean,
		readValue(channelNumber: number): number,
		releaseChannel(channel: number): void,
		channelCount: number,
		channelMode: Windows.Devices.Adc.Provider.ProviderAdcChannelMode,
		maxValue: number,
		minValue: number,
		resolutionInBits: number
	}

	declare interface IGpioProvider {
		getControllers: any
	}

	declare interface II2cProvider {
		getControllersAsync: any
	}

	declare interface IPerceptionFrameProvider {
		setProperty(
		value: Windows.Devices.Perception.Provider.PerceptionPropertyChangeRequest
	): void,
		start(): void,
		stop(): void,
		available: boolean,
		frameProviderInfo: Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo,
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare interface IPerceptionFrameProviderManager {
		getFrameProvider(
		frameProviderInfo: Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo
	): Windows.Devices.Perception.Provider.IPerceptionFrameProvider
	}

	declare interface ISpiProvider {
		getControllersAsync: any
	}

	declare interface IWebAccountProviderOperation {
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind
	}

		declare class ContactPickerUI  {
		addContact(
		id: string, contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
		addContact(
		contact: Windows.ApplicationModel.Contacts.Contact
	): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
		containsContact(id: string): boolean;
		desiredFields: Windows.Foundation.Collections.IVectorView<string>;
		desiredFieldsWithContactFieldType: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.ContactFieldType>;
		oncontactremoved: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI, Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>;
		addEventListener(
		type: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI, Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>
	): void;
		removeEventListener(
		type: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI, Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>
	): void;
		removeContact(id: string): void;
		selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ContactRemovedEventArgs  {
		id: string
	}

	declare class GpioPinProviderValueChangedEventArgs  {
		edge: any
	}

	declare class ProviderI2cConnectionSettings  {
		busSpeed: any;
		sharingMode: any;
		slaveAddress: any
	}

	declare class KnownPerceptionFrameKind  {
		color: string;
		depth: string;
		infrared: string
	}

	declare class PerceptionControlGroup  {
		constructor(ids: Windows.Foundation.Collections.IIterable<string>): this;
		frameProviderIds: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class PerceptionCorrelation  {
		constructor(targetId: string, position: Windows.Foundation.Numerics.Vector3, orientation: Windows.Foundation.Numerics.Quaternion): this;
		orientation: Windows.Foundation.Numerics.Quaternion;
		position: Windows.Foundation.Numerics.Vector3;
		targetId: string
	}

	declare class PerceptionCorrelationGroup  {
		constructor(relativeLocations: Windows.Foundation.Collections.IIterable<Windows.Devices.Perception.Provider.PerceptionCorrelation>): this;
		relativeLocations: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.Provider.PerceptionCorrelation>
	}

	declare class PerceptionFaceAuthenticationGroup  {
		constructor(ids: Windows.Foundation.Collections.IIterable<string>, startHandler: Windows.Devices.Perception.Provider.PerceptionStartFaceAuthenticationHandler, stopHandler: Windows.Devices.Perception.Provider.PerceptionStopFaceAuthenticationHandler): this;
		frameProviderIds: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class PerceptionFrame  {
		frameData: Windows.Foundation.IMemoryBuffer;
		properties: Windows.Foundation.Collections.ValueSet;
		relativeTime: number
	}

	declare class PerceptionFrameProviderInfo  {
		constructor(): this;
		deviceKind: string;
		displayName: string;
		frameKind: string;
		hidden: boolean;
		id: string
	}

	declare class PerceptionFrameProviderManagerService  {
		publishFrameForProvider(
		provider: Windows.Devices.Perception.Provider.IPerceptionFrameProvider, frame: Windows.Devices.Perception.Provider.PerceptionFrame
	): void;
		registerControlGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, controlGroup: Windows.Devices.Perception.Provider.PerceptionControlGroup
	): void;
		registerCorrelationGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, correlationGroup: Windows.Devices.Perception.Provider.PerceptionCorrelationGroup
	): void;
		registerFaceAuthenticationGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, faceAuthenticationGroup: Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup
	): void;
		registerFrameProviderInfo(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, frameProviderInfo: Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo
	): void;
		unregisterControlGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, controlGroup: Windows.Devices.Perception.Provider.PerceptionControlGroup
	): void;
		unregisterCorrelationGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, correlationGroup: Windows.Devices.Perception.Provider.PerceptionCorrelationGroup
	): void;
		unregisterFaceAuthenticationGroup(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, faceAuthenticationGroup: Windows.Devices.Perception.Provider.PerceptionFaceAuthenticationGroup
	): void;
		unregisterFrameProviderInfo(
		manager: Windows.Devices.Perception.Provider.IPerceptionFrameProviderManager, frameProviderInfo: Windows.Devices.Perception.Provider.PerceptionFrameProviderInfo
	): void;
		updateAvailabilityForProvider(
		provider: Windows.Devices.Perception.Provider.IPerceptionFrameProvider, available: boolean
	): void
	}

	declare class PerceptionPropertyChangeRequest  {
		getDeferral(): Windows.Foundation.Deferral;
		name: string;
		status: Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus;
		value: any
	}

	declare class PerceptionVideoFrameAllocator  {
		constructor(maxOutstandingFrameCountForWrite: number, format: Windows.Graphics.Imaging.BitmapPixelFormat, resolution: Windows.Foundation.Size, alpha: Windows.Graphics.Imaging.BitmapAlphaMode): this;
		allocateFrame(): Windows.Devices.Perception.Provider.PerceptionFrame;
		close(): void;
		copyFromVideoFrame(
		frame: Windows.Media.VideoFrame
	): Windows.Devices.Perception.Provider.PerceptionFrame
	}

	declare class ProviderSpiConnectionSettings  {
		chipSelectLine: any;
		clockFrequency: any;
		dataBitLength: any;
		mode: any;
		sharingMode: any
	}

	declare class WebAccountClientView  {
		constructor(viewType: Windows.Security.Authentication.Web.Provider.WebAccountClientViewType, applicationCallbackUri: Windows.Foundation.Uri, accountPairwiseId: string): this;
		constructor(viewType: Windows.Security.Authentication.Web.Provider.WebAccountClientViewType, applicationCallbackUri: Windows.Foundation.Uri): this;
		accountPairwiseId: string;
		applicationCallbackUri: Windows.Foundation.Uri;
		type: Windows.Security.Authentication.Web.Provider.WebAccountClientViewType
	}

	declare class WebAccountManager  {
		addWebAccountAsync(
		webAccountId: string, webAccountUserName: string, props: Windows.Foundation.Collections.IMapView<string, string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccount>;
		addWebAccountAsync(
		webAccountId: string, webAccountUserName: string, props: Windows.Foundation.Collections.IMapView<string, string>, scope: Windows.Security.Authentication.Web.Provider.WebAccountScope
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.WebAccount>;
		clearViewAsync(
		webAccount: Windows.Security.Credentials.WebAccount, applicationCallbackUri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncAction;
		clearWebAccountPictureAsync(
		webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteWebAccountAsync(
		webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Foundation.IPromiseWithIAsyncAction;
		findAllProviderWebAccountsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getScope(
		webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Security.Authentication.Web.Provider.WebAccountScope;
		getViewsAsync(
		webAccount: Windows.Security.Credentials.WebAccount
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		pullCookiesAsync(
		uriString: string, callerPFN: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		pushCookiesAsync(
		uri: Windows.Foundation.Uri, cookies: Windows.Foundation.Collections.IVectorView<Windows.Web.Http.HttpCookie>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setScopeAsync(
		webAccount: Windows.Security.Credentials.WebAccount, scope: Windows.Security.Authentication.Web.Provider.WebAccountScope
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setViewAsync(
		webAccount: Windows.Security.Credentials.WebAccount, view: Windows.Security.Authentication.Web.Provider.WebAccountClientView
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setWebAccountPictureAsync(
		webAccount: Windows.Security.Credentials.WebAccount, webAccountPicture: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		updateWebAccountPropertiesAsync(
		webAccount: Windows.Security.Credentials.WebAccount, webAccountUserName: string, additionalProperties: Windows.Foundation.Collections.IMapView<string, string>
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class WebAccountProviderAddAccountOperation  {
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		reportCompleted(): void
	}

	declare class WebAccountProviderDeleteAccountOperation  {
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		reportCompleted(): void;
		reportError(value: Windows.Security.Authentication.Web.Core.WebProviderError): void;
		webAccount: Windows.Security.Credentials.WebAccount
	}

	declare class WebAccountProviderGetTokenSilentOperation  {
		cacheExpirationTime: Date;
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		providerRequest: Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest;
		providerResponses: Windows.Foundation.Collections.IVector<Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse>;
		reportCompleted(): void;
		reportError(value: Windows.Security.Authentication.Web.Core.WebProviderError): void;
		reportUserInteractionRequired(): void;
		reportUserInteractionRequired(value: Windows.Security.Authentication.Web.Core.WebProviderError): void
	}

	declare class WebAccountProviderManageAccountOperation  {
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		reportCompleted(): void;
		webAccount: Windows.Security.Credentials.WebAccount
	}

	declare class WebAccountProviderRequestTokenOperation  {
		cacheExpirationTime: Date;
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		providerRequest: Windows.Security.Authentication.Web.Provider.WebProviderTokenRequest;
		providerResponses: Windows.Foundation.Collections.IVector<Windows.Security.Authentication.Web.Provider.WebProviderTokenResponse>;
		reportCompleted(): void;
		reportError(value: Windows.Security.Authentication.Web.Core.WebProviderError): void;
		reportUserCanceled(): void
	}

	declare class WebAccountProviderRetrieveCookiesOperation  {
		applicationCallbackUri: Windows.Foundation.Uri;
		context: Windows.Foundation.Uri;
		cookies: Windows.Foundation.Collections.IVector<Windows.Web.Http.HttpCookie>;
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		reportCompleted(): void;
		reportError(value: Windows.Security.Authentication.Web.Core.WebProviderError): void;
		uri: Windows.Foundation.Uri
	}

	declare class WebAccountProviderSignOutAccountOperation  {
		applicationCallbackUri: Windows.Foundation.Uri;
		clientId: string;
		kind: Windows.Security.Authentication.Web.Provider.WebAccountProviderOperationKind;
		reportCompleted(): void;
		reportError(value: Windows.Security.Authentication.Web.Core.WebProviderError): void;
		webAccount: Windows.Security.Credentials.WebAccount
	}

	declare class WebAccountProviderTriggerDetails  {
		operation: Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation
	}

	declare class WebProviderTokenRequest  {
		applicationCallbackUri: Windows.Foundation.Uri;
		clientRequest: Windows.Security.Authentication.Web.Core.WebTokenRequest;
		getApplicationTokenBindingKeyAsync(
		keyType: Windows.Security.Authentication.Web.TokenBindingKeyType, target: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Cryptography.Core.CryptographicKey>;
		webAccountSelectionOptions: Windows.Security.Authentication.Web.Provider.WebAccountSelectionOptions;
		webAccounts: Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.WebAccount>
	}

	declare class WebProviderTokenResponse  {
		constructor(webTokenResponse: Windows.Security.Authentication.Web.Core.WebTokenResponse): this;
		clientResponse: Windows.Security.Authentication.Web.Core.WebTokenResponse
	}

	declare class FileOpenPickerUI  {
		addFile(
		id: string, file: Windows.Storage.IStorageFile
	): Windows.Storage.Pickers.Provider.AddFileResult;
		allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
		canAddFile(file: Windows.Storage.IStorageFile): boolean;
		containsFile(id: string): boolean;
		onclosing: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.PickerClosingEventArgs>;
		addEventListener(
		type: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.PickerClosingEventArgs>
	): void;
		removeEventListener(
		type: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.PickerClosingEventArgs>
	): void;
		onfileremoved: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.FileRemovedEventArgs>;
		addEventListener(
		type: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.FileRemovedEventArgs>
	): void;
		removeEventListener(
		type: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI, Windows.Storage.Pickers.Provider.FileRemovedEventArgs>
	): void;
		removeFile(id: string): void;
		selectionMode: Windows.Storage.Pickers.Provider.FileSelectionMode;
		settingsIdentifier: string;
		title: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class FileRemovedEventArgs  {
		id: string
	}

	declare class FileSavePickerUI  {
		allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
		fileName: string;
		onfilenamechanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, any>;
		addEventListener(
		type: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, any>
	): void;
		removeEventListener(
		type: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, any>
	): void;
		ontargetfilerequested: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>;
		addEventListener(
		type: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>
	): void;
		removeEventListener(
		type: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI, Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>
	): void;
		settingsIdentifier: string;
		title: string;
		trySetFileName(value: string): Windows.Storage.Pickers.Provider.SetFileNameResult;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PickerClosingDeferral  {
		complete(): void
	}

	declare class PickerClosingEventArgs  {
		closingOperation: Windows.Storage.Pickers.Provider.PickerClosingOperation;
		isCanceled: boolean
	}

	declare class PickerClosingOperation  {
		deadline: Date;
		getDeferral(): Windows.Storage.Pickers.Provider.PickerClosingDeferral
	}

	declare class TargetFileRequest  {
		getDeferral(): Windows.Storage.Pickers.Provider.TargetFileRequestDeferral;
		targetFile: Windows.Storage.IStorageFile
	}

	declare class TargetFileRequestDeferral  {
		complete(): void
	}

	declare class TargetFileRequestedEventArgs  {
		request: Windows.Storage.Pickers.Provider.TargetFileRequest
	}

	declare class CachedFileUpdater  {
		setUpdateInformation(
		file: Windows.Storage.IStorageFile, contentId: string, readMode: Windows.Storage.Provider.ReadActivationMode, writeMode: Windows.Storage.Provider.WriteActivationMode, options: Windows.Storage.Provider.CachedFileOptions
	): void
	}

	declare class CachedFileUpdaterUI  {
		getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
		onfileupdaterequested: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, Windows.Storage.Provider.FileUpdateRequestedEventArgs>;
		addEventListener(
		type: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, Windows.Storage.Provider.FileUpdateRequestedEventArgs>
	): void;
		removeEventListener(
		type: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, Windows.Storage.Provider.FileUpdateRequestedEventArgs>
	): void;
		onuirequested: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, any>;
		addEventListener(
		type: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, any>
	): void;
		removeEventListener(
		type: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI, any>
	): void;
		title: string;
		uiStatus: Windows.Storage.Provider.UIStatus;
		updateRequest: Windows.Storage.Provider.FileUpdateRequest;
		updateTarget: Windows.Storage.Provider.CachedFileTarget;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class FileUpdateRequest  {
		contentId: string;
		file: Windows.Storage.StorageFile;
		getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
		status: Windows.Storage.Provider.FileUpdateStatus;
		updateLocalFile(value: Windows.Storage.IStorageFile): void;
		userInputNeededMessage: string
	}

	declare class FileUpdateRequestDeferral  {
		complete(): void
	}

	declare class FileUpdateRequestedEventArgs  {
		request: Windows.Storage.Provider.FileUpdateRequest
	}

	
}

declare module 'DataTransfer' {
	declare type DataProviderHandler = (request: Windows.ApplicationModel.DataTransfer.DataProviderRequest) => void;

			declare class Clipboard  {
		clear(): void;
		flush(): void;
		getContent(): Windows.ApplicationModel.DataTransfer.DataPackageView;
		oncontentchanged: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
		setContent(content: Windows.ApplicationModel.DataTransfer.DataPackage): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DataPackage  {
		constructor(): this;
		getView(): Windows.ApplicationModel.DataTransfer.DataPackageView;
		ondestroyed: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, any>;
		addEventListener(
		type: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, any>
	): void;
		removeEventListener(
		type: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, any>
	): void;
		onoperationcompleted: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>;
		addEventListener(
		type: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>
	): void;
		removeEventListener(
		type: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage, Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>
	): void;
		properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
		requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
		resourceMap: Windows.Foundation.Collections.IMap<string, Windows.Storage.Streams.RandomAccessStreamReference>;
		setApplicationLink(value: Windows.Foundation.Uri): void;
		setBitmap(value: Windows.Storage.Streams.RandomAccessStreamReference): void;
		setData(formatId: string, value: any): void;
		setDataProvider(
		formatId: string, delayRenderer: Windows.ApplicationModel.DataTransfer.DataProviderHandler
	): void;
		setHtmlFormat(value: string): void;
		setRtf(value: string): void;
		setStorageItems(
		value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>
	): void;
		setStorageItems(
		value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>, readOnly: boolean
	): void;
		setText(value: string): void;
		setUri(value: Windows.Foundation.Uri): void;
		setWebLink(value: Windows.Foundation.Uri): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DataPackagePropertySet  {
		applicationListingUri: Windows.Foundation.Uri;
		applicationName: string;
		clear(): void;
		contentSourceApplicationLink: Windows.Foundation.Uri;
		contentSourceWebLink: Windows.Foundation.Uri;
		description: string;
		enterpriseId: string;
		fileTypes: Windows.Foundation.Collections.IVector<string>;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		logoBackgroundColor: Windows.UI.Color;
		lookup(key: string): any;
		packageFamilyName: string;
		remove(key: string): void;
		size: number;
		square30x30Logo: Windows.Storage.Streams.IRandomAccessStreamReference;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		title: string
	}

	declare class DataPackagePropertySetView  {
		applicationListingUri: Windows.Foundation.Uri;
		applicationName: string;
		contentSourceApplicationLink: Windows.Foundation.Uri;
		contentSourceWebLink: Windows.Foundation.Uri;
		description: string;
		enterpriseId: string;
		fileTypes: Windows.Foundation.Collections.IVectorView<string>;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		hasKey(key: string): boolean;
		logoBackgroundColor: Windows.UI.Color;
		lookup(key: string): any;
		packageFamilyName: string;
		size: number;
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<string, any>,
		second: Windows.Foundation.Collections.IMapView<string, any>
	};
		square30x30Logo: Windows.Storage.Streams.IRandomAccessStreamReference;
		thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
		title: string
	}

	declare class DataPackageView  {
		availableFormats: Windows.Foundation.Collections.IVectorView<string>;
		contains(formatId: string): boolean;
		getApplicationLinkAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Uri>;
		getBitmapAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
		getDataAsync(formatId: string): Windows.Foundation.IPromiseWithIAsyncOperation<any>;
		getHtmlFormatAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getResourceMapAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMapView<any, any>>;
		getRtfAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getStorageItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getTextAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getTextAsync(formatId: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getUriAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Uri>;
		getWebLinkAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Uri>;
		properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView;
		reportOperationCompleted(value: Windows.ApplicationModel.DataTransfer.DataPackageOperation): void;
		requestAccessAsync(
		enterpriseId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>;
		requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
		setAcceptedFormatId(formatId: string): void;
		unlockAndAssumeEnterpriseIdentity(): Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult
	}

	declare class DataProviderDeferral  {
		complete(): void
	}

	declare class DataProviderRequest  {
		deadline: Date;
		formatId: string;
		getDeferral(): Windows.ApplicationModel.DataTransfer.DataProviderDeferral;
		setData(value: any): void
	}

	declare class DataRequest  {
		data: Windows.ApplicationModel.DataTransfer.DataPackage;
		deadline: Date;
		failWithDisplayText(value: string): void;
		getDeferral(): Windows.ApplicationModel.DataTransfer.DataRequestDeferral
	}

	declare class DataRequestDeferral  {
		complete(): void
	}

	declare class DataRequestedEventArgs  {
		request: Windows.ApplicationModel.DataTransfer.DataRequest
	}

	declare class DataTransferManager  {
		getForCurrentView(): Windows.ApplicationModel.DataTransfer.DataTransferManager;
		showShareUI(): void;
		ondatarequested: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>;
		addEventListener(
		type: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>
	): void;
		removeEventListener(
		type: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>
	): void;
		ontargetapplicationchosen: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>;
		addEventListener(
		type: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>
	): void;
		removeEventListener(
		type: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager, Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class HtmlFormatHelper  {
		createHtmlFormat(htmlFragment: string): string;
		getStaticFragment(htmlFormat: string): string
	}

	declare class OperationCompletedEventArgs  {
		acceptedFormatId: any;
		operation: Windows.ApplicationModel.DataTransfer.DataPackageOperation
	}

	declare class SharedStorageAccessManager  {
		addFile(file: Windows.Storage.IStorageFile): string;
		redeemTokenForFileAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		removeFile(token: string): void
	}

	declare class StandardDataFormats  {
		applicationLink: string;
		bitmap: string;
		html: string;
		rtf: string;
		storageItems: string;
		text: string;
		uri: string;
		webLink: string
	}

	declare class TargetApplicationChosenEventArgs  {
		applicationName: string
	}

	
}

declare module 'ShareTarget' {
				declare class QuickLink  {
		constructor(): this;
		id: string;
		supportedDataFormats: Windows.Foundation.Collections.IVector<string>;
		supportedFileTypes: Windows.Foundation.Collections.IVector<string>;
		thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
		title: string
	}

	declare class ShareOperation  {
		data: Windows.ApplicationModel.DataTransfer.DataPackageView;
		dismissUI(): void;
		quickLinkId: string;
		removeThisQuickLink(): void;
		reportCompleted(): void;
		reportCompleted(quicklink: Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
		reportDataRetrieved(): void;
		reportError(value: string): void;
		reportStarted(): void;
		reportSubmittedBackgroundTask(): void
	}

	
}

declare module 'Email' {
				declare class EmailAttachment  {
		constructor(): this;
		constructor(filename: string, data: Windows.Storage.Streams.IRandomAccessStreamReference): this;
		constructor(fileName: string, data: Windows.Storage.Streams.IRandomAccessStreamReference, mimeType: string): this;
		contentId: string;
		contentLocation: string;
		data: Windows.Storage.Streams.IRandomAccessStreamReference;
		downloadState: Windows.ApplicationModel.Email.EmailAttachmentDownloadState;
		estimatedDownloadSizeInBytes: number;
		fileName: string;
		id: string;
		isFromBaseMessage: boolean;
		isInline: boolean;
		mimeType: string
	}

	declare class EmailConversation  {
		findMessagesAsync(
		count: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findMessagesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		flagState: Windows.ApplicationModel.Email.EmailFlagState;
		hasAttachment: boolean;
		id: string;
		importance: Windows.ApplicationModel.Email.EmailImportance;
		lastEmailResponseKind: Windows.ApplicationModel.Email.EmailMessageResponseKind;
		latestSender: Windows.ApplicationModel.Email.EmailRecipient;
		mailboxId: string;
		messageCount: number;
		mostRecentMessageId: string;
		mostRecentMessageTime: Date;
		preview: string;
		subject: string;
		unreadMessageCount: number
	}

	declare class EmailConversationBatch  {
		conversations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Email.EmailConversation>;
		status: Windows.ApplicationModel.Email.EmailBatchStatus
	}

	declare class EmailConversationReader  {
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailConversationBatch>
	}

	declare class EmailFolder  {
		createFolderAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailFolder>;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		findChildFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getConversationReader(): Windows.ApplicationModel.Email.EmailConversationReader;
		getConversationReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailConversationReader;
		getMessageAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMessage>;
		getMessageCountsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailItemCounts>;
		getMessageReader(): Windows.ApplicationModel.Email.EmailMessageReader;
		getMessageReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailMessageReader;
		id: string;
		isSyncEnabled: boolean;
		kind: Windows.ApplicationModel.Email.EmailSpecialFolderKind;
		lastSuccessfulSyncTime: Date;
		mailboxId: string;
		parentFolderId: string;
		remoteId: string;
		saveMessageAsync(
		message: Windows.ApplicationModel.Email.EmailMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tryMoveAsync(
		newParentFolder: Windows.ApplicationModel.Email.EmailFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryMoveAsync(
		newParentFolder: Windows.ApplicationModel.Email.EmailFolder, newFolderName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		trySaveAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class EmailIrmInfo  {
		constructor(): this;
		constructor(expiration: Date, irmTemplate: Windows.ApplicationModel.Email.EmailIrmTemplate): this;
		canEdit: boolean;
		canExtractData: boolean;
		canForward: boolean;
		canModifyRecipientsOnResponse: boolean;
		canPrintData: boolean;
		canRemoveIrmOnResponse: boolean;
		canReply: boolean;
		canReplyAll: boolean;
		expirationDate: Date;
		isIrmOriginator: boolean;
		isProgramaticAccessAllowed: boolean;
		template: Windows.ApplicationModel.Email.EmailIrmTemplate
	}

	declare class EmailIrmTemplate  {
		constructor(id: string, name: string, description: string): this;
		constructor(): this;
		description: string;
		id: string;
		name: string
	}

	declare class EmailItemCounts  {
		flagged: number;
		important: number;
		total: number;
		unread: number
	}

	declare class EmailMailbox  {
		capabilities: Windows.ApplicationModel.Email.EmailMailboxCapabilities;
		changeMessageFlagStateAsync(
		messageId: string, flagState: Windows.ApplicationModel.Email.EmailFlagState
	): Windows.Foundation.IPromiseWithIAsyncAction;
		changeTracker: Windows.ApplicationModel.Email.EmailMailboxChangeTracker;
		createResponseMessageAsync(
		messageId: string, responseType: Windows.ApplicationModel.Email.EmailMessageResponseKind, subject: string, responseHeaderType: Windows.ApplicationModel.Email.EmailMessageBodyKind, responseHeader: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMessage>;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteMessageAsync(messageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		downloadAttachmentAsync(attachmentId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		downloadMessageAsync(messageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		getConversationAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailConversation>;
		getConversationReader(): Windows.ApplicationModel.Email.EmailConversationReader;
		getConversationReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailConversationReader;
		getFolderAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailFolder>;
		getMessageAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMessage>;
		getMessageReader(): Windows.ApplicationModel.Email.EmailMessageReader;
		getMessageReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailMessageReader;
		getSpecialFolderAsync(
		folderType: Windows.ApplicationModel.Email.EmailSpecialFolderKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailFolder>;
		id: string;
		isDataEncryptedUnderLock: boolean;
		isOwnedByCurrentApp: boolean;
		linkedMailboxId: string;
		mailAddress: string;
		mailAddressAliases: Windows.Foundation.Collections.IVector<string>;
		markFolderAsSeenAsync(folderId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		markFolderSyncEnabledAsync(
		folderId: string, isSyncEnabled: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction;
		markMessageAsSeenAsync(messageId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		markMessageReadAsync(
		messageId: string, isRead: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction;
		networkAccountId: string;
		networkId: string;
		onmailboxchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailbox, Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs>;
		addEventListener(
		type: "mailboxchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailbox, Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs>
	): void;
		removeEventListener(
		type: "mailboxchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailbox, Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs>
	): void;
		otherAppReadAccess: Windows.ApplicationModel.Email.EmailMailboxOtherAppReadAccess;
		otherAppWriteAccess: Windows.ApplicationModel.Email.EmailMailboxOtherAppWriteAccess;
		policies: Windows.ApplicationModel.Email.EmailMailboxPolicies;
		resolveRecipientsAsync(
		recipients: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		saveDraftAsync(
		message: Windows.ApplicationModel.Email.EmailMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sendMessageAsync(
		message: Windows.ApplicationModel.Email.EmailMessage
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sendMessageAsync(
		message: Windows.ApplicationModel.Email.EmailMessage, smartSend: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sourceDisplayName: string;
		syncManager: Windows.ApplicationModel.Email.EmailMailboxSyncManager;
		tryCreateFolderAsync(
		parentFolderId: string, name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult>;
		tryDeleteFolderAsync(
		folderId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxDeleteFolderStatus>;
		tryEmptyFolderAsync(
		folderId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxEmptyFolderStatus>;
		tryForwardMeetingAsync(
		meeting: Windows.ApplicationModel.Email.EmailMessage, recipients: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Email.EmailRecipient>, subject: string, forwardHeaderType: Windows.ApplicationModel.Email.EmailMessageBodyKind, forwardHeader: string, comment: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryGetAutoReplySettingsAsync(
		requestedFormat: Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings>;
		tryMoveFolderAsync(
		folderId: string, newParentFolderId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryMoveFolderAsync(
		folderId: string, newParentFolderId: string, newFolderName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryMoveMessageAsync(
		messageId: string, newParentFolderId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryProposeNewTimeForMeetingAsync(
		meeting: Windows.ApplicationModel.Email.EmailMessage, newStartTime: Date, newDuration: number, subject: string, comment: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		trySetAutoReplySettingsAsync(
		autoReplySettings: Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryUpdateMeetingResponseAsync(
		meeting: Windows.ApplicationModel.Email.EmailMessage, response: Windows.ApplicationModel.Email.EmailMeetingResponseType, subject: string, comment: string, sendUpdate: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		userDataAccountId: string;
		validateCertificatesAsync(
		certificates: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.Certificate>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class EmailMailboxAction  {
		changeNumber: number;
		kind: Windows.ApplicationModel.Email.EmailMailboxActionKind
	}

	declare class EmailMailboxAutoReply  {
		isEnabled: boolean;
		response: string
	}

	declare class EmailMailboxAutoReplySettings  {
		constructor(): this;
		endTime: Date;
		internalReply: Windows.ApplicationModel.Email.EmailMailboxAutoReply;
		isEnabled: boolean;
		knownExternalReply: Windows.ApplicationModel.Email.EmailMailboxAutoReply;
		responseKind: Windows.ApplicationModel.Email.EmailMailboxAutoReplyMessageResponseKind;
		startTime: Date;
		unknownExternalReply: Windows.ApplicationModel.Email.EmailMailboxAutoReply
	}

	declare class EmailMailboxCapabilities  {
		canCreateFolder: boolean;
		canDeleteFolder: boolean;
		canEmptyFolder: boolean;
		canForwardMeetings: any;
		canGetAndSetExternalAutoReplies: any;
		canGetAndSetInternalAutoReplies: any;
		canMoveFolder: boolean;
		canProposeNewTimeForMeetings: any;
		canResolveRecipients: boolean;
		canServerSearchFolders: any;
		canServerSearchMailbox: any;
		canSmartSend: any;
		canUpdateMeetingResponses: any;
		canValidateCertificates: boolean
	}

	declare class EmailMailboxChange  {
		changeType: Windows.ApplicationModel.Email.EmailMailboxChangeType;
		folder: Windows.ApplicationModel.Email.EmailFolder;
		mailboxActions: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Email.EmailMailboxAction>;
		message: Windows.ApplicationModel.Email.EmailMessage
	}

	declare class EmailMailboxChangeReader  {
		acceptChanges(): void;
		acceptChangesThrough(
		lastChangeToAcknowledge: Windows.ApplicationModel.Email.EmailMailboxChange
	): void;
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class EmailMailboxChangeTracker  {
		enable(): void;
		getChangeReader(): Windows.ApplicationModel.Email.EmailMailboxChangeReader;
		isTracking: boolean;
		reset(): void
	}

	declare class EmailMailboxChangedDeferral  {
		complete(): void
	}

	declare class EmailMailboxChangedEventArgs  {
		getDeferral(): Windows.ApplicationModel.Email.EmailMailboxChangedDeferral
	}

	declare class EmailMailboxCreateFolderResult  {
		folder: Windows.ApplicationModel.Email.EmailFolder;
		status: Windows.ApplicationModel.Email.EmailMailboxCreateFolderStatus
	}

	declare class EmailMailboxPolicies  {
		allowSmimeSoftCertificates: boolean;
		allowedSmimeEncryptionAlgorithmNegotiation: Windows.ApplicationModel.Email.EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation;
		mustEncryptSmimeMessages: boolean;
		mustSignSmimeMessages: boolean;
		requiredSmimeEncryptionAlgorithm: Windows.ApplicationModel.Email.EmailMailboxSmimeEncryptionAlgorithm;
		requiredSmimeSigningAlgorithm: Windows.ApplicationModel.Email.EmailMailboxSmimeSigningAlgorithm
	}

	declare class EmailMailboxSyncManager  {
		lastAttemptedSyncTime: Date;
		lastSuccessfulSyncTime: Date;
		onsyncstatuschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailboxSyncManager, any>;
		addEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailboxSyncManager, any>
	): void;
		removeEventListener(
		type: "syncstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Email.EmailMailboxSyncManager, any>
	): void;
		status: Windows.ApplicationModel.Email.EmailMailboxSyncStatus;
		syncAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class EmailManager  {
		requestStoreAsync(
		accessType: Windows.ApplicationModel.Email.EmailStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailStore>;
		showComposeNewEmailAsync(
		message: Windows.ApplicationModel.Email.EmailMessage
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class EmailMeetingInfo  {
		constructor(): this;
		allowNewTimeProposal: boolean;
		appointmentOriginalStartTime: Date;
		appointmentRoamingId: string;
		duration: number;
		isAllDay: boolean;
		isReportedOutOfDateByServer: boolean;
		isResponseRequested: boolean;
		location: string;
		proposedDuration: number;
		proposedStartTime: Date;
		recurrence: Windows.ApplicationModel.Appointments.AppointmentRecurrence;
		recurrenceStartTime: Date;
		remoteChangeNumber: number;
		startTime: Date
	}

	declare class EmailMessage  {
		constructor(): this;
		allowInternetImages: boolean;
		attachments: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Email.EmailAttachment>;
		bcc: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Email.EmailRecipient>;
		body: string;
		cc: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Email.EmailRecipient>;
		changeNumber: number;
		conversationId: string;
		downloadState: Windows.ApplicationModel.Email.EmailMessageDownloadState;
		estimatedDownloadSizeInBytes: number;
		flagState: Windows.ApplicationModel.Email.EmailFlagState;
		folderId: string;
		getBodyStream(
		type: Windows.ApplicationModel.Email.EmailMessageBodyKind
	): Windows.Storage.Streams.IRandomAccessStreamReference;
		hasPartialBodies: boolean;
		id: string;
		importance: Windows.ApplicationModel.Email.EmailImportance;
		inResponseToMessageId: string;
		irmInfo: Windows.ApplicationModel.Email.EmailIrmInfo;
		isDraftMessage: boolean;
		isRead: boolean;
		isSeen: boolean;
		isServerSearchMessage: boolean;
		isSmartSendable: boolean;
		lastResponseKind: Windows.ApplicationModel.Email.EmailMessageResponseKind;
		mailboxId: string;
		meetingInfo: Windows.ApplicationModel.Email.EmailMeetingInfo;
		messageClass: string;
		normalizedSubject: string;
		originalCodePage: number;
		preview: string;
		remoteId: string;
		sender: Windows.ApplicationModel.Email.EmailRecipient;
		sentTime: Date;
		setBodyStream(
		type: Windows.ApplicationModel.Email.EmailMessageBodyKind, stream: Windows.Storage.Streams.IRandomAccessStreamReference
	): void;
		smimeData: Windows.Storage.Streams.IRandomAccessStreamReference;
		smimeKind: Windows.ApplicationModel.Email.EmailMessageSmimeKind;
		subject: string;
		to: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Email.EmailRecipient>
	}

	declare class EmailMessageBatch  {
		messages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Email.EmailMessage>;
		status: Windows.ApplicationModel.Email.EmailBatchStatus
	}

	declare class EmailMessageReader  {
		readBatchAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMessageBatch>
	}

	declare class EmailQueryOptions  {
		constructor(): this;
		constructor(text: string, fields: Windows.ApplicationModel.Email.EmailQuerySearchFields): this;
		constructor(text: string): this;
		folderIds: Windows.Foundation.Collections.IVector<string>;
		kind: Windows.ApplicationModel.Email.EmailQueryKind;
		sortDirection: Windows.ApplicationModel.Email.EmailQuerySortDirection;
		sortProperty: Windows.ApplicationModel.Email.EmailQuerySortProperty;
		textSearch: Windows.ApplicationModel.Email.EmailQueryTextSearch
	}

	declare class EmailQueryTextSearch  {
		fields: Windows.ApplicationModel.Email.EmailQuerySearchFields;
		searchScope: Windows.ApplicationModel.Email.EmailQuerySearchScope;
		text: string
	}

	declare class EmailRecipient  {
		constructor(): this;
		constructor(address: string, name: string): this;
		constructor(address: string): this;
		address: string;
		name: string
	}

	declare class EmailRecipientResolutionResult  {
		publicKeys: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		status: Windows.ApplicationModel.Email.EmailRecipientResolutionStatus
	}

	declare class EmailStore  {
		createMailboxAsync(
		accountName: string, accountAddress: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailbox>;
		createMailboxAsync(
		accountName: string, accountAddress: string, userDataAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailbox>;
		findMailboxesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getConversationAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailConversation>;
		getConversationReader(): Windows.ApplicationModel.Email.EmailConversationReader;
		getConversationReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailConversationReader;
		getFolderAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailFolder>;
		getMailboxAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMailbox>;
		getMessageAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Email.EmailMessage>;
		getMessageReader(): Windows.ApplicationModel.Email.EmailMessageReader;
		getMessageReader(
		options: Windows.ApplicationModel.Email.EmailQueryOptions
	): Windows.ApplicationModel.Email.EmailMessageReader
	}

	declare class EmailStoreNotificationTriggerDetails  {
		
	}

	
}

declare module 'ExtendedExecution' {
				declare class ExtendedExecutionRevokedEventArgs  {
		reason: Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedReason
	}

	declare class ExtendedExecutionSession  {
		constructor(): this;
		close(): void;
		description: string;
		onrevoked: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedEventArgs>;
		addEventListener(
		type: "revoked", listener: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedEventArgs>
	): void;
		removeEventListener(
		type: "revoked", listener: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionRevokedEventArgs>
	): void;
		percentProgress: number;
		reason: Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionReason;
		requestExtensionAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Foreground' {
				declare class ExtendedExecutionForegroundRevokedEventArgs  {
		reason: Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedReason
	}

	declare class ExtendedExecutionForegroundSession  {
		constructor(): this;
		close(): void;
		description: string;
		onrevoked: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedEventArgs>;
		addEventListener(
		type: "revoked", listener: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedEventArgs>
	): void;
		removeEventListener(
		type: "revoked", listener: Windows.Foundation.TypedEventHandler<any, Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundRevokedEventArgs>
	): void;
		reason: Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundReason;
		requestExtensionAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'LockScreen' {
				declare class LockApplicationHost  {
		getForCurrentView(): Windows.ApplicationModel.LockScreen.LockApplicationHost;
		onunlocking: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockApplicationHost, Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs>;
		addEventListener(
		type: "unlocking", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockApplicationHost, Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs>
	): void;
		removeEventListener(
		type: "unlocking", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockApplicationHost, Windows.ApplicationModel.LockScreen.LockScreenUnlockingEventArgs>
	): void;
		requestUnlock(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LockScreenBadge  {
		automationName: string;
		glyph: Windows.Storage.Streams.IRandomAccessStream;
		launchApp(): void;
		logo: Windows.Storage.Streams.IRandomAccessStream;
		number: number
	}

	declare class LockScreenInfo  {
		alarmIcon: Windows.Storage.Streams.IRandomAccessStream;
		badges: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.LockScreen.LockScreenBadge>;
		detailText: Windows.Foundation.Collections.IVectorView<string>;
		lockScreenImage: Windows.Storage.Streams.IRandomAccessStream;
		onalarmiconchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>;
		addEventListener(
		type: "alarmiconchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		removeEventListener(
		type: "alarmiconchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		onbadgeschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>;
		addEventListener(
		type: "badgeschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		removeEventListener(
		type: "badgeschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		ondetailtextchanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>;
		addEventListener(
		type: "detailtextchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		removeEventListener(
		type: "detailtextchanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		onlockscreenimagechanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>;
		addEventListener(
		type: "lockscreenimagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		removeEventListener(
		type: "lockscreenimagechanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.LockScreen.LockScreenInfo, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LockScreenUnlockingDeferral  {
		complete(): void
	}

	declare class LockScreenUnlockingEventArgs  {
		deadline: Date;
		getDeferral(): Windows.ApplicationModel.LockScreen.LockScreenUnlockingDeferral
	}

	
}

declare module 'Resources' {
				declare class ResourceLoader  {
		getForCurrentView(): Windows.ApplicationModel.Resources.ResourceLoader;
		getForCurrentView(name: string): Windows.ApplicationModel.Resources.ResourceLoader;
		getForViewIndependentUse(name: string): Windows.ApplicationModel.Resources.ResourceLoader;
		getForViewIndependentUse(): Windows.ApplicationModel.Resources.ResourceLoader;
		getStringForReference(uri: Windows.Foundation.Uri): string;
		constructor(name: string): this;
		constructor(): this;
		getString(resource: string): string;
		getStringForUri(uri: Windows.Foundation.Uri): string
	}

	
}

declare module 'Search' {
		declare interface IStorageQueryResultBase {
		applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void,
		findStartIndexAsync(value: any): Windows.Foundation.IPromiseWithIAsyncOperation<number>,
		getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions,
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>,
		folder: Windows.Storage.StorageFolder
	}

	declare interface IIndexableContent {
		id: string,
		properties: Windows.Foundation.Collections.IMap<string, any>,
		stream: Windows.Storage.Streams.IRandomAccessStream,
		streamContentType: string
	}

	declare interface SortEntry {
		ascendingOrder: boolean,
		propertyName: string
	}

		declare class LocalContentSuggestionSettings  {
		constructor(): this;
		aqsFilter: string;
		enabled: boolean;
		locations: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFolder>;
		propertiesToMatch: Windows.Foundation.Collections.IVector<string>
	}

	declare class SearchPane  {
		getForCurrentView(): Windows.ApplicationModel.Search.SearchPane;
		hideThisApplication(): void;
		language: string;
		onquerychanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>;
		addEventListener(
		type: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>
	): void;
		removeEventListener(
		type: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>
	): void;
		onquerysubmitted: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>;
		addEventListener(
		type: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>
	): void;
		removeEventListener(
		type: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>
	): void;
		onresultsuggestionchosen: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>;
		addEventListener(
		type: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>
	): void;
		removeEventListener(
		type: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>
	): void;
		onsuggestionsrequested: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>;
		addEventListener(
		type: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>
	): void;
		onvisibilitychanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>;
		addEventListener(
		type: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>
	): void;
		removeEventListener(
		type: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane, Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>
	): void;
		placeholderText: string;
		queryText: string;
		searchHistoryContext: string;
		searchHistoryEnabled: boolean;
		setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
		show(): void;
		show(query: string): void;
		showOnKeyboardInput: boolean;
		trySetQueryText(query: string): boolean;
		visible: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SearchPaneQueryChangedEventArgs  {
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
		queryText: string
	}

	declare class SearchPaneQueryLinguisticDetails  {
		queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
		queryTextCompositionLength: number;
		queryTextCompositionStart: number
	}

	declare class SearchPaneQuerySubmittedEventArgs  {
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
		queryText: string
	}

	declare class SearchPaneResultSuggestionChosenEventArgs  {
		tag: string
	}

	declare class SearchPaneSuggestionsRequest  {
		getDeferral(): Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral;
		isCanceled: boolean;
		searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection
	}

	declare class SearchPaneSuggestionsRequestDeferral  {
		complete(): void
	}

	declare class SearchPaneSuggestionsRequestedEventArgs  {
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
		queryText: string;
		request: Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest
	}

	declare class SearchPaneVisibilityChangedEventArgs  {
		visible: boolean
	}

	declare class SearchQueryLinguisticDetails  {
		constructor(queryTextAlternatives: Windows.Foundation.Collections.IIterable<string>, queryTextCompositionStart: number, queryTextCompositionLength: number): this;
		queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
		queryTextCompositionLength: number;
		queryTextCompositionStart: number
	}

	declare class SearchSuggestionCollection  {
		appendQuerySuggestion(text: string): void;
		appendQuerySuggestions(suggestions: Windows.Foundation.Collections.IIterable<string>): void;
		appendResultSuggestion(
		text: string, detailText: string, tag: string, image: Windows.Storage.Streams.IRandomAccessStreamReference, imageAlternateText: string
	): void;
		appendSearchSeparator(label: string): void;
		size: number
	}

	declare class SearchSuggestionsRequest  {
		getDeferral(): Windows.ApplicationModel.Search.SearchSuggestionsRequestDeferral;
		isCanceled: boolean;
		searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection
	}

	declare class SearchSuggestionsRequestDeferral  {
		complete(): void
	}

	declare class ContentIndexer  {
		getIndexer(indexName: string): Windows.Storage.Search.ContentIndexer;
		getIndexer(): Windows.Storage.Search.ContentIndexer;
		addAsync(indexableContent: Windows.Storage.Search.IIndexableContent): any;
		createQuery(
		searchFilter: string, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>, sortOrder: Windows.Foundation.Collections.IIterable<Windows.Storage.Search.SortEntry>
	): Windows.Storage.Search.ContentIndexerQuery;
		createQuery(
		searchFilter: string, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>, sortOrder: Windows.Foundation.Collections.IIterable<Windows.Storage.Search.SortEntry>, searchFilterLanguage: string
	): Windows.Storage.Search.ContentIndexerQuery;
		createQuery(
		searchFilter: string, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Storage.Search.ContentIndexerQuery;
		deleteAllAsync(): any;
		deleteAsync(contentId: string): any;
		deleteMultipleAsync(contentIds: Windows.Foundation.Collections.IIterable<string>): any;
		retrievePropertiesAsync(
		contentId: string, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMapView<any, any>>;
		revision: number;
		updateAsync(indexableContent: Windows.Storage.Search.IIndexableContent): any
	}

	declare class ContentIndexerQuery  {
		getAsync(
		startIndex: number, maxItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		getPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getPropertiesAsync(
		startIndex: number, maxItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		queryFolder: Windows.Storage.StorageFolder
	}

	declare class IndexableContent  {
		constructor(): this;
		id: string;
		properties: Windows.Foundation.Collections.IMap<string, any>;
		stream: Windows.Storage.Streams.IRandomAccessStream;
		streamContentType: string
	}

	declare class QueryOptions  {
		constructor(query: Windows.Storage.Search.CommonFileQuery, fileTypeFilter: Windows.Foundation.Collections.IIterable<string>): this;
		constructor(query: Windows.Storage.Search.CommonFolderQuery): this;
		constructor(): this;
		applicationSearchFilter: string;
		dateStackOption: Windows.Storage.Search.DateStackOption;
		fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
		folderDepth: Windows.Storage.Search.FolderDepth;
		groupPropertyName: string;
		indexerOption: Windows.Storage.Search.IndexerOption;
		language: string;
		loadFromString(value: string): void;
		saveToString(): string;
		setPropertyPrefetch(
		options: Windows.Storage.FileProperties.PropertyPrefetchOptions, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): void;
		setThumbnailPrefetch(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): void;
		sortOrder: Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>;
		storageProviderIdFilter: Windows.Foundation.Collections.IVector<string>;
		userSearchFilter: string
	}

	declare class SortEntryVector extends Array<Windows.Storage.Search.SortEntry> {
		append(value: Windows.Storage.Search.SortEntry): void;
		clear(): void;
		first(): Windows.Foundation.Collections.IIterator<Windows.Storage.Search.SortEntry>;
		getAt(index: number): Windows.Storage.Search.SortEntry;
		getMany(
		startIndex: number
	): {
		items: Windows.Storage.Search.SortEntry,
		returnValue: number
	};
		getView(): Windows.Foundation.Collections.IVectorView<Windows.Storage.Search.SortEntry>;
		indexOf(
		value: Windows.Storage.Search.SortEntry
	): {
		index: number,
		returnValue: boolean
	};
		insertAt(index: number, value: Windows.Storage.Search.SortEntry): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Storage.Search.SortEntry): void;
		setAt(index: number, value: Windows.Storage.Search.SortEntry): void;
		size: number;
		indexOf(
		value: Windows.Storage.Search.SortEntry, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Storage.Search.SortEntry, fromIndex?: number): number
	}

	declare class StorageFileQueryResult  {
		applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
		findStartIndexAsync(value: any): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		folder: Windows.Storage.StorageFolder;
		getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
		getFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		startIndex: number, maxNumberOfItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		getMatchingPropertiesWithRanges(
		file: Windows.Storage.StorageFile
	): Windows.Foundation.Collections.IMap<string, Windows.Foundation.Collections.IVectorView<any>>;
		oncontentschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		onoptionschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StorageFolderQueryResult  {
		applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
		findStartIndexAsync(value: any): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		folder: Windows.Storage.StorageFolder;
		getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
		getFoldersAsync(
		startIndex: number, maxNumberOfItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		oncontentschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		onoptionschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StorageItemQueryResult  {
		applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
		findStartIndexAsync(value: any): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		folder: Windows.Storage.StorageFolder;
		getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemsAsync(
		startIndex: number, maxNumberOfItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		oncontentschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		onoptionschanged: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>;
		addEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		removeEventListener(
		type: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StorageLibraryContentChangedTriggerDetails  {
		createModifiedSinceQuery(lastQueryTime: Date): Windows.Storage.Search.StorageItemQueryResult;
		folder: Windows.Storage.StorageFolder
	}

	declare class ValueAndLanguage  {
		constructor(): this;
		language: string;
		value: any
	}

	
}

declare module 'Store' {
	declare type LicenseChangedEventHandler = (ev: WinRTEvent<void>) => void;

			declare class CurrentApp  {
		appId: string;
		getAppPurchaseCampaignIdAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getAppReceiptAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getCustomerCollectionsIdAsync: any;
		getCustomerPurchaseIdAsync: any;
		getProductReceiptAsync(productId: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getUnfulfilledConsumablesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
		linkUri: Windows.Foundation.Uri;
		loadListingInformationAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		loadListingInformationByKeywordsAsync(
		keywords: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		loadListingInformationByProductIdsAsync(
		productIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		reportConsumableFulfillmentAsync(
		productId: string, transactionId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.FulfillmentResult>;
		reportProductFulfillment(productId: string): void;
		requestAppPurchaseAsync(
		includeReceipt: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		requestProductPurchaseAsync(
		productId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.PurchaseResults>;
		requestProductPurchaseAsync(
		productId: string, offerId: string, displayProperties: Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.PurchaseResults>;
		requestProductPurchaseAsync(
		productId: string, includeReceipt: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>
	}

	declare class CurrentAppSimulator  {
		appId: string;
		getAppPurchaseCampaignIdAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getAppReceiptAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getProductReceiptAsync(productId: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getUnfulfilledConsumablesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
		linkUri: Windows.Foundation.Uri;
		loadListingInformationAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		loadListingInformationByKeywordsAsync(
		keywords: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		loadListingInformationByProductIdsAsync(
		productIds: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
		reloadSimulatorAsync(
		simulatorSettingsFile: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		reportConsumableFulfillmentAsync(
		productId: string, transactionId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.FulfillmentResult>;
		requestAppPurchaseAsync(
		includeReceipt: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		requestProductPurchaseAsync(
		productId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.PurchaseResults>;
		requestProductPurchaseAsync(
		productId: string, offerId: string, displayProperties: Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.PurchaseResults>;
		requestProductPurchaseAsync(
		productId: string, includeReceipt: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>
	}

	declare class LicenseInformation  {
		expirationDate: Date;
		isActive: boolean;
		isTrial: boolean;
		onlicensechanged: Windows.ApplicationModel.Store.LicenseChangedEventHandler;
		addEventListener(
		type: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler
	): void;
		removeEventListener(
		type: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler
	): void;
		productLicenses: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Store.ProductLicense>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ListingInformation  {
		ageRating: number;
		currencyCode: any;
		currentMarket: string;
		description: string;
		formattedBasePrice: any;
		formattedPrice: string;
		isOnSale: any;
		name: string;
		productListings: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.Store.ProductListing>;
		saleEndDate: any
	}

	declare class ProductLicense  {
		expirationDate: Date;
		isActive: boolean;
		isConsumable: boolean;
		productId: string
	}

	declare class ProductListing  {
		currencyCode: any;
		description: string;
		formattedBasePrice: any;
		formattedPrice: string;
		imageUri: Windows.Foundation.Uri;
		isOnSale: any;
		keywords: Windows.Foundation.Collections.IIterable<string>;
		name: string;
		productId: string;
		productType: Windows.ApplicationModel.Store.ProductType;
		saleEndDate: Date;
		tag: string
	}

	declare class ProductPurchaseDisplayProperties  {
		constructor(): this;
		constructor(name: string): this;
		description: string;
		image: Windows.Foundation.Uri;
		name: string
	}

	declare class PurchaseResults  {
		offerId: string;
		receiptXml: string;
		status: Windows.ApplicationModel.Store.ProductPurchaseStatus;
		transactionId: string
	}

	declare class UnfulfilledConsumable  {
		offerId: string;
		productId: string;
		transactionId: string
	}

	
}

declare module 'InstallControl' {
				declare class AppInstallItem  {
		cancel(): void;
		cancel(correlationVector: string): void;
		getCurrentStatus(): Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallStatus;
		installType: Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallType;
		isUserInitiated: boolean;
		oncompleted: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>;
		addEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>
	): void;
		removeEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>
	): void;
		onstatuschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>;
		addEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>
	): void;
		removeEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem, any>
	): void;
		packageFamilyName: string;
		pause(): void;
		pause(correlationVector: string): void;
		productId: string;
		restart(): void;
		restart(correlationVector: string): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppInstallManager  {
		constructor(): this;
		acquisitionIdentity: string;
		appInstallItems: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		autoUpdateSetting: Windows.ApplicationModel.Store.Preview.InstallControl.AutoUpdateSetting;
		cancel(productId: string): void;
		cancel(productId: string, correlationVector: string): void;
		getIsAppAllowedToInstallAsync(productId: string): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getIsAppAllowedToInstallAsync(
		productId: string, skuId: string, catalogId: string, correlationVector: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getIsApplicableAsync(
		productId: string, skuId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		isStoreBlockedByPolicyAsync(
		storeClientName: string, storeClientPublisher: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		onitemcompleted: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>;
		addEventListener(
		type: "itemcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>
	): void;
		removeEventListener(
		type: "itemcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>
	): void;
		onitemstatuschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>;
		addEventListener(
		type: "itemstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>
	): void;
		removeEventListener(
		type: "itemstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager, Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManagerItemEventArgs>
	): void;
		pause(productId: string): void;
		pause(productId: string, correlationVector: string): void;
		restart(productId: string): void;
		restart(productId: string, correlationVector: string): void;
		searchForAllUpdatesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		searchForAllUpdatesAsync(
		correlationVector: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		searchForUpdatesAsync(
		productId: string, skuId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		searchForUpdatesAsync(
		productId: string, skuId: string, catalogId: string, correlationVector: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		startAppInstallAsync(
		productId: string, skuId: string, repair: boolean, forceUseOfNonRemovableStorage: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		startAppInstallAsync(
		productId: string, skuId: string, repair: boolean, forceUseOfNonRemovableStorage: boolean, catalogId: string, bundleId: string, correlationVector: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		updateAppByPackageFamilyNameAsync(
		packageFamilyName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		updateAppByPackageFamilyNameAsync(
		packageFamilyName: string, correlationVector: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppInstallManagerItemEventArgs  {
		item: Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallItem
	}

	declare class AppInstallStatus  {
		bytesDownloaded: number;
		downloadSizeInBytes: number;
		errorCode: WinRTError;
		installState: Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallState;
		percentComplete: number
	}

	
}

declare module 'Preview' {
				declare class StoreConfiguration  {
		filterUnsupportedSystemFeaturesAsync(
		systemFeatures: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Store.Preview.StoreSystemFeature>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		hardwareManufacturerInfo: Windows.ApplicationModel.Store.Preview.StoreHardwareManufacturerInfo;
		isStoreWebAccountId(webAccountId: string): boolean;
		purchasePromptingPolicy: number;
		setMobileOperatorConfiguration(
		mobileOperatorId: string, appDownloadLimitInMegabytes: number, updateDownloadLimitInMegabytes: number
	): void;
		setStoreWebAccountId(webAccountId: string): void;
		setSystemConfiguration(
		catalogHardwareManufacturerId: string, catalogStoreContentModifierId: string, systemConfigurationExpiration: Date, catalogHardwareDescriptor: string
	): void
	}

	declare class StoreHardwareManufacturerInfo  {
		hardwareManufacturerId: string;
		manufacturerName: string;
		modelName: string;
		storeContentModifierId: string
	}

	declare class StorePreview  {
		loadAddOnProductInfosAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		requestProductPurchaseByProductIdAndSkuIdAsync(
		productId: string, skuId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Store.Preview.StorePreviewPurchaseResults>
	}

	declare class StorePreviewProductInfo  {
		description: string;
		productId: string;
		productType: string;
		skuInfoList: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Store.Preview.StorePreviewSkuInfo>;
		title: string
	}

	declare class StorePreviewPurchaseResults  {
		productPurchaseStatus: Windows.ApplicationModel.Store.Preview.StorePreviewProductPurchaseStatus
	}

	declare class StorePreviewSkuInfo  {
		currencyCode: string;
		customDeveloperData: string;
		description: string;
		extendedData: string;
		formattedListPrice: string;
		productId: string;
		skuId: string;
		skuType: string;
		title: string
	}

	declare class ClassicAppManager  {
		findInstalledApp: any
	}

	declare class InstalledClassicAppInfo  {
		displayName: any;
		displayVersion: any
	}

	
}

declare module 'SystemAccess' {
				declare class DeviceAccountConfiguration  {
		constructor(): this;
		accountName: string;
		calendarSyncEnabled: boolean;
		contactsSyncEnabled: boolean;
		deviceAccountTypeId: string;
		domain: string;
		emailAddress: string;
		emailSyncEnabled: boolean;
		incomingServerAddress: string;
		incomingServerPort: number;
		incomingServerRequiresSsl: boolean;
		incomingServerUsername: string;
		outgoingServerAddress: string;
		outgoingServerPort: number;
		outgoingServerRequiresSsl: boolean;
		outgoingServerUsername: string;
		serverType: Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountServerType
	}

	declare class UserDataAccountSystemAccessManager  {
		addAndShowDeviceAccountsAsync(
		accounts: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>
	}

	
}

declare module 'UserDataAccounts' {
				declare class UserDataAccount  {
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deviceAccountTypeId: string;
		enterpriseId: string;
		findAppointmentCalendarsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findContactAnnotationListsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findContactListsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findEmailMailboxesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		icon: Windows.Storage.Streams.IRandomAccessStreamReference;
		id: string;
		isProtectedUnderLock: boolean;
		otherAppReadAccess: Windows.ApplicationModel.UserDataAccounts.UserDataAccountOtherAppReadAccess;
		packageFamilyName: string;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		userDisplayName: string
	}

	declare class UserDataAccountManager  {
		requestStoreAsync(
		storeAccessType: Windows.ApplicationModel.UserDataAccounts.UserDataAccountStoreAccessType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.UserDataAccounts.UserDataAccountStore>;
		showAccountErrorResolverAsync(id: string): Windows.Foundation.IPromiseWithIAsyncAction;
		showAccountSettingsAsync(id: string): Windows.Foundation.IPromiseWithIAsyncAction;
		showAddAccountAsync(
		contentKinds: Windows.ApplicationModel.UserDataAccounts.UserDataAccountContentKinds
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>
	}

	declare class UserDataAccountStore  {
		createAccountAsync(
		userDisplayName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.UserDataAccounts.UserDataAccount>;
		findAccountsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getAccountAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.UserDataAccounts.UserDataAccount>
	}

	
}

declare module 'VoiceCommands' {
				declare class VoiceCommand  {
		commandName: string;
		properties: Windows.Foundation.Collections.IMapView<string, Windows.Foundation.Collections.IVectorView<any>>;
		speechRecognitionResult: Windows.Media.SpeechRecognition.SpeechRecognitionResult
	}

	declare class VoiceCommandCompletedEventArgs  {
		reason: Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletionReason
	}

	declare class VoiceCommandConfirmationResult  {
		confirmed: boolean
	}

	declare class VoiceCommandContentTile  {
		constructor(): this;
		appContext: any;
		appLaunchArgument: string;
		contentTileType: Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTileType;
		image: Windows.Storage.IStorageFile;
		textLine1: string;
		textLine2: string;
		textLine3: string;
		title: string
	}

	declare class VoiceCommandDefinition  {
		language: string;
		name: string;
		setPhraseListAsync(
		phraseListName: string, phraseList: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class VoiceCommandDefinitionManager  {
		installCommandDefinitionsFromStorageFileAsync(file: Windows.Storage.StorageFile): Windows.Foundation.IPromiseWithIAsyncAction;
		installedCommandDefinitions: Windows.Foundation.Collections.IMapView<string, Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinition>
	}

	declare class VoiceCommandDisambiguationResult  {
		selectedItem: Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile
	}

	declare class VoiceCommandResponse  {
		createResponse(
		message: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage, contentTiles: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>
	): Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse;
		createResponse(
		userMessage: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage
	): Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse;
		createResponseForPrompt(
		message: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage, repeatMessage: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage, contentTiles: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>
	): Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse;
		createResponseForPrompt(
		message: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage, repeatMessage: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage
	): Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse;
		maxSupportedVoiceCommandContentTiles: number;
		appLaunchArgument: string;
		message: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage;
		repeatMessage: Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage;
		voiceCommandContentTiles: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile>
	}

	declare class VoiceCommandServiceConnection  {
		fromAppServiceTriggerDetails(
		triggerDetails: Windows.ApplicationModel.AppService.AppServiceTriggerDetails
	): Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection;
		getVoiceCommandAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.VoiceCommands.VoiceCommand>;
		language: Windows.Globalization.Language;
		onvoicecommandcompleted: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection, Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletedEventArgs>;
		addEventListener(
		type: "voicecommandcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection, Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletedEventArgs>
	): void;
		removeEventListener(
		type: "voicecommandcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection, Windows.ApplicationModel.VoiceCommands.VoiceCommandCompletedEventArgs>
	): void;
		reportFailureAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncAction;
		reportProgressAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncAction;
		reportSuccessAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncAction;
		requestAppLaunchAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncAction;
		requestConfirmationAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.VoiceCommands.VoiceCommandConfirmationResult>;
		requestDisambiguationAsync(
		response: Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.VoiceCommands.VoiceCommandDisambiguationResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class VoiceCommandUserMessage  {
		constructor(): this;
		displayMessage: string;
		spokenMessage: string
	}

	
}

declare module 'System' {
				declare class WalletItemSystemStore  {
		deleteAsync(
		item: Windows.ApplicationModel.Wallet.WalletItem
	): Windows.Foundation.IPromiseWithIAsyncAction;
		getAppStatusForItem(
		item: Windows.ApplicationModel.Wallet.WalletItem
	): Windows.ApplicationModel.Wallet.System.WalletItemAppAssociation;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		importItemAsync(
		stream: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Wallet.WalletItem>;
		launchAppForItemAsync(
		item: Windows.ApplicationModel.Wallet.WalletItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		onitemschanged: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Wallet.System.WalletItemSystemStore, any>;
		addEventListener(
		type: "itemschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Wallet.System.WalletItemSystemStore, any>
	): void;
		removeEventListener(
		type: "itemschanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Wallet.System.WalletItemSystemStore, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WalletManagerSystem  {
		requestStoreAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Wallet.System.WalletItemSystemStore>
	}

	declare class AppMemoryReport  {
		peakPrivateCommitUsage: number;
		privateCommitUsage: number;
		totalCommitLimit: number;
		totalCommitUsage: number
	}

	declare class AppMemoryUsageLimitChangingEventArgs  {
		newLimit: number;
		oldLimit: number
	}

	declare class FolderLauncherOptions  {
		constructor(): this;
		desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference;
		itemsToSelect: Windows.Foundation.Collections.IVector<Windows.Storage.IStorageItem>
	}

	declare class KnownUserProperties  {
		accountName: string;
		displayName: string;
		domainName: string;
		firstName: string;
		guestHost: string;
		lastName: string;
		principalName: string;
		providerName: string;
		sessionInitiationProtocolUri: string
	}

	declare class LaunchUriResult  {
		result: Windows.Foundation.Collections.ValueSet;
		status: Windows.System.LaunchUriStatus
	}

	declare class Launcher  {
		findFileHandlersAsync(
		extension: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
		findUriSchemeHandlersAsync(
		scheme: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
		findUriSchemeHandlersAsync(
		scheme: string, launchQuerySupportType: Windows.System.LaunchQuerySupportType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
		launchFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchFileAsync(
		file: Windows.Storage.IStorageFile, options: Windows.System.LauncherOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchFolderAsync(
		folder: Windows.Storage.IStorageFolder, options: Windows.System.FolderLauncherOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchFolderAsync(
		folder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchUriAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchUriAsync(
		uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchUriAsync(
		uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		launchUriForResultsAsync(
		uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchUriResult>;
		launchUriForResultsAsync(
		uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchUriResult>;
		queryFileSupportAsync(
		file: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
		queryFileSupportAsync(
		file: Windows.Storage.StorageFile, packageFamilyName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
		queryUriSupportAsync(
		uri: Windows.Foundation.Uri, launchQuerySupportType: Windows.System.LaunchQuerySupportType, packageFamilyName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
		queryUriSupportAsync(
		uri: Windows.Foundation.Uri, launchQuerySupportType: Windows.System.LaunchQuerySupportType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.LaunchQuerySupportStatus>
	}

	declare class LauncherOptions  {
		constructor(): this;
		contentType: string;
		desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference;
		displayApplicationPicker: boolean;
		fallbackUri: Windows.Foundation.Uri;
		neighboringFilesQuery: Windows.Storage.Search.StorageFileQueryResult;
		preferredApplicationDisplayName: string;
		preferredApplicationPackageFamilyName: string;
		targetApplicationPackageFamilyName: string;
		treatAsUntrusted: boolean;
		ui: Windows.System.LauncherUIOptions
	}

	declare class LauncherUIOptions  {
		invocationPoint: Windows.Foundation.Point;
		preferredPlacement: Windows.UI.Popups.Placement;
		selectionRect: Windows.Foundation.Rect
	}

	declare class MemoryManager  {
		appMemoryUsage: number;
		appMemoryUsageLevel: Windows.System.AppMemoryUsageLevel;
		appMemoryUsageLimit: number;
		getAppMemoryReport(): Windows.System.AppMemoryReport;
		getProcessMemoryReport(): Windows.System.ProcessMemoryReport;
		onappmemoryusagedecreased: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "appmemoryusagedecreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "appmemoryusagedecreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		onappmemoryusageincreased: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "appmemoryusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "appmemoryusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		onappmemoryusagelimitchanging: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "appmemoryusagelimitchanging", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "appmemoryusagelimitchanging", listener: Windows.Foundation.EventHandler<any>
	): void;
		trySetAppMemoryUsageLimit: any;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ProcessLauncher  {
		runToCompletionAsync: any
	}

	declare class ProcessLauncherOptions  {
		standardError: any;
		standardInput: any;
		standardOutput: any;
		workingDirectory: any
	}

	declare class ProcessLauncherResult  {
		exitCode: any
	}

	declare class ProcessMemoryReport  {
		privateWorkingSetUsage: number;
		totalWorkingSetUsage: number
	}

	declare class ProtocolForResultsOperation  {
		reportCompleted(data: Windows.Foundation.Collections.ValueSet): void
	}

	declare class ShutdownManager  {
		beginShutdown: any;
		cancelShutdown: any
	}

	declare class TimeZoneSettings  {
		canChangeTimeZone: any;
		changeTimeZoneByDisplayName: any;
		currentTimeZoneDisplayName: any;
		supportedTimeZoneDisplayNames: any
	}

	declare class User  {
		createWatcher(): Windows.System.UserWatcher;
		findAllAsync(
		type: Windows.System.UserType, status: Windows.System.UserAuthenticationStatus
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllAsync(
		type: Windows.System.UserType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFromId(nonRoamableId: string): Windows.System.User;
		authenticationStatus: Windows.System.UserAuthenticationStatus;
		getPictureAsync(
		desiredSize: Windows.System.UserPictureSize
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamReference>;
		getPropertiesAsync(
		values: Windows.Foundation.Collections.IVectorView<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IPropertySet>;
		getPropertyAsync(value: string): Windows.Foundation.IPromiseWithIAsyncOperation<any>;
		nonRoamableId: string;
		type: Windows.System.UserType
	}

	declare class UserAuthenticationStatusChangeDeferral  {
		complete(): void
	}

	declare class UserAuthenticationStatusChangingEventArgs  {
		currentStatus: Windows.System.UserAuthenticationStatus;
		getDeferral(): Windows.System.UserAuthenticationStatusChangeDeferral;
		newStatus: Windows.System.UserAuthenticationStatus;
		user: Windows.System.User
	}

	declare class UserChangedEventArgs  {
		user: Windows.System.User
	}

	declare class UserWatcher  {
		onadded: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>;
		addEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		removeEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		onauthenticationstatuschanged: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>;
		addEventListener(
		type: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		removeEventListener(
		type: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		onauthenticationstatuschanging: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserAuthenticationStatusChangingEventArgs>;
		addEventListener(
		type: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserAuthenticationStatusChangingEventArgs>
	): void;
		removeEventListener(
		type: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserAuthenticationStatusChangingEventArgs>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>
	): void;
		onremoved: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>;
		addEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		removeEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, any>
	): void;
		onupdated: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>;
		addEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		removeEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher, Windows.System.UserChangedEventArgs>
	): void;
		start(): void;
		status: Windows.System.UserWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Wallet' {
				declare class WalletBarcode  {
		constructor(streamToBarcodeImage: Windows.Storage.Streams.IRandomAccessStreamReference): this;
		constructor(symbology: Windows.ApplicationModel.Wallet.WalletBarcodeSymbology, value: string): this;
		getImageAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamReference>;
		symbology: Windows.ApplicationModel.Wallet.WalletBarcodeSymbology;
		value: string
	}

	declare class WalletItem  {
		constructor(kind: Windows.ApplicationModel.Wallet.WalletItemKind, displayName: string): this;
		barcode: Windows.ApplicationModel.Wallet.WalletBarcode;
		bodyBackgroundImage: Windows.Storage.Streams.IRandomAccessStreamReference;
		bodyColor: Windows.UI.Color;
		bodyFontColor: Windows.UI.Color;
		displayMessage: string;
		displayName: string;
		displayProperties: Windows.Foundation.Collections.IMap<string, Windows.ApplicationModel.Wallet.WalletItemCustomProperty>;
		expirationDate: Date;
		headerBackgroundImage: Windows.Storage.Streams.IRandomAccessStreamReference;
		headerColor: Windows.UI.Color;
		headerFontColor: Windows.UI.Color;
		id: string;
		isAcknowledged: boolean;
		isDisplayMessageLaunchable: boolean;
		isMoreTransactionHistoryLaunchable: boolean;
		issuerDisplayName: string;
		kind: Windows.ApplicationModel.Wallet.WalletItemKind;
		lastUpdated: Date;
		logo159x159: Windows.Storage.Streams.IRandomAccessStreamReference;
		logo336x336: Windows.Storage.Streams.IRandomAccessStreamReference;
		logo99x99: Windows.Storage.Streams.IRandomAccessStreamReference;
		logoImage: Windows.Storage.Streams.IRandomAccessStreamReference;
		logoText: string;
		promotionalImage: Windows.Storage.Streams.IRandomAccessStreamReference;
		relevantDate: Date;
		relevantDateDisplayMessage: string;
		relevantLocations: Windows.Foundation.Collections.IMap<string, Windows.ApplicationModel.Wallet.WalletRelevantLocation>;
		transactionHistory: Windows.Foundation.Collections.IMap<string, Windows.ApplicationModel.Wallet.WalletTransaction>;
		verbs: Windows.Foundation.Collections.IMap<string, Windows.ApplicationModel.Wallet.WalletVerb>
	}

	declare class WalletItemCustomProperty  {
		constructor(name: string, value: string): this;
		autoDetectLinks: boolean;
		detailViewPosition: Windows.ApplicationModel.Wallet.WalletDetailViewPosition;
		name: string;
		summaryViewPosition: Windows.ApplicationModel.Wallet.WalletSummaryViewPosition;
		value: string
	}

	declare class WalletItemStore  {
		addAsync(
		id: string, item: Windows.ApplicationModel.Wallet.WalletItem
	): Windows.Foundation.IPromiseWithIAsyncAction;
		clearAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(id: string): Windows.Foundation.IPromiseWithIAsyncAction;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Wallet.WalletItem>>;
		getItemsAsync(
		kind: Windows.ApplicationModel.Wallet.WalletItemKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getWalletItemAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Wallet.WalletItem>;
		importItemAsync(
		stream: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Wallet.WalletItem>;
		showAsync(id: string): Windows.Foundation.IPromiseWithIAsyncAction;
		showAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		updateAsync(
		item: Windows.ApplicationModel.Wallet.WalletItem
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class WalletManager  {
		requestStoreAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.ApplicationModel.Wallet.WalletItemStore>
	}

	declare class WalletRelevantLocation  {
		constructor(): this;
		displayMessage: string;
		position: Windows.Devices.Geolocation.BasicGeoposition
	}

	declare class WalletTransaction  {
		constructor(): this;
		description: string;
		displayAmount: string;
		displayLocation: string;
		ignoreTimeOfDay: boolean;
		isLaunchable: boolean;
		transactionDate: Date
	}

	declare class WalletVerb  {
		constructor(name: string): this;
		name: string
	}

	
}

declare module 'Pdf' {
				declare class PdfDocument  {
		loadFromFileAsync(
		file: Windows.Storage.IStorageFile, password: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Pdf.PdfDocument>;
		loadFromFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Pdf.PdfDocument>;
		loadFromStreamAsync(
		inputStream: Windows.Storage.Streams.IRandomAccessStream, password: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Pdf.PdfDocument>;
		loadFromStreamAsync(
		inputStream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Pdf.PdfDocument>;
		getPage(pageIndex: number): Windows.Data.Pdf.PdfPage;
		isPasswordProtected: boolean;
		pageCount: number
	}

	declare class PdfPage  {
		close(): void;
		dimensions: Windows.Data.Pdf.PdfPageDimensions;
		index: number;
		preferredZoom: number;
		preparePageAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		renderToStreamAsync(
		outputStream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		renderToStreamAsync(
		outputStream: Windows.Storage.Streams.IRandomAccessStream, options: Windows.Data.Pdf.PdfPageRenderOptions
	): Windows.Foundation.IPromiseWithIAsyncAction;
		rotation: Windows.Data.Pdf.PdfPageRotation;
		size: Windows.Foundation.Size
	}

	declare class PdfPageDimensions  {
		artBox: Windows.Foundation.Rect;
		bleedBox: Windows.Foundation.Rect;
		cropBox: Windows.Foundation.Rect;
		mediaBox: Windows.Foundation.Rect;
		trimBox: Windows.Foundation.Rect
	}

	declare class PdfPageRenderOptions  {
		constructor(): this;
		backgroundColor: Windows.UI.Color;
		bitmapEncoderId: string;
		destinationHeight: number;
		destinationWidth: number;
		isIgnoringHighContrast: boolean;
		sourceRect: Windows.Foundation.Rect
	}

	
}

declare module 'Text' {
	declare type SelectableWordSegmentsTokenizingHandler = (
		precedingWords: Windows.Foundation.Collections.IIterable<Windows.Data.Text.SelectableWordSegment>, words: Windows.Foundation.Collections.IIterable<Windows.Data.Text.SelectableWordSegment>
	) => void;

	declare type WordSegmentsTokenizingHandler = (
		precedingWords: Windows.Foundation.Collections.IIterable<Windows.Data.Text.WordSegment>, words: Windows.Foundation.Collections.IIterable<Windows.Data.Text.WordSegment>
	) => void;

	declare interface TextSegment {
		length: number,
		startPosition: number
	}

	declare interface FontWeight {
		weight: number
	}

		declare class AlternateWordForm  {
		alternateText: string;
		normalizationFormat: Windows.Data.Text.AlternateNormalizationFormat;
		sourceTextSegment: Windows.Data.Text.TextSegment
	}

	declare class SelectableWordSegment  {
		sourceTextSegment: Windows.Data.Text.TextSegment;
		text: string
	}

	declare class SelectableWordsSegmenter  {
		constructor(language: string): this;
		getTokenAt(text: string, startIndex: number): Windows.Data.Text.SelectableWordSegment;
		getTokens(
		text: string
	): Windows.Foundation.Collections.IVectorView<Windows.Data.Text.SelectableWordSegment>;
		resolvedLanguage: string;
		tokenize(
		text: string, startIndex: number, handler: Windows.Data.Text.SelectableWordSegmentsTokenizingHandler
	): void
	}

	declare class SemanticTextQuery  {
		constructor(aqsFilter: string, filterLanguage: string): this;
		constructor(aqsFilter: string): this;
		find(
		content: string
	): Windows.Foundation.Collections.IVectorView<Windows.Data.Text.TextSegment>;
		findInProperty(
		propertyContent: string, propertyName: string
	): Windows.Foundation.Collections.IVectorView<Windows.Data.Text.TextSegment>
	}

	declare class TextConversionGenerator  {
		constructor(languageTag: string): this;
		getCandidatesAsync(
		input: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCandidatesAsync(
		input: string, maxCandidates: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		languageAvailableButNotInstalled: boolean;
		resolvedLanguage: string
	}

	declare class TextPredictionGenerator  {
		constructor(languageTag: string): this;
		getCandidatesAsync(
		input: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCandidatesAsync(
		input: string, maxCandidates: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		languageAvailableButNotInstalled: boolean;
		resolvedLanguage: string
	}

	declare class TextReverseConversionGenerator  {
		constructor(languageTag: string): this;
		convertBackAsync(input: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		languageAvailableButNotInstalled: boolean;
		resolvedLanguage: string
	}

	declare class UnicodeCharacters  {
		getCodepointFromSurrogatePair(highSurrogate: number, lowSurrogate: number): number;
		getGeneralCategory(codepoint: number): Windows.Data.Text.UnicodeGeneralCategory;
		getNumericType(codepoint: number): Windows.Data.Text.UnicodeNumericType;
		getSurrogatePairFromCodepoint(codepoint: number): {
		highSurrogate: string,
		lowSurrogate: string
	};
		isAlphabetic(codepoint: number): boolean;
		isCased(codepoint: number): boolean;
		isGraphemeBase(codepoint: number): boolean;
		isGraphemeExtend(codepoint: number): boolean;
		isHighSurrogate(codepoint: number): boolean;
		isIdContinue(codepoint: number): boolean;
		isIdStart(codepoint: number): boolean;
		isLowSurrogate(codepoint: number): boolean;
		isLowercase(codepoint: number): boolean;
		isNoncharacter(codepoint: number): boolean;
		isSupplementary(codepoint: number): boolean;
		isUppercase(codepoint: number): boolean;
		isWhitespace(codepoint: number): boolean
	}

	declare class WordSegment  {
		alternateForms: Windows.Foundation.Collections.IVectorView<Windows.Data.Text.AlternateWordForm>;
		sourceTextSegment: Windows.Data.Text.TextSegment;
		text: string
	}

	declare class WordsSegmenter  {
		constructor(language: string): this;
		getTokenAt(text: string, startIndex: number): Windows.Data.Text.WordSegment;
		getTokens(
		text: string
	): Windows.Foundation.Collections.IVectorView<Windows.Data.Text.WordSegment>;
		resolvedLanguage: string;
		tokenize(
		text: string, startIndex: number, handler: Windows.Data.Text.WordSegmentsTokenizingHandler
	): void
	}

	
}

declare module 'Dom' {
		declare interface IXmlNode {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode,
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode,
		hasChildNodes(): boolean,
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode,
		normalize(): void,
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode,
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode,
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap,
		childNodes: Windows.Data.Xml.Dom.XmlNodeList,
		firstChild: Windows.Data.Xml.Dom.IXmlNode,
		lastChild: Windows.Data.Xml.Dom.IXmlNode,
		localName: any,
		namespaceUri: any,
		nextSibling: Windows.Data.Xml.Dom.IXmlNode,
		nodeName: string,
		nodeType: Windows.Data.Xml.Dom.NodeType,
		nodeValue: any,
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument,
		parentNode: Windows.Data.Xml.Dom.IXmlNode,
		prefix: any,
		previousSibling: Windows.Data.Xml.Dom.IXmlNode
	}

	declare interface IXmlText {
		splitText(offset: number): Windows.Data.Xml.Dom.IXmlText
	}

	declare interface IXmlNodeSelector {
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList,
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList,
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode,
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode
	}

	declare interface IXmlNodeSerializer {
		getXml(): string,
		innerText: string
	}

	declare interface IXmlCharacterData {
		appendData(data: string): void,
		deleteData(offset: number, count: number): void,
		insertData(offset: number, data: string): void,
		replaceData(offset: number, count: number, data: string): void,
		substringData(offset: number, count: number): string,
		data: string,
		length: number
	}

		declare class DtdEntity  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		notationName: any;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		publicId: any;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		systemId: any
	}

	declare class DtdNotation  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		publicId: any;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		systemId: any
	}

	declare class XmlAttribute  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		name: string;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		specified: boolean;
		value: string
	}

	declare class XmlCDataSection  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		appendData(data: string): void;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		data: string;
		deleteData(offset: number, count: number): void;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		insertData(offset: number, data: string): void;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		length: number;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		replaceData(offset: number, count: number, data: string): void;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
		substringData(offset: number, count: number): string
	}

	declare class XmlComment  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		appendData(data: string): void;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		data: string;
		deleteData(offset: number, count: number): void;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		insertData(offset: number, data: string): void;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		length: number;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		replaceData(offset: number, count: number, data: string): void;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		substringData(offset: number, count: number): string
	}

	declare class XmlDocument  {
		loadFromFileAsync(
		file: Windows.Storage.IStorageFile, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
		loadFromFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
		loadFromUriAsync(
		uri: Windows.Foundation.Uri, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
		loadFromUriAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
		constructor(): this;
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		createAttribute(name: string): Windows.Data.Xml.Dom.XmlAttribute;
		createAttributeNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlAttribute;
		createCDataSection(data: string): Windows.Data.Xml.Dom.XmlCDataSection;
		createComment(data: string): Windows.Data.Xml.Dom.XmlComment;
		createDocumentFragment(): Windows.Data.Xml.Dom.XmlDocumentFragment;
		createElement(tagName: string): Windows.Data.Xml.Dom.XmlElement;
		createElementNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlElement;
		createEntityReference(name: string): Windows.Data.Xml.Dom.XmlEntityReference;
		createProcessingInstruction(target: string, data: string): Windows.Data.Xml.Dom.XmlProcessingInstruction;
		createTextNode(data: string): Windows.Data.Xml.Dom.XmlText;
		doctype: Windows.Data.Xml.Dom.XmlDocumentType;
		documentElement: Windows.Data.Xml.Dom.XmlElement;
		documentUri: string;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getElementById(elementId: string): Windows.Data.Xml.Dom.XmlElement;
		getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
		getXml(): string;
		hasChildNodes(): boolean;
		implementation: Windows.Data.Xml.Dom.XmlDomImplementation;
		importNode(
		node: Windows.Data.Xml.Dom.IXmlNode, deep: boolean
	): Windows.Data.Xml.Dom.IXmlNode;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		loadXml(xml: string, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): void;
		loadXml(xml: string): void;
		loadXmlFromBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
		loadXmlFromBuffer(
		buffer: Windows.Storage.Streams.IBuffer, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings
	): void;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		saveToFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode
	}

	declare class XmlDocumentFragment  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode
	}

	declare class XmlDocumentType  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		entities: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		name: string;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		notations: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode
	}

	declare class XmlDomImplementation  {
		hasFeature(feature: string, version: any): boolean
	}

	declare class XmlElement  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getAttribute(attributeName: string): string;
		getAttributeNS(namespaceUri: any, localName: string): string;
		getAttributeNode(attributeName: string): Windows.Data.Xml.Dom.XmlAttribute;
		getAttributeNodeNS(namespaceUri: any, localName: string): Windows.Data.Xml.Dom.XmlAttribute;
		getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeAttribute(attributeName: string): void;
		removeAttributeNS(namespaceUri: any, localName: string): void;
		removeAttributeNode(
		attributeNode: Windows.Data.Xml.Dom.XmlAttribute
	): Windows.Data.Xml.Dom.XmlAttribute;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		setAttribute(attributeName: string, attributeValue: string): void;
		setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
		setAttributeNode(
		newAttribute: Windows.Data.Xml.Dom.XmlAttribute
	): Windows.Data.Xml.Dom.XmlAttribute;
		setAttributeNodeNS(
		newAttribute: Windows.Data.Xml.Dom.XmlAttribute
	): Windows.Data.Xml.Dom.XmlAttribute;
		tagName: string
	}

	declare class XmlEntityReference  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode
	}

	declare class XmlLoadSettings  {
		constructor(): this;
		elementContentWhiteSpace: boolean;
		maxElementDepth: number;
		prohibitDtd: boolean;
		resolveExternals: boolean;
		validateOnParse: boolean
	}

	declare class XmlNamedNodeMap extends Array<Windows.Data.Xml.Dom.IXmlNode> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
		getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
		getMany(
		startIndex: number
	): {
		items: Windows.Data.Xml.Dom.IXmlNode,
		returnValue: number
	};
		getNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
		getNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
		indexOf(
		value: Windows.Data.Xml.Dom.IXmlNode
	): {
		index: number,
		returnValue: boolean
	};
		item(index: number): Windows.Data.Xml.Dom.IXmlNode;
		length: number;
		removeNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
		removeNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
		setNamedItem(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		setNamedItemNS(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		size: number;
		indexOf(
		value: Windows.Data.Xml.Dom.IXmlNode, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Data.Xml.Dom.IXmlNode, fromIndex?: number): number
	}

	declare class XmlNodeList extends Array<Windows.Data.Xml.Dom.IXmlNode> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
		getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
		getMany(
		startIndex: number
	): {
		items: Windows.Data.Xml.Dom.IXmlNode,
		returnValue: number
	};
		indexOf(
		value: Windows.Data.Xml.Dom.IXmlNode
	): {
		index: number,
		returnValue: boolean
	};
		item(index: number): Windows.Data.Xml.Dom.IXmlNode;
		length: number;
		size: number;
		indexOf(
		value: Windows.Data.Xml.Dom.IXmlNode, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Data.Xml.Dom.IXmlNode, fromIndex?: number): number
	}

	declare class XmlProcessingInstruction  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		data: string;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		target: string
	}

	declare class XmlText  {
		appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		appendData(data: string): void;
		attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
		childNodes: Windows.Data.Xml.Dom.XmlNodeList;
		cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
		data: string;
		deleteData(offset: number, count: number): void;
		firstChild: Windows.Data.Xml.Dom.IXmlNode;
		getXml(): string;
		hasChildNodes(): boolean;
		innerText: string;
		insertBefore(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		insertData(offset: number, data: string): void;
		lastChild: Windows.Data.Xml.Dom.IXmlNode;
		length: number;
		localName: any;
		namespaceUri: any;
		nextSibling: Windows.Data.Xml.Dom.IXmlNode;
		nodeName: string;
		nodeType: Windows.Data.Xml.Dom.NodeType;
		nodeValue: any;
		normalize(): void;
		ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
		parentNode: Windows.Data.Xml.Dom.IXmlNode;
		prefix: any;
		previousSibling: Windows.Data.Xml.Dom.IXmlNode;
		removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
		replaceChild(
		newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode
	): Windows.Data.Xml.Dom.IXmlNode;
		replaceData(offset: number, count: number, data: string): void;
		selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
		selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
		selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
		selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
		splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
		substringData(offset: number, count: number): string
	}

	
}

declare module 'Xsl' {
				declare class XsltProcessor  {
		constructor(document: Windows.Data.Xml.Dom.XmlDocument): this;
		transformToDocument(inputNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.XmlDocument;
		transformToString(inputNode: Windows.Data.Xml.Dom.IXmlNode): string
	}

	
}

declare module 'Adc' {
				declare class AdcChannel  {
		close(): void;
		controller: Windows.Devices.Adc.AdcController;
		readRatio(): number;
		readValue(): number
	}

	declare class AdcController  {
		getControllersAsync(
		provider: Windows.Devices.Adc.Provider.IAdcProvider
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Adc.AdcController>;
		channelCount: number;
		channelMode: Windows.Devices.Adc.AdcChannelMode;
		isChannelModeSupported(channelMode: Windows.Devices.Adc.AdcChannelMode): boolean;
		maxValue: number;
		minValue: number;
		openChannel(channelNumber: number): Windows.Devices.Adc.AdcChannel;
		resolutionInBits: number
	}

	
}

declare module 'AllJoyn' {
		declare interface IAllJoynAcceptSessionJoiner {
		accept(): void
	}

		declare class AllJoynAboutData  {
		appId: string;
		appNames: Windows.Foundation.Collections.IMap<string, string>;
		dateOfManufacture: Date;
		defaultAppName: string;
		defaultDescription: string;
		defaultManufacturer: string;
		descriptions: Windows.Foundation.Collections.IMap<string, string>;
		isEnabled: boolean;
		manufacturers: Windows.Foundation.Collections.IMap<string, string>;
		modelNumber: string;
		softwareVersion: string;
		supportUrl: Windows.Foundation.Uri
	}

	declare class AllJoynAboutDataView  {
		getDataBySessionPortAsync(
		uniqueName: string, busAttachment: Windows.Devices.AllJoyn.AllJoynBusAttachment, sessionPort: number, language: Windows.Globalization.Language
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.AllJoyn.AllJoynAboutDataView>;
		getDataBySessionPortAsync(
		uniqueName: string, busAttachment: Windows.Devices.AllJoyn.AllJoynBusAttachment, sessionPort: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.AllJoyn.AllJoynAboutDataView>;
		ajSoftwareVersion: string;
		appId: string;
		appName: string;
		dateOfManufacture: Date;
		defaultLanguage: Windows.Globalization.Language;
		description: string;
		deviceId: string;
		deviceName: string;
		hardwareVersion: string;
		manufacturer: string;
		modelNumber: string;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		softwareVersion: string;
		status: number;
		supportUrl: Windows.Foundation.Uri;
		supportedLanguages: Windows.Foundation.Collections.IVectorView<Windows.Globalization.Language>
	}

	declare class AllJoynAcceptSessionJoinerEventArgs  {
		constructor(uniqueName: string, sessionPort: number, trafficType: Windows.Devices.AllJoyn.AllJoynTrafficType, proximity: number, acceptSessionJoiner: Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner): this;
		accept(): void;
		sameNetwork: boolean;
		samePhysicalNode: boolean;
		sessionPort: number;
		trafficType: Windows.Devices.AllJoyn.AllJoynTrafficType;
		uniqueName: string
	}

	declare class AllJoynAuthenticationCompleteEventArgs  {
		authenticationMechanism: Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism;
		peerUniqueName: string;
		succeeded: boolean
	}

	declare class AllJoynBusAttachment  {
		constructor(): this;
		constructor(connectionSpecification: string): this;
		aboutData: Windows.Devices.AllJoyn.AllJoynAboutData;
		authenticationMechanisms: Windows.Foundation.Collections.IVector<Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism>;
		connect(): void;
		connectionSpecification: string;
		disconnect(): void;
		onauthenticationcomplete: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs>;
		addEventListener(
		type: "authenticationcomplete", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs>
	): void;
		removeEventListener(
		type: "authenticationcomplete", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs>
	): void;
		oncredentialsrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs>;
		addEventListener(
		type: "credentialsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "credentialsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs>
	): void;
		oncredentialsverificationrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs>;
		addEventListener(
		type: "credentialsverificationrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs>
	): void;
		removeEventListener(
		type: "credentialsverificationrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs>
	): void;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.AllJoyn.AllJoynBusAttachment, Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs>
	): void;
		pingAsync(uniqueName: string): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		state: Windows.Devices.AllJoyn.AllJoynBusAttachmentState;
		uniqueName: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AllJoynBusAttachmentStateChangedEventArgs  {
		state: Windows.Devices.AllJoyn.AllJoynBusAttachmentState;
		status: number
	}

	declare class AllJoynCredentials  {
		authenticationMechanism: Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism;
		certificate: Windows.Security.Cryptography.Certificates.Certificate;
		passwordCredential: Windows.Security.Credentials.PasswordCredential;
		timeout: number
	}

	declare class AllJoynCredentialsRequestedEventArgs  {
		attemptCount: number;
		credentials: Windows.Devices.AllJoyn.AllJoynCredentials;
		getDeferral(): Windows.Foundation.Deferral;
		peerUniqueName: string;
		requestedUserName: string
	}

	declare class AllJoynCredentialsVerificationRequestedEventArgs  {
		accept(): void;
		authenticationMechanism: Windows.Devices.AllJoyn.AllJoynAuthenticationMechanism;
		getDeferral(): Windows.Foundation.Deferral;
		peerCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		peerCertificateErrorSeverity: Windows.Networking.Sockets.SocketSslErrorSeverity;
		peerCertificateErrors: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>;
		peerIntermediateCertificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		peerUniqueName: string
	}

	declare class AllJoynMessageInfo  {
		constructor(senderUniqueName: string): this;
		senderUniqueName: string
	}

	declare class AllJoynProducerStoppedEventArgs  {
		constructor(status: number): this;
		status: number
	}

	declare class AllJoynServiceInfo  {
		constructor(uniqueName: string, objectPath: string, sessionPort: number): this;
		objectPath: string;
		sessionPort: number;
		uniqueName: string
	}

	declare class AllJoynServiceInfoRemovedEventArgs  {
		constructor(uniqueName: string): this;
		uniqueName: string
	}

	declare class AllJoynSessionLostEventArgs  {
		constructor(reason: Windows.Devices.AllJoyn.AllJoynSessionLostReason): this;
		reason: Windows.Devices.AllJoyn.AllJoynSessionLostReason
	}

	declare class AllJoynSessionMemberAddedEventArgs  {
		constructor(uniqueName: string): this;
		uniqueName: string
	}

	declare class AllJoynSessionMemberRemovedEventArgs  {
		constructor(uniqueName: string): this;
		uniqueName: string
	}

	declare class AllJoynStatus  {
		authenticationFailed: number;
		authenticationRejectedByUser: number;
		connectionRefused: number;
		fail: number;
		insufficientSecurity: number;
		invalidArgument1: number;
		invalidArgument2: number;
		invalidArgument3: number;
		invalidArgument4: number;
		invalidArgument5: number;
		invalidArgument6: number;
		invalidArgument7: number;
		invalidArgument8: number;
		ok: number;
		operationTimedOut: number;
		otherEndClosed: number;
		sslConnectFailed: number;
		sslIdentityVerificationFailed: number
	}

	declare class AllJoynWatcherStoppedEventArgs  {
		constructor(status: number): this;
		status: number
	}

	
}

declare module 'Advertisement' {
				declare class BluetoothLEAdvertisement  {
		constructor(): this;
		dataSections: Windows.Foundation.Collections.IVector<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection>;
		flags: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFlags;
		getManufacturerDataByCompanyId(
		companyId: number
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData>;
		getSectionsByType(
		type: number
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementDataSection>;
		localName: string;
		manufacturerData: Windows.Foundation.Collections.IVector<Windows.Devices.Bluetooth.Advertisement.BluetoothLEManufacturerData>;
		serviceUuids: Windows.Foundation.Collections.IVector<string>
	}

	declare class BluetoothLEAdvertisementBytePattern  {
		constructor(): this;
		constructor(dataType: number, offset: number, data: Windows.Storage.Streams.IBuffer): this;
		data: Windows.Storage.Streams.IBuffer;
		dataType: number;
		offset: number
	}

	declare class BluetoothLEAdvertisementDataSection  {
		constructor(): this;
		constructor(dataType: number, data: Windows.Storage.Streams.IBuffer): this;
		data: Windows.Storage.Streams.IBuffer;
		dataType: number
	}

	declare class BluetoothLEAdvertisementDataTypes  {
		advertisingInterval: number;
		appearance: number;
		completeLocalName: number;
		completeService128BitUuids: number;
		completeService16BitUuids: number;
		completeService32BitUuids: number;
		flags: number;
		incompleteService128BitUuids: number;
		incompleteService16BitUuids: number;
		incompleteService32BitUuids: number;
		manufacturerSpecificData: number;
		publicTargetAddress: number;
		randomTargetAddress: number;
		serviceData128BitUuids: number;
		serviceData16BitUuids: number;
		serviceData32BitUuids: number;
		serviceSolicitation128BitUuids: number;
		serviceSolicitation16BitUuids: number;
		serviceSolicitation32BitUuids: number;
		shortenedLocalName: number;
		slaveConnectionIntervalRange: number;
		txPowerLevel: number
	}

	declare class BluetoothLEAdvertisementFilter  {
		constructor(): this;
		advertisement: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement;
		bytePatterns: Windows.Foundation.Collections.IVector<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementBytePattern>
	}

	declare class BluetoothLEAdvertisementPublisher  {
		constructor(): this;
		constructor(advertisement: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement): this;
		advertisement: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement;
		onstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>;
		addEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>
	): void;
		removeEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatusChangedEventArgs>
	): void;
		start(): void;
		status: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BluetoothLEAdvertisementPublisherStatusChangedEventArgs  {
		error: Windows.Devices.Bluetooth.BluetoothError;
		status: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementPublisherStatus
	}

	declare class BluetoothLEAdvertisementReceivedEventArgs  {
		advertisement: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisement;
		advertisementType: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementType;
		bluetoothAddress: number;
		rawSignalStrengthInDBm: number;
		timestamp: Date
	}

	declare class BluetoothLEAdvertisementWatcher  {
		constructor(advertisementFilter: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter): this;
		constructor(): this;
		advertisementFilter: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementFilter;
		maxOutOfRangeTimeout: number;
		maxSamplingInterval: number;
		minOutOfRangeTimeout: number;
		minSamplingInterval: number;
		onreceived: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs>;
		addEventListener(
		type: "received", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs>
	): void;
		removeEventListener(
		type: "received", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementReceivedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcher, Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStoppedEventArgs>
	): void;
		scanningMode: Windows.Devices.Bluetooth.Advertisement.BluetoothLEScanningMode;
		signalStrengthFilter: Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter;
		start(): void;
		status: Windows.Devices.Bluetooth.Advertisement.BluetoothLEAdvertisementWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BluetoothLEAdvertisementWatcherStoppedEventArgs  {
		error: Windows.Devices.Bluetooth.BluetoothError
	}

	declare class BluetoothLEManufacturerData  {
		constructor(): this;
		constructor(companyId: number, data: Windows.Storage.Streams.IBuffer): this;
		companyId: number;
		data: Windows.Storage.Streams.IBuffer
	}

	
}

declare module 'Bluetooth' {
				declare class BluetoothClassOfDevice  {
		fromParts(
		majorClass: Windows.Devices.Bluetooth.BluetoothMajorClass, minorClass: Windows.Devices.Bluetooth.BluetoothMinorClass, serviceCapabilities: Windows.Devices.Bluetooth.BluetoothServiceCapabilities
	): Windows.Devices.Bluetooth.BluetoothClassOfDevice;
		fromRawValue(rawValue: number): Windows.Devices.Bluetooth.BluetoothClassOfDevice;
		majorClass: Windows.Devices.Bluetooth.BluetoothMajorClass;
		minorClass: Windows.Devices.Bluetooth.BluetoothMinorClass;
		rawValue: number;
		serviceCapabilities: Windows.Devices.Bluetooth.BluetoothServiceCapabilities
	}

	declare class BluetoothDevice  {
		fromBluetoothAddressAsync(
		address: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.BluetoothDevice>;
		fromHostNameAsync(
		hostName: Windows.Networking.HostName
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.BluetoothDevice>;
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.BluetoothDevice>;
		getDeviceSelector(): string;
		getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;
		getDeviceSelectorFromClassOfDevice(classOfDevice: Windows.Devices.Bluetooth.BluetoothClassOfDevice): string;
		getDeviceSelectorFromConnectionStatus(connectionStatus: Windows.Devices.Bluetooth.BluetoothConnectionStatus): string;
		getDeviceSelectorFromDeviceName(deviceName: string): string;
		getDeviceSelectorFromPairingState(pairingState: boolean): string;
		bluetoothAddress: number;
		classOfDevice: Windows.Devices.Bluetooth.BluetoothClassOfDevice;
		close(): void;
		connectionStatus: Windows.Devices.Bluetooth.BluetoothConnectionStatus;
		deviceId: string;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		hostName: Windows.Networking.HostName;
		name: string;
		onconnectionstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>;
		addEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		removeEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		onnamechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>;
		addEventListener(
		type: "namechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		removeEventListener(
		type: "namechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		onsdprecordschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>;
		addEventListener(
		type: "sdprecordschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		removeEventListener(
		type: "sdprecordschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothDevice, any>
	): void;
		rfcommServices: Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService>;
		sdpRecords: Windows.Foundation.Collections.IVectorView<Windows.Storage.Streams.IBuffer>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BluetoothLEAppearance  {
		fromParts(
		appearanceCategory: number, appearanceSubCategory: number
	): Windows.Devices.Bluetooth.BluetoothLEAppearance;
		fromRawValue(rawValue: number): Windows.Devices.Bluetooth.BluetoothLEAppearance;
		category: number;
		rawValue: number;
		subCategory: number
	}

	declare class BluetoothLEAppearanceCategories  {
		barcodeScanner: number;
		bloodPressure: number;
		clock: number;
		computer: number;
		cycling: number;
		display: number;
		eyeGlasses: number;
		glucoseMeter: number;
		heartRate: number;
		humanInterfaceDevice: number;
		keyring: number;
		mediaPlayer: number;
		outdoorSportActivity: number;
		phone: number;
		pulseOximeter: number;
		remoteControl: number;
		runningWalking: number;
		tag: number;
		thermometer: number;
		uncategorized: number;
		watch: number;
		weightScale: number
	}

	declare class BluetoothLEAppearanceSubcategories  {
		barcodeScanner: number;
		bloodPressureArm: number;
		bloodPressureWrist: number;
		cardReader: number;
		cyclingCadenceSensor: number;
		cyclingComputer: number;
		cyclingPowerSensor: number;
		cyclingSpeedCadenceSensor: number;
		cyclingSpeedSensor: number;
		digitalPen: number;
		digitizerTablet: number;
		gamepad: number;
		generic: number;
		heartRateBelt: number;
		joystick: number;
		keyboard: number;
		locationDisplay: number;
		locationNavigationDisplay: number;
		locationNavigationPod: number;
		locationPod: number;
		mouse: number;
		oximeterFingertip: number;
		oximeterWristWorn: number;
		runningWalkingInShoe: number;
		runningWalkingOnHip: number;
		runningWalkingOnShoe: number;
		sportsWatch: number;
		thermometerEar: number
	}

	declare class BluetoothLEDevice  {
		fromBluetoothAddressAsync(
		bluetoothAddress: number, bluetoothAddressType: Windows.Devices.Bluetooth.BluetoothAddressType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.BluetoothLEDevice>;
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.BluetoothLEDevice>;
		getDeviceSelector(): string;
		getDeviceSelectorFromAppearance(appearance: Windows.Devices.Bluetooth.BluetoothLEAppearance): string;
		getDeviceSelectorFromBluetoothAddress(bluetoothAddress: number): string;
		getDeviceSelectorFromBluetoothAddress(
		bluetoothAddress: number, bluetoothAddressType: Windows.Devices.Bluetooth.BluetoothAddressType
	): string;
		getDeviceSelectorFromConnectionStatus(connectionStatus: Windows.Devices.Bluetooth.BluetoothConnectionStatus): string;
		getDeviceSelectorFromDeviceName(deviceName: string): string;
		getDeviceSelectorFromPairingState(pairingState: boolean): string;
		appearance: Windows.Devices.Bluetooth.BluetoothLEAppearance;
		bluetoothAddress: number;
		bluetoothAddressType: Windows.Devices.Bluetooth.BluetoothAddressType;
		close(): void;
		connectionStatus: Windows.Devices.Bluetooth.BluetoothConnectionStatus;
		deviceId: string;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		gattServices: Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>;
		getGattService(
		serviceUuid: string
	): Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService;
		name: string;
		onconnectionstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>;
		addEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		removeEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		ongattserviceschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>;
		addEventListener(
		type: "gattserviceschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		removeEventListener(
		type: "gattserviceschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		onnamechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>;
		addEventListener(
		type: "namechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		removeEventListener(
		type: "namechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.BluetoothLEDevice, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BluetoothSignalStrengthFilter  {
		constructor(): this;
		inRangeThresholdInDBm: number;
		outOfRangeThresholdInDBm: number;
		outOfRangeTimeout: number;
		samplingInterval: number
	}

	
}

declare module 'GenericAttributeProfile' {
				declare class GattCharacteristic  {
		convertShortIdToUuid(shortId: number): string;
		attributeHandle: number;
		characteristicProperties: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristicProperties;
		getAllDescriptors(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor>;
		getDescriptors(
		descriptorUuid: string
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDescriptor>;
		onvaluechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic, Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs>;
		addEventListener(
		type: "valuechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic, Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs>
	): void;
		removeEventListener(
		type: "valuechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic, Windows.Devices.Bluetooth.GenericAttributeProfile.GattValueChangedEventArgs>
	): void;
		presentationFormats: Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattPresentationFormat>;
		protectionLevel: Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel;
		readClientCharacteristicConfigurationDescriptorAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadClientCharacteristicConfigurationDescriptorResult>;
		readValueAsync(
		cacheMode: Windows.Devices.Bluetooth.BluetoothCacheMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>;
		readValueAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>;
		service: Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService;
		userDescription: string;
		uuid: string;
		writeClientCharacteristicConfigurationDescriptorAsync(
		clientCharacteristicConfigurationDescriptorValue: Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>;
		writeValueAsync(
		value: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>;
		writeValueAsync(
		value: Windows.Storage.Streams.IBuffer, writeOption: Windows.Devices.Bluetooth.GenericAttributeProfile.GattWriteOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class GattCharacteristicUuids  {
		alertCategoryId: string;
		alertCategoryIdBitMask: string;
		alertLevel: string;
		alertNotificationControlPoint: string;
		alertStatus: string;
		batteryLevel: string;
		bloodPressureFeature: string;
		bloodPressureMeasurement: string;
		bodySensorLocation: string;
		bootKeyboardInputReport: string;
		bootKeyboardOutputReport: string;
		bootMouseInputReport: string;
		cscFeature: string;
		cscMeasurement: string;
		currentTime: string;
		cyclingPowerControlPoint: string;
		cyclingPowerFeature: string;
		cyclingPowerMeasurement: string;
		cyclingPowerVector: string;
		dateTime: string;
		dayDateTime: string;
		dayOfWeek: string;
		dstOffset: string;
		exactTime256: string;
		firmwareRevisionString: string;
		gapAppearance: string;
		gapDeviceName: string;
		gapPeripheralPreferredConnectionParameters: string;
		gapPeripheralPrivacyFlag: string;
		gapReconnectionAddress: string;
		gattServiceChanged: string;
		glucoseFeature: string;
		glucoseMeasurement: string;
		glucoseMeasurementContext: string;
		hardwareRevisionString: string;
		heartRateControlPoint: string;
		heartRateMeasurement: string;
		hidControlPoint: string;
		hidInformation: string;
		ieee1107320601RegulatoryCertificationDataList: string;
		intermediateCuffPressure: string;
		intermediateTemperature: string;
		lnControlPoint: string;
		lnFeature: string;
		localTimeInformation: string;
		locationAndSpeed: string;
		manufacturerNameString: string;
		measurementInterval: string;
		modelNumberString: string;
		navigation: string;
		newAlert: string;
		pnpId: string;
		positionQuality: string;
		protocolMode: string;
		recordAccessControlPoint: string;
		referenceTimeInformation: string;
		report: string;
		reportMap: string;
		ringerControlPoint: string;
		ringerSetting: string;
		rscFeature: string;
		rscMeasurement: string;
		scControlPoint: string;
		scanIntervalWindow: string;
		scanRefresh: string;
		sensorLocation: string;
		serialNumberString: string;
		softwareRevisionString: string;
		supportUnreadAlertCategory: string;
		supportedNewAlertCategory: string;
		systemId: string;
		temperatureMeasurement: string;
		temperatureType: string;
		timeAccuracy: string;
		timeSource: string;
		timeUpdateControlPoint: string;
		timeUpdateState: string;
		timeWithDst: string;
		timeZone: string;
		txPowerLevel: string;
		unreadAlertStatus: string
	}

	declare class GattDescriptor  {
		convertShortIdToUuid(shortId: number): string;
		attributeHandle: number;
		protectionLevel: Windows.Devices.Bluetooth.GenericAttributeProfile.GattProtectionLevel;
		readValueAsync(
		cacheMode: Windows.Devices.Bluetooth.BluetoothCacheMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>;
		readValueAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattReadResult>;
		uuid: string;
		writeValueAsync(
		value: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>
	}

	declare class GattDescriptorUuids  {
		characteristicAggregateFormat: string;
		characteristicExtendedProperties: string;
		characteristicPresentationFormat: string;
		characteristicUserDescription: string;
		clientCharacteristicConfiguration: string;
		serverCharacteristicConfiguration: string
	}

	declare class GattDeviceService  {
		convertShortIdToUuid(shortId: number): string;
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>;
		getDeviceSelectorFromShortId(serviceShortId: number): string;
		getDeviceSelectorFromUuid(serviceUuid: string): string;
		attributeHandle: number;
		close(): void;
		device: Windows.Devices.Bluetooth.BluetoothLEDevice;
		deviceId: string;
		getAllCharacteristics(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic>;
		getAllIncludedServices(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>;
		getCharacteristics(
		characteristicUuid: string
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic>;
		getIncludedServices(
		serviceUuid: string
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>;
		parentServices: Windows.Foundation.Collections.IVectorView<Windows.Devices.Bluetooth.GenericAttributeProfile.GattDeviceService>;
		uuid: string
	}

	declare class GattPresentationFormat  {
		bluetoothSigAssignedNumbers: number;
		description: number;
		exponent: number;
		formatType: number;
		namespace: number;
		unit: number
	}

	declare class GattPresentationFormatTypes  {
		bit2: number;
		boolean: number;
		duInt16: number;
		float: number;
		float32: number;
		float64: number;
		nibble: number;
		sfloat: number;
		sint12: number;
		sint128: number;
		sint16: number;
		sint24: number;
		sint32: number;
		sint48: number;
		sint64: number;
		sint8: number;
		struct: number;
		uint12: number;
		uint128: number;
		uint16: number;
		uint24: number;
		uint32: number;
		uint48: number;
		uint64: number;
		uint8: number;
		utf16: number;
		utf8: number
	}

	declare class GattReadClientCharacteristicConfigurationDescriptorResult  {
		clientCharacteristicConfigurationDescriptor: Windows.Devices.Bluetooth.GenericAttributeProfile.GattClientCharacteristicConfigurationDescriptorValue;
		status: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus
	}

	declare class GattReadResult  {
		status: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus;
		value: Windows.Storage.Streams.IBuffer
	}

	declare class GattReliableWriteTransaction  {
		constructor(): this;
		commitAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.GenericAttributeProfile.GattCommunicationStatus>;
		writeValue(
		characteristic: Windows.Devices.Bluetooth.GenericAttributeProfile.GattCharacteristic, value: Windows.Storage.Streams.IBuffer
	): void
	}

	declare class GattServiceUuids  {
		alertNotification: string;
		battery: string;
		bloodPressure: string;
		currentTime: string;
		cyclingPower: string;
		cyclingSpeedAndCadence: string;
		deviceInformation: string;
		genericAccess: string;
		genericAttribute: string;
		glucose: string;
		healthThermometer: string;
		heartRate: string;
		humanInterfaceDevice: string;
		immediateAlert: string;
		linkLoss: string;
		locationAndNavigation: string;
		nextDstChange: string;
		phoneAlertStatus: string;
		referenceTimeUpdate: string;
		runningSpeedAndCadence: string;
		scanParameters: string;
		txPower: string
	}

	declare class GattValueChangedEventArgs  {
		characteristicValue: Windows.Storage.Streams.IBuffer;
		timestamp: Date
	}

	
}

declare module 'Rfcomm' {
				declare class RfcommDeviceService  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.Rfcomm.RfcommDeviceService>;
		getDeviceSelector(serviceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId): string;
		close(): void;
		connectionHostName: Windows.Networking.HostName;
		connectionServiceName: string;
		device: Windows.Devices.Bluetooth.BluetoothDevice;
		getSdpRawAttributesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMapView<any, any>>;
		getSdpRawAttributesAsync(
		cacheMode: Windows.Devices.Bluetooth.BluetoothCacheMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMapView<any, any>>;
		maxProtectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
		protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
		serviceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId
	}

	declare class RfcommServiceId  {
		fromShortId(shortId: number): Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		fromUuid(uuid: string): Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		genericFileTransfer: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		obexFileTransfer: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		obexObjectPush: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		phoneBookAccessPce: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		phoneBookAccessPse: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		serialPort: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		asShortId(): number;
		asString(): string;
		uuid: string
	}

	declare class RfcommServiceProvider  {
		createAsync(
		serviceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Bluetooth.Rfcomm.RfcommServiceProvider>;
		sdpRawAttributes: Windows.Foundation.Collections.IMap<number, Windows.Storage.Streams.IBuffer>;
		serviceId: Windows.Devices.Bluetooth.Rfcomm.RfcommServiceId;
		startAdvertising(listener: Windows.Networking.Sockets.StreamSocketListener): void;
		startAdvertising(
		listener: Windows.Networking.Sockets.StreamSocketListener, radioDiscoverable: boolean
	): void;
		stopAdvertising(): void
	}

	
}

declare module 'Custom' {
		declare interface IIOControlCode {
		accessMode: Windows.Devices.Custom.IOControlAccessMode,
		bufferingMethod: Windows.Devices.Custom.IOControlBufferingMethod,
		controlCode: number,
		deviceType: number,
		function: number
	}

		declare class CustomDevice  {
		fromIdAsync(
		deviceId: string, desiredAccess: Windows.Devices.Custom.DeviceAccessMode, sharingMode: Windows.Devices.Custom.DeviceSharingMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Custom.CustomDevice>;
		getDeviceSelector(classGuid: string): string;
		inputStream: Windows.Storage.Streams.IInputStream;
		outputStream: Windows.Storage.Streams.IOutputStream;
		sendIOControlAsync(
		ioControlCode: Windows.Devices.Custom.IIOControlCode, inputBuffer: Windows.Storage.Streams.IBuffer, outputBuffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		trySendIOControlAsync(
		ioControlCode: Windows.Devices.Custom.IIOControlCode, inputBuffer: Windows.Storage.Streams.IBuffer, outputBuffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class IOControlCode  {
		constructor(deviceType: number, func: number, accessMode: Windows.Devices.Custom.IOControlAccessMode, bufferingMethod: Windows.Devices.Custom.IOControlBufferingMethod): this;
		accessMode: Windows.Devices.Custom.IOControlAccessMode;
		bufferingMethod: Windows.Devices.Custom.IOControlBufferingMethod;
		controlCode: number;
		deviceType: number;
		function: number
	}

	declare class KnownDeviceTypes  {
		unknown: number
	}

	declare class CustomSensor  {
		fromIdAsync(
		sensorId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.Custom.CustomSensor>;
		getDeviceSelector(interfaceId: string): string;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.Custom.CustomSensorReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Custom.CustomSensor, Windows.Devices.Sensors.Custom.CustomSensorReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Custom.CustomSensor, Windows.Devices.Sensors.Custom.CustomSensorReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Custom.CustomSensor, Windows.Devices.Sensors.Custom.CustomSensorReadingChangedEventArgs>
	): void;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CustomSensorReading  {
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		timestamp: Date
	}

	declare class CustomSensorReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.Custom.CustomSensorReading
	}

	
}

declare module 'Enumeration' {
		declare interface IDevicePairingSettings {
		
	}

		declare class DeviceAccessChangedEventArgs  {
		status: Windows.Devices.Enumeration.DeviceAccessStatus
	}

	declare class DeviceAccessInformation  {
		createFromDeviceClass(
		deviceClass: Windows.Devices.Enumeration.DeviceClass
	): Windows.Devices.Enumeration.DeviceAccessInformation;
		createFromDeviceClassId(deviceClassId: string): Windows.Devices.Enumeration.DeviceAccessInformation;
		createFromId(deviceId: string): Windows.Devices.Enumeration.DeviceAccessInformation;
		currentStatus: Windows.Devices.Enumeration.DeviceAccessStatus;
		onaccesschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceAccessInformation, Windows.Devices.Enumeration.DeviceAccessChangedEventArgs>;
		addEventListener(
		type: "accesschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceAccessInformation, Windows.Devices.Enumeration.DeviceAccessChangedEventArgs>
	): void;
		removeEventListener(
		type: "accesschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceAccessInformation, Windows.Devices.Enumeration.DeviceAccessChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DeviceConnectionChangeTriggerDetails  {
		deviceId: string
	}

	declare class DeviceDisconnectButtonClickedEventArgs  {
		device: Windows.Devices.Enumeration.DeviceInformation
	}

	declare class DeviceInformation  {
		createFromIdAsync(
		deviceId: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
		createFromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
		createFromIdAsync(
		deviceId: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>, kind: Windows.Devices.Enumeration.DeviceInformationKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
		createWatcher(): Windows.Devices.Enumeration.DeviceWatcher;
		createWatcher(
		aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Devices.Enumeration.DeviceWatcher;
		createWatcher(aqsFilter: string): Windows.Devices.Enumeration.DeviceWatcher;
		createWatcher(
		deviceClass: Windows.Devices.Enumeration.DeviceClass
	): Windows.Devices.Enumeration.DeviceWatcher;
		createWatcher(
		aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>, kind: Windows.Devices.Enumeration.DeviceInformationKind
	): Windows.Devices.Enumeration.DeviceWatcher;
		findAllAsync(
		aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
		findAllAsync(
		deviceClass: Windows.Devices.Enumeration.DeviceClass
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
		findAllAsync(
		aqsFilter: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
		findAllAsync(
		aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>, kind: Windows.Devices.Enumeration.DeviceInformationKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
		getAqsFilterFromDeviceClass(deviceClass: Windows.Devices.Enumeration.DeviceClass): string;
		enclosureLocation: Windows.Devices.Enumeration.EnclosureLocation;
		getGlyphThumbnailAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
		getThumbnailAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
		id: string;
		isDefault: boolean;
		isEnabled: boolean;
		kind: Windows.Devices.Enumeration.DeviceInformationKind;
		name: string;
		pairing: Windows.Devices.Enumeration.DeviceInformationPairing;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		update(updateInfo: Windows.Devices.Enumeration.DeviceInformationUpdate): void
	}

	declare class DeviceInformationCollection extends Array<Windows.Devices.Enumeration.DeviceInformation> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.DeviceInformation>;
		getAt(index: number): Windows.Devices.Enumeration.DeviceInformation;
		getMany(
		startIndex: number
	): {
		items: Windows.Devices.Enumeration.DeviceInformation,
		returnValue: number
	};
		indexOf(
		value: Windows.Devices.Enumeration.DeviceInformation
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Devices.Enumeration.DeviceInformation, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Devices.Enumeration.DeviceInformation, fromIndex?: number
	): number
	}

	declare class DeviceInformationCustomPairing  {
		onpairingrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceInformationCustomPairing, Windows.Devices.Enumeration.DevicePairingRequestedEventArgs>;
		addEventListener(
		type: "pairingrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceInformationCustomPairing, Windows.Devices.Enumeration.DevicePairingRequestedEventArgs>
	): void;
		removeEventListener(
		type: "pairingrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceInformationCustomPairing, Windows.Devices.Enumeration.DevicePairingRequestedEventArgs>
	): void;
		pairAsync(
		pairingKindsSupported: Windows.Devices.Enumeration.DevicePairingKinds
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		pairAsync(
		pairingKindsSupported: Windows.Devices.Enumeration.DevicePairingKinds, minProtectionLevel: Windows.Devices.Enumeration.DevicePairingProtectionLevel, devicePairingSettings: Windows.Devices.Enumeration.IDevicePairingSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		pairAsync(
		pairingKindsSupported: Windows.Devices.Enumeration.DevicePairingKinds, minProtectionLevel: Windows.Devices.Enumeration.DevicePairingProtectionLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DeviceInformationPairing  {
		tryRegisterForAllInboundPairingRequests(pairingKindsSupported: Windows.Devices.Enumeration.DevicePairingKinds): boolean;
		canPair: boolean;
		custom: Windows.Devices.Enumeration.DeviceInformationCustomPairing;
		isPaired: boolean;
		pairAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		pairAsync(
		minProtectionLevel: Windows.Devices.Enumeration.DevicePairingProtectionLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		pairAsync(
		minProtectionLevel: Windows.Devices.Enumeration.DevicePairingProtectionLevel, devicePairingSettings: Windows.Devices.Enumeration.IDevicePairingSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DevicePairingResult>;
		protectionLevel: Windows.Devices.Enumeration.DevicePairingProtectionLevel;
		unpairAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceUnpairingResult>
	}

	declare class DeviceInformationUpdate  {
		id: string;
		kind: Windows.Devices.Enumeration.DeviceInformationKind;
		properties: Windows.Foundation.Collections.IMapView<string, any>
	}

	declare class DevicePairingRequestedEventArgs  {
		accept(): void;
		accept(pin: string): void;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		getDeferral(): Windows.Foundation.Deferral;
		pairingKind: Windows.Devices.Enumeration.DevicePairingKinds;
		pin: string
	}

	declare class DevicePairingResult  {
		protectionLevelUsed: Windows.Devices.Enumeration.DevicePairingProtectionLevel;
		status: Windows.Devices.Enumeration.DevicePairingResultStatus
	}

	declare class DevicePicker  {
		constructor(): this;
		appearance: Windows.Devices.Enumeration.DevicePickerAppearance;
		filter: Windows.Devices.Enumeration.DevicePickerFilter;
		hide(): void;
		ondevicepickerdismissed: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, any>;
		addEventListener(
		type: "devicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, any>
	): void;
		removeEventListener(
		type: "devicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, any>
	): void;
		ondeviceselected: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceSelectedEventArgs>;
		addEventListener(
		type: "deviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceSelectedEventArgs>
	): void;
		removeEventListener(
		type: "deviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceSelectedEventArgs>
	): void;
		ondisconnectbuttonclicked: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs>;
		addEventListener(
		type: "disconnectbuttonclicked", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs>
	): void;
		removeEventListener(
		type: "disconnectbuttonclicked", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DevicePicker, Windows.Devices.Enumeration.DeviceDisconnectButtonClickedEventArgs>
	): void;
		pickSingleDeviceAsync(
		selection: Windows.Foundation.Rect, placement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
		pickSingleDeviceAsync(
		selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
		requestedProperties: Windows.Foundation.Collections.IVector<string>;
		setDisplayStatus(
		device: Windows.Devices.Enumeration.DeviceInformation, status: string, options: Windows.Devices.Enumeration.DevicePickerDisplayStatusOptions
	): void;
		show(
		selection: Windows.Foundation.Rect, placement: Windows.UI.Popups.Placement
	): void;
		show(selection: Windows.Foundation.Rect): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DevicePickerAppearance  {
		accentColor: Windows.UI.Color;
		backgroundColor: Windows.UI.Color;
		foregroundColor: Windows.UI.Color;
		selectedAccentColor: Windows.UI.Color;
		selectedBackgroundColor: Windows.UI.Color;
		selectedForegroundColor: Windows.UI.Color;
		title: string
	}

	declare class DevicePickerFilter  {
		supportedDeviceClasses: Windows.Foundation.Collections.IVector<Windows.Devices.Enumeration.DeviceClass>;
		supportedDeviceSelectors: Windows.Foundation.Collections.IVector<string>
	}

	declare class DeviceSelectedEventArgs  {
		selectedDevice: Windows.Devices.Enumeration.DeviceInformation
	}

	declare class DeviceThumbnail  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		contentType: string;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class DeviceUnpairingResult  {
		status: Windows.Devices.Enumeration.DeviceUnpairingResultStatus
	}

	declare class DeviceWatcher  {
		getBackgroundTrigger(
		requestedEventKinds: Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.DeviceWatcherEventKind>
	): Windows.ApplicationModel.Background.DeviceWatcherTrigger;
		onadded: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformation>;
		addEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformation>
	): void;
		removeEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformation>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>
	): void;
		onremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>;
		addEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>
	): void;
		removeEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, any>
	): void;
		onupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>;
		addEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>
	): void;
		removeEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher, Windows.Devices.Enumeration.DeviceInformationUpdate>
	): void;
		start(): void;
		status: Windows.Devices.Enumeration.DeviceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DeviceWatcherEvent  {
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		deviceInformationUpdate: Windows.Devices.Enumeration.DeviceInformationUpdate;
		kind: Windows.Devices.Enumeration.DeviceWatcherEventKind
	}

	declare class DeviceWatcherTriggerDetails  {
		deviceWatcherEvents: Windows.Foundation.Collections.IVectorView<Windows.Devices.Enumeration.DeviceWatcherEvent>
	}

	declare class EnclosureLocation  {
		inDock: boolean;
		inLid: boolean;
		panel: Windows.Devices.Enumeration.Panel
	}

	
}

declare module 'Pnp' {
				declare class PnpObject  {
		createFromIdAsync(
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType, id: string, requestedProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObject>;
		createWatcher(
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string
	): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
		createWatcher(
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
		findAllAsync(
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
		findAllAsync(
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
		id: string;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
		update(updateInfo: Windows.Devices.Enumeration.Pnp.PnpObjectUpdate): void
	}

	declare class PnpObjectCollection extends Array<Windows.Devices.Enumeration.Pnp.PnpObject> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.Pnp.PnpObject>;
		getAt(index: number): Windows.Devices.Enumeration.Pnp.PnpObject;
		getMany(
		startIndex: number
	): {
		items: Windows.Devices.Enumeration.Pnp.PnpObject,
		returnValue: number
	};
		indexOf(
		value: Windows.Devices.Enumeration.Pnp.PnpObject
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Devices.Enumeration.Pnp.PnpObject, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Devices.Enumeration.Pnp.PnpObject, fromIndex?: number
	): number
	}

	declare class PnpObjectUpdate  {
		id: string;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		type: Windows.Devices.Enumeration.Pnp.PnpObjectType
	}

	declare class PnpObjectWatcher  {
		onadded: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObject>;
		addEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObject>
	): void;
		removeEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObject>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>
	): void;
		onremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>;
		addEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>
	): void;
		removeEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, any>
	): void;
		onupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>;
		addEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>
	): void;
		removeEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher, Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>
	): void;
		start(): void;
		status: Windows.Devices.Enumeration.DeviceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Geolocation' {
		declare interface BasicGeoposition {
		altitude: number,
		latitude: number,
		longitude: number
	}

	declare interface IGeoshape {
		altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem,
		geoshapeType: Windows.Devices.Geolocation.GeoshapeType,
		spatialReferenceId: number
	}

		declare class CivicAddress  {
		city: string;
		country: string;
		postalCode: string;
		state: string;
		timestamp: Date
	}

	declare class GeoboundingBox  {
		tryCompute(
		positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>
	): Windows.Devices.Geolocation.GeoboundingBox;
		tryCompute(
		positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>, altitudeRefSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem, spatialReferenceId: number
	): Windows.Devices.Geolocation.GeoboundingBox;
		tryCompute(
		positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>, altitudeRefSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem
	): Windows.Devices.Geolocation.GeoboundingBox;
		constructor(northwestCorner: Windows.Devices.Geolocation.BasicGeoposition, southeastCorner: Windows.Devices.Geolocation.BasicGeoposition): this;
		constructor(northwestCorner: Windows.Devices.Geolocation.BasicGeoposition, southeastCorner: Windows.Devices.Geolocation.BasicGeoposition, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem): this;
		constructor(northwestCorner: Windows.Devices.Geolocation.BasicGeoposition, southeastCorner: Windows.Devices.Geolocation.BasicGeoposition, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem, spatialReferenceId: number): this;
		altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem;
		center: Windows.Devices.Geolocation.BasicGeoposition;
		geoshapeType: Windows.Devices.Geolocation.GeoshapeType;
		maxAltitude: number;
		minAltitude: number;
		northwestCorner: Windows.Devices.Geolocation.BasicGeoposition;
		southeastCorner: Windows.Devices.Geolocation.BasicGeoposition;
		spatialReferenceId: number
	}

	declare class Geocircle  {
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition, radius: number): this;
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition, radius: number, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem, spatialReferenceId: number): this;
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition, radius: number, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem): this;
		altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem;
		center: Windows.Devices.Geolocation.BasicGeoposition;
		geoshapeType: Windows.Devices.Geolocation.GeoshapeType;
		radius: number;
		spatialReferenceId: number
	}

	declare class Geocoordinate  {
		accuracy: number;
		altitude: number;
		altitudeAccuracy: number;
		heading: number;
		latitude: number;
		longitude: number;
		point: Windows.Devices.Geolocation.Geopoint;
		positionSource: Windows.Devices.Geolocation.PositionSource;
		positionSourceTimestamp: Date;
		satelliteData: Windows.Devices.Geolocation.GeocoordinateSatelliteData;
		speed: number;
		timestamp: Date
	}

	declare class GeocoordinateSatelliteData  {
		horizontalDilutionOfPrecision: number;
		positionDilutionOfPrecision: number;
		verticalDilutionOfPrecision: number
	}

	declare class Geolocator  {
		getGeopositionHistoryAsync(
		startTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getGeopositionHistoryAsync(
		startTime: Date, duration: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Geolocation.GeolocationAccessStatus>;
		constructor(): this;
		desiredAccuracy: Windows.Devices.Geolocation.PositionAccuracy;
		desiredAccuracyInMeters: number;
		getGeopositionAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
		getGeopositionAsync(
		maximumAge: number, timeout: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
		locationStatus: Windows.Devices.Geolocation.PositionStatus;
		movementThreshold: number;
		onpositionchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.PositionChangedEventArgs>;
		addEventListener(
		type: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.PositionChangedEventArgs>
	): void;
		removeEventListener(
		type: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.PositionChangedEventArgs>
	): void;
		onstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.StatusChangedEventArgs>;
		addEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.StatusChangedEventArgs>
	): void;
		removeEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator, Windows.Devices.Geolocation.StatusChangedEventArgs>
	): void;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class Geopath  {
		constructor(positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>): this;
		constructor(positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem, spatialReferenceId: number): this;
		constructor(positions: Windows.Foundation.Collections.IIterable<Windows.Devices.Geolocation.BasicGeoposition>, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem): this;
		altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem;
		geoshapeType: Windows.Devices.Geolocation.GeoshapeType;
		positions: Windows.Foundation.Collections.IVectorView<Windows.Devices.Geolocation.BasicGeoposition>;
		spatialReferenceId: number
	}

	declare class Geopoint  {
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition): this;
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem, spatialReferenceId: number): this;
		constructor(position: Windows.Devices.Geolocation.BasicGeoposition, altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem): this;
		altitudeReferenceSystem: Windows.Devices.Geolocation.AltitudeReferenceSystem;
		geoshapeType: Windows.Devices.Geolocation.GeoshapeType;
		position: Windows.Devices.Geolocation.BasicGeoposition;
		spatialReferenceId: number
	}

	declare class Geoposition  {
		civicAddress: Windows.Devices.Geolocation.CivicAddress;
		coordinate: Windows.Devices.Geolocation.Geocoordinate;
		venueData: Windows.Devices.Geolocation.VenueData
	}

	declare class PositionChangedEventArgs  {
		position: Windows.Devices.Geolocation.Geoposition
	}

	declare class StatusChangedEventArgs  {
		status: Windows.Devices.Geolocation.PositionStatus
	}

	declare class VenueData  {
		id: string;
		level: string
	}

	
}

declare module 'Geofencing' {
				declare class Geofence  {
		constructor(id: string, geoshape: Windows.Devices.Geolocation.IGeoshape, monitoredStates: Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates, singleUse: boolean, dwellTime: number, startTime: Date, duration: number): this;
		constructor(id: string, geoshape: Windows.Devices.Geolocation.IGeoshape, monitoredStates: Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates, singleUse: boolean): this;
		constructor(id: string, geoshape: Windows.Devices.Geolocation.IGeoshape): this;
		constructor(id: string, geoshape: Windows.Devices.Geolocation.IGeoshape, monitoredStates: Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates, singleUse: boolean, dwellTime: number): this;
		duration: number;
		dwellTime: number;
		geoshape: Windows.Devices.Geolocation.IGeoshape;
		id: string;
		monitoredStates: Windows.Devices.Geolocation.Geofencing.MonitoredGeofenceStates;
		singleUse: boolean;
		startTime: Date
	}

	declare class GeofenceMonitor  {
		current: Windows.Devices.Geolocation.Geofencing.GeofenceMonitor;
		geofences: Windows.Foundation.Collections.IVector<Windows.Devices.Geolocation.Geofencing.Geofence>;
		lastKnownGeoposition: Windows.Devices.Geolocation.Geoposition;
		ongeofencestatechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>;
		addEventListener(
		type: "geofencestatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>
	): void;
		removeEventListener(
		type: "geofencestatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>
	): void;
		onstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>;
		addEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>
	): void;
		removeEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geofencing.GeofenceMonitor, any>
	): void;
		readReports(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Geolocation.Geofencing.GeofenceStateChangeReport>;
		status: Windows.Devices.Geolocation.Geofencing.GeofenceMonitorStatus;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class GeofenceStateChangeReport  {
		geofence: Windows.Devices.Geolocation.Geofencing.Geofence;
		geoposition: Windows.Devices.Geolocation.Geoposition;
		newState: Windows.Devices.Geolocation.Geofencing.GeofenceState;
		removalReason: Windows.Devices.Geolocation.Geofencing.GeofenceRemovalReason
	}

	
}

declare module 'Gpio' {
				declare class GpioController  {
		getControllersAsync(
		provider: Windows.Devices.Gpio.Provider.IGpioProvider
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getDefault(): Windows.Devices.Gpio.GpioController;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Gpio.GpioController>;
		openPin(pinNumber: number): Windows.Devices.Gpio.GpioPin;
		openPin(
		pinNumber: number, sharingMode: Windows.Devices.Gpio.GpioSharingMode
	): Windows.Devices.Gpio.GpioPin;
		pinCount: number;
		tryOpenPin(
		pinNumber: number, sharingMode: Windows.Devices.Gpio.GpioSharingMode
	): {
		pin: Windows.Devices.Gpio.GpioPin,
		openStatus: Windows.Devices.Gpio.GpioOpenStatus,
		returnValue: boolean
	}
	}

	declare class GpioPin  {
		close(): void;
		debounceTimeout: number;
		getDriveMode(): Windows.Devices.Gpio.GpioPinDriveMode;
		isDriveModeSupported(driveMode: Windows.Devices.Gpio.GpioPinDriveMode): boolean;
		onvaluechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Gpio.GpioPin, Windows.Devices.Gpio.GpioPinValueChangedEventArgs>;
		addEventListener(
		type: "valuechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Gpio.GpioPin, Windows.Devices.Gpio.GpioPinValueChangedEventArgs>
	): void;
		removeEventListener(
		type: "valuechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Gpio.GpioPin, Windows.Devices.Gpio.GpioPinValueChangedEventArgs>
	): void;
		pinNumber: number;
		read(): Windows.Devices.Gpio.GpioPinValue;
		setDriveMode(value: Windows.Devices.Gpio.GpioPinDriveMode): void;
		sharingMode: Windows.Devices.Gpio.GpioSharingMode;
		write(value: Windows.Devices.Gpio.GpioPinValue): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class GpioPinValueChangedEventArgs  {
		edge: Windows.Devices.Gpio.GpioPinEdge
	}

	
}

declare module 'HumanInterfaceDevice' {
				declare class HidBooleanControl  {
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription;
		id: number;
		isActive: boolean;
		usageId: number;
		usagePage: number
	}

	declare class HidBooleanControlDescription  {
		id: number;
		parentCollections: Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidCollection>;
		reportId: number;
		reportType: Windows.Devices.HumanInterfaceDevice.HidReportType;
		usageId: number;
		usagePage: number
	}

	declare class HidCollection  {
		id: number;
		type: Windows.Devices.HumanInterfaceDevice.HidCollectionType;
		usageId: number;
		usagePage: number
	}

	declare class HidDevice  {
		fromIdAsync(
		deviceId: string, accessMode: Windows.Storage.FileAccessMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.HumanInterfaceDevice.HidDevice>;
		getDeviceSelector(usagePage: number, usageId: number): string;
		getDeviceSelector(
		usagePage: number, usageId: number, vendorId: number, productId: number
	): string;
		close(): void;
		createFeatureReport(): Windows.Devices.HumanInterfaceDevice.HidFeatureReport;
		createFeatureReport(reportId: number): Windows.Devices.HumanInterfaceDevice.HidFeatureReport;
		createOutputReport(): Windows.Devices.HumanInterfaceDevice.HidOutputReport;
		createOutputReport(reportId: number): Windows.Devices.HumanInterfaceDevice.HidOutputReport;
		getBooleanControlDescriptions(
		reportType: Windows.Devices.HumanInterfaceDevice.HidReportType, usagePage: number, usageId: number
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription>;
		getFeatureReportAsync(
		reportId: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.HumanInterfaceDevice.HidFeatureReport>;
		getFeatureReportAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.HumanInterfaceDevice.HidFeatureReport>;
		getInputReportAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.HumanInterfaceDevice.HidInputReport>;
		getInputReportAsync(
		reportId: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.HumanInterfaceDevice.HidInputReport>;
		getNumericControlDescriptions(
		reportType: Windows.Devices.HumanInterfaceDevice.HidReportType, usagePage: number, usageId: number
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription>;
		oninputreportreceived: Windows.Foundation.TypedEventHandler<Windows.Devices.HumanInterfaceDevice.HidDevice, Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs>;
		addEventListener(
		type: "inputreportreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.HumanInterfaceDevice.HidDevice, Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs>
	): void;
		removeEventListener(
		type: "inputreportreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.HumanInterfaceDevice.HidDevice, Windows.Devices.HumanInterfaceDevice.HidInputReportReceivedEventArgs>
	): void;
		productId: number;
		sendFeatureReportAsync(
		featureReport: Windows.Devices.HumanInterfaceDevice.HidFeatureReport
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		sendOutputReportAsync(
		outputReport: Windows.Devices.HumanInterfaceDevice.HidOutputReport
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		usageId: number;
		usagePage: number;
		vendorId: number;
		version: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class HidFeatureReport  {
		data: Windows.Storage.Streams.IBuffer;
		getBooleanControl(
		usagePage: number, usageId: number
	): Windows.Devices.HumanInterfaceDevice.HidBooleanControl;
		getBooleanControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidBooleanControl;
		getNumericControl(
		usagePage: number, usageId: number
	): Windows.Devices.HumanInterfaceDevice.HidNumericControl;
		getNumericControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidNumericControl;
		id: number
	}

	declare class HidInputReport  {
		activatedBooleanControls: Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidBooleanControl>;
		data: Windows.Storage.Streams.IBuffer;
		getBooleanControl: any;
		getBooleanControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidBooleanControl;
		getNumericControl: any;
		getNumericControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidNumericControl;
		id: number;
		transitionedBooleanControls: Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidBooleanControl>
	}

	declare class HidInputReportReceivedEventArgs  {
		report: Windows.Devices.HumanInterfaceDevice.HidInputReport
	}

	declare class HidNumericControl  {
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription;
		id: number;
		isGrouped: boolean;
		scaledValue: number;
		usageId: number;
		usagePage: number;
		value: number
	}

	declare class HidNumericControlDescription  {
		hasNull: boolean;
		id: number;
		isAbsolute: boolean;
		logicalMaximum: number;
		logicalMinimum: number;
		parentCollections: Windows.Foundation.Collections.IVectorView<Windows.Devices.HumanInterfaceDevice.HidCollection>;
		physicalMaximum: number;
		physicalMinimum: number;
		reportCount: number;
		reportId: number;
		reportSize: number;
		reportType: Windows.Devices.HumanInterfaceDevice.HidReportType;
		unit: number;
		unitExponent: number;
		usageId: number;
		usagePage: number
	}

	declare class HidOutputReport  {
		data: Windows.Storage.Streams.IBuffer;
		getBooleanControl: any;
		getBooleanControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidBooleanControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidBooleanControl;
		getNumericControl: any;
		getNumericControlByDescription(
		controlDescription: Windows.Devices.HumanInterfaceDevice.HidNumericControlDescription
	): Windows.Devices.HumanInterfaceDevice.HidNumericControl;
		id: number
	}

	
}

declare module 'I2c' {
		declare interface I2cTransferResult {
		bytesTransferred: number,
		status: Windows.Devices.I2c.I2cTransferStatus
	}

		declare class I2cConnectionSettings  {
		constructor(slaveAddress: number): this;
		busSpeed: Windows.Devices.I2c.I2cBusSpeed;
		sharingMode: Windows.Devices.I2c.I2cSharingMode;
		slaveAddress: number
	}

	declare class I2cController  {
		getControllersAsync(
		provider: Windows.Devices.I2c.Provider.II2cProvider
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.I2c.I2cController>;
		getDevice(
		settings: Windows.Devices.I2c.I2cConnectionSettings
	): Windows.Devices.I2c.I2cDevice
	}

	declare class I2cDevice  {
		fromIdAsync(
		deviceId: string, settings: Windows.Devices.I2c.I2cConnectionSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.I2c.I2cDevice>;
		getDeviceSelector(friendlyName: string): string;
		getDeviceSelector(): string;
		close(): void;
		connectionSettings: Windows.Devices.I2c.I2cConnectionSettings;
		deviceId: string;
		read(buffer: number[]): void;
		readPartial(buffer: number[]): Windows.Devices.I2c.I2cTransferResult;
		write(buffer: number[]): void;
		writePartial(buffer: number[]): Windows.Devices.I2c.I2cTransferResult;
		writeRead(writeBuffer: number[], readBuffer: number[]): void;
		writeReadPartial(
		writeBuffer: number[], readBuffer: number[]
	): Windows.Devices.I2c.I2cTransferResult
	}

	
}

declare module 'Input' {
		declare interface MouseDelta {
		x: number,
		y: number
	}

	declare interface PointerDeviceUsage {
		maxLogical: number,
		maxPhysical: number,
		minLogical: number,
		minPhysical: number,
		physicalMultiplier: number,
		unit: number,
		usage: number,
		usagePage: number
	}

	declare interface GamepadReading {
		buttons: Windows.Gaming.Input.GamepadButtons,
		leftThumbstickX: number,
		leftThumbstickY: number,
		leftTrigger: number,
		rightThumbstickX: number,
		rightThumbstickY: number,
		rightTrigger: number,
		timestamp: number
	}

	declare interface IGameController {
		headset: Windows.Gaming.Input.Headset,
		isWireless: boolean,
		user: Windows.System.User
	}

	declare interface GamepadVibration {
		leftMotor: number,
		leftTrigger: number,
		rightMotor: number,
		rightTrigger: number
	}

	declare interface CrossSlideThresholds {
		rearrangeStart: number,
		selectionStart: number,
		speedBumpEnd: number,
		speedBumpStart: number
	}

	declare interface ManipulationDelta {
		expansion: number,
		rotation: number,
		scale: number,
		translation: Windows.Foundation.Point
	}

	declare interface ManipulationVelocities {
		angular: number,
		expansion: number,
		linear: Windows.Foundation.Point
	}

	declare interface IPointerPointTransform {
		transformBounds(rect: Windows.Foundation.Rect): Windows.Foundation.Rect,
		tryTransform(
		inPoint: Windows.Foundation.Point
	): {
		outPoint: Windows.Foundation.Point,
		returnValue: boolean
	},
		inverse: Windows.UI.Input.IPointerPointTransform
	}

		declare class KeyboardCapabilities  {
		constructor(): this;
		keyboardPresent: number
	}

	declare class MouseCapabilities  {
		constructor(): this;
		horizontalWheelPresent: number;
		mousePresent: number;
		numberOfButtons: number;
		swapButtons: number;
		verticalWheelPresent: number
	}

	declare class MouseDevice  {
		getForCurrentView(): Windows.Devices.Input.MouseDevice;
		onmousemoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice, Windows.Devices.Input.MouseEventArgs>;
		addEventListener(
		type: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice, Windows.Devices.Input.MouseEventArgs>
	): void;
		removeEventListener(
		type: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice, Windows.Devices.Input.MouseEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MouseEventArgs  {
		mouseDelta: Windows.Devices.Input.MouseDelta
	}

	declare class PointerDevice  {
		getPointerDevice(pointerId: number): Windows.Devices.Input.PointerDevice;
		getPointerDevices(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDevice>;
		isIntegrated: boolean;
		maxContacts: number;
		maxPointersWithZDistance: any;
		physicalDeviceRect: Windows.Foundation.Rect;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		screenRect: Windows.Foundation.Rect;
		supportedUsages: Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDeviceUsage>
	}

	declare class TouchCapabilities  {
		constructor(): this;
		contacts: number;
		touchPresent: number
	}

	declare class Gamepad  {
		gamepads: Windows.Foundation.Collections.IVectorView<Windows.Gaming.Input.Gamepad>;
		ongamepadadded: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "gamepadadded", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "gamepadadded", listener: Windows.Foundation.EventHandler<any>): void;
		ongamepadremoved: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "gamepadremoved", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "gamepadremoved", listener: Windows.Foundation.EventHandler<any>): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		getCurrentReading(): Windows.Gaming.Input.GamepadReading;
		headset: Windows.Gaming.Input.Headset;
		isWireless: boolean;
		onheadsetconnected: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>;
		addEventListener(
		type: "headsetconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>
	): void;
		removeEventListener(
		type: "headsetconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>
	): void;
		onheadsetdisconnected: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>;
		addEventListener(
		type: "headsetdisconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>
	): void;
		removeEventListener(
		type: "headsetdisconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.Gaming.Input.Headset>
	): void;
		onuserchanged: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.System.UserChangedEventArgs>;
		addEventListener(
		type: "userchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.System.UserChangedEventArgs>
	): void;
		removeEventListener(
		type: "userchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Gaming.Input.IGameController, Windows.System.UserChangedEventArgs>
	): void;
		user: Windows.System.User;
		vibration: Windows.Gaming.Input.GamepadVibration;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class Headset  {
		captureDeviceId: string;
		renderDeviceId: string
	}

	declare class CrossSlidingEventArgs  {
		crossSlidingState: Windows.UI.Input.CrossSlidingState;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point
	}

	declare class DraggingEventArgs  {
		draggingState: Windows.UI.Input.DraggingState;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point
	}

	declare class EdgeGesture  {
		getForCurrentView(): Windows.UI.Input.EdgeGesture;
		oncanceled: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>;
		addEventListener(
		type: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		removeEventListener(
		type: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		oncompleted: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>;
		addEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		removeEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		onstarting: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>;
		addEventListener(
		type: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		removeEventListener(
		type: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture, Windows.UI.Input.EdgeGestureEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class EdgeGestureEventArgs  {
		kind: Windows.UI.Input.EdgeGestureKind
	}

	declare class GestureRecognizer  {
		constructor(): this;
		autoProcessInertia: boolean;
		canBeDoubleTap(value: Windows.UI.Input.PointerPoint): boolean;
		completeGesture(): void;
		crossSlideExact: boolean;
		crossSlideHorizontally: boolean;
		crossSlideThresholds: Windows.UI.Input.CrossSlideThresholds;
		gestureSettings: Windows.UI.Input.GestureSettings;
		inertiaExpansion: number;
		inertiaExpansionDeceleration: number;
		inertiaRotationAngle: number;
		inertiaRotationDeceleration: number;
		inertiaTranslationDeceleration: number;
		inertiaTranslationDisplacement: number;
		isActive: boolean;
		isInertial: boolean;
		manipulationExact: boolean;
		mouseWheelParameters: Windows.UI.Input.MouseWheelParameters;
		oncrosssliding: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.CrossSlidingEventArgs>;
		addEventListener(
		type: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.CrossSlidingEventArgs>
	): void;
		removeEventListener(
		type: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.CrossSlidingEventArgs>
	): void;
		ondragging: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.DraggingEventArgs>;
		addEventListener(
		type: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.DraggingEventArgs>
	): void;
		removeEventListener(
		type: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.DraggingEventArgs>
	): void;
		onholding: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.HoldingEventArgs>;
		addEventListener(
		type: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.HoldingEventArgs>
	): void;
		removeEventListener(
		type: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.HoldingEventArgs>
	): void;
		onmanipulationcompleted: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationCompletedEventArgs>;
		addEventListener(
		type: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationCompletedEventArgs>
	): void;
		removeEventListener(
		type: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationCompletedEventArgs>
	): void;
		onmanipulationinertiastarting: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationInertiaStartingEventArgs>;
		addEventListener(
		type: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationInertiaStartingEventArgs>
	): void;
		removeEventListener(
		type: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationInertiaStartingEventArgs>
	): void;
		onmanipulationstarted: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationStartedEventArgs>;
		addEventListener(
		type: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationStartedEventArgs>
	): void;
		removeEventListener(
		type: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationStartedEventArgs>
	): void;
		onmanipulationupdated: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationUpdatedEventArgs>;
		addEventListener(
		type: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.ManipulationUpdatedEventArgs>
	): void;
		onrighttapped: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.RightTappedEventArgs>;
		addEventListener(
		type: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.RightTappedEventArgs>
	): void;
		removeEventListener(
		type: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.RightTappedEventArgs>
	): void;
		ontapped: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.TappedEventArgs>;
		addEventListener(
		type: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.TappedEventArgs>
	): void;
		removeEventListener(
		type: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer, Windows.UI.Input.TappedEventArgs>
	): void;
		pivotCenter: Windows.Foundation.Point;
		pivotRadius: number;
		processDownEvent(value: Windows.UI.Input.PointerPoint): void;
		processInertia(): void;
		processMouseWheelEvent(
		value: Windows.UI.Input.PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean
	): void;
		processMoveEvents(
		value: Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>
	): void;
		processUpEvent(value: Windows.UI.Input.PointerPoint): void;
		showGestureFeedback: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class HoldingEventArgs  {
		holdingState: Windows.UI.Input.HoldingState;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point
	}

	declare class KeyboardDeliveryInterceptor  {
		getForCurrentView(): Windows.UI.Input.KeyboardDeliveryInterceptor;
		isInterceptionEnabledWhenInForeground: boolean;
		onkeydown: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>;
		addEventListener(
		type: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>
	): void;
		removeEventListener(
		type: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>
	): void;
		onkeyup: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>;
		addEventListener(
		type: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>
	): void;
		removeEventListener(
		type: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.KeyboardDeliveryInterceptor, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ManipulationCompletedEventArgs  {
		cumulative: Windows.UI.Input.ManipulationDelta;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point;
		velocities: Windows.UI.Input.ManipulationVelocities
	}

	declare class ManipulationInertiaStartingEventArgs  {
		cumulative: Windows.UI.Input.ManipulationDelta;
		delta: Windows.UI.Input.ManipulationDelta;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point;
		velocities: Windows.UI.Input.ManipulationVelocities
	}

	declare class ManipulationStartedEventArgs  {
		cumulative: Windows.UI.Input.ManipulationDelta;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point
	}

	declare class ManipulationUpdatedEventArgs  {
		cumulative: Windows.UI.Input.ManipulationDelta;
		delta: Windows.UI.Input.ManipulationDelta;
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point;
		velocities: Windows.UI.Input.ManipulationVelocities
	}

	declare class MouseWheelParameters  {
		charTranslation: Windows.Foundation.Point;
		deltaRotationAngle: number;
		deltaScale: number;
		pageTranslation: Windows.Foundation.Point
	}

	declare class PointerPoint  {
		getCurrentPoint(pointerId: number): Windows.UI.Input.PointerPoint;
		getCurrentPoint(
		pointerId: number, transform: Windows.UI.Input.IPointerPointTransform
	): Windows.UI.Input.PointerPoint;
		getIntermediatePoints(
		pointerId: number, transform: Windows.UI.Input.IPointerPointTransform
	): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
		getIntermediatePoints(
		pointerId: number
	): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
		frameId: number;
		isInContact: boolean;
		pointerDevice: Windows.Devices.Input.PointerDevice;
		pointerId: number;
		position: Windows.Foundation.Point;
		properties: Windows.UI.Input.PointerPointProperties;
		rawPosition: Windows.Foundation.Point;
		timestamp: number
	}

	declare class PointerPointProperties  {
		contactRect: Windows.Foundation.Rect;
		contactRectRaw: Windows.Foundation.Rect;
		getUsageValue(usagePage: number, usageId: number): number;
		hasUsage(usagePage: number, usageId: number): boolean;
		isBarrelButtonPressed: boolean;
		isCanceled: boolean;
		isEraser: boolean;
		isHorizontalMouseWheel: boolean;
		isInRange: boolean;
		isInverted: boolean;
		isLeftButtonPressed: boolean;
		isMiddleButtonPressed: boolean;
		isPrimary: boolean;
		isRightButtonPressed: boolean;
		isXButton1Pressed: boolean;
		isXButton2Pressed: boolean;
		mouseWheelDelta: number;
		orientation: number;
		pointerUpdateKind: Windows.UI.Input.PointerUpdateKind;
		pressure: number;
		touchConfidence: boolean;
		twist: number;
		xtilt: number;
		ytilt: number;
		zdistance: any
	}

	declare class PointerVisualizationSettings  {
		getForCurrentView(): Windows.UI.Input.PointerVisualizationSettings;
		isBarrelButtonFeedbackEnabled: boolean;
		isContactFeedbackEnabled: boolean
	}

	declare class RightTappedEventArgs  {
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point
	}

	declare class TappedEventArgs  {
		pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
		position: Windows.Foundation.Point;
		tapCount: number
	}

	
}

declare module 'Lights' {
				declare class Lamp  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Lights.Lamp>;
		getDefaultAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Lights.Lamp>;
		getDeviceSelector(): string;
		brightnessLevel: number;
		close(): void;
		color: Windows.UI.Color;
		deviceId: string;
		isColorSettable: boolean;
		isEnabled: boolean;
		onavailabilitychanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Lights.Lamp, Windows.Devices.Lights.LampAvailabilityChangedEventArgs>;
		addEventListener(
		type: "availabilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Lights.Lamp, Windows.Devices.Lights.LampAvailabilityChangedEventArgs>
	): void;
		removeEventListener(
		type: "availabilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Lights.Lamp, Windows.Devices.Lights.LampAvailabilityChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LampAvailabilityChangedEventArgs  {
		isAvailable: boolean
	}

	
}

declare module 'Devices' {
	declare type CallControlEventHandler = (ev: WinRTEvent<Windows.Media.Devices.CallControl>) => void;

	declare type DialRequestedEventHandler = (
		ev: Windows.Media.Devices.DialRequestedEventArgs & WinRTEvent<Windows.Media.Devices.CallControl>
	) => void;

	declare type KeypadPressedEventHandler = (
		ev: Windows.Media.Devices.KeypadPressedEventArgs & WinRTEvent<Windows.Media.Devices.CallControl>
	) => void;

	declare type RedialRequestedEventHandler = (
		ev: Windows.Media.Devices.RedialRequestedEventArgs & WinRTEvent<Windows.Media.Devices.CallControl>
	) => void;

			declare class LowLevelDevicesAggregateProvider  {
		adcControllerProvider: any;
		gpioControllerProvider: any;
		i2cControllerProvider: any;
		pwmControllerProvider: any;
		spiControllerProvider: any
	}

	declare class LowLevelDevicesController  {
		defaultProvider: any
	}

	declare class AdvancedPhotoCaptureSettings  {
		constructor(): this;
		mode: Windows.Media.Devices.AdvancedPhotoMode
	}

	declare class AdvancedPhotoControl  {
		configure(settings: Windows.Media.Devices.AdvancedPhotoCaptureSettings): void;
		mode: Windows.Media.Devices.AdvancedPhotoMode;
		supported: boolean;
		supportedModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.AdvancedPhotoMode>
	}

	declare class AudioDeviceController  {
		getAvailableMediaStreamProperties(
		mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
		getMediaStreamProperties(
		mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Media.MediaProperties.IMediaEncodingProperties;
		muted: boolean;
		setMediaStreamPropertiesAsync(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncAction;
		volumePercent: number
	}

	declare class CallControl  {
		fromId(deviceId: string): Windows.Media.Devices.CallControl;
		getDefault(): Windows.Media.Devices.CallControl;
		endCall(callToken: number): void;
		hasRinger: boolean;
		indicateActiveCall(callToken: number): void;
		indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
		indicateNewOutgoingCall(): number;
		onanswerrequested: Windows.Media.Devices.CallControlEventHandler;
		addEventListener(
		type: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		removeEventListener(
		type: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		onaudiotransferrequested: Windows.Media.Devices.CallControlEventHandler;
		addEventListener(
		type: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		removeEventListener(
		type: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		ondialrequested: Windows.Media.Devices.DialRequestedEventHandler;
		addEventListener(
		type: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler
	): void;
		removeEventListener(
		type: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler
	): void;
		onhanguprequested: Windows.Media.Devices.CallControlEventHandler;
		addEventListener(
		type: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		removeEventListener(
		type: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler
	): void;
		onkeypadpressed: Windows.Media.Devices.KeypadPressedEventHandler;
		addEventListener(
		type: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler
	): void;
		removeEventListener(
		type: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler
	): void;
		onredialrequested: Windows.Media.Devices.RedialRequestedEventHandler;
		addEventListener(
		type: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler
	): void;
		removeEventListener(
		type: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DefaultAudioCaptureDeviceChangedEventArgs  {
		id: string;
		role: Windows.Media.Devices.AudioDeviceRole
	}

	declare class DefaultAudioRenderDeviceChangedEventArgs  {
		id: string;
		role: Windows.Media.Devices.AudioDeviceRole
	}

	declare class DialRequestedEventArgs  {
		contact: any;
		handled(): void
	}

	declare class ExposureCompensationControl  {
		max: number;
		min: number;
		setValueAsync(value: number): Windows.Foundation.IPromiseWithIAsyncAction;
		step: number;
		supported: boolean;
		value: number
	}

	declare class ExposureControl  {
		auto: boolean;
		max: number;
		min: number;
		setAutoAsync(value: boolean): Windows.Foundation.IPromiseWithIAsyncAction;
		setValueAsync(shutterDuration: number): Windows.Foundation.IPromiseWithIAsyncAction;
		step: number;
		supported: boolean;
		value: number
	}

	declare class ExposurePriorityVideoControl  {
		enabled: boolean;
		supported: boolean
	}

	declare class FlashControl  {
		assistantLightEnabled: boolean;
		assistantLightSupported: boolean;
		auto: boolean;
		enabled: boolean;
		powerPercent: number;
		powerSupported: boolean;
		redEyeReduction: boolean;
		redEyeReductionSupported: boolean;
		supported: boolean
	}

	declare class FocusControl  {
		configure(settings: Windows.Media.Devices.FocusSettings): void;
		focusAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		focusChangedSupported: boolean;
		focusState: Windows.Media.Devices.MediaCaptureFocusState;
		lockAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		max: number;
		min: number;
		mode: Windows.Media.Devices.FocusMode;
		preset: Windows.Media.Devices.FocusPreset;
		setPresetAsync(
		preset: Windows.Media.Devices.FocusPreset
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setPresetAsync(
		preset: Windows.Media.Devices.FocusPreset, completeBeforeFocus: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setValueAsync(focus: number): Windows.Foundation.IPromiseWithIAsyncAction;
		step: number;
		supported: boolean;
		supportedFocusDistances: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.ManualFocusDistance>;
		supportedFocusModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.FocusMode>;
		supportedFocusRanges: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.AutoFocusRange>;
		supportedPresets: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.FocusPreset>;
		unlockAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		value: number;
		waitForFocusSupported: boolean
	}

	declare class FocusSettings  {
		constructor(): this;
		autoFocusRange: Windows.Media.Devices.AutoFocusRange;
		disableDriverFallback: boolean;
		distance: Windows.Media.Devices.ManualFocusDistance;
		mode: Windows.Media.Devices.FocusMode;
		value: number;
		waitForFocus: boolean
	}

	declare class HdrVideoControl  {
		mode: Windows.Media.Devices.HdrVideoMode;
		supported: boolean;
		supportedModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.HdrVideoMode>
	}

	declare class IsoSpeedControl  {
		auto: boolean;
		max: number;
		min: number;
		preset: Windows.Media.Devices.IsoSpeedPreset;
		setAutoAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		setPresetAsync(
		preset: Windows.Media.Devices.IsoSpeedPreset
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setValueAsync(isoSpeed: number): Windows.Foundation.IPromiseWithIAsyncAction;
		step: number;
		supported: boolean;
		supportedPresets: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.IsoSpeedPreset>;
		value: number
	}

	declare class KeypadPressedEventArgs  {
		telephonyKey: Windows.Media.Devices.TelephonyKey
	}

	declare class LowLagPhotoControl  {
		desiredThumbnailSize: number;
		getCurrentFrameRate(): Windows.Media.MediaProperties.MediaRatio;
		getHighestConcurrentFrameRate(
		captureProperties: Windows.Media.MediaProperties.IMediaEncodingProperties
	): Windows.Media.MediaProperties.MediaRatio;
		hardwareAcceleratedThumbnailSupported: number;
		thumbnailEnabled: boolean;
		thumbnailFormat: Windows.Media.MediaProperties.MediaThumbnailFormat
	}

	declare class LowLagPhotoSequenceControl  {
		desiredThumbnailSize: number;
		getCurrentFrameRate(): Windows.Media.MediaProperties.MediaRatio;
		getHighestConcurrentFrameRate(
		captureProperties: Windows.Media.MediaProperties.IMediaEncodingProperties
	): Windows.Media.MediaProperties.MediaRatio;
		hardwareAcceleratedThumbnailSupported: number;
		maxPastPhotos: number;
		maxPhotosPerSecond: number;
		pastPhotoLimit: number;
		photosPerSecondLimit: number;
		supported: boolean;
		thumbnailEnabled: boolean;
		thumbnailFormat: Windows.Media.MediaProperties.MediaThumbnailFormat
	}

	declare class MediaDevice  {
		getAudioCaptureSelector(): string;
		getAudioRenderSelector(): string;
		getDefaultAudioCaptureId(role: Windows.Media.Devices.AudioDeviceRole): string;
		getDefaultAudioRenderId(role: Windows.Media.Devices.AudioDeviceRole): string;
		getVideoCaptureSelector(): string;
		ondefaultaudiocapturedevicechanged: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>;
		addEventListener(
		type: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>
	): void;
		removeEventListener(
		type: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>
	): void;
		ondefaultaudiorenderdevicechanged: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>;
		addEventListener(
		type: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>
	): void;
		removeEventListener(
		type: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaDeviceControl  {
		capabilities: Windows.Media.Devices.MediaDeviceControlCapabilities;
		tryGetAuto(): {
		value: boolean,
		returnValue: boolean
	};
		tryGetValue(): {
		value: number,
		returnValue: boolean
	};
		trySetAuto(value: boolean): boolean;
		trySetValue(value: number): boolean
	}

	declare class MediaDeviceControlCapabilities  {
		autoModeSupported: boolean;
		default: number;
		max: number;
		min: number;
		step: number;
		supported: boolean
	}

	declare class OpticalImageStabilizationControl  {
		mode: Windows.Media.Devices.OpticalImageStabilizationMode;
		supported: boolean;
		supportedModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.OpticalImageStabilizationMode>
	}

	declare class PhotoConfirmationControl  {
		enabled: boolean;
		pixelFormat: Windows.Media.MediaProperties.MediaPixelFormat;
		supported: boolean
	}

	declare class RedialRequestedEventArgs  {
		handled(): void
	}

	declare class RegionOfInterest  {
		constructor(): this;
		autoExposureEnabled: boolean;
		autoFocusEnabled: boolean;
		autoWhiteBalanceEnabled: boolean;
		bounds: Windows.Foundation.Rect;
		boundsNormalized: boolean;
		type: Windows.Media.Devices.RegionOfInterestType;
		weight: number
	}

	declare class RegionsOfInterestControl  {
		autoExposureSupported: boolean;
		autoFocusSupported: boolean;
		autoWhiteBalanceSupported: boolean;
		clearRegionsAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		maxRegions: number;
		setRegionsAsync(
		regions: Windows.Foundation.Collections.IIterable<Windows.Media.Devices.RegionOfInterest>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setRegionsAsync(
		regions: Windows.Foundation.Collections.IIterable<Windows.Media.Devices.RegionOfInterest>, lockValues: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class SceneModeControl  {
		setValueAsync(
		sceneMode: Windows.Media.Devices.CaptureSceneMode
	): Windows.Foundation.IPromiseWithIAsyncAction;
		supportedModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.CaptureSceneMode>;
		value: Windows.Media.Devices.CaptureSceneMode
	}

	declare class TorchControl  {
		enabled: boolean;
		powerPercent: number;
		powerSupported: boolean;
		supported: boolean
	}

	declare class VideoDeviceController  {
		advancedPhotoControl: Windows.Media.Devices.AdvancedPhotoControl;
		backlightCompensation: Windows.Media.Devices.MediaDeviceControl;
		brightness: Windows.Media.Devices.MediaDeviceControl;
		contrast: Windows.Media.Devices.MediaDeviceControl;
		desiredOptimization: Windows.Media.Devices.MediaCaptureOptimization;
		exposure: Windows.Media.Devices.MediaDeviceControl;
		exposureCompensationControl: Windows.Media.Devices.ExposureCompensationControl;
		exposureControl: Windows.Media.Devices.ExposureControl;
		exposurePriorityVideoControl: Windows.Media.Devices.ExposurePriorityVideoControl;
		flashControl: Windows.Media.Devices.FlashControl;
		focus: Windows.Media.Devices.MediaDeviceControl;
		focusControl: Windows.Media.Devices.FocusControl;
		getAvailableMediaStreamProperties(
		mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
		getDeviceProperty(propertyId: string): any;
		getMediaStreamProperties(
		mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Media.MediaProperties.IMediaEncodingProperties;
		hdrVideoControl: Windows.Media.Devices.HdrVideoControl;
		hue: Windows.Media.Devices.MediaDeviceControl;
		isoSpeedControl: Windows.Media.Devices.IsoSpeedControl;
		lowLagPhoto: Windows.Media.Devices.LowLagPhotoControl;
		lowLagPhotoSequence: Windows.Media.Devices.LowLagPhotoSequenceControl;
		opticalImageStabilizationControl: Windows.Media.Devices.OpticalImageStabilizationControl;
		pan: Windows.Media.Devices.MediaDeviceControl;
		photoConfirmationControl: Windows.Media.Devices.PhotoConfirmationControl;
		primaryUse: Windows.Media.Devices.CaptureUse;
		regionsOfInterestControl: Windows.Media.Devices.RegionsOfInterestControl;
		roll: Windows.Media.Devices.MediaDeviceControl;
		sceneModeControl: Windows.Media.Devices.SceneModeControl;
		setDeviceProperty(propertyId: string, propertyValue: any): void;
		setMediaStreamPropertiesAsync(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tilt: Windows.Media.Devices.MediaDeviceControl;
		torchControl: Windows.Media.Devices.TorchControl;
		tryGetPowerlineFrequency(
		
	): {
		value: Windows.Media.Capture.PowerlineFrequency,
		returnValue: boolean
	};
		trySetPowerlineFrequency(value: Windows.Media.Capture.PowerlineFrequency): boolean;
		variablePhotoSequenceController: Windows.Media.Devices.Core.VariablePhotoSequenceController;
		whiteBalance: Windows.Media.Devices.MediaDeviceControl;
		whiteBalanceControl: Windows.Media.Devices.WhiteBalanceControl;
		zoom: Windows.Media.Devices.MediaDeviceControl;
		zoomControl: Windows.Media.Devices.ZoomControl
	}

	declare class WhiteBalanceControl  {
		max: number;
		min: number;
		preset: Windows.Media.Devices.ColorTemperaturePreset;
		setPresetAsync(
		preset: Windows.Media.Devices.ColorTemperaturePreset
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setValueAsync(temperature: number): Windows.Foundation.IPromiseWithIAsyncAction;
		step: number;
		supported: boolean;
		value: number
	}

	declare class ZoomControl  {
		configure(settings: Windows.Media.Devices.ZoomSettings): void;
		max: number;
		min: number;
		mode: Windows.Media.Devices.ZoomTransitionMode;
		step: number;
		supported: boolean;
		supportedModes: Windows.Foundation.Collections.IVectorView<Windows.Media.Devices.ZoomTransitionMode>;
		value: number
	}

	declare class ZoomSettings  {
		constructor(): this;
		mode: Windows.Media.Devices.ZoomTransitionMode;
		value: number
	}

	
}

declare module 'Midi' {
		declare interface IMidiMessage {
		rawData: Windows.Storage.Streams.IBuffer,
		timestamp: number,
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare interface IMidiOutPort {
		sendBuffer(midiData: Windows.Storage.Streams.IBuffer): void,
		sendMessage(midiMessage: Windows.Devices.Midi.IMidiMessage): void,
		deviceId: string
	}

		declare class MidiActiveSensingMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiChannelPressureMessage  {
		constructor(channel: number, pressure: number): this;
		channel: number;
		pressure: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiContinueMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiControlChangeMessage  {
		constructor(channel: number, controller: number, controlValue: number): this;
		channel: number;
		controlValue: number;
		controller: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiInPort  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Midi.MidiInPort>;
		getDeviceSelector(): string;
		close(): void;
		deviceId: string;
		onmessagereceived: Windows.Foundation.TypedEventHandler<Windows.Devices.Midi.MidiInPort, Windows.Devices.Midi.MidiMessageReceivedEventArgs>;
		addEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Midi.MidiInPort, Windows.Devices.Midi.MidiMessageReceivedEventArgs>
	): void;
		removeEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Midi.MidiInPort, Windows.Devices.Midi.MidiMessageReceivedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MidiMessageReceivedEventArgs  {
		message: Windows.Devices.Midi.IMidiMessage
	}

	declare class MidiNoteOffMessage  {
		constructor(channel: number, note: number, velocity: number): this;
		channel: number;
		note: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType;
		velocity: number
	}

	declare class MidiNoteOnMessage  {
		constructor(channel: number, note: number, velocity: number): this;
		channel: number;
		note: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType;
		velocity: number
	}

	declare class MidiOutPort  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Midi.IMidiOutPort>;
		getDeviceSelector(): string;
		close(): void;
		deviceId: string;
		sendBuffer(midiData: Windows.Storage.Streams.IBuffer): void;
		sendMessage(midiMessage: Windows.Devices.Midi.IMidiMessage): void
	}

	declare class MidiPitchBendChangeMessage  {
		constructor(channel: number, bend: number): this;
		bend: number;
		channel: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiPolyphonicKeyPressureMessage  {
		constructor(channel: number, note: number, pressure: number): this;
		channel: number;
		note: number;
		pressure: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiProgramChangeMessage  {
		constructor(channel: number, program: number): this;
		channel: number;
		program: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiSongPositionPointerMessage  {
		constructor(beats: number): this;
		beats: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiSongSelectMessage  {
		constructor(song: number): this;
		rawData: Windows.Storage.Streams.IBuffer;
		song: number;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiStartMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiStopMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiSynthesizer  {
		createAsync(
		audioDevice: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Midi.MidiSynthesizer>;
		createAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Midi.MidiSynthesizer>;
		isSynthesizer(midiDevice: Windows.Devices.Enumeration.DeviceInformation): boolean;
		audioDevice: Windows.Devices.Enumeration.DeviceInformation;
		close(): void;
		deviceId: string;
		sendBuffer(midiData: Windows.Storage.Streams.IBuffer): void;
		sendMessage(midiMessage: Windows.Devices.Midi.IMidiMessage): void;
		volume: number
	}

	declare class MidiSystemExclusiveMessage  {
		constructor(rawData: Windows.Storage.Streams.IBuffer): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiSystemResetMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiTimeCodeMessage  {
		constructor(frameType: number, values: number): this;
		frameType: number;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType;
		values: number
	}

	declare class MidiTimingClockMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	declare class MidiTuneRequestMessage  {
		constructor(): this;
		rawData: Windows.Storage.Streams.IBuffer;
		timestamp: number;
		type: Windows.Devices.Midi.MidiMessageType
	}

	
}

declare module 'Perception' {
				declare class KnownCameraIntrinsicsProperties  {
		focalLength: string;
		principalPoint: string;
		radialDistortion: string;
		tangentialDistortion: string
	}

	declare class KnownPerceptionColorFrameSourceProperties  {
		autoExposureEnabled: string;
		exposure: string;
		exposureCompensation: string
	}

	declare class KnownPerceptionDepthFrameSourceProperties  {
		maxDepth: string;
		minDepth: string
	}

	declare class KnownPerceptionFrameSourceProperties  {
		deviceId: any;
		deviceModelVersion: string;
		enclosureLocation: string;
		frameKind: string;
		id: string;
		physicalDeviceIds: string
	}

	declare class KnownPerceptionInfraredFrameSourceProperties  {
		activeIlluminationEnabled: string;
		ambientSubtractionEnabled: string;
		autoExposureEnabled: string;
		exposure: string;
		exposureCompensation: string;
		interleavedIlluminationEnabled: string;
		structureLightPatternEnabled: string
	}

	declare class KnownPerceptionVideoFrameSourceProperties  {
		availableVideoProfiles: string;
		cameraIntrinsics: string;
		isMirrored: string;
		supportedVideoProfiles: string;
		videoProfile: string
	}

	declare class KnownPerceptionVideoProfileProperties  {
		bitmapAlphaMode: string;
		bitmapPixelFormat: string;
		frameDuration: string;
		height: string;
		width: string
	}

	declare class PerceptionColorFrame  {
		close(): void;
		videoFrame: Windows.Media.VideoFrame
	}

	declare class PerceptionColorFrameArrivedEventArgs  {
		relativeTime: number;
		tryOpenFrame(): Windows.Devices.Perception.PerceptionColorFrame
	}

	declare class PerceptionColorFrameReader  {
		close(): void;
		isPaused: boolean;
		onframearrived: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameReader, Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs>;
		addEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameReader, Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs>
	): void;
		removeEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameReader, Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs>
	): void;
		source: Windows.Devices.Perception.PerceptionColorFrameSource;
		tryReadLatestFrame(): Windows.Devices.Perception.PerceptionColorFrame;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionColorFrameSource  {
		createWatcher(): Windows.Devices.Perception.PerceptionColorFrameSourceWatcher;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		fromIdAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionColorFrameSource>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>;
		acquireControlSession(): Windows.Devices.Perception.PerceptionControlSession;
		active: boolean;
		available: boolean;
		availableVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		cameraIntrinsics: Windows.Media.Devices.Core.CameraIntrinsics;
		canControlIndependentlyFrom(targetId: string): boolean;
		deviceId: any;
		deviceKind: string;
		displayName: string;
		id: string;
		isControlled: boolean;
		isCorrelatedWith(targetId: string): boolean;
		onactivechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>;
		addEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		removeEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		onavailablechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>;
		addEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		removeEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		oncameraintrinsicschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>;
		addEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		removeEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		onpropertieschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>;
		addEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		removeEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		onvideoprofilechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>;
		addEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		removeEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSource, any>
	): void;
		openReader(): Windows.Devices.Perception.PerceptionColorFrameReader;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		supportedVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		tryGetDepthCorrelatedCameraIntrinsicsAsync(
		correlatedDepthFrameSource: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>;
		tryGetDepthCorrelatedCoordinateMapperAsync(
		targetSourceId: string, correlatedDepthFrameSource: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>;
		tryGetTransformTo(
		targetId: string
	): {
		result: Windows.Foundation.Numerics.Matrix4x4,
		returnValue: boolean
	};
		trySetVideoProfileAsync(
		controlSession: Windows.Devices.Perception.PerceptionControlSession, profile: Windows.Devices.Perception.PerceptionVideoProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>;
		videoProfile: Windows.Devices.Perception.PerceptionVideoProfile;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionColorFrameSourceAddedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionColorFrameSource
	}

	declare class PerceptionColorFrameSourceRemovedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionColorFrameSource
	}

	declare class PerceptionColorFrameSourceWatcher  {
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>
	): void;
		onsourceadded: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs>;
		addEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs>
	): void;
		removeEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs>
	): void;
		onsourceremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs>;
		addEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs>
	): void;
		removeEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionColorFrameSourceWatcher, any>
	): void;
		start(): void;
		status: Windows.Devices.Enumeration.DeviceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionControlSession  {
		close(): void;
		oncontrollost: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionControlSession, any>;
		addEventListener(
		type: "controllost", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionControlSession, any>
	): void;
		removeEventListener(
		type: "controllost", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionControlSession, any>
	): void;
		trySetPropertyAsync(
		name: string, value: any
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionDepthCorrelatedCameraIntrinsics  {
		unprojectAllPixelsAtCorrelatedDepthAsync(
		depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): {
		results: Windows.Foundation.Numerics.Vector3,
		returnValue: Windows.Foundation.IPromiseWithIAsyncAction
	};
		unprojectPixelAtCorrelatedDepth(
		pixelCoordinate: Windows.Foundation.Point, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): Windows.Foundation.Numerics.Vector3;
		unprojectPixelsAtCorrelatedDepth(
		sourceCoordinates: Windows.Foundation.Point, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): Windows.Foundation.Numerics.Vector3;
		unprojectRegionPixelsAtCorrelatedDepthAsync(
		region: Windows.Foundation.Rect, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): {
		results: Windows.Foundation.Numerics.Vector3,
		returnValue: Windows.Foundation.IPromiseWithIAsyncAction
	}
	}

	declare class PerceptionDepthCorrelatedCoordinateMapper  {
		mapAllPixelsToTargetAsync(
		depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): {
		targetCoordinates: Windows.Foundation.Point,
		returnValue: Windows.Foundation.IPromiseWithIAsyncAction
	};
		mapPixelToTarget(
		sourcePixelCoordinate: Windows.Foundation.Point, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): Windows.Foundation.Point;
		mapPixelsToTarget(
		sourceCoordinates: Windows.Foundation.Point, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): Windows.Foundation.Point;
		mapRegionOfPixelsToTargetAsync(
		region: Windows.Foundation.Rect, depthFrame: Windows.Devices.Perception.PerceptionDepthFrame
	): {
		targetCoordinates: Windows.Foundation.Point,
		returnValue: Windows.Foundation.IPromiseWithIAsyncAction
	}
	}

	declare class PerceptionDepthFrame  {
		close(): void;
		videoFrame: Windows.Media.VideoFrame
	}

	declare class PerceptionDepthFrameArrivedEventArgs  {
		relativeTime: number;
		tryOpenFrame(): Windows.Devices.Perception.PerceptionDepthFrame
	}

	declare class PerceptionDepthFrameReader  {
		close(): void;
		isPaused: boolean;
		onframearrived: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameReader, Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs>;
		addEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameReader, Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs>
	): void;
		removeEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameReader, Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs>
	): void;
		source: Windows.Devices.Perception.PerceptionDepthFrameSource;
		tryReadLatestFrame(): Windows.Devices.Perception.PerceptionDepthFrame;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionDepthFrameSource  {
		createWatcher(): Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		fromIdAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthFrameSource>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>;
		acquireControlSession(): Windows.Devices.Perception.PerceptionControlSession;
		active: boolean;
		available: boolean;
		availableVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		cameraIntrinsics: Windows.Media.Devices.Core.CameraIntrinsics;
		canControlIndependentlyFrom(targetId: string): boolean;
		deviceId: any;
		deviceKind: string;
		displayName: string;
		id: string;
		isControlled: boolean;
		isCorrelatedWith(targetId: string): boolean;
		onactivechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>;
		addEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		removeEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		onavailablechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>;
		addEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		removeEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		oncameraintrinsicschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>;
		addEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		removeEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		onpropertieschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>;
		addEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		removeEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		onvideoprofilechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>;
		addEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		removeEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSource, any>
	): void;
		openReader(): Windows.Devices.Perception.PerceptionDepthFrameReader;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		supportedVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		tryGetDepthCorrelatedCameraIntrinsicsAsync(
		target: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>;
		tryGetDepthCorrelatedCoordinateMapperAsync(
		targetId: string, depthFrameSourceToMapWith: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>;
		tryGetTransformTo(
		targetId: string
	): {
		result: Windows.Foundation.Numerics.Matrix4x4,
		returnValue: boolean
	};
		trySetVideoProfileAsync(
		controlSession: Windows.Devices.Perception.PerceptionControlSession, profile: Windows.Devices.Perception.PerceptionVideoProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>;
		videoProfile: Windows.Devices.Perception.PerceptionVideoProfile;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionDepthFrameSourceAddedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionDepthFrameSource
	}

	declare class PerceptionDepthFrameSourceRemovedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionDepthFrameSource
	}

	declare class PerceptionDepthFrameSourceWatcher  {
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>
	): void;
		onsourceadded: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs>;
		addEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs>
	): void;
		removeEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs>
	): void;
		onsourceremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs>;
		addEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs>
	): void;
		removeEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher, any>
	): void;
		start(): void;
		status: Windows.Devices.Enumeration.DeviceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionFrameSourcePropertiesChangedEventArgs  {
		collectionChange: Windows.Foundation.Collections.CollectionChange;
		key: string
	}

	declare class PerceptionFrameSourcePropertyChangeResult  {
		newValue: any;
		status: Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeStatus
	}

	declare class PerceptionInfraredFrame  {
		close(): void;
		videoFrame: Windows.Media.VideoFrame
	}

	declare class PerceptionInfraredFrameArrivedEventArgs  {
		relativeTime: number;
		tryOpenFrame(): Windows.Devices.Perception.PerceptionInfraredFrame
	}

	declare class PerceptionInfraredFrameReader  {
		close(): void;
		isPaused: boolean;
		onframearrived: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameReader, Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs>;
		addEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameReader, Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs>
	): void;
		removeEventListener(
		type: "framearrived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameReader, Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs>
	): void;
		source: Windows.Devices.Perception.PerceptionInfraredFrameSource;
		tryReadLatestFrame(): Windows.Devices.Perception.PerceptionInfraredFrame;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionInfraredFrameSource  {
		createWatcher(): Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		fromIdAsync(
		id: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionInfraredFrameSource>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourceAccessStatus>;
		acquireControlSession(): Windows.Devices.Perception.PerceptionControlSession;
		active: boolean;
		available: boolean;
		availableVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		cameraIntrinsics: Windows.Media.Devices.Core.CameraIntrinsics;
		canControlIndependentlyFrom(targetId: string): boolean;
		deviceId: any;
		deviceKind: string;
		displayName: string;
		id: string;
		isControlled: boolean;
		isCorrelatedWith(targetId: string): boolean;
		onactivechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>;
		addEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		removeEventListener(
		type: "activechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		onavailablechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>;
		addEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		removeEventListener(
		type: "availablechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		oncameraintrinsicschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>;
		addEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		removeEventListener(
		type: "cameraintrinsicschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		onpropertieschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>;
		addEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		removeEventListener(
		type: "propertieschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs>
	): void;
		onvideoprofilechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>;
		addEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		removeEventListener(
		type: "videoprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSource, any>
	): void;
		openReader(): Windows.Devices.Perception.PerceptionInfraredFrameReader;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		supportedVideoProfiles: Windows.Foundation.Collections.IVectorView<Windows.Devices.Perception.PerceptionVideoProfile>;
		tryGetDepthCorrelatedCameraIntrinsicsAsync(
		target: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics>;
		tryGetDepthCorrelatedCoordinateMapperAsync(
		targetId: string, depthFrameSourceToMapWith: Windows.Devices.Perception.PerceptionDepthFrameSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper>;
		tryGetTransformTo(
		targetId: string
	): {
		result: Windows.Foundation.Numerics.Matrix4x4,
		returnValue: boolean
	};
		trySetVideoProfileAsync(
		controlSession: Windows.Devices.Perception.PerceptionControlSession, profile: Windows.Devices.Perception.PerceptionVideoProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult>;
		videoProfile: Windows.Devices.Perception.PerceptionVideoProfile;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionInfraredFrameSourceAddedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionInfraredFrameSource
	}

	declare class PerceptionInfraredFrameSourceRemovedEventArgs  {
		frameSource: Windows.Devices.Perception.PerceptionInfraredFrameSource
	}

	declare class PerceptionInfraredFrameSourceWatcher  {
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>
	): void;
		onsourceadded: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs>;
		addEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs>
	): void;
		removeEventListener(
		type: "sourceadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs>
	): void;
		onsourceremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs>;
		addEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs>
	): void;
		removeEventListener(
		type: "sourceremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher, any>
	): void;
		start(): void;
		status: Windows.Devices.Enumeration.DeviceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PerceptionVideoProfile  {
		bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
		bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
		frameDuration: number;
		height: number;
		isEqual(other: Windows.Devices.Perception.PerceptionVideoProfile): boolean;
		width: number
	}

	declare class PerceptionTimestamp  {
		predictionAmount: any;
		targetTime: any
	}

	declare class PerceptionTimestampHelper  {
		fromHistoricalTargetTime: any
	}

	
}

declare module 'PointOfService' {
				declare class BarcodeScanner  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.BarcodeScanner>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.BarcodeScanner>;
		getDeviceSelector(): string;
		capabilities: Windows.Devices.PointOfService.BarcodeScannerCapabilities;
		checkHealthAsync(
		level: Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		claimScannerAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.ClaimedBarcodeScanner>;
		deviceId: string;
		getSupportedProfiles(): Windows.Foundation.Collections.IVectorView<string>;
		getSupportedSymbologiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		isProfileSupported(profile: string): boolean;
		isSymbologySupportedAsync(
		barcodeSymbology: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		onstatusupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.BarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs>;
		addEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.BarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.BarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs>
	): void;
		retrieveStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BarcodeScannerCapabilities  {
		isImagePreviewSupported: boolean;
		isSoftwareTriggerSupported: boolean;
		isStatisticsReportingSupported: boolean;
		isStatisticsUpdatingSupported: boolean;
		powerReportingType: Windows.Devices.PointOfService.UnifiedPosPowerReportingType
	}

	declare class BarcodeScannerDataReceivedEventArgs  {
		report: Windows.Devices.PointOfService.BarcodeScannerReport
	}

	declare class BarcodeScannerErrorOccurredEventArgs  {
		errorData: Windows.Devices.PointOfService.UnifiedPosErrorData;
		isRetriable: boolean;
		partialInputData: Windows.Devices.PointOfService.BarcodeScannerReport
	}

	declare class BarcodeScannerImagePreviewReceivedEventArgs  {
		preview: Windows.Storage.Streams.IRandomAccessStreamWithContentType
	}

	declare class BarcodeScannerReport  {
		scanData: Windows.Storage.Streams.IBuffer;
		scanDataLabel: Windows.Storage.Streams.IBuffer;
		scanDataType: number
	}

	declare class BarcodeScannerStatusUpdatedEventArgs  {
		extendedStatus: number;
		status: Windows.Devices.PointOfService.BarcodeScannerStatus
	}

	declare class BarcodeSymbologies  {
		ausPost: number;
		aztec: number;
		canPost: number;
		ccab: number;
		ccc: number;
		chinaPost: number;
		codabar: number;
		codablock128: number;
		codablockA: number;
		codablockF: number;
		code11: number;
		code128: number;
		code16k: number;
		code32: number;
		code39: number;
		code39Ex: number;
		code49: number;
		code93: number;
		code93Ex: number;
		dataCode: number;
		dataMatrix: number;
		dutchKix: number;
		ean13: number;
		ean13Add2: number;
		ean13Add5: number;
		ean8: number;
		ean8Add2: number;
		ean8Add5: number;
		ean99: number;
		ean99Add2: number;
		ean99Add5: number;
		eanv: number;
		eanvAdd2: number;
		eanvAdd5: number;
		extendedBase: number;
		getName(scanDataType: number): string;
		gs1128: number;
		gs1128Coupon: number;
		gs1DatabarType1: number;
		gs1DatabarType2: number;
		gs1DatabarType3: number;
		hanXin: number;
		infoMail: number;
		isbn: number;
		isbnAdd5: number;
		isbt: number;
		ismn: number;
		ismnAdd2: number;
		ismnAdd5: number;
		issn: number;
		issnAdd2: number;
		issnAdd5: number;
		italianPost25: number;
		italianPost39: number;
		japanPost: number;
		koreanPost: number;
		maxicode: number;
		micr: number;
		microPdf417: number;
		microQr: number;
		msTag: number;
		msi: number;
		ocrA: number;
		ocrB: number;
		pdf417: number;
		plessey: number;
		pzn: number;
		qr: number;
		sisac: number;
		swedenPost: number;
		telepen: number;
		tfDis: number;
		tfIata: number;
		tfInd: number;
		tfInt: number;
		tfMat: number;
		tfStd: number;
		tlc39: number;
		trioptic39: number;
		uccEan128: number;
		ukPost: number;
		unknown: number;
		upcCoupon: number;
		upca: number;
		upcaAdd2: number;
		upcaAdd5: number;
		upce: number;
		upceAdd2: number;
		upceAdd5: number;
		us4StateFics: number;
		usIntelligent: number;
		usIntelligentPkg: number;
		usPlanet: number;
		usPostNet: number
	}

	declare class CashDrawer  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.CashDrawer>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.CashDrawer>;
		getDeviceSelector(): string;
		capabilities: Windows.Devices.PointOfService.CashDrawerCapabilities;
		checkHealthAsync(
		level: Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		claimDrawerAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.ClaimedCashDrawer>;
		deviceId: string;
		drawerEventSource: Windows.Devices.PointOfService.CashDrawerEventSource;
		getStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		isDrawerOpen: boolean;
		onstatusupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawer, Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs>;
		addEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawer, Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawer, Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs>
	): void;
		status: Windows.Devices.PointOfService.CashDrawerStatus;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CashDrawerCapabilities  {
		isDrawerOpenSensorAvailable: boolean;
		isStatisticsReportingSupported: boolean;
		isStatisticsUpdatingSupported: boolean;
		isStatusMultiDrawerDetectSupported: boolean;
		isStatusReportingSupported: boolean;
		powerReportingType: Windows.Devices.PointOfService.UnifiedPosPowerReportingType
	}

	declare class CashDrawerCloseAlarm  {
		alarmTimeout: number;
		beepDelay: number;
		beepDuration: number;
		beepFrequency: number;
		onalarmtimeoutexpired: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerCloseAlarm, any>;
		addEventListener(
		type: "alarmtimeoutexpired", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerCloseAlarm, any>
	): void;
		removeEventListener(
		type: "alarmtimeoutexpired", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerCloseAlarm, any>
	): void;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CashDrawerClosedEventArgs  {
		cashDrawer: Windows.Devices.PointOfService.CashDrawer
	}

	declare class CashDrawerEventSource  {
		ondrawerclosed: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerClosedEventArgs>;
		addEventListener(
		type: "drawerclosed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerClosedEventArgs>
	): void;
		removeEventListener(
		type: "drawerclosed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerClosedEventArgs>
	): void;
		ondraweropened: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerOpenedEventArgs>;
		addEventListener(
		type: "draweropened", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerOpenedEventArgs>
	): void;
		removeEventListener(
		type: "draweropened", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.CashDrawerEventSource, Windows.Devices.PointOfService.CashDrawerOpenedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CashDrawerOpenedEventArgs  {
		cashDrawer: Windows.Devices.PointOfService.CashDrawer
	}

	declare class CashDrawerStatus  {
		extendedStatus: number;
		statusKind: Windows.Devices.PointOfService.CashDrawerStatusKind
	}

	declare class CashDrawerStatusUpdatedEventArgs  {
		status: Windows.Devices.PointOfService.CashDrawerStatus
	}

	declare class ClaimedBarcodeScanner  {
		close(): void;
		deviceId: string;
		disableAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		enableAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		isDecodeDataEnabled: boolean;
		isDisabledOnDataReceived: boolean;
		isEnabled: boolean;
		ondatareceived: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs>;
		addEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs>
	): void;
		onerroroccurred: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs>;
		addEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs>
	): void;
		removeEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs>
	): void;
		onimagepreviewreceived: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs>;
		addEventListener(
		type: "imagepreviewreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs>
	): void;
		removeEventListener(
		type: "imagepreviewreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedBarcodeScanner, Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs>
	): void;
		onreleasedevicerequested: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.EventHandler<any>
	): void;
		ontriggerpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "triggerpressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "triggerpressed", listener: Windows.Foundation.EventHandler<any>): void;
		ontriggerreleased: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "triggerreleased", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "triggerreleased", listener: Windows.Foundation.EventHandler<any>): void;
		resetStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		retainDevice(): void;
		setActiveProfileAsync(profile: string): Windows.Foundation.IPromiseWithIAsyncAction;
		setActiveSymbologiesAsync(
		symbologies: Windows.Foundation.Collections.IIterable<number>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startSoftwareTriggerAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopSoftwareTriggerAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		updateStatisticsAsync(
		statistics: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ClaimedCashDrawer  {
		close(): void;
		closeAlarm: Windows.Devices.PointOfService.CashDrawerCloseAlarm;
		deviceId: string;
		disableAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		enableAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		isDrawerOpen: boolean;
		isEnabled: boolean;
		onreleasedevicerequested: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedCashDrawer, any>;
		addEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedCashDrawer, any>
	): void;
		removeEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedCashDrawer, any>
	): void;
		openDrawerAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		resetStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		retainDeviceAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		updateStatisticsAsync(
		statistics: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ClaimedJournalPrinter  {
		charactersPerLine: number;
		colorCartridge: Windows.Devices.PointOfService.PosPrinterColorCartridge;
		createJob(): Windows.Devices.PointOfService.JournalPrintJob;
		isCartridgeEmpty: boolean;
		isCartridgeRemoved: boolean;
		isCoverOpen: boolean;
		isHeadCleaning: boolean;
		isLetterQuality: boolean;
		isPaperEmpty: boolean;
		isPaperNearEnd: boolean;
		isReadyToPrint: boolean;
		lineHeight: number;
		lineSpacing: number;
		lineWidth: number;
		validateData(data: string): boolean
	}

	declare class ClaimedMagneticStripeReader  {
		authenticateDeviceAsync(responseToken: number[]): any;
		close(): void;
		dataEncryptionAlgorithm: number;
		deAuthenticateDeviceAsync(responseToken: number[]): any;
		deviceId: string;
		disableAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		enableAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		isDecodeDataEnabled: boolean;
		isDeviceAuthenticated: boolean;
		isDisabledOnDataReceived: boolean;
		isEnabled: boolean;
		isTransmitSentinelsEnabled: boolean;
		onaamvacarddatareceived: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs>;
		addEventListener(
		type: "aamvacarddatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "aamvacarddatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs>
	): void;
		onbankcarddatareceived: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs>;
		addEventListener(
		type: "bankcarddatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "bankcarddatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs>
	): void;
		onerroroccurred: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs>;
		addEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs>
	): void;
		removeEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs>
	): void;
		onreleasedevicerequested: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.EventHandler<any>
	): void;
		onvendorspecificdatareceived: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>;
		addEventListener(
		type: "vendorspecificdatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "vendorspecificdatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedMagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>
	): void;
		resetStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		retainDevice(): void;
		retrieveDeviceAuthenticationDataAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		setErrorReportingType(
		value: Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType
	): void;
		tracksToRead: Windows.Devices.PointOfService.MagneticStripeReaderTrackIds;
		updateKeyAsync(key: string, keyName: string): any;
		updateStatisticsAsync(
		statistics: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ClaimedPosPrinter  {
		characterSet: number;
		close(): void;
		deviceId: string;
		disableAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		enableAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		isCharacterSetMappingEnabled: boolean;
		isCoverOpen: boolean;
		isEnabled: boolean;
		journal: Windows.Devices.PointOfService.ClaimedJournalPrinter;
		mapMode: Windows.Devices.PointOfService.PosPrinterMapMode;
		onreleasedevicerequested: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedPosPrinter, Windows.Devices.PointOfService.PosPrinterReleaseDeviceRequestedEventArgs>;
		addEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedPosPrinter, Windows.Devices.PointOfService.PosPrinterReleaseDeviceRequestedEventArgs>
	): void;
		removeEventListener(
		type: "releasedevicerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.ClaimedPosPrinter, Windows.Devices.PointOfService.PosPrinterReleaseDeviceRequestedEventArgs>
	): void;
		receipt: Windows.Devices.PointOfService.ClaimedReceiptPrinter;
		resetStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		retainDeviceAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		slip: Windows.Devices.PointOfService.ClaimedSlipPrinter;
		updateStatisticsAsync(
		statistics: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ClaimedReceiptPrinter  {
		charactersPerLine: number;
		colorCartridge: Windows.Devices.PointOfService.PosPrinterColorCartridge;
		createJob(): Windows.Devices.PointOfService.ReceiptPrintJob;
		isCartridgeEmpty: boolean;
		isCartridgeRemoved: boolean;
		isCoverOpen: boolean;
		isHeadCleaning: boolean;
		isLetterQuality: boolean;
		isPaperEmpty: boolean;
		isPaperNearEnd: boolean;
		isReadyToPrint: boolean;
		lineHeight: number;
		lineSpacing: number;
		lineWidth: number;
		linesToPaperCut: number;
		pageSize: Windows.Foundation.Size;
		printArea: Windows.Foundation.Rect;
		sidewaysMaxChars: number;
		sidewaysMaxLines: number;
		validateData(data: string): boolean
	}

	declare class ClaimedSlipPrinter  {
		changePrintSide(printSide: Windows.Devices.PointOfService.PosPrinterPrintSide): void;
		charactersPerLine: number;
		closeJaws(): void;
		colorCartridge: Windows.Devices.PointOfService.PosPrinterColorCartridge;
		createJob(): Windows.Devices.PointOfService.SlipPrintJob;
		insertSlipAsync(timeout: number): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		isCartridgeEmpty: boolean;
		isCartridgeRemoved: boolean;
		isCoverOpen: boolean;
		isHeadCleaning: boolean;
		isLetterQuality: boolean;
		isPaperEmpty: boolean;
		isPaperNearEnd: boolean;
		isReadyToPrint: boolean;
		lineHeight: number;
		lineSpacing: number;
		lineWidth: number;
		linesNearEndToEnd: number;
		maxLines: number;
		openJaws(): void;
		pageSize: Windows.Foundation.Size;
		printArea: Windows.Foundation.Rect;
		printSide: Windows.Devices.PointOfService.PosPrinterPrintSide;
		removeSlipAsync(timeout: number): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		sidewaysMaxChars: number;
		sidewaysMaxLines: number;
		validateData(data: string): boolean
	}

	declare class JournalPrintJob  {
		executeAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		print(data: string): void;
		printLine(data: string): void;
		printLine(): void
	}

	declare class JournalPrinterCapabilities  {
		cartridgeSensors: Windows.Devices.PointOfService.PosPrinterCartridgeSensors;
		colorCartridgeCapabilities: Windows.Devices.PointOfService.PosPrinterColorCapabilities;
		isBoldSupported: boolean;
		isDoubleHighDoubleWidePrintSupported: boolean;
		isDoubleHighPrintSupported: boolean;
		isDoubleWidePrintSupported: boolean;
		isDualColorSupported: boolean;
		isItalicSupported: boolean;
		isPaperEmptySensorSupported: boolean;
		isPaperNearEndSensorSupported: boolean;
		isPrinterPresent: boolean;
		isUnderlineSupported: boolean;
		supportedCharactersPerLine: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class MagneticStripeReader  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.MagneticStripeReader>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.MagneticStripeReader>;
		getDeviceSelector(): string;
		capabilities: Windows.Devices.PointOfService.MagneticStripeReaderCapabilities;
		checkHealthAsync(
		level: Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		claimReaderAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.ClaimedMagneticStripeReader>;
		deviceAuthenticationProtocol: Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationProtocol;
		deviceId: string;
		getErrorReportingType(): Windows.Devices.PointOfService.MagneticStripeReaderErrorReportingType;
		onstatusupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.MagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs>;
		addEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.MagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.MagneticStripeReader, Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs>
	): void;
		retrieveStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		supportedCardTypes: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MagneticStripeReaderAamvaCardDataReceivedEventArgs  {
		address: string;
		birthDate: string;
		city: string;
		class: string;
		endorsements: string;
		expirationDate: string;
		eyeColor: string;
		firstName: string;
		gender: string;
		hairColor: string;
		height: string;
		licenseNumber: string;
		postalCode: string;
		report: Windows.Devices.PointOfService.MagneticStripeReaderReport;
		restrictions: string;
		state: string;
		suffix: string;
		surname: string;
		weight: string
	}

	declare class MagneticStripeReaderBankCardDataReceivedEventArgs  {
		accountNumber: string;
		expirationDate: string;
		firstName: string;
		middleInitial: string;
		report: Windows.Devices.PointOfService.MagneticStripeReaderReport;
		serviceCode: string;
		suffix: string;
		surname: string;
		title: string
	}

	declare class MagneticStripeReaderCapabilities  {
		authenticationLevel: Windows.Devices.PointOfService.MagneticStripeReaderAuthenticationLevel;
		cardAuthentication: string;
		isIsoSupported: boolean;
		isJisOneSupported: boolean;
		isJisTwoSupported: boolean;
		isStatisticsReportingSupported: boolean;
		isStatisticsUpdatingSupported: boolean;
		isTrackDataMaskingSupported: boolean;
		isTransmitSentinelsSupported: boolean;
		powerReportingType: Windows.Devices.PointOfService.UnifiedPosPowerReportingType;
		supportedEncryptionAlgorithms: number
	}

	declare class MagneticStripeReaderCardTypes  {
		aamva: number;
		bank: number;
		extendedBase: number;
		unknown: number
	}

	declare class MagneticStripeReaderEncryptionAlgorithms  {
		extendedBase: number;
		none: number;
		tripleDesDukpt: number
	}

	declare class MagneticStripeReaderErrorOccurredEventArgs  {
		errorData: Windows.Devices.PointOfService.UnifiedPosErrorData;
		partialInputData: Windows.Devices.PointOfService.MagneticStripeReaderReport;
		track1Status: Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType;
		track2Status: Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType;
		track3Status: Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType;
		track4Status: Windows.Devices.PointOfService.MagneticStripeReaderTrackErrorType
	}

	declare class MagneticStripeReaderReport  {
		additionalSecurityInformation: Windows.Storage.Streams.IBuffer;
		cardAuthenticationData: Windows.Storage.Streams.IBuffer;
		cardAuthenticationDataLength: number;
		cardType: number;
		properties: Windows.Foundation.Collections.IMapView<string, string>;
		track1: Windows.Devices.PointOfService.MagneticStripeReaderTrackData;
		track2: Windows.Devices.PointOfService.MagneticStripeReaderTrackData;
		track3: Windows.Devices.PointOfService.MagneticStripeReaderTrackData;
		track4: Windows.Devices.PointOfService.MagneticStripeReaderTrackData
	}

	declare class MagneticStripeReaderStatusUpdatedEventArgs  {
		extendedStatus: number;
		status: Windows.Devices.PointOfService.MagneticStripeReaderStatus
	}

	declare class MagneticStripeReaderTrackData  {
		data: Windows.Storage.Streams.IBuffer;
		discretionaryData: Windows.Storage.Streams.IBuffer;
		encryptedData: Windows.Storage.Streams.IBuffer
	}

	declare class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs  {
		report: Windows.Devices.PointOfService.MagneticStripeReaderReport
	}

	declare class PosPrinter  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.PosPrinter>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.PosPrinter>;
		getDeviceSelector(): string;
		capabilities: Windows.Devices.PointOfService.PosPrinterCapabilities;
		checkHealthAsync(
		level: Windows.Devices.PointOfService.UnifiedPosHealthCheckLevel
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		claimPrinterAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.PointOfService.ClaimedPosPrinter>;
		deviceId: string;
		getStatisticsAsync(
		statisticsCategories: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		onstatusupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.PosPrinter, Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs>;
		addEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.PosPrinter, Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "statusupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.PointOfService.PosPrinter, Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs>
	): void;
		status: Windows.Devices.PointOfService.PosPrinterStatus;
		supportedCharacterSets: Windows.Foundation.Collections.IVectorView<number>;
		supportedTypeFaces: Windows.Foundation.Collections.IVectorView<string>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PosPrinterCapabilities  {
		canMapCharacterSet: boolean;
		defaultCharacterSet: number;
		hasCoverSensor: boolean;
		isStatisticsReportingSupported: boolean;
		isStatisticsUpdatingSupported: boolean;
		isTransactionSupported: boolean;
		journal: Windows.Devices.PointOfService.JournalPrinterCapabilities;
		powerReportingType: Windows.Devices.PointOfService.UnifiedPosPowerReportingType;
		receipt: Windows.Devices.PointOfService.ReceiptPrinterCapabilities;
		slip: Windows.Devices.PointOfService.SlipPrinterCapabilities
	}

	declare class PosPrinterCharacterSetIds  {
		ansi: number;
		ascii: number;
		utf16LE: number
	}

	declare class PosPrinterReleaseDeviceRequestedEventArgs  {
		
	}

	declare class PosPrinterStatus  {
		extendedStatus: number;
		statusKind: Windows.Devices.PointOfService.PosPrinterStatusKind
	}

	declare class PosPrinterStatusUpdatedEventArgs  {
		status: Windows.Devices.PointOfService.PosPrinterStatus
	}

	declare class ReceiptPrintJob  {
		cutPaper(): void;
		cutPaper(percentage: number): void;
		drawRuledLine(
		positionList: string, lineDirection: Windows.Devices.PointOfService.PosPrinterLineDirection, lineWidth: number, lineStyle: Windows.Devices.PointOfService.PosPrinterLineStyle, lineColor: number
	): void;
		executeAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		markFeed(kind: Windows.Devices.PointOfService.PosPrinterMarkFeedKind): void;
		print(data: string): void;
		printBarcode(
		data: string, symbology: number, height: number, width: number, textPosition: Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		printBarcodeCustomAlign(
		data: string, symbology: number, height: number, width: number, textPosition: Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition, alignmentDistance: number
	): void;
		printBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment, width: number
	): void;
		printBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		printCustomAlignedBitmap(bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number): void;
		printCustomAlignedBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number, width: number
	): void;
		printLine(data: string): void;
		printLine(): void;
		printSavedBitmap(bitmapNumber: number): void;
		setBarcodeRotation(value: Windows.Devices.PointOfService.PosPrinterRotation): void;
		setBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		setBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment, width: number
	): void;
		setCustomAlignedBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number
	): void;
		setCustomAlignedBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number, width: number
	): void;
		setPrintArea(value: Windows.Foundation.Rect): void;
		setPrintRotation(
		value: Windows.Devices.PointOfService.PosPrinterRotation, includeBitmaps: boolean
	): void
	}

	declare class ReceiptPrinterCapabilities  {
		canCutPaper: boolean;
		cartridgeSensors: Windows.Devices.PointOfService.PosPrinterCartridgeSensors;
		colorCartridgeCapabilities: Windows.Devices.PointOfService.PosPrinterColorCapabilities;
		is180RotationSupported: boolean;
		isBarcodeSupported: boolean;
		isBitmapSupported: boolean;
		isBoldSupported: boolean;
		isDoubleHighDoubleWidePrintSupported: boolean;
		isDoubleHighPrintSupported: boolean;
		isDoubleWidePrintSupported: boolean;
		isDualColorSupported: boolean;
		isItalicSupported: boolean;
		isLeft90RotationSupported: boolean;
		isPaperEmptySensorSupported: boolean;
		isPaperNearEndSensorSupported: boolean;
		isPrintAreaSupported: boolean;
		isPrinterPresent: boolean;
		isRight90RotationSupported: boolean;
		isStampSupported: boolean;
		isUnderlineSupported: boolean;
		markFeedCapabilities: Windows.Devices.PointOfService.PosPrinterMarkFeedCapabilities;
		ruledLineCapabilities: Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities;
		supportedBarcodeRotations: Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>;
		supportedBitmapRotations: Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>;
		supportedCharactersPerLine: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class SlipPrintJob  {
		drawRuledLine(
		positionList: string, lineDirection: Windows.Devices.PointOfService.PosPrinterLineDirection, lineWidth: number, lineStyle: Windows.Devices.PointOfService.PosPrinterLineStyle, lineColor: number
	): void;
		executeAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		print(data: string): void;
		printBarcode(
		data: string, symbology: number, height: number, width: number, textPosition: Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		printBarcodeCustomAlign(
		data: string, symbology: number, height: number, width: number, textPosition: Windows.Devices.PointOfService.PosPrinterBarcodeTextPosition, alignmentDistance: number
	): void;
		printBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment, width: number
	): void;
		printBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		printCustomAlignedBitmap(bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number): void;
		printCustomAlignedBitmap(
		bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number, width: number
	): void;
		printLine(data: string): void;
		printLine(): void;
		printSavedBitmap(bitmapNumber: number): void;
		setBarcodeRotation(value: Windows.Devices.PointOfService.PosPrinterRotation): void;
		setBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment
	): void;
		setBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignment: Windows.Devices.PointOfService.PosPrinterAlignment, width: number
	): void;
		setCustomAlignedBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number
	): void;
		setCustomAlignedBitmap(
		bitmapNumber: number, bitmap: Windows.Graphics.Imaging.BitmapFrame, alignmentDistance: number, width: number
	): void;
		setPrintArea(value: Windows.Foundation.Rect): void;
		setPrintRotation(
		value: Windows.Devices.PointOfService.PosPrinterRotation, includeBitmaps: boolean
	): void
	}

	declare class SlipPrinterCapabilities  {
		cartridgeSensors: Windows.Devices.PointOfService.PosPrinterCartridgeSensors;
		colorCartridgeCapabilities: Windows.Devices.PointOfService.PosPrinterColorCapabilities;
		is180RotationSupported: boolean;
		isBarcodeSupported: boolean;
		isBitmapSupported: boolean;
		isBoldSupported: boolean;
		isBothSidesPrintingSupported: boolean;
		isDoubleHighDoubleWidePrintSupported: boolean;
		isDoubleHighPrintSupported: boolean;
		isDoubleWidePrintSupported: boolean;
		isDualColorSupported: boolean;
		isFullLengthSupported: boolean;
		isItalicSupported: boolean;
		isLeft90RotationSupported: boolean;
		isPaperEmptySensorSupported: boolean;
		isPaperNearEndSensorSupported: boolean;
		isPrintAreaSupported: boolean;
		isPrinterPresent: boolean;
		isRight90RotationSupported: boolean;
		isUnderlineSupported: boolean;
		ruledLineCapabilities: Windows.Devices.PointOfService.PosPrinterRuledLineCapabilities;
		supportedBarcodeRotations: Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>;
		supportedBitmapRotations: Windows.Foundation.Collections.IVectorView<Windows.Devices.PointOfService.PosPrinterRotation>;
		supportedCharactersPerLine: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class UnifiedPosErrorData  {
		extendedReason: number;
		message: string;
		reason: Windows.Devices.PointOfService.UnifiedPosErrorReason;
		severity: Windows.Devices.PointOfService.UnifiedPosErrorSeverity
	}

	
}

declare module 'Portable' {
				declare class ServiceDevice  {
		getDeviceSelector(serviceType: Windows.Devices.Portable.ServiceDeviceType): string;
		getDeviceSelectorFromServiceId(serviceId: string): string
	}

	declare class StorageDevice  {
		fromId(DeviceId: string): Windows.Storage.StorageFolder;
		getDeviceSelector(): string
	}

	
}

declare module 'Power' {
				declare class Battery  {
		aggregateBattery: Windows.Devices.Power.Battery;
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Power.Battery>;
		getDeviceSelector(): string;
		deviceId: string;
		getReport(): Windows.Devices.Power.BatteryReport;
		onreportupdated: Windows.Foundation.TypedEventHandler<Windows.Devices.Power.Battery, any>;
		addEventListener(
		type: "reportupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Power.Battery, any>
	): void;
		removeEventListener(
		type: "reportupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Power.Battery, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BatteryReport  {
		chargeRateInMilliwatts: number;
		designCapacityInMilliwattHours: number;
		fullChargeCapacityInMilliwattHours: number;
		remainingCapacityInMilliwattHours: number;
		status: Windows.System.Power.BatteryStatus
	}

	declare class BackgroundEnergyManager  {
		excessiveUsageLevel: number;
		lowUsageLevel: number;
		maxAcceptableUsageLevel: number;
		nearMaxAcceptableUsageLevel: number;
		nearTerminationUsageLevel: number;
		onrecentenergyusageincreased: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		onrecentenergyusagereturnedtolow: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>
	): void;
		recentEnergyUsage: number;
		recentEnergyUsageLevel: number;
		terminationUsageLevel: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ForegroundEnergyManager  {
		excessiveUsageLevel: number;
		lowUsageLevel: number;
		maxAcceptableUsageLevel: number;
		nearMaxAcceptableUsageLevel: number;
		onrecentenergyusageincreased: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>
	): void;
		onrecentenergyusagereturnedtolow: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>
	): void;
		recentEnergyUsage: number;
		recentEnergyUsageLevel: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PowerManager  {
		batteryStatus: Windows.System.Power.BatteryStatus;
		energySaverStatus: Windows.System.Power.EnergySaverStatus;
		onbatterystatuschanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "batterystatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "batterystatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		onenergysaverstatuschanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "energysaverstatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "energysaverstatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		onpowersupplystatuschanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "powersupplystatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "powersupplystatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		onremainingchargepercentchanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "remainingchargepercentchanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "remainingchargepercentchanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		onremainingdischargetimechanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "remainingdischargetimechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "remainingdischargetimechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		powerSupplyStatus: Windows.System.Power.PowerSupplyStatus;
		remainingChargePercent: number;
		remainingDischargeTime: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Extensions' {
				declare class Print3DWorkflow  {
		deviceID: string;
		getPrintModelPackage(): any;
		isPrintReady: boolean;
		onprintrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.Print3DWorkflow, Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs>;
		addEventListener(
		type: "printrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.Print3DWorkflow, Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs>
	): void;
		removeEventListener(
		type: "printrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.Print3DWorkflow, Windows.Devices.Printers.Extensions.Print3DWorkflowPrintRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class Print3DWorkflowPrintRequestedEventArgs  {
		setExtendedStatus(value: Windows.Devices.Printers.Extensions.Print3DWorkflowDetail): void;
		setSource(source: any): void;
		setSourceChanged(value: boolean): void;
		status: Windows.Devices.Printers.Extensions.Print3DWorkflowStatus
	}

	declare class PrintExtensionContext  {
		fromDeviceId(deviceId: string): any
	}

	declare class PrintNotificationEventDetails  {
		eventData: string;
		printerName: string
	}

	declare class PrintTaskConfiguration  {
		onsaverequested: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration, Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>;
		addEventListener(
		type: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration, Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>
	): void;
		removeEventListener(
		type: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration, Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>
	): void;
		printerExtensionContext: any;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PrintTaskConfigurationSaveRequest  {
		cancel(): void;
		deadline: Date;
		getDeferral(
		
	): Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral;
		save(printerExtensionContext: any): void
	}

	declare class PrintTaskConfigurationSaveRequestedDeferral  {
		complete(): void
	}

	declare class PrintTaskConfigurationSaveRequestedEventArgs  {
		request: Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest
	}

	
}

declare module 'Printers' {
				declare class Print3DDevice  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Printers.Print3DDevice>;
		getDeviceSelector(): string;
		printSchema: Windows.Devices.Printers.PrintSchema
	}

	declare class PrintSchema  {
		getCapabilitiesAsync(
		constrainTicket: Windows.Storage.Streams.IRandomAccessStreamWithContentType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
		getDefaultPrintTicketAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
		mergeAndValidateWithDefaultPrintTicketAsync(
		deltaTicket: Windows.Storage.Streams.IRandomAccessStreamWithContentType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>
	}

	
}

declare module 'Pwm' {
				declare class PwmController  {
		getControllersAsync: any;
		getDefaultAsync: any;
		actualFrequency: any;
		maxFrequency: any;
		minFrequency: any;
		openPin: any;
		pinCount: any;
		setDesiredFrequency: any
	}

	declare class PwmPin  {
		close: any;
		controller: any;
		getActiveDutyCyclePercentage: any;
		isStarted: any;
		polarity: any;
		setActiveDutyCyclePercentage: any;
		start: any;
		stop: any
	}

	
}

declare module 'Radios' {
				declare class Radio  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Radios.Radio>;
		getDeviceSelector(): string;
		getRadiosAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Radios.RadioAccessStatus>;
		kind: Windows.Devices.Radios.RadioKind;
		name: string;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Radios.Radio, any>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Radios.Radio, any>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Radios.Radio, any>
	): void;
		setStateAsync(
		value: Windows.Devices.Radios.RadioState
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Radios.RadioAccessStatus>;
		state: Windows.Devices.Radios.RadioState;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Scanners' {
		declare interface ImageScannerResolution {
		dpiX: number,
		dpiY: number
	}

		declare class ImageScanner  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Scanners.ImageScanner>;
		getDeviceSelector(): string;
		autoConfiguration: Windows.Devices.Scanners.ImageScannerAutoConfiguration;
		defaultScanSource: Windows.Devices.Scanners.ImageScannerScanSource;
		deviceId: string;
		feederConfiguration: Windows.Devices.Scanners.ImageScannerFeederConfiguration;
		flatbedConfiguration: Windows.Devices.Scanners.ImageScannerFlatbedConfiguration;
		isPreviewSupported(scanSource: Windows.Devices.Scanners.ImageScannerScanSource): boolean;
		isScanSourceSupported(value: Windows.Devices.Scanners.ImageScannerScanSource): boolean;
		scanFilesToFolderAsync(
		scanSource: Windows.Devices.Scanners.ImageScannerScanSource, storageFolder: Windows.Storage.StorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Devices.Scanners.ImageScannerScanResult, number>;
		scanPreviewToStreamAsync(
		scanSource: Windows.Devices.Scanners.ImageScannerScanSource, targetStream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Scanners.ImageScannerPreviewResult>
	}

	declare class ImageScannerAutoConfiguration  {
		defaultFormat: Windows.Devices.Scanners.ImageScannerFormat;
		format: Windows.Devices.Scanners.ImageScannerFormat;
		isFormatSupported(value: Windows.Devices.Scanners.ImageScannerFormat): boolean
	}

	declare class ImageScannerFeederConfiguration  {
		actualResolution: Windows.Devices.Scanners.ImageScannerResolution;
		autoCroppingMode: Windows.Devices.Scanners.ImageScannerAutoCroppingMode;
		autoDetectPageSize: boolean;
		brightness: number;
		brightnessStep: number;
		canAutoDetectPageSize: boolean;
		canScanAhead: boolean;
		canScanDuplex: boolean;
		colorMode: Windows.Devices.Scanners.ImageScannerColorMode;
		contrast: number;
		contrastStep: number;
		defaultBrightness: number;
		defaultColorMode: Windows.Devices.Scanners.ImageScannerColorMode;
		defaultContrast: number;
		defaultFormat: Windows.Devices.Scanners.ImageScannerFormat;
		desiredResolution: Windows.Devices.Scanners.ImageScannerResolution;
		duplex: boolean;
		format: Windows.Devices.Scanners.ImageScannerFormat;
		isAutoCroppingModeSupported(value: Windows.Devices.Scanners.ImageScannerAutoCroppingMode): boolean;
		isColorModeSupported(value: Windows.Devices.Scanners.ImageScannerColorMode): boolean;
		isFormatSupported(value: Windows.Devices.Scanners.ImageScannerFormat): boolean;
		isPageSizeSupported(
		pageSize: Windows.Graphics.Printing.PrintMediaSize, pageOrientation: Windows.Graphics.Printing.PrintOrientation
	): boolean;
		maxBrightness: number;
		maxContrast: number;
		maxNumberOfPages: number;
		maxResolution: Windows.Devices.Scanners.ImageScannerResolution;
		maxScanArea: Windows.Foundation.Size;
		minBrightness: number;
		minContrast: number;
		minResolution: Windows.Devices.Scanners.ImageScannerResolution;
		minScanArea: Windows.Foundation.Size;
		opticalResolution: Windows.Devices.Scanners.ImageScannerResolution;
		pageOrientation: Windows.Graphics.Printing.PrintOrientation;
		pageSize: Windows.Graphics.Printing.PrintMediaSize;
		pageSizeDimensions: Windows.Foundation.Size;
		scanAhead: boolean;
		selectedScanRegion: Windows.Foundation.Rect
	}

	declare class ImageScannerFlatbedConfiguration  {
		actualResolution: Windows.Devices.Scanners.ImageScannerResolution;
		autoCroppingMode: Windows.Devices.Scanners.ImageScannerAutoCroppingMode;
		brightness: number;
		brightnessStep: number;
		colorMode: Windows.Devices.Scanners.ImageScannerColorMode;
		contrast: number;
		contrastStep: number;
		defaultBrightness: number;
		defaultColorMode: Windows.Devices.Scanners.ImageScannerColorMode;
		defaultContrast: number;
		defaultFormat: Windows.Devices.Scanners.ImageScannerFormat;
		desiredResolution: Windows.Devices.Scanners.ImageScannerResolution;
		format: Windows.Devices.Scanners.ImageScannerFormat;
		isAutoCroppingModeSupported(value: Windows.Devices.Scanners.ImageScannerAutoCroppingMode): boolean;
		isColorModeSupported(value: Windows.Devices.Scanners.ImageScannerColorMode): boolean;
		isFormatSupported(value: Windows.Devices.Scanners.ImageScannerFormat): boolean;
		maxBrightness: number;
		maxContrast: number;
		maxResolution: Windows.Devices.Scanners.ImageScannerResolution;
		maxScanArea: Windows.Foundation.Size;
		minBrightness: number;
		minContrast: number;
		minResolution: Windows.Devices.Scanners.ImageScannerResolution;
		minScanArea: Windows.Foundation.Size;
		opticalResolution: Windows.Devices.Scanners.ImageScannerResolution;
		selectedScanRegion: Windows.Foundation.Rect
	}

	declare class ImageScannerPreviewResult  {
		format: Windows.Devices.Scanners.ImageScannerFormat;
		succeeded: boolean
	}

	declare class ImageScannerScanResult  {
		scannedFiles: Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>
	}

	
}

declare module 'Sensors' {
		declare interface ISensorDataThreshold {
		
	}

		declare class Accelerometer  {
		getDefault(): Windows.Devices.Sensors.Accelerometer;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.AccelerometerReading;
		maxBatchSize: number;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>
	): void;
		onshaken: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerShakenEventArgs>;
		addEventListener(
		type: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerShakenEventArgs>
	): void;
		removeEventListener(
		type: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer, Windows.Devices.Sensors.AccelerometerShakenEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		reportInterval: number;
		reportLatency: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AccelerometerReading  {
		accelerationX: number;
		accelerationY: number;
		accelerationZ: number;
		timestamp: Date
	}

	declare class AccelerometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.AccelerometerReading
	}

	declare class AccelerometerShakenEventArgs  {
		timestamp: Date
	}

	declare class ActivitySensor  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.ActivitySensor>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.ActivitySensor>;
		getDeviceSelector(): string;
		getSystemHistoryAsync(
		fromTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getSystemHistoryAsync(
		fromTime: Date, duration: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		deviceId: string;
		getCurrentReadingAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.ActivitySensorReading>;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ActivitySensor, Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ActivitySensor, Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ActivitySensor, Windows.Devices.Sensors.ActivitySensorReadingChangedEventArgs>
	): void;
		powerInMilliwatts: number;
		subscribedActivities: Windows.Foundation.Collections.IVector<Windows.Devices.Sensors.ActivityType>;
		supportedActivities: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ActivityType>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ActivitySensorReading  {
		activity: Windows.Devices.Sensors.ActivityType;
		confidence: Windows.Devices.Sensors.ActivitySensorReadingConfidence;
		timestamp: Date
	}

	declare class ActivitySensorReadingChangeReport  {
		reading: Windows.Devices.Sensors.ActivitySensorReading
	}

	declare class ActivitySensorReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.ActivitySensorReading
	}

	declare class ActivitySensorTriggerDetails  {
		readReports(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ActivitySensorReadingChangeReport>
	}

	declare class Altimeter  {
		getDefault(): Windows.Devices.Sensors.Altimeter;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.AltimeterReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Altimeter, Windows.Devices.Sensors.AltimeterReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Altimeter, Windows.Devices.Sensors.AltimeterReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Altimeter, Windows.Devices.Sensors.AltimeterReadingChangedEventArgs>
	): void;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AltimeterReading  {
		altitudeChangeInMeters: number;
		timestamp: Date
	}

	declare class AltimeterReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.AltimeterReading
	}

	declare class Barometer  {
		getDefault(): Windows.Devices.Sensors.Barometer;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.BarometerReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Barometer, Windows.Devices.Sensors.BarometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Barometer, Windows.Devices.Sensors.BarometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Barometer, Windows.Devices.Sensors.BarometerReadingChangedEventArgs>
	): void;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class BarometerReading  {
		stationPressureInHectopascals: number;
		timestamp: Date
	}

	declare class BarometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.BarometerReading
	}

	declare class Compass  {
		getDefault(): Windows.Devices.Sensors.Compass;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.CompassReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass, Windows.Devices.Sensors.CompassReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass, Windows.Devices.Sensors.CompassReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass, Windows.Devices.Sensors.CompassReadingChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CompassReading  {
		headingAccuracy: Windows.Devices.Sensors.MagnetometerAccuracy;
		headingMagneticNorth: number;
		headingTrueNorth: number;
		timestamp: Date
	}

	declare class CompassReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.CompassReading
	}

	declare class Gyrometer  {
		getDefault(): Windows.Devices.Sensors.Gyrometer;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.GyrometerReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer, Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer, Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer, Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class GyrometerReading  {
		angularVelocityX: number;
		angularVelocityY: number;
		angularVelocityZ: number;
		timestamp: Date
	}

	declare class GyrometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.GyrometerReading
	}

	declare class Inclinometer  {
		getDefault(): Windows.Devices.Sensors.Inclinometer;
		getDefaultForRelativeReadings(): Windows.Devices.Sensors.Inclinometer;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.InclinometerReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer, Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer, Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer, Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		readingType: Windows.Devices.Sensors.SensorReadingType;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class InclinometerReading  {
		pitchDegrees: number;
		rollDegrees: number;
		timestamp: Date;
		yawAccuracy: Windows.Devices.Sensors.MagnetometerAccuracy;
		yawDegrees: number
	}

	declare class InclinometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.InclinometerReading
	}

	declare class LightSensor  {
		getDefault(): Windows.Devices.Sensors.LightSensor;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.LightSensorReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor, Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor, Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor, Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>
	): void;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LightSensorReading  {
		illuminanceInLux: number;
		timestamp: Date
	}

	declare class LightSensorReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.LightSensorReading
	}

	declare class Magnetometer  {
		getDefault(): Windows.Devices.Sensors.Magnetometer;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.MagnetometerReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Magnetometer, Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Magnetometer, Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Magnetometer, Windows.Devices.Sensors.MagnetometerReadingChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MagnetometerReading  {
		directionalAccuracy: Windows.Devices.Sensors.MagnetometerAccuracy;
		magneticFieldX: number;
		magneticFieldY: number;
		magneticFieldZ: number;
		timestamp: Date
	}

	declare class MagnetometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.MagnetometerReading
	}

	declare class OrientationSensor  {
		getDefault(): Windows.Devices.Sensors.OrientationSensor;
		getDefaultForRelativeReadings(): Windows.Devices.Sensors.OrientationSensor;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.OrientationSensorReading;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor, Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor, Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor, Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		readingType: Windows.Devices.Sensors.SensorReadingType;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class OrientationSensorReading  {
		quaternion: Windows.Devices.Sensors.SensorQuaternion;
		rotationMatrix: Windows.Devices.Sensors.SensorRotationMatrix;
		timestamp: Date;
		yawAccuracy: Windows.Devices.Sensors.MagnetometerAccuracy
	}

	declare class OrientationSensorReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.OrientationSensorReading
	}

	declare class Pedometer  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.Pedometer>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sensors.Pedometer>;
		getDeviceSelector(): string;
		getReadingsFromTriggerDetails: any;
		getSystemHistoryAsync(
		fromTime: Date
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getSystemHistoryAsync(
		fromTime: Date, duration: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		deviceId: string;
		getCurrentReadings: any;
		minimumReportInterval: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Pedometer, Windows.Devices.Sensors.PedometerReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Pedometer, Windows.Devices.Sensors.PedometerReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Pedometer, Windows.Devices.Sensors.PedometerReadingChangedEventArgs>
	): void;
		powerInMilliwatts: number;
		reportInterval: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PedometerDataThreshold  {
		constructor(sensor: Windows.Devices.Sensors.Pedometer, stepGoal: number): this
	}

	declare class PedometerReading  {
		cumulativeSteps: number;
		cumulativeStepsDuration: number;
		stepKind: Windows.Devices.Sensors.PedometerStepKind;
		timestamp: Date
	}

	declare class PedometerReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.PedometerReading
	}

	declare class ProximitySensor  {
		fromId(sensorId: string): Windows.Devices.Sensors.ProximitySensor;
		getDeviceSelector(): string;
		getReadingsFromTriggerDetails(
		triggerDetails: Windows.Devices.Sensors.SensorDataThresholdTriggerDetails
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sensors.ProximitySensorReading>;
		createDisplayOnOffController(): Windows.Devices.Sensors.ProximitySensorDisplayOnOffController;
		deviceId: string;
		getCurrentReading(): Windows.Devices.Sensors.ProximitySensorReading;
		maxDistanceInMillimeters: number;
		minDistanceInMillimeters: number;
		onreadingchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ProximitySensor, Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs>;
		addEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ProximitySensor, Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs>
	): void;
		removeEventListener(
		type: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.ProximitySensor, Windows.Devices.Sensors.ProximitySensorReadingChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ProximitySensorDataThreshold  {
		constructor(sensor: Windows.Devices.Sensors.ProximitySensor): this
	}

	declare class ProximitySensorDisplayOnOffController  {
		close(): void
	}

	declare class ProximitySensorReading  {
		distanceInMillimeters: number;
		isDetected: boolean;
		timestamp: Date
	}

	declare class ProximitySensorReadingChangedEventArgs  {
		reading: Windows.Devices.Sensors.ProximitySensorReading
	}

	declare class SensorDataThresholdTriggerDetails  {
		deviceId: string;
		sensorType: Windows.Devices.Sensors.SensorType
	}

	declare class SensorQuaternion  {
		w: number;
		x: number;
		y: number;
		z: number
	}

	declare class SensorRotationMatrix  {
		m11: number;
		m12: number;
		m13: number;
		m21: number;
		m22: number;
		m23: number;
		m31: number;
		m32: number;
		m33: number
	}

	declare class SimpleOrientationSensor  {
		getDefault(): Windows.Devices.Sensors.SimpleOrientationSensor;
		deviceId: string;
		getCurrentOrientation(): Windows.Devices.Sensors.SimpleOrientation;
		onorientationchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor, Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>;
		addEventListener(
		type: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor, Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>
	): void;
		removeEventListener(
		type: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor, Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>
	): void;
		readingTransform: Windows.Graphics.Display.DisplayOrientations;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SimpleOrientationSensorOrientationChangedEventArgs  {
		orientation: Windows.Devices.Sensors.SimpleOrientation;
		timestamp: Date
	}

	
}

declare module 'SerialCommunication' {
				declare class ErrorReceivedEventArgs  {
		error: Windows.Devices.SerialCommunication.SerialError
	}

	declare class PinChangedEventArgs  {
		pinChange: Windows.Devices.SerialCommunication.SerialPinChange
	}

	declare class SerialDevice  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SerialCommunication.SerialDevice>;
		getDeviceSelector(portName: string): string;
		getDeviceSelector(): string;
		getDeviceSelectorFromUsbVidPid(vendorId: number, productId: number): string;
		baudRate: number;
		breakSignalState: boolean;
		bytesReceived: number;
		carrierDetectState: boolean;
		clearToSendState: boolean;
		close(): void;
		dataBits: number;
		dataSetReadyState: boolean;
		handshake: Windows.Devices.SerialCommunication.SerialHandshake;
		inputStream: Windows.Storage.Streams.IInputStream;
		isDataTerminalReadyEnabled: boolean;
		isRequestToSendEnabled: boolean;
		onerrorreceived: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.ErrorReceivedEventArgs>;
		addEventListener(
		type: "errorreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.ErrorReceivedEventArgs>
	): void;
		removeEventListener(
		type: "errorreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.ErrorReceivedEventArgs>
	): void;
		onpinchanged: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.PinChangedEventArgs>;
		addEventListener(
		type: "pinchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.PinChangedEventArgs>
	): void;
		removeEventListener(
		type: "pinchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SerialCommunication.SerialDevice, Windows.Devices.SerialCommunication.PinChangedEventArgs>
	): void;
		outputStream: Windows.Storage.Streams.IOutputStream;
		parity: Windows.Devices.SerialCommunication.SerialParity;
		portName: string;
		readTimeout: number;
		stopBits: Windows.Devices.SerialCommunication.SerialStopBitCount;
		usbProductId: number;
		usbVendorId: number;
		writeTimeout: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'SmartCards' {
	declare type SmartCardPinResetHandler = (
		sender: Windows.Devices.SmartCards.SmartCardProvisioning, request: Windows.Devices.SmartCards.SmartCardPinResetRequest
	) => void;

			declare class CardAddedEventArgs  {
		smartCard: Windows.Devices.SmartCards.SmartCard
	}

	declare class CardRemovedEventArgs  {
		smartCard: Windows.Devices.SmartCards.SmartCard
	}

	declare class SmartCard  {
		connectAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardConnection>;
		getAnswerToResetAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		getStatusAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardStatus>;
		reader: Windows.Devices.SmartCards.SmartCardReader
	}

	declare class SmartCardChallengeContext  {
		challenge: Windows.Storage.Streams.IBuffer;
		changeAdministrativeKeyAsync(
		response: Windows.Storage.Streams.IBuffer, newAdministrativeKey: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncAction;
		close(): void;
		provisionAsync(
		response: Windows.Storage.Streams.IBuffer, formatCard: boolean
	): Windows.Foundation.IPromiseWithIAsyncAction;
		provisionAsync(
		response: Windows.Storage.Streams.IBuffer, formatCard: boolean, newCardId: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		verifyResponseAsync(
		response: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class SmartCardConnection  {
		close(): void;
		transmitAsync(
		command: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>
	}

	declare class SmartCardPinPolicy  {
		constructor(): this;
		digits: Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption;
		lowercaseLetters: Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption;
		maxLength: number;
		minLength: number;
		specialCharacters: Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption;
		uppercaseLetters: Windows.Devices.SmartCards.SmartCardPinCharacterPolicyOption
	}

	declare class SmartCardPinResetDeferral  {
		complete(): void
	}

	declare class SmartCardPinResetRequest  {
		challenge: Windows.Storage.Streams.IBuffer;
		deadline: Date;
		getDeferral(): Windows.Devices.SmartCards.SmartCardPinResetDeferral;
		setResponse(response: Windows.Storage.Streams.IBuffer): void
	}

	declare class SmartCardProvisioning  {
		fromSmartCardAsync(
		card: Windows.Devices.SmartCards.SmartCard
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardProvisioning>;
		requestAttestedVirtualSmartCardCreationAsync: any;
		requestVirtualSmartCardCreationAsync(
		friendlyName: string, administrativeKey: Windows.Storage.Streams.IBuffer, pinPolicy: Windows.Devices.SmartCards.SmartCardPinPolicy, cardId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardProvisioning>;
		requestVirtualSmartCardCreationAsync(
		friendlyName: string, administrativeKey: Windows.Storage.Streams.IBuffer, pinPolicy: Windows.Devices.SmartCards.SmartCardPinPolicy
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardProvisioning>;
		requestVirtualSmartCardDeletionAsync(
		card: Windows.Devices.SmartCards.SmartCard
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getAuthorityKeyContainerNameAsync: any;
		getChallengeContextAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardChallengeContext>;
		getIdAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		requestPinChangeAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestPinResetAsync(
		handler: Windows.Devices.SmartCards.SmartCardPinResetHandler
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		smartCard: Windows.Devices.SmartCards.SmartCard
	}

	declare class SmartCardReader  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardReader>;
		getDeviceSelector(kind: Windows.Devices.SmartCards.SmartCardReaderKind): string;
		getDeviceSelector(): string;
		deviceId: string;
		findAllCardsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getStatusAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.SmartCards.SmartCardReaderStatus>;
		kind: Windows.Devices.SmartCards.SmartCardReaderKind;
		name: string;
		oncardadded: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardAddedEventArgs>;
		addEventListener(
		type: "cardadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardAddedEventArgs>
	): void;
		removeEventListener(
		type: "cardadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardAddedEventArgs>
	): void;
		oncardremoved: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardRemovedEventArgs>;
		addEventListener(
		type: "cardremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardRemovedEventArgs>
	): void;
		removeEventListener(
		type: "cardremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.SmartCards.SmartCardReader, Windows.Devices.SmartCards.CardRemovedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Sms' {
	declare type SmsDeviceStatusChangedEventHandler = (ev: WinRTEvent<Windows.Devices.Sms.SmsDevice>) => void;

	declare type SmsMessageReceivedEventHandler = (
		ev: Windows.Devices.Sms.SmsMessageReceivedEventArgs & WinRTEvent<Windows.Devices.Sms.SmsDevice>
	) => void;

	declare interface ISmsMessage {
		id: number,
		messageClass: Windows.Devices.Sms.SmsMessageClass
	}

	declare interface SmsEncodedLength {
		byteCountLastSegment: number,
		bytesPerSegment: number,
		characterCountLastSegment: number,
		charactersPerSegment: number,
		segmentCount: number
	}

	declare interface ISmsMessageBase {
		cellularClass: Windows.Devices.Sms.CellularClass,
		deviceId: string,
		messageClass: Windows.Devices.Sms.SmsMessageClass,
		messageType: Windows.Devices.Sms.SmsMessageType,
		simIccId: string
	}

	declare interface ISmsBinaryMessage {
		getData(): Array<number>,
		setData(value: Array<number>): void,
		format: Windows.Devices.Sms.SmsDataFormat
	}

		declare class DeleteSmsMessageOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncActionCompletedHandler;
		errorCode: WinRTError;
		getResults(): void;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class DeleteSmsMessagesOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncActionCompletedHandler;
		errorCode: WinRTError;
		getResults(): void;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class GetSmsDeviceOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.SmsDevice>;
		errorCode: WinRTError;
		getResults(): Windows.Devices.Sms.SmsDevice;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class GetSmsMessageOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.ISmsMessage>;
		errorCode: WinRTError;
		getResults(): Windows.Devices.Sms.ISmsMessage;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class GetSmsMessagesOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Foundation.Collections.IVectorView<any>, number>;
		errorCode: WinRTError;
		getResults(): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>;
		id: number;
		progress: Windows.Foundation.AsyncOperationProgressHandler<Windows.Foundation.Collections.IVectorView<any>, number>;
		status: Windows.Foundation.AsyncStatus
	}

	declare class SendSmsMessageOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncActionCompletedHandler;
		errorCode: WinRTError;
		getResults(): void;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class SmsAppMessage  {
		constructor(): this;
		binaryBody: Windows.Storage.Streams.IBuffer;
		body: string;
		callbackNumber: string;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceId: string;
		encoding: Windows.Devices.Sms.SmsEncoding;
		from: string;
		isDeliveryNotificationEnabled: boolean;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageType: Windows.Devices.Sms.SmsMessageType;
		portNumber: number;
		protocolId: number;
		retryAttemptCount: number;
		simIccId: string;
		teleserviceId: number;
		timestamp: Date;
		to: string
	}

	declare class SmsBinaryMessage  {
		constructor(): this;
		format: Windows.Devices.Sms.SmsDataFormat;
		getData(): number[];
		id: number;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		setData(value: number[]): void
	}

	declare class SmsBroadcastMessage  {
		body: string;
		broadcastType: Windows.Devices.Sms.SmsBroadcastType;
		cellularClass: Windows.Devices.Sms.CellularClass;
		channel: number;
		deviceId: string;
		geographicalScope: Windows.Devices.Sms.SmsGeographicalScope;
		isEmergencyAlert: boolean;
		isUserPopupRequested: boolean;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageCode: number;
		messageType: Windows.Devices.Sms.SmsMessageType;
		simIccId: string;
		timestamp: Date;
		to: string;
		updateNumber: number
	}

	declare class SmsDevice  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sms.SmsDevice>;
		fromNetworkAccountIdAsync(
		networkAccountId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sms.SmsDevice>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sms.SmsDevice>;
		getDeviceSelector(): string;
		accountPhoneNumber: string;
		calculateLength(
		message: Windows.Devices.Sms.SmsTextMessage
	): Windows.Devices.Sms.SmsEncodedLength;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
		messageStore: Windows.Devices.Sms.SmsDeviceMessageStore;
		onsmsdevicestatuschanged: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler;
		addEventListener(
		type: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler
	): void;
		removeEventListener(
		type: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler
	): void;
		onsmsmessagereceived: Windows.Devices.Sms.SmsMessageReceivedEventHandler;
		addEventListener(
		type: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler
	): void;
		removeEventListener(
		type: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler
	): void;
		sendMessageAsync(
		message: Windows.Devices.Sms.ISmsMessage
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Devices.Sms.SendSmsMessageOperation>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SmsDevice2  {
		fromId(deviceId: string): Windows.Devices.Sms.SmsDevice2;
		fromParentId(parentDeviceId: string): Windows.Devices.Sms.SmsDevice2;
		getDefault(): Windows.Devices.Sms.SmsDevice2;
		getDeviceSelector(): string;
		accountPhoneNumber: string;
		calculateLength(
		message: Windows.Devices.Sms.ISmsMessageBase
	): Windows.Devices.Sms.SmsEncodedLength;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceId: string;
		deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
		ondevicestatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsDevice2, any>;
		addEventListener(
		type: "devicestatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsDevice2, any>
	): void;
		removeEventListener(
		type: "devicestatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsDevice2, any>
	): void;
		parentDeviceId: string;
		sendMessageAndGetResultAsync(
		message: Windows.Devices.Sms.ISmsMessageBase
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sms.SmsSendMessageResult>;
		smscAddress: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SmsDeviceMessageStore  {
		deleteMessageAsync(messageId: number): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteMessagesAsync(
		messageFilter: Windows.Devices.Sms.SmsMessageFilter
	): Windows.Foundation.IPromiseWithIAsyncAction;
		getMessageAsync(
		messageId: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Sms.ISmsMessage>;
		getMessagesAsync(
		messageFilter: Windows.Devices.Sms.SmsMessageFilter
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<any>, number>;
		maxMessages: number
	}

	declare class SmsFilterRule  {
		constructor(messageType: Windows.Devices.Sms.SmsMessageType): this;
		broadcastChannels: Windows.Foundation.Collections.IVector<number>;
		broadcastTypes: Windows.Foundation.Collections.IVector<Windows.Devices.Sms.SmsBroadcastType>;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceIds: Windows.Foundation.Collections.IVector<string>;
		imsiPrefixes: Windows.Foundation.Collections.IVector<string>;
		messageType: Windows.Devices.Sms.SmsMessageType;
		portNumbers: Windows.Foundation.Collections.IVector<number>;
		protocolIds: Windows.Foundation.Collections.IVector<number>;
		senderNumbers: Windows.Foundation.Collections.IVector<string>;
		teleserviceIds: Windows.Foundation.Collections.IVector<number>;
		textMessagePrefixes: Windows.Foundation.Collections.IVector<string>;
		wapApplicationIds: Windows.Foundation.Collections.IVector<string>;
		wapContentTypes: Windows.Foundation.Collections.IVector<string>
	}

	declare class SmsFilterRules  {
		constructor(actionType: Windows.Devices.Sms.SmsFilterActionType): this;
		actionType: Windows.Devices.Sms.SmsFilterActionType;
		rules: Windows.Foundation.Collections.IVector<Windows.Devices.Sms.SmsFilterRule>
	}

	declare class SmsMessageReceivedEventArgs  {
		binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
		textMessage: Windows.Devices.Sms.SmsTextMessage
	}

	declare class SmsMessageReceivedTriggerDetails  {
		accept(): void;
		appMessage: Windows.Devices.Sms.SmsAppMessage;
		broadcastMessage: Windows.Devices.Sms.SmsBroadcastMessage;
		drop(): void;
		messageType: Windows.Devices.Sms.SmsMessageType;
		statusMessage: Windows.Devices.Sms.SmsStatusMessage;
		textMessage: Windows.Devices.Sms.SmsTextMessage2;
		voicemailMessage: Windows.Devices.Sms.SmsVoicemailMessage;
		wapMessage: Windows.Devices.Sms.SmsWapMessage
	}

	declare class SmsMessageRegistration  {
		allRegistrations: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.SmsMessageRegistration>;
		register(
		id: string, filterRules: Windows.Devices.Sms.SmsFilterRules
	): Windows.Devices.Sms.SmsMessageRegistration;
		id: string;
		onmessagereceived: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsMessageRegistration, Windows.Devices.Sms.SmsMessageReceivedTriggerDetails>;
		addEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsMessageRegistration, Windows.Devices.Sms.SmsMessageReceivedTriggerDetails>
	): void;
		removeEventListener(
		type: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sms.SmsMessageRegistration, Windows.Devices.Sms.SmsMessageReceivedTriggerDetails>
	): void;
		unregister(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SmsReceivedEventDetails  {
		binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
		deviceId: string;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageIndex: number
	}

	declare class SmsSendMessageResult  {
		cellularClass: Windows.Devices.Sms.CellularClass;
		isErrorTransient: boolean;
		isSuccessful: boolean;
		messageReferenceNumbers: Windows.Foundation.Collections.IVectorView<number>;
		modemErrorCode: Windows.Devices.Sms.SmsModemErrorCode;
		networkCauseCode: number;
		transportFailureCause: number
	}

	declare class SmsStatusMessage  {
		body: string;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceId: string;
		dischargeTime: Date;
		from: string;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageReferenceNumber: number;
		messageType: Windows.Devices.Sms.SmsMessageType;
		serviceCenterTimestamp: Date;
		simIccId: string;
		status: number;
		to: string
	}

	declare class SmsTextMessage  {
		fromBinaryData(
		format: Windows.Devices.Sms.SmsDataFormat, value: number[]
	): Windows.Devices.Sms.SmsTextMessage;
		fromBinaryMessage(
		binaryMessage: Windows.Devices.Sms.SmsBinaryMessage
	): Windows.Devices.Sms.SmsTextMessage;
		constructor(): this;
		body: string;
		encoding: Windows.Devices.Sms.SmsEncoding;
		from: string;
		id: number;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		partCount: number;
		partNumber: number;
		partReferenceId: number;
		timestamp: Date;
		to: string;
		toBinaryMessages(
		format: Windows.Devices.Sms.SmsDataFormat
	): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsBinaryMessage>
	}

	declare class SmsTextMessage2  {
		constructor(): this;
		body: string;
		callbackNumber: string;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceId: string;
		encoding: Windows.Devices.Sms.SmsEncoding;
		from: string;
		isDeliveryNotificationEnabled: boolean;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageType: Windows.Devices.Sms.SmsMessageType;
		protocolId: number;
		retryAttemptCount: number;
		simIccId: string;
		teleserviceId: number;
		timestamp: Date;
		to: string
	}

	declare class SmsVoicemailMessage  {
		body: string;
		cellularClass: Windows.Devices.Sms.CellularClass;
		deviceId: string;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageCount: number;
		messageType: Windows.Devices.Sms.SmsMessageType;
		simIccId: string;
		timestamp: Date;
		to: string
	}

	declare class SmsWapMessage  {
		applicationId: string;
		binaryBody: Windows.Storage.Streams.IBuffer;
		cellularClass: Windows.Devices.Sms.CellularClass;
		contentType: string;
		deviceId: string;
		from: string;
		headers: Windows.Foundation.Collections.IMap<string, string>;
		messageClass: Windows.Devices.Sms.SmsMessageClass;
		messageType: Windows.Devices.Sms.SmsMessageType;
		simIccId: string;
		timestamp: Date;
		to: string
	}

	
}

declare module 'Spi' {
				declare class SpiBusInfo  {
		chipSelectLineCount: number;
		maxClockFrequency: number;
		minClockFrequency: number;
		supportedDataBitLengths: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class SpiConnectionSettings  {
		constructor(chipSelectLine: number): this;
		chipSelectLine: number;
		clockFrequency: number;
		dataBitLength: number;
		mode: Windows.Devices.Spi.SpiMode;
		sharingMode: Windows.Devices.Spi.SpiSharingMode
	}

	declare class SpiController  {
		getControllersAsync(
		provider: Windows.Devices.Spi.Provider.ISpiProvider
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getDefaultAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Spi.SpiController>;
		getDevice(
		settings: Windows.Devices.Spi.SpiConnectionSettings
	): Windows.Devices.Spi.SpiDevice
	}

	declare class SpiDevice  {
		fromIdAsync(
		busId: string, settings: Windows.Devices.Spi.SpiConnectionSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Spi.SpiDevice>;
		getBusInfo(busId: string): Windows.Devices.Spi.SpiBusInfo;
		getDeviceSelector(friendlyName: string): string;
		getDeviceSelector(): string;
		close(): void;
		connectionSettings: Windows.Devices.Spi.SpiConnectionSettings;
		deviceId: string;
		read(): number[];
		transferFullDuplex(writeBuffer: number[]): number[];
		transferSequential(writeBuffer: number[]): number[];
		write(buffer: number[]): void
	}

	
}

declare module 'Usb' {
				declare class UsbBulkInEndpointDescriptor  {
		endpointNumber: number;
		maxPacketSize: number;
		pipe: Windows.Devices.Usb.UsbBulkInPipe
	}

	declare class UsbBulkInPipe  {
		clearStallAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		endpointDescriptor: Windows.Devices.Usb.UsbBulkInEndpointDescriptor;
		flushBuffer(): void;
		inputStream: Windows.Storage.Streams.IInputStream;
		maxTransferSizeBytes: number;
		readOptions: Windows.Devices.Usb.UsbReadOptions
	}

	declare class UsbBulkOutEndpointDescriptor  {
		endpointNumber: number;
		maxPacketSize: number;
		pipe: Windows.Devices.Usb.UsbBulkOutPipe
	}

	declare class UsbBulkOutPipe  {
		clearStallAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		endpointDescriptor: Windows.Devices.Usb.UsbBulkOutEndpointDescriptor;
		outputStream: Windows.Storage.Streams.IOutputStream;
		writeOptions: Windows.Devices.Usb.UsbWriteOptions
	}

	declare class UsbConfiguration  {
		configurationDescriptor: Windows.Devices.Usb.UsbConfigurationDescriptor;
		descriptors: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbDescriptor>;
		usbInterfaces: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterface>
	}

	declare class UsbConfigurationDescriptor  {
		parse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): Windows.Devices.Usb.UsbConfigurationDescriptor;
		tryParse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): {
		parsed: Windows.Devices.Usb.UsbConfigurationDescriptor,
		returnValue: boolean
	};
		configurationValue: number;
		maxPowerMilliamps: number;
		remoteWakeup: boolean;
		selfPowered: boolean
	}

	declare class UsbControlRequestType  {
		constructor(): this;
		asByte: number;
		controlTransferType: Windows.Devices.Usb.UsbControlTransferType;
		direction: Windows.Devices.Usb.UsbTransferDirection;
		recipient: Windows.Devices.Usb.UsbControlRecipient
	}

	declare class UsbDescriptor  {
		descriptorType: number;
		length: number;
		readDescriptorBuffer(buffer: Windows.Storage.Streams.IBuffer): void
	}

	declare class UsbDevice  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Usb.UsbDevice>;
		getDeviceClassSelector(usbClass: Windows.Devices.Usb.UsbDeviceClass): string;
		getDeviceSelector(vendorId: number, productId: number): string;
		getDeviceSelector(winUsbInterfaceClass: string): string;
		getDeviceSelector(vendorId: number, productId: number, winUsbInterfaceClass: string): string;
		close(): void;
		configuration: Windows.Devices.Usb.UsbConfiguration;
		defaultInterface: Windows.Devices.Usb.UsbInterface;
		deviceDescriptor: Windows.Devices.Usb.UsbDeviceDescriptor;
		sendControlInTransferAsync(
		setupPacket: Windows.Devices.Usb.UsbSetupPacket, buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		sendControlInTransferAsync(
		setupPacket: Windows.Devices.Usb.UsbSetupPacket
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		sendControlOutTransferAsync(
		setupPacket: Windows.Devices.Usb.UsbSetupPacket
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		sendControlOutTransferAsync(
		setupPacket: Windows.Devices.Usb.UsbSetupPacket, buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<number>
	}

	declare class UsbDeviceClass  {
		constructor(): this;
		classCode: number;
		protocolCode: number;
		subclassCode: number
	}

	declare class UsbDeviceClasses  {
		activeSync: Windows.Devices.Usb.UsbDeviceClass;
		cdcControl: Windows.Devices.Usb.UsbDeviceClass;
		deviceFirmwareUpdate: Windows.Devices.Usb.UsbDeviceClass;
		irda: Windows.Devices.Usb.UsbDeviceClass;
		measurement: Windows.Devices.Usb.UsbDeviceClass;
		palmSync: Windows.Devices.Usb.UsbDeviceClass;
		personalHealthcare: Windows.Devices.Usb.UsbDeviceClass;
		physical: Windows.Devices.Usb.UsbDeviceClass;
		vendorSpecific: Windows.Devices.Usb.UsbDeviceClass
	}

	declare class UsbDeviceDescriptor  {
		bcdDeviceRevision: number;
		bcdUsb: number;
		maxPacketSize0: number;
		numberOfConfigurations: number;
		productId: number;
		vendorId: number
	}

	declare class UsbEndpointDescriptor  {
		parse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): Windows.Devices.Usb.UsbEndpointDescriptor;
		tryParse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): {
		parsed: Windows.Devices.Usb.UsbEndpointDescriptor,
		returnValue: boolean
	};
		asBulkInEndpointDescriptor: Windows.Devices.Usb.UsbBulkInEndpointDescriptor;
		asBulkOutEndpointDescriptor: Windows.Devices.Usb.UsbBulkOutEndpointDescriptor;
		asInterruptInEndpointDescriptor: Windows.Devices.Usb.UsbInterruptInEndpointDescriptor;
		asInterruptOutEndpointDescriptor: Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor;
		direction: Windows.Devices.Usb.UsbTransferDirection;
		endpointNumber: number;
		endpointType: Windows.Devices.Usb.UsbEndpointType
	}

	declare class UsbInterface  {
		bulkInPipes: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbBulkInPipe>;
		bulkOutPipes: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbBulkOutPipe>;
		descriptors: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbDescriptor>;
		interfaceNumber: number;
		interfaceSettings: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterfaceSetting>;
		interruptInPipes: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterruptInPipe>;
		interruptOutPipes: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterruptOutPipe>
	}

	declare class UsbInterfaceDescriptor  {
		parse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): Windows.Devices.Usb.UsbInterfaceDescriptor;
		tryParse(
		descriptor: Windows.Devices.Usb.UsbDescriptor
	): {
		parsed: Windows.Devices.Usb.UsbInterfaceDescriptor,
		returnValue: boolean
	};
		alternateSettingNumber: number;
		classCode: number;
		interfaceNumber: number;
		protocolCode: number;
		subclassCode: number
	}

	declare class UsbInterfaceSetting  {
		bulkInEndpoints: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbBulkInEndpointDescriptor>;
		bulkOutEndpoints: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbBulkOutEndpointDescriptor>;
		descriptors: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbDescriptor>;
		interfaceDescriptor: Windows.Devices.Usb.UsbInterfaceDescriptor;
		interruptInEndpoints: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterruptInEndpointDescriptor>;
		interruptOutEndpoints: Windows.Foundation.Collections.IVectorView<Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor>;
		selectSettingAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		selected: boolean
	}

	declare class UsbInterruptInEndpointDescriptor  {
		endpointNumber: number;
		interval: number;
		maxPacketSize: number;
		pipe: Windows.Devices.Usb.UsbInterruptInPipe
	}

	declare class UsbInterruptInEventArgs  {
		interruptData: Windows.Storage.Streams.IBuffer
	}

	declare class UsbInterruptInPipe  {
		clearStallAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		endpointDescriptor: Windows.Devices.Usb.UsbInterruptInEndpointDescriptor;
		ondatareceived: Windows.Foundation.TypedEventHandler<Windows.Devices.Usb.UsbInterruptInPipe, Windows.Devices.Usb.UsbInterruptInEventArgs>;
		addEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Usb.UsbInterruptInPipe, Windows.Devices.Usb.UsbInterruptInEventArgs>
	): void;
		removeEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Usb.UsbInterruptInPipe, Windows.Devices.Usb.UsbInterruptInEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class UsbInterruptOutEndpointDescriptor  {
		endpointNumber: number;
		interval: number;
		maxPacketSize: number;
		pipe: Windows.Devices.Usb.UsbInterruptOutPipe
	}

	declare class UsbInterruptOutPipe  {
		clearStallAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		endpointDescriptor: Windows.Devices.Usb.UsbInterruptOutEndpointDescriptor;
		outputStream: Windows.Storage.Streams.IOutputStream;
		writeOptions: Windows.Devices.Usb.UsbWriteOptions
	}

	declare class UsbSetupPacket  {
		constructor(): this;
		constructor(eightByteBuffer: Windows.Storage.Streams.IBuffer): this;
		index: number;
		length: number;
		request: number;
		requestType: Windows.Devices.Usb.UsbControlRequestType;
		value: number
	}

	
}

declare module 'WiFi' {
				declare class WiFiAdapter  {
		findAllAdaptersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFi.WiFiAdapter>;
		getDeviceSelector(): string;
		requestAccessAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFi.WiFiAccessStatus>;
		connectAsync(
		availableNetwork: Windows.Devices.WiFi.WiFiAvailableNetwork, reconnectionKind: Windows.Devices.WiFi.WiFiReconnectionKind
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFi.WiFiConnectionResult>;
		connectAsync(
		availableNetwork: Windows.Devices.WiFi.WiFiAvailableNetwork, reconnectionKind: Windows.Devices.WiFi.WiFiReconnectionKind, passwordCredential: Windows.Security.Credentials.PasswordCredential
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFi.WiFiConnectionResult>;
		connectAsync(
		availableNetwork: Windows.Devices.WiFi.WiFiAvailableNetwork, reconnectionKind: Windows.Devices.WiFi.WiFiReconnectionKind, passwordCredential: Windows.Security.Credentials.PasswordCredential, ssid: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFi.WiFiConnectionResult>;
		disconnect(): void;
		networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
		networkReport: Windows.Devices.WiFi.WiFiNetworkReport;
		onavailablenetworkschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFi.WiFiAdapter, any>;
		addEventListener(
		type: "availablenetworkschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFi.WiFiAdapter, any>
	): void;
		removeEventListener(
		type: "availablenetworkschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFi.WiFiAdapter, any>
	): void;
		scanAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiAvailableNetwork  {
		beaconInterval: number;
		bssid: string;
		channelCenterFrequencyInKilohertz: number;
		isWiFiDirect: boolean;
		networkKind: Windows.Devices.WiFi.WiFiNetworkKind;
		networkRssiInDecibelMilliwatts: number;
		phyKind: Windows.Devices.WiFi.WiFiPhyKind;
		securitySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
		signalBars: number;
		ssid: string;
		uptime: number
	}

	declare class WiFiConnectionResult  {
		connectionStatus: Windows.Devices.WiFi.WiFiConnectionStatus
	}

	declare class WiFiNetworkReport  {
		availableNetworks: Windows.Foundation.Collections.IVectorView<Windows.Devices.WiFi.WiFiAvailableNetwork>;
		timestamp: Date
	}

	
}

declare module 'Services' {
				declare class WiFiDirectService  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectService>;
		getSelector(serviceName: string): string;
		getSelector(
		serviceName: string, serviceInfoFilter: Windows.Storage.Streams.IBuffer
	): string;
		connectAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>;
		connectAsync(
		pin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>;
		getProvisioningInfoAsync(
		selectedConfigurationMethod: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo>;
		onsessiondeferred: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectService, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionDeferredEventArgs>;
		addEventListener(
		type: "sessiondeferred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectService, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionDeferredEventArgs>
	): void;
		removeEventListener(
		type: "sessiondeferred", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectService, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionDeferredEventArgs>
	): void;
		preferGroupOwnerMode: boolean;
		remoteServiceInfo: Windows.Storage.Streams.IBuffer;
		serviceError: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError;
		sessionInfo: Windows.Storage.Streams.IBuffer;
		supportedConfigurationMethods: Windows.Foundation.Collections.IVectorView<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectServiceAdvertiser  {
		constructor(serviceName: string): this;
		advertisementStatus: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertisementStatus;
		autoAcceptSession: boolean;
		connectAsync(
		deviceInfo: Windows.Devices.Enumeration.DeviceInformation, pin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>;
		connectAsync(
		deviceInfo: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession>;
		customServiceStatusCode: number;
		deferredSessionInfo: Windows.Storage.Streams.IBuffer;
		onadvertisementstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, any>;
		addEventListener(
		type: "advertisementstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, any>
	): void;
		removeEventListener(
		type: "advertisementstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, any>
	): void;
		onautoacceptsessionconnected: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>;
		addEventListener(
		type: "autoacceptsessionconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>
	): void;
		removeEventListener(
		type: "autoacceptsessionconnected", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>
	): void;
		onsessionrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequestedEventArgs>;
		addEventListener(
		type: "sessionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequestedEventArgs>
	): void;
		removeEventListener(
		type: "sessionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceAdvertiser, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequestedEventArgs>
	): void;
		preferGroupOwnerMode: boolean;
		preferredConfigurationMethods: Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod>;
		serviceError: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceError;
		serviceInfo: Windows.Storage.Streams.IBuffer;
		serviceName: string;
		serviceNamePrefixes: Windows.Foundation.Collections.IVector<string>;
		serviceStatus: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceStatus;
		start(): void;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectServiceAutoAcceptSessionConnectedEventArgs  {
		session: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession;
		sessionInfo: Windows.Storage.Streams.IBuffer
	}

	declare class WiFiDirectServiceProvisioningInfo  {
		isGroupFormationNeeded: boolean;
		selectedConfigurationMethod: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceConfigurationMethod
	}

	declare class WiFiDirectServiceRemotePortAddedEventArgs  {
		endpointPairs: Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
		protocol: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceIPProtocol
	}

	declare class WiFiDirectServiceSession  {
		addDatagramSocketAsync(
		value: Windows.Networking.Sockets.DatagramSocket
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addStreamSocketListenerAsync(
		value: Windows.Networking.Sockets.StreamSocketListener
	): Windows.Foundation.IPromiseWithIAsyncAction;
		advertisementId: number;
		close(): void;
		errorStatus: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionErrorStatus;
		getConnectionEndpointPairs(): Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
		onremoteportadded: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs>;
		addEventListener(
		type: "remoteportadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs>
	): void;
		removeEventListener(
		type: "remoteportadded", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, Windows.Devices.WiFiDirect.Services.WiFiDirectServiceRemotePortAddedEventArgs>
	): void;
		onsessionstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, any>;
		addEventListener(
		type: "sessionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, any>
	): void;
		removeEventListener(
		type: "sessionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSession, any>
	): void;
		serviceAddress: string;
		serviceName: string;
		sessionAddress: string;
		sessionId: number;
		status: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionStatus;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectServiceSessionDeferredEventArgs  {
		deferredSessionInfo: Windows.Storage.Streams.IBuffer
	}

	declare class WiFiDirectServiceSessionRequest  {
		close(): void;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		provisioningInfo: Windows.Devices.WiFiDirect.Services.WiFiDirectServiceProvisioningInfo;
		sessionInfo: Windows.Storage.Streams.IBuffer
	}

	declare class WiFiDirectServiceSessionRequestedEventArgs  {
		getSessionRequest(): Windows.Devices.WiFiDirect.Services.WiFiDirectServiceSessionRequest
	}

	
}

declare module 'WiFiDirect' {
				declare class WiFiDirectAdvertisement  {
		informationElements: Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectInformationElement>;
		isAutonomousGroupOwnerEnabled: boolean;
		legacySettings: Windows.Devices.WiFiDirect.WiFiDirectLegacySettings;
		listenStateDiscoverability: Windows.Devices.WiFiDirect.WiFiDirectAdvertisementListenStateDiscoverability;
		supportedConfigurationMethods: Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod>
	}

	declare class WiFiDirectAdvertisementPublisher  {
		constructor(): this;
		advertisement: Windows.Devices.WiFiDirect.WiFiDirectAdvertisement;
		onstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher, Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>;
		addEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher, Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>
	): void;
		removeEventListener(
		type: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisher, Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatusChangedEventArgs>
	): void;
		start(): void;
		status: Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectAdvertisementPublisherStatusChangedEventArgs  {
		error: Windows.Devices.WiFiDirect.WiFiDirectError;
		status: Windows.Devices.WiFiDirect.WiFiDirectAdvertisementPublisherStatus
	}

	declare class WiFiDirectConnectionListener  {
		constructor(): this;
		onconnectionrequested: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectConnectionListener, Windows.Devices.WiFiDirect.WiFiDirectConnectionRequestedEventArgs>;
		addEventListener(
		type: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectConnectionListener, Windows.Devices.WiFiDirect.WiFiDirectConnectionRequestedEventArgs>
	): void;
		removeEventListener(
		type: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectConnectionListener, Windows.Devices.WiFiDirect.WiFiDirectConnectionRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectConnectionParameters  {
		getDevicePairingKinds(
		configurationMethod: Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod
	): Windows.Devices.Enumeration.DevicePairingKinds;
		constructor(): this;
		groupOwnerIntent: number;
		preferenceOrderedConfigurationMethods: Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectConfigurationMethod>;
		preferredPairingProcedure: Windows.Devices.WiFiDirect.WiFiDirectPairingProcedure
	}

	declare class WiFiDirectConnectionRequest  {
		close(): void;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation
	}

	declare class WiFiDirectConnectionRequestedEventArgs  {
		getConnectionRequest(): Windows.Devices.WiFiDirect.WiFiDirectConnectionRequest
	}

	declare class WiFiDirectDevice  {
		fromIdAsync(
		deviceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.WiFiDirectDevice>;
		fromIdAsync(
		deviceId: string, connectionParameters: Windows.Devices.WiFiDirect.WiFiDirectConnectionParameters
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.WiFiDirect.WiFiDirectDevice>;
		getDeviceSelector(): string;
		getDeviceSelector(type: Windows.Devices.WiFiDirect.WiFiDirectDeviceSelectorType): string;
		close(): void;
		connectionStatus: Windows.Devices.WiFiDirect.WiFiDirectConnectionStatus;
		deviceId: string;
		getConnectionEndpointPairs(): Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
		onconnectionstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectDevice, any>;
		addEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectDevice, any>
	): void;
		removeEventListener(
		type: "connectionstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.WiFiDirect.WiFiDirectDevice, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WiFiDirectInformationElement  {
		createFromBuffer(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectInformationElement>;
		createFromDeviceInformation(
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.Collections.IVector<Windows.Devices.WiFiDirect.WiFiDirectInformationElement>;
		constructor(): this;
		oui: Windows.Storage.Streams.IBuffer;
		ouiType: number;
		value: Windows.Storage.Streams.IBuffer
	}

	declare class WiFiDirectLegacySettings  {
		isEnabled: boolean;
		passphrase: Windows.Security.Credentials.PasswordCredential;
		ssid: string
	}

	
}

declare module 'Diagnostics' {
		declare interface ILoggingChannel {
		logMessage(eventString: string): void,
		logMessage(eventString: string, level: Windows.Foundation.Diagnostics.LoggingLevel): void,
		logValuePair(
		value1: string, value2: number, level: Windows.Foundation.Diagnostics.LoggingLevel
	): void,
		logValuePair(value1: string, value2: number): void,
		enabled: boolean,
		level: Windows.Foundation.Diagnostics.LoggingLevel,
		name: string
	}

	declare interface IFileLoggingSession {
		addLoggingChannel(
		loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel
	): void,
		addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void,
		closeAndSaveToFileAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void,
		name: string
	}

		declare class AsyncCausalityTracer  {
		ontracingstatuschanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "tracingstatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "tracingstatuschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		traceOperationCompletion(
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, status: Windows.Foundation.AsyncStatus
	): void;
		traceOperationCreation(
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, operationName: string, relatedContext: number
	): void;
		traceOperationRelation(
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, relation: Windows.Foundation.Diagnostics.CausalityRelation
	): void;
		traceSynchronousWorkCompletion(
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, work: Windows.Foundation.Diagnostics.CausalitySynchronousWork
	): void;
		traceSynchronousWorkStart(
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, work: Windows.Foundation.Diagnostics.CausalitySynchronousWork
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ErrorDetails  {
		createFromHResultAsync(
		errorCode: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Diagnostics.ErrorDetails>;
		description: string;
		helpUri: Windows.Foundation.Uri;
		longDescription: string
	}

	declare class FileLoggingSession  {
		constructor(name: string): this;
		addLoggingChannel(
		loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel
	): void;
		addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
		close(): void;
		closeAndSaveToFileAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		name: string;
		onlogfilegenerated: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession, Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>;
		addEventListener(
		type: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession, Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>
	): void;
		removeEventListener(
		type: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession, Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>
	): void;
		removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LogFileGeneratedEventArgs  {
		file: Windows.Storage.StorageFile
	}

	declare class LoggingActivity  {
		constructor(activityName: string, loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, level: Windows.Foundation.Diagnostics.LoggingLevel): this;
		constructor(activityName: string, loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): this;
		channel: Windows.Foundation.Diagnostics.LoggingChannel;
		close(): void;
		id: string;
		isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel, keywords: number): boolean;
		isEnabled(): boolean;
		isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel): boolean;
		logEvent(eventName: string): void;
		logEvent(
		eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel
	): void;
		logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
		logEvent(
		eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions
	): void;
		name: string;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel
	): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(startEventName: string): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields
	): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions
	): Windows.Foundation.Diagnostics.LoggingActivity;
		stopActivity(
		stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, options: Windows.Foundation.Diagnostics.LoggingOptions
	): void;
		stopActivity(stopEventName: string): void;
		stopActivity(
		stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields
	): void
	}

	declare class LoggingChannel  {
		constructor(name: string): this;
		constructor(name: string, options: Windows.Foundation.Diagnostics.LoggingChannelOptions): this;
		constructor(name: string, options: Windows.Foundation.Diagnostics.LoggingChannelOptions, id: string): this;
		close(): void;
		enabled: boolean;
		id: string;
		isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel, keywords: number): boolean;
		isEnabled(): boolean;
		isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel): boolean;
		level: Windows.Foundation.Diagnostics.LoggingLevel;
		logEvent(eventName: string): void;
		logEvent(
		eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel
	): void;
		logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
		logEvent(
		eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions
	): void;
		logMessage(eventString: string): void;
		logMessage(eventString: string, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
		logValuePair(
		value1: string, value2: number, level: Windows.Foundation.Diagnostics.LoggingLevel
	): void;
		logValuePair(value1: string, value2: number): void;
		name: string;
		onloggingenabled: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel, any>;
		addEventListener(
		type: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel, any>
	): void;
		removeEventListener(
		type: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel, any>
	): void;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel
	): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(startEventName: string): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields
	): Windows.Foundation.Diagnostics.LoggingActivity;
		startActivity(
		startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions
	): Windows.Foundation.Diagnostics.LoggingActivity;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class LoggingChannelOptions  {
		constructor(): this;
		constructor(group: string): this;
		group: string
	}

	declare class LoggingFields  {
		constructor(): this;
		addBoolean(
		name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addBoolean(
		name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addBoolean(name: string, value: boolean): void;
		addBooleanArray(name: string, value: boolean[]): void;
		addBooleanArray(
		name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addBooleanArray(
		name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addChar16(name: string, value: string): void;
		addChar16(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addChar16(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addChar16Array(name: string, value: string[]): void;
		addChar16Array(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addChar16Array(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addDateTime(name: string, value: Date): void;
		addDateTime(
		name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addDateTime(
		name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addDateTimeArray(
		name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addDateTimeArray(
		name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addDateTimeArray(name: string, value: Date[]): void;
		addDouble(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addDouble(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addDouble(name: string, value: number): void;
		addDoubleArray(
		name: string, value: Float64Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addDoubleArray(
		name: string, value: Float64Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addDoubleArray(name: string, value: Float64Array): void;
		addEmpty(name: string): void;
		addEmpty(
		name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addEmpty(name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
		addGuid(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addGuid(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addGuid(name: string, value: string): void;
		addGuidArray(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addGuidArray(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addGuidArray(name: string, value: string[]): void;
		addInt16(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt16(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt16(name: string, value: number): void;
		addInt16Array(name: string, value: Int16Array): void;
		addInt16Array(
		name: string, value: Int16Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt16Array(
		name: string, value: Int16Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt32(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt32(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt32(name: string, value: number): void;
		addInt32Array(
		name: string, value: Int32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt32Array(
		name: string, value: Int32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt32Array(name: string, value: Int32Array): void;
		addInt64(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt64(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt64(name: string, value: number): void;
		addInt64Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addInt64Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addInt64Array(name: string, value: number[]): void;
		addPoint(name: string, value: Windows.Foundation.Point): void;
		addPoint(
		name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addPoint(
		name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addPointArray(
		name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addPointArray(
		name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addPointArray(name: string, value: Windows.Foundation.Point): void;
		addRect(
		name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addRect(
		name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addRect(name: string, value: Windows.Foundation.Rect): void;
		addRectArray(name: string, value: Windows.Foundation.Rect): void;
		addRectArray(
		name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addRectArray(
		name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addSingle(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addSingle(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addSingle(name: string, value: number): void;
		addSingleArray(name: string, value: Float32Array): void;
		addSingleArray(
		name: string, value: Float32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addSingleArray(
		name: string, value: Float32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addSize(name: string, value: Windows.Foundation.Size): void;
		addSize(
		name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addSize(
		name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addSizeArray(
		name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addSizeArray(name: string, value: Windows.Foundation.Size): void;
		addSizeArray(
		name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addString(name: string, value: string): void;
		addString(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addString(
		name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addStringArray(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addStringArray(
		name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addStringArray(name: string, value: string[]): void;
		addTimeSpan(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addTimeSpan(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addTimeSpan(name: string, value: number): void;
		addTimeSpanArray(name: string, value: number[]): void;
		addTimeSpanArray(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addTimeSpanArray(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt16(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt16(name: string, value: number): void;
		addUInt16(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt16Array(name: string, value: Uint16Array): void;
		addUInt16Array(
		name: string, value: Uint16Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt16Array(
		name: string, value: Uint16Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt32(name: string, value: number): void;
		addUInt32(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt32(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt32Array(name: string, value: Uint32Array): void;
		addUInt32Array(
		name: string, value: Uint32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt32Array(
		name: string, value: Uint32Array, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt64(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt64(name: string, value: number): void;
		addUInt64(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt64Array(name: string, value: number[]): void;
		addUInt64Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt64Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt8(name: string, value: number): void;
		addUInt8(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		addUInt8(
		name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt8Array(name: string, value: number[]): void;
		addUInt8Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat
	): void;
		addUInt8Array(
		name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number
	): void;
		beginStruct(name: string): void;
		beginStruct(name: string, tags: number): void;
		clear(): void;
		endStruct(): void
	}

	declare class LoggingOptions  {
		constructor(): this;
		constructor(keywords: number): this;
		activityId: string;
		keywords: number;
		opcode: Windows.Foundation.Diagnostics.LoggingOpcode;
		relatedActivityId: string;
		tags: number;
		task: number
	}

	declare class LoggingSession  {
		constructor(name: string): this;
		addLoggingChannel(
		loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel
	): void;
		addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
		close(): void;
		name: string;
		removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
		saveToFileAsync(
		folder: Windows.Storage.IStorageFolder, fileName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>
	}

	declare class RuntimeBrokerErrorSettings  {
		constructor(): this;
		getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
		setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void
	}

	declare class TracingStatusChangedEventArgs  {
		enabled: boolean;
		traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel
	}

	declare class ProcessCpuUsage  {
		getReport(): Windows.System.Diagnostics.ProcessCpuUsageReport
	}

	declare class ProcessCpuUsageReport  {
		kernelTime: number;
		userTime: number
	}

	declare class ProcessDiagnosticInfo  {
		getForCurrentProcess(): Windows.System.Diagnostics.ProcessDiagnosticInfo;
		getForProcesses(
		
	): Windows.Foundation.Collections.IVectorView<Windows.System.Diagnostics.ProcessDiagnosticInfo>;
		cpuUsage: Windows.System.Diagnostics.ProcessCpuUsage;
		diskUsage: Windows.System.Diagnostics.ProcessDiskUsage;
		executableFileName: string;
		memoryUsage: Windows.System.Diagnostics.ProcessMemoryUsage;
		parent: Windows.System.Diagnostics.ProcessDiagnosticInfo;
		processId: number;
		processStartTime: Date
	}

	declare class ProcessDiskUsage  {
		getReport(): Windows.System.Diagnostics.ProcessDiskUsageReport
	}

	declare class ProcessDiskUsageReport  {
		bytesReadCount: number;
		bytesWrittenCount: number;
		otherBytesCount: number;
		otherOperationCount: number;
		readOperationCount: number;
		writeOperationCount: number
	}

	declare class ProcessMemoryUsage  {
		getReport(): Windows.System.Diagnostics.ProcessMemoryUsageReport
	}

	declare class ProcessMemoryUsageReport  {
		nonPagedPoolSizeInBytes: number;
		pageFaultCount: number;
		pageFileSizeInBytes: number;
		pagedPoolSizeInBytes: number;
		peakNonPagedPoolSizeInBytes: number;
		peakPageFileSizeInBytes: number;
		peakPagedPoolSizeInBytes: number;
		peakVirtualMemorySizeInBytes: number;
		peakWorkingSetSizeInBytes: number;
		privatePageCount: number;
		virtualMemorySizeInBytes: number;
		workingSetSizeInBytes: number
	}

	declare class BackgroundEnergyDiagnostics  {
		computeTotalEnergyUsage(): number;
		deviceSpecificConversionFactor: number;
		resetTotalEnergyUsage(): void
	}

	declare class ForegroundEnergyDiagnostics  {
		computeTotalEnergyUsage(): number;
		deviceSpecificConversionFactor: number;
		resetTotalEnergyUsage(): void
	}

	declare class HttpDiagnosticProvider  {
		createFromProcessDiagnosticInfo(
		processDiagnosticInfo: Windows.System.Diagnostics.ProcessDiagnosticInfo
	): Windows.Web.Http.Diagnostics.HttpDiagnosticProvider;
		onrequestresponsecompleted: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs>;
		addEventListener(
		type: "requestresponsecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs>
	): void;
		removeEventListener(
		type: "requestresponsecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs>
	): void;
		onrequestsent: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs>;
		addEventListener(
		type: "requestsent", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs>
	): void;
		removeEventListener(
		type: "requestsent", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs>
	): void;
		onresponsereceived: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs>;
		addEventListener(
		type: "responsereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs>
	): void;
		removeEventListener(
		type: "responsereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Web.Http.Diagnostics.HttpDiagnosticProvider, Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs>
	): void;
		start(): void;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class HttpDiagnosticProviderRequestResponseCompletedEventArgs  {
		activityId: string;
		initiator: Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator;
		processId: any;
		requestedUri: Windows.Foundation.Uri;
		sourceLocations: any;
		threadId: any;
		timestamps: Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps
	}

	declare class HttpDiagnosticProviderRequestResponseTimestamps  {
		cacheCheckedTimestamp: Date;
		connectionCompletedTimestamp: Date;
		connectionInitiatedTimestamp: Date;
		nameResolvedTimestamp: Date;
		requestCompletedTimestamp: Date;
		requestSentTimestamp: Date;
		responseCompletedTimestamp: Date;
		responseReceivedTimestamp: Date;
		sslNegotiatedTimestamp: Date
	}

	declare class HttpDiagnosticProviderRequestSentEventArgs  {
		activityId: string;
		initiator: Windows.Web.Http.Diagnostics.HttpDiagnosticRequestInitiator;
		message: Windows.Web.Http.HttpRequestMessage;
		processId: number;
		sourceLocations: Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation>;
		threadId: number;
		timestamp: Date
	}

	declare class HttpDiagnosticProviderResponseReceivedEventArgs  {
		activityId: string;
		message: Windows.Web.Http.HttpResponseMessage;
		timestamp: Date
	}

	declare class HttpDiagnosticSourceLocation  {
		columnNumber: number;
		lineNumber: number;
		sourceUri: Windows.Foundation.Uri
	}

	
}

declare module 'Metadata' {
				declare class ActivatableAttribute  {
		
	}

	declare class AllowForWebAttribute  {
		
	}

	declare class AllowMultipleAttribute  {
		
	}

	declare class ApiContractAttribute  {
		
	}

	declare class ApiInformation  {
		isApiContractPresent(contractName: string, majorVersion: number): boolean;
		isApiContractPresent(contractName: string, majorVersion: number, minorVersion: number): boolean;
		isEnumNamedValuePresent(enumTypeName: string, valueName: string): boolean;
		isEventPresent(typeName: string, eventName: string): boolean;
		isMethodPresent(typeName: string, methodName: string): boolean;
		isMethodPresent(typeName: string, methodName: string, inputParameterCount: number): boolean;
		isPropertyPresent(typeName: string, propertyName: string): boolean;
		isReadOnlyPropertyPresent(typeName: string, propertyName: string): boolean;
		isTypePresent(typeName: string): boolean;
		isWriteablePropertyPresent(typeName: string, propertyName: string): boolean
	}

	declare class AttributeUsageAttribute  {
		
	}

	declare class ComposableAttribute  {
		
	}

	declare class ContractVersionAttribute  {
		
	}

	declare class DefaultAttribute  {
		
	}

	declare class DefaultOverloadAttribute  {
		
	}

	declare class DeprecatedAttribute  {
		
	}

	declare class DualApiPartitionAttribute  {
		
	}

	declare class ExclusiveToAttribute  {
		
	}

	declare class ExperimentalAttribute  {
		
	}

	declare class GCPressureAttribute  {
		
	}

	declare class GuidAttribute  {
		
	}

	declare class HasVariantAttribute  {
		
	}

	declare class InternalAttribute  {
		
	}

	declare class LengthIsAttribute  {
		
	}

	declare class MarshalingBehaviorAttribute  {
		
	}

	declare class MetadataMarshalAttribute  {
		
	}

	declare class MuseAttribute  {
		
	}

	declare class OverloadAttribute  {
		
	}

	declare class OverridableAttribute  {
		
	}

	declare class PlatformAttribute  {
		
	}

	declare class PreviousContractVersionAttribute  {
		
	}

	declare class ProtectedAttribute  {
		
	}

	declare class RangeAttribute  {
		
	}

	declare class RemoteAsyncAttribute  {
		
	}

	declare class StaticAttribute  {
		
	}

	declare class ThreadingAttribute  {
		
	}

	declare class VariantAttribute  {
		
	}

	declare class VersionAttribute  {
		
	}

	declare class WebHostHiddenAttribute  {
		
	}

	
}

declare module 'Numerics' {
		declare interface Matrix4x4 {
		m11: number,
		m12: number,
		m13: number,
		m14: number,
		m21: number,
		m22: number,
		m23: number,
		m24: number,
		m31: number,
		m32: number,
		m33: number,
		m34: number,
		m41: number,
		m42: number,
		m43: number,
		m44: number
	}

	declare interface Vector3 {
		x: number,
		y: number,
		z: number
	}

	declare interface Quaternion {
		w: number,
		x: number,
		y: number,
		z: number
	}

	declare interface Vector2 {
		x: number,
		y: number
	}

	declare interface Matrix3x2 {
		m11: number,
		m12: number,
		m21: number,
		m22: number,
		m31: number,
		m32: number
	}

			
}

declare module 'GamesEnumeration' {
				declare class GameList  {
		addEventListener: any;
		findAllAsync: any;
		ongameadded: any;
		ongameremoved: any;
		ongameupdated: any;
		removeEventListener: any
	}

	declare class GameListEntry  {
		category: any;
		displayInfo: any;
		launchAsync: any;
		properties: any;
		setCategoryAsync: any
	}

	
}

declare module 'UI' {
		declare interface Color {
		a: number,
		b: number,
		g: number,
		r: number
	}

		declare class GameBar  {
		addEventListener: any;
		isInputRedirected: any;
		onisinputredirectedchanged: any;
		onvisibilitychanged: any;
		removeEventListener: any;
		visible: any
	}

	declare class CredentialPicker  {
		pickAsync(
		targetName: string, message: string, caption: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
		pickAsync(
		targetName: string, message: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
		pickAsync(
		options: Windows.Security.Credentials.UI.CredentialPickerOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>
	}

	declare class CredentialPickerOptions  {
		constructor(): this;
		alwaysDisplayDialog: boolean;
		authenticationProtocol: Windows.Security.Credentials.UI.AuthenticationProtocol;
		callerSavesCredential: boolean;
		caption: string;
		credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
		customAuthenticationProtocol: string;
		errorCode: number;
		message: string;
		previousCredential: Windows.Storage.Streams.IBuffer;
		targetName: string
	}

	declare class CredentialPickerResults  {
		credential: Windows.Storage.Streams.IBuffer;
		credentialDomainName: string;
		credentialPassword: string;
		credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
		credentialSaved: boolean;
		credentialUserName: string;
		errorCode: number
	}

	declare class UserConsentVerifier  {
		checkAvailabilityAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.UI.UserConsentVerifierAvailability>;
		requestVerificationAsync(
		message: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.UI.UserConsentVerificationResult>
	}

	declare class ColorHelper  {
		fromArgb(a: number, r: number, g: number, b: number): Windows.UI.Color
	}

	declare class Colors  {
		aliceBlue: Windows.UI.Color;
		antiqueWhite: Windows.UI.Color;
		aqua: Windows.UI.Color;
		aquamarine: Windows.UI.Color;
		azure: Windows.UI.Color;
		beige: Windows.UI.Color;
		bisque: Windows.UI.Color;
		black: Windows.UI.Color;
		blanchedAlmond: Windows.UI.Color;
		blue: Windows.UI.Color;
		blueViolet: Windows.UI.Color;
		brown: Windows.UI.Color;
		burlyWood: Windows.UI.Color;
		cadetBlue: Windows.UI.Color;
		chartreuse: Windows.UI.Color;
		chocolate: Windows.UI.Color;
		coral: Windows.UI.Color;
		cornflowerBlue: Windows.UI.Color;
		cornsilk: Windows.UI.Color;
		crimson: Windows.UI.Color;
		cyan: Windows.UI.Color;
		darkBlue: Windows.UI.Color;
		darkCyan: Windows.UI.Color;
		darkGoldenrod: Windows.UI.Color;
		darkGray: Windows.UI.Color;
		darkGreen: Windows.UI.Color;
		darkKhaki: Windows.UI.Color;
		darkMagenta: Windows.UI.Color;
		darkOliveGreen: Windows.UI.Color;
		darkOrange: Windows.UI.Color;
		darkOrchid: Windows.UI.Color;
		darkRed: Windows.UI.Color;
		darkSalmon: Windows.UI.Color;
		darkSeaGreen: Windows.UI.Color;
		darkSlateBlue: Windows.UI.Color;
		darkSlateGray: Windows.UI.Color;
		darkTurquoise: Windows.UI.Color;
		darkViolet: Windows.UI.Color;
		deepPink: Windows.UI.Color;
		deepSkyBlue: Windows.UI.Color;
		dimGray: Windows.UI.Color;
		dodgerBlue: Windows.UI.Color;
		firebrick: Windows.UI.Color;
		floralWhite: Windows.UI.Color;
		forestGreen: Windows.UI.Color;
		fuchsia: Windows.UI.Color;
		gainsboro: Windows.UI.Color;
		ghostWhite: Windows.UI.Color;
		gold: Windows.UI.Color;
		goldenrod: Windows.UI.Color;
		gray: Windows.UI.Color;
		green: Windows.UI.Color;
		greenYellow: Windows.UI.Color;
		honeydew: Windows.UI.Color;
		hotPink: Windows.UI.Color;
		indianRed: Windows.UI.Color;
		indigo: Windows.UI.Color;
		ivory: Windows.UI.Color;
		khaki: Windows.UI.Color;
		lavender: Windows.UI.Color;
		lavenderBlush: Windows.UI.Color;
		lawnGreen: Windows.UI.Color;
		lemonChiffon: Windows.UI.Color;
		lightBlue: Windows.UI.Color;
		lightCoral: Windows.UI.Color;
		lightCyan: Windows.UI.Color;
		lightGoldenrodYellow: Windows.UI.Color;
		lightGray: Windows.UI.Color;
		lightGreen: Windows.UI.Color;
		lightPink: Windows.UI.Color;
		lightSalmon: Windows.UI.Color;
		lightSeaGreen: Windows.UI.Color;
		lightSkyBlue: Windows.UI.Color;
		lightSlateGray: Windows.UI.Color;
		lightSteelBlue: Windows.UI.Color;
		lightYellow: Windows.UI.Color;
		lime: Windows.UI.Color;
		limeGreen: Windows.UI.Color;
		linen: Windows.UI.Color;
		magenta: Windows.UI.Color;
		maroon: Windows.UI.Color;
		mediumAquamarine: Windows.UI.Color;
		mediumBlue: Windows.UI.Color;
		mediumOrchid: Windows.UI.Color;
		mediumPurple: Windows.UI.Color;
		mediumSeaGreen: Windows.UI.Color;
		mediumSlateBlue: Windows.UI.Color;
		mediumSpringGreen: Windows.UI.Color;
		mediumTurquoise: Windows.UI.Color;
		mediumVioletRed: Windows.UI.Color;
		midnightBlue: Windows.UI.Color;
		mintCream: Windows.UI.Color;
		mistyRose: Windows.UI.Color;
		moccasin: Windows.UI.Color;
		navajoWhite: Windows.UI.Color;
		navy: Windows.UI.Color;
		oldLace: Windows.UI.Color;
		olive: Windows.UI.Color;
		oliveDrab: Windows.UI.Color;
		orange: Windows.UI.Color;
		orangeRed: Windows.UI.Color;
		orchid: Windows.UI.Color;
		paleGoldenrod: Windows.UI.Color;
		paleGreen: Windows.UI.Color;
		paleTurquoise: Windows.UI.Color;
		paleVioletRed: Windows.UI.Color;
		papayaWhip: Windows.UI.Color;
		peachPuff: Windows.UI.Color;
		peru: Windows.UI.Color;
		pink: Windows.UI.Color;
		plum: Windows.UI.Color;
		powderBlue: Windows.UI.Color;
		purple: Windows.UI.Color;
		red: Windows.UI.Color;
		rosyBrown: Windows.UI.Color;
		royalBlue: Windows.UI.Color;
		saddleBrown: Windows.UI.Color;
		salmon: Windows.UI.Color;
		sandyBrown: Windows.UI.Color;
		seaGreen: Windows.UI.Color;
		seaShell: Windows.UI.Color;
		sienna: Windows.UI.Color;
		silver: Windows.UI.Color;
		skyBlue: Windows.UI.Color;
		slateBlue: Windows.UI.Color;
		slateGray: Windows.UI.Color;
		snow: Windows.UI.Color;
		springGreen: Windows.UI.Color;
		steelBlue: Windows.UI.Color;
		tan: Windows.UI.Color;
		teal: Windows.UI.Color;
		thistle: Windows.UI.Color;
		tomato: Windows.UI.Color;
		transparent: Windows.UI.Color;
		turquoise: Windows.UI.Color;
		violet: Windows.UI.Color;
		wheat: Windows.UI.Color;
		white: Windows.UI.Color;
		whiteSmoke: Windows.UI.Color;
		yellow: Windows.UI.Color;
		yellowGreen: Windows.UI.Color
	}

	
}

declare module 'Storage' {
	declare type ApplicationDataSetVersionHandler = (setVersionRequest: Windows.Storage.SetVersionRequest) => void;

	declare type StreamedFileDataRequestedHandler = (stream: Windows.Storage.StreamedFileDataRequest) => void;

	declare interface IStorageItem {
		deleteAsync(
		option: Windows.Storage.StorageDeleteOption
	): Windows.Foundation.IPromiseWithIAsyncAction,
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction,
		getBasicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.BasicProperties>,
		isOfType(type: Windows.Storage.StorageItemTypes): boolean,
		renameAsync(
		desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction,
		renameAsync(desiredName: string): Windows.Foundation.IPromiseWithIAsyncAction,
		attributes: Windows.Storage.FileAttributes,
		dateCreated: Date,
		name: string,
		path: string,
		getParentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>,
		isEqual(item: Windows.Storage.IStorageItem): boolean
	}

	declare interface IStorageFile {
		copyAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction,
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		moveAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction,
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncAction,
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction,
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncAction,
		openAsync(
		accessMode: Windows.Storage.FileAccessMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>,
		openAsync(
		accessMode: Windows.Storage.FileAccessMode, options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>,
		openTransactedWriteAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>,
		openTransactedWriteAsync(
		options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>,
		contentType: string,
		fileType: string
	}

	declare interface IStorageFolder {
		createFileAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		createFileAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		createFolderAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>,
		createFolderAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>,
		getFileAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>,
		getFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>,
		getFolderAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>,
		getFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>,
		getItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>,
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>,
		tryGetItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>
	}

		declare class GameSaveBlobGetResult  {
		status: Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus;
		value: Windows.Foundation.Collections.IMapView<string, Windows.Storage.Streams.IBuffer>
	}

	declare class GameSaveBlobInfo  {
		name: string;
		size: number
	}

	declare class GameSaveBlobInfoGetResult  {
		status: Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus;
		value: Windows.Foundation.Collections.IVectorView<Windows.Gaming.XboxLive.Storage.GameSaveBlobInfo>
	}

	declare class GameSaveBlobInfoQuery  {
		getBlobInfoAsync(
		startIndex: number, maxNumberOfItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult>;
		getBlobInfoAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoGetResult>;
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>
	}

	declare class GameSaveContainer  {
		createBlobInfoQuery(blobNamePrefix: string): Windows.Gaming.XboxLive.Storage.GameSaveBlobInfoQuery;
		getAsync(
		blobsToRead: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveBlobGetResult>;
		name: string;
		provider: Windows.Gaming.XboxLive.Storage.GameSaveProvider;
		readAsync(
		blobsToRead: Windows.Foundation.Collections.IMapView<string, Windows.Storage.Streams.IBuffer>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>;
		submitPropertySetUpdatesAsync(
		blobsToWrite: Windows.Foundation.Collections.IPropertySet, blobsToDelete: Windows.Foundation.Collections.IIterable<string>, displayName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>;
		submitUpdatesAsync(
		blobsToWrite: Windows.Foundation.Collections.IMapView<string, Windows.Storage.Streams.IBuffer>, blobsToDelete: Windows.Foundation.Collections.IIterable<string>, displayName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>
	}

	declare class GameSaveContainerInfo  {
		displayName: string;
		lastModifiedTime: Date;
		name: string;
		needsSync: boolean;
		totalSize: number
	}

	declare class GameSaveContainerInfoGetResult  {
		status: Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus;
		value: Windows.Foundation.Collections.IVectorView<Windows.Gaming.XboxLive.Storage.GameSaveContainerInfo>
	}

	declare class GameSaveContainerInfoQuery  {
		getContainerInfoAsync(
		startIndex: number, maxNumberOfItems: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult>;
		getContainerInfoAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoGetResult>;
		getItemCountAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>
	}

	declare class GameSaveOperationResult  {
		status: Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus
	}

	declare class GameSaveProvider  {
		getForUserAsync(
		user: Windows.System.User, serviceConfigId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult>;
		getSyncOnDemandForUserAsync(
		user: Windows.System.User, serviceConfigId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveProviderGetResult>;
		containersChangedSinceLastSync: Windows.Foundation.Collections.IVectorView<string>;
		createContainer(name: string): Windows.Gaming.XboxLive.Storage.GameSaveContainer;
		createContainerInfoQuery(
		containerNamePrefix: string
	): Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery;
		createContainerInfoQuery(): Windows.Gaming.XboxLive.Storage.GameSaveContainerInfoQuery;
		deleteContainerAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Gaming.XboxLive.Storage.GameSaveOperationResult>;
		getRemainingBytesInQuotaAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<number>;
		user: Windows.System.User
	}

	declare class GameSaveProviderGetResult  {
		status: Windows.Gaming.XboxLive.Storage.GameSaveErrorStatus;
		value: Windows.Gaming.XboxLive.Storage.GameSaveProvider
	}

	declare class ApplicationData  {
		current: Windows.Storage.ApplicationData;
		getForUserAsync(
		user: Windows.System.User
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.ApplicationData>;
		clearAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		clearAsync(
		locality: Windows.Storage.ApplicationDataLocality
	): Windows.Foundation.IPromiseWithIAsyncAction;
		clearPublisherCacheFolderAsync(folderName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		getPublisherCacheFolder(folderName: string): Windows.Storage.StorageFolder;
		localCacheFolder: Windows.Storage.StorageFolder;
		localFolder: Windows.Storage.StorageFolder;
		localSettings: Windows.Storage.ApplicationDataContainer;
		ondatachanged: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData, any>;
		addEventListener(
		type: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData, any>
	): void;
		removeEventListener(
		type: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData, any>
	): void;
		roamingFolder: Windows.Storage.StorageFolder;
		roamingSettings: Windows.Storage.ApplicationDataContainer;
		roamingStorageQuota: number;
		setVersionAsync(
		desiredVersion: number, handler: Windows.Storage.ApplicationDataSetVersionHandler
	): Windows.Foundation.IPromiseWithIAsyncAction;
		sharedLocalFolder: Windows.Storage.StorageFolder;
		signalDataChanged(): void;
		temporaryFolder: Windows.Storage.StorageFolder;
		version: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ApplicationDataCompositeValue  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, any>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ApplicationDataContainer  {
		containers: Windows.Foundation.Collections.IMapView<string, Windows.Storage.ApplicationDataContainer>;
		createContainer(
		name: string, disposition: Windows.Storage.ApplicationDataCreateDisposition
	): Windows.Storage.ApplicationDataContainer;
		deleteContainer(name: string): void;
		locality: Windows.Storage.ApplicationDataLocality;
		name: string;
		values: Windows.Foundation.Collections.IPropertySet
	}

	declare class ApplicationDataContainerSettings  {
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, any>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CachedFileManager  {
		completeUpdatesAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Provider.FileUpdateStatus>;
		deferUpdates(file: Windows.Storage.IStorageFile): void
	}

	declare class DownloadsFolder  {
		createFileAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileAsync(
		desiredName: string, option: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileForUserAsync(
		user: Windows.System.User, desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileForUserAsync(
		user: Windows.System.User, desiredName: string, option: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFolderAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderAsync(
		desiredName: string, option: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderForUserAsync(
		user: Windows.System.User, desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderForUserAsync(
		user: Windows.System.User, desiredName: string, option: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>
	}

	declare class FileIO  {
		appendLinesAsync(
		file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendLinesAsync(
		file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendTextAsync(
		file: Windows.Storage.IStorageFile, contents: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendTextAsync(
		file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		readBufferAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		readLinesAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		readLinesAsync(
		file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		readTextAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		readTextAsync(
		file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		writeBufferAsync(
		file: Windows.Storage.IStorageFile, buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeBytesAsync(
		file: Windows.Storage.IStorageFile, buffer: number[]
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeLinesAsync(
		file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeLinesAsync(
		file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeTextAsync(
		file: Windows.Storage.IStorageFile, contents: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeTextAsync(
		file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class KnownFolders  {
		appCaptures: Windows.Storage.StorageFolder;
		cameraRoll: Windows.Storage.StorageFolder;
		documentsLibrary: Windows.Storage.StorageFolder;
		getFolderForUserAsync(
		user: Windows.System.User, folderId: Windows.Storage.KnownFolderId
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		homeGroup: Windows.Storage.StorageFolder;
		mediaServerDevices: Windows.Storage.StorageFolder;
		musicLibrary: Windows.Storage.StorageFolder;
		objects3D: Windows.Storage.StorageFolder;
		picturesLibrary: Windows.Storage.StorageFolder;
		playlists: Windows.Storage.StorageFolder;
		recordedCalls: Windows.Storage.StorageFolder;
		removableDevices: Windows.Storage.StorageFolder;
		savedPictures: Windows.Storage.StorageFolder;
		videosLibrary: Windows.Storage.StorageFolder
	}

	declare class PathIO  {
		appendLinesAsync(
		absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendLinesAsync(
		absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendTextAsync(
		absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		appendTextAsync(
		absolutePath: string, contents: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		readBufferAsync(
		absolutePath: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		readLinesAsync(
		absolutePath: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		readLinesAsync(
		absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		readTextAsync(absolutePath: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		readTextAsync(
		absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		writeBufferAsync(
		absolutePath: string, buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeBytesAsync(
		absolutePath: string, buffer: number[]
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeLinesAsync(
		absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeLinesAsync(
		absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeTextAsync(
		absolutePath: string, contents: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		writeTextAsync(
		absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class SetVersionDeferral  {
		complete(): void
	}

	declare class SetVersionRequest  {
		currentVersion: number;
		desiredVersion: number;
		getDeferral(): Windows.Storage.SetVersionDeferral
	}

	declare class StorageFile  {
		createStreamedFileAsync(
		displayNameWithExtension: string, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createStreamedFileFromUriAsync(
		displayNameWithExtension: string, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFileFromApplicationUriAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFileFromPathAsync(
		path: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		replaceWithStreamedFileAsync(
		fileToReplace: Windows.Storage.IStorageFile, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		replaceWithStreamedFileFromUriAsync(
		fileToReplace: Windows.Storage.IStorageFile, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		attributes: Windows.Storage.FileAttributes;
		contentType: string;
		copyAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		dateCreated: Date;
		deleteAsync(
		option: Windows.Storage.StorageDeleteOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		displayType: string;
		fileType: string;
		folderRelativeId: string;
		getBasicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
		getParentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		isAvailable: boolean;
		isEqual(item: Windows.Storage.IStorageItem): boolean;
		isOfType(type: Windows.Storage.StorageItemTypes): boolean;
		moveAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		name: string;
		openAsync(
		accessMode: Windows.Storage.FileAccessMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		openAsync(
		accessMode: Windows.Storage.FileAccessMode, options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		openReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
		openSequentialReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IInputStream>;
		openTransactedWriteAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>;
		openTransactedWriteAsync(
		options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>;
		path: string;
		properties: Windows.Storage.FileProperties.StorageItemContentProperties;
		provider: Windows.Storage.StorageProvider;
		renameAsync(desiredName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		renameAsync(
		desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class StorageFolder  {
		getFolderFromPathAsync(
		path: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
		attributes: Windows.Storage.FileAttributes;
		createFileAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
		createFileQuery(
		query: Windows.Storage.Search.CommonFileQuery
	): Windows.Storage.Search.StorageFileQueryResult;
		createFileQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageFileQueryResult;
		createFolderAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
		createFolderQuery(
		query: Windows.Storage.Search.CommonFolderQuery
	): Windows.Storage.Search.StorageFolderQueryResult;
		createFolderQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageFolderQueryResult;
		createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
		createItemQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageItemQueryResult;
		dateCreated: Date;
		deleteAsync(
		option: Windows.Storage.StorageDeleteOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		displayType: string;
		folderRelativeId: string;
		getBasicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
		getFileAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFilesAsync(
		query: Windows.Storage.Search.CommonFileQuery
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFolderAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		query: Windows.Storage.Search.CommonFolderQuery
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getIndexedStateAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Search.IndexedState>;
		getItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemsAsync(
		startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getParentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getScaledImageAsThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
		isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
		isEqual(item: Windows.Storage.IStorageItem): boolean;
		isOfType(type: Windows.Storage.StorageItemTypes): boolean;
		name: string;
		path: string;
		properties: Windows.Storage.FileProperties.StorageItemContentProperties;
		provider: Windows.Storage.StorageProvider;
		renameAsync(desiredName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		renameAsync(
		desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tryGetItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>
	}

	declare class StorageLibrary  {
		getLibraryAsync(
		libraryId: Windows.Storage.KnownLibraryId
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageLibrary>;
		getLibraryForUserAsync(
		user: Windows.System.User, libraryId: Windows.Storage.KnownLibraryId
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageLibrary>;
		folders: Windows.Foundation.Collections.IObservableVector<Windows.Storage.StorageFolder>;
		ondefinitionchanged: Windows.Foundation.TypedEventHandler<Windows.Storage.StorageLibrary, any>;
		addEventListener(
		type: "definitionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.StorageLibrary, any>
	): void;
		removeEventListener(
		type: "definitionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.StorageLibrary, any>
	): void;
		requestAddFolderAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		requestRemoveFolderAsync(
		folder: Windows.Storage.StorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		saveFolder: Windows.Storage.StorageFolder;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class StorageProvider  {
		displayName: string;
		id: string
	}

	declare class StorageStreamTransaction  {
		close(): void;
		commitAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stream: Windows.Storage.Streams.IRandomAccessStream
	}

	declare class StreamedFileDataRequest  {
		close(): void;
		failAndClose(failureMode: Windows.Storage.StreamedFileFailureMode): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class SystemAudioProperties  {
		encodingBitrate: string
	}

	declare class SystemGPSProperties  {
		latitudeDecimal: string;
		longitudeDecimal: string
	}

	declare class SystemImageProperties  {
		horizontalSize: string;
		verticalSize: string
	}

	declare class SystemMediaProperties  {
		duration: string;
		producer: string;
		publisher: string;
		subTitle: string;
		writer: string;
		year: string
	}

	declare class SystemMusicProperties  {
		albumArtist: string;
		albumTitle: string;
		artist: string;
		composer: string;
		conductor: string;
		displayArtist: string;
		genre: string;
		trackNumber: string
	}

	declare class SystemPhotoProperties  {
		cameraManufacturer: string;
		cameraModel: string;
		dateTaken: string;
		orientation: string;
		peopleNames: string
	}

	declare class SystemProperties  {
		audio: Windows.Storage.SystemAudioProperties;
		author: string;
		comment: string;
		gps: Windows.Storage.SystemGPSProperties;
		image: Windows.Storage.SystemImageProperties;
		itemNameDisplay: string;
		keywords: string;
		media: Windows.Storage.SystemMediaProperties;
		music: Windows.Storage.SystemMusicProperties;
		photo: Windows.Storage.SystemPhotoProperties;
		rating: string;
		title: string;
		video: Windows.Storage.SystemVideoProperties
	}

	declare class SystemVideoProperties  {
		director: string;
		frameHeight: string;
		frameWidth: string;
		orientation: string;
		totalBitrate: string
	}

	
}

declare module 'Globalization' {
				declare class ApplicationLanguages  {
		languages: Windows.Foundation.Collections.IVectorView<string>;
		manifestLanguages: Windows.Foundation.Collections.IVectorView<string>;
		primaryLanguageOverride: string
	}

	declare class Calendar  {
		constructor(languages: Windows.Foundation.Collections.IIterable<string>, calendar: string, clock: string): this;
		constructor(languages: Windows.Foundation.Collections.IIterable<string>): this;
		constructor(): this;
		constructor(languages: Windows.Foundation.Collections.IIterable<string>, calendar: string, clock: string, timeZoneId: string): this;
		addDays(days: number): void;
		addEras(eras: number): void;
		addHours(hours: number): void;
		addMinutes(minutes: number): void;
		addMonths(months: number): void;
		addNanoseconds(nanoseconds: number): void;
		addPeriods(periods: number): void;
		addSeconds(seconds: number): void;
		addWeeks(weeks: number): void;
		addYears(years: number): void;
		changeCalendarSystem(value: string): void;
		changeClock(value: string): void;
		changeTimeZone(timeZoneId: string): void;
		clone(): Windows.Globalization.Calendar;
		compare(other: Windows.Globalization.Calendar): number;
		compareDateTime(other: Date): number;
		copyTo(other: Windows.Globalization.Calendar): void;
		day: number;
		dayAsPaddedString(minDigits: number): string;
		dayAsString(): string;
		dayOfWeek: Windows.Globalization.DayOfWeek;
		dayOfWeekAsSoloString(idealLength: number): string;
		dayOfWeekAsSoloString(): string;
		dayOfWeekAsString(idealLength: number): string;
		dayOfWeekAsString(): string;
		era: number;
		eraAsString(idealLength: number): string;
		eraAsString(): string;
		firstDayInThisMonth: number;
		firstEra: number;
		firstHourInThisPeriod: number;
		firstMinuteInThisHour: number;
		firstMonthInThisYear: number;
		firstPeriodInThisDay: number;
		firstSecondInThisMinute: number;
		firstYearInThisEra: number;
		getCalendarSystem(): string;
		getClock(): string;
		getDateTime(): Date;
		getTimeZone(): string;
		hour: number;
		hourAsPaddedString(minDigits: number): string;
		hourAsString(): string;
		isDaylightSavingTime: boolean;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		lastDayInThisMonth: number;
		lastEra: number;
		lastHourInThisPeriod: number;
		lastMinuteInThisHour: number;
		lastMonthInThisYear: number;
		lastPeriodInThisDay: number;
		lastSecondInThisMinute: number;
		lastYearInThisEra: number;
		minute: number;
		minuteAsPaddedString(minDigits: number): string;
		minuteAsString(): string;
		month: number;
		monthAsNumericString(): string;
		monthAsPaddedNumericString(minDigits: number): string;
		monthAsSoloString(idealLength: number): string;
		monthAsSoloString(): string;
		monthAsString(idealLength: number): string;
		monthAsString(): string;
		nanosecond: number;
		nanosecondAsPaddedString(minDigits: number): string;
		nanosecondAsString(): string;
		numberOfDaysInThisMonth: number;
		numberOfEras: number;
		numberOfHoursInThisPeriod: number;
		numberOfMinutesInThisHour: number;
		numberOfMonthsInThisYear: number;
		numberOfPeriodsInThisDay: number;
		numberOfSecondsInThisMinute: number;
		numberOfYearsInThisEra: number;
		numeralSystem: string;
		period: number;
		periodAsString(): string;
		periodAsString(idealLength: number): string;
		resolvedLanguage: string;
		second: number;
		secondAsPaddedString(minDigits: number): string;
		secondAsString(): string;
		setDateTime(value: Date): void;
		setToMax(): void;
		setToMin(): void;
		setToNow(): void;
		timeZoneAsString(): string;
		timeZoneAsString(idealLength: number): string;
		year: number;
		yearAsPaddedString(minDigits: number): string;
		yearAsString(): string;
		yearAsTruncatedString(remainingDigits: number): string
	}

	declare class CalendarIdentifiers  {
		gregorian: string;
		hebrew: string;
		hijri: string;
		japanese: string;
		julian: string;
		korean: string;
		persian: string;
		taiwan: string;
		thai: string;
		umAlQura: string
	}

	declare class ClockIdentifiers  {
		twelveHour: string;
		twentyFourHour: string
	}

	declare class CurrencyIdentifiers  {
		aed: string;
		afn: string;
		all: string;
		amd: string;
		ang: string;
		aoa: string;
		ars: string;
		aud: string;
		awg: string;
		azn: string;
		bam: string;
		bbd: string;
		bdt: string;
		bgn: string;
		bhd: string;
		bif: string;
		bmd: string;
		bnd: string;
		bob: string;
		brl: string;
		bsd: string;
		btn: string;
		bwp: string;
		byr: string;
		bzd: string;
		cad: string;
		cdf: string;
		chf: string;
		clp: string;
		cny: string;
		cop: string;
		crc: string;
		cup: string;
		cve: string;
		czk: string;
		djf: string;
		dkk: string;
		dop: string;
		dzd: string;
		egp: string;
		ern: string;
		etb: string;
		eur: string;
		fjd: string;
		fkp: string;
		gbp: string;
		gel: string;
		ghs: string;
		gip: string;
		gmd: string;
		gnf: string;
		gtq: string;
		gyd: string;
		hkd: string;
		hnl: string;
		hrk: string;
		htg: string;
		huf: string;
		idr: string;
		ils: string;
		inr: string;
		iqd: string;
		irr: string;
		isk: string;
		jmd: string;
		jod: string;
		jpy: string;
		kes: string;
		kgs: string;
		khr: string;
		kmf: string;
		kpw: string;
		krw: string;
		kwd: string;
		kyd: string;
		kzt: string;
		lak: string;
		lbp: string;
		lkr: string;
		lrd: string;
		lsl: string;
		ltl: string;
		lvl: string;
		lyd: string;
		mad: string;
		mdl: string;
		mga: string;
		mkd: string;
		mmk: string;
		mnt: string;
		mop: string;
		mro: string;
		mur: string;
		mvr: string;
		mwk: string;
		mxn: string;
		myr: string;
		mzn: string;
		nad: string;
		ngn: string;
		nio: string;
		nok: string;
		npr: string;
		nzd: string;
		omr: string;
		pab: string;
		pen: string;
		pgk: string;
		php: string;
		pkr: string;
		pln: string;
		pyg: string;
		qar: string;
		ron: string;
		rsd: string;
		rub: string;
		rwf: string;
		sar: string;
		sbd: string;
		scr: string;
		sdg: string;
		sek: string;
		sgd: string;
		shp: string;
		sll: string;
		sos: string;
		srd: string;
		std: string;
		syp: string;
		szl: string;
		thb: string;
		tjs: string;
		tmt: string;
		tnd: string;
		top: string;
		try: string;
		ttd: string;
		twd: string;
		tzs: string;
		uah: string;
		ugx: string;
		usd: string;
		uyu: string;
		uzs: string;
		vef: string;
		vnd: string;
		vuv: string;
		wst: string;
		xaf: string;
		xcd: string;
		xof: string;
		xpf: string;
		xxx: string;
		yer: string;
		zar: string;
		zmw: string;
		zwl: string
	}

	declare class GeographicRegion  {
		isSupported(geographicRegionCode: string): boolean;
		constructor(): this;
		constructor(geographicRegionCode: string): this;
		code: string;
		codeThreeDigit: string;
		codeThreeLetter: string;
		codeTwoLetter: string;
		currenciesInUse: Windows.Foundation.Collections.IVectorView<string>;
		displayName: string;
		nativeName: string
	}

	declare class JapanesePhoneme  {
		displayText: string;
		isPhraseStart: boolean;
		yomiText: string
	}

	declare class JapanesePhoneticAnalyzer  {
		getWords(
		input: string, monoRuby: boolean
	): Windows.Foundation.Collections.IVectorView<Windows.Globalization.JapanesePhoneme>;
		getWords(
		input: string
	): Windows.Foundation.Collections.IVectorView<Windows.Globalization.JapanesePhoneme>
	}

	declare class Language  {
		currentInputMethodLanguageTag: string;
		isWellFormed(languageTag: string): boolean;
		trySetInputMethodLanguageTag(languageTag: string): boolean;
		constructor(languageTag: string): this;
		displayName: string;
		getExtensionSubtags(singleton: string): Windows.Foundation.Collections.IVectorView<string>;
		languageTag: string;
		nativeName: string;
		script: string
	}

	declare class NumeralSystemIdentifiers  {
		arab: string;
		arabExt: string;
		bali: string;
		beng: string;
		brah: string;
		cham: string;
		deva: string;
		fullWide: string;
		gujr: string;
		guru: string;
		haniDec: string;
		java: string;
		kali: string;
		khmr: string;
		knda: string;
		lana: string;
		lanaTham: string;
		laoo: string;
		latn: string;
		lepc: string;
		limb: string;
		mathBold: string;
		mathDbl: string;
		mathMono: string;
		mathSanb: string;
		mathSans: string;
		mlym: string;
		mong: string;
		mtei: string;
		mymr: string;
		mymrShan: string;
		nkoo: string;
		olck: string;
		orya: string;
		osma: string;
		saur: string;
		sund: string;
		talu: string;
		tamlDec: string;
		telu: string;
		thai: string;
		tibt: string;
		vaii: string;
		zmthBold: string;
		zmthDbl: string;
		zmthMono: string;
		zmthSanb: string;
		zmthSans: string
	}

	
}

declare module 'Collation' {
				declare class CharacterGrouping  {
		first: string;
		label: string
	}

	declare class CharacterGroupings extends Array<Windows.Globalization.Collation.CharacterGrouping> {
		constructor(): this;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Globalization.Collation.CharacterGrouping>;
		getAt(index: number): Windows.Globalization.Collation.CharacterGrouping;
		getMany(
		startIndex: number
	): {
		items: Windows.Globalization.Collation.CharacterGrouping,
		returnValue: number
	};
		indexOf(
		value: Windows.Globalization.Collation.CharacterGrouping
	): {
		index: number,
		returnValue: boolean
	};
		lookup(text: string): string;
		size: number;
		indexOf(
		value: Windows.Globalization.Collation.CharacterGrouping, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Globalization.Collation.CharacterGrouping, fromIndex?: number
	): number
	}

	
}

declare module 'DateTimeFormatting' {
				declare class DateTimeFormatter  {
		longDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
		longTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
		shortDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
		shortTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
		constructor(hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat): this;
		constructor(formatTemplate: string): this;
		constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;
		constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string): this;
		constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat): this;
		constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>): this;
		constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>): this;
		calendar: string;
		clock: string;
		format(value: Date): string;
		format(datetime: Date, timeZoneId: string): string;
		geographicRegion: string;
		includeDay: Windows.Globalization.DateTimeFormatting.DayFormat;
		includeDayOfWeek: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat;
		includeHour: Windows.Globalization.DateTimeFormatting.HourFormat;
		includeMinute: Windows.Globalization.DateTimeFormatting.MinuteFormat;
		includeMonth: Windows.Globalization.DateTimeFormatting.MonthFormat;
		includeSecond: Windows.Globalization.DateTimeFormatting.SecondFormat;
		includeYear: Windows.Globalization.DateTimeFormatting.YearFormat;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		numeralSystem: string;
		patterns: Windows.Foundation.Collections.IVectorView<string>;
		resolvedGeographicRegion: string;
		resolvedLanguage: string;
		template: string
	}

	
}

declare module 'Fonts' {
				declare class LanguageFont  {
		fontFamily: string;
		fontStretch: Windows.UI.Text.FontStretch;
		fontStyle: Windows.UI.Text.FontStyle;
		fontWeight: Windows.UI.Text.FontWeight;
		scaleFactor: number
	}

	declare class LanguageFontGroup  {
		constructor(languageTag: string): this;
		documentAlternate1Font: Windows.Globalization.Fonts.LanguageFont;
		documentAlternate2Font: Windows.Globalization.Fonts.LanguageFont;
		documentHeadingFont: Windows.Globalization.Fonts.LanguageFont;
		fixedWidthTextFont: Windows.Globalization.Fonts.LanguageFont;
		modernDocumentFont: Windows.Globalization.Fonts.LanguageFont;
		traditionalDocumentFont: Windows.Globalization.Fonts.LanguageFont;
		uiCaptionFont: Windows.Globalization.Fonts.LanguageFont;
		uiHeadingFont: Windows.Globalization.Fonts.LanguageFont;
		uiNotificationHeadingFont: Windows.Globalization.Fonts.LanguageFont;
		uiTextFont: Windows.Globalization.Fonts.LanguageFont;
		uiTitleFont: Windows.Globalization.Fonts.LanguageFont
	}

	
}

declare module 'NumberFormatting' {
		declare interface INumberRounder {
		roundDouble(value: number): number,
		roundInt32(value: number): number,
		roundInt64(value: number): number,
		roundSingle(value: number): number,
		roundUInt32(value: number): number,
		roundUInt64(value: number): number
	}

		declare class CurrencyFormatter  {
		constructor(currencyCode: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string): this;
		constructor(currencyCode: string): this;
		applyRoundingForCurrency(
		roundingAlgorithm: Windows.Globalization.NumberFormatting.RoundingAlgorithm
	): void;
		currency: string;
		format(value: number): string;
		format(value: number): string;
		format(value: number): string;
		formatDouble(value: number): string;
		formatInt(value: number): string;
		formatUInt(value: number): string;
		fractionDigits: number;
		geographicRegion: string;
		integerDigits: number;
		isDecimalPointAlwaysDisplayed: boolean;
		isGrouped: boolean;
		isZeroSigned: boolean;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		mode: Windows.Globalization.NumberFormatting.CurrencyFormatterMode;
		numberRounder: Windows.Globalization.NumberFormatting.INumberRounder;
		numeralSystem: string;
		parseDouble(text: string): number;
		parseInt(text: string): number;
		parseUInt(text: string): number;
		resolvedGeographicRegion: string;
		resolvedLanguage: string;
		significantDigits: number
	}

	declare class DecimalFormatter  {
		constructor(): this;
		constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string): this;
		format(value: number): string;
		format(value: number): string;
		format(value: number): string;
		formatDouble(value: number): string;
		formatInt(value: number): string;
		formatUInt(value: number): string;
		fractionDigits: number;
		geographicRegion: string;
		integerDigits: number;
		isDecimalPointAlwaysDisplayed: boolean;
		isGrouped: boolean;
		isZeroSigned: boolean;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		numberRounder: Windows.Globalization.NumberFormatting.INumberRounder;
		numeralSystem: string;
		parseDouble(text: string): number;
		parseInt(text: string): number;
		parseUInt(text: string): number;
		resolvedGeographicRegion: string;
		resolvedLanguage: string;
		significantDigits: number
	}

	declare class IncrementNumberRounder  {
		constructor(): this;
		increment: number;
		roundDouble(value: number): number;
		roundInt32(value: number): number;
		roundInt64(value: number): number;
		roundSingle(value: number): number;
		roundUInt32(value: number): number;
		roundUInt64(value: number): number;
		roundingAlgorithm: Windows.Globalization.NumberFormatting.RoundingAlgorithm
	}

	declare class NumeralSystemTranslator  {
		constructor(languages: Windows.Foundation.Collections.IIterable<string>): this;
		constructor(): this;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		numeralSystem: string;
		resolvedLanguage: string;
		translateNumerals(value: string): string
	}

	declare class PercentFormatter  {
		constructor(): this;
		constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string): this;
		format(value: number): string;
		format(value: number): string;
		format(value: number): string;
		formatDouble(value: number): string;
		formatInt(value: number): string;
		formatUInt(value: number): string;
		fractionDigits: number;
		geographicRegion: string;
		integerDigits: number;
		isDecimalPointAlwaysDisplayed: boolean;
		isGrouped: boolean;
		isZeroSigned: boolean;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		numberRounder: Windows.Globalization.NumberFormatting.INumberRounder;
		numeralSystem: string;
		parseDouble(text: string): number;
		parseInt(text: string): number;
		parseUInt(text: string): number;
		resolvedGeographicRegion: string;
		resolvedLanguage: string;
		significantDigits: number
	}

	declare class PermilleFormatter  {
		constructor(): this;
		constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string): this;
		format(value: number): string;
		format(value: number): string;
		format(value: number): string;
		formatDouble(value: number): string;
		formatInt(value: number): string;
		formatUInt(value: number): string;
		fractionDigits: number;
		geographicRegion: string;
		integerDigits: number;
		isDecimalPointAlwaysDisplayed: boolean;
		isGrouped: boolean;
		isZeroSigned: boolean;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		numberRounder: Windows.Globalization.NumberFormatting.INumberRounder;
		numeralSystem: string;
		parseDouble(text: string): number;
		parseInt(text: string): number;
		parseUInt(text: string): number;
		resolvedGeographicRegion: string;
		resolvedLanguage: string;
		significantDigits: number
	}

	declare class SignificantDigitsNumberRounder  {
		constructor(): this;
		roundDouble(value: number): number;
		roundInt32(value: number): number;
		roundInt64(value: number): number;
		roundSingle(value: number): number;
		roundUInt32(value: number): number;
		roundUInt64(value: number): number;
		roundingAlgorithm: Windows.Globalization.NumberFormatting.RoundingAlgorithm;
		significantDigits: number
	}

	
}

declare module 'Direct3D11' {
		declare interface IDirect3DSurface {
		description: Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription
	}

	declare interface Direct3DSurfaceDescription {
		format: Windows.Graphics.DirectX.DirectXPixelFormat,
		height: number,
		multisampleDescription: Windows.Graphics.DirectX.Direct3D11.Direct3DMultisampleDescription,
		width: number
	}

	declare interface Direct3DMultisampleDescription {
		count: number,
		quality: number
	}

			
}

declare module 'Display' {
	declare type DisplayPropertiesEventHandler = (ev: WinRTEvent<any>) => void;

			declare class DisplayInformation  {
		autoRotationPreferences: Windows.Graphics.Display.DisplayOrientations;
		getForCurrentView(): Windows.Graphics.Display.DisplayInformation;
		ondisplaycontentsinvalidated: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>;
		addEventListener(
		type: "displaycontentsinvalidated", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		removeEventListener(
		type: "displaycontentsinvalidated", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		currentOrientation: Windows.Graphics.Display.DisplayOrientations;
		diagonalSizeInInches: number;
		getColorProfileAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		logicalDpi: number;
		nativeOrientation: Windows.Graphics.Display.DisplayOrientations;
		oncolorprofilechanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>;
		addEventListener(
		type: "colorprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		removeEventListener(
		type: "colorprofilechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		ondpichanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>;
		addEventListener(
		type: "dpichanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		removeEventListener(
		type: "dpichanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		onorientationchanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>;
		addEventListener(
		type: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		removeEventListener(
		type: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		onstereoenabledchanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>;
		addEventListener(
		type: "stereoenabledchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		removeEventListener(
		type: "stereoenabledchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Display.DisplayInformation, any>
	): void;
		rawDpiX: number;
		rawDpiY: number;
		rawPixelsPerViewPixel: number;
		resolutionScale: Windows.Graphics.Display.ResolutionScale;
		stereoEnabled: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DisplayProperties  {
		autoRotationPreferences: Windows.Graphics.Display.DisplayOrientations;
		currentOrientation: Windows.Graphics.Display.DisplayOrientations;
		getColorProfileAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		logicalDpi: number;
		nativeOrientation: Windows.Graphics.Display.DisplayOrientations;
		oncolorprofilechanged: Windows.Graphics.Display.DisplayPropertiesEventHandler;
		addEventListener(
		type: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		removeEventListener(
		type: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		ondisplaycontentsinvalidated: Windows.Graphics.Display.DisplayPropertiesEventHandler;
		addEventListener(
		type: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		removeEventListener(
		type: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		onlogicaldpichanged: Windows.Graphics.Display.DisplayPropertiesEventHandler;
		addEventListener(
		type: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		removeEventListener(
		type: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		onorientationchanged: Windows.Graphics.Display.DisplayPropertiesEventHandler;
		addEventListener(
		type: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		removeEventListener(
		type: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		onstereoenabledchanged: Windows.Graphics.Display.DisplayPropertiesEventHandler;
		addEventListener(
		type: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		removeEventListener(
		type: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler
	): void;
		resolutionScale: Windows.Graphics.Display.ResolutionScale;
		stereoEnabled: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DisplayRequest  {
		constructor(): this;
		requestActive(): void;
		requestRelease(): void
	}

	
}

declare module 'Holographic' {
				declare class HolographicCamera  {
		id: any;
		isStereo: any;
		renderTargetSize: any;
		setFarPlaneDistance: any;
		setNearPlaneDistance: any;
		viewportScaleFactor: any
	}

	declare class HolographicCameraPose  {
		farPlaneDistance: any;
		holographicCamera: any;
		nearPlaneDistance: any;
		projectionTransform: any;
		tryGetCullingFrustum: any;
		tryGetViewTransform: any;
		tryGetVisibleFrustum: any;
		viewport: any
	}

	declare class HolographicCameraRenderingParameters  {
		direct3D11BackBuffer: any;
		direct3D11Device: any;
		setFocusPoint: any
	}

	declare class HolographicFrame  {
		addedCameras: any;
		currentPrediction: any;
		duration: any;
		getRenderingParameters: any;
		presentUsingCurrentPrediction: any;
		removedCameras: any;
		updateCurrentPrediction: any;
		waitForFrameToFinish: any
	}

	declare class HolographicFramePrediction  {
		cameraPoses: any;
		timestamp: any
	}

	declare class HolographicSpace  {
		createForCoreWindow: any;
		addEventListener: any;
		createNextFrame: any;
		oncameraadded: any;
		oncameraremoved: any;
		primaryAdapterId: any;
		removeEventListener: any;
		setDirect3D11Device: any
	}

	declare class HolographicSpaceCameraAddedEventArgs  {
		camera: any;
		getDeferral: any
	}

	declare class HolographicSpaceCameraRemovedEventArgs  {
		camera: any
	}

	
}

declare module 'Imaging' {
		declare interface BitmapPlaneDescription {
		height: number,
		startIndex: number,
		stride: number,
		width: number
	}

	declare interface BitmapBounds {
		height: number,
		width: number,
		x: number,
		y: number
	}

	declare interface BitmapSize {
		height: number,
		width: number
	}

		declare class BitmapBuffer  {
		close(): void;
		createReference(): Windows.Foundation.IMemoryBufferReference;
		getPlaneCount(): number;
		getPlaneDescription(index: number): Windows.Graphics.Imaging.BitmapPlaneDescription
	}

	declare class BitmapCodecInformation  {
		codecId: string;
		fileExtensions: Windows.Foundation.Collections.IVectorView<string>;
		friendlyName: string;
		mimeTypes: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class BitmapDecoder  {
		bmpDecoderId: string;
		createAsync(
		stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
		createAsync(
		decoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
		getDecoderInformationEnumerator(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
		gifDecoderId: string;
		icoDecoderId: string;
		jpegDecoderId: string;
		jpegXRDecoderId: string;
		pngDecoderId: string;
		tiffDecoderId: string;
		bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
		bitmapContainerProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
		bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
		bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
		decoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
		dpiX: number;
		dpiY: number;
		frameCount: number;
		getFrameAsync(
		frameIndex: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapFrame>;
		getPixelDataAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
		getPixelDataAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
		getPreviewAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
		getSoftwareBitmapAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getSoftwareBitmapAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getSoftwareBitmapAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getThumbnailAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
		orientedPixelHeight: number;
		orientedPixelWidth: number;
		pixelHeight: number;
		pixelWidth: number
	}

	declare class BitmapEncoder  {
		bmpEncoderId: string;
		createAsync(
		encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream, encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
		createAsync(
		encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
		createForInPlacePropertyEncodingAsync(
		bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
		createForTranscodingAsync(
		stream: Windows.Storage.Streams.IRandomAccessStream, bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
		getEncoderInformationEnumerator(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
		gifEncoderId: string;
		jpegEncoderId: string;
		jpegXREncoderId: string;
		pngEncoderId: string;
		tiffEncoderId: string;
		bitmapContainerProperties: Windows.Graphics.Imaging.BitmapProperties;
		bitmapProperties: Windows.Graphics.Imaging.BitmapProperties;
		bitmapTransform: Windows.Graphics.Imaging.BitmapTransform;
		encoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		generatedThumbnailHeight: number;
		generatedThumbnailWidth: number;
		goToNextFrameAsync(
		encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		goToNextFrameAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		isThumbnailGenerated: boolean;
		setPixelData(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, width: number, height: number, dpiX: number, dpiY: number, pixels: number[]
	): void;
		setSoftwareBitmap(bitmap: Windows.Graphics.Imaging.SoftwareBitmap): void
	}

	declare class BitmapFrame  {
		bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
		bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
		bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
		dpiX: number;
		dpiY: number;
		getPixelDataAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
		getPixelDataAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
		getSoftwareBitmapAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getSoftwareBitmapAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getSoftwareBitmapAsync(
		pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		getThumbnailAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
		orientedPixelHeight: number;
		orientedPixelWidth: number;
		pixelHeight: number;
		pixelWidth: number
	}

	declare class BitmapProperties  {
		getPropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
		setPropertiesAsync(
		propertiesToSet: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class BitmapPropertiesView  {
		getPropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>
	}

	declare class BitmapPropertySet  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(
		
	): Windows.Foundation.Collections.IMapView<string, Windows.Graphics.Imaging.BitmapTypedValue>;
		hasKey(key: string): boolean;
		insert(key: string, value: Windows.Graphics.Imaging.BitmapTypedValue): boolean;
		lookup(key: string): Windows.Graphics.Imaging.BitmapTypedValue;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number
	}

	declare class BitmapTransform  {
		constructor(): this;
		bounds: Windows.Graphics.Imaging.BitmapBounds;
		flip: Windows.Graphics.Imaging.BitmapFlip;
		interpolationMode: Windows.Graphics.Imaging.BitmapInterpolationMode;
		rotation: Windows.Graphics.Imaging.BitmapRotation;
		scaledHeight: number;
		scaledWidth: number
	}

	declare class BitmapTypedValue  {
		constructor(value: any, type: Windows.Foundation.PropertyType): this;
		type: Windows.Foundation.PropertyType;
		value: any
	}

	declare class ImageStream  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		contentType: string;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class PixelDataProvider  {
		detachPixelData(): number[]
	}

	declare class SoftwareBitmap  {
		convert(
		source: Windows.Graphics.Imaging.SoftwareBitmap, format: Windows.Graphics.Imaging.BitmapPixelFormat, alpha: Windows.Graphics.Imaging.BitmapAlphaMode
	): Windows.Graphics.Imaging.SoftwareBitmap;
		convert(
		source: Windows.Graphics.Imaging.SoftwareBitmap, format: Windows.Graphics.Imaging.BitmapPixelFormat
	): Windows.Graphics.Imaging.SoftwareBitmap;
		copy(
		source: Windows.Graphics.Imaging.SoftwareBitmap
	): Windows.Graphics.Imaging.SoftwareBitmap;
		createCopyFromBuffer(
		source: Windows.Storage.Streams.IBuffer, format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number
	): Windows.Graphics.Imaging.SoftwareBitmap;
		createCopyFromBuffer(
		source: Windows.Storage.Streams.IBuffer, format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number, alpha: Windows.Graphics.Imaging.BitmapAlphaMode
	): Windows.Graphics.Imaging.SoftwareBitmap;
		createCopyFromSurfaceAsync(
		surface: Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		createCopyFromSurfaceAsync(
		surface: Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface, alpha: Windows.Graphics.Imaging.BitmapAlphaMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.SoftwareBitmap>;
		constructor(format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number, alpha: Windows.Graphics.Imaging.BitmapAlphaMode): this;
		constructor(format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number): this;
		bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
		bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
		close(): void;
		copyFromBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
		copyTo(bitmap: Windows.Graphics.Imaging.SoftwareBitmap): void;
		copyToBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
		dpiX: number;
		dpiY: number;
		getReadOnlyView(): Windows.Graphics.Imaging.SoftwareBitmap;
		isReadOnly: boolean;
		lockBuffer(
		mode: Windows.Graphics.Imaging.BitmapBufferAccessMode
	): Windows.Graphics.Imaging.BitmapBuffer;
		pixelHeight: number;
		pixelWidth: number
	}

	
}

declare module 'OptionDetails' {
		declare interface IPrintOptionDetails {
		trySetValue(value: any): boolean,
		errorText: string,
		optionId: string,
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType,
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates,
		value: any
	}

		declare class PrintBindingOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintCollationOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintColorModeOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintCopiesOptionDetails  {
		errorText: string;
		maxValue: number;
		minValue: number;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintCustomItemDetails  {
		itemDisplayName: string;
		itemId: string
	}

	declare class PrintCustomItemListOptionDetails  {
		addItem(itemId: string, displayName: string): void;
		displayName: string;
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintCustomTextOptionDetails  {
		displayName: string;
		errorText: string;
		maxCharacters: number;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintDuplexOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintHolePunchOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintMediaSizeOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintMediaTypeOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintOrientationOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintQualityOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintStapleOptionDetails  {
		errorText: string;
		items: Windows.Foundation.Collections.IVectorView<any>;
		optionId: string;
		optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
		state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
		trySetValue(value: any): boolean;
		value: any
	}

	declare class PrintTaskOptionChangedEventArgs  {
		optionId: any
	}

	declare class PrintTaskOptionDetails  {
		getFromPrintTaskOptions(
		printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions
	): Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails;
		createItemListOption(
		optionId: string, displayName: string
	): Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
		createTextOption(
		optionId: string, displayName: string
	): Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
		displayedOptions: Windows.Foundation.Collections.IVector<string>;
		getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
		onbeginvalidation: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, any>;
		addEventListener(
		type: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, any>
	): void;
		removeEventListener(
		type: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, any>
	): void;
		onoptionchanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>;
		addEventListener(
		type: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>
	): void;
		removeEventListener(
		type: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails, Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>
	): void;
		options: Windows.Foundation.Collections.IMapView<string, Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Printing' {
	declare type PrintTaskSourceRequestedHandler = (args: Windows.Graphics.Printing.PrintTaskSourceRequestedArgs) => void;

	declare interface PrintPageDescription {
		dpiX: number,
		dpiY: number,
		imageableRect: Windows.Foundation.Rect,
		pageSize: Windows.Foundation.Size
	}

	declare interface IPrintDocumentSource {
		
	}

		declare class PrintManager  {
		getForCurrentView(): Windows.Graphics.Printing.PrintManager;
		showPrintUIAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		onprinttaskrequested: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager, Windows.Graphics.Printing.PrintTaskRequestedEventArgs>;
		addEventListener(
		type: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager, Windows.Graphics.Printing.PrintTaskRequestedEventArgs>
	): void;
		removeEventListener(
		type: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager, Windows.Graphics.Printing.PrintTaskRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PrintTask  {
		is3DManufacturingTargetEnabled: boolean;
		isPrinterTargetEnabled: boolean;
		oncompleted: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskCompletedEventArgs>;
		addEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskCompletedEventArgs>
	): void;
		removeEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskCompletedEventArgs>
	): void;
		onpreviewing: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>;
		addEventListener(
		type: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>
	): void;
		removeEventListener(
		type: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>
	): void;
		onprogressing: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskProgressingEventArgs>;
		addEventListener(
		type: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskProgressingEventArgs>
	): void;
		removeEventListener(
		type: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, Windows.Graphics.Printing.PrintTaskProgressingEventArgs>
	): void;
		onsubmitting: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>;
		addEventListener(
		type: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>
	): void;
		removeEventListener(
		type: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask, any>
	): void;
		options: Windows.Graphics.Printing.PrintTaskOptions;
		properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
		source: Windows.Graphics.Printing.IPrintDocumentSource;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PrintTaskCompletedEventArgs  {
		completion: Windows.Graphics.Printing.PrintTaskCompletion
	}

	declare class PrintTaskOptions  {
		binding: Windows.Graphics.Printing.PrintBinding;
		collation: Windows.Graphics.Printing.PrintCollation;
		colorMode: Windows.Graphics.Printing.PrintColorMode;
		displayedOptions: Windows.Foundation.Collections.IVector<string>;
		duplex: Windows.Graphics.Printing.PrintDuplex;
		getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
		holePunch: Windows.Graphics.Printing.PrintHolePunch;
		maxCopies: number;
		mediaSize: Windows.Graphics.Printing.PrintMediaSize;
		mediaType: Windows.Graphics.Printing.PrintMediaType;
		minCopies: number;
		numberOfCopies: number;
		orientation: Windows.Graphics.Printing.PrintOrientation;
		printQuality: Windows.Graphics.Printing.PrintQuality;
		staple: Windows.Graphics.Printing.PrintStaple
	}

	declare class PrintTaskProgressingEventArgs  {
		documentPageCount: number
	}

	declare class PrintTaskRequest  {
		createPrintTask(
		title: string, handler: Windows.Graphics.Printing.PrintTaskSourceRequestedHandler
	): Windows.Graphics.Printing.PrintTask;
		deadline: Date;
		getDeferral(): Windows.Graphics.Printing.PrintTaskRequestedDeferral
	}

	declare class PrintTaskRequestedDeferral  {
		complete(): void
	}

	declare class PrintTaskRequestedEventArgs  {
		request: Windows.Graphics.Printing.PrintTaskRequest
	}

	declare class PrintTaskSourceRequestedArgs  {
		deadline: Date;
		getDeferral(): Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral;
		setSource(source: Windows.Graphics.Printing.IPrintDocumentSource): void
	}

	declare class PrintTaskSourceRequestedDeferral  {
		complete(): void
	}

	declare class StandardPrintTaskOptions  {
		binding: string;
		collation: string;
		colorMode: string;
		copies: string;
		duplex: string;
		holePunch: string;
		inputBin: string;
		mediaSize: string;
		mediaType: string;
		nup: string;
		orientation: string;
		printQuality: string;
		staple: string
	}

	
}

declare module 'Printing3D' {
	declare type Print3DTaskSourceRequestedHandler = (args: Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs) => void;

	declare interface Printing3DBufferDescription {
		format: Windows.Graphics.Printing3D.Printing3DBufferFormat,
		stride: number
	}

		declare class Print3DManager  {
		getForCurrentView(): Windows.Graphics.Printing3D.Print3DManager;
		showPrintUIAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		ontaskrequested: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DManager, Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs>;
		addEventListener(
		type: "taskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DManager, Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs>
	): void;
		removeEventListener(
		type: "taskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DManager, Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class Print3DTask  {
		oncompleted: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs>;
		addEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs>
	): void;
		removeEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs>
	): void;
		onsourcechanged: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs>;
		addEventListener(
		type: "sourcechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs>
	): void;
		removeEventListener(
		type: "sourcechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs>
	): void;
		onsubmitting: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, any>;
		addEventListener(
		type: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, any>
	): void;
		removeEventListener(
		type: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing3D.Print3DTask, any>
	): void;
		source: Windows.Graphics.Printing3D.Printing3D3MFPackage;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class Print3DTaskCompletedEventArgs  {
		completion: Windows.Graphics.Printing3D.Print3DTaskCompletion;
		extendedStatus: Windows.Graphics.Printing3D.Print3DTaskDetail
	}

	declare class Print3DTaskRequest  {
		createTask(
		title: string, printerId: string, handler: Windows.Graphics.Printing3D.Print3DTaskSourceRequestedHandler
	): Windows.Graphics.Printing3D.Print3DTask
	}

	declare class Print3DTaskRequestedEventArgs  {
		request: Windows.Graphics.Printing3D.Print3DTaskRequest
	}

	declare class Print3DTaskSourceChangedEventArgs  {
		source: Windows.Graphics.Printing3D.Printing3D3MFPackage
	}

	declare class Print3DTaskSourceRequestedArgs  {
		setSource(source: Windows.Graphics.Printing3D.Printing3D3MFPackage): void
	}

	declare class Printing3D3MFPackage  {
		loadAsync(
		value: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Printing3D.Printing3D3MFPackage>;
		constructor(): this;
		loadModelFromPackageAsync(
		value: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Printing3D.Printing3DModel>;
		modelPart: Windows.Storage.Streams.IRandomAccessStream;
		printTicket: Windows.Storage.Streams.IRandomAccessStream;
		saveAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		saveModelToPackageAsync(
		value: Windows.Graphics.Printing3D.Printing3DModel
	): Windows.Foundation.IPromiseWithIAsyncAction;
		textures: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DTextureResource>;
		thumbnail: Windows.Graphics.Printing3D.Printing3DTextureResource
	}

	declare class Printing3DBaseMaterial  {
		abs: string;
		pla: string;
		constructor(): this;
		color: Windows.Graphics.Printing3D.Printing3DColorMaterial;
		name: string
	}

	declare class Printing3DBaseMaterialGroup  {
		constructor(MaterialGroupId: number): this;
		bases: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DBaseMaterial>;
		materialGroupId: number
	}

	declare class Printing3DColorMaterial  {
		constructor(): this;
		color: Windows.UI.Color;
		value: number
	}

	declare class Printing3DColorMaterialGroup  {
		constructor(MaterialGroupId: number): this;
		colors: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DColorMaterial>;
		materialGroupId: number
	}

	declare class Printing3DComponent  {
		constructor(): this;
		components: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DComponentWithMatrix>;
		mesh: Windows.Graphics.Printing3D.Printing3DMesh;
		name: string;
		partNumber: string;
		thumbnail: Windows.Graphics.Printing3D.Printing3DTextureResource;
		type: Windows.Graphics.Printing3D.Printing3DObjectType
	}

	declare class Printing3DComponentWithMatrix  {
		constructor(): this;
		component: Windows.Graphics.Printing3D.Printing3DComponent;
		matrix: Windows.Foundation.Numerics.Matrix4x4
	}

	declare class Printing3DCompositeMaterial  {
		constructor(): this;
		values: Windows.Foundation.Collections.IVector<number>
	}

	declare class Printing3DCompositeMaterialGroup  {
		constructor(MaterialGroupId: number): this;
		composites: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DCompositeMaterial>;
		materialGroupId: number;
		materialIndices: Windows.Foundation.Collections.IVector<number>
	}

	declare class Printing3DMaterial  {
		constructor(): this;
		baseGroups: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup>;
		colorGroups: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DColorMaterialGroup>;
		compositeGroups: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup>;
		multiplePropertyGroups: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup>;
		texture2CoordGroups: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup>
	}

	declare class Printing3DMesh  {
		constructor(): this;
		bufferDescriptionSet: Windows.Foundation.Collections.IPropertySet;
		bufferSet: Windows.Foundation.Collections.IPropertySet;
		createTriangleIndices(value: number): void;
		createTriangleMaterialIndices(value: number): void;
		createVertexNormals(value: number): void;
		createVertexPositions(value: number): void;
		getTriangleIndices(): Windows.Storage.Streams.IBuffer;
		getTriangleMaterialIndices(): Windows.Storage.Streams.IBuffer;
		getVertexNormals(): Windows.Storage.Streams.IBuffer;
		getVertexPositions(): Windows.Storage.Streams.IBuffer;
		indexCount: number;
		triangleIndicesDescription: Windows.Graphics.Printing3D.Printing3DBufferDescription;
		triangleMaterialIndicesDescription: Windows.Graphics.Printing3D.Printing3DBufferDescription;
		verifyAsync(
		value: Windows.Graphics.Printing3D.Printing3DMeshVerificationMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Printing3D.Printing3DMeshVerificationResult>;
		vertexCount: number;
		vertexNormalsDescription: Windows.Graphics.Printing3D.Printing3DBufferDescription;
		vertexPositionsDescription: Windows.Graphics.Printing3D.Printing3DBufferDescription
	}

	declare class Printing3DMeshVerificationResult  {
		isValid: boolean;
		nonmanifoldTriangles: Windows.Foundation.Collections.IVectorView<number>;
		reversedNormalTriangles: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class Printing3DModel  {
		constructor(): this;
		build: Windows.Graphics.Printing3D.Printing3DComponent;
		clone(): Windows.Graphics.Printing3D.Printing3DModel;
		components: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DComponent>;
		material: Windows.Graphics.Printing3D.Printing3DMaterial;
		meshes: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DMesh>;
		metadata: Windows.Foundation.Collections.IMap<string, string>;
		repairAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		requiredExtensions: Windows.Foundation.Collections.IVector<string>;
		textures: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DModelTexture>;
		unit: Windows.Graphics.Printing3D.Printing3DModelUnit;
		version: string
	}

	declare class Printing3DModelTexture  {
		constructor(): this;
		textureResource: Windows.Graphics.Printing3D.Printing3DTextureResource;
		tileStyleU: Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior;
		tileStyleV: Windows.Graphics.Printing3D.Printing3DTextureEdgeBehavior
	}

	declare class Printing3DMultiplePropertyMaterial  {
		constructor(): this;
		materialIndices: Windows.Foundation.Collections.IVector<number>
	}

	declare class Printing3DMultiplePropertyMaterialGroup  {
		constructor(MaterialGroupId: number): this;
		materialGroupId: number;
		materialGroupIndices: Windows.Foundation.Collections.IVector<number>;
		multipleProperties: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial>
	}

	declare class Printing3DTexture2CoordMaterial  {
		constructor(): this;
		texture: Windows.Graphics.Printing3D.Printing3DModelTexture;
		u: number;
		v: number
	}

	declare class Printing3DTexture2CoordMaterialGroup  {
		constructor(MaterialGroupId: number): this;
		materialGroupId: number;
		texture: Windows.Graphics.Printing3D.Printing3DModelTexture;
		texture2Coords: Windows.Foundation.Collections.IVector<Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial>
	}

	declare class Printing3DTextureResource  {
		constructor(): this;
		name: string;
		textureData: Windows.Storage.Streams.IRandomAccessStreamWithContentType
	}

	
}

declare module 'Deployment' {
				declare class DeploymentResult  {
		activityId: string;
		errorText: string;
		extendedErrorCode: WinRTError
	}

	declare class PackageUserInformation  {
		installState: Windows.Management.Deployment.PackageInstallState;
		userSecurityId: string
	}

	declare class PackageVolume  {
		constructor(): this;
		findPackage(
		packageFullName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackageForUser(
		userSecurityId: string, packageFullName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackages(): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackages(
		packageName: string, packagePublisher: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackages(
		packageFamilyName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUser(
		userSecurityId: string, packageFamilyName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUser(
		userSecurityId: string, packageName: string, packagePublisher: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUser(
		userSecurityId: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUserWithPackageTypes(
		userSecurityId: string, packageTypes: Windows.Management.Deployment.PackageTypes
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUserWithPackageTypes(
		userSecurityId: string, packageTypes: Windows.Management.Deployment.PackageTypes, packageName: string, packagePublisher: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesForUserWithPackageTypes(
		userSecurityId: string, packageTypes: Windows.Management.Deployment.PackageTypes, packageFamilyName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesWithPackageTypes(
		packageTypes: Windows.Management.Deployment.PackageTypes, packageFamilyName: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesWithPackageTypes(
		packageTypes: Windows.Management.Deployment.PackageTypes
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		findPackagesWithPackageTypes(
		packageTypes: Windows.Management.Deployment.PackageTypes, packageName: string, packagePublisher: string
	): Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Package>;
		isOffline: boolean;
		isSystemVolume: boolean;
		mountPoint: string;
		name: string;
		packageStorePath: string;
		supportsHardLinks: boolean
	}

	
}

declare module 'Orchestration' {
				declare class CurrentAppOrchestration  {
		getForCurrentView: any;
		startSingleAppMode: any
	}

	declare class SingleAppModeContext  {
		close: any
	}

	
}

declare module 'Workplace' {
				declare class MdmPolicy  {
		isBrowserAllowed(): boolean;
		isCameraAllowed(): boolean;
		isMicrosoftAccountAllowed(): boolean;
		isStoreAllowed(): boolean
	}

	declare class WorkplaceSettings  {
		isMicrosoftAccountOptional: boolean
	}

	
}

declare module 'Audio' {
		declare interface IAudioNode {
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void,
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void,
		reset(): void,
		start(): void,
		stop(): void,
		consumeInput: boolean,
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>,
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties,
		outgoingGain: number
	}

		declare class AudioDeviceInputNode  {
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode, gain: number): void;
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		close(): void;
		consumeInput: boolean;
		device: Windows.Devices.Enumeration.DeviceInformation;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		outgoingConnections: Windows.Foundation.Collections.IVectorView<Windows.Media.Audio.AudioGraphConnection>;
		outgoingGain: number;
		removeOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		reset(): void;
		start(): void;
		stop(): void
	}

	declare class AudioDeviceOutputNode  {
		close(): void;
		consumeInput: boolean;
		device: Windows.Devices.Enumeration.DeviceInformation;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		outgoingGain: number;
		reset(): void;
		start(): void;
		stop(): void
	}

	declare class AudioFileInputNode  {
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode, gain: number): void;
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		close(): void;
		consumeInput: boolean;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		duration: number;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		endTime: number;
		loopCount: number;
		onfilecompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFileInputNode, any>;
		addEventListener(
		type: "filecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFileInputNode, any>
	): void;
		removeEventListener(
		type: "filecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFileInputNode, any>
	): void;
		outgoingConnections: Windows.Foundation.Collections.IVectorView<Windows.Media.Audio.AudioGraphConnection>;
		outgoingGain: number;
		playbackSpeedFactor: number;
		position: number;
		removeOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		reset(): void;
		seek(position: number): void;
		sourceFile: Windows.Storage.StorageFile;
		start(): void;
		startTime: number;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AudioFileOutputNode  {
		close(): void;
		consumeInput: boolean;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		file: Windows.Storage.IStorageFile;
		fileEncodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile;
		finalizeAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Transcoding.TranscodeFailureReason>;
		outgoingGain: number;
		reset(): void;
		start(): void;
		stop(): void
	}

	declare class AudioFrameCompletedEventArgs  {
		frame: Windows.Media.AudioFrame
	}

	declare class AudioFrameInputNode  {
		addFrame(frame: Windows.Media.AudioFrame): void;
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode, gain: number): void;
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		close(): void;
		consumeInput: boolean;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		discardQueuedFrames(): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		onaudioframecompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.AudioFrameCompletedEventArgs>;
		addEventListener(
		type: "audioframecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.AudioFrameCompletedEventArgs>
	): void;
		removeEventListener(
		type: "audioframecompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.AudioFrameCompletedEventArgs>
	): void;
		onquantumstarted: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs>;
		addEventListener(
		type: "quantumstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs>
	): void;
		removeEventListener(
		type: "quantumstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioFrameInputNode, Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs>
	): void;
		outgoingConnections: Windows.Foundation.Collections.IVectorView<Windows.Media.Audio.AudioGraphConnection>;
		outgoingGain: number;
		playbackSpeedFactor: number;
		queuedSampleCount: number;
		removeOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		reset(): void;
		start(): void;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AudioFrameOutputNode  {
		close(): void;
		consumeInput: boolean;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		getFrame(): Windows.Media.AudioFrame;
		outgoingGain: number;
		reset(): void;
		start(): void;
		stop(): void
	}

	declare class AudioGraph  {
		createAsync(
		settings: Windows.Media.Audio.AudioGraphSettings
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioGraphResult>;
		close(): void;
		completedQuantumCount: number;
		createDeviceInputNodeAsync(
		category: Windows.Media.Capture.MediaCategory, encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioDeviceInputNodeResult>;
		createDeviceInputNodeAsync(
		category: Windows.Media.Capture.MediaCategory
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioDeviceInputNodeResult>;
		createDeviceInputNodeAsync(
		category: Windows.Media.Capture.MediaCategory, encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties, device: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioDeviceInputNodeResult>;
		createDeviceOutputNodeAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioDeviceOutputNodeResult>;
		createFileInputNodeAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioFileInputNodeResult>;
		createFileOutputNodeAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioFileOutputNodeResult>;
		createFileOutputNodeAsync(
		file: Windows.Storage.IStorageFile, fileEncodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Audio.CreateAudioFileOutputNodeResult>;
		createFrameInputNode(
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties
	): Windows.Media.Audio.AudioFrameInputNode;
		createFrameInputNode(): Windows.Media.Audio.AudioFrameInputNode;
		createFrameOutputNode(
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties
	): Windows.Media.Audio.AudioFrameOutputNode;
		createFrameOutputNode(): Windows.Media.Audio.AudioFrameOutputNode;
		createSubmixNode(): Windows.Media.Audio.AudioSubmixNode;
		createSubmixNode(
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties
	): Windows.Media.Audio.AudioSubmixNode;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		latencyInSamples: number;
		onquantumprocessed: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>;
		addEventListener(
		type: "quantumprocessed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>
	): void;
		removeEventListener(
		type: "quantumprocessed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>
	): void;
		onquantumstarted: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>;
		addEventListener(
		type: "quantumstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>
	): void;
		removeEventListener(
		type: "quantumstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, any>
	): void;
		onunrecoverableerroroccurred: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs>;
		addEventListener(
		type: "unrecoverableerroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs>
	): void;
		removeEventListener(
		type: "unrecoverableerroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Audio.AudioGraph, Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs>
	): void;
		primaryRenderDevice: Windows.Devices.Enumeration.DeviceInformation;
		renderDeviceAudioProcessing: Windows.Media.AudioProcessing;
		resetAllNodes(): void;
		samplesPerQuantum: number;
		start(): void;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AudioGraphConnection  {
		destination: Windows.Media.Audio.IAudioNode;
		gain: number
	}

	declare class AudioGraphSettings  {
		constructor(audioRenderCategory: Windows.Media.Render.AudioRenderCategory): this;
		audioRenderCategory: Windows.Media.Render.AudioRenderCategory;
		desiredRenderDeviceAudioProcessing: Windows.Media.AudioProcessing;
		desiredSamplesPerQuantum: number;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		primaryRenderDevice: Windows.Devices.Enumeration.DeviceInformation;
		quantumSizeSelectionMode: Windows.Media.Audio.QuantumSizeSelectionMode
	}

	declare class AudioGraphUnrecoverableErrorOccurredEventArgs  {
		error: Windows.Media.Audio.AudioGraphUnrecoverableError
	}

	declare class AudioSubmixNode  {
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode, gain: number): void;
		addOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		close(): void;
		consumeInput: boolean;
		disableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		effectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		enableEffectsByDefinition(definition: Windows.Media.Effects.IAudioEffectDefinition): void;
		encodingProperties: Windows.Media.MediaProperties.AudioEncodingProperties;
		outgoingConnections: Windows.Foundation.Collections.IVectorView<Windows.Media.Audio.AudioGraphConnection>;
		outgoingGain: number;
		removeOutgoingConnection(destination: Windows.Media.Audio.IAudioNode): void;
		reset(): void;
		start(): void;
		stop(): void
	}

	declare class CreateAudioDeviceInputNodeResult  {
		deviceInputNode: Windows.Media.Audio.AudioDeviceInputNode;
		status: Windows.Media.Audio.AudioDeviceNodeCreationStatus
	}

	declare class CreateAudioDeviceOutputNodeResult  {
		deviceOutputNode: Windows.Media.Audio.AudioDeviceOutputNode;
		status: Windows.Media.Audio.AudioDeviceNodeCreationStatus
	}

	declare class CreateAudioFileInputNodeResult  {
		fileInputNode: Windows.Media.Audio.AudioFileInputNode;
		status: Windows.Media.Audio.AudioFileNodeCreationStatus
	}

	declare class CreateAudioFileOutputNodeResult  {
		fileOutputNode: Windows.Media.Audio.AudioFileOutputNode;
		status: Windows.Media.Audio.AudioFileNodeCreationStatus
	}

	declare class CreateAudioGraphResult  {
		graph: Windows.Media.Audio.AudioGraph;
		status: Windows.Media.Audio.AudioGraphCreationStatus
	}

	declare class EchoEffectDefinition  {
		constructor(audioGraph: Windows.Media.Audio.AudioGraph): this;
		activatableClassId: string;
		delay: number;
		feedback: number;
		properties: Windows.Foundation.Collections.IPropertySet;
		wetDryMix: number
	}

	declare class EqualizerBand  {
		bandwidth: number;
		frequencyCenter: number;
		gain: number
	}

	declare class EqualizerEffectDefinition  {
		constructor(audioGraph: Windows.Media.Audio.AudioGraph): this;
		activatableClassId: string;
		bands: Windows.Foundation.Collections.IVectorView<Windows.Media.Audio.EqualizerBand>;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class FrameInputNodeQuantumStartedEventArgs  {
		requiredSamples: number
	}

	declare class LimiterEffectDefinition  {
		constructor(audioGraph: Windows.Media.Audio.AudioGraph): this;
		activatableClassId: string;
		loudness: number;
		properties: Windows.Foundation.Collections.IPropertySet;
		release: number
	}

	declare class ReverbEffectDefinition  {
		constructor(audioGraph: Windows.Media.Audio.AudioGraph): this;
		activatableClassId: string;
		decayTime: number;
		density: number;
		disableLateField: boolean;
		earlyDiffusion: number;
		highEQCutoff: number;
		highEQGain: number;
		lateDiffusion: number;
		lowEQCutoff: number;
		lowEQGain: number;
		positionLeft: number;
		positionMatrixLeft: number;
		positionMatrixRight: number;
		positionRight: number;
		properties: Windows.Foundation.Collections.IPropertySet;
		rearDelay: number;
		reflectionsDelay: number;
		reflectionsGain: number;
		reverbDelay: number;
		reverbGain: number;
		roomFilterFreq: number;
		roomFilterHF: number;
		roomFilterMain: number;
		roomSize: number;
		wetDryMix: number
	}

	
}

declare module 'Media' {
		declare interface IMediaExtension {
		setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void
	}

	declare interface IMediaMarker {
		mediaMarkerType: string,
		text: string,
		time: number
	}

		declare class AudioBuffer  {
		capacity: number;
		close(): void;
		createReference(): Windows.Foundation.IMemoryBufferReference;
		length: number
	}

	declare class AudioFrame  {
		constructor(capacity: number): this;
		close(): void;
		duration: number;
		extendedProperties: Windows.Foundation.Collections.IPropertySet;
		isDiscontinuous: boolean;
		isReadOnly: boolean;
		lockBuffer(mode: Windows.Media.AudioBufferAccessMode): Windows.Media.AudioBuffer;
		relativeTime: number;
		systemRelativeTime: number;
		type: string
	}

	declare class AutoRepeatModeChangeRequestedEventArgs  {
		requestedAutoRepeatMode: Windows.Media.MediaPlaybackAutoRepeatMode
	}

	declare class ImageDisplayProperties  {
		subtitle: string;
		title: string
	}

	declare class MediaControl  {
		albumArt: Windows.Foundation.Uri;
		artistName: string;
		isPlaying: boolean;
		onchanneldownpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		onchanneluppressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
		onfastforwardpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		onnexttrackpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
		onpausepressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
		onplaypausetogglepressed: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		onplaypressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
		onprevioustrackpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>
	): void;
		onrecordpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
		onrewindpressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
		onsoundlevelchanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		onstoppressed: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
		soundLevel: Windows.Media.SoundLevel;
		trackName: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaExtensionManager  {
		constructor(): this;
		registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
		registerAudioDecoder(
		activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		registerAudioEncoder(
		activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
		registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
		registerByteStreamHandler(
		activatableClassId: string, fileExtension: string, mimeType: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		registerSchemeHandler(
		activatableClassId: string, scheme: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		registerSchemeHandler(activatableClassId: string, scheme: string): void;
		registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
		registerVideoDecoder(
		activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
		registerVideoEncoder(
		activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet
	): void
	}

	declare class MediaMarkerTypes  {
		bookmark: string
	}

	declare class MediaProcessingTriggerDetails  {
		arguments: Windows.Foundation.Collections.ValueSet
	}

	declare class MusicDisplayProperties  {
		albumArtist: string;
		albumTitle: string;
		artist: string;
		genres: Windows.Foundation.Collections.IVector<string>;
		title: string;
		trackNumber: number
	}

	declare class PlaybackPositionChangeRequestedEventArgs  {
		requestedPlaybackPosition: number
	}

	declare class PlaybackRateChangeRequestedEventArgs  {
		requestedPlaybackRate: number
	}

	declare class ShuffleEnabledChangeRequestedEventArgs  {
		requestedShuffleEnabled: boolean
	}

	declare class SystemMediaTransportControls  {
		getForCurrentView(): Windows.Media.SystemMediaTransportControls;
		autoRepeatMode: Windows.Media.MediaPlaybackAutoRepeatMode;
		displayUpdater: Windows.Media.SystemMediaTransportControlsDisplayUpdater;
		isChannelDownEnabled: boolean;
		isChannelUpEnabled: boolean;
		isEnabled: boolean;
		isFastForwardEnabled: boolean;
		isNextEnabled: boolean;
		isPauseEnabled: boolean;
		isPlayEnabled: boolean;
		isPreviousEnabled: boolean;
		isRecordEnabled: boolean;
		isRewindEnabled: boolean;
		isStopEnabled: boolean;
		onautorepeatmodechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.AutoRepeatModeChangeRequestedEventArgs>;
		addEventListener(
		type: "autorepeatmodechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.AutoRepeatModeChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "autorepeatmodechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.AutoRepeatModeChangeRequestedEventArgs>
	): void;
		onbuttonpressed: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs>;
		addEventListener(
		type: "buttonpressed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs>
	): void;
		removeEventListener(
		type: "buttonpressed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsButtonPressedEventArgs>
	): void;
		onplaybackpositionchangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.PlaybackPositionChangeRequestedEventArgs>;
		addEventListener(
		type: "playbackpositionchangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.PlaybackPositionChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "playbackpositionchangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.PlaybackPositionChangeRequestedEventArgs>
	): void;
		onplaybackratechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, any>;
		addEventListener(
		type: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, any>
	): void;
		removeEventListener(
		type: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, any>
	): void;
		onpropertychanged: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs>;
		addEventListener(
		type: "propertychanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs>
	): void;
		removeEventListener(
		type: "propertychanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.SystemMediaTransportControlsPropertyChangedEventArgs>
	): void;
		onshuffleenabledchangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.ShuffleEnabledChangeRequestedEventArgs>;
		addEventListener(
		type: "shuffleenabledchangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.ShuffleEnabledChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "shuffleenabledchangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SystemMediaTransportControls, Windows.Media.ShuffleEnabledChangeRequestedEventArgs>
	): void;
		playbackRate: number;
		playbackStatus: Windows.Media.MediaPlaybackStatus;
		shuffleEnabled: boolean;
		soundLevel: Windows.Media.SoundLevel;
		updateTimelineProperties(
		timelineProperties: Windows.Media.SystemMediaTransportControlsTimelineProperties
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SystemMediaTransportControlsButtonPressedEventArgs  {
		button: Windows.Media.SystemMediaTransportControlsButton
	}

	declare class SystemMediaTransportControlsDisplayUpdater  {
		appMediaId: string;
		clearAll(): void;
		copyFromFileAsync(
		type: Windows.Media.MediaPlaybackType, source: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		imageProperties: Windows.Media.ImageDisplayProperties;
		musicProperties: Windows.Media.MusicDisplayProperties;
		thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
		type: Windows.Media.MediaPlaybackType;
		update(): void;
		videoProperties: Windows.Media.VideoDisplayProperties
	}

	declare class SystemMediaTransportControlsPropertyChangedEventArgs  {
		property: Windows.Media.SystemMediaTransportControlsProperty
	}

	declare class SystemMediaTransportControlsTimelineProperties  {
		constructor(): this;
		endTime: number;
		maxSeekTime: number;
		minSeekTime: number;
		position: number;
		startTime: number
	}

	declare class VideoDisplayProperties  {
		genres: Windows.Foundation.Collections.IVector<string>;
		subtitle: string;
		title: string
	}

	declare class VideoEffects  {
		videoStabilization: string
	}

	declare class VideoFrame  {
		constructor(format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number, alpha: Windows.Graphics.Imaging.BitmapAlphaMode): this;
		constructor(format: Windows.Graphics.Imaging.BitmapPixelFormat, width: number, height: number): this;
		close(): void;
		copyToAsync(frame: Windows.Media.VideoFrame): Windows.Foundation.IPromiseWithIAsyncAction;
		direct3DSurface: Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface;
		duration: number;
		extendedProperties: Windows.Foundation.Collections.IPropertySet;
		isDiscontinuous: boolean;
		isReadOnly: boolean;
		relativeTime: number;
		softwareBitmap: Windows.Graphics.Imaging.SoftwareBitmap;
		systemRelativeTime: number;
		type: string
	}

	
}

declare module 'Capture' {
	declare type MediaCaptureFailedEventHandler = (
		ev: Windows.Media.Capture.MediaCaptureFailedEventArgs & WinRTEvent<Windows.Media.Capture.MediaCapture>
	) => void;

	declare type RecordLimitationExceededEventHandler = (ev: WinRTEvent<Windows.Media.Capture.MediaCapture>) => void;

	declare interface WhiteBalanceGain {
		b: number,
		g: number,
		r: number
	}

		declare class AdvancedCapturedPhoto  {
		context: any;
		frame: Windows.Media.Capture.CapturedFrame;
		mode: Windows.Media.Devices.AdvancedPhotoMode
	}

	declare class AdvancedPhotoCapture  {
		captureAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.AdvancedCapturedPhoto>;
		captureAsync(
		context: any
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.AdvancedCapturedPhoto>;
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		onallphotoscaptured: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, any>;
		addEventListener(
		type: "allphotoscaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, any>
	): void;
		removeEventListener(
		type: "allphotoscaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, any>
	): void;
		onoptionalreferencephotocaptured: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs>;
		addEventListener(
		type: "optionalreferencephotocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs>
	): void;
		removeEventListener(
		type: "optionalreferencephotocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.AdvancedPhotoCapture, Windows.Media.Capture.OptionalReferencePhotoCapturedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AppCapture  {
		getForCurrentView: any;
		addEventListener: any;
		isCapturingAudio: any;
		isCapturingVideo: any;
		oncapturingchanged: any;
		removeEventListener: any
	}

	declare class AppCaptureAlternateShortcutKeys  {
		saveHistoricalVideoKey: Windows.System.VirtualKey;
		saveHistoricalVideoKeyModifiers: Windows.System.VirtualKeyModifiers;
		takeScreenshotKey: Windows.System.VirtualKey;
		takeScreenshotKeyModifiers: Windows.System.VirtualKeyModifiers;
		toggleGameBarKey: Windows.System.VirtualKey;
		toggleGameBarKeyModifiers: Windows.System.VirtualKeyModifiers;
		toggleMicrophoneCaptureKey: any;
		toggleMicrophoneCaptureKeyModifiers: any;
		toggleRecordingIndicatorKey: Windows.System.VirtualKey;
		toggleRecordingIndicatorKeyModifiers: Windows.System.VirtualKeyModifiers;
		toggleRecordingKey: Windows.System.VirtualKey;
		toggleRecordingKeyModifiers: Windows.System.VirtualKeyModifiers
	}

	declare class AppCaptureManager  {
		applySettings(appCaptureSettings: Windows.Media.Capture.AppCaptureSettings): void;
		getCurrentSettings(): Windows.Media.Capture.AppCaptureSettings
	}

	declare class AppCaptureSettings  {
		alternateShortcutKeys: Windows.Media.Capture.AppCaptureAlternateShortcutKeys;
		appCaptureDestinationFolder: Windows.Storage.StorageFolder;
		audioEncodingBitrate: number;
		customVideoEncodingBitrate: number;
		customVideoEncodingHeight: number;
		customVideoEncodingWidth: number;
		hasHardwareEncoder: boolean;
		historicalBufferLength: number;
		historicalBufferLengthUnit: Windows.Media.Capture.AppCaptureHistoricalBufferLengthUnit;
		isAppCaptureEnabled: boolean;
		isAudioCaptureEnabled: boolean;
		isCpuConstrained: boolean;
		isDisabledByPolicy: boolean;
		isGpuConstrained: boolean;
		isHistoricalCaptureEnabled: boolean;
		isHistoricalCaptureOnBatteryAllowed: boolean;
		isHistoricalCaptureOnWirelessDisplayAllowed: boolean;
		isMemoryConstrained: boolean;
		isMicrophoneCaptureEnabled: any;
		maximumRecordLength: number;
		screenshotDestinationFolder: Windows.Storage.StorageFolder;
		videoEncodingBitrateMode: Windows.Media.Capture.AppCaptureVideoEncodingBitrateMode;
		videoEncodingResolutionMode: Windows.Media.Capture.AppCaptureVideoEncodingResolutionMode
	}

	declare class CameraCaptureUI  {
		constructor(): this;
		captureFileAsync(
		mode: Windows.Media.Capture.CameraCaptureUIMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		photoSettings: Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings;
		videoSettings: Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings
	}

	declare class CameraCaptureUIPhotoCaptureSettings  {
		allowCropping: boolean;
		croppedAspectRatio: Windows.Foundation.Size;
		croppedSizeInPixels: Windows.Foundation.Size;
		format: Windows.Media.Capture.CameraCaptureUIPhotoFormat;
		maxResolution: Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution
	}

	declare class CameraCaptureUIVideoCaptureSettings  {
		allowTrimming: boolean;
		format: Windows.Media.Capture.CameraCaptureUIVideoFormat;
		maxDurationInSeconds: number;
		maxResolution: Windows.Media.Capture.CameraCaptureUIMaxVideoResolution
	}

	declare class CameraOptionsUI  {
		show(mediaCapture: Windows.Media.Capture.MediaCapture): void
	}

	declare class CapturedFrame  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		contentType: string;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		height: number;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		softwareBitmap: Windows.Graphics.Imaging.SoftwareBitmap;
		width: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class CapturedFrameControlValues  {
		exposure: number;
		exposureCompensation: number;
		flashPowerPercent: number;
		flashed: boolean;
		focus: number;
		focusState: Windows.Media.Devices.MediaCaptureFocusState;
		isoAnalogGain: number;
		isoDigitalGain: number;
		isoSpeed: number;
		sceneMode: Windows.Media.Devices.CaptureSceneMode;
		sensorFrameRate: Windows.Media.MediaProperties.MediaRatio;
		whiteBalance: number;
		whiteBalanceGain: Windows.Media.Capture.WhiteBalanceGain;
		zoomFactor: number
	}

	declare class CapturedPhoto  {
		frame: Windows.Media.Capture.CapturedFrame;
		thumbnail: Windows.Media.Capture.CapturedFrame
	}

	declare class LowLagMediaRecording  {
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		pauseAsync(
		behavior: Windows.Media.Devices.MediaCapturePauseBehavior
	): Windows.Foundation.IPromiseWithIAsyncAction;
		resumeAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopAsync(): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class LowLagPhotoCapture  {
		captureAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.CapturedPhoto>;
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class LowLagPhotoSequenceCapture  {
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		onphotocaptured: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.LowLagPhotoSequenceCapture, Windows.Media.Capture.PhotoCapturedEventArgs>;
		addEventListener(
		type: "photocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.LowLagPhotoSequenceCapture, Windows.Media.Capture.PhotoCapturedEventArgs>
	): void;
		removeEventListener(
		type: "photocaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.LowLagPhotoSequenceCapture, Windows.Media.Capture.PhotoCapturedEventArgs>
	): void;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaCapture  {
		findAllVideoProfiles(
		videoDeviceId: string
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfile>;
		findConcurrentProfiles(
		videoDeviceId: string
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfile>;
		findKnownVideoProfiles(
		videoDeviceId: string, name: Windows.Media.Capture.KnownVideoProfile
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfile>;
		isVideoProfileSupported(videoDeviceId: string): boolean;
		constructor(): this;
		addAudioEffectAsync(
		definition: Windows.Media.Effects.IAudioEffectDefinition
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.IMediaExtension>;
		addEffectAsync(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, effectActivationID: string, effectSettings: Windows.Foundation.Collections.IPropertySet
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addVideoEffectAsync(
		definition: Windows.Media.Effects.IVideoEffectDefinition, mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.IMediaExtension>;
		audioDeviceController: Windows.Media.Devices.AudioDeviceController;
		cameraStreamState: Windows.Media.Devices.CameraStreamState;
		capturePhotoToStorageFileAsync(
		type: Windows.Media.MediaProperties.ImageEncodingProperties, file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		capturePhotoToStreamAsync(
		type: Windows.Media.MediaProperties.ImageEncodingProperties, stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		clearEffectsAsync(
		mediaStreamType: Windows.Media.Capture.MediaStreamType
	): Windows.Foundation.IPromiseWithIAsyncAction;
		close(): void;
		getEncoderProperty(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string
	): any;
		getPreviewFrameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.VideoFrame>;
		getPreviewFrameAsync(
		destination: Windows.Media.VideoFrame
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.VideoFrame>;
		getPreviewMirroring(): boolean;
		getPreviewRotation(): Windows.Media.Capture.VideoRotation;
		getRecordRotation(): Windows.Media.Capture.VideoRotation;
		initializeAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		initializeAsync(
		mediaCaptureInitializationSettings: Windows.Media.Capture.MediaCaptureInitializationSettings
	): Windows.Foundation.IPromiseWithIAsyncAction;
		mediaCaptureSettings: Windows.Media.Capture.MediaCaptureSettings;
		oncamerastreamstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>;
		addEventListener(
		type: "camerastreamstatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>
	): void;
		removeEventListener(
		type: "camerastreamstatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>
	): void;
		onfailed: Windows.Media.Capture.MediaCaptureFailedEventHandler;
		addEventListener(
		type: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler
	): void;
		removeEventListener(
		type: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler
	): void;
		onfocuschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.MediaCaptureFocusChangedEventArgs>;
		addEventListener(
		type: "focuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.MediaCaptureFocusChangedEventArgs>
	): void;
		removeEventListener(
		type: "focuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.MediaCaptureFocusChangedEventArgs>
	): void;
		onphotoconfirmationcaptured: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.PhotoConfirmationCapturedEventArgs>;
		addEventListener(
		type: "photoconfirmationcaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.PhotoConfirmationCapturedEventArgs>
	): void;
		removeEventListener(
		type: "photoconfirmationcaptured", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, Windows.Media.Capture.PhotoConfirmationCapturedEventArgs>
	): void;
		onrecordlimitationexceeded: Windows.Media.Capture.RecordLimitationExceededEventHandler;
		addEventListener(
		type: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler
	): void;
		removeEventListener(
		type: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler
	): void;
		onthermalstatuschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>;
		addEventListener(
		type: "thermalstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>
	): void;
		removeEventListener(
		type: "thermalstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Capture.MediaCapture, any>
	): void;
		pauseRecordAsync(
		behavior: Windows.Media.Devices.MediaCapturePauseBehavior
	): Windows.Foundation.IPromiseWithIAsyncAction;
		prepareAdvancedPhotoCaptureAsync(
		encodingProperties: Windows.Media.MediaProperties.ImageEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.AdvancedPhotoCapture>;
		prepareLowLagPhotoCaptureAsync(
		type: Windows.Media.MediaProperties.ImageEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagPhotoCapture>;
		prepareLowLagPhotoSequenceCaptureAsync(
		type: Windows.Media.MediaProperties.ImageEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagPhotoSequenceCapture>;
		prepareLowLagRecordToCustomSinkAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagMediaRecording>;
		prepareLowLagRecordToCustomSinkAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagMediaRecording>;
		prepareLowLagRecordToStorageFileAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagMediaRecording>;
		prepareLowLagRecordToStreamAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.LowLagMediaRecording>;
		prepareVariablePhotoSequenceCaptureAsync(
		type: Windows.Media.MediaProperties.ImageEncodingProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Capture.Core.VariablePhotoSequenceCapture>;
		resumeRecordAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		setEncoderProperty(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string, propertyValue: any
	): void;
		setEncodingPropertiesAsync(
		mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties, encoderProperties: Windows.Media.MediaProperties.MediaPropertySet
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setPreviewMirroring(value: boolean): void;
		setPreviewRotation(value: Windows.Media.Capture.VideoRotation): void;
		setRecordRotation(value: Windows.Media.Capture.VideoRotation): void;
		startRecordToCustomSinkAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startRecordToCustomSinkAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startRecordToStorageFileAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startRecordToStreamAsync(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		stopRecordAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		thermalStatus: Windows.Media.Capture.MediaCaptureThermalStatus;
		videoDeviceController: Windows.Media.Devices.VideoDeviceController;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaCaptureFailedEventArgs  {
		code: number;
		message: string
	}

	declare class MediaCaptureFocusChangedEventArgs  {
		focusState: Windows.Media.Devices.MediaCaptureFocusState
	}

	declare class MediaCaptureInitializationSettings  {
		constructor(): this;
		audioDeviceId: string;
		audioProcessing: Windows.Media.AudioProcessing;
		audioSource: Windows.Media.Core.IMediaSource;
		mediaCategory: Windows.Media.Capture.MediaCategory;
		photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
		photoMediaDescription: Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription;
		previewMediaDescription: Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription;
		recordMediaDescription: Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription;
		streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
		videoDeviceId: string;
		videoProfile: Windows.Media.Capture.MediaCaptureVideoProfile;
		videoSource: Windows.Media.Core.IMediaSource
	}

	declare class MediaCaptureSettings  {
		audioDeviceId: string;
		audioProcessing: Windows.Media.AudioProcessing;
		cameraSoundRequiredForRegion: boolean;
		concurrentRecordAndPhotoSequenceSupported: boolean;
		concurrentRecordAndPhotoSupported: boolean;
		horizontal35mmEquivalentFocalLength: number;
		mediaCategory: Windows.Media.Capture.MediaCategory;
		photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
		pitchOffsetDegrees: number;
		streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
		vertical35mmEquivalentFocalLength: number;
		videoDeviceCharacteristic: Windows.Media.Capture.VideoDeviceCharacteristic;
		videoDeviceId: string
	}

	declare class MediaCaptureVideoProfile  {
		getConcurrency(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfile>;
		id: string;
		supportedPhotoMediaDescription: Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>;
		supportedPreviewMediaDescription: Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>;
		supportedRecordMediaDescription: Windows.Foundation.Collections.IVectorView<Windows.Media.Capture.MediaCaptureVideoProfileMediaDescription>;
		videoDeviceId: string
	}

	declare class MediaCaptureVideoProfileMediaDescription  {
		frameRate: number;
		height: number;
		isHdrVideoSupported: boolean;
		isVariablePhotoSequenceSupported: boolean;
		width: number
	}

	declare class OptionalReferencePhotoCapturedEventArgs  {
		context: any;
		frame: Windows.Media.Capture.CapturedFrame
	}

	declare class PhotoCapturedEventArgs  {
		captureTimeOffset: number;
		frame: Windows.Media.Capture.CapturedFrame;
		thumbnail: Windows.Media.Capture.CapturedFrame
	}

	declare class PhotoConfirmationCapturedEventArgs  {
		captureTimeOffset: number;
		frame: Windows.Media.Capture.CapturedFrame
	}

	declare class VideoStreamConfiguration  {
		inputProperties: Windows.Media.MediaProperties.VideoEncodingProperties;
		outputProperties: Windows.Media.MediaProperties.VideoEncodingProperties
	}

	
}

declare module 'Casting' {
				declare class CastingConnection  {
		close(): void;
		device: Windows.Media.Casting.CastingDevice;
		disconnectAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Casting.CastingConnectionErrorStatus>;
		onerroroccurred: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs>;
		addEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs>
	): void;
		removeEventListener(
		type: "erroroccurred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, Windows.Media.Casting.CastingConnectionErrorOccurredEventArgs>
	): void;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, any>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, any>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingConnection, any>
	): void;
		requestStartCastingAsync(
		value: Windows.Media.Casting.CastingSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Casting.CastingConnectionErrorStatus>;
		source: Windows.Media.Casting.CastingSource;
		state: Windows.Media.Casting.CastingConnectionState;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CastingConnectionErrorOccurredEventArgs  {
		errorStatus: Windows.Media.Casting.CastingConnectionErrorStatus;
		message: string
	}

	declare class CastingDevice  {
		deviceInfoSupportsCastingAsync(
		device: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		fromIdAsync(
		value: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Casting.CastingDevice>;
		getDeviceSelector(type: Windows.Media.Casting.CastingPlaybackTypes): string;
		getDeviceSelectorFromCastingSourceAsync(
		castingSource: Windows.Media.Casting.CastingSource
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		createCastingConnection(): Windows.Media.Casting.CastingConnection;
		friendlyName: string;
		getSupportedCastingPlaybackTypesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Casting.CastingPlaybackTypes>;
		icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
		id: string
	}

	declare class CastingDevicePicker  {
		constructor(): this;
		appearance: Windows.Devices.Enumeration.DevicePickerAppearance;
		filter: Windows.Media.Casting.CastingDevicePickerFilter;
		hide(): void;
		oncastingdevicepickerdismissed: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, any>;
		addEventListener(
		type: "castingdevicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, any>
	): void;
		removeEventListener(
		type: "castingdevicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, any>
	): void;
		oncastingdeviceselected: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, Windows.Media.Casting.CastingDeviceSelectedEventArgs>;
		addEventListener(
		type: "castingdeviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, Windows.Media.Casting.CastingDeviceSelectedEventArgs>
	): void;
		removeEventListener(
		type: "castingdeviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Casting.CastingDevicePicker, Windows.Media.Casting.CastingDeviceSelectedEventArgs>
	): void;
		show(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): void;
		show(selection: Windows.Foundation.Rect): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CastingDevicePickerFilter  {
		supportedCastingSources: Windows.Foundation.Collections.IVector<Windows.Media.Casting.CastingSource>;
		supportsAudio: boolean;
		supportsPictures: boolean;
		supportsVideo: boolean
	}

	declare class CastingDeviceSelectedEventArgs  {
		selectedCastingDevice: Windows.Media.Casting.CastingDevice
	}

	declare class CastingSource  {
		preferredSourceUri: Windows.Foundation.Uri
	}

	
}

declare module 'ClosedCaptioning' {
				declare class ClosedCaptionProperties  {
		backgroundColor: Windows.Media.ClosedCaptioning.ClosedCaptionColor;
		backgroundOpacity: Windows.Media.ClosedCaptioning.ClosedCaptionOpacity;
		computedBackgroundColor: Windows.UI.Color;
		computedFontColor: Windows.UI.Color;
		computedRegionColor: Windows.UI.Color;
		fontColor: Windows.Media.ClosedCaptioning.ClosedCaptionColor;
		fontEffect: Windows.Media.ClosedCaptioning.ClosedCaptionEdgeEffect;
		fontOpacity: Windows.Media.ClosedCaptioning.ClosedCaptionOpacity;
		fontSize: Windows.Media.ClosedCaptioning.ClosedCaptionSize;
		fontStyle: Windows.Media.ClosedCaptioning.ClosedCaptionStyle;
		regionColor: Windows.Media.ClosedCaptioning.ClosedCaptionColor;
		regionOpacity: Windows.Media.ClosedCaptioning.ClosedCaptionOpacity
	}

	
}

declare module 'ContentRestrictions' {
				declare class ContentRestrictionsBrowsePolicy  {
		geographicRegion: string;
		maxBrowsableAgeRating: number;
		preferredAgeRating: number
	}

	declare class RatedContentDescription  {
		constructor(id: string, title: string, category: Windows.Media.ContentRestrictions.RatedContentCategory): this;
		category: Windows.Media.ContentRestrictions.RatedContentCategory;
		id: string;
		image: Windows.Storage.Streams.IRandomAccessStreamReference;
		ratings: Windows.Foundation.Collections.IVector<string>;
		title: string
	}

	declare class RatedContentRestrictions  {
		constructor(): this;
		constructor(maxAgeRating: number): this;
		getBrowsePolicyAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.ContentRestrictions.ContentRestrictionsBrowsePolicy>;
		getRestrictionLevelAsync(
		RatedContentDescription: Windows.Media.ContentRestrictions.RatedContentDescription
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.ContentRestrictions.ContentAccessRestrictionLevel>;
		onrestrictionschanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "restrictionschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "restrictionschanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		requestContentAccessAsync(
		RatedContentDescription: Windows.Media.ContentRestrictions.RatedContentDescription
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'DialProtocol' {
				declare class DialApp  {
		appName: string;
		getAppStateAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialAppStateDetails>;
		requestLaunchAsync(
		appArgument: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialAppLaunchResult>;
		stopAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialAppStopResult>
	}

	declare class DialAppStateDetails  {
		fullXml: string;
		state: Windows.Media.DialProtocol.DialAppState
	}

	declare class DialDevice  {
		deviceInfoSupportsDialAsync(
		device: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		fromIdAsync(
		value: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialDevice>;
		getDeviceSelector(appName: string): string;
		friendlyName: string;
		getDialApp(appName: string): Windows.Media.DialProtocol.DialApp;
		id: string;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference
	}

	declare class DialDevicePicker  {
		constructor(): this;
		appearance: Windows.Devices.Enumeration.DevicePickerAppearance;
		filter: Windows.Media.DialProtocol.DialDevicePickerFilter;
		hide(): void;
		ondialdevicepickerdismissed: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, any>;
		addEventListener(
		type: "dialdevicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, any>
	): void;
		removeEventListener(
		type: "dialdevicepickerdismissed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, any>
	): void;
		ondialdeviceselected: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDeviceSelectedEventArgs>;
		addEventListener(
		type: "dialdeviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDeviceSelectedEventArgs>
	): void;
		removeEventListener(
		type: "dialdeviceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDeviceSelectedEventArgs>
	): void;
		ondisconnectbuttonclicked: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDisconnectButtonClickedEventArgs>;
		addEventListener(
		type: "disconnectbuttonclicked", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDisconnectButtonClickedEventArgs>
	): void;
		removeEventListener(
		type: "disconnectbuttonclicked", listener: Windows.Foundation.TypedEventHandler<Windows.Media.DialProtocol.DialDevicePicker, Windows.Media.DialProtocol.DialDisconnectButtonClickedEventArgs>
	): void;
		pickSingleDialDeviceAsync(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialDevice>;
		pickSingleDialDeviceAsync(
		selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.DialProtocol.DialDevice>;
		setDisplayStatus(
		device: Windows.Media.DialProtocol.DialDevice, status: Windows.Media.DialProtocol.DialDeviceDisplayStatus
	): void;
		show(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): void;
		show(selection: Windows.Foundation.Rect): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class DialDevicePickerFilter  {
		supportedAppNames: Windows.Foundation.Collections.IVector<string>
	}

	declare class DialDeviceSelectedEventArgs  {
		selectedDialDevice: Windows.Media.DialProtocol.DialDevice
	}

	declare class DialDisconnectButtonClickedEventArgs  {
		device: Windows.Media.DialProtocol.DialDevice
	}

	
}

declare module 'Editing' {
				declare class BackgroundAudioTrack  {
		createFromEmbeddedAudioTrack(
		embeddedAudioTrack: Windows.Media.Editing.EmbeddedAudioTrack
	): Windows.Media.Editing.BackgroundAudioTrack;
		createFromFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Editing.BackgroundAudioTrack>;
		audioEffectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		clone(): Windows.Media.Editing.BackgroundAudioTrack;
		delay: number;
		getAudioEncodingProperties(): Windows.Media.MediaProperties.AudioEncodingProperties;
		originalDuration: number;
		trimTimeFromEnd: number;
		trimTimeFromStart: number;
		trimmedDuration: number;
		userData: Windows.Foundation.Collections.IMap<string, string>;
		volume: number
	}

	declare class EmbeddedAudioTrack  {
		getAudioEncodingProperties(): Windows.Media.MediaProperties.AudioEncodingProperties
	}

	declare class MediaClip  {
		createFromColor(
		color: Windows.UI.Color, originalDuration: number
	): Windows.Media.Editing.MediaClip;
		createFromFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Editing.MediaClip>;
		createFromImageFileAsync(
		file: Windows.Storage.IStorageFile, originalDuration: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Editing.MediaClip>;
		createFromSurface(
		surface: Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface, originalDuration: number
	): Windows.Media.Editing.MediaClip;
		audioEffectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IAudioEffectDefinition>;
		clone(): Windows.Media.Editing.MediaClip;
		embeddedAudioTracks: Windows.Foundation.Collections.IVectorView<Windows.Media.Editing.EmbeddedAudioTrack>;
		endTimeInComposition: number;
		getVideoEncodingProperties(): Windows.Media.MediaProperties.VideoEncodingProperties;
		originalDuration: number;
		selectedEmbeddedAudioTrackIndex: number;
		startTimeInComposition: number;
		trimTimeFromEnd: number;
		trimTimeFromStart: number;
		trimmedDuration: number;
		userData: Windows.Foundation.Collections.IMap<string, string>;
		videoEffectDefinitions: Windows.Foundation.Collections.IVector<Windows.Media.Effects.IVideoEffectDefinition>;
		volume: number
	}

	declare class MediaComposition  {
		loadAsync(
		file: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Editing.MediaComposition>;
		constructor(): this;
		backgroundAudioTracks: Windows.Foundation.Collections.IVector<Windows.Media.Editing.BackgroundAudioTrack>;
		clips: Windows.Foundation.Collections.IVector<Windows.Media.Editing.MediaClip>;
		clone(): Windows.Media.Editing.MediaComposition;
		createDefaultEncodingProfile(): Windows.Media.MediaProperties.MediaEncodingProfile;
		duration: number;
		generateMediaStreamSource(
		encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Media.Core.MediaStreamSource;
		generateMediaStreamSource(): Windows.Media.Core.MediaStreamSource;
		generatePreviewMediaStreamSource(
		scaledWidth: number, scaledHeight: number
	): Windows.Media.Core.MediaStreamSource;
		getThumbnailAsync(
		timeFromStart: number, scaledWidth: number, scaledHeight: number, framePrecision: Windows.Media.Editing.VideoFramePrecision
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
		getThumbnailsAsync(
		timesFromStart: Windows.Foundation.Collections.IIterable<number>, scaledWidth: number, scaledHeight: number, framePrecision: Windows.Media.Editing.VideoFramePrecision
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		overlayLayers: Windows.Foundation.Collections.IVector<Windows.Media.Editing.MediaOverlayLayer>;
		renderToFileAsync(
		destination: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Transcoding.TranscodeFailureReason, number>;
		renderToFileAsync(
		destination: Windows.Storage.IStorageFile, trimmingPreference: Windows.Media.Editing.MediaTrimmingPreference
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Transcoding.TranscodeFailureReason, number>;
		renderToFileAsync(
		destination: Windows.Storage.IStorageFile, trimmingPreference: Windows.Media.Editing.MediaTrimmingPreference, encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Transcoding.TranscodeFailureReason, number>;
		saveAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		userData: Windows.Foundation.Collections.IMap<string, string>
	}

	declare class MediaOverlay  {
		constructor(clip: Windows.Media.Editing.MediaClip): this;
		constructor(clip: Windows.Media.Editing.MediaClip, position: Windows.Foundation.Rect, opacity: number): this;
		audioEnabled: boolean;
		clip: Windows.Media.Editing.MediaClip;
		clone(): Windows.Media.Editing.MediaOverlay;
		delay: number;
		opacity: number;
		position: Windows.Foundation.Rect
	}

	declare class MediaOverlayLayer  {
		constructor(): this;
		constructor(compositorDefinition: Windows.Media.Effects.IVideoCompositorDefinition): this;
		clone(): Windows.Media.Editing.MediaOverlayLayer;
		customCompositorDefinition: Windows.Media.Effects.IVideoCompositorDefinition;
		overlays: Windows.Foundation.Collections.IVector<Windows.Media.Editing.MediaOverlay>
	}

	
}

declare module 'Effects' {
		declare interface IAudioEffectDefinition {
		activatableClassId: string,
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare interface IVideoEffectDefinition {
		activatableClassId: string,
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare interface IVideoCompositorDefinition {
		activatableClassId: string,
		properties: Windows.Foundation.Collections.IPropertySet
	}

		declare class AudioCaptureEffectsManager  {
		getAudioCaptureEffects(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Effects.AudioEffect>;
		onaudiocaptureeffectschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioCaptureEffectsManager, any>;
		addEventListener(
		type: "audiocaptureeffectschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioCaptureEffectsManager, any>
	): void;
		removeEventListener(
		type: "audiocaptureeffectschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioCaptureEffectsManager, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AudioEffect  {
		audioEffectType: Windows.Media.Effects.AudioEffectType
	}

	declare class AudioEffectDefinition  {
		constructor(activatableClassId: string, props: Windows.Foundation.Collections.IPropertySet): this;
		constructor(activatableClassId: string): this;
		activatableClassId: string;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class AudioEffectsManager  {
		createAudioCaptureEffectsManager(
		deviceId: string, category: Windows.Media.Capture.MediaCategory
	): Windows.Media.Effects.AudioCaptureEffectsManager;
		createAudioCaptureEffectsManager(
		deviceId: string, category: Windows.Media.Capture.MediaCategory, mode: Windows.Media.AudioProcessing
	): Windows.Media.Effects.AudioCaptureEffectsManager;
		createAudioRenderEffectsManager(
		deviceId: string, category: Windows.Media.Render.AudioRenderCategory, mode: Windows.Media.AudioProcessing
	): Windows.Media.Effects.AudioRenderEffectsManager;
		createAudioRenderEffectsManager(
		deviceId: string, category: Windows.Media.Render.AudioRenderCategory
	): Windows.Media.Effects.AudioRenderEffectsManager
	}

	declare class AudioRenderEffectsManager  {
		effectsProviderSettingsLabel: string;
		effectsProviderThumbnail: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
		getAudioRenderEffects(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Effects.AudioEffect>;
		onaudiorendereffectschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioRenderEffectsManager, any>;
		addEventListener(
		type: "audiorendereffectschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioRenderEffectsManager, any>
	): void;
		removeEventListener(
		type: "audiorendereffectschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Effects.AudioRenderEffectsManager, any>
	): void;
		showSettingsUI(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CompositeVideoFrameContext  {
		backgroundFrame: Windows.Media.VideoFrame;
		getOverlayForSurface(
		surfaceToOverlay: Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface
	): Windows.Media.Editing.MediaOverlay;
		outputFrame: Windows.Media.VideoFrame;
		surfacesToOverlay: Windows.Foundation.Collections.IVectorView<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>
	}

	declare class ProcessAudioFrameContext  {
		inputFrame: Windows.Media.AudioFrame;
		outputFrame: Windows.Media.AudioFrame
	}

	declare class ProcessVideoFrameContext  {
		inputFrame: Windows.Media.VideoFrame;
		outputFrame: Windows.Media.VideoFrame
	}

	declare class VideoCompositorDefinition  {
		constructor(activatableClassId: string, props: Windows.Foundation.Collections.IPropertySet): this;
		constructor(activatableClassId: string): this;
		activatableClassId: string;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class VideoEffectDefinition  {
		constructor(activatableClassId: string, props: Windows.Foundation.Collections.IPropertySet): this;
		constructor(activatableClassId: string): this;
		activatableClassId: string;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class VideoTransformEffectDefinition  {
		constructor(): this;
		activatableClassId: string;
		cropRectangle: Windows.Foundation.Rect;
		mirror: Windows.Media.MediaProperties.MediaMirroringOptions;
		outputSize: Windows.Foundation.Size;
		paddingColor: Windows.UI.Color;
		processingAlgorithm: Windows.Media.Transcoding.MediaVideoProcessingAlgorithm;
		properties: Windows.Foundation.Collections.IPropertySet;
		rotation: Windows.Media.MediaProperties.MediaRotation
	}

	
}

declare module 'FaceAnalysis' {
				declare class DetectedFace  {
		faceBox: Windows.Graphics.Imaging.BitmapBounds
	}

	declare class FaceDetector  {
		createAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.FaceAnalysis.FaceDetector>;
		getSupportedBitmapPixelFormats(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapPixelFormat>;
		isBitmapPixelFormatSupported(bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat): boolean;
		isSupported: boolean;
		detectFacesAsync(
		image: Windows.Graphics.Imaging.SoftwareBitmap
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		detectFacesAsync(
		image: Windows.Graphics.Imaging.SoftwareBitmap, searchArea: Windows.Graphics.Imaging.BitmapBounds
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>;
		maxDetectableFaceSize: Windows.Graphics.Imaging.BitmapSize;
		minDetectableFaceSize: Windows.Graphics.Imaging.BitmapSize
	}

	declare class FaceTracker  {
		createAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.FaceAnalysis.FaceTracker>;
		getSupportedBitmapPixelFormats(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapPixelFormat>;
		isBitmapPixelFormatSupported(bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat): boolean;
		isSupported: boolean;
		maxDetectableFaceSize: Windows.Graphics.Imaging.BitmapSize;
		minDetectableFaceSize: Windows.Graphics.Imaging.BitmapSize;
		processNextFrameAsync(
		videoFrame: Windows.Media.VideoFrame
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVector<any>>
	}

	
}

declare module 'Import' {
		declare interface PhotoImportProgress {
		bytesImported: number,
		importProgress: number,
		itemsImported: number,
		totalBytesToImport: number,
		totalItemsToImport: number
	}

		declare class PhotoImportDeleteImportedItemsFromSourceResult  {
		deletedItems: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportItem>;
		hasSucceeded: boolean;
		photosCount: number;
		photosSizeInBytes: number;
		session: Windows.Media.Import.PhotoImportSession;
		siblingsCount: number;
		siblingsSizeInBytes: number;
		sidecarsCount: number;
		sidecarsSizeInBytes: number;
		totalCount: number;
		totalSizeInBytes: number;
		videosCount: number;
		videosSizeInBytes: number
	}

	declare class PhotoImportFindItemsResult  {
		foundItems: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportItem>;
		hasSucceeded: boolean;
		importItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Import.PhotoImportImportItemsResult, Windows.Media.Import.PhotoImportProgress>;
		importMode: Windows.Media.Import.PhotoImportImportMode;
		onitemimported: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportItemImportedEventArgs>;
		addEventListener(
		type: "itemimported", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportItemImportedEventArgs>
	): void;
		removeEventListener(
		type: "itemimported", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportItemImportedEventArgs>
	): void;
		onselectionchanged: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportSelectionChangedEventArgs>;
		addEventListener(
		type: "selectionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportSelectionChangedEventArgs>
	): void;
		removeEventListener(
		type: "selectionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Import.PhotoImportFindItemsResult, Windows.Media.Import.PhotoImportSelectionChangedEventArgs>
	): void;
		photosCount: number;
		photosSizeInBytes: number;
		selectAll(): void;
		selectNewAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		selectNone(): void;
		selectedPhotosCount: number;
		selectedPhotosSizeInBytes: number;
		selectedSiblingsCount: number;
		selectedSiblingsSizeInBytes: number;
		selectedSidecarsCount: number;
		selectedSidecarsSizeInBytes: number;
		selectedTotalCount: number;
		selectedTotalSizeInBytes: number;
		selectedVideosCount: number;
		selectedVideosSizeInBytes: number;
		session: Windows.Media.Import.PhotoImportSession;
		setImportMode(value: Windows.Media.Import.PhotoImportImportMode): void;
		siblingsCount: number;
		siblingsSizeInBytes: number;
		sidecarsCount: number;
		sidecarsSizeInBytes: number;
		totalCount: number;
		totalSizeInBytes: number;
		videosCount: number;
		videosSizeInBytes: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PhotoImportImportItemsResult  {
		deleteImportedItemsFromSourceAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult, number>;
		hasSucceeded: boolean;
		importedItems: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportItem>;
		photosCount: number;
		photosSizeInBytes: number;
		session: Windows.Media.Import.PhotoImportSession;
		siblingsCount: number;
		siblingsSizeInBytes: number;
		sidecarsCount: number;
		sidecarsSizeInBytes: number;
		totalCount: number;
		totalSizeInBytes: number;
		videosCount: number;
		videosSizeInBytes: number
	}

	declare class PhotoImportItem  {
		contentType: Windows.Media.Import.PhotoImportContentType;
		date: Date;
		deletedFileNames: Windows.Foundation.Collections.IVectorView<string>;
		importedFileNames: Windows.Foundation.Collections.IVectorView<string>;
		isSelected: boolean;
		itemKey: number;
		name: string;
		sibling: Windows.Media.Import.PhotoImportSidecar;
		sidecars: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportSidecar>;
		sizeInBytes: number;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		videoSegments: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportVideoSegment>
	}

	declare class PhotoImportItemImportedEventArgs  {
		importedItem: Windows.Media.Import.PhotoImportItem
	}

	declare class PhotoImportManager  {
		findAllSourcesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getPendingOperations(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportOperation>;
		isSupportedAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class PhotoImportOperation  {
		continueDeletingImportedItemsFromSourceAsync: Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult, number>;
		continueFindingItemsAsync: Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Import.PhotoImportFindItemsResult, number>;
		continueImportingItemsAsync: Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Import.PhotoImportImportItemsResult, Windows.Media.Import.PhotoImportProgress>;
		session: Windows.Media.Import.PhotoImportSession;
		stage: Windows.Media.Import.PhotoImportStage
	}

	declare class PhotoImportSelectionChangedEventArgs  {
		isSelectionEmpty: boolean
	}

	declare class PhotoImportSession  {
		appendSessionDateToDestinationFolder: boolean;
		close(): void;
		destinationFileNamePrefix: string;
		destinationFolder: Windows.Storage.IStorageFolder;
		findItemsAsync(
		contentTypeFilter: Windows.Media.Import.PhotoImportContentTypeFilter, itemSelectionMode: Windows.Media.Import.PhotoImportItemSelectionMode
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Import.PhotoImportFindItemsResult, number>;
		sessionId: string;
		source: Windows.Media.Import.PhotoImportSource;
		subfolderCreationMode: Windows.Media.Import.PhotoImportSubfolderCreationMode
	}

	declare class PhotoImportSidecar  {
		date: Date;
		name: string;
		sizeInBytes: number
	}

	declare class PhotoImportSource  {
		fromFolderAsync(
		sourceRootFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Import.PhotoImportSource>;
		fromIdAsync(
		sourceId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Import.PhotoImportSource>;
		batteryLevelPercent: number;
		connectionProtocol: string;
		connectionTransport: Windows.Media.Import.PhotoImportConnectionTransport;
		createImportSession(): Windows.Media.Import.PhotoImportSession;
		dateTime: Date;
		description: string;
		displayName: string;
		id: string;
		isLocked: boolean;
		isMassStorage: boolean;
		manufacturer: string;
		model: string;
		powerSource: Windows.Media.Import.PhotoImportPowerSource;
		serialNumber: string;
		storageMedia: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportStorageMedium>;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		type: Windows.Media.Import.PhotoImportSourceType
	}

	declare class PhotoImportStorageMedium  {
		availableSpaceInBytes: number;
		capacityInBytes: number;
		description: string;
		name: string;
		refresh(): void;
		serialNumber: string;
		storageMediumType: Windows.Media.Import.PhotoImportStorageMediumType;
		supportedAccessMode: Windows.Media.Import.PhotoImportAccessMode
	}

	declare class PhotoImportVideoSegment  {
		date: Date;
		name: string;
		sibling: Windows.Media.Import.PhotoImportSidecar;
		sidecars: Windows.Foundation.Collections.IVectorView<Windows.Media.Import.PhotoImportSidecar>;
		sizeInBytes: number
	}

	
}

declare module 'MediaProperties' {
		declare interface IMediaEncodingProperties {
		properties: Windows.Media.MediaProperties.MediaPropertySet,
		subtype: string,
		type: string
	}

		declare class AudioEncodingProperties  {
		createAac(
		sampleRate: number, channelCount: number, bitrate: number
	): Windows.Media.MediaProperties.AudioEncodingProperties;
		createAacAdts(
		sampleRate: number, channelCount: number, bitrate: number
	): Windows.Media.MediaProperties.AudioEncodingProperties;
		createMp3(
		sampleRate: number, channelCount: number, bitrate: number
	): Windows.Media.MediaProperties.AudioEncodingProperties;
		createPcm(
		sampleRate: number, channelCount: number, bitsPerSample: number
	): Windows.Media.MediaProperties.AudioEncodingProperties;
		createWma(
		sampleRate: number, channelCount: number, bitrate: number
	): Windows.Media.MediaProperties.AudioEncodingProperties;
		constructor(): this;
		bitrate: number;
		bitsPerSample: number;
		channelCount: number;
		getFormatUserData(): number[];
		properties: Windows.Media.MediaProperties.MediaPropertySet;
		sampleRate: number;
		setFormatUserData(value: number[]): void;
		subtype: string;
		type: string
	}

	declare class ContainerEncodingProperties  {
		constructor(): this;
		properties: Windows.Media.MediaProperties.MediaPropertySet;
		subtype: string;
		type: string
	}

	declare class H264ProfileIds  {
		baseline: number;
		constrainedBaseline: number;
		extended: number;
		high: number;
		high10: number;
		high422: number;
		high444: number;
		main: number;
		multiviewHigh: number;
		stereoHigh: number
	}

	declare class ImageEncodingProperties  {
		createBmp(): Windows.Media.MediaProperties.ImageEncodingProperties;
		createJpeg(): Windows.Media.MediaProperties.ImageEncodingProperties;
		createJpegXR(): Windows.Media.MediaProperties.ImageEncodingProperties;
		createPng(): Windows.Media.MediaProperties.ImageEncodingProperties;
		createUncompressed(
		format: Windows.Media.MediaProperties.MediaPixelFormat
	): Windows.Media.MediaProperties.ImageEncodingProperties;
		constructor(): this;
		height: number;
		properties: Windows.Media.MediaProperties.MediaPropertySet;
		subtype: string;
		type: string;
		width: number
	}

	declare class MediaEncodingProfile  {
		createAvi(
		quality: Windows.Media.MediaProperties.VideoEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createFromFileAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
		createFromStreamAsync(
		stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
		createM4a(
		quality: Windows.Media.MediaProperties.AudioEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createMp3(
		quality: Windows.Media.MediaProperties.AudioEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createMp4(
		quality: Windows.Media.MediaProperties.VideoEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createWav(
		quality: Windows.Media.MediaProperties.AudioEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createWma(
		quality: Windows.Media.MediaProperties.AudioEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		createWmv(
		quality: Windows.Media.MediaProperties.VideoEncodingQuality
	): Windows.Media.MediaProperties.MediaEncodingProfile;
		constructor(): this;
		audio: Windows.Media.MediaProperties.AudioEncodingProperties;
		container: Windows.Media.MediaProperties.ContainerEncodingProperties;
		video: Windows.Media.MediaProperties.VideoEncodingProperties
	}

	declare class MediaEncodingSubtypes  {
		aac: string;
		aacAdts: string;
		ac3: string;
		amrNb: string;
		amrWb: string;
		argb32: string;
		asf: string;
		avi: string;
		bgra8: string;
		bmp: string;
		eac3: string;
		float: string;
		gif: string;
		h263: string;
		h264: string;
		h264Es: string;
		hevc: string;
		hevcEs: string;
		iyuv: string;
		jpeg: string;
		jpegXr: string;
		mjpg: string;
		mp3: string;
		mpeg: string;
		mpeg1: string;
		mpeg2: string;
		mpeg4: string;
		nv12: string;
		pcm: string;
		png: string;
		rgb24: string;
		rgb32: string;
		tiff: string;
		wave: string;
		wma8: string;
		wma9: string;
		wmv3: string;
		wvc1: string;
		yuy2: string;
		yv12: string
	}

	declare class MediaPropertySet  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, any>;
		hasKey(key: string): boolean;
		insert(key: string, value: any): boolean;
		lookup(key: string): any;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number
	}

	declare class MediaRatio  {
		denominator: number;
		numerator: number
	}

	declare class Mpeg2ProfileIds  {
		high: number;
		main: number;
		signalNoiseRatioScalable: number;
		simple: number;
		spatiallyScalable: number
	}

	declare class VideoEncodingProperties  {
		createH264(): Windows.Media.MediaProperties.VideoEncodingProperties;
		createMpeg2(): Windows.Media.MediaProperties.VideoEncodingProperties;
		createUncompressed(
		subtype: string, width: number, height: number
	): Windows.Media.MediaProperties.VideoEncodingProperties;
		constructor(): this;
		bitrate: number;
		frameRate: Windows.Media.MediaProperties.MediaRatio;
		getFormatUserData(): number[];
		height: number;
		pixelAspectRatio: Windows.Media.MediaProperties.MediaRatio;
		profileId: number;
		properties: Windows.Media.MediaProperties.MediaPropertySet;
		setFormatUserData(value: number[]): void;
		subtype: string;
		type: string;
		width: number
	}

	
}

declare module 'Ocr' {
				declare class OcrEngine  {
		availableRecognizerLanguages: Windows.Foundation.Collections.IVectorView<Windows.Globalization.Language>;
		isLanguageSupported(language: Windows.Globalization.Language): boolean;
		maxImageDimension: number;
		tryCreateFromLanguage(language: Windows.Globalization.Language): Windows.Media.Ocr.OcrEngine;
		tryCreateFromUserProfileLanguages(): Windows.Media.Ocr.OcrEngine;
		recognizeAsync(
		bitmap: Windows.Graphics.Imaging.SoftwareBitmap
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Ocr.OcrResult>;
		recognizerLanguage: Windows.Globalization.Language
	}

	declare class OcrLine  {
		text: string;
		words: Windows.Foundation.Collections.IVectorView<Windows.Media.Ocr.OcrWord>
	}

	declare class OcrResult  {
		lines: Windows.Foundation.Collections.IVectorView<Windows.Media.Ocr.OcrLine>;
		text: string;
		textAngle: number
	}

	declare class OcrWord  {
		boundingRect: Windows.Foundation.Rect;
		text: string
	}

	
}

declare module 'PlayTo' {
				declare class CurrentTimeChangeRequestedEventArgs  {
		time: number
	}

	declare class MuteChangeRequestedEventArgs  {
		mute: boolean
	}

	declare class PlayToConnection  {
		onerror: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>;
		addEventListener(
		type: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>
	): void;
		removeEventListener(
		type: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>
	): void;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>
	): void;
		ontransferred: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>;
		addEventListener(
		type: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>
	): void;
		removeEventListener(
		type: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection, Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>
	): void;
		state: Windows.Media.PlayTo.PlayToConnectionState;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PlayToConnectionErrorEventArgs  {
		code: Windows.Media.PlayTo.PlayToConnectionError;
		message: string
	}

	declare class PlayToConnectionStateChangedEventArgs  {
		currentState: Windows.Media.PlayTo.PlayToConnectionState;
		previousState: Windows.Media.PlayTo.PlayToConnectionState
	}

	declare class PlayToConnectionTransferredEventArgs  {
		currentSource: Windows.Media.PlayTo.PlayToSource;
		previousSource: Windows.Media.PlayTo.PlayToSource
	}

	declare class PlayToManager  {
		getForCurrentView(): Windows.Media.PlayTo.PlayToManager;
		showPlayToUI(): void;
		defaultSourceSelection: boolean;
		onsourcerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>;
		addEventListener(
		type: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>
	): void;
		removeEventListener(
		type: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>
	): void;
		onsourceselected: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>;
		addEventListener(
		type: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>
	): void;
		removeEventListener(
		type: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager, Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PlayToReceiver  {
		constructor(): this;
		friendlyName: string;
		notifyDurationChange(duration: number): void;
		notifyEnded(): void;
		notifyError(): void;
		notifyLoadedMetadata(): void;
		notifyPaused(): void;
		notifyPlaying(): void;
		notifyRateChange(rate: number): void;
		notifySeeked(): void;
		notifySeeking(): void;
		notifyStopped(): void;
		notifyTimeUpdate(currentTime: number): void;
		notifyVolumeChange(volume: number, mute: boolean): void;
		oncurrenttimechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>;
		addEventListener(
		type: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>
	): void;
		onmutechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.MuteChangeRequestedEventArgs>;
		addEventListener(
		type: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.MuteChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.MuteChangeRequestedEventArgs>
	): void;
		onpauserequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>;
		addEventListener(
		type: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		removeEventListener(
		type: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		onplaybackratechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>;
		addEventListener(
		type: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		removeEventListener(
		type: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		onplayrequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>;
		addEventListener(
		type: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		removeEventListener(
		type: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		onsourcechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.SourceChangeRequestedEventArgs>;
		addEventListener(
		type: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.SourceChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.SourceChangeRequestedEventArgs>
	): void;
		onstoprequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>;
		addEventListener(
		type: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		removeEventListener(
		type: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		ontimeupdaterequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>;
		addEventListener(
		type: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		removeEventListener(
		type: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, any>
	): void;
		onvolumechangerequested: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>;
		addEventListener(
		type: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>
	): void;
		removeEventListener(
		type: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver, Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>
	): void;
		properties: Windows.Foundation.Collections.IPropertySet;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		supportsAudio: boolean;
		supportsImage: boolean;
		supportsVideo: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PlayToSource  {
		connection: Windows.Media.PlayTo.PlayToConnection;
		next: Windows.Media.PlayTo.PlayToSource;
		playNext(): void;
		preferredSourceUri: Windows.Foundation.Uri
	}

	declare class PlayToSourceDeferral  {
		complete(): void
	}

	declare class PlayToSourceRequest  {
		deadline: Date;
		displayErrorString(errorString: string): void;
		getDeferral(): Windows.Media.PlayTo.PlayToSourceDeferral;
		setSource(value: Windows.Media.PlayTo.PlayToSource): void
	}

	declare class PlayToSourceRequestedEventArgs  {
		sourceRequest: Windows.Media.PlayTo.PlayToSourceRequest
	}

	declare class PlayToSourceSelectedEventArgs  {
		friendlyName: string;
		icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
		supportsAudio: boolean;
		supportsImage: boolean;
		supportsVideo: boolean
	}

	declare class PlaybackRateChangeRequestedEventArgs  {
		rate: number
	}

	declare class SourceChangeRequestedEventArgs  {
		album: string;
		author: string;
		date: Date;
		description: string;
		genre: string;
		properties: Windows.Foundation.Collections.IMapView<string, any>;
		rating: number;
		stream: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
		thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		title: string
	}

	declare class VolumeChangeRequestedEventArgs  {
		volume: number
	}

	
}

declare module 'Playback' {
		declare interface IMediaPlaybackSource {
		
	}

		declare class BackgroundMediaPlayer  {
		current: Windows.Media.Playback.MediaPlayer;
		isMediaPlaying(): boolean;
		onmessagereceivedfrombackground: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "messagereceivedfrombackground", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "messagereceivedfrombackground", listener: Windows.Foundation.EventHandler<any>
	): void;
		onmessagereceivedfromforeground: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "messagereceivedfromforeground", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "messagereceivedfromforeground", listener: Windows.Foundation.EventHandler<any>
	): void;
		sendMessageToBackground(value: Windows.Foundation.Collections.ValueSet): void;
		sendMessageToForeground(value: Windows.Foundation.Collections.ValueSet): void;
		shutdown(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class CurrentMediaPlaybackItemChangedEventArgs  {
		newItem: Windows.Media.Playback.MediaPlaybackItem;
		oldItem: Windows.Media.Playback.MediaPlaybackItem
	}

	declare class MediaPlaybackAudioTrackList extends Array<Windows.Media.Core.AudioTrack> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Media.Core.AudioTrack>;
		getAt(index: number): Windows.Media.Core.AudioTrack;
		getMany(
		startIndex: number
	): {
		items: Windows.Media.Core.AudioTrack,
		returnValue: number
	};
		indexOf(
		value: Windows.Media.Core.AudioTrack
	): {
		index: number,
		returnValue: boolean
	};
		onselectedindexchanged: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>;
		addEventListener(
		type: "selectedindexchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>
	): void;
		removeEventListener(
		type: "selectedindexchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>
	): void;
		selectedIndex: number;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		indexOf(
		value: Windows.Media.Core.AudioTrack, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Media.Core.AudioTrack, fromIndex?: number): number
	}

	declare class MediaPlaybackItem  {
		findFromMediaSource: any;
		constructor(source: Windows.Media.Core.MediaSource): this;
		audioTracks: Windows.Media.Playback.MediaPlaybackAudioTrackList;
		onaudiotrackschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>;
		addEventListener(
		type: "audiotrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		removeEventListener(
		type: "audiotrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		ontimedmetadatatrackschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>;
		addEventListener(
		type: "timedmetadatatrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		removeEventListener(
		type: "timedmetadatatrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		onvideotrackschanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>;
		addEventListener(
		type: "videotrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		removeEventListener(
		type: "videotrackschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackItem, Windows.Foundation.Collections.IVectorChangedEventArgs>
	): void;
		source: Windows.Media.Core.MediaSource;
		timedMetadataTracks: Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList;
		videoTracks: Windows.Media.Playback.MediaPlaybackVideoTrackList;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaPlaybackItemError  {
		errorCode: Windows.Media.Playback.MediaPlaybackItemErrorCode;
		extendedError: WinRTError
	}

	declare class MediaPlaybackItemFailedEventArgs  {
		error: Windows.Media.Playback.MediaPlaybackItemError;
		item: Windows.Media.Playback.MediaPlaybackItem
	}

	declare class MediaPlaybackItemOpenedEventArgs  {
		item: Windows.Media.Playback.MediaPlaybackItem
	}

	declare class MediaPlaybackList  {
		constructor(): this;
		autoRepeatEnabled: boolean;
		currentItem: Windows.Media.Playback.MediaPlaybackItem;
		currentItemIndex: number;
		items: Windows.Foundation.Collections.IObservableVector<Windows.Media.Playback.MediaPlaybackItem>;
		maxPrefetchTime: number;
		moveNext(): Windows.Media.Playback.MediaPlaybackItem;
		movePrevious(): Windows.Media.Playback.MediaPlaybackItem;
		moveTo(itemIndex: number): Windows.Media.Playback.MediaPlaybackItem;
		oncurrentitemchanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs>;
		addEventListener(
		type: "currentitemchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs>
	): void;
		removeEventListener(
		type: "currentitemchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.CurrentMediaPlaybackItemChangedEventArgs>
	): void;
		onitemfailed: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemFailedEventArgs>;
		addEventListener(
		type: "itemfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemFailedEventArgs>
	): void;
		removeEventListener(
		type: "itemfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemFailedEventArgs>
	): void;
		onitemopened: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs>;
		addEventListener(
		type: "itemopened", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs>
	): void;
		removeEventListener(
		type: "itemopened", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackList, Windows.Media.Playback.MediaPlaybackItemOpenedEventArgs>
	): void;
		setShuffledItems(
		value: Windows.Foundation.Collections.IIterable<Windows.Media.Playback.MediaPlaybackItem>
	): void;
		shuffleEnabled: boolean;
		shuffledItems: Windows.Foundation.Collections.IVectorView<Windows.Media.Playback.MediaPlaybackItem>;
		startingItem: Windows.Media.Playback.MediaPlaybackItem;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaPlaybackTimedMetadataTrackList extends Array<Windows.Media.Core.TimedMetadataTrack> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Media.Core.TimedMetadataTrack>;
		getAt(index: number): Windows.Media.Core.TimedMetadataTrack;
		getMany(
		startIndex: number
	): {
		items: Windows.Media.Core.TimedMetadataTrack,
		returnValue: number
	};
		getPresentationMode(index: number): Windows.Media.Playback.TimedMetadataTrackPresentationMode;
		indexOf(
		value: Windows.Media.Core.TimedMetadataTrack
	): {
		index: number,
		returnValue: boolean
	};
		onpresentationmodechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList, Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs>;
		addEventListener(
		type: "presentationmodechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList, Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs>
	): void;
		removeEventListener(
		type: "presentationmodechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlaybackTimedMetadataTrackList, Windows.Media.Playback.TimedMetadataPresentationModeChangedEventArgs>
	): void;
		setPresentationMode(
		index: number, value: Windows.Media.Playback.TimedMetadataTrackPresentationMode
	): void;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		indexOf(
		value: Windows.Media.Core.TimedMetadataTrack, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Media.Core.TimedMetadataTrack, fromIndex?: number
	): number
	}

	declare class MediaPlaybackVideoTrackList extends Array<Windows.Media.Core.VideoTrack> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Media.Core.VideoTrack>;
		getAt(index: number): Windows.Media.Core.VideoTrack;
		getMany(
		startIndex: number
	): {
		items: Windows.Media.Core.VideoTrack,
		returnValue: number
	};
		indexOf(
		value: Windows.Media.Core.VideoTrack
	): {
		index: number,
		returnValue: boolean
	};
		onselectedindexchanged: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>;
		addEventListener(
		type: "selectedindexchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>
	): void;
		removeEventListener(
		type: "selectedindexchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Core.ISingleSelectMediaTrackList, any>
	): void;
		selectedIndex: number;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		indexOf(
		value: Windows.Media.Core.VideoTrack, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Media.Core.VideoTrack, fromIndex?: number): number
	}

	declare class MediaPlayer  {
		addAudioEffect(
		activatableClassId: string, effectOptional: boolean, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		audioCategory: Windows.Media.Playback.MediaPlayerAudioCategory;
		audioDeviceType: Windows.Media.Playback.MediaPlayerAudioDeviceType;
		autoPlay: boolean;
		bufferingProgress: number;
		canPause: boolean;
		canSeek: boolean;
		currentState: Windows.Media.Playback.MediaPlayerState;
		isLoopingEnabled: boolean;
		isMuted: boolean;
		isProtected: boolean;
		naturalDuration: number;
		onbufferingended: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "bufferingended", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "bufferingended", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		onbufferingstarted: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "bufferingstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "bufferingstarted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		oncurrentstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "currentstatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "currentstatechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		onmediaended: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "mediaended", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "mediaended", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		onmediafailed: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerFailedEventArgs>;
		addEventListener(
		type: "mediafailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerFailedEventArgs>
	): void;
		removeEventListener(
		type: "mediafailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerFailedEventArgs>
	): void;
		onmediaopened: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "mediaopened", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "mediaopened", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		onmediaplayerratechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerRateChangedEventArgs>;
		addEventListener(
		type: "mediaplayerratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerRateChangedEventArgs>
	): void;
		removeEventListener(
		type: "mediaplayerratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.MediaPlayerRateChangedEventArgs>
	): void;
		onplaybackmediamarkerreached: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs>;
		addEventListener(
		type: "playbackmediamarkerreached", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs>
	): void;
		removeEventListener(
		type: "playbackmediamarkerreached", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, Windows.Media.Playback.PlaybackMediaMarkerReachedEventArgs>
	): void;
		onseekcompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "seekcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "seekcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		onvolumechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>;
		addEventListener(
		type: "volumechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		removeEventListener(
		type: "volumechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Playback.MediaPlayer, any>
	): void;
		pause(): void;
		play(): void;
		playbackMediaMarkers: Windows.Media.Playback.PlaybackMediaMarkerSequence;
		playbackRate: number;
		position: number;
		protectionManager: Windows.Media.Protection.MediaProtectionManager;
		removeAllEffects(): void;
		setFileSource(file: Windows.Storage.IStorageFile): void;
		setMediaSource(source: Windows.Media.Core.IMediaSource): void;
		setStreamSource(stream: Windows.Storage.Streams.IRandomAccessStream): void;
		setUriSource(value: Windows.Foundation.Uri): void;
		source: Windows.Media.Playback.IMediaPlaybackSource;
		systemMediaTransportControls: Windows.Media.SystemMediaTransportControls;
		volume: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaPlayerDataReceivedEventArgs  {
		data: Windows.Foundation.Collections.IMap<string, string>
	}

	declare class MediaPlayerFailedEventArgs  {
		error: Windows.Media.Playback.MediaPlayerError;
		errorMessage: string;
		extendedErrorCode: WinRTError
	}

	declare class MediaPlayerRateChangedEventArgs  {
		newRate: number
	}

	declare class PlaybackMediaMarker  {
		constructor(value: number, mediaMarketType: string, text: string): this;
		constructor(value: number): this;
		mediaMarkerType: string;
		text: string;
		time: number
	}

	declare class PlaybackMediaMarkerReachedEventArgs  {
		playbackMediaMarker: Windows.Media.Playback.PlaybackMediaMarker
	}

	declare class PlaybackMediaMarkerSequence  {
		constructor(): this;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Media.Playback.PlaybackMediaMarker>;
		insert(value: Windows.Media.Playback.PlaybackMediaMarker): void;
		size: number
	}

	declare class TimedMetadataPresentationModeChangedEventArgs  {
		newPresentationMode: Windows.Media.Playback.TimedMetadataTrackPresentationMode;
		oldPresentationMode: Windows.Media.Playback.TimedMetadataTrackPresentationMode;
		track: Windows.Media.Core.TimedMetadataTrack
	}

	
}

declare module 'Playlists' {
				declare class Playlist  {
		loadAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Playlists.Playlist>;
		constructor(): this;
		files: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFile>;
		saveAsAsync(
		saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption, playlistFormat: Windows.Media.Playlists.PlaylistFormat
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		saveAsAsync(
		saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction
	}

	
}

declare module 'Protection' {
	declare type ComponentLoadFailedEventHandler = (
		ev: Windows.Media.Protection.ComponentLoadFailedEventArgs & WinRTEvent<Windows.Media.Protection.MediaProtectionManager>
	) => void;

	declare type RebootNeededEventHandler = (ev: WinRTEvent<Windows.Media.Protection.MediaProtectionManager>) => void;

	declare type ServiceRequestedEventHandler = (
		ev: Windows.Media.Protection.ServiceRequestedEventArgs & WinRTEvent<Windows.Media.Protection.MediaProtectionManager>
	) => void;

	declare interface IMediaProtectionServiceRequest {
		protectionSystem: string,
		type: string
	}

		declare class ComponentLoadFailedEventArgs  {
		completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
		information: Windows.Media.Protection.RevocationAndRenewalInformation
	}

	declare class ComponentRenewal  {
		renewSystemComponentsAsync(
		information: Windows.Media.Protection.RevocationAndRenewalInformation
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Media.Protection.RenewalStatus, number>
	}

	declare class MediaProtectionManager  {
		constructor(): this;
		oncomponentloadfailed: Windows.Media.Protection.ComponentLoadFailedEventHandler;
		addEventListener(
		type: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler
	): void;
		removeEventListener(
		type: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler
	): void;
		onrebootneeded: Windows.Media.Protection.RebootNeededEventHandler;
		addEventListener(
		type: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler
	): void;
		removeEventListener(
		type: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler
	): void;
		onservicerequested: Windows.Media.Protection.ServiceRequestedEventHandler;
		addEventListener(
		type: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler
	): void;
		removeEventListener(
		type: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler
	): void;
		properties: Windows.Foundation.Collections.IPropertySet;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MediaProtectionPMPServer  {
		constructor(pProperties: Windows.Foundation.Collections.IPropertySet): this;
		properties: Windows.Foundation.Collections.IPropertySet
	}

	declare class MediaProtectionServiceCompletion  {
		complete(success: boolean): void
	}

	declare class ProtectionCapabilities  {
		isTypeSupported: any
	}

	declare class RevocationAndRenewalInformation  {
		items: Windows.Foundation.Collections.IVector<Windows.Media.Protection.RevocationAndRenewalItem>
	}

	declare class RevocationAndRenewalItem  {
		headerHash: string;
		name: string;
		publicKeyHash: string;
		reasons: Windows.Media.Protection.RevocationAndRenewalReasons;
		renewalId: string
	}

	declare class ServiceRequestedEventArgs  {
		completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
		mediaPlaybackItem: Windows.Media.Playback.MediaPlaybackItem;
		request: Windows.Media.Protection.IMediaProtectionServiceRequest
	}

	
}

declare module 'PlayReady' {
		declare interface INDLicenseFetchDescriptor {
		contentID: number,
		contentIDType: Windows.Media.Protection.PlayReady.NDContentIDType,
		licenseFetchChallengeCustomData: Windows.Media.Protection.PlayReady.INDCustomData
	}

	declare interface INDLicenseFetchResult {
		responseCustomData: Windows.Media.Protection.PlayReady.INDCustomData
	}

	declare interface INDClosedCaptionDataReceivedEventArgs {
		closedCaptionData: number,
		closedCaptionDataFormat: Windows.Media.Protection.PlayReady.NDClosedCaptionFormat,
		presentationTimestamp: number
	}

	declare interface INDLicenseFetchCompletedEventArgs {
		responseCustomData: Windows.Media.Protection.PlayReady.INDCustomData
	}

	declare interface INDProximityDetectionCompletedEventArgs {
		proximityDetectionRetryCount: number
	}

	declare interface INDRegistrationCompletedEventArgs {
		responseCustomData: Windows.Media.Protection.PlayReady.INDCustomData,
		transmitterCertificateAccepted: boolean,
		transmitterProperties: Windows.Media.Protection.PlayReady.INDTransmitterProperties
	}

	declare interface INDCustomData {
		customData: number,
		customDataTypeID: number
	}

	declare interface INDStartResult {
		mediaStreamSource: Windows.Media.Core.MediaStreamSource
	}

	declare interface INDDownloadEngine {
		close(): void,
		open(uri: Windows.Foundation.Uri, sessionIDBytes: Array<number>): void,
		pause(): void,
		resume(): void,
		seek(startPosition: number): void,
		bufferFullMaxThresholdInSamples: number,
		bufferFullMinThresholdInSamples: number,
		canSeek: boolean,
		notifier: Windows.Media.Protection.PlayReady.NDDownloadEngineNotifier
	}

	declare interface INDStreamParser {
		beginOfStream(): void,
		endOfStream(): void,
		getStreamInformation(
		descriptor: Windows.Media.Core.IMediaStreamDescriptor
	): {
		streamType: Windows.Media.Protection.PlayReady.NDMediaStreamType,
		returnValue: number
	},
		parseData(dataBytes: Array<number>): void,
		notifier: Windows.Media.Protection.PlayReady.NDStreamParserNotifier
	}

	declare interface INDMessenger {
		sendLicenseFetchRequestAsync(
		sessionIDBytes: Array<number>, challengeDataBytes: Array<number>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>,
		sendProximityDetectionResponseAsync(
		pdType: Windows.Media.Protection.PlayReady.NDProximityDetectionType, transmitterChannelBytes: Array<number>, sessionIDBytes: Array<number>, responseDataBytes: Array<number>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>,
		sendProximityDetectionStartAsync(
		pdType: Windows.Media.Protection.PlayReady.NDProximityDetectionType, transmitterChannelBytes: Array<number>, sessionIDBytes: Array<number>, challengeDataBytes: Array<number>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>,
		sendRegistrationRequestAsync(
		sessionIDBytes: Array<number>, challengeDataBytes: Array<number>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>
	}

	declare interface INDSendResult {
		response: number
	}

	declare interface IPlayReadyServiceRequest {
		beginServiceRequest(): Windows.Foundation.IAsyncAction,
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage,
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest,
		processManualEnablingResponse(responseBytes: Array<number>): WinRTError,
		challengeCustomData: string,
		responseCustomData: string,
		uri: Windows.Foundation.Uri
	}

	declare interface IPlayReadyDomain {
		accountId: string,
		domainJoinUrl: Windows.Foundation.Uri,
		friendlyName: string,
		revision: number,
		serviceId: string
	}

	declare interface IPlayReadyLicense {
		getKIDAtChainDepth(chainDepth: number): string,
		chainDepth: number,
		domainAccountID: string,
		expirationDate: Date,
		expireAfterFirstPlay: number,
		fullyEvaluated: boolean,
		usableForPlay: boolean
	}

	declare interface IPlayReadyLicenseAcquisitionServiceRequest {
		contentHeader: Windows.Media.Protection.PlayReady.PlayReadyContentHeader,
		domainServiceId: string
	}

	declare interface IPlayReadySecureStopServiceRequest {
		publisherCertificate: number,
		sessionID: string,
		startTime: Date,
		stopped: boolean,
		updateTime: Date
	}

	declare interface INDTransmitterProperties {
		certificateType: Windows.Media.Protection.PlayReady.NDCertificateType,
		clientID: number,
		expirationDate: Date,
		modelDigest: number,
		modelManufacturerName: string,
		modelName: string,
		modelNumber: string,
		platformIdentifier: Windows.Media.Protection.PlayReady.NDCertificatePlatformID,
		securityLevel: number,
		securityVersion: number,
		supportedFeatures: Windows.Media.Protection.PlayReady.NDCertificateFeature
	}

		declare class NDClient  {
		constructor(downloadEngine: Windows.Media.Protection.PlayReady.INDDownloadEngine, streamParser: Windows.Media.Protection.PlayReady.INDStreamParser, pMessenger: Windows.Media.Protection.PlayReady.INDMessenger): this;
		close(): void;
		licenseFetchAsync(
		licenseFetchDescriptor: Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDLicenseFetchResult>;
		onclosedcaptiondatareceived: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs>;
		addEventListener(
		type: "closedcaptiondatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "closedcaptiondatareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDClosedCaptionDataReceivedEventArgs>
	): void;
		onlicensefetchcompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs>;
		addEventListener(
		type: "licensefetchcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs>
	): void;
		removeEventListener(
		type: "licensefetchcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDLicenseFetchCompletedEventArgs>
	): void;
		onproximitydetectioncompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs>;
		addEventListener(
		type: "proximitydetectioncompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs>
	): void;
		removeEventListener(
		type: "proximitydetectioncompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDProximityDetectionCompletedEventArgs>
	): void;
		onregistrationcompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs>;
		addEventListener(
		type: "registrationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs>
	): void;
		removeEventListener(
		type: "registrationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, Windows.Media.Protection.PlayReady.INDRegistrationCompletedEventArgs>
	): void;
		onreregistrationneeded: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, any>;
		addEventListener(
		type: "reregistrationneeded", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, any>
	): void;
		removeEventListener(
		type: "reregistrationneeded", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Protection.PlayReady.NDClient, any>
	): void;
		reRegistrationAsync(
		registrationCustomData: Windows.Media.Protection.PlayReady.INDCustomData
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startAsync(
		contentUrl: Windows.Foundation.Uri, startAsyncOptions: number, registrationCustomData: Windows.Media.Protection.PlayReady.INDCustomData, licenseFetchDescriptor: Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDStartResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class NDCustomData  {
		constructor(customDataTypeIDBytes: number[], customDataBytes: number[]): this;
		customData: number;
		customDataTypeID: number
	}

	declare class NDDownloadEngineNotifier  {
		constructor(): this;
		onContentIDReceived(
		licenseFetchDescriptor: Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor
	): void;
		onDataReceived(dataBytes: number[], bytesReceived: number): void;
		onEndOfStream(): void;
		onNetworkError(): void;
		onPlayReadyObjectReceived(dataBytes: number[]): void;
		onStreamOpened(): void
	}

	declare class NDLicenseFetchDescriptor  {
		constructor(contentIDType: Windows.Media.Protection.PlayReady.NDContentIDType, contentIDBytes: number[], licenseFetchChallengeCustomData: Windows.Media.Protection.PlayReady.INDCustomData): this;
		contentID: number;
		contentIDType: Windows.Media.Protection.PlayReady.NDContentIDType;
		licenseFetchChallengeCustomData: Windows.Media.Protection.PlayReady.INDCustomData
	}

	declare class NDStorageFileHelper  {
		constructor(): this;
		getFileURLs(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.Collections.IVector<string>
	}

	declare class NDStreamParserNotifier  {
		constructor(): this;
		onBeginSetupDecryptor(
		descriptor: Windows.Media.Core.IMediaStreamDescriptor, keyID: string, proBytes: number[]
	): void;
		onContentIDReceived(
		licenseFetchDescriptor: Windows.Media.Protection.PlayReady.INDLicenseFetchDescriptor
	): void;
		onMediaStreamDescriptorCreated(
		audioStreamDescriptors: Windows.Foundation.Collections.IVector<Windows.Media.Core.AudioStreamDescriptor>, videoStreamDescriptors: Windows.Foundation.Collections.IVector<Windows.Media.Core.VideoStreamDescriptor>
	): void;
		onSampleParsed(
		streamID: number, streamType: Windows.Media.Protection.PlayReady.NDMediaStreamType, streamSample: Windows.Media.Core.MediaStreamSample, pts: number, ccFormat: Windows.Media.Protection.PlayReady.NDClosedCaptionFormat, ccDataBytes: number[]
	): void
	}

	declare class NDTCPMessenger  {
		constructor(remoteHostName: string, remoteHostPort: number): this;
		sendLicenseFetchRequestAsync(
		sessionIDBytes: number[], challengeDataBytes: number[]
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>;
		sendProximityDetectionResponseAsync(
		pdType: Windows.Media.Protection.PlayReady.NDProximityDetectionType, transmitterChannelBytes: number[], sessionIDBytes: number[], responseDataBytes: number[]
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>;
		sendProximityDetectionStartAsync(
		pdType: Windows.Media.Protection.PlayReady.NDProximityDetectionType, transmitterChannelBytes: number[], sessionIDBytes: number[], challengeDataBytes: number[]
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>;
		sendRegistrationRequestAsync(
		sessionIDBytes: number[], challengeDataBytes: number[]
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Protection.PlayReady.INDSendResult>
	}

	declare class PlayReadyContentHeader  {
		constructor(contentKeyId: string, contentKeyIdString: string, contentEncryptionAlgorithm: Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: Windows.Foundation.Uri, licenseAcquisitionUserInterfaceUrl: Windows.Foundation.Uri, customAttributes: string, domainServiceId: string): this;
		constructor(headerBytes: number[], licenseAcquisitionUrl: Windows.Foundation.Uri, licenseAcquisitionUserInterfaceUrl: Windows.Foundation.Uri, customAttributes: string, domainServiceId: string): this;
		constructor(dwFlags: number, contentKeyIds: string[], contentKeyIdStrings: string[], contentEncryptionAlgorithm: Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm, licenseAcquisitionUrl: Windows.Foundation.Uri, licenseAcquisitionUserInterfaceUrl: Windows.Foundation.Uri, customAttributes: string, domainServiceId: string): this;
		constructor(headerBytes: number[]): this;
		customAttributes: string;
		decryptorSetup: Windows.Media.Protection.PlayReady.PlayReadyDecryptorSetup;
		domainServiceId: string;
		encryptionType: Windows.Media.Protection.PlayReady.PlayReadyEncryptionAlgorithm;
		getSerializedHeader(): number[];
		headerWithEmbeddedUpdates: Windows.Media.Protection.PlayReady.PlayReadyContentHeader;
		keyId: string;
		keyIdString: string;
		keyIdStrings: string;
		keyIds: string;
		licenseAcquisitionUrl: Windows.Foundation.Uri;
		licenseAcquisitionUserInterfaceUrl: Windows.Foundation.Uri
	}

	declare class PlayReadyContentResolver  {
		serviceRequest(
		contentHeader: Windows.Media.Protection.PlayReady.PlayReadyContentHeader
	): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest
	}

	declare class PlayReadyDomain  {
		accountId: string;
		domainJoinUrl: Windows.Foundation.Uri;
		friendlyName: string;
		revision: number;
		serviceId: string
	}

	declare class PlayReadyDomainIterable  {
		constructor(domainAccountId: string): this;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Media.Protection.PlayReady.IPlayReadyDomain>
	}

	declare class PlayReadyDomainIterator  {
		current: Windows.Media.Protection.PlayReady.IPlayReadyDomain;
		getMany(
		
	): {
		items: Windows.Media.Protection.PlayReady.IPlayReadyDomain,
		returnValue: number
	};
		hasCurrent: boolean;
		moveNext(): boolean
	}

	declare class PlayReadyDomainJoinServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		domainAccountId: string;
		domainFriendlyName: string;
		domainServiceId: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyDomainLeaveServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		domainAccountId: string;
		domainServiceId: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyITADataGenerator  {
		constructor(): this;
		generateData(
		guidCPSystemId: string, countOfStreams: number, configuration: Windows.Foundation.Collections.IPropertySet, format: Windows.Media.Protection.PlayReady.PlayReadyITADataFormat
	): number[]
	}

	declare class PlayReadyIndividualizationServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyLicense  {
		chainDepth: number;
		domainAccountID: string;
		expirationDate: Date;
		expireAfterFirstPlay: number;
		fullyEvaluated: boolean;
		getKIDAtChainDepth(chainDepth: number): string;
		usableForPlay: boolean
	}

	declare class PlayReadyLicenseAcquisitionServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		contentHeader: Windows.Media.Protection.PlayReady.PlayReadyContentHeader;
		domainServiceId: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyLicenseIterable  {
		constructor(contentHeader: Windows.Media.Protection.PlayReady.PlayReadyContentHeader, fullyEvaluated: boolean): this;
		constructor(): this;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Media.Protection.PlayReady.IPlayReadyLicense>
	}

	declare class PlayReadyLicenseIterator  {
		current: Windows.Media.Protection.PlayReady.IPlayReadyLicense;
		getMany(
		
	): {
		items: Windows.Media.Protection.PlayReady.IPlayReadyLicense,
		returnValue: number
	};
		hasCurrent: boolean;
		moveNext(): boolean
	}

	declare class PlayReadyLicenseManagement  {
		deleteLicenses(
		contentHeader: Windows.Media.Protection.PlayReady.PlayReadyContentHeader
	): Windows.Foundation.IAsyncAction
	}

	declare class PlayReadyLicenseSession  {
		constructor(configuration: Windows.Foundation.Collections.IPropertySet): this;
		configureMediaProtectionManager(mpm: Windows.Media.Protection.MediaProtectionManager): void;
		createLAServiceRequest(
		
	): Windows.Media.Protection.PlayReady.IPlayReadyLicenseAcquisitionServiceRequest
	}

	declare class PlayReadyMeteringReportServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		meteringCertificate: number;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyRevocationServiceRequest  {
		constructor(): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		responseCustomData: string;
		type: string;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadySecureStopIterable  {
		constructor(publisherCertBytes: number[]): this;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest>
	}

	declare class PlayReadySecureStopIterator  {
		current: Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest;
		getMany(
		
	): {
		items: Windows.Media.Protection.PlayReady.IPlayReadySecureStopServiceRequest,
		returnValue: number
	};
		hasCurrent: boolean;
		moveNext(): boolean
	}

	declare class PlayReadySecureStopServiceRequest  {
		constructor(sessionID: string, publisherCertBytes: number[]): this;
		constructor(publisherCertBytes: number[]): this;
		beginServiceRequest(): Windows.Foundation.IAsyncAction;
		challengeCustomData: string;
		generateManualEnablingChallenge(): Windows.Media.Protection.PlayReady.PlayReadySoapMessage;
		nextServiceRequest(): Windows.Media.Protection.PlayReady.IPlayReadyServiceRequest;
		processManualEnablingResponse(responseBytes: number[]): WinRTError;
		protectionSystem: string;
		publisherCertificate: number;
		responseCustomData: string;
		sessionID: string;
		startTime: Date;
		stopped: boolean;
		type: string;
		updateTime: Date;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadySoapMessage  {
		getMessageBody(): number[];
		messageHeaders: Windows.Foundation.Collections.IPropertySet;
		uri: Windows.Foundation.Uri
	}

	declare class PlayReadyStatics  {
		checkSupportedHardware(
		hwdrmFeature: Windows.Media.Protection.PlayReady.PlayReadyHardwareDRMFeatures
	): boolean;
		domainJoinServiceRequestType: string;
		domainLeaveServiceRequestType: string;
		individualizationServiceRequestType: string;
		licenseAcquirerServiceRequestType: string;
		mediaProtectionSystemId: string;
		meteringReportServiceRequestType: string;
		playReadyCertificateSecurityLevel: number;
		playReadySecurityVersion: number;
		revocationServiceRequestType: string;
		secureStopServiceRequestType: string
	}

	
}

declare module 'SpeechRecognition' {
		declare interface ISpeechRecognitionConstraint {
		isEnabled: boolean,
		probability: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability,
		tag: string,
		type: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType
	}

		declare class SpeechContinuousRecognitionCompletedEventArgs  {
		status: Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus
	}

	declare class SpeechContinuousRecognitionResultGeneratedEventArgs  {
		result: Windows.Media.SpeechRecognition.SpeechRecognitionResult
	}

	declare class SpeechContinuousRecognitionSession  {
		autoStopSilenceTimeout: number;
		cancelAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		oncompleted: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs>;
		addEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs>
	): void;
		removeEventListener(
		type: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs>
	): void;
		onresultgenerated: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs>;
		addEventListener(
		type: "resultgenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs>
	): void;
		removeEventListener(
		type: "resultgenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession, Windows.Media.SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs>
	): void;
		pauseAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		resume(): void;
		startAsync(
		mode: Windows.Media.SpeechRecognition.SpeechContinuousRecognitionMode
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		stopAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SpeechRecognitionCompilationResult  {
		status: Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus
	}

	declare class SpeechRecognitionGrammarFileConstraint  {
		constructor(file: Windows.Storage.StorageFile): this;
		constructor(file: Windows.Storage.StorageFile, tag: string): this;
		grammarFile: Windows.Storage.StorageFile;
		isEnabled: boolean;
		probability: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability;
		tag: string;
		type: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType
	}

	declare class SpeechRecognitionHypothesis  {
		text: string
	}

	declare class SpeechRecognitionHypothesisGeneratedEventArgs  {
		hypothesis: Windows.Media.SpeechRecognition.SpeechRecognitionHypothesis
	}

	declare class SpeechRecognitionListConstraint  {
		constructor(commands: Windows.Foundation.Collections.IIterable<string>): this;
		constructor(commands: Windows.Foundation.Collections.IIterable<string>, tag: string): this;
		commands: Windows.Foundation.Collections.IVector<string>;
		isEnabled: boolean;
		probability: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability;
		tag: string;
		type: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType
	}

	declare class SpeechRecognitionQualityDegradingEventArgs  {
		problem: Windows.Media.SpeechRecognition.SpeechRecognitionAudioProblem
	}

	declare class SpeechRecognitionResult  {
		confidence: Windows.Media.SpeechRecognition.SpeechRecognitionConfidence;
		constraint: Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint;
		getAlternates(
		maxAlternates: number
	): Windows.Foundation.Collections.IVectorView<Windows.Media.SpeechRecognition.SpeechRecognitionResult>;
		phraseDuration: number;
		phraseStartTime: Date;
		rawConfidence: number;
		rulePath: Windows.Foundation.Collections.IVectorView<string>;
		semanticInterpretation: Windows.Media.SpeechRecognition.SpeechRecognitionSemanticInterpretation;
		status: Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus;
		text: string
	}

	declare class SpeechRecognitionSemanticInterpretation  {
		properties: Windows.Foundation.Collections.IMapView<string, Windows.Foundation.Collections.IVectorView<any>>
	}

	declare class SpeechRecognitionTopicConstraint  {
		constructor(scenario: Windows.Media.SpeechRecognition.SpeechRecognitionScenario, topicHint: string, tag: string): this;
		constructor(scenario: Windows.Media.SpeechRecognition.SpeechRecognitionScenario, topicHint: string): this;
		isEnabled: boolean;
		probability: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability;
		scenario: Windows.Media.SpeechRecognition.SpeechRecognitionScenario;
		tag: string;
		topicHint: string;
		type: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType
	}

	declare class SpeechRecognitionVoiceCommandDefinitionConstraint  {
		isEnabled: boolean;
		probability: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability;
		tag: string;
		type: Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType
	}

	declare class SpeechRecognizer  {
		supportedGrammarLanguages: Windows.Foundation.Collections.IVectorView<Windows.Globalization.Language>;
		supportedTopicLanguages: Windows.Foundation.Collections.IVectorView<Windows.Globalization.Language>;
		systemSpeechLanguage: Windows.Globalization.Language;
		constructor(): this;
		constructor(language: Windows.Globalization.Language): this;
		close(): void;
		compileConstraintsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult>;
		constraints: Windows.Foundation.Collections.IVector<Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint>;
		continuousRecognitionSession: Windows.Media.SpeechRecognition.SpeechContinuousRecognitionSession;
		currentLanguage: Windows.Globalization.Language;
		onhypothesisgenerated: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs>;
		addEventListener(
		type: "hypothesisgenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs>
	): void;
		removeEventListener(
		type: "hypothesisgenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs>
	): void;
		onrecognitionqualitydegrading: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs>;
		addEventListener(
		type: "recognitionqualitydegrading", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs>
	): void;
		removeEventListener(
		type: "recognitionqualitydegrading", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs>
	): void;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.SpeechRecognizer, Windows.Media.SpeechRecognition.SpeechRecognizerStateChangedEventArgs>
	): void;
		recognizeAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult>;
		recognizeWithUIAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult>;
		state: Windows.Media.SpeechRecognition.SpeechRecognizerState;
		stopRecognitionAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		timeouts: Windows.Media.SpeechRecognition.SpeechRecognizerTimeouts;
		uiOptions: Windows.Media.SpeechRecognition.SpeechRecognizerUIOptions;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SpeechRecognizerStateChangedEventArgs  {
		state: Windows.Media.SpeechRecognition.SpeechRecognizerState
	}

	declare class SpeechRecognizerTimeouts  {
		babbleTimeout: number;
		endSilenceTimeout: number;
		initialSilenceTimeout: number
	}

	declare class SpeechRecognizerUIOptions  {
		audiblePrompt: string;
		exampleText: string;
		isReadBackEnabled: boolean;
		showConfirmation: boolean
	}

	
}

declare module 'SpeechSynthesis' {
				declare class SpeechSynthesisStream  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		contentType: string;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		markers: Windows.Foundation.Collections.IVectorView<Windows.Media.IMediaMarker>;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class SpeechSynthesizer  {
		allVoices: Windows.Foundation.Collections.IVectorView<Windows.Media.SpeechSynthesis.VoiceInformation>;
		defaultVoice: Windows.Media.SpeechSynthesis.VoiceInformation;
		constructor(): this;
		close(): void;
		synthesizeSsmlToStreamAsync(
		Ssml: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.SpeechSynthesis.SpeechSynthesisStream>;
		synthesizeTextToStreamAsync(
		text: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.SpeechSynthesis.SpeechSynthesisStream>;
		voice: Windows.Media.SpeechSynthesis.VoiceInformation
	}

	declare class VoiceInformation  {
		description: string;
		displayName: string;
		gender: Windows.Media.SpeechSynthesis.VoiceGender;
		id: string;
		language: string
	}

	
}

declare module 'Adaptive' {
				declare class AdaptiveMediaSource  {
		createFromStreamAsync(
		stream: Windows.Storage.Streams.IInputStream, uri: Windows.Foundation.Uri, contentType: string, httpClient: Windows.Web.Http.HttpClient
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>;
		createFromStreamAsync(
		stream: Windows.Storage.Streams.IInputStream, uri: Windows.Foundation.Uri, contentType: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>;
		createFromUriAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>;
		createFromUriAsync(
		uri: Windows.Foundation.Uri, httpClient: Windows.Web.Http.HttpClient
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult>;
		isContentTypeSupported(contentType: string): boolean;
		advancedSettings: any;
		audioOnlyPlayback: boolean;
		availableBitrates: Windows.Foundation.Collections.IVectorView<number>;
		currentDownloadBitrate: number;
		currentPlaybackBitrate: number;
		desiredLiveOffset: number;
		desiredMaxBitrate: number;
		desiredMinBitrate: number;
		inboundBitsPerSecond: number;
		inboundBitsPerSecondWindow: number;
		initialBitrate: number;
		isLive: boolean;
		ondownloadbitratechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>;
		addEventListener(
		type: "downloadbitratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>
	): void;
		removeEventListener(
		type: "downloadbitratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs>
	): void;
		ondownloadcompleted: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs>;
		addEventListener(
		type: "downloadcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs>
	): void;
		removeEventListener(
		type: "downloadcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs>
	): void;
		ondownloadfailed: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs>;
		addEventListener(
		type: "downloadfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs>
	): void;
		removeEventListener(
		type: "downloadfailed", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs>
	): void;
		ondownloadrequested: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs>;
		addEventListener(
		type: "downloadrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs>
	): void;
		removeEventListener(
		type: "downloadrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs>
	): void;
		onplaybackbitratechanged: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>;
		addEventListener(
		type: "playbackbitratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>
	): void;
		removeEventListener(
		type: "playbackbitratechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.Streaming.Adaptive.AdaptiveMediaSource, Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AdaptiveMediaSourceAdvancedSettings  {
		allSegmentsIndependent: any;
		bitrateDowngradeTriggerRatio: any;
		desiredBitrateHeadroomRatio: any
	}

	declare class AdaptiveMediaSourceCreationResult  {
		httpResponseMessage: Windows.Web.Http.HttpResponseMessage;
		mediaSource: Windows.Media.Streaming.Adaptive.AdaptiveMediaSource;
		status: Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationStatus
	}

	declare class AdaptiveMediaSourceDownloadBitrateChangedEventArgs  {
		newValue: number;
		oldValue: number
	}

	declare class AdaptiveMediaSourceDownloadCompletedEventArgs  {
		httpResponseMessage: Windows.Web.Http.HttpResponseMessage;
		resourceByteRangeLength: number;
		resourceByteRangeOffset: number;
		resourceType: Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType;
		resourceUri: Windows.Foundation.Uri
	}

	declare class AdaptiveMediaSourceDownloadFailedEventArgs  {
		httpResponseMessage: Windows.Web.Http.HttpResponseMessage;
		resourceByteRangeLength: number;
		resourceByteRangeOffset: number;
		resourceType: Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType;
		resourceUri: Windows.Foundation.Uri
	}

	declare class AdaptiveMediaSourceDownloadRequestedDeferral  {
		complete(): void
	}

	declare class AdaptiveMediaSourceDownloadRequestedEventArgs  {
		getDeferral(
		
	): Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral;
		resourceByteRangeLength: number;
		resourceByteRangeOffset: number;
		resourceType: Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceResourceType;
		resourceUri: Windows.Foundation.Uri;
		result: Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult
	}

	declare class AdaptiveMediaSourceDownloadResult  {
		buffer: Windows.Storage.Streams.IBuffer;
		contentType: string;
		extendedStatus: number;
		inputStream: Windows.Storage.Streams.IInputStream;
		resourceUri: Windows.Foundation.Uri
	}

	declare class AdaptiveMediaSourcePlaybackBitrateChangedEventArgs  {
		audioOnly: boolean;
		newValue: number;
		oldValue: number
	}

	
}

declare module 'Transcoding' {
				declare class MediaTranscoder  {
		constructor(): this;
		addAudioEffect(
		activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		addAudioEffect(activatableClassId: string): void;
		addVideoEffect(activatableClassId: string): void;
		addVideoEffect(
		activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet
	): void;
		alwaysReencode: boolean;
		clearEffects(): void;
		hardwareAccelerationEnabled: boolean;
		prepareFileTranscodeAsync(
		source: Windows.Storage.IStorageFile, destination: Windows.Storage.IStorageFile, profile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
		prepareMediaStreamSourceTranscodeAsync(
		source: Windows.Media.Core.IMediaSource, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
		prepareStreamTranscodeAsync(
		source: Windows.Storage.Streams.IRandomAccessStream, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
		trimStartTime: number;
		trimStopTime: number;
		videoProcessingAlgorithm: Windows.Media.Transcoding.MediaVideoProcessingAlgorithm
	}

	declare class PrepareTranscodeResult  {
		canTranscode: boolean;
		failureReason: Windows.Media.Transcoding.TranscodeFailureReason;
		transcodeAsync(): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<number>
	}

	
}

declare module 'BackgroundTransfer' {
		declare interface BackgroundDownloadProgress {
		bytesReceived: number,
		hasResponseChanged: boolean,
		hasRestarted: boolean,
		status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus,
		totalBytesToReceive: number
	}

	declare interface BackgroundUploadProgress {
		bytesReceived: number,
		bytesSent: number,
		hasResponseChanged: boolean,
		hasRestarted: boolean,
		status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus,
		totalBytesToReceive: number,
		totalBytesToSend: number
	}

		declare class BackgroundDownloader  {
		getCurrentDownloadsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCurrentDownloadsAsync(
		group: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCurrentDownloadsForTransferGroupAsync(
		group: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		requestUnconstrainedDownloadsAsync(
		operations: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.DownloadOperation>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult>;
		constructor(): this;
		constructor(completionGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup): this;
		completionGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup;
		costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
		createDownload(
		uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile
	): Windows.Networking.BackgroundTransfer.DownloadOperation;
		createDownload(
		uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyFile: Windows.Storage.IStorageFile
	): Windows.Networking.BackgroundTransfer.DownloadOperation;
		createDownloadAsync(
		uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.DownloadOperation>;
		failureTileNotification: Windows.UI.Notifications.TileNotification;
		failureToastNotification: Windows.UI.Notifications.ToastNotification;
		group: string;
		method: string;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		setRequestHeader(headerName: string, headerValue: string): void;
		successTileNotification: Windows.UI.Notifications.TileNotification;
		successToastNotification: Windows.UI.Notifications.ToastNotification;
		transferGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	}

	declare class BackgroundTransferCompletionGroup  {
		constructor(): this;
		enable(): void;
		isEnabled: boolean;
		trigger: Windows.ApplicationModel.Background.IBackgroundTrigger
	}

	declare class BackgroundTransferCompletionGroupTriggerDetails  {
		downloads: Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.DownloadOperation>;
		uploads: Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.UploadOperation>
	}

	declare class BackgroundTransferContentPart  {
		constructor(): this;
		constructor(name: string, fileName: string): this;
		constructor(name: string): this;
		setFile(value: Windows.Storage.IStorageFile): void;
		setHeader(headerName: string, headerValue: string): void;
		setText(value: string): void
	}

	declare class BackgroundTransferError  {
		getStatus(hresult: number): Windows.Web.WebErrorStatus
	}

	declare class BackgroundTransferGroup  {
		createGroup(name: string): Windows.Networking.BackgroundTransfer.BackgroundTransferGroup;
		name: string;
		transferBehavior: Windows.Networking.BackgroundTransfer.BackgroundTransferBehavior
	}

	declare class BackgroundUploader  {
		getCurrentUploadsAsync(
		group: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCurrentUploadsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getCurrentUploadsForTransferGroupAsync(
		group: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		requestUnconstrainedUploadsAsync(
		operations: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.UploadOperation>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UnconstrainedTransferRequestResult>;
		constructor(): this;
		constructor(completionGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup): this;
		completionGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferCompletionGroup;
		costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
		createUpload(
		uri: Windows.Foundation.Uri, sourceFile: Windows.Storage.IStorageFile
	): Windows.Networking.BackgroundTransfer.UploadOperation;
		createUploadAsync(
		uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
		createUploadAsync(
		uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string, boundary: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
		createUploadAsync(
		uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
		createUploadFromStreamAsync(
		uri: Windows.Foundation.Uri, sourceStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
		failureTileNotification: Windows.UI.Notifications.TileNotification;
		failureToastNotification: Windows.UI.Notifications.ToastNotification;
		group: string;
		method: string;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		setRequestHeader(headerName: string, headerValue: string): void;
		successTileNotification: Windows.UI.Notifications.TileNotification;
		successToastNotification: Windows.UI.Notifications.ToastNotification;
		transferGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	}

	declare class ContentPrefetcher  {
		contentUris: Windows.Foundation.Collections.IVector<Windows.Foundation.Uri>;
		indirectContentUri: Windows.Foundation.Uri;
		lastSuccessfulPrefetchTime: Date
	}

	declare class DownloadOperation  {
		attachAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation, Windows.Networking.BackgroundTransfer.DownloadOperation>;
		costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
		getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
		getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		group: string;
		guid: string;
		method: string;
		pause(): void;
		priority: Windows.Networking.BackgroundTransfer.BackgroundTransferPriority;
		progress: Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress;
		requestedUri: Windows.Foundation.Uri;
		resultFile: Windows.Storage.IStorageFile;
		resume(): void;
		startAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation, Windows.Networking.BackgroundTransfer.DownloadOperation>;
		transferGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	}

	declare class ResponseInformation  {
		actualUri: Windows.Foundation.Uri;
		headers: Windows.Foundation.Collections.IMapView<string, string>;
		isResumable: boolean;
		statusCode: number
	}

	declare class UnconstrainedTransferRequestResult  {
		isUnconstrained: boolean
	}

	declare class UploadOperation  {
		attachAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation, Windows.Networking.BackgroundTransfer.UploadOperation>;
		costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
		getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
		getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		group: string;
		guid: string;
		method: string;
		priority: Windows.Networking.BackgroundTransfer.BackgroundTransferPriority;
		progress: Windows.Networking.BackgroundTransfer.BackgroundUploadProgress;
		requestedUri: Windows.Foundation.Uri;
		sourceFile: Windows.Storage.IStorageFile;
		startAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation, Windows.Networking.BackgroundTransfer.UploadOperation>;
		transferGroup: Windows.Networking.BackgroundTransfer.BackgroundTransferGroup
	}

	
}

declare module 'Connectivity' {
	declare type NetworkStatusChangedEventHandler = (ev: WinRTEvent<any>) => void;

	declare interface NetworkUsageStates {
		roaming: Windows.Networking.Connectivity.TriStates,
		shared: Windows.Networking.Connectivity.TriStates
	}

		declare class AttributedNetworkUsage  {
		attributionId: string;
		attributionName: string;
		attributionThumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
		bytesReceived: number;
		bytesSent: number
	}

	declare class CellularApnContext  {
		constructor(): this;
		accessPointName: string;
		authenticationType: Windows.Networking.Connectivity.CellularApnAuthenticationType;
		isCompressionEnabled: boolean;
		password: string;
		providerId: string;
		userName: string
	}

	declare class ConnectionCost  {
		approachingDataLimit: boolean;
		backgroundDataUsageRestricted: boolean;
		networkCostType: Windows.Networking.Connectivity.NetworkCostType;
		overDataLimit: boolean;
		roaming: boolean
	}

	declare class ConnectionProfile  {
		getAttributedNetworkUsageAsync(
		startTime: Date, endTime: Date, states: Windows.Networking.Connectivity.NetworkUsageStates
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getConnectionCost(): Windows.Networking.Connectivity.ConnectionCost;
		getConnectivityIntervalsAsync(
		startTime: Date, endTime: Date, states: Windows.Networking.Connectivity.NetworkUsageStates
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getDataPlanStatus(): Windows.Networking.Connectivity.DataPlanStatus;
		getDomainConnectivityLevel(): Windows.Networking.Connectivity.DomainConnectivityLevel;
		getLocalUsage(
		StartTime: Date, EndTime: Date, States: Windows.Networking.Connectivity.RoamingStates
	): Windows.Networking.Connectivity.DataUsage;
		getLocalUsage(StartTime: Date, EndTime: Date): Windows.Networking.Connectivity.DataUsage;
		getNetworkConnectivityLevel(): Windows.Networking.Connectivity.NetworkConnectivityLevel;
		getNetworkNames(): Windows.Foundation.Collections.IVectorView<string>;
		getNetworkUsageAsync(
		startTime: Date, endTime: Date, granularity: Windows.Networking.Connectivity.DataUsageGranularity, states: Windows.Networking.Connectivity.NetworkUsageStates
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getSignalBars(): number;
		isWlanConnectionProfile: boolean;
		isWwanConnectionProfile: boolean;
		networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
		networkSecuritySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
		profileName: string;
		serviceProviderGuid: string;
		wlanConnectionProfileDetails: Windows.Networking.Connectivity.WlanConnectionProfileDetails;
		wwanConnectionProfileDetails: Windows.Networking.Connectivity.WwanConnectionProfileDetails
	}

	declare class ConnectionProfileFilter  {
		constructor(): this;
		isBackgroundDataUsageRestricted: boolean;
		isConnected: boolean;
		isOverDataLimit: boolean;
		isRoaming: boolean;
		isWlanConnectionProfile: boolean;
		isWwanConnectionProfile: boolean;
		networkCostType: Windows.Networking.Connectivity.NetworkCostType;
		rawData: Windows.Storage.Streams.IBuffer;
		serviceProviderGuid: string
	}

	declare class ConnectionSession  {
		close(): void;
		connectionProfile: Windows.Networking.Connectivity.ConnectionProfile
	}

	declare class ConnectivityInterval  {
		connectionDuration: number;
		startTime: Date
	}

	declare class ConnectivityManager  {
		acquireConnectionAsync(
		CellularApnContext: Windows.Networking.Connectivity.CellularApnContext
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.Connectivity.ConnectionSession>;
		addHttpRoutePolicy(RoutePolicy: Windows.Networking.Connectivity.RoutePolicy): void;
		removeHttpRoutePolicy(RoutePolicy: Windows.Networking.Connectivity.RoutePolicy): void
	}

	declare class DataPlanStatus  {
		dataLimitInMegabytes: number;
		dataPlanUsage: Windows.Networking.Connectivity.DataPlanUsage;
		inboundBitsPerSecond: number;
		maxTransferSizeInMegabytes: number;
		nextBillingCycle: Date;
		outboundBitsPerSecond: number
	}

	declare class DataPlanUsage  {
		lastSyncTime: Date;
		megabytesUsed: number
	}

	declare class DataUsage  {
		bytesReceived: number;
		bytesSent: number
	}

	declare class IPInformation  {
		networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
		prefixLength: number
	}

	declare class LanIdentifier  {
		infrastructureId: Windows.Networking.Connectivity.LanIdentifierData;
		networkAdapterId: string;
		portId: Windows.Networking.Connectivity.LanIdentifierData
	}

	declare class LanIdentifierData  {
		type: number;
		value: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class NetworkAdapter  {
		getConnectedProfileAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile>;
		ianaInterfaceType: number;
		inboundMaxBitsPerSecond: number;
		networkAdapterId: string;
		networkItem: Windows.Networking.Connectivity.NetworkItem;
		outboundMaxBitsPerSecond: number
	}

	declare class NetworkInformation  {
		findConnectionProfilesAsync(
		pProfileFilter: Windows.Networking.Connectivity.ConnectionProfileFilter
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getConnectionProfiles(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile>;
		getHostNames(): Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName>;
		getInternetConnectionProfile(): Windows.Networking.Connectivity.ConnectionProfile;
		getLanIdentifiers(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.LanIdentifier>;
		getProxyConfigurationAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.Connectivity.ProxyConfiguration>;
		getSortedEndpointPairs(
		destinationList: Windows.Foundation.Collections.IIterable<Windows.Networking.EndpointPair>, sortOptions: Windows.Networking.HostNameSortOptions
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
		onnetworkstatuschanged: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler;
		addEventListener(
		type: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler
	): void;
		removeEventListener(
		type: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class NetworkItem  {
		getNetworkTypes(): Windows.Networking.Connectivity.NetworkTypes;
		networkId: string
	}

	declare class NetworkSecuritySettings  {
		networkAuthenticationType: Windows.Networking.Connectivity.NetworkAuthenticationType;
		networkEncryptionType: Windows.Networking.Connectivity.NetworkEncryptionType
	}

	declare class NetworkStateChangeEventDetails  {
		hasNewConnectionCost: boolean;
		hasNewDomainConnectivityLevel: boolean;
		hasNewHostNameList: boolean;
		hasNewInternetConnectionProfile: boolean;
		hasNewNetworkConnectivityLevel: boolean;
		hasNewTetheringClientCount: boolean;
		hasNewTetheringOperationalState: boolean;
		hasNewWwanRegistrationState: boolean
	}

	declare class NetworkUsage  {
		bytesReceived: number;
		bytesSent: number;
		connectionDuration: number
	}

	declare class ProxyConfiguration  {
		canConnectDirectly: boolean;
		proxyUris: Windows.Foundation.Collections.IVectorView<Windows.Foundation.Uri>
	}

	declare class RoutePolicy  {
		constructor(connectionProfile: Windows.Networking.Connectivity.ConnectionProfile, hostName: Windows.Networking.HostName, type: Windows.Networking.DomainNameType): this;
		connectionProfile: Windows.Networking.Connectivity.ConnectionProfile;
		hostName: Windows.Networking.HostName;
		hostNameType: Windows.Networking.DomainNameType
	}

	declare class WlanConnectionProfileDetails  {
		getConnectedSsid(): string
	}

	declare class WwanConnectionProfileDetails  {
		accessPointName: string;
		getCurrentDataClass(): Windows.Networking.Connectivity.WwanDataClass;
		getNetworkRegistrationState(): Windows.Networking.Connectivity.WwanNetworkRegistrationState;
		homeProviderId: string
	}

	
}

declare module 'Networking' {
				declare class EndpointPair  {
		constructor(localHostName: Windows.Networking.HostName, localServiceName: string, remoteHostName: Windows.Networking.HostName, remoteServiceName: string): this;
		localHostName: Windows.Networking.HostName;
		localServiceName: string;
		remoteHostName: Windows.Networking.HostName;
		remoteServiceName: string
	}

	declare class HostName  {
		compare(value1: string, value2: string): number;
		constructor(hostName: string): this;
		canonicalName: string;
		displayName: string;
		ipInformation: Windows.Networking.Connectivity.IPInformation;
		isEqual(hostName: Windows.Networking.HostName): boolean;
		rawName: string;
		type: Windows.Networking.HostNameType
	}

	
}

declare module 'NetworkOperators' {
		declare interface ProfileUsage {
		lastSyncTime: Date,
		usageInMegabytes: number
	}

		declare class HotspotAuthenticationContext  {
		tryGetAuthenticationContext(
		evenToken: string
	): {
		context: Windows.Networking.NetworkOperators.HotspotAuthenticationContext,
		returnValue: boolean
	};
		abortAuthentication(markAsManual: boolean): void;
		authenticationUrl: Windows.Foundation.Uri;
		issueCredentials(
		userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean
	): void;
		issueCredentialsAsync(
		userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.HotspotCredentialsAuthenticationResult>;
		networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
		redirectMessageUrl: Windows.Foundation.Uri;
		redirectMessageXml: Windows.Data.Xml.Dom.XmlDocument;
		skipAuthentication(): void;
		triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
		wirelessNetworkId: number
	}

	declare class HotspotAuthenticationEventDetails  {
		eventToken: string
	}

	declare class HotspotCredentialsAuthenticationResult  {
		authenticationReplyXml: Windows.Data.Xml.Dom.XmlDocument;
		hasNetworkErrorOccurred: boolean;
		logoffUrl: Windows.Foundation.Uri;
		responseCode: Windows.Networking.NetworkOperators.HotspotAuthenticationResponseCode
	}

	declare class KnownCSimFilePaths  {
		efSpn: Windows.Foundation.Collections.IVectorView<number>;
		gid1: Windows.Foundation.Collections.IVectorView<number>;
		gid2: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class KnownRuimFilePaths  {
		efSpn: Windows.Foundation.Collections.IVectorView<number>;
		gid1: Windows.Foundation.Collections.IVectorView<number>;
		gid2: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class KnownSimFilePaths  {
		efOns: Windows.Foundation.Collections.IVectorView<number>;
		efSpn: Windows.Foundation.Collections.IVectorView<number>;
		gid1: Windows.Foundation.Collections.IVectorView<number>;
		gid2: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class KnownUSimFilePaths  {
		efOpl: Windows.Foundation.Collections.IVectorView<number>;
		efPnn: Windows.Foundation.Collections.IVectorView<number>;
		efSpn: Windows.Foundation.Collections.IVectorView<number>;
		gid1: Windows.Foundation.Collections.IVectorView<number>;
		gid2: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class MobileBroadbandAccount  {
		availableNetworkAccountIds: Windows.Foundation.Collections.IVectorView<string>;
		createFromNetworkAccountId(
		networkAccountId: string
	): Windows.Networking.NetworkOperators.MobileBroadbandAccount;
		currentDeviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
		currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
		getConnectionProfiles(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile>;
		networkAccountId: string;
		serviceProviderGuid: string;
		serviceProviderName: string
	}

	declare class MobileBroadbandAccountEventArgs  {
		networkAccountId: string
	}

	declare class MobileBroadbandAccountUpdatedEventArgs  {
		hasDeviceInformationChanged: boolean;
		hasNetworkChanged: boolean;
		networkAccountId: string
	}

	declare class MobileBroadbandAccountWatcher  {
		constructor(): this;
		onaccountadded: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>;
		addEventListener(
		type: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>
	): void;
		removeEventListener(
		type: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>
	): void;
		onaccountremoved: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>;
		addEventListener(
		type: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>
	): void;
		removeEventListener(
		type: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>
	): void;
		onaccountupdated: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>;
		addEventListener(
		type: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>
	): void;
		removeEventListener(
		type: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher, any>
	): void;
		start(): void;
		status: Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MobileBroadbandDeviceInformation  {
		cellularClass: Windows.Devices.Sms.CellularClass;
		currentRadioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState;
		customDataClass: string;
		dataClasses: Windows.Networking.NetworkOperators.DataClasses;
		deviceId: string;
		deviceType: Windows.Networking.NetworkOperators.MobileBroadbandDeviceType;
		firmwareInformation: string;
		manufacturer: string;
		mobileEquipmentId: string;
		model: string;
		networkDeviceStatus: Windows.Networking.NetworkOperators.NetworkDeviceStatus;
		pinManager: Windows.Networking.NetworkOperators.MobileBroadbandPinManager;
		revision: string;
		serialNumber: string;
		simIccId: string;
		subscriberId: string;
		telephoneNumbers: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class MobileBroadbandDeviceService  {
		deviceServiceId: string;
		openCommandSession(
		
	): Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandSession;
		openDataSession(): Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession;
		supportedCommands: Windows.Foundation.Collections.IVectorView<number>
	}

	declare class MobileBroadbandDeviceServiceCommandResult  {
		responseData: Windows.Storage.Streams.IBuffer;
		statusCode: number
	}

	declare class MobileBroadbandDeviceServiceCommandSession  {
		closeSession(): void;
		sendQueryCommandAsync(
		commandId: number, data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult>;
		sendSetCommandAsync(
		commandId: number, data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceCommandResult>
	}

	declare class MobileBroadbandDeviceServiceDataReceivedEventArgs  {
		receivedData: Windows.Storage.Streams.IBuffer
	}

	declare class MobileBroadbandDeviceServiceDataSession  {
		closeSession(): void;
		ondatareceived: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession, Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs>;
		addEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession, Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs>
	): void;
		removeEventListener(
		type: "datareceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataSession, Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs>
	): void;
		writeDataAsync(
		value: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class MobileBroadbandDeviceServiceInformation  {
		deviceServiceId: string;
		isDataReadSupported: boolean;
		isDataWriteSupported: boolean
	}

	declare class MobileBroadbandDeviceServiceTriggerDetails  {
		deviceId: string;
		deviceServiceId: string;
		receivedData: Windows.Storage.Streams.IBuffer
	}

	declare class MobileBroadbandModem  {
		fromId(deviceId: string): Windows.Networking.NetworkOperators.MobileBroadbandModem;
		getDefault(): Windows.Networking.NetworkOperators.MobileBroadbandModem;
		getDeviceSelector(): string;
		currentAccount: Windows.Networking.NetworkOperators.MobileBroadbandAccount;
		currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
		deviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
		deviceServices: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandDeviceServiceInformation>;
		getCurrentConfigurationAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandModemConfiguration>;
		getDeviceService(
		deviceServiceId: string
	): Windows.Networking.NetworkOperators.MobileBroadbandDeviceService;
		isResetSupported: boolean;
		maxDeviceServiceCommandSizeInBytes: number;
		maxDeviceServiceDataSizeInBytes: number;
		resetAsync(): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class MobileBroadbandModemConfiguration  {
		homeProviderId: string;
		homeProviderName: string;
		uicc: Windows.Networking.NetworkOperators.MobileBroadbandUicc
	}

	declare class MobileBroadbandNetwork  {
		accessPointName: string;
		activationNetworkError: number;
		getVoiceCallSupportAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
		networkRegistrationState: Windows.Networking.NetworkOperators.NetworkRegistrationState;
		packetAttachNetworkError: number;
		registeredDataClass: Windows.Networking.NetworkOperators.DataClasses;
		registeredProviderId: string;
		registeredProviderName: string;
		registrationNetworkError: number;
		registrationUiccApps: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandUiccApp>;
		showConnectionUI(): void
	}

	declare class MobileBroadbandNetworkRegistrationStateChange  {
		deviceId: string;
		network: Windows.Networking.NetworkOperators.MobileBroadbandNetwork
	}

	declare class MobileBroadbandNetworkRegistrationStateChangeTriggerDetails  {
		networkRegistrationStateChanges: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandNetworkRegistrationStateChange>
	}

	declare class MobileBroadbandPin  {
		attemptsRemaining: number;
		changeAsync(
		currentPin: string, newPin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>;
		disableAsync(
		currentPin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>;
		enableAsync(
		currentPin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>;
		enabled: boolean;
		enterAsync(
		currentPin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>;
		format: Windows.Networking.NetworkOperators.MobileBroadbandPinFormat;
		lockState: Windows.Networking.NetworkOperators.MobileBroadbandPinLockState;
		maxLength: number;
		minLength: number;
		type: Windows.Networking.NetworkOperators.MobileBroadbandPinType;
		unblockAsync(
		pinUnblockKey: string, newPin: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandPinOperationResult>
	}

	declare class MobileBroadbandPinLockStateChange  {
		deviceId: string;
		pinLockState: Windows.Networking.NetworkOperators.MobileBroadbandPinLockState;
		pinType: Windows.Networking.NetworkOperators.MobileBroadbandPinType
	}

	declare class MobileBroadbandPinLockStateChangeTriggerDetails  {
		pinLockStateChanges: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandPinLockStateChange>
	}

	declare class MobileBroadbandPinManager  {
		getPin(
		pinType: Windows.Networking.NetworkOperators.MobileBroadbandPinType
	): Windows.Networking.NetworkOperators.MobileBroadbandPin;
		supportedPins: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandPinType>
	}

	declare class MobileBroadbandPinOperationResult  {
		attemptsRemaining: number;
		isSuccessful: boolean
	}

	declare class MobileBroadbandRadioStateChange  {
		deviceId: string;
		radioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState
	}

	declare class MobileBroadbandRadioStateChangeTriggerDetails  {
		radioStateChanges: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandRadioStateChange>
	}

	declare class MobileBroadbandUicc  {
		getUiccAppsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandUiccAppsResult>;
		simIccId: string
	}

	declare class MobileBroadbandUiccApp  {
		getRecordDetailsAsync(
		uiccFilePath: Windows.Foundation.Collections.IIterable<number>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult>;
		id: Windows.Storage.Streams.IBuffer;
		kind: Windows.Networking.NetworkOperators.UiccAppKind;
		readRecordAsync(
		uiccFilePath: Windows.Foundation.Collections.IIterable<number>, recordIndex: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.MobileBroadbandUiccAppReadRecordResult>
	}

	declare class MobileBroadbandUiccAppReadRecordResult  {
		data: Windows.Storage.Streams.IBuffer;
		status: Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus
	}

	declare class MobileBroadbandUiccAppRecordDetailsResult  {
		kind: Windows.Networking.NetworkOperators.UiccAppRecordKind;
		readAccessCondition: Windows.Networking.NetworkOperators.UiccAccessCondition;
		recordCount: number;
		recordSize: number;
		status: Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus;
		writeAccessCondition: Windows.Networking.NetworkOperators.UiccAccessCondition
	}

	declare class MobileBroadbandUiccAppsResult  {
		status: Windows.Networking.NetworkOperators.MobileBroadbandUiccAppOperationStatus;
		uiccApps: Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.MobileBroadbandUiccApp>
	}

	declare class NetworkOperatorNotificationEventDetails  {
		authorizeTethering(allow: boolean, entitlementFailureReason: string): void;
		encodingType: number;
		message: string;
		networkAccountId: string;
		notificationType: Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType;
		ruleId: string;
		smsMessage: Windows.Devices.Sms.ISmsMessage
	}

	declare class NetworkOperatorTetheringAccessPointConfiguration  {
		constructor(): this;
		passphrase: string;
		ssid: string
	}

	declare class NetworkOperatorTetheringClient  {
		hostNames: Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName>;
		macAddress: string
	}

	declare class NetworkOperatorTetheringManager  {
		createFromConnectionProfile(
		profile: Windows.Networking.Connectivity.ConnectionProfile
	): Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager;
		createFromNetworkAccountId(
		networkAccountId: string
	): Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager;
		getTetheringCapability(
		networkAccountId: string
	): Windows.Networking.NetworkOperators.TetheringCapability;
		getTetheringCapabilityFromConnectionProfile(
		profile: Windows.Networking.Connectivity.ConnectionProfile
	): Windows.Networking.NetworkOperators.TetheringCapability;
		clientCount: number;
		configureAccessPointAsync(
		configuration: Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration
	): Windows.Foundation.IPromiseWithIAsyncAction;
		getCurrentAccessPointConfiguration(
		
	): Windows.Networking.NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration;
		getTetheringClients(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.NetworkOperators.NetworkOperatorTetheringClient>;
		maxClientCount: number;
		startTetheringAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult>;
		stopTetheringAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.NetworkOperatorTetheringOperationResult>;
		tetheringOperationalState: Windows.Networking.NetworkOperators.TetheringOperationalState
	}

	declare class NetworkOperatorTetheringOperationResult  {
		additionalErrorMessage: string;
		status: Windows.Networking.NetworkOperators.TetheringOperationStatus
	}

	declare class ProvisionFromXmlDocumentResults  {
		allElementsProvisioned: boolean;
		provisionResultsXml: string
	}

	declare class ProvisionedProfile  {
		updateCost(value: Windows.Networking.Connectivity.NetworkCostType): void;
		updateUsage(value: Windows.Networking.NetworkOperators.ProfileUsage): void
	}

	declare class ProvisioningAgent  {
		createFromNetworkAccountId(
		networkAccountId: string
	): Windows.Networking.NetworkOperators.ProvisioningAgent;
		constructor(): this;
		getProvisionedProfile(
		mediaType: Windows.Networking.NetworkOperators.ProfileMediaType, profileName: string
	): Windows.Networking.NetworkOperators.ProvisionedProfile;
		provisionFromXmlDocumentAsync(
		provisioningXmlDocument: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>
	}

	declare class UssdMessage  {
		constructor(messageText: string): this;
		dataCodingScheme: number;
		getPayload(): number[];
		payloadAsText: string;
		setPayload(value: number[]): void
	}

	declare class UssdReply  {
		message: Windows.Networking.NetworkOperators.UssdMessage;
		resultCode: Windows.Networking.NetworkOperators.UssdResultCode
	}

	declare class UssdSession  {
		createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.UssdSession;
		createFromNetworkInterfaceId(networkInterfaceId: string): Windows.Networking.NetworkOperators.UssdSession;
		close(): void;
		sendMessageAndGetReplyAsync(
		message: Windows.Networking.NetworkOperators.UssdMessage
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.NetworkOperators.UssdReply>
	}

	
}

declare module 'Proximity' {
	declare type DeviceArrivedEventHandler = (ev: WinRTEvent<Windows.Networking.Proximity.ProximityDevice>) => void;

	declare type DeviceDepartedEventHandler = (ev: WinRTEvent<Windows.Networking.Proximity.ProximityDevice>) => void;

	declare type MessageTransmittedHandler = (
		sender: Windows.Networking.Proximity.ProximityDevice, messageId: number
	) => void;

	declare type MessageReceivedHandler = (
		sender: Windows.Networking.Proximity.ProximityDevice, message: Windows.Networking.Proximity.ProximityMessage
	) => void;

			declare class ConnectionRequestedEventArgs  {
		peerInformation: Windows.Networking.Proximity.PeerInformation
	}

	declare class PeerFinder  {
		allowBluetooth: boolean;
		allowInfrastructure: boolean;
		allowWiFiDirect: boolean;
		alternateIdentities: Windows.Foundation.Collections.IMap<string, string>;
		connectAsync(
		peerInformation: Windows.Networking.Proximity.PeerInformation
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.Sockets.StreamSocket>;
		createWatcher(): Windows.Networking.Proximity.PeerWatcher;
		discoveryData: Windows.Storage.Streams.IBuffer;
		displayName: string;
		findAllPeersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		onconnectionrequested: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.ConnectionRequestedEventArgs>;
		addEventListener(
		type: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.ConnectionRequestedEventArgs>
	): void;
		removeEventListener(
		type: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.ConnectionRequestedEventArgs>
	): void;
		ontriggeredconnectionstatechanged: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>;
		addEventListener(
		type: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any, Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>
	): void;
		role: Windows.Networking.Proximity.PeerRole;
		start(peerMessage: string): void;
		start(): void;
		stop(): void;
		supportedDiscoveryTypes: Windows.Networking.Proximity.PeerDiscoveryTypes;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PeerInformation  {
		discoveryData: Windows.Storage.Streams.IBuffer;
		displayName: string;
		hostName: Windows.Networking.HostName;
		id: string;
		serviceName: string
	}

	declare class PeerWatcher  {
		onadded: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>;
		addEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		removeEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>
	): void;
		onremoved: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>;
		addEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		removeEventListener(
		type: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, any>
	): void;
		onupdated: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>;
		addEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		removeEventListener(
		type: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Proximity.PeerWatcher, Windows.Networking.Proximity.PeerInformation>
	): void;
		start(): void;
		status: Windows.Networking.Proximity.PeerWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ProximityDevice  {
		fromId(deviceId: string): Windows.Networking.Proximity.ProximityDevice;
		getDefault(): Windows.Networking.Proximity.ProximityDevice;
		getDeviceSelector(): string;
		bitsPerSecond: number;
		deviceId: string;
		maxMessageBytes: number;
		ondevicearrived: Windows.Networking.Proximity.DeviceArrivedEventHandler;
		addEventListener(
		type: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler
	): void;
		removeEventListener(
		type: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler
	): void;
		ondevicedeparted: Windows.Networking.Proximity.DeviceDepartedEventHandler;
		addEventListener(
		type: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler
	): void;
		removeEventListener(
		type: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler
	): void;
		publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer): number;
		publishBinaryMessage(
		messageType: string, message: Windows.Storage.Streams.IBuffer, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler
	): number;
		publishMessage(messageType: string, message: string): number;
		publishMessage(
		messageType: string, message: string, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler
	): number;
		publishUriMessage(
		message: Windows.Foundation.Uri, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler
	): number;
		publishUriMessage(message: Windows.Foundation.Uri): number;
		stopPublishingMessage(messageId: number): void;
		stopSubscribingForMessage(subscriptionId: number): void;
		subscribeForMessage(
		messageType: string, messageReceivedHandler: Windows.Networking.Proximity.MessageReceivedHandler
	): number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ProximityMessage  {
		data: Windows.Storage.Streams.IBuffer;
		dataAsString: string;
		messageType: string;
		subscriptionId: number
	}

	declare class TriggeredConnectionStateChangedEventArgs  {
		id: number;
		socket: Windows.Networking.Sockets.StreamSocket;
		state: Windows.Networking.Proximity.TriggeredConnectState
	}

	
}

declare module 'PushNotifications' {
				declare class PushNotificationChannel  {
		close(): void;
		expirationTime: Date;
		onpushnotificationreceived: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel, Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>;
		addEventListener(
		type: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel, Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>
	): void;
		removeEventListener(
		type: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel, Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>
	): void;
		uri: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PushNotificationChannelManager  {
		createPushNotificationChannelForApplicationAsync(
		applicationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
		createPushNotificationChannelForApplicationAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
		createPushNotificationChannelForSecondaryTileAsync(
		tileId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>
	}

	declare class PushNotificationReceivedEventArgs  {
		badgeNotification: Windows.UI.Notifications.BadgeNotification;
		cancel: boolean;
		notificationType: Windows.Networking.PushNotifications.PushNotificationType;
		rawNotification: any;
		tileNotification: Windows.UI.Notifications.TileNotification;
		toastNotification: Windows.UI.Notifications.ToastNotification
	}

	declare class RawNotification  {
		content: string
	}

	
}

declare module 'Dnssd' {
				declare class DnssdRegistrationResult  {
		constructor(): this;
		hasInstanceNameChanged: boolean;
		ipAddress: Windows.Networking.HostName;
		status: Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationStatus
	}

	declare class DnssdServiceInstance  {
		constructor(DnssdServiceInstanceName: string, hostName: Windows.Networking.HostName, port: number): this;
		dnssdServiceInstanceName: string;
		hostName: Windows.Networking.HostName;
		port: number;
		priority: number;
		registerDatagramSocketAsync(
		socket: Windows.Networking.Sockets.DatagramSocket, adapter: Windows.Networking.Connectivity.NetworkAdapter
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>;
		registerDatagramSocketAsync(
		socket: Windows.Networking.Sockets.DatagramSocket
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>;
		registerStreamSocketListenerAsync(
		socket: Windows.Networking.Sockets.StreamSocketListener, adapter: Windows.Networking.Connectivity.NetworkAdapter
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>;
		registerStreamSocketListenerAsync(
		socket: Windows.Networking.Sockets.StreamSocketListener
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.ServiceDiscovery.Dnssd.DnssdRegistrationResult>;
		textAttributes: Windows.Foundation.Collections.IMap<string, string>;
		weight: number
	}

	declare class DnssdServiceInstanceCollection extends Array<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance>;
		getAt(index: number): Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance;
		getMany(
		startIndex: number
	): {
		items: Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance,
		returnValue: number
	};
		indexOf(
		value: Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance, fromIndex?: number
	): number
	}

	declare class DnssdServiceWatcher  {
		onadded: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance>;
		addEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance>
	): void;
		removeEventListener(
		type: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceInstance>
	): void;
		onenumerationcompleted: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>;
		addEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>
	): void;
		removeEventListener(
		type: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>
	): void;
		onstopped: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>;
		addEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>
	): void;
		removeEventListener(
		type: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcher, any>
	): void;
		start(): void;
		status: Windows.Networking.ServiceDiscovery.Dnssd.DnssdServiceWatcherStatus;
		stop(): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'XboxLive' {
				declare class XboxLiveDeviceAddress  {
		createFromSnapshotBase64(base64: string): Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		createFromSnapshotBuffer(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		createFromSnapshotBytes(buffer: number[]): Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		getLocal(): Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		maxSnapshotBytesSize: number;
		compare(otherDeviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress): number;
		getSnapshotAsBase64(): string;
		getSnapshotAsBuffer(): Windows.Storage.Streams.IBuffer;
		getSnapshotAsBytes(): {
		buffer: number[],
		bytesWritten: number
	};
		isLocal: boolean;
		isValid: boolean;
		networkAccessKind: Windows.Networking.XboxLive.XboxLiveNetworkAccessKind;
		onsnapshotchanged: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveDeviceAddress, any>;
		addEventListener(
		type: "snapshotchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveDeviceAddress, any>
	): void;
		removeEventListener(
		type: "snapshotchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveDeviceAddress, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class XboxLiveEndpointPair  {
		findEndpointPairByHostNamesAndPorts(
		localHostName: Windows.Networking.HostName, localPort: string, remoteHostName: Windows.Networking.HostName, remotePort: string
	): Windows.Networking.XboxLive.XboxLiveEndpointPair;
		findEndpointPairBySocketAddressBytes(
		localSocketAddress: number[], remoteSocketAddress: number[]
	): Windows.Networking.XboxLive.XboxLiveEndpointPair;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		getLocalSocketAddressBytes(): number[];
		getRemoteSocketAddressBytes(): number[];
		localHostName: Windows.Networking.HostName;
		localPort: string;
		onstatechanged: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPair, Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs>;
		addEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPair, Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs>
	): void;
		removeEventListener(
		type: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPair, Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs>
	): void;
		remoteDeviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		remoteHostName: Windows.Networking.HostName;
		remotePort: string;
		state: Windows.Networking.XboxLive.XboxLiveEndpointPairState;
		template: Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class XboxLiveEndpointPairCreationResult  {
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		endpointPair: Windows.Networking.XboxLive.XboxLiveEndpointPair;
		isExistingPathEvaluation: boolean;
		status: Windows.Networking.XboxLive.XboxLiveEndpointPairCreationStatus
	}

	declare class XboxLiveEndpointPairStateChangedEventArgs  {
		newState: Windows.Networking.XboxLive.XboxLiveEndpointPairState;
		oldState: Windows.Networking.XboxLive.XboxLiveEndpointPairState
	}

	declare class XboxLiveEndpointPairTemplate  {
		getTemplateByName(name: string): Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate;
		templates: Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate>;
		acceptorBoundPortRangeLower: number;
		acceptorBoundPortRangeUpper: number;
		createEndpointPairAsync(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress, behaviors: Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>;
		createEndpointPairAsync(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>;
		createEndpointPairForPortsAsync(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress, initiatorPort: string, acceptorPort: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>;
		createEndpointPairForPortsAsync(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress, initiatorPort: string, acceptorPort: string, behaviors: Windows.Networking.XboxLive.XboxLiveEndpointPairCreationBehaviors
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult>;
		endpointPairs: Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveEndpointPair>;
		initiatorBoundPortRangeLower: number;
		initiatorBoundPortRangeUpper: number;
		name: string;
		oninboundendpointpaircreated: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate, Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs>;
		addEventListener(
		type: "inboundendpointpaircreated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate, Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs>
	): void;
		removeEventListener(
		type: "inboundendpointpaircreated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate, Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs>
	): void;
		socketKind: Windows.Networking.XboxLive.XboxLiveSocketKind;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class XboxLiveInboundEndpointPairCreatedEventArgs  {
		endpointPair: Windows.Networking.XboxLive.XboxLiveEndpointPair
	}

	declare class XboxLiveQualityOfServiceMeasurement  {
		clearPrivatePayload(): void;
		isSystemInboundBandwidthConstrained: boolean;
		isSystemOutboundBandwidthConstrained: boolean;
		maxPrivatePayloadSize: number;
		maxSimultaneousProbeConnections: number;
		publishPrivatePayloadBytes(payload: number[]): void;
		publishedPrivatePayload: Windows.Storage.Streams.IBuffer;
		constructor(): this;
		deviceAddresses: Windows.Foundation.Collections.IVector<Windows.Networking.XboxLive.XboxLiveDeviceAddress>;
		getMetricResult(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress, metric: Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric
	): Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult;
		getMetricResultsForDevice(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>;
		getMetricResultsForMetric(
		metric: Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric
	): Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>;
		getPrivatePayloadResult(
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress
	): Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult;
		measureAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		metricResults: Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult>;
		metrics: Windows.Foundation.Collections.IVector<Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric>;
		numberOfProbesToAttempt: number;
		numberOfResultsPending: number;
		privatePayloadResults: Windows.Foundation.Collections.IVectorView<Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult>;
		shouldRequestPrivatePayloads: boolean;
		timeoutInMilliseconds: number
	}

	declare class XboxLiveQualityOfServiceMetricResult  {
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		metric: Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetric;
		status: Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus;
		value: number
	}

	declare class XboxLiveQualityOfServicePrivatePayloadResult  {
		deviceAddress: Windows.Networking.XboxLive.XboxLiveDeviceAddress;
		status: Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurementStatus;
		value: Windows.Storage.Streams.IBuffer
	}

	
}

declare module 'People' {
				declare class HeadPose  {
		forwardDirection: any;
		position: any;
		upDirection: any
	}

	
}

declare module 'Spatial' {
				declare class SpatialAnchor  {
		tryCreateRelativeTo: any;
		addEventListener: any;
		coordinateSystem: any;
		onrawcoordinatesystemadjusted: any;
		rawCoordinateSystem: any;
		removeEventListener: any
	}

	declare class SpatialAnchorManager  {
		requestStoreAsync: any
	}

	declare class SpatialAnchorRawCoordinateSystemAdjustedEventArgs  {
		oldRawCoordinateSystemToNewRawCoordinateSystemTransform: any
	}

	declare class SpatialAnchorStore  {
		clear: any;
		getAllSavedAnchors: any;
		remove: any;
		trySave: any
	}

	declare class SpatialAnchorTransferManager  {
		requestAccessAsync: any;
		tryExportAnchorsAsync: any;
		tryImportAnchorsAsync: any
	}

	declare class SpatialBoundingVolume  {
		fromBox: any;
		fromFrustum: any;
		fromOrientedBox: any;
		fromSphere: any
	}

	declare class SpatialCoordinateSystem  {
		tryGetTransformTo: any
	}

	declare class SpatialLocation  {
		absoluteAngularAcceleration: any;
		absoluteAngularVelocity: any;
		absoluteLinearAcceleration: any;
		absoluteLinearVelocity: any;
		orientation: any;
		position: any
	}

	declare class SpatialLocator  {
		getDefault: any;
		addEventListener: any;
		createAttachedFrameOfReferenceAtCurrentHeading: any;
		createStationaryFrameOfReferenceAtCurrentLocation: any;
		locatability: any;
		onlocatabilitychanged: any;
		onpositionaltrackingdeactivating: any;
		removeEventListener: any;
		tryLocateAtTimestamp: any
	}

	declare class SpatialLocatorAttachedFrameOfReference  {
		adjustHeading: any;
		getStationaryCoordinateSystemAtTimestamp: any;
		relativeOrientation: any;
		relativePosition: any;
		tryGetRelativeHeadingAtTimestamp: any
	}

	declare class SpatialLocatorPositionalTrackingDeactivatingEventArgs  {
		canceled: any
	}

	declare class SpatialStationaryFrameOfReference  {
		coordinateSystem: any
	}

	declare class SpatialGestureRecognizer  {
		addEventListener: any;
		cancelPendingGestures: any;
		captureInteraction: any;
		gestureSettings: any;
		onholdcanceled: any;
		onholdcompleted: any;
		onholdstarted: any;
		onmanipulationcanceled: any;
		onmanipulationcompleted: any;
		onmanipulationstarted: any;
		onmanipulationupdated: any;
		onnavigationcanceled: any;
		onnavigationcompleted: any;
		onnavigationstarted: any;
		onnavigationupdated: any;
		onrecognitionended: any;
		onrecognitionstarted: any;
		ontapped: any;
		removeEventListener: any;
		trySetGestureSettings: any
	}

	declare class SpatialHoldCanceledEventArgs  {
		interactionSourceKind: any
	}

	declare class SpatialHoldCompletedEventArgs  {
		interactionSourceKind: any
	}

	declare class SpatialHoldStartedEventArgs  {
		interactionSourceKind: any;
		tryGetPointerPose: any
	}

	declare class SpatialInteraction  {
		sourceState: any
	}

	declare class SpatialInteractionDetectedEventArgs  {
		interaction: any;
		interactionSourceKind: any;
		tryGetPointerPose: any
	}

	declare class SpatialInteractionManager  {
		getForCurrentView: any;
		addEventListener: any;
		getDetectedSourcesAtTimestamp: any;
		oninteractiondetected: any;
		onsourcedetected: any;
		onsourcelost: any;
		onsourcepressed: any;
		onsourcereleased: any;
		onsourceupdated: any;
		removeEventListener: any
	}

	declare class SpatialInteractionSource  {
		id: any;
		kind: any
	}

	declare class SpatialInteractionSourceEventArgs  {
		state: any
	}

	declare class SpatialInteractionSourceLocation  {
		position: any;
		velocity: any
	}

	declare class SpatialInteractionSourceProperties  {
		sourceLossRisk: any;
		tryGetLocation: any;
		tryGetSourceLossMitigationDirection: any
	}

	declare class SpatialInteractionSourceState  {
		isPressed: any;
		properties: any;
		source: any;
		timestamp: any;
		tryGetPointerPose: any
	}

	declare class SpatialManipulationCanceledEventArgs  {
		interactionSourceKind: any
	}

	declare class SpatialManipulationCompletedEventArgs  {
		interactionSourceKind: any;
		tryGetCumulativeDelta: any
	}

	declare class SpatialManipulationDelta  {
		translation: any
	}

	declare class SpatialManipulationStartedEventArgs  {
		interactionSourceKind: any;
		tryGetPointerPose: any
	}

	declare class SpatialManipulationUpdatedEventArgs  {
		interactionSourceKind: any;
		tryGetCumulativeDelta: any
	}

	declare class SpatialNavigationCanceledEventArgs  {
		interactionSourceKind: any
	}

	declare class SpatialNavigationCompletedEventArgs  {
		interactionSourceKind: any;
		normalizedOffset: any
	}

	declare class SpatialNavigationStartedEventArgs  {
		interactionSourceKind: any;
		isNavigatingX: any;
		isNavigatingY: any;
		isNavigatingZ: any;
		tryGetPointerPose: any
	}

	declare class SpatialNavigationUpdatedEventArgs  {
		interactionSourceKind: any;
		normalizedOffset: any
	}

	declare class SpatialPointerPose  {
		tryGetAtTimestamp: any;
		head: any;
		timestamp: any
	}

	declare class SpatialRecognitionEndedEventArgs  {
		interactionSourceKind: any
	}

	declare class SpatialRecognitionStartedEventArgs  {
		interactionSourceKind: any;
		isGesturePossible: any;
		tryGetPointerPose: any
	}

	declare class SpatialTappedEventArgs  {
		interactionSourceKind: any;
		tapCount: any;
		tryGetPointerPose: any
	}

	
}

declare module 'Surfaces' {
				declare class SpatialSurfaceInfo  {
		id: any;
		tryComputeLatestMeshAsync: any;
		tryGetBounds: any;
		updateTime: any
	}

	declare class SpatialSurfaceMesh  {
		coordinateSystem: any;
		surfaceInfo: any;
		triangleIndices: any;
		vertexNormals: any;
		vertexPositionScale: any;
		vertexPositions: any
	}

	declare class SpatialSurfaceMeshBuffer  {
		data: any;
		elementCount: any;
		format: any;
		stride: any
	}

	declare class SpatialSurfaceMeshOptions  {
		supportedTriangleIndexFormats: any;
		supportedVertexNormalFormats: any;
		supportedVertexPositionFormats: any;
		includeVertexNormals: any;
		triangleIndexFormat: any;
		vertexNormalFormat: any;
		vertexPositionFormat: any
	}

	declare class SpatialSurfaceObserver  {
		requestAccessAsync: any;
		addEventListener: any;
		getObservedSurfaces: any;
		onobservedsurfaceschanged: any;
		removeEventListener: any;
		setBoundingVolume: any;
		setBoundingVolumes: any
	}

	
}

declare module 'OnlineId' {
				declare class OnlineIdAuthenticator  {
		constructor(): this;
		applicationId: string;
		authenticateUserAsync(
		request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Security.Authentication.OnlineId.UserAuthenticationOperation>;
		authenticateUserAsync(
		requests: Windows.Foundation.Collections.IIterable<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>, credentialPromptType: Windows.Security.Authentication.OnlineId.CredentialPromptType
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Security.Authentication.OnlineId.UserAuthenticationOperation>;
		authenticatedSafeCustomerId: string;
		canSignOut: boolean;
		signOutUserAsync(
		
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Security.Authentication.OnlineId.SignOutUserOperation>
	}

	declare class OnlineIdServiceTicket  {
		errorCode: number;
		request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
		value: string
	}

	declare class OnlineIdServiceTicketRequest  {
		constructor(service: string, policy: string): this;
		constructor(service: string): this;
		policy: string;
		service: string
	}

	declare class SignOutUserOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncActionCompletedHandler;
		errorCode: WinRTError;
		getResults(): void;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class UserAuthenticationOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Security.Authentication.OnlineId.UserIdentity>;
		errorCode: WinRTError;
		getResults(): Windows.Security.Authentication.OnlineId.UserIdentity;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class UserIdentity  {
		firstName: string;
		id: string;
		isBetaAccount: boolean;
		isConfirmedPC: boolean;
		lastName: string;
		safeCustomerId: string;
		signInName: string;
		tickets: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>
	}

	
}

declare module 'Web' {
				declare class WebAuthenticationBroker  {
		authenticateAndContinue(requestUri: Windows.Foundation.Uri, callbackUri: Windows.Foundation.Uri): void;
		authenticateAndContinue(requestUri: Windows.Foundation.Uri): void;
		authenticateAndContinue(
		requestUri: Windows.Foundation.Uri, callbackUri: Windows.Foundation.Uri, continuationData: Windows.Foundation.Collections.ValueSet, options: Windows.Security.Authentication.Web.WebAuthenticationOptions
	): void;
		authenticateAsync(
		options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri, callbackUri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
		authenticateAsync(
		options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
		authenticateSilentlyAsync(
		requestUri: Windows.Foundation.Uri, options: Windows.Security.Authentication.Web.WebAuthenticationOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
		authenticateSilentlyAsync(
		requestUri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
		getCurrentApplicationCallbackUri(): Windows.Foundation.Uri
	}

	declare class WebAuthenticationResult  {
		responseData: string;
		responseErrorDetail: number;
		responseStatus: Windows.Security.Authentication.Web.WebAuthenticationStatus
	}

	declare class WebError  {
		getStatus(hresult: number): Windows.Web.WebErrorStatus
	}

	
}

declare module 'Credentials' {
				declare class KeyCredential  {
		getAttestationAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.KeyCredentialAttestationResult>;
		name: string;
		requestSignAsync(
		data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.KeyCredentialOperationResult>;
		retrievePublicKey(): Windows.Storage.Streams.IBuffer;
		retrievePublicKey(
		blobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType
	): Windows.Storage.Streams.IBuffer
	}

	declare class KeyCredentialAttestationResult  {
		attestationBuffer: Windows.Storage.Streams.IBuffer;
		certificateChainBuffer: Windows.Storage.Streams.IBuffer;
		status: Windows.Security.Credentials.KeyCredentialAttestationStatus
	}

	declare class KeyCredentialManager  {
		deleteAsync(name: string): Windows.Foundation.IPromiseWithIAsyncAction;
		isSupportedAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		openAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.KeyCredentialRetrievalResult>;
		renewAttestationAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		requestCreateAsync(
		name: string, option: Windows.Security.Credentials.KeyCredentialCreationOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Credentials.KeyCredentialRetrievalResult>
	}

	declare class KeyCredentialOperationResult  {
		result: Windows.Storage.Streams.IBuffer;
		status: Windows.Security.Credentials.KeyCredentialStatus
	}

	declare class KeyCredentialRetrievalResult  {
		credential: Windows.Security.Credentials.KeyCredential;
		status: Windows.Security.Credentials.KeyCredentialStatus
	}

	declare class PasswordCredential  {
		constructor(resource: string, userName: string, password: string): this;
		constructor(): this;
		password: string;
		properties: Windows.Foundation.Collections.IPropertySet;
		resource: string;
		retrievePassword(): void;
		userName: string
	}

	declare class PasswordCredentialPropertyStore  {
		constructor(): this;
		clear(): void;
		first(): any;
		getView(): any;
		hasKey(key: string): any;
		insert(key: string, value: any): any;
		lookup(key: string): any;
		onmapchanged: Windows.Foundation.Collections.MapChangedEventHandler<string, any>;
		addEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		removeEventListener(
		type: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string, any>
	): void;
		remove(key: string): void;
		size: number;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class PasswordVault  {
		constructor(): this;
		add(credential: Windows.Security.Credentials.PasswordCredential): void;
		findAllByResource(
		resource: string
	): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
		findAllByUserName(
		userName: string
	): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
		remove(credential: Windows.Security.Credentials.PasswordCredential): void;
		retrieve(
		resource: string, userName: string
	): Windows.Security.Credentials.PasswordCredential;
		retrieveAll(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>
	}

	declare class WebAccount  {
		constructor(webAccountProvider: Windows.Security.Credentials.WebAccountProvider, userName: string, state: Windows.Security.Credentials.WebAccountState): this;
		getPictureAsync(
		desizedSize: Windows.Security.Credentials.WebAccountPictureSize
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		id: string;
		properties: Windows.Foundation.Collections.IMapView<string, string>;
		signOutAsync(clientId: string): Windows.Foundation.IPromiseWithIAsyncAction;
		signOutAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		state: Windows.Security.Credentials.WebAccountState;
		userName: string;
		webAccountProvider: Windows.Security.Credentials.WebAccountProvider
	}

	declare class WebAccountProvider  {
		constructor(id: string, displayName: string, iconUri: Windows.Foundation.Uri): this;
		authority: string;
		displayName: string;
		displayPurpose: string;
		iconUri: Windows.Foundation.Uri;
		id: string;
		user: Windows.System.User
	}

	
}

declare module 'Certificates' {
				declare class Certificate  {
		constructor(certBlob: Windows.Storage.Streams.IBuffer): this;
		buildChainAsync(
		certificates: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.Certificate>, parameters: Windows.Security.Cryptography.Certificates.ChainBuildingParameters
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Cryptography.Certificates.CertificateChain>;
		buildChainAsync(
		certificates: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.Certificate>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Cryptography.Certificates.CertificateChain>;
		enhancedKeyUsages: Windows.Foundation.Collections.IVectorView<string>;
		friendlyName: string;
		getCertificateBlob(): Windows.Storage.Streams.IBuffer;
		getHashValue(hashAlgorithmName: string): number[];
		getHashValue(): number[];
		hasPrivateKey: boolean;
		isSecurityDeviceBound: boolean;
		isStronglyProtected: boolean;
		issuer: string;
		keyAlgorithmName: string;
		keyUsages: Windows.Security.Cryptography.Certificates.CertificateKeyUsages;
		serialNumber: number;
		signatureAlgorithmName: string;
		signatureHashAlgorithmName: string;
		subject: string;
		subjectAlternativeName: Windows.Security.Cryptography.Certificates.SubjectAlternativeNameInfo;
		validFrom: Date;
		validTo: Date
	}

	declare class CertificateChain  {
		getCertificates(
		includeRoot: boolean
	): Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		validate(): Windows.Security.Cryptography.Certificates.ChainValidationResult;
		validate(
		parameter: Windows.Security.Cryptography.Certificates.ChainValidationParameters
	): Windows.Security.Cryptography.Certificates.ChainValidationResult
	}

	declare class CertificateEnrollmentManager  {
		createRequestAsync(
		request: Windows.Security.Cryptography.Certificates.CertificateRequestProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		importPfxDataAsync(
		pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		importPfxDataAsync(
		pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string, keyStorageProvider: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		importPfxDataAsync(
		pfxData: string, password: string, pfxImportParameters: Windows.Security.Cryptography.Certificates.PfxImportParameters
	): Windows.Foundation.IPromiseWithIAsyncAction;
		installCertificateAsync(
		certificate: string, installOption: Windows.Security.Cryptography.Certificates.InstallOptions
	): Windows.Foundation.IPromiseWithIAsyncAction;
		userCertificateEnrollmentManager: Windows.Security.Cryptography.Certificates.UserCertificateEnrollmentManager
	}

	declare class CertificateKeyUsages  {
		constructor(): this;
		crlSign: boolean;
		dataEncipherment: boolean;
		digitalSignature: boolean;
		encipherOnly: boolean;
		keyAgreement: boolean;
		keyCertificateSign: boolean;
		keyEncipherment: boolean;
		nonRepudiation: boolean
	}

	declare class CertificateQuery  {
		constructor(): this;
		enhancedKeyUsages: Windows.Foundation.Collections.IVector<string>;
		friendlyName: string;
		hardwareOnly: boolean;
		includeDuplicates: boolean;
		includeExpiredCertificates: boolean;
		issuerName: string;
		storeName: string;
		thumbprint: number
	}

	declare class CertificateRequestProperties  {
		constructor(): this;
		attestationCredentialCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		containerName: string;
		containerNamePrefix: string;
		curveName: string;
		curveParameters: number;
		exportable: Windows.Security.Cryptography.Certificates.ExportOption;
		friendlyName: string;
		hashAlgorithmName: string;
		keyAlgorithmName: string;
		keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
		keySize: number;
		keyStorageProviderName: string;
		keyUsages: Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
		signingCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		smartcardReaderName: string;
		subject: string;
		useExistingKey: boolean
	}

	declare class CertificateStore  {
		add(certificate: Windows.Security.Cryptography.Certificates.Certificate): void;
		delete(certificate: Windows.Security.Cryptography.Certificates.Certificate): void;
		name: string
	}

	declare class CertificateStores  {
		findAllAsync(
		query: Windows.Security.Cryptography.Certificates.CertificateQuery
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getStoreByName(storeName: string): Windows.Security.Cryptography.Certificates.CertificateStore;
		intermediateCertificationAuthorities: Windows.Security.Cryptography.Certificates.CertificateStore;
		trustedRootCertificationAuthorities: Windows.Security.Cryptography.Certificates.CertificateStore
	}

	declare class ChainBuildingParameters  {
		constructor(): this;
		authorityInformationAccessEnabled: boolean;
		currentTimeValidationEnabled: boolean;
		enhancedKeyUsages: Windows.Foundation.Collections.IVector<string>;
		exclusiveTrustRoots: Windows.Foundation.Collections.IVector<Windows.Security.Cryptography.Certificates.Certificate>;
		networkRetrievalEnabled: boolean;
		revocationCheckEnabled: boolean;
		validationTimestamp: Date
	}

	declare class ChainValidationParameters  {
		constructor(): this;
		certificateChainPolicy: Windows.Security.Cryptography.Certificates.CertificateChainPolicy;
		serverDnsName: Windows.Networking.HostName
	}

	declare class CmsAttachedSignature  {
		generateSignatureAsync(
		data: Windows.Storage.Streams.IBuffer, signers: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.CmsSignerInfo>, certificates: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.Certificate>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		constructor(inputBlob: Windows.Storage.Streams.IBuffer): this;
		certificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		content: number;
		signers: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.CmsSignerInfo>;
		verifySignature(): Windows.Security.Cryptography.Certificates.SignatureValidationResult
	}

	declare class CmsDetachedSignature  {
		generateSignatureAsync(
		data: Windows.Storage.Streams.IInputStream, signers: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.CmsSignerInfo>, certificates: Windows.Foundation.Collections.IIterable<Windows.Security.Cryptography.Certificates.Certificate>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		constructor(inputBlob: Windows.Storage.Streams.IBuffer): this;
		certificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		signers: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.CmsSignerInfo>;
		verifySignatureAsync(
		data: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.Cryptography.Certificates.SignatureValidationResult>
	}

	declare class CmsSignerInfo  {
		constructor(): this;
		certificate: Windows.Security.Cryptography.Certificates.Certificate;
		hashAlgorithmName: string;
		timestampInfo: Windows.Security.Cryptography.Certificates.CmsTimestampInfo
	}

	declare class CmsTimestampInfo  {
		certificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>;
		signingCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		timestamp: Date
	}

	declare class KeyAlgorithmNames  {
		dsa: string;
		ecdh: string;
		ecdh256: string;
		ecdh384: string;
		ecdh521: string;
		ecdsa: string;
		ecdsa256: string;
		ecdsa384: string;
		ecdsa521: string;
		rsa: string
	}

	declare class KeyAttestationHelper  {
		decryptTpmAttestationCredentialAsync(credential: string): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		decryptTpmAttestationCredentialAsync(
		credential: string, containerName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getTpmAttestationCredentialId(credential: string): string
	}

	declare class KeyStorageProviderNames  {
		passportKeyStorageProvider: string;
		platformKeyStorageProvider: string;
		smartcardKeyStorageProvider: string;
		softwareKeyStorageProvider: string
	}

	declare class PfxImportParameters  {
		constructor(): this;
		containerNamePrefix: string;
		exportable: Windows.Security.Cryptography.Certificates.ExportOption;
		friendlyName: string;
		installOptions: Windows.Security.Cryptography.Certificates.InstallOptions;
		keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
		keyStorageProviderName: string;
		readerName: string
	}

	declare class SubjectAlternativeNameInfo  {
		constructor(): this;
		distinguishedName: Windows.Foundation.Collections.IVectorView<string>;
		dnsName: Windows.Foundation.Collections.IVectorView<string>;
		emailName: Windows.Foundation.Collections.IVectorView<string>;
		ipAddress: Windows.Foundation.Collections.IVectorView<string>;
		principalName: Windows.Foundation.Collections.IVectorView<string>;
		url: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class UserCertificateEnrollmentManager  {
		createRequestAsync(
		request: Windows.Security.Cryptography.Certificates.CertificateRequestProperties
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		importPfxDataAsync(
		pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		importPfxDataAsync(
		pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string, keyStorageProvider: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		importPfxDataAsync(
		pfxData: string, password: string, pfxImportParameters: Windows.Security.Cryptography.Certificates.PfxImportParameters
	): Windows.Foundation.IPromiseWithIAsyncAction;
		installCertificateAsync(
		certificate: string, installOption: Windows.Security.Cryptography.Certificates.InstallOptions
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	
}

declare module 'Cryptography' {
				declare class CryptographicBuffer  {
		compare(
		object1: Windows.Storage.Streams.IBuffer, object2: Windows.Storage.Streams.IBuffer
	): boolean;
		convertBinaryToString(
		encoding: Windows.Security.Cryptography.BinaryStringEncoding, buffer: Windows.Storage.Streams.IBuffer
	): string;
		convertStringToBinary(
		value: string, encoding: Windows.Security.Cryptography.BinaryStringEncoding
	): Windows.Storage.Streams.IBuffer;
		copyToByteArray(buffer: Windows.Storage.Streams.IBuffer): number[];
		createFromByteArray(value: number[]): Windows.Storage.Streams.IBuffer;
		decodeFromBase64String(value: string): Windows.Storage.Streams.IBuffer;
		decodeFromHexString(value: string): Windows.Storage.Streams.IBuffer;
		encodeToBase64String(buffer: Windows.Storage.Streams.IBuffer): string;
		encodeToHexString(buffer: Windows.Storage.Streams.IBuffer): string;
		generateRandom(length: number): Windows.Storage.Streams.IBuffer;
		generateRandomNumber(): number
	}

	
}

declare module 'DataProtection' {
				declare class DataProtectionProvider  {
		constructor(protectionDescriptor: string): this;
		constructor(): this;
		protectAsync(
		data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		protectStreamAsync(
		src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		unprotectAsync(
		data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IBuffer>;
		unprotectStreamAsync(
		src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	
}

declare module 'EnterpriseData' {
				declare class BufferProtectUnprotectResult  {
		buffer: Windows.Storage.Streams.IBuffer;
		protectionInfo: Windows.Security.EnterpriseData.DataProtectionInfo
	}

	declare class DataProtectionInfo  {
		identity: string;
		status: Windows.Security.EnterpriseData.DataProtectionStatus
	}

	declare class DataProtectionManager  {
		getProtectionInfoAsync(
		protectedData: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.DataProtectionInfo>;
		getStreamProtectionInfoAsync(
		protectedStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.DataProtectionInfo>;
		protectAsync(
		data: Windows.Storage.Streams.IBuffer, identity: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.BufferProtectUnprotectResult>;
		protectStreamAsync(
		unprotectedStream: Windows.Storage.Streams.IInputStream, identity: string, protectedStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.DataProtectionInfo>;
		unprotectAsync(
		data: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.BufferProtectUnprotectResult>;
		unprotectStreamAsync(
		protectedStream: Windows.Storage.Streams.IInputStream, unprotectedStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.DataProtectionInfo>
	}

	declare class FileProtectionInfo  {
		identity: string;
		isRoamable: boolean;
		status: Windows.Security.EnterpriseData.FileProtectionStatus
	}

	declare class FileProtectionManager  {
		copyProtectionAsync(
		source: Windows.Storage.IStorageItem, target: Windows.Storage.IStorageItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		createProtectedAndOpenAsync(
		parentFolder: Windows.Storage.IStorageFolder, desiredName: string, identity: string, collisionOption: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedFileCreateResult>;
		getProtectionInfoAsync(
		source: Windows.Storage.IStorageItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.FileProtectionInfo>;
		isContainerAsync: any;
		loadFileFromContainerAsync(
		containerFile: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedContainerImportResult>;
		loadFileFromContainerAsync(
		containerFile: Windows.Storage.IStorageFile, target: Windows.Storage.IStorageItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedContainerImportResult>;
		loadFileFromContainerAsync(
		containerFile: Windows.Storage.IStorageFile, target: Windows.Storage.IStorageItem, collisionOption: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedContainerImportResult>;
		protectAsync(
		target: Windows.Storage.IStorageItem, identity: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.FileProtectionInfo>;
		saveFileAsContainerAsync(
		protectedFile: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedContainerExportResult>;
		saveFileAsContainerAsync(
		protectedFile: Windows.Storage.IStorageFile, sharedWithIdentities: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectedContainerExportResult>
	}

	declare class FileRevocationManager  {
		copyProtectionAsync(
		sourceStorageItem: Windows.Storage.IStorageItem, targetStorageItem: Windows.Storage.IStorageItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getStatusAsync(
		storageItem: Windows.Storage.IStorageItem
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.FileProtectionStatus>;
		protectAsync(
		storageItem: Windows.Storage.IStorageItem, enterpriseIdentity: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.FileProtectionStatus>;
		revoke(enterpriseIdentity: string): void
	}

	declare class ProtectedAccessResumedEventArgs  {
		identities: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class ProtectedAccessSuspendingEventArgs  {
		deadline: Date;
		getDeferral(): Windows.Foundation.Deferral;
		identities: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class ProtectedContainerExportResult  {
		file: Windows.Storage.StorageFile;
		status: Windows.Security.EnterpriseData.ProtectedImportExportStatus
	}

	declare class ProtectedContainerImportResult  {
		file: Windows.Storage.StorageFile;
		status: Windows.Security.EnterpriseData.ProtectedImportExportStatus
	}

	declare class ProtectedContentRevokedEventArgs  {
		identities: Windows.Foundation.Collections.IVectorView<string>
	}

	declare class ProtectedFileCreateResult  {
		file: Windows.Storage.StorageFile;
		protectionInfo: Windows.Security.EnterpriseData.FileProtectionInfo;
		stream: Windows.Storage.Streams.IRandomAccessStream
	}

	declare class ProtectionPolicyManager  {
		checkAccess(
		sourceIdentity: string, targetIdentity: string
	): Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult;
		checkAccessForApp(
		sourceIdentity: string, appPackageFamilyName: string
	): Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult;
		clearProcessUIPolicy(): void;
		createCurrentThreadNetworkContext(identity: string): Windows.Security.EnterpriseData.ThreadNetworkContext;
		getEnforcementLevel(identity: string): Windows.Security.EnterpriseData.EnforcementLevel;
		getForCurrentView(): Windows.Security.EnterpriseData.ProtectionPolicyManager;
		getPrimaryManagedIdentityForNetworkEndpointAsync(
		endpointHost: Windows.Networking.HostName
	): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		hasContentBeenRevokedSince(identity: string, since: Date): boolean;
		isIdentityManaged(identity: string): boolean;
		isProtectionEnabled: boolean;
		isProtectionUnderLockRequired(identity: string): boolean;
		isUserDecryptionAllowed(identity: string): boolean;
		onpolicychanged: Windows.Foundation.EventHandler<any>;
		addEventListener(type: "policychanged", listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: "policychanged", listener: Windows.Foundation.EventHandler<any>): void;
		onprotectedaccessresumed: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "protectedaccessresumed", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "protectedaccessresumed", listener: Windows.Foundation.EventHandler<any>
	): void;
		onprotectedaccesssuspending: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "protectedaccesssuspending", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "protectedaccesssuspending", listener: Windows.Foundation.EventHandler<any>
	): void;
		onprotectedcontentrevoked: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "protectedcontentrevoked", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "protectedcontentrevoked", listener: Windows.Foundation.EventHandler<any>
	): void;
		requestAccessAsync(
		sourceIdentity: string, targetIdentity: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>;
		requestAccessForAppAsync(
		sourceIdentity: string, appPackageFamilyName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.EnterpriseData.ProtectionPolicyEvaluationResult>;
		revokeContent(identity: string): void;
		tryApplyProcessUIPolicy(identity: string): boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		identity: string
	}

	declare class ThreadNetworkContext  {
		close(): void
	}

	
}

declare module 'ExchangeActiveSyncProvisioning' {
				declare class EasClientDeviceInformation  {
		constructor(): this;
		friendlyName: string;
		id: string;
		operatingSystem: string;
		systemFirmwareVersion: string;
		systemHardwareVersion: string;
		systemManufacturer: string;
		systemProductName: string;
		systemSku: string
	}

	declare class EasClientSecurityPolicy  {
		constructor(): this;
		applyAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>;
		checkCompliance(): Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
		disallowConvenienceLogon: boolean;
		maxInactivityTimeLock: number;
		maxPasswordFailedAttempts: number;
		minPasswordComplexCharacters: number;
		minPasswordLength: number;
		passwordExpiration: number;
		passwordHistory: number;
		requireEncryption: boolean
	}

	declare class EasComplianceResults  {
		compliant: boolean;
		disallowConvenienceLogonResult: Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
		encryptionProviderType: Windows.Security.ExchangeActiveSyncProvisioning.EasEncryptionProviderType;
		maxInactivityTimeLockResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
		maxPasswordFailedAttemptsResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
		minPasswordComplexCharactersResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
		minPasswordLengthResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
		passwordExpirationResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
		passwordHistoryResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
		requireEncryptionResult: Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult
	}

	
}

declare module 'AccessCache' {
		declare interface AccessListEntry {
		metadata: string,
		token: string
	}

		declare class AccessListEntryView extends Array<Windows.Storage.AccessCache.AccessListEntry> {
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Storage.AccessCache.AccessListEntry>;
		getAt(index: number): Windows.Storage.AccessCache.AccessListEntry;
		getMany(
		startIndex: number
	): {
		items: Windows.Storage.AccessCache.AccessListEntry,
		returnValue: number
	};
		indexOf(
		value: Windows.Storage.AccessCache.AccessListEntry
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Storage.AccessCache.AccessListEntry, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Storage.AccessCache.AccessListEntry, fromIndex?: number
	): number
	}

	declare class ItemRemovedEventArgs  {
		removedEntry: Windows.Storage.AccessCache.AccessListEntry
	}

	declare class StorageApplicationPermissions  {
		futureAccessList: Windows.Storage.AccessCache.StorageItemAccessList;
		mostRecentlyUsedList: Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList
	}

	declare class StorageItemAccessList  {
		add(file: Windows.Storage.IStorageItem, metadata: string): string;
		add(file: Windows.Storage.IStorageItem): string;
		addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
		addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
		checkAccess(file: Windows.Storage.IStorageItem): boolean;
		clear(): void;
		containsItem(token: string): boolean;
		entries: Windows.Storage.AccessCache.AccessListEntryView;
		getFileAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFileAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFolderAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getFolderAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getItemAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		getItemAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		maximumItemsAllowed: number;
		remove(token: string): void
	}

	declare class StorageItemMostRecentlyUsedList  {
		add(file: Windows.Storage.IStorageItem, metadata: string): string;
		add(file: Windows.Storage.IStorageItem): string;
		add(
		file: Windows.Storage.IStorageItem, metadata: string, visibility: Windows.Storage.AccessCache.RecentStorageItemVisibility
	): string;
		addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
		addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
		addOrReplace(
		token: string, file: Windows.Storage.IStorageItem, metadata: string, visibility: Windows.Storage.AccessCache.RecentStorageItemVisibility
	): void;
		checkAccess(file: Windows.Storage.IStorageItem): boolean;
		clear(): void;
		containsItem(token: string): boolean;
		entries: Windows.Storage.AccessCache.AccessListEntryView;
		getFileAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFileAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFolderAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getFolderAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getItemAsync(
		token: string, options: Windows.Storage.AccessCache.AccessCacheOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		getItemAsync(
		token: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		maximumItemsAllowed: number;
		onitemremoved: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList, Windows.Storage.AccessCache.ItemRemovedEventArgs>;
		addEventListener(
		type: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList, Windows.Storage.AccessCache.ItemRemovedEventArgs>
	): void;
		removeEventListener(
		type: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList, Windows.Storage.AccessCache.ItemRemovedEventArgs>
	): void;
		remove(token: string): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'BulkAccess' {
		declare interface IStorageItemInformation {
		basicProperties: Windows.Storage.FileProperties.BasicProperties,
		documentProperties: Windows.Storage.FileProperties.DocumentProperties,
		imageProperties: Windows.Storage.FileProperties.ImageProperties,
		musicProperties: Windows.Storage.FileProperties.MusicProperties,
		thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail,
		videoProperties: Windows.Storage.FileProperties.VideoProperties
	}

		declare class FileInformation  {
		attributes: Windows.Storage.FileAttributes;
		basicProperties: Windows.Storage.FileProperties.BasicProperties;
		contentType: string;
		copyAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		copyAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		dateCreated: Date;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(
		option: Windows.Storage.StorageDeleteOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		displayType: string;
		documentProperties: Windows.Storage.FileProperties.DocumentProperties;
		fileType: string;
		folderRelativeId: string;
		getBasicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
		getParentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		imageProperties: Windows.Storage.FileProperties.ImageProperties;
		isAvailable: boolean;
		isEqual(item: Windows.Storage.IStorageItem): boolean;
		isOfType(type: Windows.Storage.StorageItemTypes): boolean;
		moveAndReplaceAsync(
		fileToReplace: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		moveAsync(
		destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string
	): Windows.Foundation.IPromiseWithIAsyncAction;
		musicProperties: Windows.Storage.FileProperties.MusicProperties;
		name: string;
		onpropertiesupdated: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>;
		addEventListener(
		type: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		removeEventListener(
		type: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		onthumbnailupdated: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>;
		addEventListener(
		type: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		removeEventListener(
		type: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		openAsync(
		accessMode: Windows.Storage.FileAccessMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		openAsync(
		accessMode: Windows.Storage.FileAccessMode, options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
		openReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
		openSequentialReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IInputStream>;
		openTransactedWriteAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>;
		openTransactedWriteAsync(
		options: Windows.Storage.StorageOpenOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageStreamTransaction>;
		path: string;
		properties: Windows.Storage.FileProperties.StorageItemContentProperties;
		provider: Windows.Storage.StorageProvider;
		renameAsync(desiredName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		renameAsync(
		desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
		videoProperties: Windows.Storage.FileProperties.VideoProperties;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class FileInformationFactory  {
		constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions, delayLoad: boolean): this;
		constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions): this;
		constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number): this;
		constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode): this;
		getFilesAsync(
		startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemsAsync(
		startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getVirtualizedFilesVector(): any;
		getVirtualizedFoldersVector(): any;
		getVirtualizedItemsVector(): any
	}

	declare class FolderInformation  {
		areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
		attributes: Windows.Storage.FileAttributes;
		basicProperties: Windows.Storage.FileProperties.BasicProperties;
		createFileAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
		createFileQuery(
		query: Windows.Storage.Search.CommonFileQuery
	): Windows.Storage.Search.StorageFileQueryResult;
		createFileQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageFileQueryResult;
		createFolderAsync(
		desiredName: string, options: Windows.Storage.CreationCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderAsync(
		desiredName: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
		createFolderQuery(
		query: Windows.Storage.Search.CommonFolderQuery
	): Windows.Storage.Search.StorageFolderQueryResult;
		createFolderQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageFolderQueryResult;
		createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
		createItemQueryWithOptions(
		queryOptions: Windows.Storage.Search.QueryOptions
	): Windows.Storage.Search.StorageItemQueryResult;
		dateCreated: Date;
		deleteAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		deleteAsync(
		option: Windows.Storage.StorageDeleteOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		displayName: string;
		displayType: string;
		documentProperties: Windows.Storage.FileProperties.DocumentProperties;
		folderRelativeId: string;
		getBasicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
		getFileAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		getFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		query: Windows.Storage.Search.CommonFileQuery
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFilesAsync(
		query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFolderAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getFoldersAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getFoldersAsync(
		query: Windows.Storage.Search.CommonFolderQuery
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getIndexedStateAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Search.IndexedState>;
		getItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		getItemsAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getItemsAsync(
		startIndex: number, maxItemsToRetrieve: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		getParentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		getThumbnailAsync(
		mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
		imageProperties: Windows.Storage.FileProperties.ImageProperties;
		isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
		isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
		isEqual(item: Windows.Storage.IStorageItem): boolean;
		isOfType(type: Windows.Storage.StorageItemTypes): boolean;
		musicProperties: Windows.Storage.FileProperties.MusicProperties;
		name: string;
		onpropertiesupdated: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>;
		addEventListener(
		type: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		removeEventListener(
		type: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		onthumbnailupdated: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>;
		addEventListener(
		type: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		removeEventListener(
		type: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation, any>
	): void;
		path: string;
		properties: Windows.Storage.FileProperties.StorageItemContentProperties;
		provider: Windows.Storage.StorageProvider;
		renameAsync(desiredName: string): Windows.Foundation.IPromiseWithIAsyncAction;
		renameAsync(
		desiredName: string, option: Windows.Storage.NameCollisionOption
	): Windows.Foundation.IPromiseWithIAsyncAction;
		thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
		tryGetItemAsync(
		name: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.IStorageItem>;
		videoProperties: Windows.Storage.FileProperties.VideoProperties;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	
}

declare module 'Compression' {
				declare class Compressor  {
		constructor(underlyingStream: Windows.Storage.Streams.IOutputStream): this;
		constructor(underlyingStream: Windows.Storage.Streams.IOutputStream, algorithm: Windows.Storage.Compression.CompressAlgorithm, blockSize: number): this;
		close(): void;
		detachStream(): Windows.Storage.Streams.IOutputStream;
		finishAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class Decompressor  {
		constructor(underlyingStream: Windows.Storage.Streams.IInputStream): this;
		close(): void;
		detachStream(): Windows.Storage.Streams.IInputStream;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>
	}

	
}

declare module 'FileProperties' {
				declare class BasicProperties  {
		dateModified: Date;
		itemDate: Date;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		size: number
	}

	declare class DocumentProperties  {
		author: Windows.Foundation.Collections.IVector<string>;
		comment: string;
		keywords: Windows.Foundation.Collections.IVector<string>;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		title: string
	}

	declare class GeotagHelper  {
		getGeotagAsync(
		file: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Devices.Geolocation.Geopoint>;
		setGeotagAsync(
		file: Windows.Storage.IStorageFile, geopoint: Windows.Devices.Geolocation.Geopoint
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setGeotagFromGeolocatorAsync(
		file: Windows.Storage.IStorageFile, geolocator: Windows.Devices.Geolocation.Geolocator
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class ImageProperties  {
		cameraManufacturer: string;
		cameraModel: string;
		dateTaken: Date;
		height: number;
		keywords: Windows.Foundation.Collections.IVector<string>;
		latitude: number;
		longitude: number;
		orientation: Windows.Storage.FileProperties.PhotoOrientation;
		peopleNames: Windows.Foundation.Collections.IVectorView<string>;
		rating: number;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		title: string;
		width: number
	}

	declare class MusicProperties  {
		album: string;
		albumArtist: string;
		artist: string;
		bitrate: number;
		composers: Windows.Foundation.Collections.IVector<string>;
		conductors: Windows.Foundation.Collections.IVector<string>;
		duration: number;
		genre: Windows.Foundation.Collections.IVector<string>;
		producers: Windows.Foundation.Collections.IVector<string>;
		publisher: string;
		rating: number;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		subtitle: string;
		title: string;
		trackNumber: number;
		writers: Windows.Foundation.Collections.IVector<string>;
		year: number
	}

	declare class StorageItemContentProperties  {
		getDocumentPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.DocumentProperties>;
		getImagePropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.ImageProperties>;
		getMusicPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.MusicProperties>;
		getVideoPropertiesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.FileProperties.VideoProperties>;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class StorageItemThumbnail  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		contentType: string;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		originalHeight: number;
		originalWidth: number;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		returnedSmallerCachedSize: boolean;
		seek(position: number): void;
		size: number;
		type: Windows.Storage.FileProperties.ThumbnailType;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class VideoProperties  {
		bitrate: number;
		directors: Windows.Foundation.Collections.IVector<string>;
		duration: number;
		height: number;
		keywords: Windows.Foundation.Collections.IVector<string>;
		latitude: number;
		longitude: number;
		orientation: Windows.Storage.FileProperties.VideoOrientation;
		producers: Windows.Foundation.Collections.IVector<string>;
		publisher: string;
		rating: number;
		retrievePropertiesAsync(
		propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IMap<any, any>>;
		savePropertiesAsync(
		propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>
	): Windows.Foundation.IPromiseWithIAsyncAction;
		savePropertiesAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		subtitle: string;
		title: string;
		width: number;
		writers: Windows.Foundation.Collections.IVector<string>;
		year: number
	}

	
}

declare module 'Pickers' {
				declare class FileExtensionVector extends Array<string> {
		append(value: string): void;
		clear(): void;
		first(): Windows.Foundation.Collections.IIterator<string>;
		getAt(index: number): string;
		getMany(startIndex: number): {
		items: string[],
		returnValue: number
	};
		getView(): Windows.Foundation.Collections.IVectorView<string>;
		indexOf(value: string): {
		index: number,
		returnValue: boolean
	};
		insertAt(index: number, value: string): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: string[]): void;
		setAt(index: number, value: string): void;
		size: number;
		indexOf(value: string, ...extra: any[]): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: string, fromIndex?: number): number
	}

	declare class FileOpenPicker  {
		resumePickSingleFileAsync: any;
		constructor(): this;
		commitButtonText: string;
		continuationData: Windows.Foundation.Collections.ValueSet;
		fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
		pickMultipleFilesAndContinue(): void;
		pickMultipleFilesAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		pickSingleFileAndContinue(): void;
		pickSingleFileAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		pickSingleFileAsync(
		pickerOperationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		settingsIdentifier: string;
		suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
		viewMode: Windows.Storage.Pickers.PickerViewMode
	}

	declare class FilePickerFileTypesOrderedMap  {
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(
		
	): Windows.Foundation.Collections.IMapView<string, Windows.Foundation.Collections.IVector<string>>;
		hasKey(key: string): boolean;
		insert(key: string, value: Windows.Foundation.Collections.IVector<string>): boolean;
		lookup(key: string): Windows.Foundation.Collections.IVector<string>;
		remove(key: string): void;
		size: number
	}

	declare class FilePickerSelectedFilesArray extends Array<Windows.Storage.StorageFile> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Storage.StorageFile>;
		getAt(index: number): Windows.Storage.StorageFile;
		getMany(
		startIndex: number
	): {
		items: Windows.Storage.StorageFile,
		returnValue: number
	};
		indexOf(
		value: Windows.Storage.StorageFile
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Storage.StorageFile, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Storage.StorageFile, fromIndex?: number): number
	}

	declare class FileSavePicker  {
		constructor(): this;
		commitButtonText: string;
		continuationData: Windows.Foundation.Collections.ValueSet;
		defaultFileExtension: string;
		enterpriseId: string;
		fileTypeChoices: Windows.Foundation.Collections.IMap<string, Windows.Foundation.Collections.IVector<string>>;
		pickSaveFileAndContinue(): void;
		pickSaveFileAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFile>;
		settingsIdentifier: string;
		suggestedFileName: string;
		suggestedSaveFile: Windows.Storage.StorageFile;
		suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId
	}

	declare class FolderPicker  {
		constructor(): this;
		commitButtonText: string;
		continuationData: Windows.Foundation.Collections.ValueSet;
		fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
		pickFolderAndContinue(): void;
		pickSingleFolderAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.StorageFolder>;
		settingsIdentifier: string;
		suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
		viewMode: Windows.Storage.Pickers.PickerViewMode
	}

	
}

declare module 'Streams' {
		declare interface IRandomAccessStreamReference {
		openReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>
	}

	declare interface IRandomAccessStreamWithContentType {
		
	}

	declare interface IRandomAccessStream {
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream,
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream,
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream,
		seek(position: number): void,
		canRead: boolean,
		canWrite: boolean,
		position: number,
		size: number
	}

	declare interface IBuffer {
		capacity: number,
		length: number
	}

	declare interface IInputStream {
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>
	}

	declare interface IOutputStream {
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>,
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare interface IContentTypeProvider {
		contentType: string
	}

	declare interface IInputStreamReference {
		openSequentialReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IInputStream>
	}

		declare class Buffer  {
		createCopyFromMemoryBuffer(input: Windows.Foundation.IMemoryBuffer): Windows.Storage.Streams.Buffer;
		createMemoryBufferOverIBuffer(input: Windows.Storage.Streams.IBuffer): Windows.Foundation.MemoryBuffer;
		constructor(capacity: number): this;
		byteLength: any;
		capacity: number;
		length: number
	}

	declare class DataReader  {
		fromBuffer(buffer: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.DataReader;
		constructor(inputStream: Windows.Storage.Streams.IInputStream): this;
		byteOrder: Windows.Storage.Streams.ByteOrder;
		close(): void;
		detachBuffer(): Windows.Storage.Streams.IBuffer;
		detachStream(): Windows.Storage.Streams.IInputStream;
		inputStreamOptions: Windows.Storage.Streams.InputStreamOptions;
		loadAsync(
		count: number
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Storage.Streams.DataReaderLoadOperation>;
		readBoolean(): boolean;
		readBuffer(length: number): Windows.Storage.Streams.IBuffer;
		readByte(): number;
		readBytes(): number[];
		readDateTime(): Date;
		readDouble(): number;
		readGuid(): string;
		readInt16(): number;
		readInt32(): number;
		readInt64(): number;
		readSingle(): number;
		readString(codeUnitCount: number): string;
		readTimeSpan(): number;
		readUInt16(): number;
		readUInt32(): number;
		readUInt64(): number;
		unconsumedBufferLength: number;
		unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding
	}

	declare class DataReaderLoadOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
		errorCode: WinRTError;
		getResults(): number;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class DataWriter  {
		constructor(): this;
		constructor(outputStream: Windows.Storage.Streams.IOutputStream): this;
		byteOrder: Windows.Storage.Streams.ByteOrder;
		close(): void;
		detachBuffer(): Windows.Storage.Streams.IBuffer;
		detachStream(): Windows.Storage.Streams.IOutputStream;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		measureString(value: string): number;
		storeAsync(
		
	): Windows.Foundation.IPromiseWithOperation<any, Windows.Storage.Streams.DataWriterStoreOperation>;
		unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
		unstoredBufferLength: number;
		writeBoolean(value: boolean): void;
		writeBuffer(buffer: Windows.Storage.Streams.IBuffer, start: number, count: number): void;
		writeBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
		writeByte(value: number): void;
		writeBytes(value: number[]): void;
		writeDateTime(value: Date): void;
		writeDouble(value: number): void;
		writeGuid(value: string): void;
		writeInt16(value: number): void;
		writeInt32(value: number): void;
		writeInt64(value: number): void;
		writeSingle(value: number): void;
		writeString(value: string): number;
		writeTimeSpan(value: number): void;
		writeUInt16(value: number): void;
		writeUInt32(value: number): void;
		writeUInt64(value: number): void
	}

	declare class DataWriterStoreOperation  {
		cancel(): void;
		close(): void;
		completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
		errorCode: WinRTError;
		getResults(): number;
		id: number;
		status: Windows.Foundation.AsyncStatus
	}

	declare class FileInputStream  {
		close(): void;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>
	}

	declare class FileOutputStream  {
		close(): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class FileRandomAccessStream  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class InMemoryRandomAccessStream  {
		constructor(): this;
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class InputStreamOverStream  {
		close(): void;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>
	}

	declare class OutputStreamOverStream  {
		close(): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class RandomAccessStream  {
		copyAndCloseAsync(
		source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		copyAsync(
		source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream, bytesToCopy: number
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		copyAsync(
		source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class RandomAccessStreamOverStream  {
		canRead: boolean;
		canWrite: boolean;
		cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
		close(): void;
		flushAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
		getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
		position: number;
		readAsync(
		buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		seek(position: number): void;
		size: number;
		writeAsync(
		buffer: Windows.Storage.Streams.IBuffer
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class RandomAccessStreamReference  {
		createFromFile(
		file: Windows.Storage.IStorageFile
	): Windows.Storage.Streams.RandomAccessStreamReference;
		createFromStream(
		stream: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Storage.Streams.RandomAccessStreamReference;
		createFromUri(
		uri: Windows.Foundation.Uri
	): Windows.Storage.Streams.RandomAccessStreamReference;
		openReadAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>
	}

	
}

declare module 'Profile' {
				declare class AnalyticsInfo  {
		deviceForm: string;
		versionInfo: Windows.System.Profile.AnalyticsVersionInfo
	}

	declare class AnalyticsVersionInfo  {
		deviceFamily: string;
		deviceFamilyVersion: string
	}

	declare class HardwareIdentification  {
		getPackageSpecificToken(nonce: Windows.Storage.Streams.IBuffer): Windows.System.Profile.HardwareToken
	}

	declare class HardwareToken  {
		certificate: Windows.Storage.Streams.IBuffer;
		id: Windows.Storage.Streams.IBuffer;
		signature: Windows.Storage.Streams.IBuffer
	}

	declare class KnownRetailInfoProperties  {
		batteryLifeDescription: string;
		displayDescription: string;
		displayModelName: string;
		formFactor: string;
		frontCameraDescription: string;
		graphicsDescription: string;
		hasNfc: string;
		hasOpticalDrive: string;
		hasSdSlot: string;
		isFeatured: string;
		isOfficeInstalled: string;
		manufacturerName: string;
		memory: string;
		modelName: string;
		price: string;
		processorDescription: string;
		rearCameraDescription: string;
		retailAccessCode: string;
		screenSize: string;
		storageDescription: string;
		weight: string;
		windowsEdition: string
	}

	declare class PlatformDiagnosticsAndUsageDataSettings  {
		addEventListener: any;
		canCollectDiagnostics: any;
		collectionLevel: any;
		oncollectionlevelchanged: any;
		removeEventListener: any
	}

	declare class RetailInfo  {
		isDemoModeEnabled: boolean;
		properties: Windows.Foundation.Collections.IMapView<string, any>
	}

	
}

declare module 'SystemManufacturers' {
				declare class SmbiosInformation  {
		serialNumber: string
	}

	
}

declare module 'RemoteDesktop' {
				declare class InteractiveSession  {
		isRemote: boolean
	}

	
}

declare module 'UserProfile' {
				declare class AdvertisingManager  {
		advertisingId: string
	}

	declare class FirstSignInSettings  {
		getDefault(): Windows.System.UserProfile.FirstSignInSettings;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		hasKey(key: string): boolean;
		lookup(key: string): any;
		size: number;
		split(
		
	): {
		first: Windows.Foundation.Collections.IMapView<string, any>,
		second: Windows.Foundation.Collections.IMapView<string, any>
	}
	}

	declare class GlobalizationPreferences  {
		calendars: Windows.Foundation.Collections.IVectorView<string>;
		clocks: Windows.Foundation.Collections.IVectorView<string>;
		currencies: Windows.Foundation.Collections.IVectorView<string>;
		homeGeographicRegion: string;
		languages: Windows.Foundation.Collections.IVectorView<string>;
		weekStartsOn: Windows.Globalization.DayOfWeek
	}

	declare class LockScreen  {
		getImageStream(): Windows.Storage.Streams.IRandomAccessStream;
		originalImageFile: Windows.Foundation.Uri;
		requestSetImageFeedAsync(
		syndicationFeedUri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.UserProfile.SetImageFeedResult>;
		setImageFileAsync(
		value: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncAction;
		setImageStreamAsync(
		value: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tryRemoveImageFeed(): boolean
	}

	declare class UserInformation  {
		accountPictureChangeEnabled: boolean;
		getAccountPicture(
		kind: Windows.System.UserProfile.AccountPictureKind
	): Windows.Storage.IStorageFile;
		getDisplayNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getDomainNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getFirstNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getLastNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getPrincipalNameAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<string>;
		getSessionInitiationProtocolUriAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Uri>;
		nameAccessAllowed: boolean;
		onaccountpicturechanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		setAccountPictureAsync(
		image: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
		setAccountPictureFromStreamAsync(
		image: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
		setAccountPicturesAsync(
		smallImage: Windows.Storage.IStorageFile, largeImage: Windows.Storage.IStorageFile, video: Windows.Storage.IStorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
		setAccountPicturesFromStreamsAsync(
		smallImage: Windows.Storage.Streams.IRandomAccessStream, largeImage: Windows.Storage.Streams.IRandomAccessStream, video: Windows.Storage.Streams.IRandomAccessStream
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class UserProfilePersonalizationSettings  {
		current: Windows.System.UserProfile.UserProfilePersonalizationSettings;
		isSupported(): boolean;
		trySetLockScreenImageAsync(
		imageFile: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		trySetWallpaperImageAsync(
		imageFile: Windows.Storage.StorageFile
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	
}

declare module 'ApplicationSettings' {
	declare type CredentialCommandCredentialDeletedHandler = (command: Windows.UI.ApplicationSettings.CredentialCommand) => void;

	declare type WebAccountCommandInvokedHandler = (
		command: Windows.UI.ApplicationSettings.WebAccountCommand, args: Windows.UI.ApplicationSettings.WebAccountInvokedArgs
	) => void;

	declare type WebAccountProviderCommandInvokedHandler = (command: Windows.UI.ApplicationSettings.WebAccountProviderCommand) => void;

			declare class AccountsSettingsPane  {
		getForCurrentView(): Windows.UI.ApplicationSettings.AccountsSettingsPane;
		show(): void;
		onaccountcommandsrequested: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.AccountsSettingsPane, Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs>;
		addEventListener(
		type: "accountcommandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.AccountsSettingsPane, Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "accountcommandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.AccountsSettingsPane, Windows.UI.ApplicationSettings.AccountsSettingsPaneCommandsRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class AccountsSettingsPaneCommandsRequestedEventArgs  {
		commands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>;
		credentialCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.CredentialCommand>;
		getDeferral(): Windows.UI.ApplicationSettings.AccountsSettingsPaneEventDeferral;
		headerText: string;
		webAccountCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.WebAccountCommand>;
		webAccountProviderCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.WebAccountProviderCommand>
	}

	declare class AccountsSettingsPaneEventDeferral  {
		complete(): void
	}

	declare class CredentialCommand  {
		constructor(passwordCredential: Windows.Security.Credentials.PasswordCredential): this;
		constructor(passwordCredential: Windows.Security.Credentials.PasswordCredential, deleted: Windows.UI.ApplicationSettings.CredentialCommandCredentialDeletedHandler): this;
		credentialDeleted: Windows.UI.ApplicationSettings.CredentialCommandCredentialDeletedHandler;
		passwordCredential: Windows.Security.Credentials.PasswordCredential
	}

	declare class SettingsCommand  {
		accountsCommand: Windows.UI.ApplicationSettings.SettingsCommand;
		constructor(settingsCommandId: any, label: string, handler: Windows.UI.Popups.UICommandInvokedHandler): this;
		id: any;
		invoked: Windows.UI.Popups.UICommandInvokedHandler;
		label: string
	}

	declare class SettingsPane  {
		edge: Windows.UI.ApplicationSettings.SettingsEdgeLocation;
		getForCurrentView(): Windows.UI.ApplicationSettings.SettingsPane;
		show(): void;
		oncommandsrequested: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane, Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>;
		addEventListener(
		type: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane, Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane, Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SettingsPaneCommandsRequest  {
		applicationCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>
	}

	declare class SettingsPaneCommandsRequestedEventArgs  {
		request: Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest
	}

	declare class WebAccountCommand  {
		constructor(webAccount: Windows.Security.Credentials.WebAccount, invoked: Windows.UI.ApplicationSettings.WebAccountCommandInvokedHandler, actions: Windows.UI.ApplicationSettings.SupportedWebAccountActions): this;
		actions: Windows.UI.ApplicationSettings.SupportedWebAccountActions;
		invoked: Windows.UI.ApplicationSettings.WebAccountCommandInvokedHandler;
		webAccount: Windows.Security.Credentials.WebAccount
	}

	declare class WebAccountInvokedArgs  {
		action: Windows.UI.ApplicationSettings.WebAccountAction
	}

	declare class WebAccountProviderCommand  {
		constructor(webAccountProvider: Windows.Security.Credentials.WebAccountProvider, invoked: Windows.UI.ApplicationSettings.WebAccountProviderCommandInvokedHandler): this;
		invoked: Windows.UI.ApplicationSettings.WebAccountProviderCommandInvokedHandler;
		webAccountProvider: Windows.Security.Credentials.WebAccountProvider
	}

	
}

declare module 'Composition' {
				declare class CompositionAnimation  {
		
	}

	declare class CompositionEasingFunction  {
		
	}

	
}

declare module 'AnimationMetrics' {
		declare interface IPropertyAnimation {
		control1: Windows.Foundation.Point,
		control2: Windows.Foundation.Point,
		delay: number,
		duration: number,
		type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType
	}

		declare class AnimationDescription  {
		constructor(effect: Windows.UI.Core.AnimationMetrics.AnimationEffect, target: Windows.UI.Core.AnimationMetrics.AnimationEffectTarget): this;
		animations: Windows.Foundation.Collections.IVectorView<Windows.UI.Core.AnimationMetrics.IPropertyAnimation>;
		delayLimit: number;
		staggerDelay: number;
		staggerDelayFactor: number;
		zorder: number
	}

	declare class OpacityAnimation  {
		control1: Windows.Foundation.Point;
		control2: Windows.Foundation.Point;
		delay: number;
		duration: number;
		finalOpacity: number;
		initialOpacity: number;
		type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType
	}

	declare class PropertyAnimation  {
		control1: Windows.Foundation.Point;
		control2: Windows.Foundation.Point;
		delay: number;
		duration: number;
		type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType
	}

	declare class ScaleAnimation  {
		control1: Windows.Foundation.Point;
		control2: Windows.Foundation.Point;
		delay: number;
		duration: number;
		finalScaleX: number;
		finalScaleY: number;
		initialScaleX: number;
		initialScaleY: number;
		normalizedOrigin: Windows.Foundation.Point;
		type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType
	}

	declare class TranslationAnimation  {
		control1: Windows.Foundation.Point;
		control2: Windows.Foundation.Point;
		delay: number;
		duration: number;
		type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType
	}

	
}

declare module 'Inking' {
				declare class InkDrawingAttributes  {
		constructor(): this;
		color: Windows.UI.Color;
		drawAsHighlighter: boolean;
		fitToCurve: boolean;
		ignorePressure: boolean;
		penTip: Windows.UI.Input.Inking.PenTipShape;
		penTipTransform: Windows.Foundation.Numerics.Matrix3x2;
		size: Windows.Foundation.Size
	}

	declare class InkManager  {
		constructor(): this;
		addStroke(stroke: Windows.UI.Input.Inking.InkStroke): void;
		boundingRect: Windows.Foundation.Rect;
		canPasteFromClipboard(): boolean;
		copySelectedToClipboard(): void;
		deleteSelected(): Windows.Foundation.Rect;
		getRecognitionResults(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognitionResult>;
		getRecognizers(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognizer>;
		getStrokes(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkStroke>;
		loadAsync(
		inputStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<number>;
		mode: Windows.UI.Input.Inking.InkManipulationMode;
		moveSelected(translation: Windows.Foundation.Point): Windows.Foundation.Rect;
		pasteFromClipboard(position: Windows.Foundation.Point): Windows.Foundation.Rect;
		processPointerDown(pointerPoint: Windows.UI.Input.PointerPoint): void;
		processPointerUp(pointerPoint: Windows.UI.Input.PointerPoint): Windows.Foundation.Rect;
		processPointerUpdate(pointerPoint: Windows.UI.Input.PointerPoint): any;
		recognizeAsync(
		recognitionTarget: Windows.UI.Input.Inking.InkRecognitionTarget
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		recognizeAsync(
		strokeCollection: Windows.UI.Input.Inking.InkStrokeContainer, recognitionTarget: Windows.UI.Input.Inking.InkRecognitionTarget
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		saveAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		selectWithLine(
		from: Windows.Foundation.Point, to: Windows.Foundation.Point
	): Windows.Foundation.Rect;
		selectWithPolyLine(
		polyline: Windows.Foundation.Collections.IIterable<Windows.Foundation.Point>
	): Windows.Foundation.Rect;
		setDefaultDrawingAttributes(drawingAttributes: Windows.UI.Input.Inking.InkDrawingAttributes): void;
		setDefaultRecognizer(recognizer: Windows.UI.Input.Inking.InkRecognizer): void;
		updateRecognitionResults(
		recognitionResults: Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognitionResult>
	): void
	}

	declare class InkPoint  {
		constructor(position: Windows.Foundation.Point, pressure: number): this;
		position: Windows.Foundation.Point;
		pressure: any
	}

	declare class InkRecognitionResult  {
		boundingRect: Windows.Foundation.Rect;
		getStrokes(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkStroke>;
		getTextCandidates(): Windows.Foundation.Collections.IVectorView<string>
	}

	declare class InkRecognizer  {
		name: string
	}

	declare class InkRecognizerContainer  {
		constructor(): this;
		getRecognizers(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognizer>;
		recognizeAsync(
		strokeCollection: Windows.UI.Input.Inking.InkStrokeContainer, recognitionTarget: Windows.UI.Input.Inking.InkRecognitionTarget
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		setDefaultRecognizer(recognizer: Windows.UI.Input.Inking.InkRecognizer): void
	}

	declare class InkStroke  {
		boundingRect: Windows.Foundation.Rect;
		clone(): Windows.UI.Input.Inking.InkStroke;
		drawingAttributes: Windows.UI.Input.Inking.InkDrawingAttributes;
		getInkPoints(): Windows.Foundation.Collections.IVectorView<InkPoint>;
		getRenderingSegments(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkStrokeRenderingSegment>;
		pointTransform: Windows.Foundation.Numerics.Matrix3x2;
		recognized: boolean;
		selected: boolean
	}

	declare class InkStrokeBuilder  {
		constructor(): this;
		appendToStroke(pointerPoint: Windows.UI.Input.PointerPoint): Windows.UI.Input.PointerPoint;
		beginStroke(pointerPoint: Windows.UI.Input.PointerPoint): void;
		createStroke(
		points: Windows.Foundation.Collections.IIterable<Windows.Foundation.Point>
	): Windows.UI.Input.Inking.InkStroke;
		createStrokeFromInkPoints(
		inkPoints: Windows.Foundation.Collections.IIterable<InkPoint>, transform: Windows.Foundation.Numerics.Matrix3x2
	): Windows.UI.Input.Inking.InkStroke;
		endStroke(pointerPoint: Windows.UI.Input.PointerPoint): Windows.UI.Input.Inking.InkStroke;
		setDefaultDrawingAttributes(drawingAttributes: Windows.UI.Input.Inking.InkDrawingAttributes): void
	}

	declare class InkStrokeContainer  {
		constructor(): this;
		addStroke(stroke: Windows.UI.Input.Inking.InkStroke): void;
		addStrokes(
		strokes: Windows.Foundation.Collections.IIterable<Windows.UI.Input.Inking.InkStroke>
	): void;
		boundingRect: Windows.Foundation.Rect;
		canPasteFromClipboard(): boolean;
		clear(): void;
		copySelectedToClipboard(): void;
		deleteSelected(): Windows.Foundation.Rect;
		getRecognitionResults(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognitionResult>;
		getStrokes(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkStroke>;
		loadAsync(
		inputStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<number>;
		moveSelected(translation: Windows.Foundation.Point): Windows.Foundation.Rect;
		pasteFromClipboard(position: Windows.Foundation.Point): Windows.Foundation.Rect;
		saveAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		selectWithLine(
		from: Windows.Foundation.Point, to: Windows.Foundation.Point
	): Windows.Foundation.Rect;
		selectWithPolyLine(
		polyline: Windows.Foundation.Collections.IIterable<Windows.Foundation.Point>
	): Windows.Foundation.Rect;
		updateRecognitionResults(
		recognitionResults: Windows.Foundation.Collections.IVectorView<Windows.UI.Input.Inking.InkRecognitionResult>
	): void
	}

	declare class InkStrokeRenderingSegment  {
		bezierControlPoint1: Windows.Foundation.Point;
		bezierControlPoint2: Windows.Foundation.Point;
		position: Windows.Foundation.Point;
		pressure: number;
		tiltX: number;
		tiltY: number;
		twist: number
	}

	
}

declare module 'Notifications' {
				declare class BadgeNotification  {
		constructor(content: Windows.Data.Xml.Dom.XmlDocument): this;
		content: Windows.Data.Xml.Dom.XmlDocument;
		expirationTime: Date
	}

	declare class BadgeUpdateManager  {
		createBadgeUpdaterForApplication(): Windows.UI.Notifications.BadgeUpdater;
		createBadgeUpdaterForApplication(applicationId: string): Windows.UI.Notifications.BadgeUpdater;
		createBadgeUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.BadgeUpdater;
		getTemplateContent(
		type: Windows.UI.Notifications.BadgeTemplateType
	): Windows.Data.Xml.Dom.XmlDocument
	}

	declare class BadgeUpdater  {
		clear(): void;
		startPeriodicUpdate(
		badgeContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		startPeriodicUpdate(
		badgeContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		stopPeriodicUpdate(): void;
		update(notification: Windows.UI.Notifications.BadgeNotification): void
	}

	declare class ScheduledTileNotification  {
		constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
		content: Windows.Data.Xml.Dom.XmlDocument;
		deliveryTime: Date;
		expirationTime: Date;
		id: string;
		tag: string
	}

	declare class ScheduledToastNotification  {
		constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date, snoozeInterval: number, maximumSnoozeCount: number): this;
		constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date): this;
		content: Windows.Data.Xml.Dom.XmlDocument;
		deliveryTime: Date;
		group: string;
		id: string;
		maximumSnoozeCount: number;
		snoozeInterval: number;
		suppressPopup: boolean;
		tag: string
	}

	declare class TileFlyoutNotification  {
		content: any;
		expirationTime: any
	}

	declare class TileFlyoutUpdateManager  {
		createTileFlyoutUpdaterForApplication: any;
		createTileFlyoutUpdaterForSecondaryTile: any;
		getTemplateContent: any
	}

	declare class TileFlyoutUpdater  {
		clear: any;
		setting: any;
		startPeriodicUpdate: any;
		stopPeriodicUpdate: any;
		update: any
	}

	declare class TileNotification  {
		constructor(content: Windows.Data.Xml.Dom.XmlDocument): this;
		content: Windows.Data.Xml.Dom.XmlDocument;
		expirationTime: Date;
		tag: string
	}

	declare class TileUpdateManager  {
		createTileUpdaterForApplication(): Windows.UI.Notifications.TileUpdater;
		createTileUpdaterForApplication(applicationId: string): Windows.UI.Notifications.TileUpdater;
		createTileUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.TileUpdater;
		getTemplateContent(
		type: Windows.UI.Notifications.TileTemplateType
	): Windows.Data.Xml.Dom.XmlDocument
	}

	declare class TileUpdater  {
		addToSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
		clear(): void;
		enableNotificationQueue(enable: boolean): void;
		enableNotificationQueueForSquare150x150(enable: boolean): void;
		enableNotificationQueueForSquare310x310(enable: boolean): void;
		enableNotificationQueueForWide310x150(enable: boolean): void;
		getScheduledTileNotifications(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledTileNotification>;
		removeFromSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
		setting: Windows.UI.Notifications.NotificationSetting;
		startPeriodicUpdate(
		tileContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		startPeriodicUpdate(
		tileContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		startPeriodicUpdateBatch(
		tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		startPeriodicUpdateBatch(
		tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence
	): void;
		stopPeriodicUpdate(): void;
		update(notification: Windows.UI.Notifications.TileNotification): void
	}

	declare class ToastActivatedEventArgs  {
		arguments: string
	}

	declare class ToastDismissedEventArgs  {
		reason: Windows.UI.Notifications.ToastDismissalReason
	}

	declare class ToastFailedEventArgs  {
		errorCode: WinRTError
	}

	declare class ToastNotification  {
		constructor(content: Windows.Data.Xml.Dom.XmlDocument): this;
		content: Windows.Data.Xml.Dom.XmlDocument;
		expirationTime: Date;
		group: string;
		onactivated: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, any>;
		addEventListener(
		type: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, any>
	): void;
		removeEventListener(
		type: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, any>
	): void;
		ondismissed: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastDismissedEventArgs>;
		addEventListener(
		type: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastDismissedEventArgs>
	): void;
		removeEventListener(
		type: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastDismissedEventArgs>
	): void;
		onfailed: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastFailedEventArgs>;
		addEventListener(
		type: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastFailedEventArgs>
	): void;
		removeEventListener(
		type: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification, Windows.UI.Notifications.ToastFailedEventArgs>
	): void;
		suppressPopup: boolean;
		tag: string;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ToastNotificationActionTriggerDetail  {
		argument: any;
		userInput: any
	}

	declare class ToastNotificationHistory  {
		clear(applicationId: string): void;
		clear(): void;
		getHistory(
		applicationId: string
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ToastNotification>;
		getHistory(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ToastNotification>;
		remove(tag: string): void;
		remove(tag: string, group: string, applicationId: string): void;
		remove(tag: string, group: string): void;
		removeGroup(group: string): void;
		removeGroup(group: string, applicationId: string): void
	}

	declare class ToastNotificationHistoryChangedTriggerDetail  {
		changeType: Windows.UI.Notifications.ToastHistoryChangedType
	}

	declare class ToastNotificationManager  {
		createToastNotifier(): Windows.UI.Notifications.ToastNotifier;
		createToastNotifier(applicationId: string): Windows.UI.Notifications.ToastNotifier;
		getTemplateContent(
		type: Windows.UI.Notifications.ToastTemplateType
	): Windows.Data.Xml.Dom.XmlDocument;
		history: Windows.UI.Notifications.ToastNotificationHistory
	}

	declare class ToastNotifier  {
		addToSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
		getScheduledToastNotifications(
		
	): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledToastNotification>;
		hide(notification: Windows.UI.Notifications.ToastNotification): void;
		removeFromSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
		setting: Windows.UI.Notifications.NotificationSetting;
		show(notification: Windows.UI.Notifications.ToastNotification): void
	}

	
}

declare module 'Popups' {
	declare type UICommandInvokedHandler = (command: Windows.UI.Popups.IUICommand) => void;

	declare interface IUICommand {
		id: any,
		invoked: Windows.UI.Popups.UICommandInvokedHandler,
		label: string
	}

		declare class MessageDialog  {
		constructor(content: string, title: string): this;
		constructor(content: string): this;
		cancelCommandIndex: number;
		commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
		content: string;
		defaultCommandIndex: number;
		options: Windows.UI.Popups.MessageDialogOptions;
		showAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.UI.Popups.IUICommand>;
		title: string
	}

	declare class PopupMenu  {
		constructor(): this;
		commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
		showAsync(
		invocationPoint: Windows.Foundation.Point
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.UI.Popups.IUICommand>;
		showForSelectionAsync(
		selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.UI.Popups.IUICommand>;
		showForSelectionAsync(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.UI.Popups.IUICommand>
	}

	declare class UICommand  {
		constructor(): this;
		constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler): this;
		constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler, commandId: any): this;
		constructor(label: string): this;
		id: any;
		invoked: Windows.UI.Popups.UICommandInvokedHandler;
		label: string
	}

	declare class UICommandSeparator  {
		constructor(): this;
		id: any;
		invoked: Windows.UI.Popups.UICommandInvokedHandler;
		label: string
	}

	
}

declare module 'StartScreen' {
				declare class JumpList  {
		isSupported(): boolean;
		loadCurrentAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.UI.StartScreen.JumpList>;
		items: Windows.Foundation.Collections.IVector<Windows.UI.StartScreen.JumpListItem>;
		saveAsync(): Windows.Foundation.IPromiseWithIAsyncAction;
		systemGroupKind: Windows.UI.StartScreen.JumpListSystemGroupKind
	}

	declare class JumpListItem  {
		createSeparator(): Windows.UI.StartScreen.JumpListItem;
		createWithArguments(args: string, displayName: string): Windows.UI.StartScreen.JumpListItem;
		arguments: string;
		description: string;
		displayName: string;
		groupName: string;
		kind: Windows.UI.StartScreen.JumpListItemKind;
		logo: Windows.Foundation.Uri;
		removedByUser: boolean
	}

	declare class SecondaryTile  {
		exists(tileId: string): boolean;
		findAllAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllAsync(
		applicationId: string
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		findAllForPackageAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperation<Windows.Foundation.Collections.IVectorView<any>>;
		constructor(): this;
		constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri, wideLogoReference: Windows.Foundation.Uri): this;
		constructor(tileId: string): this;
		constructor(tileId: string, shortName: string, displayName: string, args: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri): this;
		constructor(tileId: string, displayName: string, args: string, square150x150Logo: Windows.Foundation.Uri, desiredSize: Windows.UI.StartScreen.TileSize): this;
		arguments: string;
		backgroundColor: Windows.UI.Color;
		displayName: string;
		foregroundText: Windows.UI.StartScreen.ForegroundText;
		lockScreenBadgeLogo: Windows.Foundation.Uri;
		lockScreenDisplayBadgeAndTileText: boolean;
		logo: Windows.Foundation.Uri;
		onvisualelementsrequested: Windows.Foundation.TypedEventHandler<Windows.UI.StartScreen.SecondaryTile, Windows.UI.StartScreen.VisualElementsRequestedEventArgs>;
		addEventListener(
		type: "visualelementsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.StartScreen.SecondaryTile, Windows.UI.StartScreen.VisualElementsRequestedEventArgs>
	): void;
		removeEventListener(
		type: "visualelementsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.StartScreen.SecondaryTile, Windows.UI.StartScreen.VisualElementsRequestedEventArgs>
	): void;
		phoneticName: string;
		requestCreateAsync(
		invocationPoint: Windows.Foundation.Point
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestCreateAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestCreateForSelectionAsync(
		selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestCreateForSelectionAsync(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestDeleteAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestDeleteAsync(
		invocationPoint: Windows.Foundation.Point
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestDeleteForSelectionAsync(
		selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestDeleteForSelectionAsync(
		selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		roamingEnabled: boolean;
		shortName: string;
		smallLogo: Windows.Foundation.Uri;
		tileId: string;
		tileOptions: Windows.UI.StartScreen.TileOptions;
		updateAsync(): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		visualElements: Windows.UI.StartScreen.SecondaryTileVisualElements;
		wideLogo: Windows.Foundation.Uri;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class SecondaryTileVisualElements  {
		backgroundColor: Windows.UI.Color;
		foregroundText: Windows.UI.StartScreen.ForegroundText;
		showNameOnSquare150x150Logo: boolean;
		showNameOnSquare310x310Logo: boolean;
		showNameOnWide310x150Logo: boolean;
		square150x150Logo: Windows.Foundation.Uri;
		square30x30Logo: Windows.Foundation.Uri;
		square310x310Logo: Windows.Foundation.Uri;
		square44x44Logo: Windows.Foundation.Uri;
		square70x70Logo: Windows.Foundation.Uri;
		square71x71Logo: Windows.Foundation.Uri;
		wide310x150Logo: Windows.Foundation.Uri
	}

	declare class VisualElementsRequest  {
		alternateVisualElements: Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTileVisualElements>;
		deadline: Date;
		getDeferral(): Windows.UI.StartScreen.VisualElementsRequestDeferral;
		visualElements: Windows.UI.StartScreen.SecondaryTileVisualElements
	}

	declare class VisualElementsRequestDeferral  {
		complete(): void
	}

	declare class VisualElementsRequestedEventArgs  {
		request: Windows.UI.StartScreen.VisualElementsRequest
	}

	
}

declare module 'ViewManagement' {
				declare class AccessibilitySettings  {
		constructor(): this;
		highContrast: boolean;
		highContrastScheme: string;
		onhighcontrastchanged: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings, any>;
		addEventListener(
		type: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings, any>
	): void;
		removeEventListener(
		type: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings, any>
	): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ActivationViewSwitcher  {
		isViewPresentedOnActivationVirtualDesktop: any;
		showAsStandaloneAsync(
		viewId: number, sizePreference: Windows.UI.ViewManagement.ViewSizePreference
	): Windows.Foundation.IPromiseWithIAsyncAction;
		showAsStandaloneAsync(viewId: number): Windows.Foundation.IPromiseWithIAsyncAction
	}

	declare class ApplicationView  {
		getForCurrentView(): Windows.UI.ViewManagement.ApplicationView;
		preferredLaunchViewSize: Windows.Foundation.Size;
		preferredLaunchWindowingMode: Windows.UI.ViewManagement.ApplicationViewWindowingMode;
		terminateAppOnFinalViewClose: boolean;
		tryUnsnap(): boolean;
		tryUnsnapToFullscreen: any;
		value: Windows.UI.ViewManagement.ApplicationViewState;
		adjacentToLeftDisplayEdge: boolean;
		adjacentToRightDisplayEdge: boolean;
		desiredBoundsMode: Windows.UI.ViewManagement.ApplicationViewBoundsMode;
		exitFullScreenMode(): void;
		fullScreenSystemOverlayMode: Windows.UI.ViewManagement.FullScreenSystemOverlayMode;
		id: number;
		isFullScreen: boolean;
		isFullScreenMode: any;
		isOnLockScreen: boolean;
		isScreenCaptureEnabled: boolean;
		onconsolidated: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs>;
		addEventListener(
		type: "consolidated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs>
	): void;
		removeEventListener(
		type: "consolidated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs>
	): void;
		onvisibleboundschanged: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, any>;
		addEventListener(
		type: "visibleboundschanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, any>
	): void;
		removeEventListener(
		type: "visibleboundschanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.ApplicationView, any>
	): void;
		orientation: Windows.UI.ViewManagement.ApplicationViewOrientation;
		setDesiredBoundsMode(boundsMode: Windows.UI.ViewManagement.ApplicationViewBoundsMode): boolean;
		setPreferredMinSize(minSize: Windows.Foundation.Size): void;
		showStandardSystemOverlays(): void;
		suppressSystemOverlays: boolean;
		title: string;
		titleBar: Windows.UI.ViewManagement.ApplicationViewTitleBar;
		tryEnterFullScreenMode(): boolean;
		tryResizeView(value: Windows.Foundation.Size): boolean;
		visibleBounds: Windows.Foundation.Rect;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class ApplicationViewConsolidatedEventArgs  {
		isUserInitiated: boolean
	}

	declare class ApplicationViewSwitcher  {
		disableShowingMainViewOnActivation(): void;
		disableSystemViewActivationPolicy: any;
		prepareForCustomAnimatedSwitchAsync(
		toViewId: number, fromViewId: number, options: Windows.UI.ViewManagement.ApplicationViewSwitchingOptions
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		switchAsync(viewId: number): Windows.Foundation.IPromiseWithIAsyncAction;
		switchAsync(
		toViewId: number, fromViewId: number
	): Windows.Foundation.IPromiseWithIAsyncAction;
		switchAsync(
		toViewId: number, fromViewId: number, options: Windows.UI.ViewManagement.ApplicationViewSwitchingOptions
	): Windows.Foundation.IPromiseWithIAsyncAction;
		tryShowAsStandaloneAsync(
		viewId: number, sizePreference: Windows.UI.ViewManagement.ViewSizePreference, anchorViewId: number, anchorSizePreference: Windows.UI.ViewManagement.ViewSizePreference
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryShowAsStandaloneAsync(viewId: number): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		tryShowAsStandaloneAsync(
		viewId: number, sizePreference: Windows.UI.ViewManagement.ViewSizePreference
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>
	}

	declare class ApplicationViewTitleBar  {
		backgroundColor: Windows.UI.Color;
		buttonBackgroundColor: Windows.UI.Color;
		buttonForegroundColor: Windows.UI.Color;
		buttonHoverBackgroundColor: Windows.UI.Color;
		buttonHoverForegroundColor: Windows.UI.Color;
		buttonInactiveBackgroundColor: Windows.UI.Color;
		buttonInactiveForegroundColor: Windows.UI.Color;
		buttonPressedBackgroundColor: Windows.UI.Color;
		buttonPressedForegroundColor: Windows.UI.Color;
		foregroundColor: Windows.UI.Color;
		inactiveBackgroundColor: Windows.UI.Color;
		inactiveForegroundColor: Windows.UI.Color
	}

	declare class ApplicationViewTransferContext  {
		dataPackageFormatId: any;
		viewId: any
	}

	declare class InputPane  {
		getForCurrentView(): Windows.UI.ViewManagement.InputPane;
		occludedRect: Windows.Foundation.Rect;
		onhiding: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>;
		addEventListener(
		type: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>
	): void;
		removeEventListener(
		type: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>
	): void;
		onshowing: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>;
		addEventListener(
		type: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>
	): void;
		removeEventListener(
		type: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane, Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>
	): void;
		tryHide(): boolean;
		tryShow(): boolean;
		visible: boolean;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class InputPaneVisibilityEventArgs  {
		ensuredFocusedElementInView: boolean;
		occludedRect: Windows.Foundation.Rect
	}

	declare class ProjectionManager  {
		getDeviceSelector(): string;
		onprojectiondisplayavailablechanged: Windows.Foundation.EventHandler<any>;
		addEventListener(
		type: "projectiondisplayavailablechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		removeEventListener(
		type: "projectiondisplayavailablechanged", listener: Windows.Foundation.EventHandler<any>
	): void;
		projectionDisplayAvailable: boolean;
		requestStartProjectingAsync(
		projectionViewId: number, anchorViewId: number, selection: Windows.Foundation.Rect, prefferedPlacement: Windows.UI.Popups.Placement
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		requestStartProjectingAsync(
		projectionViewId: number, anchorViewId: number, selection: Windows.Foundation.Rect
	): Windows.Foundation.IPromiseWithIAsyncOperation<boolean>;
		startProjectingAsync(
		projectionViewId: number, anchorViewId: number
	): Windows.Foundation.IPromiseWithIAsyncAction;
		startProjectingAsync(
		projectionViewId: number, anchorViewId: number, displayDeviceInfo: Windows.Devices.Enumeration.DeviceInformation
	): Windows.Foundation.IPromiseWithIAsyncAction;
		stopProjectingAsync(
		projectionViewId: number, anchorViewId: number
	): Windows.Foundation.IPromiseWithIAsyncAction;
		swapDisplaysForViewsAsync(
		projectionViewId: number, anchorViewId: number
	): Windows.Foundation.IPromiseWithIAsyncAction;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class UISettings  {
		constructor(): this;
		animationsEnabled: boolean;
		caretBlinkRate: number;
		caretBrowsingEnabled: boolean;
		caretWidth: number;
		cursorSize: Windows.Foundation.Size;
		doubleClickTime: number;
		getColorValue(desiredColor: Windows.UI.ViewManagement.UIColorType): Windows.UI.Color;
		handPreference: Windows.UI.ViewManagement.HandPreference;
		messageDuration: number;
		mouseHoverTime: number;
		oncolorvalueschanged: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>;
		addEventListener(
		type: "colorvalueschanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>
	): void;
		removeEventListener(
		type: "colorvalueschanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>
	): void;
		ontextscalefactorchanged: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>;
		addEventListener(
		type: "textscalefactorchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>
	): void;
		removeEventListener(
		type: "textscalefactorchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.UISettings, any>
	): void;
		scrollBarArrowSize: Windows.Foundation.Size;
		scrollBarSize: Windows.Foundation.Size;
		scrollBarThumbBoxSize: Windows.Foundation.Size;
		textScaleFactor: number;
		uiElementColor(desiredElement: Windows.UI.ViewManagement.UIElementType): Windows.UI.Color;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class UIViewSettings  {
		getForCurrentView(): Windows.UI.ViewManagement.UIViewSettings;
		userInteractionMode: Windows.UI.ViewManagement.UserInteractionMode
	}

	
}

declare module 'WebUI' {
	declare type ActivatedEventHandler = (
		ev: Windows.ApplicationModel.Activation.IActivatedEventArgs & WinRTEvent<any>
	) => void;

	declare type NavigatedEventHandler = (ev: Windows.UI.WebUI.IWebUINavigatedEventArgs & WinRTEvent<any>) => void;

	declare type ResumingEventHandler = (ev: WinRTEvent<any>) => void;

	declare type SuspendingEventHandler = (ev: Windows.ApplicationModel.ISuspendingEventArgs & WinRTEvent<any>) => void;

	declare interface IWebUIBackgroundTaskInstance {
		succeeded: boolean
	}

	declare interface IWebUINavigatedEventArgs {
		navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation
	}

		declare class ActivatedDeferral  {
		complete(): void
	}

	declare class ActivatedOperation  {
		getDeferral(): Windows.UI.WebUI.ActivatedDeferral
	}

	declare class HtmlPrintDocumentSource  {
		bottomMargin: number;
		close(): void;
		content: Windows.UI.WebUI.PrintContent;
		enableHeaderFooter: boolean;
		leftMargin: number;
		pageRange: string;
		percentScale: number;
		rightMargin: number;
		shrinkToFit: boolean;
		topMargin: number;
		trySetPageRange(strPageRange: string): boolean
	}

	declare class SuspendingDeferral  {
		complete(): void
	}

	declare class SuspendingEventArgs  {
		suspendingOperation: Windows.ApplicationModel.SuspendingOperation
	}

	declare class SuspendingOperation  {
		deadline: Date;
		getDeferral(): Windows.ApplicationModel.SuspendingDeferral
	}

	declare class WebUIApplication  {
		onactivated: Windows.UI.WebUI.ActivatedEventHandler;
		addEventListener(type: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
		removeEventListener(type: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
		onnavigated: Windows.UI.WebUI.NavigatedEventHandler;
		addEventListener(type: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
		removeEventListener(type: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
		onresuming: Windows.UI.WebUI.ResumingEventHandler;
		addEventListener(type: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
		removeEventListener(type: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
		onsuspending: Windows.UI.WebUI.SuspendingEventHandler;
		addEventListener(type: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
		removeEventListener(type: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WebUIAppointmentsProviderAddAppointmentActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		addAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.AddAppointmentOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		removeAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.RemoveAppointmentOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		replaceAppointmentOperation: Windows.ApplicationModel.Appointments.AppointmentsProvider.ReplaceAppointmentOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		instanceStartDate: Date;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		localId: string;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		roamingId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		duration: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		timeToShow: Date;
		verb: string
	}

	declare class WebUIBackgroundTaskInstance  {
		current: Windows.UI.WebUI.IWebUIBackgroundTaskInstance
	}

	declare class WebUIBackgroundTaskInstanceRuntimeClass  {
		getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral;
		instanceId: string;
		oncanceled: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler;
		addEventListener(
		type: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler
	): void;
		removeEventListener(
		type: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler
	): void;
		progress: number;
		succeeded: boolean;
		suspendedCount: number;
		task: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
		triggerDetails: any;
		addEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void;
		removeEventListener(type: string, listener: Windows.Foundation.EventHandler<any>): void
	}

	declare class WebUICachedFileUpdaterActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUICameraSettingsActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		videoDeviceController: any;
		videoDeviceExtension: any
	}

	declare class WebUIContactCallActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIContactMapActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		address: Windows.ApplicationModel.Contacts.ContactAddress;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIContactMessageActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIContactPickerActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIContactPostActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIContactVideoCallActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		contact: Windows.ApplicationModel.Contacts.Contact;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		serviceId: string;
		serviceUserId: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIDeviceActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		currentlyShownApplicationViewId: number;
		deviceInformationId: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIDevicePairingActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		deviceInformation: Windows.Devices.Enumeration.DeviceInformation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIDialReceiverActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		appName: string;
		arguments: string;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string
	}

	declare class WebUIFileActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		currentlyShownApplicationViewId: number;
		files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		neighboringFilesQuery: Windows.Storage.Search.StorageFileQueryResult;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		verb: string
	}

	declare class WebUIFileOpenPickerActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		callerPackageFamilyName: string;
		fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIFileOpenPickerContinuationEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		continuationData: Windows.Foundation.Collections.ValueSet;
		files: Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIFileSavePickerActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		callerPackageFamilyName: string;
		enterpriseId: string;
		fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIFileSavePickerContinuationEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		continuationData: Windows.Foundation.Collections.ValueSet;
		file: Windows.Storage.StorageFile;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIFolderPickerContinuationEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		continuationData: Windows.Foundation.Collections.ValueSet;
		folder: Windows.Storage.StorageFolder;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUILaunchActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		arguments: string;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		prelaunchActivated: boolean;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string
	}

	declare class WebUILockScreenActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		currentlyShownApplicationViewId: number;
		info: any;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUILockScreenCallActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		arguments: string;
		callUI: Windows.ApplicationModel.Calls.LockScreenCallUI;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		tileId: string
	}

	declare class WebUINavigatedDeferral  {
		complete(): void
	}

	declare class WebUINavigatedEventArgs  {
		navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation
	}

	declare class WebUINavigatedOperation  {
		getDeferral(): Windows.UI.WebUI.WebUINavigatedDeferral
	}

	declare class WebUIPrint3DWorkflowActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		workflow: Windows.Devices.Printers.Extensions.Print3DWorkflow
	}

	declare class WebUIPrintTaskSettingsActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIProtocolActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		callerPackageFamilyName: string;
		currentlyShownApplicationViewId: number;
		data: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		uri: Windows.Foundation.Uri
	}

	declare class WebUIProtocolForResultsActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		callerPackageFamilyName: string;
		currentlyShownApplicationViewId: number;
		data: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		protocolForResultsOperation: Windows.System.ProtocolForResultsOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		uri: Windows.Foundation.Uri
	}

	declare class WebUIRestrictedLaunchActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		sharedContext: any;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUISearchActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		currentlyShownApplicationViewId: number;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		language: string;
		linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		queryText: string;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIShareTargetActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIToastNotificationActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		argument: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		userInput: Windows.Foundation.Collections.ValueSet
	}

	declare class WebUIVoiceCommandActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		result: Windows.Media.SpeechRecognition.SpeechRecognitionResult;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIWalletActionActivatedEventArgs  {
		actionId: string;
		actionKind: Windows.ApplicationModel.Wallet.WalletActionKind;
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		itemId: string;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIWebAccountProviderActivatedEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		operation: Windows.Security.Authentication.Web.Provider.IWebAccountProviderOperation;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen
	}

	declare class WebUIWebAuthenticationBrokerContinuationEventArgs  {
		activatedOperation: Windows.UI.WebUI.ActivatedOperation;
		continuationData: Windows.Foundation.Collections.ValueSet;
		kind: Windows.ApplicationModel.Activation.ActivationKind;
		previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
		splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
		webAuthenticationResult: Windows.Security.Authentication.Web.WebAuthenticationResult
	}

	
}

declare module 'AtomPub' {
				declare class AtomPubClient  {
		constructor(serverCredential: Windows.Security.Credentials.PasswordCredential): this;
		constructor(): this;
		bypassCacheOnRetrieve: boolean;
		cancelAsyncOperations(): void;
		createMediaResourceAsync(
		uri: Windows.Foundation.Uri, mediaType: string, description: string, mediaStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem, Windows.Web.Syndication.TransferProgress>;
		createResourceAsync(
		uri: Windows.Foundation.Uri, description: string, item: Windows.Web.Syndication.SyndicationItem
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem, Windows.Web.Syndication.TransferProgress>;
		deleteResourceAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
		deleteResourceItemAsync(
		item: Windows.Web.Syndication.SyndicationItem
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
		maxResponseBufferSize: number;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		retrieveFeedAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed, Windows.Web.Syndication.RetrievalProgress>;
		retrieveMediaResourceAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, Windows.Web.Syndication.RetrievalProgress>;
		retrieveResourceAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem, Windows.Web.Syndication.RetrievalProgress>;
		retrieveServiceDocumentAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.AtomPub.ServiceDocument, Windows.Web.Syndication.RetrievalProgress>;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		setRequestHeader(name: string, value: string): void;
		timeout: number;
		updateMediaResourceAsync(
		uri: Windows.Foundation.Uri, mediaType: string, mediaStream: Windows.Storage.Streams.IInputStream
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
		updateResourceAsync(
		uri: Windows.Foundation.Uri, item: Windows.Web.Syndication.SyndicationItem
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
		updateResourceItemAsync(
		item: Windows.Web.Syndication.SyndicationItem
	): Windows.Foundation.IPromiseWithIAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>
	}

	declare class ResourceCollection  {
		accepts: Windows.Foundation.Collections.IVectorView<string>;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		categories: Windows.Foundation.Collections.IVectorView<Windows.Web.Syndication.SyndicationCategory>;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		title: Windows.Web.Syndication.ISyndicationText;
		uri: Windows.Foundation.Uri
	}

	declare class ServiceDocument  {
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		workspaces: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.Workspace>
	}

	declare class Workspace  {
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		collections: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.ResourceCollection>;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		title: Windows.Web.Syndication.ISyndicationText
	}

	
}

declare module 'Filters' {
		declare interface IHttpFilter {
		sendRequestAsync(
		request: Windows.Web.Http.HttpRequestMessage
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>
	}

		declare class HttpBaseProtocolFilter  {
		constructor(): this;
		allowAutoRedirect: boolean;
		allowUI: boolean;
		automaticDecompression: boolean;
		cacheControl: Windows.Web.Http.Filters.HttpCacheControl;
		clientCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		close(): void;
		cookieManager: Windows.Web.Http.HttpCookieManager;
		cookieUsageBehavior: Windows.Web.Http.Filters.HttpCookieUsageBehavior;
		ignorableServerCertificateErrors: Windows.Foundation.Collections.IVector<Windows.Security.Cryptography.Certificates.ChainValidationResult>;
		maxConnectionsPerServer: number;
		maxVersion: Windows.Web.Http.HttpVersion;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		sendRequestAsync(
		request: Windows.Web.Http.HttpRequestMessage
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		useProxy: boolean
	}

	declare class HttpCacheControl  {
		readBehavior: Windows.Web.Http.Filters.HttpCacheReadBehavior;
		writeBehavior: Windows.Web.Http.Filters.HttpCacheWriteBehavior
	}

	
}

declare module 'Headers' {
				declare class HttpCacheDirectiveHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpNameValueHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpNameValueHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpNameValueHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpNameValueHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpNameValueHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpNameValueHeaderValue): number;
		insertAt(index: number, value: Windows.Web.Http.Headers.HttpNameValueHeaderValue): void;
		maxAge: number;
		maxStale: number;
		minFresh: number;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpNameValueHeaderValue): void;
		setAt(index: number, value: Windows.Web.Http.Headers.HttpNameValueHeaderValue): void;
		sharedMaxAge: number;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpNameValueHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpNameValueHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpChallengeHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpChallengeHeaderValue;
		tryParse(
		input: string
	): {
		challengeHeaderValue: Windows.Web.Http.Headers.HttpChallengeHeaderValue,
		returnValue: boolean
	};
		constructor(scheme: string, token: string): this;
		constructor(scheme: string): this;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		scheme: string;
		token: string
	}

	declare class HttpChallengeHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpChallengeHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpChallengeHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpChallengeHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpChallengeHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpChallengeHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpChallengeHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpChallengeHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpChallengeHeaderValue): number;
		insertAt(index: number, value: Windows.Web.Http.Headers.HttpChallengeHeaderValue): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpChallengeHeaderValue): void;
		setAt(index: number, value: Windows.Web.Http.Headers.HttpChallengeHeaderValue): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpChallengeHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpChallengeHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpConnectionOptionHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue;
		tryParse(
		input: string
	): {
		connectionOptionHeaderValue: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue,
		returnValue: boolean
	};
		constructor(token: string): this;
		token: string
	}

	declare class HttpConnectionOptionHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpContentCodingHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpContentCodingHeaderValue;
		tryParse(
		input: string
	): {
		contentCodingHeaderValue: Windows.Web.Http.Headers.HttpContentCodingHeaderValue,
		returnValue: boolean
	};
		constructor(contentCoding: string): this;
		contentCoding: string
	}

	declare class HttpContentCodingHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpContentCodingHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpContentCodingHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpContentCodingHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpContentCodingHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpContentCodingHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpContentCodingHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpContentCodingHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpContentCodingHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpContentCodingHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpContentCodingHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpContentCodingHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpContentCodingHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpContentCodingWithQualityHeaderValue  {
		parse(
		input: string
	): Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue;
		tryParse(
		input: string
	): {
		contentCodingWithQualityHeaderValue: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue,
		returnValue: boolean
	};
		constructor(contentCoding: string, quality: number): this;
		constructor(contentCoding: string): this;
		contentCoding: string;
		quality: number
	}

	declare class HttpContentCodingWithQualityHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>;
		getAt(
		index: number
	): Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpContentDispositionHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpContentDispositionHeaderValue;
		tryParse(
		input: string
	): {
		contentDispositionHeaderValue: Windows.Web.Http.Headers.HttpContentDispositionHeaderValue,
		returnValue: boolean
	};
		constructor(dispositionType: string): this;
		dispositionType: string;
		fileName: string;
		fileNameStar: string;
		name: string;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		size: number
	}

	declare class HttpContentHeaderCollection  {
		constructor(): this;
		append(name: string, value: string): void;
		clear(): void;
		contentDisposition: Windows.Web.Http.Headers.HttpContentDispositionHeaderValue;
		contentEncoding: Windows.Web.Http.Headers.HttpContentCodingHeaderValueCollection;
		contentLanguage: Windows.Web.Http.Headers.HttpLanguageHeaderValueCollection;
		contentLength: number;
		contentLocation: Windows.Foundation.Uri;
		contentMD5: Windows.Storage.Streams.IBuffer;
		contentRange: Windows.Web.Http.Headers.HttpContentRangeHeaderValue;
		contentType: Windows.Web.Http.Headers.HttpMediaTypeHeaderValue;
		expires: Date;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, string>;
		hasKey(key: string): boolean;
		insert(key: string, value: string): boolean;
		lastModified: Date;
		lookup(key: string): string;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number;
		tryAppendWithoutValidation(name: string, value: string): boolean
	}

	declare class HttpContentRangeHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpContentRangeHeaderValue;
		tryParse(
		input: string
	): {
		contentRangeHeaderValue: Windows.Web.Http.Headers.HttpContentRangeHeaderValue,
		returnValue: boolean
	};
		constructor(length: number): this;
		constructor(from: number, to: number): this;
		constructor(from: number, to: number, length: number): this;
		firstBytePosition: number;
		lastBytePosition: number;
		length: number;
		unit: string
	}

	declare class HttpCookiePairHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpCookiePairHeaderValue;
		tryParse(
		input: string
	): {
		cookiePairHeaderValue: Windows.Web.Http.Headers.HttpCookiePairHeaderValue,
		returnValue: boolean
	};
		constructor(name: string, value: string): this;
		constructor(name: string): this;
		name: string;
		value: string
	}

	declare class HttpCookiePairHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpCookiePairHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpCookiePairHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpCookiePairHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpCookiePairHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpCookiePairHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpCookiePairHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpCookiePairHeaderValue): number;
		insertAt(index: number, value: Windows.Web.Http.Headers.HttpCookiePairHeaderValue): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpCookiePairHeaderValue): void;
		setAt(index: number, value: Windows.Web.Http.Headers.HttpCookiePairHeaderValue): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpCookiePairHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpCookiePairHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpCredentialsHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpCredentialsHeaderValue;
		tryParse(
		input: string
	): {
		credentialsHeaderValue: Windows.Web.Http.Headers.HttpCredentialsHeaderValue,
		returnValue: boolean
	};
		constructor(scheme: string, token: string): this;
		constructor(scheme: string): this;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		scheme: string;
		token: string
	}

	declare class HttpDateOrDeltaHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue;
		tryParse(
		input: string
	): {
		dateOrDeltaHeaderValue: Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue,
		returnValue: boolean
	};
		date: Date;
		delta: number
	}

	declare class HttpExpectationHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpExpectationHeaderValue;
		tryParse(
		input: string
	): {
		expectationHeaderValue: Windows.Web.Http.Headers.HttpExpectationHeaderValue,
		returnValue: boolean
	};
		constructor(name: string, value: string): this;
		constructor(name: string): this;
		name: string;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		value: string
	}

	declare class HttpExpectationHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpExpectationHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpExpectationHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpExpectationHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpExpectationHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpExpectationHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpExpectationHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpExpectationHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpExpectationHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpExpectationHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpExpectationHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpExpectationHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpExpectationHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpExpectationHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpLanguageHeaderValueCollection extends Array<Windows.Globalization.Language> {
		append(value: Windows.Globalization.Language): void;
		clear(): void;
		first(): Windows.Foundation.Collections.IIterator<Windows.Globalization.Language>;
		getAt(index: number): Windows.Globalization.Language;
		getMany(
		startIndex: number
	): {
		items: Windows.Globalization.Language,
		returnValue: number
	};
		getView(): Windows.Foundation.Collections.IVectorView<Windows.Globalization.Language>;
		indexOf(
		value: Windows.Globalization.Language
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Globalization.Language): number;
		insertAt(index: number, value: Windows.Globalization.Language): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Globalization.Language): void;
		setAt(index: number, value: Windows.Globalization.Language): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Globalization.Language, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Globalization.Language, fromIndex?: number): number
	}

	declare class HttpLanguageRangeWithQualityHeaderValue  {
		parse(
		input: string
	): Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue;
		tryParse(
		input: string
	): {
		languageRangeWithQualityHeaderValue: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue,
		returnValue: boolean
	};
		constructor(languageRange: string, quality: number): this;
		constructor(languageRange: string): this;
		languageRange: string;
		quality: number
	}

	declare class HttpLanguageRangeWithQualityHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>;
		getAt(
		index: number
	): Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpMediaTypeHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpMediaTypeHeaderValue;
		tryParse(
		input: string
	): {
		mediaTypeHeaderValue: Windows.Web.Http.Headers.HttpMediaTypeHeaderValue,
		returnValue: boolean
	};
		constructor(mediaType: string): this;
		charSet: string;
		mediaType: string;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>
	}

	declare class HttpMediaTypeWithQualityHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue;
		tryParse(
		input: string
	): {
		mediaTypeWithQualityHeaderValue: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue,
		returnValue: boolean
	};
		constructor(mediaType: string, quality: number): this;
		constructor(mediaType: string): this;
		charSet: string;
		mediaType: string;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		quality: number
	}

	declare class HttpMediaTypeWithQualityHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue>;
		indexOf(
		value: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpMethodHeaderValueCollection extends Array<Windows.Web.Http.HttpMethod> {
		append(value: Windows.Web.Http.HttpMethod): void;
		clear(): void;
		first(): Windows.Foundation.Collections.IIterator<Windows.Web.Http.HttpMethod>;
		getAt(index: number): Windows.Web.Http.HttpMethod;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.HttpMethod,
		returnValue: number
	};
		getView(): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.HttpMethod>;
		indexOf(
		value: Windows.Web.Http.HttpMethod
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.HttpMethod): number;
		insertAt(index: number, value: Windows.Web.Http.HttpMethod): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.HttpMethod): void;
		setAt(index: number, value: Windows.Web.Http.HttpMethod): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.HttpMethod, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Web.Http.HttpMethod, fromIndex?: number): number
	}

	declare class HttpNameValueHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpNameValueHeaderValue;
		tryParse(
		input: string
	): {
		nameValueHeaderValue: Windows.Web.Http.Headers.HttpNameValueHeaderValue,
		returnValue: boolean
	};
		constructor(name: string, value: string): this;
		constructor(name: string): this;
		name: string;
		value: string
	}

	declare class HttpProductHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpProductHeaderValue;
		tryParse(
		input: string
	): {
		productHeaderValue: Windows.Web.Http.Headers.HttpProductHeaderValue,
		returnValue: boolean
	};
		constructor(productName: string, productVersion: string): this;
		constructor(productName: string): this;
		name: string;
		version: string
	}

	declare class HttpProductInfoHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpProductInfoHeaderValue;
		tryParse(
		input: string
	): {
		productInfoHeaderValue: Windows.Web.Http.Headers.HttpProductInfoHeaderValue,
		returnValue: boolean
	};
		constructor(productName: string, productVersion: string): this;
		constructor(productComment: string): this;
		comment: string;
		product: Windows.Web.Http.Headers.HttpProductHeaderValue
	}

	declare class HttpProductInfoHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpProductInfoHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpProductInfoHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpProductInfoHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpProductInfoHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpProductInfoHeaderValue>;
		indexOf(item: Windows.Web.Http.Headers.HttpProductInfoHeaderValue): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpProductInfoHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(item: Windows.Web.Http.Headers.HttpProductInfoHeaderValue): number;
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpProductInfoHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpProductInfoHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpProductInfoHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpProductInfoHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpProductInfoHeaderValue, fromIndex?: number
	): number
	}

	declare class HttpRequestHeaderCollection  {
		accept: Windows.Web.Http.Headers.HttpMediaTypeWithQualityHeaderValueCollection;
		acceptEncoding: Windows.Web.Http.Headers.HttpContentCodingWithQualityHeaderValueCollection;
		acceptLanguage: Windows.Web.Http.Headers.HttpLanguageRangeWithQualityHeaderValueCollection;
		append(name: string, value: string): void;
		authorization: Windows.Web.Http.Headers.HttpCredentialsHeaderValue;
		cacheControl: Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection;
		clear(): void;
		connection: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection;
		cookie: Windows.Web.Http.Headers.HttpCookiePairHeaderValueCollection;
		date: Date;
		expect: Windows.Web.Http.Headers.HttpExpectationHeaderValueCollection;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		from: string;
		getView(): Windows.Foundation.Collections.IMapView<string, string>;
		hasKey(key: string): boolean;
		host: Windows.Networking.HostName;
		ifModifiedSince: Date;
		ifUnmodifiedSince: Date;
		insert(key: string, value: string): boolean;
		lookup(key: string): string;
		maxForwards: number;
		proxyAuthorization: Windows.Web.Http.Headers.HttpCredentialsHeaderValue;
		referer: Windows.Foundation.Uri;
		remove(key: string): void;
		remove(key: string): boolean;
		size: number;
		transferEncoding: Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection;
		tryAppendWithoutValidation(name: string, value: string): boolean;
		userAgent: Windows.Web.Http.Headers.HttpProductInfoHeaderValueCollection
	}

	declare class HttpResponseHeaderCollection  {
		age: number;
		allow: Windows.Web.Http.Headers.HttpMethodHeaderValueCollection;
		append(name: string, value: string): void;
		cacheControl: Windows.Web.Http.Headers.HttpCacheDirectiveHeaderValueCollection;
		clear(): void;
		connection: Windows.Web.Http.Headers.HttpConnectionOptionHeaderValueCollection;
		date: Date;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any, any>>;
		getView(): Windows.Foundation.Collections.IMapView<string, string>;
		hasKey(key: string): boolean;
		insert(key: string, value: string): boolean;
		location: Windows.Foundation.Uri;
		lookup(key: string): string;
		proxyAuthenticate: Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection;
		remove(key: string): void;
		retryAfter: Windows.Web.Http.Headers.HttpDateOrDeltaHeaderValue;
		size: number;
		transferEncoding: Windows.Web.Http.Headers.HttpTransferCodingHeaderValueCollection;
		tryAppendWithoutValidation(name: string, value: string): boolean;
		wwwAuthenticate: Windows.Web.Http.Headers.HttpChallengeHeaderValueCollection
	}

	declare class HttpTransferCodingHeaderValue  {
		parse(input: string): Windows.Web.Http.Headers.HttpTransferCodingHeaderValue;
		tryParse(
		input: string
	): {
		transferCodingHeaderValue: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue,
		returnValue: boolean
	};
		constructor(input: string): this;
		parameters: Windows.Foundation.Collections.IVector<Windows.Web.Http.Headers.HttpNameValueHeaderValue>;
		value: string
	}

	declare class HttpTransferCodingHeaderValueCollection extends Array<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue> {
		append(value: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue): void;
		clear(): void;
		first(
		
	): Windows.Foundation.Collections.IIterator<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>;
		getAt(index: number): Windows.Web.Http.Headers.HttpTransferCodingHeaderValue;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue,
		returnValue: number
	};
		getView(
		
	): Windows.Foundation.Collections.IVectorView<Windows.Web.Http.Headers.HttpTransferCodingHeaderValue>;
		indexOf(item: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue): number;
		indexOf(item: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue
	): {
		index: number,
		returnValue: boolean
	};
		insertAt(
		index: number, value: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue
	): void;
		parseAdd(input: string): void;
		removeAt(index: number): void;
		removeAt(index: number): void;
		removeAtEnd(): void;
		replaceAll(items: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue): void;
		setAt(
		index: number, value: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue
	): void;
		size: number;
		tryParseAdd(input: string): boolean;
		indexOf(
		value: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(
		searchElement: Windows.Web.Http.Headers.HttpTransferCodingHeaderValue, fromIndex?: number
	): number
	}

	
}

declare module 'Http' {
		declare interface HttpProgress {
		bytesReceived: number,
		bytesSent: number,
		retries: number,
		stage: Windows.Web.Http.HttpProgressStage,
		totalBytesToReceive: number,
		totalBytesToSend: number
	}

	declare interface IHttpContent {
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>,
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>,
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>,
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>,
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	},
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>,
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection
	}

		declare class HttpBufferContent  {
		constructor(content: Windows.Storage.Streams.IBuffer): this;
		constructor(content: Windows.Storage.Streams.IBuffer, offset: number, count: number): this;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpClient  {
		constructor(): this;
		constructor(filter: Windows.Web.Http.Filters.IHttpFilter): this;
		close(): void;
		defaultRequestHeaders: Windows.Web.Http.Headers.HttpRequestHeaderCollection;
		deleteAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		getAsync(
		uri: Windows.Foundation.Uri, completionOption: Windows.Web.Http.HttpCompletionOption
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		getAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		getBufferAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, Windows.Web.Http.HttpProgress>;
		getInputStreamAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, Windows.Web.Http.HttpProgress>;
		getStringAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, Windows.Web.Http.HttpProgress>;
		postAsync(
		uri: Windows.Foundation.Uri, content: Windows.Web.Http.IHttpContent
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		putAsync(
		uri: Windows.Foundation.Uri, content: Windows.Web.Http.IHttpContent
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		sendRequestAsync(
		request: Windows.Web.Http.HttpRequestMessage, completionOption: Windows.Web.Http.HttpCompletionOption
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>;
		sendRequestAsync(
		request: Windows.Web.Http.HttpRequestMessage
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Http.HttpResponseMessage, Windows.Web.Http.HttpProgress>
	}

	declare class HttpCookie  {
		constructor(name: string, domain: string, path: string): this;
		domain: string;
		expires: Date;
		httpOnly: boolean;
		name: string;
		path: string;
		secure: boolean;
		value: string
	}

	declare class HttpCookieCollection extends Array<Windows.Web.Http.HttpCookie> {
		first(): Windows.Foundation.Collections.IIterator<Windows.Web.Http.HttpCookie>;
		getAt(index: number): Windows.Web.Http.HttpCookie;
		getMany(
		startIndex: number
	): {
		items: Windows.Web.Http.HttpCookie,
		returnValue: number
	};
		indexOf(
		value: Windows.Web.Http.HttpCookie
	): {
		index: number,
		returnValue: boolean
	};
		size: number;
		indexOf(
		value: Windows.Web.Http.HttpCookie, ...extra: any[]
	): {
		index: number,
		returnValue: boolean
	};
		indexOf(searchElement: Windows.Web.Http.HttpCookie, fromIndex?: number): number
	}

	declare class HttpCookieManager  {
		deleteCookie(cookie: Windows.Web.Http.HttpCookie): void;
		getCookies(uri: Windows.Foundation.Uri): Windows.Web.Http.HttpCookieCollection;
		setCookie(cookie: Windows.Web.Http.HttpCookie, thirdParty: boolean): boolean;
		setCookie(cookie: Windows.Web.Http.HttpCookie): boolean
	}

	declare class HttpFormUrlEncodedContent  {
		constructor(content: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any, any>>): this;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpMethod  {
		delete: Windows.Web.Http.HttpMethod;
		get: Windows.Web.Http.HttpMethod;
		head: Windows.Web.Http.HttpMethod;
		options: Windows.Web.Http.HttpMethod;
		patch: Windows.Web.Http.HttpMethod;
		post: Windows.Web.Http.HttpMethod;
		put: Windows.Web.Http.HttpMethod;
		constructor(method: string): this;
		method: string
	}

	declare class HttpMultipartContent  {
		constructor(): this;
		constructor(subtype: string, boundary: string): this;
		constructor(subtype: string): this;
		add(content: Windows.Web.Http.IHttpContent): void;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		first(): Windows.Foundation.Collections.IIterator<Windows.Web.Http.IHttpContent>;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpMultipartFormDataContent  {
		constructor(): this;
		constructor(boundary: string): this;
		add(content: Windows.Web.Http.IHttpContent, name: string, fileName: string): void;
		add(content: Windows.Web.Http.IHttpContent): void;
		add(content: Windows.Web.Http.IHttpContent, name: string): void;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		first(): Windows.Foundation.Collections.IIterator<Windows.Web.Http.IHttpContent>;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpRequestMessage  {
		constructor(): this;
		constructor(method: Windows.Web.Http.HttpMethod, uri: Windows.Foundation.Uri): this;
		close(): void;
		content: Windows.Web.Http.IHttpContent;
		headers: Windows.Web.Http.Headers.HttpRequestHeaderCollection;
		method: Windows.Web.Http.HttpMethod;
		properties: Windows.Foundation.Collections.IMap<string, any>;
		requestUri: Windows.Foundation.Uri;
		transportInformation: Windows.Web.Http.HttpTransportInformation
	}

	declare class HttpResponseMessage  {
		constructor(statusCode: Windows.Web.Http.HttpStatusCode): this;
		constructor(): this;
		close(): void;
		content: Windows.Web.Http.IHttpContent;
		ensureSuccessStatusCode(): Windows.Web.Http.HttpResponseMessage;
		headers: Windows.Web.Http.Headers.HttpResponseHeaderCollection;
		isSuccessStatusCode: boolean;
		reasonPhrase: string;
		requestMessage: Windows.Web.Http.HttpRequestMessage;
		source: Windows.Web.Http.HttpResponseMessageSource;
		statusCode: Windows.Web.Http.HttpStatusCode;
		version: Windows.Web.Http.HttpVersion
	}

	declare class HttpStreamContent  {
		constructor(content: Windows.Storage.Streams.IInputStream): this;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpStringContent  {
		constructor(content: string, encoding: Windows.Storage.Streams.UnicodeEncoding): this;
		constructor(content: string, encoding: Windows.Storage.Streams.UnicodeEncoding, mediaType: string): this;
		constructor(content: string): this;
		bufferAllAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>;
		close(): void;
		headers: Windows.Web.Http.Headers.HttpContentHeaderCollection;
		readAsBufferAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer, number>;
		readAsInputStreamAsync(
		
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream, number>;
		readAsStringAsync(): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<string, number>;
		tryComputeLength(): {
		length: number,
		returnValue: boolean
	};
		writeToStreamAsync(
		outputStream: Windows.Storage.Streams.IOutputStream
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<number, number>
	}

	declare class HttpTransportInformation  {
		serverCertificate: Windows.Security.Cryptography.Certificates.Certificate;
		serverCertificateErrorSeverity: Windows.Networking.Sockets.SocketSslErrorSeverity;
		serverCertificateErrors: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.ChainValidationResult>;
		serverIntermediateCertificates: Windows.Foundation.Collections.IVectorView<Windows.Security.Cryptography.Certificates.Certificate>
	}

	
}

declare module 'Syndication' {
		declare interface TransferProgress {
		bytesRetrieved: number,
		bytesSent: number,
		totalBytesToRetrieve: number,
		totalBytesToSend: number
	}

	declare interface RetrievalProgress {
		bytesRetrieved: number,
		totalBytesToRetrieve: number
	}

	declare interface ISyndicationNode {
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument,
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>,
		baseUri: Windows.Foundation.Uri,
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>,
		language: string,
		nodeName: string,
		nodeNamespace: string,
		nodeValue: string
	}

	declare interface ISyndicationText {
		text: string,
		type: string,
		xml: Windows.Data.Xml.Dom.XmlDocument
	}

		declare class SyndicationAttribute  {
		constructor(): this;
		constructor(attributeName: string, attributeNamespace: string, attributeValue: string): this;
		name: string;
		namespace: string;
		value: string
	}

	declare class SyndicationCategory  {
		constructor(term: string, scheme: string, label: string): this;
		constructor(): this;
		constructor(term: string): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		label: string;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		scheme: string;
		term: string
	}

	declare class SyndicationClient  {
		constructor(): this;
		constructor(serverCredential: Windows.Security.Credentials.PasswordCredential): this;
		bypassCacheOnRetrieve: boolean;
		maxResponseBufferSize: number;
		proxyCredential: Windows.Security.Credentials.PasswordCredential;
		retrieveFeedAsync(
		uri: Windows.Foundation.Uri
	): Windows.Foundation.IPromiseWithIAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed, Windows.Web.Syndication.RetrievalProgress>;
		serverCredential: Windows.Security.Credentials.PasswordCredential;
		setRequestHeader(name: string, value: string): void;
		timeout: number
	}

	declare class SyndicationContent  {
		constructor(sourceUri: Windows.Foundation.Uri): this;
		constructor(): this;
		constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		sourceUri: Windows.Foundation.Uri;
		text: string;
		type: string;
		xml: Windows.Data.Xml.Dom.XmlDocument
	}

	declare class SyndicationError  {
		getStatus(hresult: number): Windows.Web.Syndication.SyndicationErrorStatus
	}

	declare class SyndicationFeed  {
		constructor(): this;
		constructor(title: string, subtitle: string, uri: Windows.Foundation.Uri): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
		baseUri: Windows.Foundation.Uri;
		categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
		contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		firstUri: Windows.Foundation.Uri;
		generator: Windows.Web.Syndication.SyndicationGenerator;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		iconUri: Windows.Foundation.Uri;
		id: string;
		imageUri: Windows.Foundation.Uri;
		items: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationItem>;
		language: string;
		lastUpdatedTime: Date;
		lastUri: Windows.Foundation.Uri;
		links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
		load(feed: string): void;
		loadFromXml(feedDocument: Windows.Data.Xml.Dom.XmlDocument): void;
		nextUri: Windows.Foundation.Uri;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		previousUri: Windows.Foundation.Uri;
		rights: Windows.Web.Syndication.ISyndicationText;
		sourceFormat: Windows.Web.Syndication.SyndicationFormat;
		subtitle: Windows.Web.Syndication.ISyndicationText;
		title: Windows.Web.Syndication.ISyndicationText
	}

	declare class SyndicationGenerator  {
		constructor(): this;
		constructor(text: string): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		text: string;
		uri: Windows.Foundation.Uri;
		version: string
	}

	declare class SyndicationItem  {
		constructor(title: string, content: Windows.Web.Syndication.SyndicationContent, uri: Windows.Foundation.Uri): this;
		constructor(): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
		baseUri: Windows.Foundation.Uri;
		categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
		commentsUri: Windows.Foundation.Uri;
		content: Windows.Web.Syndication.SyndicationContent;
		contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
		editMediaUri: Windows.Foundation.Uri;
		editUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		etag: string;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		id: string;
		itemUri: Windows.Foundation.Uri;
		language: string;
		lastUpdatedTime: Date;
		links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
		load(item: string): void;
		loadFromXml(itemDocument: Windows.Data.Xml.Dom.XmlDocument): void;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		publishedDate: Date;
		rights: Windows.Web.Syndication.ISyndicationText;
		source: Windows.Web.Syndication.SyndicationFeed;
		summary: Windows.Web.Syndication.ISyndicationText;
		title: Windows.Web.Syndication.ISyndicationText
	}

	declare class SyndicationLink  {
		constructor(): this;
		constructor(uri: Windows.Foundation.Uri, relationship: string, title: string, mediaType: string, length: number): this;
		constructor(uri: Windows.Foundation.Uri): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		length: number;
		mediaType: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		relationship: string;
		resourceLanguage: string;
		title: string;
		uri: Windows.Foundation.Uri
	}

	declare class SyndicationNode  {
		constructor(nodeName: string, nodeNamespace: string, nodeValue: string): this;
		constructor(): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string
	}

	declare class SyndicationPerson  {
		constructor(name: string, email: string, uri: Windows.Foundation.Uri): this;
		constructor(): this;
		constructor(name: string): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		email: string;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		name: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		uri: Windows.Foundation.Uri
	}

	declare class SyndicationText  {
		constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType): this;
		constructor(): this;
		constructor(text: string): this;
		attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
		baseUri: Windows.Foundation.Uri;
		elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
		getXmlDocument(
		format: Windows.Web.Syndication.SyndicationFormat
	): Windows.Data.Xml.Dom.XmlDocument;
		language: string;
		nodeName: string;
		nodeNamespace: string;
		nodeValue: string;
		text: string;
		type: string;
		xml: Windows.Data.Xml.Dom.XmlDocument
	}

	
}